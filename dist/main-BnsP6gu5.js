var Dr = /* @__PURE__ */ ((n) => (n.docTypeError = "docTypeError", n.contextNotFound = "contextNotFound", n.timerNotFound = "timerNotFound", n.ctxCallOutOfScope = "ctxCallOutOfScope", n.createNodeInParserFail = "createNodeInParserFail", n.stackOverFlow = "stackOverFlow", n.parserMatchError = "parserMatchError", n.serializerMatchError = "serializerMatchError", n.getAtomFromSchemaFail = "getAtomFromSchemaFail", n.expectDomTypeError = "expectDomTypeError", n.callCommandBeforeEditorView = "callCommandBeforeEditorView", n.missingRootElement = "missingRootElement", n.missingNodeInSchema = "missingNodeInSchema", n.missingMarkInSchema = "missingMarkInSchema", n.ctxNotBind = "ctxNotBind", n.missingYjsDoc = "missingYjsDoc", n))(Dr || {});
class ei extends Error {
  constructor(e, t) {
    super(t), this.name = "MilkdownError", this.code = e;
  }
}
const AR = (n, e) => typeof e == "function" ? "[Function]" : e, Jm = (n) => JSON.stringify(n, AR);
function OR(n) {
  return new ei(
    Dr.docTypeError,
    `Doc type error, unsupported type: ${Jm(n)}`
  );
}
function ER(n) {
  return new ei(
    Dr.contextNotFound,
    `Context "${n}" not found, do you forget to inject it?`
  );
}
function IR(n) {
  return new ei(
    Dr.timerNotFound,
    `Timer "${n}" not found, do you forget to record it?`
  );
}
function Xm() {
  return new ei(
    Dr.ctxCallOutOfScope,
    "Should not call a context out of the plugin."
  );
}
function DR(n, e, t) {
  const i = `Cannot create node for ${"name" in n ? n.name : n}`, s = (u) => {
    if (u == null) return "null";
    if (Array.isArray(u))
      return `[${u.map(s).join(", ")}]`;
    if (typeof u == "object")
      return "toJSON" in u && typeof u.toJSON == "function" ? JSON.stringify(u.toJSON()) : "spec" in u ? JSON.stringify(u.spec) : JSON.stringify(u);
    if (typeof u == "string" || typeof u == "number" || typeof u == "boolean")
      return JSON.stringify(u);
    if (typeof u == "function")
      return `[Function: ${u.name || "anonymous"}]`;
    try {
      return String(u);
    } catch {
      return "[Unserializable]";
    }
  }, o = ["[Description]", i], l = ["[Attributes]", e], a = [
    "[Content]",
    (t ?? []).map((u) => u ? typeof u == "object" && "type" in u ? `${u}` : s(u) : "null")
  ], c = [o, l, a].reduce(
    (u, [h, f]) => {
      const d = `${h}: ${s(f)}.`;
      return u.concat(d);
    },
    []
  );
  return new ei(
    Dr.createNodeInParserFail,
    c.join(`
`)
  );
}
function rS() {
  return new ei(
    Dr.stackOverFlow,
    "Stack over flow, cannot pop on an empty stack."
  );
}
function NR(n) {
  return new ei(
    Dr.parserMatchError,
    `Cannot match target parser for node: ${Jm(n)}.`
  );
}
function RR(n) {
  return new ei(
    Dr.serializerMatchError,
    `Cannot match target serializer for node: ${Jm(n)}.`
  );
}
function PR(n, e) {
  return new ei(
    Dr.getAtomFromSchemaFail,
    `Cannot get ${n}: ${e} from schema.`
  );
}
function Vi(n) {
  return new ei(
    Dr.expectDomTypeError,
    `Expect to be a dom, but get: ${Jm(n)}.`
  );
}
function Sg() {
  return new ei(
    Dr.callCommandBeforeEditorView,
    "You're trying to call a command before editor view initialized, make sure to get commandManager from ctx after editor view has been initialized"
  );
}
function _R(n) {
  return new ei(
    Dr.missingNodeInSchema,
    `Missing node in schema, milkdown cannot find "${n}" in schema.`
  );
}
function LR(n) {
  return new ei(
    Dr.missingMarkInSchema,
    `Missing mark in schema, milkdown cannot find "${n}" in schema.`
  );
}
class iS {
  constructor() {
    this.sliceMap = /* @__PURE__ */ new Map(), this.get = (e) => {
      const t = typeof e == "string" ? [...this.sliceMap.values()].find((r) => r.type.name === e) : this.sliceMap.get(e.id);
      if (!t) {
        const r = typeof e == "string" ? e : e.name;
        throw ER(r);
      }
      return t;
    }, this.remove = (e) => {
      const t = typeof e == "string" ? [...this.sliceMap.values()].find((r) => r.type.name === e) : this.sliceMap.get(e.id);
      t && this.sliceMap.delete(t.type.id);
    }, this.has = (e) => typeof e == "string" ? [...this.sliceMap.values()].some((t) => t.type.name === e) : this.sliceMap.has(e.id);
  }
}
let BR = class {
  /// @internal
  constructor(e, t, r) {
    this.#t = [], this.#r = () => {
      this.#t.forEach((i) => i(this.#e));
    }, this.set = (i) => {
      this.#e = i, this.#r();
    }, this.get = () => this.#e, this.update = (i) => {
      this.#e = i(this.#e), this.#r();
    }, this.type = r, this.#e = t, e.set(r.id, this);
  }
  #t;
  /// @internal
  #e;
  #r;
  /// Add a watcher for changes in the slice.
  /// Returns a function to remove the watcher.
  on(e) {
    return this.#t.push(e), () => {
      this.#t = this.#t.filter((t) => t !== e);
    };
  }
  /// Add a one-time watcher for changes in the slice.
  /// The watcher will be removed after it is called.
  /// Returns a function to remove the watcher.
  once(e) {
    const t = this.on((r) => {
      e(r), t();
    });
    return t;
  }
  /// Remove a watcher.
  off(e) {
    this.#t = this.#t.filter((t) => t !== e);
  }
  /// Remove all watchers.
  offAll() {
    this.#t = [];
  }
};
class zR {
  /// Create a slice type with a default value and a name.
  /// The name should be unique in the container.
  constructor(e, t) {
    this.id = Symbol(`Context-${t}`), this.name = t, this._defaultValue = e, this._typeInfo = () => {
      throw Xm();
    };
  }
  /// Create a slice with a container.
  /// You can also pass a value to override the default value.
  create(e, t = this._defaultValue) {
    return new BR(e, t, this);
  }
}
const at = (n, e) => new zR(n, e);
class FR {
  /// Create an inspector with container, clock and metadata.
  constructor(e, t, r) {
    this.#n = /* @__PURE__ */ new Set(), this.#a = /* @__PURE__ */ new Set(), this.#i = /* @__PURE__ */ new Map(), this.#s = /* @__PURE__ */ new Map(), this.read = () => ({
      metadata: this.#t,
      injectedSlices: [...this.#n].map((i) => ({
        name: typeof i == "string" ? i : i.name,
        value: this.#o(i)
      })),
      consumedSlices: [...this.#a].map((i) => ({
        name: typeof i == "string" ? i : i.name,
        value: this.#o(i)
      })),
      recordedTimers: [...this.#i].map(
        ([i, { duration: s }]) => ({
          name: i.name,
          duration: s,
          status: this.#l(i)
        })
      ),
      waitTimers: [...this.#s].map(([i, { duration: s }]) => ({
        name: i.name,
        duration: s,
        status: this.#l(i)
      }))
    }), this.onRecord = (i) => {
      this.#i.set(i, { start: Date.now(), duration: 0 });
    }, this.onClear = (i) => {
      this.#i.delete(i);
    }, this.onDone = (i) => {
      const s = this.#i.get(i);
      s && (s.duration = Date.now() - s.start);
    }, this.onWait = (i, s) => {
      const o = Date.now();
      s.finally(() => {
        this.#s.set(i, { duration: Date.now() - o });
      }).catch(console.error);
    }, this.onInject = (i) => {
      this.#n.add(i);
    }, this.onRemove = (i) => {
      this.#n.delete(i);
    }, this.onUse = (i) => {
      this.#a.add(i);
    }, this.#o = (i) => this.#e.get(i).get(), this.#l = (i) => this.#r.get(i).status, this.#e = e, this.#r = t, this.#t = r;
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  #n;
  #a;
  #i;
  #s;
  #o;
  #l;
}
class U5 {
  /// Create a ctx object with container and clock.
  constructor(e, t, r) {
    this.produce = (i) => i && Object.keys(i).length ? new U5(this.#t, this.#e, { ...i }) : this, this.inject = (i, s) => {
      const o = i.create(this.#t.sliceMap);
      return s != null && o.set(s), this.#n?.onInject(i), this;
    }, this.remove = (i) => (this.#t.remove(i), this.#n?.onRemove(i), this), this.record = (i) => (i.create(this.#e.store), this.#n?.onRecord(i), this), this.clearTimer = (i) => (this.#e.remove(i), this.#n?.onClear(i), this), this.isInjected = (i) => this.#t.has(i), this.isRecorded = (i) => this.#e.has(i), this.use = (i) => (this.#n?.onUse(i), this.#t.get(i)), this.get = (i) => this.use(i).get(), this.set = (i, s) => this.use(i).set(s), this.update = (i, s) => this.use(i).update(s), this.timer = (i) => this.#e.get(i), this.done = (i) => {
      this.timer(i).done(), this.#n?.onDone(i);
    }, this.wait = (i) => {
      const s = this.timer(i).start();
      return this.#n?.onWait(i, s), s;
    }, this.waitTimers = async (i) => {
      await Promise.all(this.get(i).map((s) => this.wait(s)));
    }, this.#t = e, this.#e = t, this.#r = r, r && (this.#n = new FR(e, t, r));
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  /// @internal
  #n;
  /// Get metadata of the ctx.
  get meta() {
    return this.#r;
  }
  /// Get the inspector of the ctx.
  get inspector() {
    return this.#n;
  }
}
class HR {
  constructor() {
    this.store = /* @__PURE__ */ new Map(), this.get = (e) => {
      const t = this.store.get(e.id);
      if (!t) throw IR(e.name);
      return t;
    }, this.remove = (e) => {
      this.store.delete(e.id);
    }, this.has = (e) => this.store.has(e.id);
  }
}
class $R {
  /// @internal
  constructor(e, t) {
    this.#t = null, this.#e = null, this.#n = "pending", this.start = () => (this.#t ??= new Promise((r, i) => {
      this.#e = (s) => {
        s instanceof CustomEvent && s.detail.id === this.#r && (this.#n = "resolved", this.#a(), s.stopImmediatePropagation(), r());
      }, this.#i(() => {
        this.#n === "pending" && (this.#n = "rejected"), this.#a(), i(new Error(`Timing ${this.type.name} timeout.`));
      }), this.#n = "pending", addEventListener(this.type.name, this.#e);
    }), this.#t), this.done = () => {
      const r = new CustomEvent(this.type.name, {
        detail: { id: this.#r }
      });
      dispatchEvent(r);
    }, this.#a = () => {
      this.#e && removeEventListener(this.type.name, this.#e);
    }, this.#i = (r) => {
      setTimeout(() => {
        r();
      }, this.type.timeout);
    }, this.#r = Symbol(t.name), this.type = t, e.set(t.id, this);
  }
  #t;
  #e;
  /// @internal
  #r;
  #n;
  /// The status of the timer.
  /// Can be `pending`, `resolved` or `rejected`.
  get status() {
    return this.#n;
  }
  #a;
  #i;
}
class VR {
  /// Create a timer type with a name and a timeout.
  /// The name should be unique in the clock.
  constructor(e, t = 3e3) {
    this.create = (r) => new $R(r, this), this.id = Symbol(`Timer-${e}`), this.name = e, this.timeout = t;
  }
}
const bo = (n, e = 3e3) => new VR(n, e);
function Nn(n) {
  this.content = n;
}
Nn.prototype = {
  constructor: Nn,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(n, e, t) {
    var r = t && t != n ? this.remove(t) : this, i = r.find(n), s = r.content.slice();
    return i == -1 ? s.push(t || n, e) : (s[i + 1] = e, t && (s[i] = t)), new Nn(s);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(n) {
    var e = this.find(n);
    if (e == -1) return this;
    var t = this.content.slice();
    return t.splice(e, 2), new Nn(t);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(n, e) {
    return new Nn([n, e].concat(this.remove(n).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new Nn(t);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(n, e, t) {
    var r = this.remove(e), i = r.content.slice(), s = r.find(n);
    return i.splice(s == -1 ? i.length : s, 0, e, t), new Nn(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(n) {
    return n = Nn.from(n), n.size ? new Nn(n.content.concat(this.subtract(n).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(n) {
    return n = Nn.from(n), n.size ? new Nn(this.subtract(n).content.concat(n.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(n) {
    var e = this;
    n = Nn.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Nn.from = function(n) {
  if (n instanceof Nn) return n;
  var e = [];
  if (n) for (var t in n) e.push(t, n[t]);
  return new Nn(e);
};
function sS(n, e, t) {
  for (let r = 0; ; r++) {
    if (r == n.childCount || r == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let i = n.child(r), s = e.child(r);
    if (i == s) {
      t += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return t;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        t++;
      return t;
    }
    if (i.content.size || s.content.size) {
      let o = sS(i.content, s.content, t + 1);
      if (o != null)
        return o;
    }
    t += i.nodeSize;
  }
}
function oS(n, e, t, r) {
  for (let i = n.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: t, b: r };
    let o = n.child(--i), l = e.child(--s), a = o.nodeSize;
    if (o == l) {
      t -= a, r -= a;
      continue;
    }
    if (!o.sameMarkup(l))
      return { a: t, b: r };
    if (o.isText && o.text != l.text) {
      let c = 0, u = Math.min(o.text.length, l.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == l.text[l.text.length - c - 1]; )
        c++, t--, r--;
      return { a: t, b: r };
    }
    if (o.content.size || l.content.size) {
      let c = oS(o.content, l.content, t - 1, r - 1);
      if (c)
        return c;
    }
    t -= a, r -= a;
  }
}
let ce = class rr {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, r, i = 0, s) {
    for (let o = 0, l = 0; l < t; o++) {
      let a = this.content[o], c = l + a.nodeSize;
      if (c > e && r(a, i + l, s || null, o) !== !1 && a.content.size) {
        let u = l + 1;
        a.nodesBetween(Math.max(0, e - u), Math.min(a.content.size, t - u), r, i + u);
      }
      l = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, t, (l, a) => {
      let c = l.isText ? l.text.slice(Math.max(e, a) - a, t - a) : l.isLeaf ? i ? typeof i == "function" ? i(l) : i : l.type.spec.leafText ? l.type.spec.leafText(l) : "" : "";
      l.isBlock && (l.isLeaf && c || l.isTextblock) && r && (o ? o = !1 : s += r), s += c;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new rr(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let r = [], i = 0;
    if (t > e)
      for (let s = 0, o = 0; o < t; s++) {
        let l = this.content[s], a = o + l.nodeSize;
        a > e && ((o < e || a > t) && (l.isText ? l = l.cut(Math.max(0, e - o), Math.min(l.text.length, t - o)) : l = l.cut(Math.max(0, e - o - 1), Math.min(l.content.size, t - o - 1))), r.push(l), i += l.nodeSize), o = a;
      }
    return new rr(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? rr.empty : e == 0 && t == this.content.length ? this : new rr(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let r = this.content[e];
    if (r == t)
      return this;
    let i = this.content.slice(), s = this.size + t.nodeSize - r.nodeSize;
    return i[e] = t, new rr(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new rr([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new rr(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, r = 0; t < this.content.length; t++) {
      let i = this.content[t];
      e(i, r, t), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return sS(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, r = e.size) {
    return oS(this, e, t, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return jd(0, e);
    if (e == this.size)
      return jd(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let t = 0, r = 0; ; t++) {
      let i = this.child(t), s = r + i.nodeSize;
      if (s >= e)
        return s == e ? jd(t + 1, s) : jd(t, r);
      r = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return rr.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new rr(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return rr.empty;
    let t, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (t || (t = e.slice(0, i)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
    }
    return new rr(t || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return rr.empty;
    if (e instanceof rr)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new rr([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
ce.empty = new ce([], 0);
const Cg = { index: 0, offset: 0 };
function jd(n, e) {
  return Cg.index = n, Cg.offset = e, Cg;
}
function Yp(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let r = 0; r < n.length; r++)
      if (!Yp(n[r], e[r]))
        return !1;
  } else {
    for (let r in n)
      if (!(r in e) || !Yp(n[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in n))
        return !1;
  }
  return !0;
}
class nt {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        t || (t = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !r && s.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(s);
      }
    }
    return t || (t = e.slice()), r || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && Yp(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[t.type];
    if (!r)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    let i = r.create(t.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(t[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return nt.none;
    if (e instanceof nt)
      return [e];
    let t = e.slice();
    return t.sort((r, i) => r.type.rank - i.type.rank), t;
  }
}
nt.none = [];
class Jp extends Error {
}
class me {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, r) {
    this.content = e, this.openStart = t, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let r = aS(this.content, e + this.openStart, t);
    return r && new me(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new me(lS(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return me.empty;
    let r = t.openStart || 0, i = t.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new me(ce.fromJSON(e, t.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new me(e, r, i);
  }
}
me.empty = new me(ce.empty, 0, 0);
function lS(n, e, t) {
  let { index: r, offset: i } = n.findIndex(e), s = n.maybeChild(r), { index: o, offset: l } = n.findIndex(t);
  if (i == e || s.isText) {
    if (l != t && !n.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(r, s.copy(lS(s.content, e - i - 1, t - i - 1)));
}
function aS(n, e, t, r) {
  let { index: i, offset: s } = n.findIndex(e), o = n.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, t) ? null : n.cut(0, e).append(t).append(n.cut(e));
  let l = aS(o.content, e - s - 1, t, o);
  return l && n.replaceChild(i, o.copy(l));
}
function qR(n, e, t) {
  if (t.openStart > n.depth)
    throw new Jp("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new Jp("Inconsistent open depths");
  return cS(n, e, t, 0);
}
function cS(n, e, t, r) {
  let i = n.index(r), s = n.node(r);
  if (i == e.index(r) && r < n.depth - t.openStart) {
    let o = cS(n, e, t, r + 1);
    return s.copy(s.content.replaceChild(i, o));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) {
      let o = n.parent, l = o.content;
      return oa(o, l.cut(0, n.parentOffset).append(t.content).append(l.cut(e.parentOffset)));
    } else {
      let { start: o, end: l } = WR(t, n);
      return oa(s, hS(n, o, l, e, r));
    }
  else return oa(s, Xp(n, e, r));
}
function uS(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new Jp("Cannot join " + e.type.name + " onto " + n.type.name);
}
function w4(n, e, t) {
  let r = n.node(t);
  return uS(r, e.node(t)), r;
}
function sa(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function Lh(n, e, t, r) {
  let i = (e || n).node(t), s = 0, o = e ? e.index(t) : i.childCount;
  n && (s = n.index(t), n.depth > t ? s++ : n.textOffset && (sa(n.nodeAfter, r), s++));
  for (let l = s; l < o; l++)
    sa(i.child(l), r);
  e && e.depth == t && e.textOffset && sa(e.nodeBefore, r);
}
function oa(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function hS(n, e, t, r, i) {
  let s = n.depth > i && w4(n, e, i + 1), o = r.depth > i && w4(t, r, i + 1), l = [];
  return Lh(null, n, i, l), s && o && e.index(i) == t.index(i) ? (uS(s, o), sa(oa(s, hS(n, e, t, r, i + 1)), l)) : (s && sa(oa(s, Xp(n, e, i + 1)), l), Lh(e, t, i, l), o && sa(oa(o, Xp(t, r, i + 1)), l)), Lh(r, null, i, l), new ce(l);
}
function Xp(n, e, t) {
  let r = [];
  if (Lh(null, n, t, r), n.depth > t) {
    let i = w4(n, e, t + 1);
    sa(oa(i, Xp(n, e, t + 1)), r);
  }
  return Lh(e, null, t, r), new ce(r);
}
function WR(n, e) {
  let t = e.depth - n.openStart, i = e.node(t).copy(n.content);
  for (let s = t - 1; s >= 0; s--)
    i = e.node(s).copy(ce.from(i));
  return {
    start: i.resolveNoCache(n.openStart + t),
    end: i.resolveNoCache(i.content.size - n.openEnd - t)
  };
}
class yf {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(t);
    return r ? e.child(t).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += r.child(s).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return nt.none;
    if (this.textOffset)
      return e.child(t).marks;
    let r = e.maybeChild(t - 1), i = e.maybeChild(t);
    if (!r) {
      let l = r;
      r = i, i = l;
    }
    let s = r.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let r = t.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!t || t(this.node(r))))
        return new fS(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let r = [], i = 0, s = t;
    for (let o = e; ; ) {
      let { index: l, offset: a } = o.content.findIndex(s), c = s - a;
      if (r.push(o, l, i + a), !c || (o = o.child(l), o.isText))
        break;
      s = c - 1, i += a + 1;
    }
    return new yf(t, r, s);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    let r = W7.get(e);
    if (r)
      for (let s = 0; s < r.elts.length; s++) {
        let o = r.elts[s];
        if (o.pos == t)
          return o;
      }
    else
      W7.set(e, r = new jR());
    let i = r.elts[r.i] = yf.resolve(e, t);
    return r.i = (r.i + 1) % UR, i;
  }
}
class jR {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const UR = 12, W7 = /* @__PURE__ */ new WeakMap();
class fS {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const KR = /* @__PURE__ */ Object.create(null);
let eo = class x4 {
  /**
  @internal
  */
  constructor(e, t, r, i = nt.none) {
    this.type = e, this.attrs = t, this.marks = i, this.content = r || ce.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, r, i = 0) {
    this.content.nodesBetween(e, t, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, t, r, i) {
    return this.content.textBetween(e, t, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, r) {
    return this.type == e && Yp(this.attrs, t || e.defaultAttrs || KR) && nt.sameSet(this.marks, r || nt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new x4(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new x4(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, r = !1) {
    if (e == t)
      return me.empty;
    let i = this.resolve(e), s = this.resolve(t), o = r ? 0 : i.sharedDepth(t), l = i.start(o), c = i.node(o).content.cut(i.pos - l, s.pos - l);
    return new me(c, i.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, r) {
    return qR(this.resolve(e), this.resolve(t), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: r, offset: i } = t.content.findIndex(e);
      if (t = t.maybeChild(r), !t)
        return null;
      if (i == e || t.isText)
        return t;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(t), index: t, offset: r };
    let i = this.content.child(t - 1);
    return { node: i, index: t - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return yf.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return yf.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, r) {
    let i = !1;
    return t > e && this.nodesBetween(e, t, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), dS(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, r = ce.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s), l = o && o.matchFragment(this.content, t);
    if (!l || !l.validEnd)
      return !1;
    for (let a = i; a < s; a++)
      if (!this.type.allowsMarks(r.child(a).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, t);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = nt.none;
    for (let t = 0; t < this.marks.length; t++) {
      let r = this.marks[t];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!nt.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, r);
    }
    let i = ce.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, i, r);
    return s.type.checkAttrs(s.attrs), s;
  }
};
eo.prototype.text = void 0;
let GR = class k4 extends eo {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    if (super(e, t, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : dS(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new k4(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new k4(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
};
function dS(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class ya {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let r = new YR(e, t);
    if (r.next == null)
      return ya.empty;
    let i = pS(r);
    r.next && r.err("Unexpected trailing text");
    let s = nP(tP(i));
    return rP(s, r), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, r = e.childCount) {
    let i = this;
    for (let s = t; i && s < r; s++)
      i = i.matchType(e.child(s).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[t].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, r = 0) {
    let i = [this];
    function s(o, l) {
      let a = o.matchFragment(e, r);
      if (a && (!t || a.validEnd))
        return ce.from(l.map((c) => c.createAndFill()));
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: h } = o.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h);
          let f = s(h, l.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), s = i.match;
      if (s.matchType(e)) {
        let o = [];
        for (let l = i; l.type; l = l.via)
          o.push(l.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: l, next: a } = s.next[o];
        !l.isLeaf && !l.hasRequiredAttrs() && !(l.name in t) && (!i.type || a.validEnd) && (r.push({ match: l.contentMatch, type: l, via: i }), t[l.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && t(r.next[i].next);
    }
    return t(this), e.map((r, i) => {
      let s = i + (r.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < r.next.length; o++)
        s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
      return s;
    }).join(`
`);
  }
}
ya.empty = new ya(!0);
class YR {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function pS(n) {
  let e = [];
  do
    e.push(JR(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function JR(n) {
  let e = [];
  do
    e.push(XR(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function XR(n) {
  let e = eP(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = ZR(n, e);
    else
      break;
  return e;
}
function j7(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function ZR(n, e) {
  let t = j7(n), r = t;
  return n.eat(",") && (n.next != "}" ? r = j7(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e };
}
function QR(n, e) {
  let t = n.nodeTypes, r = t[e];
  if (r)
    return [r];
  let i = [];
  for (let s in t) {
    let o = t[s];
    o.isInGroup(e) && i.push(o);
  }
  return i.length == 0 && n.err("No node type or group '" + e + "' found"), i;
}
function eP(n) {
  if (n.eat("(")) {
    let e = pS(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = QR(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function tP(n) {
  let e = [[]];
  return i(s(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function r(o, l, a) {
    let c = { term: a, to: l };
    return e[o].push(c), c;
  }
  function i(o, l) {
    o.forEach((a) => a.to = l);
  }
  function s(o, l) {
    if (o.type == "choice")
      return o.exprs.reduce((a, c) => a.concat(s(c, l)), []);
    if (o.type == "seq")
      for (let a = 0; ; a++) {
        let c = s(o.exprs[a], l);
        if (a == o.exprs.length - 1)
          return c;
        i(c, l = t());
      }
    else if (o.type == "star") {
      let a = t();
      return r(l, a), i(s(o.expr, a), a), [r(a)];
    } else if (o.type == "plus") {
      let a = t();
      return i(s(o.expr, l), a), i(s(o.expr, a), a), [r(a)];
    } else {
      if (o.type == "opt")
        return [r(l)].concat(s(o.expr, l));
      if (o.type == "range") {
        let a = l;
        for (let c = 0; c < o.min; c++) {
          let u = t();
          i(s(o.expr, a), u), a = u;
        }
        if (o.max == -1)
          i(s(o.expr, a), a);
        else
          for (let c = o.min; c < o.max; c++) {
            let u = t();
            r(a, u), i(s(o.expr, a), u), a = u;
          }
        return [r(a)];
      } else {
        if (o.type == "name")
          return [r(l, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function mS(n, e) {
  return e - n;
}
function U7(n, e) {
  let t = [];
  return r(e), t.sort(mS);
  function r(i) {
    let s = n[i];
    if (s.length == 1 && !s[0].term)
      return r(s[0].to);
    t.push(i);
    for (let o = 0; o < s.length; o++) {
      let { term: l, to: a } = s[o];
      !l && t.indexOf(a) == -1 && r(a);
    }
  }
}
function nP(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(U7(n, 0));
  function t(r) {
    let i = [];
    r.forEach((o) => {
      n[o].forEach(({ term: l, to: a }) => {
        if (!l)
          return;
        let c;
        for (let u = 0; u < i.length; u++)
          i[u][0] == l && (c = i[u][1]);
        U7(n, a).forEach((u) => {
          c || i.push([l, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let s = e[r.join(",")] = new ya(r.indexOf(n.length - 1) > -1);
    for (let o = 0; o < i.length; o++) {
      let l = i[o][1].sort(mS);
      s.next.push({ type: i[o][0], next: e[l.join(",")] || t(l) });
    }
    return s;
  }
}
function rP(n, e) {
  for (let t = 0, r = [n]; t < r.length; t++) {
    let i = r[t], s = !i.validEnd, o = [];
    for (let l = 0; l < i.next.length; l++) {
      let { type: a, next: c } = i.next[l];
      o.push(a.name), s && !(a.isText || a.hasRequiredAttrs()) && (s = !1), r.indexOf(c) == -1 && r.push(c);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function gS(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    if (!r.hasDefault)
      return null;
    e[t] = r.default;
  }
  return e;
}
function yS(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in n) {
    let i = e && e[r];
    if (i === void 0) {
      let s = n[r];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    t[r] = i;
  }
  return t;
}
function bS(n, e, t, r) {
  for (let i in e)
    if (!(i in n))
      throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`);
  for (let i in n) {
    let s = n[i];
    s.validate && s.validate(e[i]);
  }
}
function vS(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      t[r] = new sP(n, r, e[r]);
  return t;
}
let Zp = class wS {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = vS(e, r.attrs), this.defaultAttrs = gS(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ya.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : yS(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new eo(this, this.computeAttrs(e), ce.from(t), nt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, r) {
    return t = ce.from(t), this.checkContent(t), new eo(this, this.computeAttrs(e), t, nt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, r) {
    if (e = this.computeAttrs(e), t = ce.from(t), t.size) {
      let o = this.contentMatch.fillBefore(t);
      if (!o)
        return null;
      t = o.append(t);
    }
    let i = this.contentMatch.matchFragment(t), s = i && i.fillBefore(ce.empty, !0);
    return s ? new eo(this, e, t.append(s), nt.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    bS(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
    return t ? t.length ? t : nt.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => r[s] = new wS(s, t, o));
    let i = t.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function iP(n, e, t) {
  let r = t.split("|");
  return (i) => {
    let s = i === null ? "null" : typeof i;
    if (r.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n}, got ${s}`);
  };
}
class sP {
  constructor(e, t, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? iP(e, t, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Zm {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = vS(e, i.attrs), this.excluded = null;
    let s = gS(this.attrs);
    this.instance = s ? new nt(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new nt(this, yS(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, o) => r[s] = new Zm(s, i++, t, o)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    bS(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class xS {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let i in e)
      t[i] = e[i];
    t.nodes = Nn.from(e.nodes), t.marks = Nn.from(e.marks || {}), this.nodes = Zp.compile(this.spec.nodes, this), this.marks = Zm.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let s = this.nodes[i], o = s.spec.content || "", l = s.spec.marks;
      if (s.contentMatch = r[o] || (r[o] = ya.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!s.isInline || !s.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = s;
      }
      s.markSet = l == "_" ? null : l ? K7(this, l.split(" ")) : l == "" || !s.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let s = this.marks[i], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : K7(this, o.split(" "));
    }
    this.nodeFromJSON = (i) => eo.fromJSON(this, i), this.markFromJSON = (i) => nt.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof Zp) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let r = this.nodes.text;
    return new GR(r, r.defaultAttrs, e, nt.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function K7(n, e) {
  let t = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], s = n.marks[i], o = s;
    if (s)
      t.push(s);
    else
      for (let l in n.marks) {
        let a = n.marks[l];
        (i == "_" || a.spec.group && a.spec.group.split(" ").indexOf(i) > -1) && t.push(o = a);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return t;
}
function oP(n) {
  return n.tag != null;
}
function lP(n) {
  return n.style != null;
}
class ll {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    t.forEach((i) => {
      if (oP(i))
        this.tags.push(i);
      else if (lP(i)) {
        let s = /[^=]*/.exec(i.style)[0];
        r.indexOf(s) < 0 && r.push(s), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let s = e.nodes[i.node];
      return s.contentMatch.matchType(s);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let r = new Y7(this, t, !1);
    return r.addAll(e, nt.none, t.from, t.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let r = new Y7(this, t, !0);
    return r.addAll(e, nt.none, t.from, t.to), me.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (uP(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], l = o.style;
      if (!(l.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      l.length > e.length && (l.charCodeAt(e.length) != 61 || l.slice(e.length + 1) != t))) {
        if (o.getAttrs) {
          let a = o.getAttrs(t);
          if (a === !1)
            continue;
          o.attrs = a || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function r(i) {
      let s = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < t.length; o++) {
        let l = t[o];
        if ((l.priority == null ? 50 : l.priority) < s)
          break;
      }
      t.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = J7(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = J7(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new ll(e, ll.schemaRules(e)));
  }
}
const kS = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, aP = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, SS = { ol: !0, ul: !0 }, bf = 1, S4 = 2, Bh = 4;
function G7(n, e, t) {
  return e != null ? (e ? bf : 0) | (e === "full" ? S4 : 0) : n && n.whitespace == "pre" ? bf | S4 : t & ~Bh;
}
class Ud {
  constructor(e, t, r, i, s, o) {
    this.type = e, this.attrs = t, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = nt.none, this.match = s || (o & Bh ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore(ce.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & bf)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let t = ce.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore(ce.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !kS.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
let Y7 = class {
  constructor(e, t, r) {
    this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = t.topNode, s, o = G7(null, t.preserveWhitespace, 0) | (r ? Bh : 0);
    i ? s = new Ud(i.type, i.attrs, nt.none, !0, t.topMatch || i.type.contentMatch, o) : r ? s = new Ud(null, null, nt.none, !0, null, o) : s = new Ud(e.schema.topNodeType, null, nt.none, !0, null, o), this.nodes = [s], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, t) {
    e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
  }
  addTextNode(e, t) {
    let r = e.nodeValue, i = this.top, s = i.options & S4 ? "full" : this.localPreserveWS || (i.options & bf) > 0;
    if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (s)
        s !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let o = i.content[i.content.length - 1], l = e.previousSibling;
        (!o || l && l.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), t, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t, r) {
    let i = this.localPreserveWS, s = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let o = e.nodeName.toLowerCase(), l;
    SS.hasOwnProperty(o) && this.parser.normalizeLists && cP(e);
    let a = this.options.ruleFromNode && this.options.ruleFromNode(e) || (l = this.parser.matchTag(e, this, r));
    e: if (a ? a.ignore : aP.hasOwnProperty(o))
      this.findInside(e), this.ignoreFallback(e, t);
    else if (!a || a.skip || a.closeParent) {
      a && a.closeParent ? this.open = Math.max(0, this.open - 1) : a && a.skip.nodeType && (e = a.skip);
      let c, u = this.needsBlock;
      if (kS.hasOwnProperty(o))
        s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), c = !0, s.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, t);
        break e;
      }
      let h = a && a.skip ? t : this.readStyles(e, t);
      h && this.addAll(e, h), c && this.sync(s), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, t);
      c && this.addElementByRule(e, a, c, a.consuming === !1 ? l : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
  }
  // Called for ignored nodes
  ignoreFallback(e, t) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, t) {
    let r = e.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let s = this.parser.matchedStyles[i], o = r.getPropertyValue(s);
        if (o)
          for (let l = void 0; ; ) {
            let a = this.parser.matchStyle(s, o, this, l);
            if (!a)
              break;
            if (a.ignore)
              return null;
            if (a.clearMark ? t = t.filter((c) => !a.clearMark(c)) : t = t.concat(this.parser.schema.marks[a.mark].create(a.attrs)), a.consuming === !1)
              l = a;
            else
              break;
          }
      }
    return t;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, r, i) {
    let s, o;
    if (t.node)
      if (o = this.parser.schema.nodes[t.node], o.isLeaf)
        this.insertNode(o.create(t.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let a = this.enter(o, t.attrs || null, r, t.preserveWhitespace);
        a && (s = !0, r = a);
      }
    else {
      let a = this.parser.schema.marks[t.mark];
      r = r.concat(a.create(t.attrs));
    }
    let l = this.top;
    if (o && o.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, r, i);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((a) => this.insertNode(a, r, !1));
    else {
      let a = e;
      typeof t.contentElement == "string" ? a = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? a = t.contentElement(e) : t.contentElement && (a = t.contentElement), this.findAround(e, a, !0), this.addAll(a, r), this.findAround(e, a, !1);
    }
    s && this.sync(l) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, r, i) {
    let s = r || 0;
    for (let o = r ? e.childNodes[r] : e.firstChild, l = i == null ? null : e.childNodes[i]; o != l; o = o.nextSibling, ++s)
      this.findAtPoint(e, s), this.addDOM(o, t);
    this.findAtPoint(e, s);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, t, r) {
    let i, s;
    for (let o = this.open, l = 0; o >= 0; o--) {
      let a = this.nodes[o], c = a.findWrapping(e);
      if (c && (!i || i.length > c.length + l) && (i = c, s = a, !c.length))
        break;
      if (a.solid) {
        if (r)
          break;
        l += 2;
      }
    }
    if (!i)
      return null;
    this.sync(s);
    for (let o = 0; o < i.length; o++)
      t = this.enterInner(i[o], null, t, !1);
    return t;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, t, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let s = this.textblockFromContext();
      s && (t = this.enterInner(s, null, t));
    }
    let i = this.findPlace(e, t, r);
    if (i) {
      this.closeExtra();
      let s = this.top;
      s.match && (s.match = s.match.matchType(e.type));
      let o = nt.none;
      for (let l of i.concat(e.marks))
        (s.type ? s.type.allowsMarkType(l.type) : X7(l.type, e.type)) && (o = l.addToSet(o));
      return s.content.push(e.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, r, i) {
    let s = this.findPlace(e.create(t), r, !1);
    return s && (s = this.enterInner(e, t, r, !0, i)), s;
  }
  // Open a node of the given type
  enterInner(e, t, r, i = !1, s) {
    this.closeExtra();
    let o = this.top;
    o.match = o.match && o.match.matchType(e);
    let l = G7(e, s, o.options);
    o.options & Bh && o.content.length == 0 && (l |= Bh);
    let a = nt.none;
    return r = r.filter((c) => (o.type ? o.type.allowsMarkType(c.type) : X7(c.type, e)) ? (a = c.addToSet(a), !1) : !0), this.nodes.push(new Ud(e, t, a, i, null, l)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--) {
      if (this.nodes[t] == e)
        return this.open = t, !0;
      this.localPreserveWS && (this.nodes[t].options |= bf);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let r = this.nodes[t].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, r) {
    if (e != t && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (l, a) => {
      for (; l >= 0; l--) {
        let c = t[l];
        if (c == "") {
          if (l == t.length - 1 || l == 0)
            continue;
          for (; a >= s; a--)
            if (o(l - 1, a))
              return !0;
          return !1;
        } else {
          let u = a > 0 || a == 0 && i ? this.nodes[a].type : r && a >= s ? r.node(a - s).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          a--;
        }
      }
      return !0;
    };
    return o(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let t in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[t];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
};
function cP(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && SS.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
  }
}
function uP(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function J7(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function X7(n, e) {
  let t = e.schema.nodes;
  for (let r in t) {
    let i = t[r];
    if (!i.allowsMarkType(n))
      continue;
    let s = [], o = (l) => {
      s.push(l);
      for (let a = 0; a < l.edgeCount; a++) {
        let { type: c, next: u } = l.edge(a);
        if (c == e || s.indexOf(u) < 0 && o(u))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
class wl {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, r) {
    r || (r = Mg(t).createDocumentFragment());
    let i = r, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let l = 0, a = 0;
        for (; l < s.length && a < o.marks.length; ) {
          let c = o.marks[a];
          if (!this.marks[c.type.name]) {
            a++;
            continue;
          }
          if (!c.eq(s[l][0]) || c.type.spec.spanning === !1)
            break;
          l++, a++;
        }
        for (; l < s.length; )
          i = s.pop()[1];
        for (; a < o.marks.length; ) {
          let c = o.marks[a++], u = this.serializeMark(c, o.isInline, t);
          u && (s.push([c, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, t));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: r, contentDOM: i } = q0(Mg(t), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let r = this.serializeNodeInner(e, t);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, t);
      s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, t, r = {}) {
    let i = this.marks[e.type.name];
    return i && q0(Mg(r), i(e, t), null, e.attrs);
  }
  static renderSpec(e, t, r = null, i) {
    return q0(e, t, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new wl(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = Z7(e.nodes);
    return t.text || (t.text = (r) => r.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Z7(e.marks);
  }
}
function Z7(n) {
  let e = {};
  for (let t in n) {
    let r = n[t].spec.toDOM;
    r && (e[t] = r);
  }
  return e;
}
function Mg(n) {
  return n.document || window.document;
}
const Q7 = /* @__PURE__ */ new WeakMap();
function hP(n) {
  let e = Q7.get(n);
  return e === void 0 && Q7.set(n, e = fP(n)), e;
}
function fP(n) {
  let e = null;
  function t(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let i = 0; i < r.length; i++)
            t(r[i]);
      else
        for (let i in r)
          t(r[i]);
  }
  return t(n), e;
}
function q0(n, e, t, r) {
  if (typeof e == "string")
    return { dom: n.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], s;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (s = hP(r)) && s.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let o = i.indexOf(" ");
  o > 0 && (t = i.slice(0, o), i = i.slice(o + 1));
  let l, a = t ? n.createElementNS(t, i) : n.createElement(i), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let h in c)
      if (c[h] != null) {
        let f = h.indexOf(" ");
        f > 0 ? a.setAttributeNS(h.slice(0, f), h.slice(f + 1), c[h]) : h == "style" && a.style ? a.style.cssText = c[h] : a.setAttribute(h, c[h]);
      }
  }
  for (let h = u; h < e.length; h++) {
    let f = e[h];
    if (f === 0) {
      if (h < e.length - 1 || h > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: a, contentDOM: a };
    } else {
      let { dom: d, contentDOM: p } = q0(n, f, t, r);
      if (a.appendChild(d), p) {
        if (l)
          throw new RangeError("Multiple content holes");
        l = p;
      }
    }
  }
  return { dom: a, contentDOM: l };
}
const dP = {};
function K5(n, e) {
  const t = dP, r = typeof t.includeImageAlt == "boolean" ? t.includeImageAlt : !0, i = typeof t.includeHtml == "boolean" ? t.includeHtml : !0;
  return CS(n, r, i);
}
function CS(n, e, t) {
  if (pP(n)) {
    if ("value" in n)
      return n.type === "html" && !t ? "" : n.value;
    if (e && "alt" in n && n.alt)
      return n.alt;
    if ("children" in n)
      return e6(n.children, e, t);
  }
  return Array.isArray(n) ? e6(n, e, t) : "";
}
function e6(n, e, t) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; )
    r[i] = CS(n[i], e, t);
  return r.join("");
}
function pP(n) {
  return !!(n && typeof n == "object");
}
const t6 = document.createElement("i");
function G5(n) {
  const e = "&" + n + ";";
  t6.innerHTML = e;
  const t = t6.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    t.charCodeAt(t.length - 1) === 59 && n !== "semi" || t === e ? !1 : t
  );
}
function Xr(n, e, t, r) {
  const i = n.length;
  let s = 0, o;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, t = t > 0 ? t : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(e, t), n.splice(...o);
  else
    for (t && n.splice(e, t); s < r.length; )
      o = r.slice(s, s + 1e4), o.unshift(e, 0), n.splice(...o), s += 1e4, e += 1e4;
}
function si(n, e) {
  return n.length > 0 ? (Xr(n, n.length, 0, e), n) : e;
}
const n6 = {}.hasOwnProperty;
function MS(n) {
  const e = {};
  let t = -1;
  for (; ++t < n.length; )
    mP(e, n[t]);
  return e;
}
function mP(n, e) {
  let t;
  for (t in e) {
    const i = (n6.call(n, t) ? n[t] : void 0) || (n[t] = {}), s = e[t];
    let o;
    if (s)
      for (o in s) {
        n6.call(i, o) || (i[o] = []);
        const l = s[o];
        gP(
          // @ts-expect-error Looks like a list.
          i[o],
          Array.isArray(l) ? l : l ? [l] : []
        );
      }
  }
}
function gP(n, e) {
  let t = -1;
  const r = [];
  for (; ++t < e.length; )
    (e[t].add === "after" ? n : r).push(e[t]);
  Xr(n, 0, 0, r);
}
function TS(n, e) {
  const t = Number.parseInt(n, e);
  return (
    // C0 except for HT, LF, FF, CR, space.
    t < 9 || t === 11 || t > 13 && t < 32 || // Control character (DEL) of C0, and C1 controls.
    t > 126 && t < 160 || // Lone high surrogates and low surrogates.
    t > 55295 && t < 57344 || // Noncharacters.
    t > 64975 && t < 65008 || /* eslint-disable no-bitwise */
    (t & 65535) === 65535 || (t & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    t > 1114111 ? "�" : String.fromCodePoint(t)
  );
}
function Ni(n) {
  return n.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const lr = xl(/[A-Za-z]/), Tr = xl(/[\dA-Za-z]/), yP = xl(/[#-'*+\--9=?A-Z^-~]/);
function Qp(n) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    n !== null && (n < 32 || n === 127)
  );
}
const C4 = xl(/\d/), bP = xl(/[\dA-Fa-f]/), vP = xl(/[!-/:-@[-`{-~]/);
function Ne(n) {
  return n !== null && n < -2;
}
function Nt(n) {
  return n !== null && (n < 0 || n === 32);
}
function lt(n) {
  return n === -2 || n === -1 || n === 32;
}
const Qm = xl(new RegExp("\\p{P}|\\p{S}", "u")), ba = xl(/\s/);
function xl(n) {
  return e;
  function e(t) {
    return t !== null && t > -1 && n.test(String.fromCharCode(t));
  }
}
function it(n, e, t, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return o;
  function o(a) {
    return lt(a) ? (n.enter(t), l(a)) : e(a);
  }
  function l(a) {
    return lt(a) && s++ < i ? (n.consume(a), l) : (n.exit(t), e(a));
  }
}
const wP = {
  tokenize: xP
};
function xP(n) {
  const e = n.attempt(this.parser.constructs.contentInitial, r, i);
  let t;
  return e;
  function r(l) {
    if (l === null) {
      n.consume(l);
      return;
    }
    return n.enter("lineEnding"), n.consume(l), n.exit("lineEnding"), it(n, e, "linePrefix");
  }
  function i(l) {
    return n.enter("paragraph"), s(l);
  }
  function s(l) {
    const a = n.enter("chunkText", {
      contentType: "text",
      previous: t
    });
    return t && (t.next = a), t = a, o(l);
  }
  function o(l) {
    if (l === null) {
      n.exit("chunkText"), n.exit("paragraph"), n.consume(l);
      return;
    }
    return Ne(l) ? (n.consume(l), n.exit("chunkText"), s) : (n.consume(l), o);
  }
}
const kP = {
  tokenize: SP
}, r6 = {
  tokenize: CP
};
function SP(n) {
  const e = this, t = [];
  let r = 0, i, s, o;
  return l;
  function l(k) {
    if (r < t.length) {
      const C = t[r];
      return e.containerState = C[1], n.attempt(C[0].continuation, a, c)(k);
    }
    return c(k);
  }
  function a(k) {
    if (r++, e.containerState._closeFlow) {
      e.containerState._closeFlow = void 0, i && w();
      const C = e.events.length;
      let M = C, T;
      for (; M--; )
        if (e.events[M][0] === "exit" && e.events[M][1].type === "chunkFlow") {
          T = e.events[M][1].end;
          break;
        }
      b(r);
      let N = C;
      for (; N < e.events.length; )
        e.events[N][1].end = {
          ...T
        }, N++;
      return Xr(e.events, M + 1, 0, e.events.slice(C)), e.events.length = N, c(k);
    }
    return l(k);
  }
  function c(k) {
    if (r === t.length) {
      if (!i)
        return f(k);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return p(k);
      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return e.containerState = {}, n.check(r6, u, h)(k);
  }
  function u(k) {
    return i && w(), b(r), f(k);
  }
  function h(k) {
    return e.parser.lazy[e.now().line] = r !== t.length, o = e.now().offset, p(k);
  }
  function f(k) {
    return e.containerState = {}, n.attempt(r6, d, p)(k);
  }
  function d(k) {
    return r++, t.push([e.currentConstruct, e.containerState]), f(k);
  }
  function p(k) {
    if (k === null) {
      i && w(), b(0), n.consume(k);
      return;
    }
    return i = i || e.parser.flow(e.now()), n.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: s
    }), m(k);
  }
  function m(k) {
    if (k === null) {
      g(n.exit("chunkFlow"), !0), b(0), n.consume(k);
      return;
    }
    return Ne(k) ? (n.consume(k), g(n.exit("chunkFlow")), r = 0, e.interrupt = void 0, l) : (n.consume(k), m);
  }
  function g(k, C) {
    const M = e.sliceStream(k);
    if (C && M.push(null), k.previous = s, s && (s.next = k), s = k, i.defineSkip(k.start), i.write(M), e.parser.lazy[k.start.line]) {
      let T = i.events.length;
      for (; T--; )
        if (
          // The token starts before the line ending…
          i.events[T][1].start.offset < o && // …and either is not ended yet…
          (!i.events[T][1].end || // …or ends after it.
          i.events[T][1].end.offset > o)
        )
          return;
      const N = e.events.length;
      let B = N, $, R;
      for (; B--; )
        if (e.events[B][0] === "exit" && e.events[B][1].type === "chunkFlow") {
          if ($) {
            R = e.events[B][1].end;
            break;
          }
          $ = !0;
        }
      for (b(r), T = N; T < e.events.length; )
        e.events[T][1].end = {
          ...R
        }, T++;
      Xr(e.events, B + 1, 0, e.events.slice(N)), e.events.length = T;
    }
  }
  function b(k) {
    let C = t.length;
    for (; C-- > k; ) {
      const M = t[C];
      e.containerState = M[1], M[0].exit.call(e, n);
    }
    t.length = k;
  }
  function w() {
    i.write([null]), s = void 0, i = void 0, e.containerState._closeFlow = void 0;
  }
}
function CP(n, e, t) {
  return it(n, n.attempt(this.parser.constructs.document, e, t), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function Ic(n) {
  if (n === null || Nt(n) || ba(n))
    return 1;
  if (Qm(n))
    return 2;
}
function e1(n, e, t) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; ) {
    const s = n[i].resolveAll;
    s && !r.includes(s) && (e = s(e, t), r.push(s));
  }
  return e;
}
const M4 = {
  name: "attention",
  resolveAll: MP,
  tokenize: TP
};
function MP(n, e) {
  let t = -1, r, i, s, o, l, a, c, u;
  for (; ++t < n.length; )
    if (n[t][0] === "enter" && n[t][1].type === "attentionSequence" && n[t][1]._close) {
      for (r = t; r--; )
        if (n[r][0] === "exit" && n[r][1].type === "attentionSequence" && n[r][1]._open && // If the markers are the same:
        e.sliceSerialize(n[r][1]).charCodeAt(0) === e.sliceSerialize(n[t][1]).charCodeAt(0)) {
          if ((n[r][1]._close || n[t][1]._open) && (n[t][1].end.offset - n[t][1].start.offset) % 3 && !((n[r][1].end.offset - n[r][1].start.offset + n[t][1].end.offset - n[t][1].start.offset) % 3))
            continue;
          a = n[r][1].end.offset - n[r][1].start.offset > 1 && n[t][1].end.offset - n[t][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...n[r][1].end
          }, f = {
            ...n[t][1].start
          };
          i6(h, -a), i6(f, a), o = {
            type: a > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...n[r][1].end
            }
          }, l = {
            type: a > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...n[t][1].start
            },
            end: f
          }, s = {
            type: a > 1 ? "strongText" : "emphasisText",
            start: {
              ...n[r][1].end
            },
            end: {
              ...n[t][1].start
            }
          }, i = {
            type: a > 1 ? "strong" : "emphasis",
            start: {
              ...o.start
            },
            end: {
              ...l.end
            }
          }, n[r][1].end = {
            ...o.start
          }, n[t][1].start = {
            ...l.end
          }, c = [], n[r][1].end.offset - n[r][1].start.offset && (c = si(c, [["enter", n[r][1], e], ["exit", n[r][1], e]])), c = si(c, [["enter", i, e], ["enter", o, e], ["exit", o, e], ["enter", s, e]]), c = si(c, e1(e.parser.constructs.insideSpan.null, n.slice(r + 1, t), e)), c = si(c, [["exit", s, e], ["enter", l, e], ["exit", l, e], ["exit", i, e]]), n[t][1].end.offset - n[t][1].start.offset ? (u = 2, c = si(c, [["enter", n[t][1], e], ["exit", n[t][1], e]])) : u = 0, Xr(n, r - 1, t - r + 3, c), t = r + c.length - u - 2;
          break;
        }
    }
  for (t = -1; ++t < n.length; )
    n[t][1].type === "attentionSequence" && (n[t][1].type = "data");
  return n;
}
function TP(n, e) {
  const t = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Ic(r);
  let s;
  return o;
  function o(a) {
    return s = a, n.enter("attentionSequence"), l(a);
  }
  function l(a) {
    if (a === s)
      return n.consume(a), l;
    const c = n.exit("attentionSequence"), u = Ic(a), h = !u || u === 2 && i || t.includes(a), f = !i || i === 2 && u || t.includes(r);
    return c._open = !!(s === 42 ? h : h && (i || !f)), c._close = !!(s === 42 ? f : f && (u || !h)), e(a);
  }
}
function i6(n, e) {
  n.column += e, n.offset += e, n._bufferIndex += e;
}
const AP = {
  name: "autolink",
  tokenize: OP
};
function OP(n, e, t) {
  let r = 0;
  return i;
  function i(d) {
    return n.enter("autolink"), n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.enter("autolinkProtocol"), s;
  }
  function s(d) {
    return lr(d) ? (n.consume(d), o) : d === 64 ? t(d) : c(d);
  }
  function o(d) {
    return d === 43 || d === 45 || d === 46 || Tr(d) ? (r = 1, l(d)) : c(d);
  }
  function l(d) {
    return d === 58 ? (n.consume(d), r = 0, a) : (d === 43 || d === 45 || d === 46 || Tr(d)) && r++ < 32 ? (n.consume(d), l) : (r = 0, c(d));
  }
  function a(d) {
    return d === 62 ? (n.exit("autolinkProtocol"), n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.exit("autolink"), e) : d === null || d === 32 || d === 60 || Qp(d) ? t(d) : (n.consume(d), a);
  }
  function c(d) {
    return d === 64 ? (n.consume(d), u) : yP(d) ? (n.consume(d), c) : t(d);
  }
  function u(d) {
    return Tr(d) ? h(d) : t(d);
  }
  function h(d) {
    return d === 46 ? (n.consume(d), r = 0, u) : d === 62 ? (n.exit("autolinkProtocol").type = "autolinkEmail", n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.exit("autolink"), e) : f(d);
  }
  function f(d) {
    if ((d === 45 || Tr(d)) && r++ < 63) {
      const p = d === 45 ? f : h;
      return n.consume(d), p;
    }
    return t(d);
  }
}
const sd = {
  partial: !0,
  tokenize: EP
};
function EP(n, e, t) {
  return r;
  function r(s) {
    return lt(s) ? it(n, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || Ne(s) ? e(s) : t(s);
  }
}
const AS = {
  continuation: {
    tokenize: DP
  },
  exit: NP,
  name: "blockQuote",
  tokenize: IP
};
function IP(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const l = r.containerState;
      return l.open || (n.enter("blockQuote", {
        _container: !0
      }), l.open = !0), n.enter("blockQuotePrefix"), n.enter("blockQuoteMarker"), n.consume(o), n.exit("blockQuoteMarker"), s;
    }
    return t(o);
  }
  function s(o) {
    return lt(o) ? (n.enter("blockQuotePrefixWhitespace"), n.consume(o), n.exit("blockQuotePrefixWhitespace"), n.exit("blockQuotePrefix"), e) : (n.exit("blockQuotePrefix"), e(o));
  }
}
function DP(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return lt(o) ? it(n, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : s(o);
  }
  function s(o) {
    return n.attempt(AS, e, t)(o);
  }
}
function NP(n) {
  n.exit("blockQuote");
}
const OS = {
  name: "characterEscape",
  tokenize: RP
};
function RP(n, e, t) {
  return r;
  function r(s) {
    return n.enter("characterEscape"), n.enter("escapeMarker"), n.consume(s), n.exit("escapeMarker"), i;
  }
  function i(s) {
    return vP(s) ? (n.enter("characterEscapeValue"), n.consume(s), n.exit("characterEscapeValue"), n.exit("characterEscape"), e) : t(s);
  }
}
const ES = {
  name: "characterReference",
  tokenize: PP
};
function PP(n, e, t) {
  const r = this;
  let i = 0, s, o;
  return l;
  function l(h) {
    return n.enter("characterReference"), n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), a;
  }
  function a(h) {
    return h === 35 ? (n.enter("characterReferenceMarkerNumeric"), n.consume(h), n.exit("characterReferenceMarkerNumeric"), c) : (n.enter("characterReferenceValue"), s = 31, o = Tr, u(h));
  }
  function c(h) {
    return h === 88 || h === 120 ? (n.enter("characterReferenceMarkerHexadecimal"), n.consume(h), n.exit("characterReferenceMarkerHexadecimal"), n.enter("characterReferenceValue"), s = 6, o = bP, u) : (n.enter("characterReferenceValue"), s = 7, o = C4, u(h));
  }
  function u(h) {
    if (h === 59 && i) {
      const f = n.exit("characterReferenceValue");
      return o === Tr && !G5(r.sliceSerialize(f)) ? t(h) : (n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), n.exit("characterReference"), e);
    }
    return o(h) && i++ < s ? (n.consume(h), u) : t(h);
  }
}
const s6 = {
  partial: !0,
  tokenize: LP
}, o6 = {
  concrete: !0,
  name: "codeFenced",
  tokenize: _P
};
function _P(n, e, t) {
  const r = this, i = {
    partial: !0,
    tokenize: M
  };
  let s = 0, o = 0, l;
  return a;
  function a(T) {
    return c(T);
  }
  function c(T) {
    const N = r.events[r.events.length - 1];
    return s = N && N[1].type === "linePrefix" ? N[2].sliceSerialize(N[1], !0).length : 0, l = T, n.enter("codeFenced"), n.enter("codeFencedFence"), n.enter("codeFencedFenceSequence"), u(T);
  }
  function u(T) {
    return T === l ? (o++, n.consume(T), u) : o < 3 ? t(T) : (n.exit("codeFencedFenceSequence"), lt(T) ? it(n, h, "whitespace")(T) : h(T));
  }
  function h(T) {
    return T === null || Ne(T) ? (n.exit("codeFencedFence"), r.interrupt ? e(T) : n.check(s6, m, C)(T)) : (n.enter("codeFencedFenceInfo"), n.enter("chunkString", {
      contentType: "string"
    }), f(T));
  }
  function f(T) {
    return T === null || Ne(T) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), h(T)) : lt(T) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), it(n, d, "whitespace")(T)) : T === 96 && T === l ? t(T) : (n.consume(T), f);
  }
  function d(T) {
    return T === null || Ne(T) ? h(T) : (n.enter("codeFencedFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), p(T));
  }
  function p(T) {
    return T === null || Ne(T) ? (n.exit("chunkString"), n.exit("codeFencedFenceMeta"), h(T)) : T === 96 && T === l ? t(T) : (n.consume(T), p);
  }
  function m(T) {
    return n.attempt(i, C, g)(T);
  }
  function g(T) {
    return n.enter("lineEnding"), n.consume(T), n.exit("lineEnding"), b;
  }
  function b(T) {
    return s > 0 && lt(T) ? it(n, w, "linePrefix", s + 1)(T) : w(T);
  }
  function w(T) {
    return T === null || Ne(T) ? n.check(s6, m, C)(T) : (n.enter("codeFlowValue"), k(T));
  }
  function k(T) {
    return T === null || Ne(T) ? (n.exit("codeFlowValue"), w(T)) : (n.consume(T), k);
  }
  function C(T) {
    return n.exit("codeFenced"), e(T);
  }
  function M(T, N, B) {
    let $ = 0;
    return R;
    function R(he) {
      return T.enter("lineEnding"), T.consume(he), T.exit("lineEnding"), V;
    }
    function V(he) {
      return T.enter("codeFencedFence"), lt(he) ? it(T, z, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(he) : z(he);
    }
    function z(he) {
      return he === l ? (T.enter("codeFencedFenceSequence"), ue(he)) : B(he);
    }
    function ue(he) {
      return he === l ? ($++, T.consume(he), ue) : $ >= o ? (T.exit("codeFencedFenceSequence"), lt(he) ? it(T, ie, "whitespace")(he) : ie(he)) : B(he);
    }
    function ie(he) {
      return he === null || Ne(he) ? (T.exit("codeFencedFence"), N(he)) : B(he);
    }
  }
}
function LP(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? t(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
const Tg = {
  name: "codeIndented",
  tokenize: zP
}, BP = {
  partial: !0,
  tokenize: FP
};
function zP(n, e, t) {
  const r = this;
  return i;
  function i(c) {
    return n.enter("codeIndented"), it(n, s, "linePrefix", 5)(c);
  }
  function s(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : t(c);
  }
  function o(c) {
    return c === null ? a(c) : Ne(c) ? n.attempt(BP, o, a)(c) : (n.enter("codeFlowValue"), l(c));
  }
  function l(c) {
    return c === null || Ne(c) ? (n.exit("codeFlowValue"), o(c)) : (n.consume(c), l);
  }
  function a(c) {
    return n.exit("codeIndented"), e(c);
  }
}
function FP(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? t(o) : Ne(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), i) : it(n, s, "linePrefix", 5)(o);
  }
  function s(o) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? e(o) : Ne(o) ? i(o) : t(o);
  }
}
const HP = {
  name: "codeText",
  previous: VP,
  resolve: $P,
  tokenize: qP
};
function $P(n) {
  let e = n.length - 4, t = 3, r, i;
  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {
    for (r = t; ++r < e; )
      if (n[r][1].type === "codeTextData") {
        n[t][1].type = "codeTextPadding", n[e][1].type = "codeTextPadding", t += 2, e -= 2;
        break;
      }
  }
  for (r = t - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "codeTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function VP(n) {
  return n !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function qP(n, e, t) {
  let r = 0, i, s;
  return o;
  function o(h) {
    return n.enter("codeText"), n.enter("codeTextSequence"), l(h);
  }
  function l(h) {
    return h === 96 ? (n.consume(h), r++, l) : (n.exit("codeTextSequence"), a(h));
  }
  function a(h) {
    return h === null ? t(h) : h === 32 ? (n.enter("space"), n.consume(h), n.exit("space"), a) : h === 96 ? (s = n.enter("codeTextSequence"), i = 0, u(h)) : Ne(h) ? (n.enter("lineEnding"), n.consume(h), n.exit("lineEnding"), a) : (n.enter("codeTextData"), c(h));
  }
  function c(h) {
    return h === null || h === 32 || h === 96 || Ne(h) ? (n.exit("codeTextData"), a(h)) : (n.consume(h), c);
  }
  function u(h) {
    return h === 96 ? (n.consume(h), i++, u) : i === r ? (n.exit("codeTextSequence"), n.exit("codeText"), e(h)) : (s.type = "codeTextData", c(h));
  }
}
class WP {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(e) {
    this.left = e ? [...e] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(e) {
    if (e < 0 || e >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(e, t) {
    const r = t ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(e, r) : e > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(e, t, r) {
    const i = t || 0;
    this.setCursor(Math.trunc(e));
    const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && Nu(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(e) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(e) {
    this.setCursor(Number.POSITIVE_INFINITY), Nu(this.left, e);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(e) {
    this.setCursor(0), this.right.push(e);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(e) {
    this.setCursor(0), Nu(this.right, e.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(e) {
    if (!(e === this.left.length || e > this.left.length && this.right.length === 0 || e < 0 && this.left.length === 0))
      if (e < this.left.length) {
        const t = this.left.splice(e, Number.POSITIVE_INFINITY);
        Nu(this.right, t.reverse());
      } else {
        const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
        Nu(this.left, t.reverse());
      }
  }
}
function Nu(n, e) {
  let t = 0;
  if (e.length < 1e4)
    n.push(...e);
  else
    for (; t < e.length; )
      n.push(...e.slice(t, t + 1e4)), t += 1e4;
}
function IS(n) {
  const e = {};
  let t = -1, r, i, s, o, l, a, c;
  const u = new WP(n);
  for (; ++t < u.length; ) {
    for (; t in e; )
      t = e[t];
    if (r = u.get(t), t && r[1].type === "chunkFlow" && u.get(t - 1)[1].type === "listItemPrefix" && (a = r[1]._tokenizer.events, s = 0, s < a.length && a[s][1].type === "lineEndingBlank" && (s += 2), s < a.length && a[s][1].type === "content"))
      for (; ++s < a.length && a[s][1].type !== "content"; )
        a[s][1].type === "chunkText" && (a[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(e, jP(u, t)), t = e[t], c = !0);
    else if (r[1]._container) {
      for (s = t, i = void 0; s--; )
        if (o = u.get(s), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank")
          o[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = s);
        else if (!(o[1].type === "linePrefix" || o[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...u.get(i)[1].start
      }, l = u.slice(i, t), l.unshift(r), u.splice(i, t - i + 1, l));
    }
  }
  return Xr(n, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function jP(n, e) {
  const t = n.get(e)[1], r = n.get(e)[2];
  let i = e - 1;
  const s = [];
  let o = t._tokenizer;
  o || (o = r.parser[t.contentType](t.start), t._contentTypeTextTrailing && (o._contentTypeTextTrailing = !0));
  const l = o.events, a = [], c = {};
  let u, h, f = -1, d = t, p = 0, m = 0;
  const g = [m];
  for (; d; ) {
    for (; n.get(++i)[1] !== d; )
      ;
    s.push(i), d._tokenizer || (u = r.sliceStream(d), d.next || u.push(null), h && o.defineSkip(d.start), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = d, d = d.next;
  }
  for (d = t; ++f < l.length; )
    // Find a void token that includes a break.
    l[f][0] === "exit" && l[f - 1][0] === "enter" && l[f][1].type === l[f - 1][1].type && l[f][1].start.line !== l[f][1].end.line && (m = f + 1, g.push(m), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (o.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : g.pop(), f = g.length; f--; ) {
    const b = l.slice(g[f], g[f + 1]), w = s.pop();
    a.push([w, w + b.length - 1]), n.splice(w, 2, b);
  }
  for (a.reverse(), f = -1; ++f < a.length; )
    c[p + a[f][0]] = p + a[f][1], p += a[f][1] - a[f][0] - 1;
  return c;
}
const UP = {
  resolve: GP,
  tokenize: YP
}, KP = {
  partial: !0,
  tokenize: JP
};
function GP(n) {
  return IS(n), n;
}
function YP(n, e) {
  let t;
  return r;
  function r(l) {
    return n.enter("content"), t = n.enter("chunkContent", {
      contentType: "content"
    }), i(l);
  }
  function i(l) {
    return l === null ? s(l) : Ne(l) ? n.check(KP, o, s)(l) : (n.consume(l), i);
  }
  function s(l) {
    return n.exit("chunkContent"), n.exit("content"), e(l);
  }
  function o(l) {
    return n.consume(l), n.exit("chunkContent"), t.next = n.enter("chunkContent", {
      contentType: "content",
      previous: t
    }), t = t.next, i;
  }
}
function JP(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return n.exit("chunkContent"), n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), it(n, s, "linePrefix");
  }
  function s(o) {
    if (o === null || Ne(o))
      return t(o);
    const l = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? e(o) : n.interrupt(r.parser.constructs.flow, t, e)(o);
  }
}
function DS(n, e, t, r, i, s, o, l, a) {
  const c = a || Number.POSITIVE_INFINITY;
  let u = 0;
  return h;
  function h(b) {
    return b === 60 ? (n.enter(r), n.enter(i), n.enter(s), n.consume(b), n.exit(s), f) : b === null || b === 32 || b === 41 || Qp(b) ? t(b) : (n.enter(r), n.enter(o), n.enter(l), n.enter("chunkString", {
      contentType: "string"
    }), m(b));
  }
  function f(b) {
    return b === 62 ? (n.enter(s), n.consume(b), n.exit(s), n.exit(i), n.exit(r), e) : (n.enter(l), n.enter("chunkString", {
      contentType: "string"
    }), d(b));
  }
  function d(b) {
    return b === 62 ? (n.exit("chunkString"), n.exit(l), f(b)) : b === null || b === 60 || Ne(b) ? t(b) : (n.consume(b), b === 92 ? p : d);
  }
  function p(b) {
    return b === 60 || b === 62 || b === 92 ? (n.consume(b), d) : d(b);
  }
  function m(b) {
    return !u && (b === null || b === 41 || Nt(b)) ? (n.exit("chunkString"), n.exit(l), n.exit(o), n.exit(r), e(b)) : u < c && b === 40 ? (n.consume(b), u++, m) : b === 41 ? (n.consume(b), u--, m) : b === null || b === 32 || b === 40 || Qp(b) ? t(b) : (n.consume(b), b === 92 ? g : m);
  }
  function g(b) {
    return b === 40 || b === 41 || b === 92 ? (n.consume(b), m) : m(b);
  }
}
function NS(n, e, t, r, i, s) {
  const o = this;
  let l = 0, a;
  return c;
  function c(d) {
    return n.enter(r), n.enter(i), n.consume(d), n.exit(i), n.enter(s), u;
  }
  function u(d) {
    return l > 999 || d === null || d === 91 || d === 93 && !a || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !l && "_hiddenFootnoteSupport" in o.parser.constructs ? t(d) : d === 93 ? (n.exit(s), n.enter(i), n.consume(d), n.exit(i), n.exit(r), e) : Ne(d) ? (n.enter("lineEnding"), n.consume(d), n.exit("lineEnding"), u) : (n.enter("chunkString", {
      contentType: "string"
    }), h(d));
  }
  function h(d) {
    return d === null || d === 91 || d === 93 || Ne(d) || l++ > 999 ? (n.exit("chunkString"), u(d)) : (n.consume(d), a || (a = !lt(d)), d === 92 ? f : h);
  }
  function f(d) {
    return d === 91 || d === 92 || d === 93 ? (n.consume(d), l++, h) : h(d);
  }
}
function RS(n, e, t, r, i, s) {
  let o;
  return l;
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? (n.enter(r), n.enter(i), n.consume(f), n.exit(i), o = f === 40 ? 41 : f, a) : t(f);
  }
  function a(f) {
    return f === o ? (n.enter(i), n.consume(f), n.exit(i), n.exit(r), e) : (n.enter(s), c(f));
  }
  function c(f) {
    return f === o ? (n.exit(s), a(o)) : f === null ? t(f) : Ne(f) ? (n.enter("lineEnding"), n.consume(f), n.exit("lineEnding"), it(n, c, "linePrefix")) : (n.enter("chunkString", {
      contentType: "string"
    }), u(f));
  }
  function u(f) {
    return f === o || f === null || Ne(f) ? (n.exit("chunkString"), c(f)) : (n.consume(f), f === 92 ? h : u);
  }
  function h(f) {
    return f === o || f === 92 ? (n.consume(f), u) : u(f);
  }
}
function zh(n, e) {
  let t;
  return r;
  function r(i) {
    return Ne(i) ? (n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), t = !0, r) : lt(i) ? it(n, r, t ? "linePrefix" : "lineSuffix")(i) : e(i);
  }
}
const XP = {
  name: "definition",
  tokenize: QP
}, ZP = {
  partial: !0,
  tokenize: e_
};
function QP(n, e, t) {
  const r = this;
  let i;
  return s;
  function s(d) {
    return n.enter("definition"), o(d);
  }
  function o(d) {
    return NS.call(
      r,
      n,
      l,
      // Note: we don’t need to reset the way `markdown-rs` does.
      t,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function l(d) {
    return i = Ni(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), d === 58 ? (n.enter("definitionMarker"), n.consume(d), n.exit("definitionMarker"), a) : t(d);
  }
  function a(d) {
    return Nt(d) ? zh(n, c)(d) : c(d);
  }
  function c(d) {
    return DS(
      n,
      u,
      // Note: we don’t need to reset the way `markdown-rs` does.
      t,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function u(d) {
    return n.attempt(ZP, h, h)(d);
  }
  function h(d) {
    return lt(d) ? it(n, f, "whitespace")(d) : f(d);
  }
  function f(d) {
    return d === null || Ne(d) ? (n.exit("definition"), r.parser.defined.push(i), e(d)) : t(d);
  }
}
function e_(n, e, t) {
  return r;
  function r(l) {
    return Nt(l) ? zh(n, i)(l) : t(l);
  }
  function i(l) {
    return RS(n, s, t, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(l);
  }
  function s(l) {
    return lt(l) ? it(n, o, "whitespace")(l) : o(l);
  }
  function o(l) {
    return l === null || Ne(l) ? e(l) : t(l);
  }
}
const t_ = {
  name: "hardBreakEscape",
  tokenize: n_
};
function n_(n, e, t) {
  return r;
  function r(s) {
    return n.enter("hardBreakEscape"), n.consume(s), i;
  }
  function i(s) {
    return Ne(s) ? (n.exit("hardBreakEscape"), e(s)) : t(s);
  }
}
const r_ = {
  name: "headingAtx",
  resolve: i_,
  tokenize: s_
};
function i_(n, e) {
  let t = n.length - 2, r = 3, i, s;
  return n[r][1].type === "whitespace" && (r += 2), t - 2 > r && n[t][1].type === "whitespace" && (t -= 2), n[t][1].type === "atxHeadingSequence" && (r === t - 1 || t - 4 > r && n[t - 2][1].type === "whitespace") && (t -= r + 1 === t ? 2 : 4), t > r && (i = {
    type: "atxHeadingText",
    start: n[r][1].start,
    end: n[t][1].end
  }, s = {
    type: "chunkText",
    start: n[r][1].start,
    end: n[t][1].end,
    contentType: "text"
  }, Xr(n, r, t - r + 1, [["enter", i, e], ["enter", s, e], ["exit", s, e], ["exit", i, e]])), n;
}
function s_(n, e, t) {
  let r = 0;
  return i;
  function i(u) {
    return n.enter("atxHeading"), s(u);
  }
  function s(u) {
    return n.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (n.consume(u), o) : u === null || Nt(u) ? (n.exit("atxHeadingSequence"), l(u)) : t(u);
  }
  function l(u) {
    return u === 35 ? (n.enter("atxHeadingSequence"), a(u)) : u === null || Ne(u) ? (n.exit("atxHeading"), e(u)) : lt(u) ? it(n, l, "whitespace")(u) : (n.enter("atxHeadingText"), c(u));
  }
  function a(u) {
    return u === 35 ? (n.consume(u), a) : (n.exit("atxHeadingSequence"), l(u));
  }
  function c(u) {
    return u === null || u === 35 || Nt(u) ? (n.exit("atxHeadingText"), l(u)) : (n.consume(u), c);
  }
}
const o_ = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], l6 = ["pre", "script", "style", "textarea"], l_ = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: u_,
  tokenize: h_
}, a_ = {
  partial: !0,
  tokenize: d_
}, c_ = {
  partial: !0,
  tokenize: f_
};
function u_(n) {
  let e = n.length;
  for (; e-- && !(n[e][0] === "enter" && n[e][1].type === "htmlFlow"); )
    ;
  return e > 1 && n[e - 2][1].type === "linePrefix" && (n[e][1].start = n[e - 2][1].start, n[e + 1][1].start = n[e - 2][1].start, n.splice(e - 2, 2)), n;
}
function h_(n, e, t) {
  const r = this;
  let i, s, o, l, a;
  return c;
  function c(O) {
    return u(O);
  }
  function u(O) {
    return n.enter("htmlFlow"), n.enter("htmlFlowData"), n.consume(O), h;
  }
  function h(O) {
    return O === 33 ? (n.consume(O), f) : O === 47 ? (n.consume(O), s = !0, m) : O === 63 ? (n.consume(O), i = 3, r.interrupt ? e : I) : lr(O) ? (n.consume(O), o = String.fromCharCode(O), g) : t(O);
  }
  function f(O) {
    return O === 45 ? (n.consume(O), i = 2, d) : O === 91 ? (n.consume(O), i = 5, l = 0, p) : lr(O) ? (n.consume(O), i = 4, r.interrupt ? e : I) : t(O);
  }
  function d(O) {
    return O === 45 ? (n.consume(O), r.interrupt ? e : I) : t(O);
  }
  function p(O) {
    const pt = "CDATA[";
    return O === pt.charCodeAt(l++) ? (n.consume(O), l === pt.length ? r.interrupt ? e : z : p) : t(O);
  }
  function m(O) {
    return lr(O) ? (n.consume(O), o = String.fromCharCode(O), g) : t(O);
  }
  function g(O) {
    if (O === null || O === 47 || O === 62 || Nt(O)) {
      const pt = O === 47, Ue = o.toLowerCase();
      return !pt && !s && l6.includes(Ue) ? (i = 1, r.interrupt ? e(O) : z(O)) : o_.includes(o.toLowerCase()) ? (i = 6, pt ? (n.consume(O), b) : r.interrupt ? e(O) : z(O)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? t(O) : s ? w(O) : k(O));
    }
    return O === 45 || Tr(O) ? (n.consume(O), o += String.fromCharCode(O), g) : t(O);
  }
  function b(O) {
    return O === 62 ? (n.consume(O), r.interrupt ? e : z) : t(O);
  }
  function w(O) {
    return lt(O) ? (n.consume(O), w) : R(O);
  }
  function k(O) {
    return O === 47 ? (n.consume(O), R) : O === 58 || O === 95 || lr(O) ? (n.consume(O), C) : lt(O) ? (n.consume(O), k) : R(O);
  }
  function C(O) {
    return O === 45 || O === 46 || O === 58 || O === 95 || Tr(O) ? (n.consume(O), C) : M(O);
  }
  function M(O) {
    return O === 61 ? (n.consume(O), T) : lt(O) ? (n.consume(O), M) : k(O);
  }
  function T(O) {
    return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? t(O) : O === 34 || O === 39 ? (n.consume(O), a = O, N) : lt(O) ? (n.consume(O), T) : B(O);
  }
  function N(O) {
    return O === a ? (n.consume(O), a = null, $) : O === null || Ne(O) ? t(O) : (n.consume(O), N);
  }
  function B(O) {
    return O === null || O === 34 || O === 39 || O === 47 || O === 60 || O === 61 || O === 62 || O === 96 || Nt(O) ? M(O) : (n.consume(O), B);
  }
  function $(O) {
    return O === 47 || O === 62 || lt(O) ? k(O) : t(O);
  }
  function R(O) {
    return O === 62 ? (n.consume(O), V) : t(O);
  }
  function V(O) {
    return O === null || Ne(O) ? z(O) : lt(O) ? (n.consume(O), V) : t(O);
  }
  function z(O) {
    return O === 45 && i === 2 ? (n.consume(O), Ce) : O === 60 && i === 1 ? (n.consume(O), ye) : O === 62 && i === 4 ? (n.consume(O), Ie) : O === 63 && i === 3 ? (n.consume(O), I) : O === 93 && i === 5 ? (n.consume(O), ze) : Ne(O) && (i === 6 || i === 7) ? (n.exit("htmlFlowData"), n.check(a_, Ve, ue)(O)) : O === null || Ne(O) ? (n.exit("htmlFlowData"), ue(O)) : (n.consume(O), z);
  }
  function ue(O) {
    return n.check(c_, ie, Ve)(O);
  }
  function ie(O) {
    return n.enter("lineEnding"), n.consume(O), n.exit("lineEnding"), he;
  }
  function he(O) {
    return O === null || Ne(O) ? ue(O) : (n.enter("htmlFlowData"), z(O));
  }
  function Ce(O) {
    return O === 45 ? (n.consume(O), I) : z(O);
  }
  function ye(O) {
    return O === 47 ? (n.consume(O), o = "", be) : z(O);
  }
  function be(O) {
    if (O === 62) {
      const pt = o.toLowerCase();
      return l6.includes(pt) ? (n.consume(O), Ie) : z(O);
    }
    return lr(O) && o.length < 8 ? (n.consume(O), o += String.fromCharCode(O), be) : z(O);
  }
  function ze(O) {
    return O === 93 ? (n.consume(O), I) : z(O);
  }
  function I(O) {
    return O === 62 ? (n.consume(O), Ie) : O === 45 && i === 2 ? (n.consume(O), I) : z(O);
  }
  function Ie(O) {
    return O === null || Ne(O) ? (n.exit("htmlFlowData"), Ve(O)) : (n.consume(O), Ie);
  }
  function Ve(O) {
    return n.exit("htmlFlow"), e(O);
  }
}
function f_(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return Ne(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s) : t(o);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
function d_(n, e, t) {
  return r;
  function r(i) {
    return n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), n.attempt(sd, e, t);
  }
}
const p_ = {
  name: "htmlText",
  tokenize: m_
};
function m_(n, e, t) {
  const r = this;
  let i, s, o;
  return l;
  function l(I) {
    return n.enter("htmlText"), n.enter("htmlTextData"), n.consume(I), a;
  }
  function a(I) {
    return I === 33 ? (n.consume(I), c) : I === 47 ? (n.consume(I), M) : I === 63 ? (n.consume(I), k) : lr(I) ? (n.consume(I), B) : t(I);
  }
  function c(I) {
    return I === 45 ? (n.consume(I), u) : I === 91 ? (n.consume(I), s = 0, p) : lr(I) ? (n.consume(I), w) : t(I);
  }
  function u(I) {
    return I === 45 ? (n.consume(I), d) : t(I);
  }
  function h(I) {
    return I === null ? t(I) : I === 45 ? (n.consume(I), f) : Ne(I) ? (o = h, ye(I)) : (n.consume(I), h);
  }
  function f(I) {
    return I === 45 ? (n.consume(I), d) : h(I);
  }
  function d(I) {
    return I === 62 ? Ce(I) : I === 45 ? f(I) : h(I);
  }
  function p(I) {
    const Ie = "CDATA[";
    return I === Ie.charCodeAt(s++) ? (n.consume(I), s === Ie.length ? m : p) : t(I);
  }
  function m(I) {
    return I === null ? t(I) : I === 93 ? (n.consume(I), g) : Ne(I) ? (o = m, ye(I)) : (n.consume(I), m);
  }
  function g(I) {
    return I === 93 ? (n.consume(I), b) : m(I);
  }
  function b(I) {
    return I === 62 ? Ce(I) : I === 93 ? (n.consume(I), b) : m(I);
  }
  function w(I) {
    return I === null || I === 62 ? Ce(I) : Ne(I) ? (o = w, ye(I)) : (n.consume(I), w);
  }
  function k(I) {
    return I === null ? t(I) : I === 63 ? (n.consume(I), C) : Ne(I) ? (o = k, ye(I)) : (n.consume(I), k);
  }
  function C(I) {
    return I === 62 ? Ce(I) : k(I);
  }
  function M(I) {
    return lr(I) ? (n.consume(I), T) : t(I);
  }
  function T(I) {
    return I === 45 || Tr(I) ? (n.consume(I), T) : N(I);
  }
  function N(I) {
    return Ne(I) ? (o = N, ye(I)) : lt(I) ? (n.consume(I), N) : Ce(I);
  }
  function B(I) {
    return I === 45 || Tr(I) ? (n.consume(I), B) : I === 47 || I === 62 || Nt(I) ? $(I) : t(I);
  }
  function $(I) {
    return I === 47 ? (n.consume(I), Ce) : I === 58 || I === 95 || lr(I) ? (n.consume(I), R) : Ne(I) ? (o = $, ye(I)) : lt(I) ? (n.consume(I), $) : Ce(I);
  }
  function R(I) {
    return I === 45 || I === 46 || I === 58 || I === 95 || Tr(I) ? (n.consume(I), R) : V(I);
  }
  function V(I) {
    return I === 61 ? (n.consume(I), z) : Ne(I) ? (o = V, ye(I)) : lt(I) ? (n.consume(I), V) : $(I);
  }
  function z(I) {
    return I === null || I === 60 || I === 61 || I === 62 || I === 96 ? t(I) : I === 34 || I === 39 ? (n.consume(I), i = I, ue) : Ne(I) ? (o = z, ye(I)) : lt(I) ? (n.consume(I), z) : (n.consume(I), ie);
  }
  function ue(I) {
    return I === i ? (n.consume(I), i = void 0, he) : I === null ? t(I) : Ne(I) ? (o = ue, ye(I)) : (n.consume(I), ue);
  }
  function ie(I) {
    return I === null || I === 34 || I === 39 || I === 60 || I === 61 || I === 96 ? t(I) : I === 47 || I === 62 || Nt(I) ? $(I) : (n.consume(I), ie);
  }
  function he(I) {
    return I === 47 || I === 62 || Nt(I) ? $(I) : t(I);
  }
  function Ce(I) {
    return I === 62 ? (n.consume(I), n.exit("htmlTextData"), n.exit("htmlText"), e) : t(I);
  }
  function ye(I) {
    return n.exit("htmlTextData"), n.enter("lineEnding"), n.consume(I), n.exit("lineEnding"), be;
  }
  function be(I) {
    return lt(I) ? it(n, ze, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(I) : ze(I);
  }
  function ze(I) {
    return n.enter("htmlTextData"), o(I);
  }
}
const Y5 = {
  name: "labelEnd",
  resolveAll: v_,
  resolveTo: w_,
  tokenize: x_
}, g_ = {
  tokenize: k_
}, y_ = {
  tokenize: S_
}, b_ = {
  tokenize: C_
};
function v_(n) {
  let e = -1;
  const t = [];
  for (; ++e < n.length; ) {
    const r = n[e][1];
    if (t.push(n[e]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", e += i;
    }
  }
  return n.length !== t.length && Xr(n, 0, n.length, t), n;
}
function w_(n, e) {
  let t = n.length, r = 0, i, s, o, l;
  for (; t--; )
    if (i = n[t][1], s) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      n[t][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (n[t][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = t, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (o = t);
  const a = {
    type: n[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...n[s][1].start
    },
    end: {
      ...n[n.length - 1][1].end
    }
  }, c = {
    type: "label",
    start: {
      ...n[s][1].start
    },
    end: {
      ...n[o][1].end
    }
  }, u = {
    type: "labelText",
    start: {
      ...n[s + r + 2][1].end
    },
    end: {
      ...n[o - 2][1].start
    }
  };
  return l = [["enter", a, e], ["enter", c, e]], l = si(l, n.slice(s + 1, s + r + 3)), l = si(l, [["enter", u, e]]), l = si(l, e1(e.parser.constructs.insideSpan.null, n.slice(s + r + 4, o - 3), e)), l = si(l, [["exit", u, e], n[o - 2], n[o - 1], ["exit", c, e]]), l = si(l, n.slice(o + 1)), l = si(l, [["exit", a, e]]), Xr(n, s, n.length, l), n;
}
function x_(n, e, t) {
  const r = this;
  let i = r.events.length, s, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return l;
  function l(f) {
    return s ? s._inactive ? h(f) : (o = r.parser.defined.includes(Ni(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), n.enter("labelEnd"), n.enter("labelMarker"), n.consume(f), n.exit("labelMarker"), n.exit("labelEnd"), a) : t(f);
  }
  function a(f) {
    return f === 40 ? n.attempt(g_, u, o ? u : h)(f) : f === 91 ? n.attempt(y_, u, o ? c : h)(f) : o ? u(f) : h(f);
  }
  function c(f) {
    return n.attempt(b_, u, h)(f);
  }
  function u(f) {
    return e(f);
  }
  function h(f) {
    return s._balanced = !0, t(f);
  }
}
function k_(n, e, t) {
  return r;
  function r(h) {
    return n.enter("resource"), n.enter("resourceMarker"), n.consume(h), n.exit("resourceMarker"), i;
  }
  function i(h) {
    return Nt(h) ? zh(n, s)(h) : s(h);
  }
  function s(h) {
    return h === 41 ? u(h) : DS(n, o, l, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function o(h) {
    return Nt(h) ? zh(n, a)(h) : u(h);
  }
  function l(h) {
    return t(h);
  }
  function a(h) {
    return h === 34 || h === 39 || h === 40 ? RS(n, c, t, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : u(h);
  }
  function c(h) {
    return Nt(h) ? zh(n, u)(h) : u(h);
  }
  function u(h) {
    return h === 41 ? (n.enter("resourceMarker"), n.consume(h), n.exit("resourceMarker"), n.exit("resource"), e) : t(h);
  }
}
function S_(n, e, t) {
  const r = this;
  return i;
  function i(l) {
    return NS.call(r, n, s, o, "reference", "referenceMarker", "referenceString")(l);
  }
  function s(l) {
    return r.parser.defined.includes(Ni(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(l) : t(l);
  }
  function o(l) {
    return t(l);
  }
}
function C_(n, e, t) {
  return r;
  function r(s) {
    return n.enter("reference"), n.enter("referenceMarker"), n.consume(s), n.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (n.enter("referenceMarker"), n.consume(s), n.exit("referenceMarker"), n.exit("reference"), e) : t(s);
  }
}
const M_ = {
  name: "labelStartImage",
  resolveAll: Y5.resolveAll,
  tokenize: T_
};
function T_(n, e, t) {
  const r = this;
  return i;
  function i(l) {
    return n.enter("labelImage"), n.enter("labelImageMarker"), n.consume(l), n.exit("labelImageMarker"), s;
  }
  function s(l) {
    return l === 91 ? (n.enter("labelMarker"), n.consume(l), n.exit("labelMarker"), n.exit("labelImage"), o) : t(l);
  }
  function o(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(l) : e(l);
  }
}
const A_ = {
  name: "labelStartLink",
  resolveAll: Y5.resolveAll,
  tokenize: O_
};
function O_(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return n.enter("labelLink"), n.enter("labelMarker"), n.consume(o), n.exit("labelMarker"), n.exit("labelLink"), s;
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(o) : e(o);
  }
}
const Ag = {
  name: "lineEnding",
  tokenize: E_
};
function E_(n, e) {
  return t;
  function t(r) {
    return n.enter("lineEnding"), n.consume(r), n.exit("lineEnding"), it(n, e, "linePrefix");
  }
}
const W0 = {
  name: "thematicBreak",
  tokenize: I_
};
function I_(n, e, t) {
  let r = 0, i;
  return s;
  function s(c) {
    return n.enter("thematicBreak"), o(c);
  }
  function o(c) {
    return i = c, l(c);
  }
  function l(c) {
    return c === i ? (n.enter("thematicBreakSequence"), a(c)) : r >= 3 && (c === null || Ne(c)) ? (n.exit("thematicBreak"), e(c)) : t(c);
  }
  function a(c) {
    return c === i ? (n.consume(c), r++, a) : (n.exit("thematicBreakSequence"), lt(c) ? it(n, l, "whitespace")(c) : l(c));
  }
}
const wr = {
  continuation: {
    tokenize: P_
  },
  exit: L_,
  name: "list",
  tokenize: R_
}, D_ = {
  partial: !0,
  tokenize: B_
}, N_ = {
  partial: !0,
  tokenize: __
};
function R_(n, e, t) {
  const r = this, i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return l;
  function l(d) {
    const p = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (p === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : C4(d)) {
      if (r.containerState.type || (r.containerState.type = p, n.enter(p, {
        _container: !0
      })), p === "listUnordered")
        return n.enter("listItemPrefix"), d === 42 || d === 45 ? n.check(W0, t, c)(d) : c(d);
      if (!r.interrupt || d === 49)
        return n.enter("listItemPrefix"), n.enter("listItemValue"), a(d);
    }
    return t(d);
  }
  function a(d) {
    return C4(d) && ++o < 10 ? (n.consume(d), a) : (!r.interrupt || o < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (n.exit("listItemValue"), c(d)) : t(d);
  }
  function c(d) {
    return n.enter("listItemMarker"), n.consume(d), n.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, n.check(
      sd,
      // Can’t be empty when interrupting.
      r.interrupt ? t : u,
      n.attempt(D_, f, h)
    );
  }
  function u(d) {
    return r.containerState.initialBlankLine = !0, s++, f(d);
  }
  function h(d) {
    return lt(d) ? (n.enter("listItemPrefixWhitespace"), n.consume(d), n.exit("listItemPrefixWhitespace"), f) : t(d);
  }
  function f(d) {
    return r.containerState.size = s + r.sliceSerialize(n.exit("listItemPrefix"), !0).length, e(d);
  }
}
function P_(n, e, t) {
  const r = this;
  return r.containerState._closeFlow = void 0, n.check(sd, i, s);
  function i(l) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, it(n, e, "listItemIndent", r.containerState.size + 1)(l);
  }
  function s(l) {
    return r.containerState.furtherBlankLines || !lt(l) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(l)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, n.attempt(N_, e, o)(l));
  }
  function o(l) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, it(n, n.attempt(wr, e, t), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l);
  }
}
function __(n, e, t) {
  const r = this;
  return it(n, i, "listItemIndent", r.containerState.size + 1);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(s) : t(s);
  }
}
function L_(n) {
  n.exit(this.containerState.type);
}
function B_(n, e, t) {
  const r = this;
  return it(n, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return !lt(s) && o && o[1].type === "listItemPrefixWhitespace" ? e(s) : t(s);
  }
}
const a6 = {
  name: "setextUnderline",
  resolveTo: z_,
  tokenize: F_
};
function z_(n, e) {
  let t = n.length, r, i, s;
  for (; t--; )
    if (n[t][0] === "enter") {
      if (n[t][1].type === "content") {
        r = t;
        break;
      }
      n[t][1].type === "paragraph" && (i = t);
    } else
      n[t][1].type === "content" && n.splice(t, 1), !s && n[t][1].type === "definition" && (s = t);
  const o = {
    type: "setextHeading",
    start: {
      ...n[r][1].start
    },
    end: {
      ...n[n.length - 1][1].end
    }
  };
  return n[i][1].type = "setextHeadingText", s ? (n.splice(i, 0, ["enter", o, e]), n.splice(s + 1, 0, ["exit", n[r][1], e]), n[r][1].end = {
    ...n[s][1].end
  }) : n[r][1] = o, n.push(["exit", o, e]), n;
}
function F_(n, e, t) {
  const r = this;
  let i;
  return s;
  function s(c) {
    let u = r.events.length, h;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        h = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (n.enter("setextHeadingLine"), i = c, o(c)) : t(c);
  }
  function o(c) {
    return n.enter("setextHeadingLineSequence"), l(c);
  }
  function l(c) {
    return c === i ? (n.consume(c), l) : (n.exit("setextHeadingLineSequence"), lt(c) ? it(n, a, "lineSuffix")(c) : a(c));
  }
  function a(c) {
    return c === null || Ne(c) ? (n.exit("setextHeadingLine"), e(c)) : t(c);
  }
}
const H_ = {
  tokenize: $_
};
function $_(n) {
  const e = this, t = n.attempt(
    // Try to parse a blank line.
    sd,
    r,
    // Try to parse initial flow (essentially, only code).
    n.attempt(this.parser.constructs.flowInitial, i, it(n, n.attempt(this.parser.constructs.flow, i, n.attempt(UP, i)), "linePrefix"))
  );
  return t;
  function r(s) {
    if (s === null) {
      n.consume(s);
      return;
    }
    return n.enter("lineEndingBlank"), n.consume(s), n.exit("lineEndingBlank"), e.currentConstruct = void 0, t;
  }
  function i(s) {
    if (s === null) {
      n.consume(s);
      return;
    }
    return n.enter("lineEnding"), n.consume(s), n.exit("lineEnding"), e.currentConstruct = void 0, t;
  }
}
const V_ = {
  resolveAll: _S()
}, q_ = PS("string"), W_ = PS("text");
function PS(n) {
  return {
    resolveAll: _S(n === "text" ? j_ : void 0),
    tokenize: e
  };
  function e(t) {
    const r = this, i = this.parser.constructs[n], s = t.attempt(i, o, l);
    return o;
    function o(u) {
      return c(u) ? s(u) : l(u);
    }
    function l(u) {
      if (u === null) {
        t.consume(u);
        return;
      }
      return t.enter("data"), t.consume(u), a;
    }
    function a(u) {
      return c(u) ? (t.exit("data"), s(u)) : (t.consume(u), a);
    }
    function c(u) {
      if (u === null)
        return !0;
      const h = i[u];
      let f = -1;
      if (h)
        for (; ++f < h.length; ) {
          const d = h[f];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function _S(n) {
  return e;
  function e(t, r) {
    let i = -1, s;
    for (; ++i <= t.length; )
      s === void 0 ? t[i] && t[i][1].type === "data" && (s = i, i++) : (!t[i] || t[i][1].type !== "data") && (i !== s + 2 && (t[s][1].end = t[i - 1][1].end, t.splice(s + 2, i - s - 2), i = s + 2), s = void 0);
    return n ? n(t, r) : t;
  }
}
function j_(n, e) {
  let t = 0;
  for (; ++t <= n.length; )
    if ((t === n.length || n[t][1].type === "lineEnding") && n[t - 1][1].type === "data") {
      const r = n[t - 1][1], i = e.sliceStream(r);
      let s = i.length, o = -1, l = 0, a;
      for (; s--; ) {
        const c = i[s];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; )
            l++, o--;
          if (o) break;
          o = -1;
        } else if (c === -2)
          a = !0, l++;
        else if (c !== -1) {
          s++;
          break;
        }
      }
      if (e._contentTypeTextTrailing && t === n.length && (l = 0), l) {
        const c = {
          type: t === n.length || a || l < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? o : r.start._bufferIndex + o,
            _index: r.start._index + s,
            line: r.end.line,
            column: r.end.column - l,
            offset: r.end.offset - l
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...c.start
        }, r.start.offset === r.end.offset ? Object.assign(r, c) : (n.splice(t, 0, ["enter", c, e], ["exit", c, e]), t += 2);
      }
      t++;
    }
  return n;
}
const U_ = {
  42: wr,
  43: wr,
  45: wr,
  48: wr,
  49: wr,
  50: wr,
  51: wr,
  52: wr,
  53: wr,
  54: wr,
  55: wr,
  56: wr,
  57: wr,
  62: AS
}, K_ = {
  91: XP
}, G_ = {
  [-2]: Tg,
  [-1]: Tg,
  32: Tg
}, Y_ = {
  35: r_,
  42: W0,
  45: [a6, W0],
  60: l_,
  61: a6,
  95: W0,
  96: o6,
  126: o6
}, J_ = {
  38: ES,
  92: OS
}, X_ = {
  [-5]: Ag,
  [-4]: Ag,
  [-3]: Ag,
  33: M_,
  38: ES,
  42: M4,
  60: [AP, p_],
  91: A_,
  92: [t_, OS],
  93: Y5,
  95: M4,
  96: HP
}, Z_ = {
  null: [M4, V_]
}, Q_ = {
  null: [42, 95]
}, eL = {
  null: []
}, tL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Q_,
  contentInitial: K_,
  disable: eL,
  document: U_,
  flow: Y_,
  flowInitial: G_,
  insideSpan: Z_,
  string: J_,
  text: X_
}, Symbol.toStringTag, { value: "Module" }));
function nL(n, e, t) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: t && t.line || 1,
    column: t && t.column || 1,
    offset: t && t.offset || 0
  };
  const i = {}, s = [];
  let o = [], l = [];
  const a = {
    attempt: N(M),
    check: N(T),
    consume: w,
    enter: k,
    exit: C,
    interrupt: N(T, {
      interrupt: !0
    })
  }, c = {
    code: null,
    containerState: {},
    defineSkip: m,
    events: [],
    now: p,
    parser: n,
    previous: null,
    sliceSerialize: f,
    sliceStream: d,
    write: h
  };
  let u = e.tokenize.call(c, a);
  return e.resolveAll && s.push(e), c;
  function h(V) {
    return o = si(o, V), g(), o[o.length - 1] !== null ? [] : (B(e, 0), c.events = e1(s, c.events, c), c.events);
  }
  function f(V, z) {
    return iL(d(V), z);
  }
  function d(V) {
    return rL(o, V);
  }
  function p() {
    const {
      _bufferIndex: V,
      _index: z,
      line: ue,
      column: ie,
      offset: he
    } = r;
    return {
      _bufferIndex: V,
      _index: z,
      line: ue,
      column: ie,
      offset: he
    };
  }
  function m(V) {
    i[V.line] = V.column, R();
  }
  function g() {
    let V;
    for (; r._index < o.length; ) {
      const z = o[r._index];
      if (typeof z == "string")
        for (V = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === V && r._bufferIndex < z.length; )
          b(z.charCodeAt(r._bufferIndex));
      else
        b(z);
    }
  }
  function b(V) {
    u = u(V);
  }
  function w(V) {
    Ne(V) ? (r.line++, r.column = 1, r.offset += V === -3 ? 2 : 1, R()) : V !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = V;
  }
  function k(V, z) {
    const ue = z || {};
    return ue.type = V, ue.start = p(), c.events.push(["enter", ue, c]), l.push(ue), ue;
  }
  function C(V) {
    const z = l.pop();
    return z.end = p(), c.events.push(["exit", z, c]), z;
  }
  function M(V, z) {
    B(V, z.from);
  }
  function T(V, z) {
    z.restore();
  }
  function N(V, z) {
    return ue;
    function ue(ie, he, Ce) {
      let ye, be, ze, I;
      return Array.isArray(ie) ? (
        /* c8 ignore next 1 */
        Ve(ie)
      ) : "tokenize" in ie ? (
        // Looks like a construct.
        Ve([
          /** @type {Construct} */
          ie
        ])
      ) : Ie(ie);
      function Ie(et) {
        return Tt;
        function Tt(Ht) {
          const sn = Ht !== null && et[Ht], Gt = Ht !== null && et.null, Lr = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(sn) ? sn : sn ? [sn] : [],
            ...Array.isArray(Gt) ? Gt : Gt ? [Gt] : []
          ];
          return Ve(Lr)(Ht);
        }
      }
      function Ve(et) {
        return ye = et, be = 0, et.length === 0 ? Ce : O(et[be]);
      }
      function O(et) {
        return Tt;
        function Tt(Ht) {
          return I = $(), ze = et, et.partial || (c.currentConstruct = et), et.name && c.parser.constructs.disable.null.includes(et.name) ? Ue() : et.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            z ? Object.assign(Object.create(c), z) : c,
            a,
            pt,
            Ue
          )(Ht);
        }
      }
      function pt(et) {
        return V(ze, I), he;
      }
      function Ue(et) {
        return I.restore(), ++be < ye.length ? O(ye[be]) : Ce;
      }
    }
  }
  function B(V, z) {
    V.resolveAll && !s.includes(V) && s.push(V), V.resolve && Xr(c.events, z, c.events.length - z, V.resolve(c.events.slice(z), c)), V.resolveTo && (c.events = V.resolveTo(c.events, c));
  }
  function $() {
    const V = p(), z = c.previous, ue = c.currentConstruct, ie = c.events.length, he = Array.from(l);
    return {
      from: ie,
      restore: Ce
    };
    function Ce() {
      r = V, c.previous = z, c.currentConstruct = ue, c.events.length = ie, l = he, R();
    }
  }
  function R() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function rL(n, e) {
  const t = e.start._index, r = e.start._bufferIndex, i = e.end._index, s = e.end._bufferIndex;
  let o;
  if (t === i)
    o = [n[t].slice(r, s)];
  else {
    if (o = n.slice(t, i), r > -1) {
      const l = o[0];
      typeof l == "string" ? o[0] = l.slice(r) : o.shift();
    }
    s > 0 && o.push(n[i].slice(0, s));
  }
  return o;
}
function iL(n, e) {
  let t = -1;
  const r = [];
  let i;
  for (; ++t < n.length; ) {
    const s = n[t];
    let o;
    if (typeof s == "string")
      o = s;
    else switch (s) {
      case -5: {
        o = "\r";
        break;
      }
      case -4: {
        o = `
`;
        break;
      }
      case -3: {
        o = `\r
`;
        break;
      }
      case -2: {
        o = e ? " " : "	";
        break;
      }
      case -1: {
        if (!e && i) continue;
        o = " ";
        break;
      }
      default:
        o = String.fromCharCode(s);
    }
    i = s === -2, r.push(o);
  }
  return r.join("");
}
function sL(n) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      MS([tL, ...(n || {}).extensions || []])
    ),
    content: i(wP),
    defined: [],
    document: i(kP),
    flow: i(H_),
    lazy: {},
    string: i(q_),
    text: i(W_)
  };
  return r;
  function i(s) {
    return o;
    function o(l) {
      return nL(r, s, l);
    }
  }
}
function oL(n) {
  for (; !IS(n); )
    ;
  return n;
}
const c6 = /[\0\t\n\r]/g;
function lL() {
  let n = 1, e = "", t = !0, r;
  return i;
  function i(s, o, l) {
    const a = [];
    let c, u, h, f, d;
    for (s = e + (typeof s == "string" ? s.toString() : new TextDecoder(o || void 0).decode(s)), h = 0, e = "", t && (s.charCodeAt(0) === 65279 && h++, t = void 0); h < s.length; ) {
      if (c6.lastIndex = h, c = c6.exec(s), f = c && c.index !== void 0 ? c.index : s.length, d = s.charCodeAt(f), !c) {
        e = s.slice(h);
        break;
      }
      if (d === 10 && h === f && r)
        a.push(-3), r = void 0;
      else
        switch (r && (a.push(-5), r = void 0), h < f && (a.push(s.slice(h, f)), n += f - h), d) {
          case 0: {
            a.push(65533), n++;
            break;
          }
          case 9: {
            for (u = Math.ceil(n / 4) * 4, a.push(-2); n++ < u; ) a.push(-1);
            break;
          }
          case 10: {
            a.push(-4), n = 1;
            break;
          }
          default:
            r = !0, n = 1;
        }
      h = f + 1;
    }
    return l && (r && a.push(-5), e && a.push(e), a.push(null)), a;
  }
}
const aL = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function LS(n) {
  return n.replace(aL, cL);
}
function cL(n, e, t) {
  if (e)
    return e;
  if (t.charCodeAt(0) === 35) {
    const i = t.charCodeAt(1), s = i === 120 || i === 88;
    return TS(t.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return G5(t) || n;
}
function Fh(n) {
  return !n || typeof n != "object" ? "" : "position" in n || "type" in n ? u6(n.position) : "start" in n || "end" in n ? u6(n) : "line" in n || "column" in n ? T4(n) : "";
}
function T4(n) {
  return h6(n && n.line) + ":" + h6(n && n.column);
}
function u6(n) {
  return T4(n && n.start) + "-" + T4(n && n.end);
}
function h6(n) {
  return n && typeof n == "number" ? n : 1;
}
const BS = {}.hasOwnProperty;
function uL(n, e, t) {
  return typeof e != "string" && (t = e, e = void 0), hL(t)(oL(sL(t).document().write(lL()(n, e, !0))));
}
function hL(n) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(re),
      autolinkProtocol: $,
      autolinkEmail: $,
      atxHeading: s(Q),
      blockQuote: s(Gt),
      characterEscape: $,
      characterReference: $,
      codeFenced: s(Lr),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: s(Lr, o),
      codeText: s(E, o),
      codeTextData: $,
      data: $,
      codeFlowValue: $,
      definition: s(P),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: s(W),
      hardBreakEscape: s(J),
      hardBreakTrailing: s(J),
      htmlFlow: s(Y, o),
      htmlFlowData: $,
      htmlText: s(Y, o),
      htmlTextData: $,
      image: s(ae),
      label: o,
      link: s(re),
      listItem: s(te),
      listItemValue: f,
      listOrdered: s(oe, h),
      listUnordered: s(oe),
      paragraph: s(De),
      reference: O,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: s(Q),
      strong: s(de),
      thematicBreak: s(Pe)
    },
    exit: {
      atxHeading: a(),
      atxHeadingSequence: M,
      autolink: a(),
      autolinkEmail: sn,
      autolinkProtocol: Ht,
      blockQuote: a(),
      characterEscapeValue: R,
      characterReferenceMarkerHexadecimal: Ue,
      characterReferenceMarkerNumeric: Ue,
      characterReferenceValue: et,
      characterReference: Tt,
      codeFenced: a(g),
      codeFencedFence: m,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: p,
      codeFlowValue: R,
      codeIndented: a(b),
      codeText: a(he),
      codeTextData: R,
      data: R,
      definition: a(),
      definitionDestinationString: C,
      definitionLabelString: w,
      definitionTitleString: k,
      emphasis: a(),
      hardBreakEscape: a(z),
      hardBreakTrailing: a(z),
      htmlFlow: a(ue),
      htmlFlowData: R,
      htmlText: a(ie),
      htmlTextData: R,
      image: a(ye),
      label: ze,
      labelText: be,
      lineEnding: V,
      link: a(Ce),
      listItem: a(),
      listOrdered: a(),
      listUnordered: a(),
      paragraph: a(),
      referenceString: pt,
      resourceDestinationString: I,
      resourceTitleString: Ie,
      resource: Ve,
      setextHeading: a(B),
      setextHeadingLineSequence: N,
      setextHeadingText: T,
      strong: a(),
      thematicBreak: a()
    }
  };
  zS(e, (n || {}).mdastExtensions || []);
  const t = {};
  return r;
  function r(F) {
    let X = {
      type: "root",
      children: []
    };
    const pe = {
      stack: [X],
      tokenStack: [],
      config: e,
      enter: l,
      exit: c,
      buffer: o,
      resume: u,
      data: t
    }, _e = [];
    let je = -1;
    for (; ++je < F.length; )
      if (F[je][1].type === "listOrdered" || F[je][1].type === "listUnordered")
        if (F[je][0] === "enter")
          _e.push(je);
        else {
          const kt = _e.pop();
          je = i(F, kt, je);
        }
    for (je = -1; ++je < F.length; ) {
      const kt = e[F[je][0]];
      BS.call(kt, F[je][1].type) && kt[F[je][1].type].call(Object.assign({
        sliceSerialize: F[je][2].sliceSerialize
      }, pe), F[je][1]);
    }
    if (pe.tokenStack.length > 0) {
      const kt = pe.tokenStack[pe.tokenStack.length - 1];
      (kt[1] || f6).call(pe, void 0, kt[0]);
    }
    for (X.position = {
      start: Oo(F.length > 0 ? F[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Oo(F.length > 0 ? F[F.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, je = -1; ++je < e.transforms.length; )
      X = e.transforms[je](X) || X;
    return X;
  }
  function i(F, X, pe) {
    let _e = X - 1, je = -1, kt = !1, _t, Yt, on, xt;
    for (; ++_e <= pe; ) {
      const mt = F[_e];
      switch (mt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          mt[0] === "enter" ? je++ : je--, xt = void 0;
          break;
        }
        case "lineEndingBlank": {
          mt[0] === "enter" && (_t && !xt && !je && !on && (on = _e), xt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          xt = void 0;
      }
      if (!je && mt[0] === "enter" && mt[1].type === "listItemPrefix" || je === -1 && mt[0] === "exit" && (mt[1].type === "listUnordered" || mt[1].type === "listOrdered")) {
        if (_t) {
          let Vn = _e;
          for (Yt = void 0; Vn--; ) {
            const En = F[Vn];
            if (En[1].type === "lineEnding" || En[1].type === "lineEndingBlank") {
              if (En[0] === "exit") continue;
              Yt && (F[Yt][1].type = "lineEndingBlank", kt = !0), En[1].type = "lineEnding", Yt = Vn;
            } else if (!(En[1].type === "linePrefix" || En[1].type === "blockQuotePrefix" || En[1].type === "blockQuotePrefixWhitespace" || En[1].type === "blockQuoteMarker" || En[1].type === "listItemIndent")) break;
          }
          on && (!Yt || on < Yt) && (_t._spread = !0), _t.end = Object.assign({}, Yt ? F[Yt][1].start : mt[1].end), F.splice(Yt || _e, 0, ["exit", _t, mt[2]]), _e++, pe++;
        }
        if (mt[1].type === "listItemPrefix") {
          const Vn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, mt[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          _t = Vn, F.splice(_e, 0, ["enter", Vn, mt[2]]), _e++, pe++, on = void 0, xt = !0;
        }
      }
    }
    return F[X][1]._spread = kt, pe;
  }
  function s(F, X) {
    return pe;
    function pe(_e) {
      l.call(this, F(_e), _e), X && X.call(this, _e);
    }
  }
  function o() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function l(F, X, pe) {
    this.stack[this.stack.length - 1].children.push(F), this.stack.push(F), this.tokenStack.push([X, pe || void 0]), F.position = {
      start: Oo(X.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function a(F) {
    return X;
    function X(pe) {
      F && F.call(this, pe), c.call(this, pe);
    }
  }
  function c(F, X) {
    const pe = this.stack.pop(), _e = this.tokenStack.pop();
    if (_e)
      _e[0].type !== F.type && (X ? X.call(this, F, _e[0]) : (_e[1] || f6).call(this, F, _e[0]));
    else throw new Error("Cannot close `" + F.type + "` (" + Fh({
      start: F.start,
      end: F.end
    }) + "): it’s not open");
    pe.position.end = Oo(F.end);
  }
  function u() {
    return K5(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f(F) {
    if (this.data.expectingFirstListItemValue) {
      const X = this.stack[this.stack.length - 2];
      X.start = Number.parseInt(this.sliceSerialize(F), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.lang = F;
  }
  function p() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.meta = F;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function g() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function b() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F.replace(/(\r?\n|\r)$/g, "");
  }
  function w(F) {
    const X = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.label = X, pe.identifier = Ni(this.sliceSerialize(F)).toLowerCase();
  }
  function k() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.title = F;
  }
  function C() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.url = F;
  }
  function M(F) {
    const X = this.stack[this.stack.length - 1];
    if (!X.depth) {
      const pe = this.sliceSerialize(F).length;
      X.depth = pe;
    }
  }
  function T() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function N(F) {
    const X = this.stack[this.stack.length - 1];
    X.depth = this.sliceSerialize(F).codePointAt(0) === 61 ? 1 : 2;
  }
  function B() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function $(F) {
    const pe = this.stack[this.stack.length - 1].children;
    let _e = pe[pe.length - 1];
    (!_e || _e.type !== "text") && (_e = Te(), _e.position = {
      start: Oo(F.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, pe.push(_e)), this.stack.push(_e);
  }
  function R(F) {
    const X = this.stack.pop();
    X.value += this.sliceSerialize(F), X.position.end = Oo(F.end);
  }
  function V(F) {
    const X = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const pe = X.children[X.children.length - 1];
      pe.position.end = Oo(F.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(X.type) && ($.call(this, F), R.call(this, F));
  }
  function z() {
    this.data.atHardBreak = !0;
  }
  function ue() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F;
  }
  function ie() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F;
  }
  function he() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F;
  }
  function Ce() {
    const F = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const X = this.data.referenceType || "shortcut";
      F.type += "Reference", F.referenceType = X, delete F.url, delete F.title;
    } else
      delete F.identifier, delete F.label;
    this.data.referenceType = void 0;
  }
  function ye() {
    const F = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const X = this.data.referenceType || "shortcut";
      F.type += "Reference", F.referenceType = X, delete F.url, delete F.title;
    } else
      delete F.identifier, delete F.label;
    this.data.referenceType = void 0;
  }
  function be(F) {
    const X = this.sliceSerialize(F), pe = this.stack[this.stack.length - 2];
    pe.label = LS(X), pe.identifier = Ni(X).toLowerCase();
  }
  function ze() {
    const F = this.stack[this.stack.length - 1], X = this.resume(), pe = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, pe.type === "link") {
      const _e = F.children;
      pe.children = _e;
    } else
      pe.alt = X;
  }
  function I() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.url = F;
  }
  function Ie() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.title = F;
  }
  function Ve() {
    this.data.inReference = void 0;
  }
  function O() {
    this.data.referenceType = "collapsed";
  }
  function pt(F) {
    const X = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.label = X, pe.identifier = Ni(this.sliceSerialize(F)).toLowerCase(), this.data.referenceType = "full";
  }
  function Ue(F) {
    this.data.characterReferenceType = F.type;
  }
  function et(F) {
    const X = this.sliceSerialize(F), pe = this.data.characterReferenceType;
    let _e;
    pe ? (_e = TS(X, pe === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : _e = G5(X);
    const je = this.stack[this.stack.length - 1];
    je.value += _e;
  }
  function Tt(F) {
    const X = this.stack.pop();
    X.position.end = Oo(F.end);
  }
  function Ht(F) {
    R.call(this, F);
    const X = this.stack[this.stack.length - 1];
    X.url = this.sliceSerialize(F);
  }
  function sn(F) {
    R.call(this, F);
    const X = this.stack[this.stack.length - 1];
    X.url = "mailto:" + this.sliceSerialize(F);
  }
  function Gt() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Lr() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function E() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function P() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function W() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Q() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function J() {
    return {
      type: "break"
    };
  }
  function Y() {
    return {
      type: "html",
      value: ""
    };
  }
  function ae() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function re() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function oe(F) {
    return {
      type: "list",
      ordered: F.type === "listOrdered",
      start: null,
      spread: F._spread,
      children: []
    };
  }
  function te(F) {
    return {
      type: "listItem",
      spread: F._spread,
      checked: null,
      children: []
    };
  }
  function De() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function de() {
    return {
      type: "strong",
      children: []
    };
  }
  function Te() {
    return {
      type: "text",
      value: ""
    };
  }
  function Pe() {
    return {
      type: "thematicBreak"
    };
  }
}
function Oo(n) {
  return {
    line: n.line,
    column: n.column,
    offset: n.offset
  };
}
function zS(n, e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const r = e[t];
    Array.isArray(r) ? zS(n, r) : fL(n, r);
  }
}
function fL(n, e) {
  let t;
  for (t in e)
    if (BS.call(e, t))
      switch (t) {
        case "canContainEols": {
          const r = e[t];
          r && n[t].push(...r);
          break;
        }
        case "transforms": {
          const r = e[t];
          r && n[t].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = e[t];
          r && Object.assign(n[t], r);
          break;
        }
      }
}
function f6(n, e) {
  throw n ? new Error("Cannot close `" + n.type + "` (" + Fh({
    start: n.start,
    end: n.end
  }) + "): a different token (`" + e.type + "`, " + Fh({
    start: e.start,
    end: e.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + Fh({
    start: e.start,
    end: e.end
  }) + ") is still open");
}
function A4(n) {
  const e = this;
  e.parser = t;
  function t(r) {
    return uL(r, {
      ...e.data("settings"),
      ...n,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("micromarkExtensions") || [],
      mdastExtensions: e.data("fromMarkdownExtensions") || []
    });
  }
}
const d6 = {}.hasOwnProperty;
function dL(n, e) {
  const t = e || {};
  function r(i, ...s) {
    let o = r.invalid;
    const l = r.handlers;
    if (i && d6.call(i, n)) {
      const a = String(i[n]);
      o = d6.call(l, a) ? l[a] : r.unknown;
    }
    if (o)
      return o.call(this, i, ...s);
  }
  return r.handlers = t.handlers || {}, r.invalid = t.invalid, r.unknown = t.unknown, r;
}
const pL = {}.hasOwnProperty;
function FS(n, e) {
  let t = -1, r;
  if (e.extensions)
    for (; ++t < e.extensions.length; )
      FS(n, e.extensions[t]);
  for (r in e)
    if (pL.call(e, r))
      switch (r) {
        case "extensions":
          break;
        /* c8 ignore next 4 */
        case "unsafe": {
          p6(n[r], e[r]);
          break;
        }
        case "join": {
          p6(n[r], e[r]);
          break;
        }
        case "handlers": {
          mL(n[r], e[r]);
          break;
        }
        default:
          n.options[r] = e[r];
      }
  return n;
}
function p6(n, e) {
  e && n.push(...e);
}
function mL(n, e) {
  e && Object.assign(n, e);
}
function gL(n, e, t, r) {
  const i = t.enter("blockquote"), s = t.createTracker(r);
  s.move("> "), s.shift(2);
  const o = t.indentLines(
    t.containerFlow(n, s.current()),
    yL
  );
  return i(), o;
}
function yL(n, e, t) {
  return ">" + (t ? "" : " ") + n;
}
function HS(n, e) {
  return m6(n, e.inConstruct, !0) && !m6(n, e.notInConstruct, !1);
}
function m6(n, e, t) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return t;
  let r = -1;
  for (; ++r < e.length; )
    if (n.includes(e[r]))
      return !0;
  return !1;
}
function g6(n, e, t, r) {
  let i = -1;
  for (; ++i < t.unsafe.length; )
    if (t.unsafe[i].character === `
` && HS(t.stack, t.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function $S(n, e) {
  const t = String(n);
  let r = t.indexOf(e), i = r, s = 0, o = 0;
  if (typeof e != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++s > o && (o = s) : s = 1, i = r + e.length, r = t.indexOf(e, i);
  return o;
}
function O4(n, e) {
  return !!(e.options.fences === !1 && n.value && // If there’s no info…
  !n.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(n.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(n.value));
}
function bL(n) {
  const e = n.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function vL(n, e, t, r) {
  const i = bL(t), s = n.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (O4(n, t)) {
    const h = t.enter("codeIndented"), f = t.indentLines(s, wL);
    return h(), f;
  }
  const l = t.createTracker(r), a = i.repeat(Math.max($S(s, i) + 1, 3)), c = t.enter("codeFenced");
  let u = l.move(a);
  if (n.lang) {
    const h = t.enter(`codeFencedLang${o}`);
    u += l.move(
      t.safe(n.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...l.current()
      })
    ), h();
  }
  if (n.lang && n.meta) {
    const h = t.enter(`codeFencedMeta${o}`);
    u += l.move(" "), u += l.move(
      t.safe(n.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...l.current()
      })
    ), h();
  }
  return u += l.move(`
`), s && (u += l.move(s + `
`)), u += l.move(a), c(), u;
}
function wL(n, e, t) {
  return (t ? "" : "    ") + n;
}
function J5(n) {
  const e = n.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function xL(n, e, t, r) {
  const i = J5(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.enter("definition");
  let l = t.enter("label");
  const a = t.createTracker(r);
  let c = a.move("[");
  return c += a.move(
    t.safe(t.associationId(n), {
      before: c,
      after: "]",
      ...a.current()
    })
  ), c += a.move("]: "), l(), // If there’s no url, or…
  !n.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (l = t.enter("destinationLiteral"), c += a.move("<"), c += a.move(
    t.safe(n.url, { before: c, after: ">", ...a.current() })
  ), c += a.move(">")) : (l = t.enter("destinationRaw"), c += a.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : `
`,
      ...a.current()
    })
  )), l(), n.title && (l = t.enter(`title${s}`), c += a.move(" " + i), c += a.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...a.current()
    })
  ), c += a.move(i), l()), o(), c;
}
function kL(n) {
  const e = n.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function al(n) {
  return "&#x" + n.toString(16).toUpperCase() + ";";
}
function em(n, e, t) {
  const r = Ic(n), i = Ic(e);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    t === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
VS.peek = SL;
function VS(n, e, t, r) {
  const i = kL(t), s = t.enter("emphasis"), o = t.createTracker(r), l = o.move(i);
  let a = o.move(
    t.containerPhrasing(n, {
      after: i,
      before: l,
      ...o.current()
    })
  );
  const c = a.charCodeAt(0), u = em(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (a = al(c) + a.slice(1));
  const h = a.charCodeAt(a.length - 1), f = em(r.after.charCodeAt(0), h, i);
  f.inside && (a = a.slice(0, -1) + al(h));
  const d = o.move(i);
  return s(), t.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, l + a + d;
}
function SL(n, e, t) {
  return t.options.emphasis || "*";
}
const t1 = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(n) {
    if (n == null)
      return AL;
    if (typeof n == "function")
      return n1(n);
    if (typeof n == "object")
      return Array.isArray(n) ? CL(n) : ML(n);
    if (typeof n == "string")
      return TL(n);
    throw new Error("Expected function, string, or object as test");
  })
);
function CL(n) {
  const e = [];
  let t = -1;
  for (; ++t < n.length; )
    e[t] = t1(n[t]);
  return n1(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function ML(n) {
  const e = (
    /** @type {Record<string, unknown>} */
    n
  );
  return n1(t);
  function t(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in n)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function TL(n) {
  return n1(e);
  function e(t) {
    return t && t.type === n;
  }
}
function n1(n) {
  return e;
  function e(t, r, i) {
    return !!(OL(t) && n.call(
      this,
      t,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function AL() {
  return !0;
}
function OL(n) {
  return n !== null && typeof n == "object" && "type" in n;
}
const qS = [], EL = !0, E4 = !1, I4 = "skip";
function X5(n, e, t, r) {
  let i;
  typeof e == "function" && typeof t != "function" ? (r = t, t = e) : i = e;
  const s = t1(i), o = r ? -1 : 1;
  l(n, void 0, [])();
  function l(a, c, u) {
    const h = (
      /** @type {Record<string, unknown>} */
      a && typeof a == "object" ? a : {}
    );
    if (typeof h.type == "string") {
      const d = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(f, "name", {
        value: "node (" + (a.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return f;
    function f() {
      let d = qS, p, m, g;
      if ((!e || s(a, c, u[u.length - 1] || void 0)) && (d = IL(t(a, u)), d[0] === E4))
        return d;
      if ("children" in a && a.children) {
        const b = (
          /** @type {UnistParent} */
          a
        );
        if (b.children && d[0] !== I4)
          for (m = (r ? b.children.length : -1) + o, g = u.concat(b); m > -1 && m < b.children.length; ) {
            const w = b.children[m];
            if (p = l(w, m, g)(), p[0] === E4)
              return p;
            m = typeof p[1] == "number" ? p[1] : m + o;
          }
      }
      return d;
    }
  }
}
function IL(n) {
  return Array.isArray(n) ? n : typeof n == "number" ? [EL, n] : n == null ? qS : [n];
}
function kl(n, e, t, r) {
  let i, s, o;
  typeof e == "function" && typeof t != "function" ? (s = void 0, o = e, i = t) : (s = e, o = t, i = r), X5(n, s, l, i);
  function l(a, c) {
    const u = c[c.length - 1], h = u ? u.children.indexOf(a) : void 0;
    return o(a, h, u);
  }
}
function WS(n, e) {
  let t = !1;
  return kl(n, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return t = !0, E4;
  }), !!((!n.depth || n.depth < 3) && K5(n) && (e.options.setext || t));
}
function DL(n, e, t, r) {
  const i = Math.max(Math.min(6, n.depth || 1), 1), s = t.createTracker(r);
  if (WS(n, t)) {
    const u = t.enter("headingSetext"), h = t.enter("phrasing"), f = t.containerPhrasing(n, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return h(), u(), f + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), l = t.enter("headingAtx"), a = t.enter("phrasing");
  s.move(o + " ");
  let c = t.containerPhrasing(n, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(c) && (c = al(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, t.options.closeAtx && (c += " " + o), a(), l(), c;
}
jS.peek = NL;
function jS(n) {
  return n.value || "";
}
function NL() {
  return "<";
}
US.peek = RL;
function US(n, e, t, r) {
  const i = J5(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.enter("image");
  let l = t.enter("label");
  const a = t.createTracker(r);
  let c = a.move("![");
  return c += a.move(
    t.safe(n.alt, { before: c, after: "]", ...a.current() })
  ), c += a.move("]("), l(), // If there’s no url but there is a title…
  !n.url && n.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (l = t.enter("destinationLiteral"), c += a.move("<"), c += a.move(
    t.safe(n.url, { before: c, after: ">", ...a.current() })
  ), c += a.move(">")) : (l = t.enter("destinationRaw"), c += a.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : ")",
      ...a.current()
    })
  )), l(), n.title && (l = t.enter(`title${s}`), c += a.move(" " + i), c += a.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...a.current()
    })
  ), c += a.move(i), l()), c += a.move(")"), o(), c;
}
function RL() {
  return "!";
}
KS.peek = PL;
function KS(n, e, t, r) {
  const i = n.referenceType, s = t.enter("imageReference");
  let o = t.enter("label");
  const l = t.createTracker(r);
  let a = l.move("![");
  const c = t.safe(n.alt, {
    before: a,
    after: "]",
    ...l.current()
  });
  a += l.move(c + "]["), o();
  const u = t.stack;
  t.stack = [], o = t.enter("reference");
  const h = t.safe(t.associationId(n), {
    before: a,
    after: "]",
    ...l.current()
  });
  return o(), t.stack = u, s(), i === "full" || !c || c !== h ? a += l.move(h + "]") : i === "shortcut" ? a = a.slice(0, -1) : a += l.move("]"), a;
}
function PL() {
  return "!";
}
GS.peek = _L;
function GS(n, e, t) {
  let r = n.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < t.unsafe.length; ) {
    const o = t.unsafe[s], l = t.compilePattern(o);
    let a;
    if (o.atBreak)
      for (; a = l.exec(r); ) {
        let c = a.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(a.index + 1);
      }
  }
  return i + r + i;
}
function _L() {
  return "`";
}
function YS(n, e) {
  const t = K5(n);
  return !!(!e.options.resourceLink && // If there’s a url…
  n.url && // And there’s a no title…
  !n.title && // And the content of `node` is a single text node…
  n.children && n.children.length === 1 && n.children[0].type === "text" && // And if the url is the same as the content…
  (t === n.url || "mailto:" + t === n.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(n.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(n.url));
}
JS.peek = LL;
function JS(n, e, t, r) {
  const i = J5(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.createTracker(r);
  let l, a;
  if (YS(n, t)) {
    const u = t.stack;
    t.stack = [], l = t.enter("autolink");
    let h = o.move("<");
    return h += o.move(
      t.containerPhrasing(n, {
        before: h,
        after: ">",
        ...o.current()
      })
    ), h += o.move(">"), l(), t.stack = u, h;
  }
  l = t.enter("link"), a = t.enter("label");
  let c = o.move("[");
  return c += o.move(
    t.containerPhrasing(n, {
      before: c,
      after: "](",
      ...o.current()
    })
  ), c += o.move("]("), a(), // If there’s no url but there is a title…
  !n.url && n.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (a = t.enter("destinationLiteral"), c += o.move("<"), c += o.move(
    t.safe(n.url, { before: c, after: ">", ...o.current() })
  ), c += o.move(">")) : (a = t.enter("destinationRaw"), c += o.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : ")",
      ...o.current()
    })
  )), a(), n.title && (a = t.enter(`title${s}`), c += o.move(" " + i), c += o.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...o.current()
    })
  ), c += o.move(i), a()), c += o.move(")"), l(), c;
}
function LL(n, e, t) {
  return YS(n, t) ? "<" : "[";
}
XS.peek = BL;
function XS(n, e, t, r) {
  const i = n.referenceType, s = t.enter("linkReference");
  let o = t.enter("label");
  const l = t.createTracker(r);
  let a = l.move("[");
  const c = t.containerPhrasing(n, {
    before: a,
    after: "]",
    ...l.current()
  });
  a += l.move(c + "]["), o();
  const u = t.stack;
  t.stack = [], o = t.enter("reference");
  const h = t.safe(t.associationId(n), {
    before: a,
    after: "]",
    ...l.current()
  });
  return o(), t.stack = u, s(), i === "full" || !c || c !== h ? a += l.move(h + "]") : i === "shortcut" ? a = a.slice(0, -1) : a += l.move("]"), a;
}
function BL() {
  return "[";
}
function Z5(n) {
  const e = n.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function zL(n) {
  const e = Z5(n), t = n.options.bulletOther;
  if (!t)
    return e === "*" ? "-" : "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (t === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + t + "`) to be different"
    );
  return t;
}
function FL(n) {
  const e = n.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function ZS(n) {
  const e = n.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function HL(n, e, t, r) {
  const i = t.enter("list"), s = t.bulletCurrent;
  let o = n.ordered ? FL(t) : Z5(t);
  const l = n.ordered ? o === "." ? ")" : "." : zL(t);
  let a = e && t.bulletLastUsed ? o === t.bulletLastUsed : !1;
  if (!n.ordered) {
    const u = n.children ? n.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      t.stack[t.stack.length - 1] === "list" && t.stack[t.stack.length - 2] === "listItem" && t.stack[t.stack.length - 3] === "list" && t.stack[t.stack.length - 4] === "listItem" && // That are each the first child.
      t.indexStack[t.indexStack.length - 1] === 0 && t.indexStack[t.indexStack.length - 2] === 0 && t.indexStack[t.indexStack.length - 3] === 0 && (a = !0), ZS(t) === o && u
    ) {
      let h = -1;
      for (; ++h < n.children.length; ) {
        const f = n.children[h];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          a = !0;
          break;
        }
      }
    }
  }
  a && (o = l), t.bulletCurrent = o;
  const c = t.containerFlow(n, r);
  return t.bulletLastUsed = o, t.bulletCurrent = s, i(), c;
}
function $L(n) {
  const e = n.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function VL(n, e, t, r) {
  const i = $L(t);
  let s = t.bulletCurrent || Z5(t);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (t.options.incrementListMarker === !1 ? 0 : e.children.indexOf(n)) + s);
  let o = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || n.spread)) && (o = Math.ceil(o / 4) * 4);
  const l = t.createTracker(r);
  l.move(s + " ".repeat(o - s.length)), l.shift(o);
  const a = t.enter("listItem"), c = t.indentLines(
    t.containerFlow(n, l.current()),
    u
  );
  return a(), c;
  function u(h, f, d) {
    return f ? (d ? "" : " ".repeat(o)) + h : (d ? s : s + " ".repeat(o - s.length)) + h;
  }
}
function qL(n, e, t, r) {
  const i = t.enter("paragraph"), s = t.enter("phrasing"), o = t.containerPhrasing(n, r);
  return s(), i(), o;
}
const WL = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  t1([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function jL(n, e, t, r) {
  return (n.children.some(function(o) {
    return WL(o);
  }) ? t.containerPhrasing : t.containerFlow).call(t, n, r);
}
function UL(n) {
  const e = n.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
QS.peek = KL;
function QS(n, e, t, r) {
  const i = UL(t), s = t.enter("strong"), o = t.createTracker(r), l = o.move(i + i);
  let a = o.move(
    t.containerPhrasing(n, {
      after: i,
      before: l,
      ...o.current()
    })
  );
  const c = a.charCodeAt(0), u = em(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (a = al(c) + a.slice(1));
  const h = a.charCodeAt(a.length - 1), f = em(r.after.charCodeAt(0), h, i);
  f.inside && (a = a.slice(0, -1) + al(h));
  const d = o.move(i + i);
  return s(), t.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, l + a + d;
}
function KL(n, e, t) {
  return t.options.strong || "*";
}
function GL(n, e, t, r) {
  return t.safe(n.value, r);
}
function YL(n) {
  const e = n.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function JL(n, e, t) {
  const r = (ZS(t) + (t.options.ruleSpaces ? " " : "")).repeat(YL(t));
  return t.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Q5 = {
  blockquote: gL,
  break: g6,
  code: vL,
  definition: xL,
  emphasis: VS,
  hardBreak: g6,
  heading: DL,
  html: jS,
  image: US,
  imageReference: KS,
  inlineCode: GS,
  link: JS,
  linkReference: XS,
  list: HL,
  listItem: VL,
  paragraph: qL,
  root: jL,
  strong: QS,
  text: GL,
  thematicBreak: JL
}, XL = [ZL];
function ZL(n, e, t, r) {
  if (e.type === "code" && O4(e, r) && (n.type === "list" || n.type === e.type && O4(n, r)))
    return !1;
  if ("spread" in t && typeof t.spread == "boolean")
    return n.type === "paragraph" && // Two paragraphs.
    (n.type === e.type || e.type === "definition" || // Paragraph followed by a setext heading.
    e.type === "heading" && WS(e, r)) ? void 0 : t.spread ? 1 : 0;
}
const Nl = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
], QL = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: `
`,
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: Nl
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: !0, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)` },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: Nl
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: !0, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: !0, character: "*", after: `(?:[ 	\r
*])` },
  { character: "*", inConstruct: "phrasing", notInConstruct: Nl },
  // A plus sign could start a list item.
  { atBreak: !0, character: "+", after: `(?:[ 	\r
])` },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: !0, character: "-", after: `(?:[ 	\r
-])` },
  // A dot could start a list item.
  { atBreak: !0, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)` },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: Nl
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: !0, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: !0, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: !0, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: Nl },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: !0, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: Nl },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: !0, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: Nl },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: !0, character: "~" }
];
function eB(n) {
  return n.label || !n.identifier ? n.label || "" : LS(n.identifier);
}
function tB(n) {
  if (!n._compiled) {
    const e = (n.atBreak ? "[\\r\\n][\\t ]*" : "") + (n.before ? "(?:" + n.before + ")" : "");
    n._compiled = new RegExp(
      (e ? "(" + e + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(n.character) ? "\\" : "") + n.character + (n.after ? "(?:" + n.after + ")" : ""),
      "g"
    );
  }
  return n._compiled;
}
function nB(n, e, t) {
  const r = e.indexStack, i = n.children || [], s = [];
  let o = -1, l = t.before, a;
  r.push(-1);
  let c = e.createTracker(t);
  for (; ++o < i.length; ) {
    const u = i[o];
    let h;
    if (r[r.length - 1] = o, o + 1 < i.length) {
      let p = e.handle.handlers[i[o + 1].type];
      p && p.peek && (p = p.peek), h = p ? p(i[o + 1], n, e, {
        before: "",
        after: "",
        ...c.current()
      }).charAt(0) : "";
    } else
      h = t.after;
    s.length > 0 && (l === "\r" || l === `
`) && u.type === "html" && (s[s.length - 1] = s[s.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), l = " ", c = e.createTracker(t), c.move(s.join("")));
    let f = e.handle(u, n, e, {
      ...c.current(),
      after: h,
      before: l
    });
    a && a === f.slice(0, 1) && (f = al(a.charCodeAt(0)) + f.slice(1));
    const d = e.attentionEncodeSurroundingInfo;
    e.attentionEncodeSurroundingInfo = void 0, a = void 0, d && (s.length > 0 && d.before && l === s[s.length - 1].slice(-1) && (s[s.length - 1] = s[s.length - 1].slice(0, -1) + al(l.charCodeAt(0))), d.after && (a = h)), c.move(f), s.push(f), l = f.slice(-1);
  }
  return r.pop(), s.join("");
}
function rB(n, e, t) {
  const r = e.indexStack, i = n.children || [], s = e.createTracker(t), o = [];
  let l = -1;
  for (r.push(-1); ++l < i.length; ) {
    const a = i[l];
    r[r.length - 1] = l, o.push(
      s.move(
        e.handle(a, n, e, {
          before: `
`,
          after: `
`,
          ...s.current()
        })
      )
    ), a.type !== "list" && (e.bulletLastUsed = void 0), l < i.length - 1 && o.push(
      s.move(iB(a, i[l + 1], n, e))
    );
  }
  return r.pop(), o.join("");
}
function iB(n, e, t, r) {
  let i = r.join.length;
  for (; i--; ) {
    const s = r.join[i](n, e, t, r);
    if (s === !0 || s === 1)
      break;
    if (typeof s == "number")
      return `
`.repeat(1 + s);
    if (s === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const sB = /\r?\n|\r/g;
function oB(n, e) {
  const t = [];
  let r = 0, i = 0, s;
  for (; s = sB.exec(n); )
    o(n.slice(r, s.index)), t.push(s[0]), r = s.index + s[0].length, i++;
  return o(n.slice(r)), t.join("");
  function o(l) {
    t.push(e(l, i, !l));
  }
}
function lB(n, e, t) {
  const r = (t.before || "") + (e || "") + (t.after || ""), i = [], s = [], o = {};
  let l = -1;
  for (; ++l < n.unsafe.length; ) {
    const u = n.unsafe[l];
    if (!HS(n.stack, u))
      continue;
    const h = n.compilePattern(u);
    let f;
    for (; f = h.exec(r); ) {
      const d = "before" in u || !!u.atBreak, p = "after" in u, m = f.index + (d ? f[1].length : 0);
      i.includes(m) ? (o[m].before && !d && (o[m].before = !1), o[m].after && !p && (o[m].after = !1)) : (i.push(m), o[m] = { before: d, after: p });
    }
  }
  i.sort(aB);
  let a = t.before ? t.before.length : 0;
  const c = r.length - (t.after ? t.after.length : 0);
  for (l = -1; ++l < i.length; ) {
    const u = i[l];
    u < a || u >= c || u + 1 < c && i[l + 1] === u + 1 && o[u].after && !o[u + 1].before && !o[u + 1].after || i[l - 1] === u - 1 && o[u].before && !o[u - 1].before && !o[u - 1].after || (a !== u && s.push(y6(r.slice(a, u), "\\")), a = u, /[!-/:-@[-`{-~]/.test(r.charAt(u)) && (!t.encode || !t.encode.includes(r.charAt(u))) ? s.push("\\") : (s.push(al(r.charCodeAt(u))), a++));
  }
  return s.push(y6(r.slice(a, c), t.after)), s.join("");
}
function aB(n, e) {
  return n - e;
}
function y6(n, e) {
  const t = /\\(?=[!-/:-@[-`{-~])/g, r = [], i = [], s = n + e;
  let o = -1, l = 0, a;
  for (; a = t.exec(s); )
    r.push(a.index);
  for (; ++o < r.length; )
    l !== r[o] && i.push(n.slice(l, r[o])), i.push("\\"), l = r[o];
  return i.push(n.slice(l)), i.join("");
}
function cB(n) {
  const e = n || {}, t = e.now || {};
  let r = e.lineShift || 0, i = t.line || 1, s = t.column || 1;
  return { move: a, current: o, shift: l };
  function o() {
    return { now: { line: i, column: s }, lineShift: r };
  }
  function l(c) {
    r += c;
  }
  function a(c) {
    const u = c || "", h = u.split(/\r?\n|\r/g), f = h[h.length - 1];
    return i += h.length - 1, s = h.length === 1 ? s + f.length : 1 + f.length + r, u;
  }
}
function uB(n, e) {
  const t = e || {}, r = {
    associationId: eB,
    containerPhrasing: pB,
    containerFlow: mB,
    createTracker: cB,
    compilePattern: tB,
    enter: s,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...Q5 },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines: oB,
    indexStack: [],
    join: [...XL],
    options: {},
    safe: gB,
    stack: [],
    unsafe: [...QL]
  };
  FS(r, t), r.options.tightDefinitions && r.join.push(dB), r.handle = dL("type", {
    invalid: hB,
    unknown: fB,
    handlers: r.handlers
  });
  let i = r.handle(n, void 0, r, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  return i && i.charCodeAt(i.length - 1) !== 10 && i.charCodeAt(i.length - 1) !== 13 && (i += `
`), i;
  function s(o) {
    return r.stack.push(o), l;
    function l() {
      r.stack.pop();
    }
  }
}
function hB(n) {
  throw new Error("Cannot handle value `" + n + "`, expected node");
}
function fB(n) {
  const e = (
    /** @type {Nodes} */
    n
  );
  throw new Error("Cannot handle unknown node `" + e.type + "`");
}
function dB(n, e) {
  if (n.type === "definition" && n.type === e.type)
    return 0;
}
function pB(n, e) {
  return nB(n, this, e);
}
function mB(n, e) {
  return rB(n, this, e);
}
function gB(n, e) {
  return lB(this, n, e);
}
function D4(n) {
  const e = this;
  e.compiler = t;
  function t(r) {
    return uB(r, {
      ...e.data("settings"),
      ...n,
      // Note: this option is not in the readme.
      // The goal is for it to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("toMarkdownExtensions") || []
    });
  }
}
function b6(n) {
  if (n)
    throw n;
}
function yB(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Og, v6;
function bB() {
  if (v6) return Og;
  v6 = 1;
  var n = Object.prototype.hasOwnProperty, e = Object.prototype.toString, t = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : e.call(c) === "[object Array]";
  }, s = function(c) {
    if (!c || e.call(c) !== "[object Object]")
      return !1;
    var u = n.call(c, "constructor"), h = c.constructor && c.constructor.prototype && n.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !u && !h)
      return !1;
    var f;
    for (f in c)
      ;
    return typeof f > "u" || n.call(c, f);
  }, o = function(c, u) {
    t && u.name === "__proto__" ? t(c, u.name, {
      enumerable: !0,
      configurable: !0,
      value: u.newValue,
      writable: !0
    }) : c[u.name] = u.newValue;
  }, l = function(c, u) {
    if (u === "__proto__")
      if (n.call(c, u)) {
        if (r)
          return r(c, u).value;
      } else return;
    return c[u];
  };
  return Og = function a() {
    var c, u, h, f, d, p, m = arguments[0], g = 1, b = arguments.length, w = !1;
    for (typeof m == "boolean" && (w = m, m = arguments[1] || {}, g = 2), (m == null || typeof m != "object" && typeof m != "function") && (m = {}); g < b; ++g)
      if (c = arguments[g], c != null)
        for (u in c)
          h = l(m, u), f = l(c, u), m !== f && (w && f && (s(f) || (d = i(f))) ? (d ? (d = !1, p = h && i(h) ? h : []) : p = h && s(h) ? h : {}, o(m, { name: u, newValue: a(w, p, f) })) : typeof f < "u" && o(m, { name: u, newValue: f }));
    return m;
  }, Og;
}
var vB = bB();
const Eg = /* @__PURE__ */ yB(vB);
function N4(n) {
  if (typeof n != "object" || n === null)
    return !1;
  const e = Object.getPrototypeOf(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}
function wB() {
  const n = [], e = { run: t, use: r };
  return e;
  function t(...i) {
    let s = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    l(null, ...i);
    function l(a, ...c) {
      const u = n[++s];
      let h = -1;
      if (a) {
        o(a);
        return;
      }
      for (; ++h < i.length; )
        (c[h] === null || c[h] === void 0) && (c[h] = i[h]);
      i = c, u ? xB(u, l)(...c) : o(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return n.push(i), e;
  }
}
function xB(n, e) {
  let t;
  return r;
  function r(...o) {
    const l = n.length > o.length;
    let a;
    l && o.push(i);
    try {
      a = n.apply(this, o);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (l && t)
        throw u;
      return i(u);
    }
    l || (a && a.then && typeof a.then == "function" ? a.then(s, i) : a instanceof Error ? i(a) : s(a));
  }
  function i(o, ...l) {
    t || (t = !0, e(o, ...l));
  }
  function s(o) {
    i(null, o);
  }
}
class Nr extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(e, t, r) {
    super(), typeof t == "string" && (r = t, t = void 0);
    let i = "", s = {}, o = !1;
    if (t && ("line" in t && "column" in t ? s = { place: t } : "start" in t && "end" in t ? s = { place: t } : "type" in t ? s = {
      ancestors: [t],
      place: t.position
    } : s = { ...t }), typeof e == "string" ? i = e : !s.cause && e && (o = !0, i = e.message, s.cause = e), !s.ruleId && !s.source && typeof r == "string") {
      const a = r.indexOf(":");
      a === -1 ? s.ruleId = r : (s.source = r.slice(0, a), s.ruleId = r.slice(a + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const a = s.ancestors[s.ancestors.length - 1];
      a && (s.place = a.position);
    }
    const l = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = l ? l.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = l ? l.line : void 0, this.name = Fh(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = o && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
Nr.prototype.file = "";
Nr.prototype.name = "";
Nr.prototype.reason = "";
Nr.prototype.message = "";
Nr.prototype.stack = "";
Nr.prototype.column = void 0;
Nr.prototype.line = void 0;
Nr.prototype.ancestors = void 0;
Nr.prototype.cause = void 0;
Nr.prototype.fatal = void 0;
Nr.prototype.place = void 0;
Nr.prototype.ruleId = void 0;
Nr.prototype.source = void 0;
const ts = { basename: kB, dirname: SB, extname: CB, join: MB, sep: "/" };
function kB(n, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  od(n);
  let t = 0, r = -1, i = n.length, s;
  if (e === void 0 || e.length === 0 || e.length > n.length) {
    for (; i--; )
      if (n.codePointAt(i) === 47) {
        if (s) {
          t = i + 1;
          break;
        }
      } else r < 0 && (s = !0, r = i + 1);
    return r < 0 ? "" : n.slice(t, r);
  }
  if (e === n)
    return "";
  let o = -1, l = e.length - 1;
  for (; i--; )
    if (n.codePointAt(i) === 47) {
      if (s) {
        t = i + 1;
        break;
      }
    } else
      o < 0 && (s = !0, o = i + 1), l > -1 && (n.codePointAt(i) === e.codePointAt(l--) ? l < 0 && (r = i) : (l = -1, r = o));
  return t === r ? r = o : r < 0 && (r = n.length), n.slice(t, r);
}
function SB(n) {
  if (od(n), n.length === 0)
    return ".";
  let e = -1, t = n.length, r;
  for (; --t; )
    if (n.codePointAt(t) === 47) {
      if (r) {
        e = t;
        break;
      }
    } else r || (r = !0);
  return e < 0 ? n.codePointAt(0) === 47 ? "/" : "." : e === 1 && n.codePointAt(0) === 47 ? "//" : n.slice(0, e);
}
function CB(n) {
  od(n);
  let e = n.length, t = -1, r = 0, i = -1, s = 0, o;
  for (; e--; ) {
    const l = n.codePointAt(e);
    if (l === 47) {
      if (o) {
        r = e + 1;
        break;
      }
      continue;
    }
    t < 0 && (o = !0, t = e + 1), l === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1);
  }
  return i < 0 || t < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && i === t - 1 && i === r + 1 ? "" : n.slice(i, t);
}
function MB(...n) {
  let e = -1, t;
  for (; ++e < n.length; )
    od(n[e]), n[e] && (t = t === void 0 ? n[e] : t + "/" + n[e]);
  return t === void 0 ? "." : TB(t);
}
function TB(n) {
  od(n);
  const e = n.codePointAt(0) === 47;
  let t = AB(n, !e);
  return t.length === 0 && !e && (t = "."), t.length > 0 && n.codePointAt(n.length - 1) === 47 && (t += "/"), e ? "/" + t : t;
}
function AB(n, e) {
  let t = "", r = 0, i = -1, s = 0, o = -1, l, a;
  for (; ++o <= n.length; ) {
    if (o < n.length)
      l = n.codePointAt(o);
    else {
      if (l === 47)
        break;
      l = 47;
    }
    if (l === 47) {
      if (!(i === o - 1 || s === 1)) if (i !== o - 1 && s === 2) {
        if (t.length < 2 || r !== 2 || t.codePointAt(t.length - 1) !== 46 || t.codePointAt(t.length - 2) !== 46) {
          if (t.length > 2) {
            if (a = t.lastIndexOf("/"), a !== t.length - 1) {
              a < 0 ? (t = "", r = 0) : (t = t.slice(0, a), r = t.length - 1 - t.lastIndexOf("/")), i = o, s = 0;
              continue;
            }
          } else if (t.length > 0) {
            t = "", r = 0, i = o, s = 0;
            continue;
          }
        }
        e && (t = t.length > 0 ? t + "/.." : "..", r = 2);
      } else
        t.length > 0 ? t += "/" + n.slice(i + 1, o) : t = n.slice(i + 1, o), r = o - i - 1;
      i = o, s = 0;
    } else l === 46 && s > -1 ? s++ : s = -1;
  }
  return t;
}
function od(n) {
  if (typeof n != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(n)
    );
}
const OB = { cwd: EB };
function EB() {
  return "/";
}
function R4(n) {
  return !!(n !== null && typeof n == "object" && "href" in n && n.href && "protocol" in n && n.protocol && // @ts-expect-error: indexing is fine.
  n.auth === void 0);
}
function IB(n) {
  if (typeof n == "string")
    n = new URL(n);
  else if (!R4(n)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + n + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (n.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return DB(n);
}
function DB(n) {
  if (n.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = n.pathname;
  let t = -1;
  for (; ++t < e.length; )
    if (e.codePointAt(t) === 37 && e.codePointAt(t + 1) === 50) {
      const r = e.codePointAt(t + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(e);
}
const Ig = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class NB {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let t;
    e ? R4(e) ? t = { path: e } : typeof e == "string" || RB(e) ? t = { value: e } : t = e : t = {}, this.cwd = "cwd" in t ? "" : OB.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Ig.length; ) {
      const s = Ig[r];
      s in t && t[s] !== void 0 && t[s] !== null && (this[s] = s === "history" ? [...t[s]] : t[s]);
    }
    let i;
    for (i in t)
      Ig.includes(i) || (this[i] = t[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? ts.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(e) {
    Ng(e, "basename"), Dg(e, "basename"), this.path = ts.join(this.dirname || "", e);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? ts.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(e) {
    w6(this.basename, "dirname"), this.path = ts.join(e || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? ts.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(e) {
    if (Dg(e, "extname"), w6(this.dirname, "extname"), e) {
      if (e.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = ts.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(e) {
    R4(e) && (e = IB(e)), Ng(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? ts.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(e) {
    Ng(e, "stem"), Dg(e, "stem"), this.path = ts.join(this.dirname || "", e + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, t, r) {
    const i = this.message(e, t, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, t, r) {
    const i = this.message(e, t, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, t, r) {
    const i = new Nr(
      // @ts-expect-error: the overloads are fine.
      e,
      t,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value);
  }
}
function Dg(n, e) {
  if (n && n.includes(ts.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + ts.sep + "`"
    );
}
function Ng(n, e) {
  if (!n)
    throw new Error("`" + e + "` cannot be empty");
}
function w6(n, e) {
  if (!n)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function RB(n) {
  return !!(n && typeof n == "object" && "byteLength" in n && "byteOffset" in n);
}
const PB = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(n) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[n], s = function() {
      return i.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, r), s;
  })
), _B = {}.hasOwnProperty;
class e3 extends PB {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = wB();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const e = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new e3()
    );
    let t = -1;
    for (; ++t < this.attachers.length; ) {
      const r = this.attachers[t];
      e.use(...r);
    }
    return e.data(Eg(!0, {}, this.namespace)), e;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(e, t) {
    return typeof e == "string" ? arguments.length === 2 ? (_g("data", this.frozen), this.namespace[e] = t, this) : _B.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (_g("data", this.frozen), this.namespace = e, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const e = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [t, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = t.call(e, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(e) {
    this.freeze();
    const t = Kd(e), r = this.parser || this.Parser;
    return Rg("parse", r), r(String(t), t);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(e, t) {
    const r = this;
    return this.freeze(), Rg("process", this.parser || this.Parser), Pg("process", this.compiler || this.Compiler), t ? i(void 0, t) : new Promise(i);
    function i(s, o) {
      const l = Kd(e), a = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(l)
      );
      r.run(a, l, function(u, h, f) {
        if (u || !h || !f)
          return c(u);
        const d = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), p = r.stringify(d, f);
        BB(p) ? f.value = p : f.result = p, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          f
        );
      });
      function c(u, h) {
        u || !h ? o(u) : s ? s(h) : t(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(e) {
    let t = !1, r;
    return this.freeze(), Rg("processSync", this.parser || this.Parser), Pg("processSync", this.compiler || this.Compiler), this.process(e, i), k6("processSync", "process", t), r;
    function i(s, o) {
      t = !0, b6(s), r = o;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(e, t, r) {
    x6(e), this.freeze();
    const i = this.transformers;
    return !r && typeof t == "function" && (r = t, t = void 0), r ? s(void 0, r) : new Promise(s);
    function s(o, l) {
      const a = Kd(t);
      i.run(e, a, c);
      function c(u, h, f) {
        const d = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || e
        );
        u ? l(u) : o ? o(d) : r(void 0, d, f);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(e, t) {
    let r = !1, i;
    return this.run(e, t, s), k6("runSync", "run", r), i;
    function s(o, l) {
      b6(o), i = l, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(e, t) {
    this.freeze();
    const r = Kd(t), i = this.compiler || this.Compiler;
    return Pg("stringify", i), x6(e), i(e, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(e, ...t) {
    const r = this.attachers, i = this.namespace;
    if (_g("use", this.frozen), e != null) if (typeof e == "function")
      a(e, t);
    else if (typeof e == "object")
      Array.isArray(e) ? l(e) : o(e);
    else
      throw new TypeError("Expected usable value, not `" + e + "`");
    return this;
    function s(c) {
      if (typeof c == "function")
        a(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          a(u, h);
        } else
          o(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function o(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      l(c.plugins), c.settings && (i.settings = Eg(!0, i.settings, c.settings));
    }
    function l(c) {
      let u = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++u < c.length; ) {
          const h = c[u];
          s(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function a(c, u) {
      let h = -1, f = -1;
      for (; ++h < r.length; )
        if (r[h][0] === c) {
          f = h;
          break;
        }
      if (f === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [d, ...p] = u;
        const m = r[f][1];
        N4(m) && N4(d) && (d = Eg(!0, m, d)), r[f] = [c, d, ...p];
      }
    }
  }
}
const P4 = new e3().freeze();
function Rg(n, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + n + "` without `parser`");
}
function Pg(n, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + n + "` without `compiler`");
}
function _g(n, e) {
  if (e)
    throw new Error(
      "Cannot call `" + n + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function x6(n) {
  if (!N4(n) || typeof n.type != "string")
    throw new TypeError("Expected node, got `" + n + "`");
}
function k6(n, e, t) {
  if (!t)
    throw new Error(
      "`" + n + "` finished async. Use `" + e + "` instead"
    );
}
function Kd(n) {
  return LB(n) ? n : new NB(n);
}
function LB(n) {
  return !!(n && typeof n == "object" && "message" in n && "messages" in n);
}
function BB(n) {
  return typeof n == "string" || zB(n);
}
function zB(n) {
  return !!(n && typeof n == "object" && "byteLength" in n && "byteOffset" in n);
}
var eC = (n) => {
  throw TypeError(n);
}, tC = (n, e, t) => e.has(n) || eC("Cannot " + t), rt = (n, e, t) => (tC(n, e, "read from private field"), t ? t.call(n) : e.get(n)), fn = (n, e, t) => e.has(n) ? eC("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), $t = (n, e, t, r) => (tC(n, e, "write to private field"), e.set(n, t), t), Zi, Xu, j0, U0, K0, Zu, Qu, Hs, eh, G0, Y0, th, J0, nh, X0, Z0, Za, ql, Q0, rh;
class nC {
}
let rC = class {
  constructor() {
    this.elements = [], this.size = () => this.elements.length, this.top = () => this.elements.at(-1), this.push = (e) => {
      this.top()?.push(e);
    }, this.open = (e) => {
      this.elements.push(e);
    }, this.close = () => {
      const e = this.elements.pop();
      if (!e) throw rS();
      return e;
    };
  }
};
class t3 extends nC {
  constructor(e, t, r) {
    super(), this.type = e, this.content = t, this.attrs = r;
  }
  push(e, ...t) {
    this.content.push(e, ...t);
  }
  pop() {
    return this.content.pop();
  }
  static create(e, t, r) {
    return new t3(e, t, r);
  }
}
const _4 = class extends rC {
  /// @internal
  constructor(e) {
    super(), fn(this, Zi), fn(this, Xu), fn(this, j0), fn(this, U0), fn(this, K0), fn(this, Zu), fn(this, Qu), $t(this, Zi, nt.none), $t(this, Xu, (t) => t.isText), $t(this, j0, (t, r) => {
      if (rt(this, Xu).call(this, t) && rt(this, Xu).call(this, r) && nt.sameSet(t.marks, r.marks))
        return this.schema.text(t.text + r.text, t.marks);
    }), $t(this, U0, (t) => {
      const r = Object.values({
        ...this.schema.nodes,
        ...this.schema.marks
      }).find((i) => i.spec.parseMarkdown.match(t));
      if (!r) throw NR(t);
      return r;
    }), $t(this, K0, (t) => {
      const r = rt(this, U0).call(this, t);
      r.spec.parseMarkdown.runner(this, t, r);
    }), this.injectRoot = (t, r, i) => (this.openNode(r, i), this.next(t.children), this), this.openNode = (t, r) => (this.open(t3.create(t, [], r)), this), $t(this, Zu, () => {
      $t(this, Zi, nt.none);
      const t = this.close();
      return rt(this, Qu).call(this, t.type, t.attrs, t.content);
    }), this.closeNode = () => {
      try {
        rt(this, Zu).call(this);
      } catch (t) {
        console.error(t);
      }
      return this;
    }, $t(this, Qu, (t, r, i) => {
      const s = t.createAndFill(r, i, rt(this, Zi));
      if (!s) throw DR(t, r, i);
      return this.push(s), s;
    }), this.addNode = (t, r, i) => {
      try {
        rt(this, Qu).call(this, t, r, i);
      } catch (s) {
        console.error(s);
      }
      return this;
    }, this.openMark = (t, r) => {
      const i = t.create(r);
      return $t(this, Zi, i.addToSet(rt(this, Zi))), this;
    }, this.closeMark = (t) => ($t(this, Zi, t.removeFromSet(rt(this, Zi))), this), this.addText = (t) => {
      try {
        const r = this.top();
        if (!r) throw rS();
        const i = r.pop(), s = this.schema.text(t, rt(this, Zi));
        if (!i)
          return r.push(s), this;
        const o = rt(this, j0).call(this, i, s);
        return o ? (r.push(o), this) : (r.push(i, s), this);
      } catch (r) {
        return console.error(r), this;
      }
    }, this.build = () => {
      let t;
      do
        t = rt(this, Zu).call(this);
      while (this.size());
      return t;
    }, this.next = (t = []) => ([t].flat().forEach((r) => rt(this, K0).call(this, r)), this), this.toDoc = () => this.build(), this.run = (t, r) => {
      const i = t.runSync(
        t.parse(r),
        r
      );
      return this.next(i), this;
    }, this.schema = e;
  }
};
Zi = /* @__PURE__ */ new WeakMap();
Xu = /* @__PURE__ */ new WeakMap();
j0 = /* @__PURE__ */ new WeakMap();
U0 = /* @__PURE__ */ new WeakMap();
K0 = /* @__PURE__ */ new WeakMap();
Zu = /* @__PURE__ */ new WeakMap();
Qu = /* @__PURE__ */ new WeakMap();
_4.create = (n, e) => {
  const t = new _4(n);
  return (r) => (t.run(e, r), t.toDoc());
};
let FB = _4;
const L4 = class extends nC {
  constructor(e, t, r, i = {}) {
    super(), this.type = e, this.children = t, this.value = r, this.props = i, this.push = (s, ...o) => {
      this.children || (this.children = []), this.children.push(s, ...o);
    }, this.pop = () => this.children?.pop();
  }
};
L4.create = (n, e, t, r = {}) => new L4(n, e, t, r);
let S6 = L4;
const HB = (n) => Object.prototype.hasOwnProperty.call(n, "size"), B4 = class extends rC {
  /// @internal
  constructor(e) {
    super(), fn(this, Hs), fn(this, eh), fn(this, G0), fn(this, Y0), fn(this, th), fn(this, J0), fn(this, nh), fn(this, X0), fn(this, Z0), fn(this, Za), fn(this, ql), fn(this, Q0), fn(this, rh), $t(this, Hs, nt.none), $t(this, eh, (t) => {
      const r = Object.values({
        ...this.schema.nodes,
        ...this.schema.marks
      }).find((i) => i.spec.toMarkdown.match(t));
      if (!r) throw RR(t.type);
      return r;
    }), $t(this, G0, (t) => rt(this, eh).call(this, t).spec.toMarkdown.runner(this, t)), $t(this, Y0, (t, r) => rt(this, eh).call(this, t).spec.toMarkdown.runner(this, t, r)), $t(this, th, (t) => {
      const { marks: r } = t, i = (l) => l.type.spec.priority ?? 50;
      [...r].sort((l, a) => i(l) - i(a)).every((l) => !rt(this, Y0).call(this, l, t)) && rt(this, G0).call(this, t), r.forEach((l) => rt(this, rh).call(this, l));
    }), $t(this, J0, (t, r) => {
      if (t.type === r || t.children?.length !== 1) return t;
      const i = (a) => {
        if (a.type === r) return a;
        if (a.children?.length !== 1) return null;
        const [c] = a.children;
        return c ? i(c) : null;
      }, s = i(t);
      if (!s) return t;
      const o = s.children ? [...s.children] : void 0, l = { ...t, children: o };
      return l.children = o, s.children = [l], s;
    }), $t(this, nh, (t) => {
      const { children: r } = t;
      return r && (t.children = r.reduce((i, s, o) => {
        if (o === 0) return [s];
        const l = i.at(-1);
        if (l && l.isMark && s.isMark) {
          s = rt(this, J0).call(this, s, l.type);
          const { children: a, ...c } = s, { children: u, ...h } = l;
          if (s.type === l.type && a && u && JSON.stringify(c) === JSON.stringify(h)) {
            const f = {
              ...h,
              children: [...u, ...a]
            };
            return i.slice(0, -1).concat(rt(this, nh).call(this, f));
          }
        }
        return i.concat(s);
      }, [])), t;
    }), $t(this, X0, (t) => {
      const r = {
        ...t.props,
        type: t.type
      };
      return t.children && (r.children = t.children), t.value && (r.value = t.value), r;
    }), this.openNode = (t, r, i) => (this.open(S6.create(t, void 0, r, i)), this), $t(this, Z0, (t, r) => {
      let i = "", s = "";
      const o = t.children;
      let l = -1, a = -1;
      const c = (h) => {
        h && h.forEach((f, d) => {
          f.type === "text" && f.value && (l < 0 && (l = d), a = d);
        });
      };
      if (o) {
        c(o);
        const h = o?.[a], f = o?.[l];
        if (h && h.value.endsWith(" ")) {
          const d = h.value, p = d.trimEnd();
          s = d.slice(p.length), h.value = p;
        }
        if (f && f.value.startsWith(" ")) {
          const d = f.value, p = d.trimStart();
          i = d.slice(0, d.length - p.length), f.value = p;
        }
      }
      i.length && rt(this, ql).call(this, "text", void 0, i);
      const u = r();
      return s.length && rt(this, ql).call(this, "text", void 0, s), u;
    }), $t(this, Za, (t = !1) => {
      const r = this.close(), i = () => rt(this, ql).call(this, r.type, r.children, r.value, r.props);
      return t ? rt(this, Z0).call(this, r, i) : i();
    }), this.closeNode = () => (rt(this, Za).call(this), this), $t(this, ql, (t, r, i, s) => {
      const o = S6.create(t, r, i, s), l = rt(this, nh).call(this, rt(this, X0).call(this, o));
      return this.push(l), l;
    }), this.addNode = (t, r, i, s) => (rt(this, ql).call(this, t, r, i, s), this), $t(this, Q0, (t, r, i, s) => t.isInSet(rt(this, Hs)) ? this : ($t(this, Hs, t.addToSet(rt(this, Hs))), this.openNode(r, i, { ...s, isMark: !0 }))), $t(this, rh, (t) => {
      t.isInSet(rt(this, Hs)) && ($t(this, Hs, t.type.removeFromSet(rt(this, Hs))), rt(this, Za).call(this, !0));
    }), this.withMark = (t, r, i, s) => (rt(this, Q0).call(this, t, r, i, s), this), this.closeMark = (t) => (rt(this, rh).call(this, t), this), this.build = () => {
      let t = null;
      do
        t = rt(this, Za).call(this);
      while (this.size());
      return t;
    }, this.next = (t) => HB(t) ? (t.forEach((r) => {
      rt(this, th).call(this, r);
    }), this) : (rt(this, th).call(this, t), this), this.toString = (t) => t.stringify(this.build()), this.run = (t) => (this.next(t), this), this.schema = e;
  }
};
Hs = /* @__PURE__ */ new WeakMap();
eh = /* @__PURE__ */ new WeakMap();
G0 = /* @__PURE__ */ new WeakMap();
Y0 = /* @__PURE__ */ new WeakMap();
th = /* @__PURE__ */ new WeakMap();
J0 = /* @__PURE__ */ new WeakMap();
nh = /* @__PURE__ */ new WeakMap();
X0 = /* @__PURE__ */ new WeakMap();
Z0 = /* @__PURE__ */ new WeakMap();
Za = /* @__PURE__ */ new WeakMap();
ql = /* @__PURE__ */ new WeakMap();
Q0 = /* @__PURE__ */ new WeakMap();
rh = /* @__PURE__ */ new WeakMap();
B4.create = (n, e) => {
  const t = new B4(n);
  return (r) => (t.run(r), t.toString(e));
};
let $B = B4;
const iC = 65535, sC = Math.pow(2, 16);
function VB(n, e) {
  return n + e * sC;
}
function C6(n) {
  return n & iC;
}
function qB(n) {
  return (n - (n & iC)) / sC;
}
const oC = 1, lC = 2, ep = 4, aC = 8;
class z4 {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.delInfo = t, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & aC) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (oC | ep)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (lC | ep)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & ep) > 0;
  }
}
class Kr {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && Kr.empty)
      return Kr.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, r = C6(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + t + qB(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let a = this.ranges[l] - (this.inverted ? i : 0);
      if (a > e)
        break;
      let c = this.ranges[l + s], u = this.ranges[l + o], h = a + c;
      if (e <= h) {
        let f = c ? e == a ? -1 : e == h ? 1 : t : t, d = a + i + (f < 0 ? 0 : u);
        if (r)
          return d;
        let p = e == (t < 0 ? a : h) ? null : VB(l / 3, e - a), m = e == a ? lC : e == h ? oC : ep;
        return (t < 0 ? e != a : e != h) && (m |= aC), new z4(d, m, p);
      }
      i += u - c;
    }
    return r ? e + i : new z4(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let r = 0, i = C6(t), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let a = this.ranges[l] - (this.inverted ? r : 0);
      if (a > e)
        break;
      let c = this.ranges[l + s], u = a + c;
      if (e <= u && l == i * 3)
        return !0;
      r += this.ranges[l + o] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], l = o - (this.inverted ? s : 0), a = o + (this.inverted ? 0 : s), c = this.ranges[i + t], u = this.ranges[i + r];
      e(l, l + c, a, a + u), s += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Kr(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Kr.empty : new Kr(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Kr.empty = new Kr([]);
class vf {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, t, r = 0, i = e ? e.length : 0) {
    this.mirror = t, this.from = r, this.to = i, this._maps = e || [], this.ownData = !(e || t);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new vf(this._maps, this.mirror, e, t);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, r = this._maps.length; t < e._maps.length; t++) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t], i != null && i < t ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, r = this._maps.length + e._maps.length; t >= 0; t--) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t].invert(), i != null && i > t ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new vf();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this._maps[s], l = o.mapResult(e, t);
      if (l.recover != null) {
        let a = this.getMirror(s);
        if (a != null && a > s && a < this.to) {
          s = a, e = this._maps[a].recover(l.recover);
          continue;
        }
      }
      i |= l.delInfo, e = l.pos;
    }
    return r ? e : new z4(e, i, null);
  }
}
const Lg = /* @__PURE__ */ Object.create(null);
class Zn {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Kr.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = Lg[t.stepType];
    if (!r)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in Lg)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Lg[e] = t, t.prototype.jsonID = e, t;
  }
}
class pn {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new pn(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new pn(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, r, i) {
    try {
      return pn.ok(e.replace(t, r, i));
    } catch (s) {
      if (s instanceof Jp)
        return pn.fail(s.message);
      throw s;
    }
  }
}
function n3(n, e, t) {
  let r = [];
  for (let i = 0; i < n.childCount; i++) {
    let s = n.child(i);
    s.content.size && (s = s.copy(n3(s.content, e, s))), s.isInline && (s = e(s, t, i)), r.push(s);
  }
  return ce.fromArray(r);
}
class Xs extends Zn {
  /**
  Create a mark step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new me(n3(t.content, (o, l) => !o.isAtom || !l.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), t.openStart, t.openEnd);
    return pn.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new us(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Xs(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Xs && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Xs(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Xs(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("addMark", Xs);
class us extends Zn {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = new me(n3(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd);
    return pn.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Xs(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new us(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof us && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new us(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new us(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("removeMark", us);
class Go extends Zn {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return pn.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return pn.fromReplace(e, this.pos, this.pos + 1, new me(ce.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let r = this.mark.addToSet(t.marks);
      if (r.length == t.marks.length) {
        for (let i = 0; i < t.marks.length; i++)
          if (!t.marks[i].isInSet(r))
            return new Go(this.pos, t.marks[i]);
        return new Go(this.pos, this.mark);
      }
    }
    return new va(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Go(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Go(t.pos, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("addNodeMark", Go);
class va extends Zn {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return pn.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return pn.fromReplace(e, this.pos, this.pos + 1, new me(ce.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new Go(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new va(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new va(t.pos, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("removeNodeMark", va);
class Cn extends Zn {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, r, i = !1) {
    super(), this.from = e, this.to = t, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && F4(e, this.from, this.to) ? pn.fail("Structure replace would overwrite content") : pn.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Kr([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new Cn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deletedAcross && r.deletedAcross ? null : new Cn(t.pos, Math.max(t.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof Cn) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? me.empty : new me(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new Cn(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? me.empty : new me(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new Cn(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Cn(t.from, t.to, me.fromJSON(e, t.slice), !!t.structure);
  }
}
Zn.jsonID("replace", Cn);
class Gn extends Zn {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, r, i, s, o, l = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = l;
  }
  apply(e) {
    if (this.structure && (F4(e, this.from, this.gapFrom) || F4(e, this.gapTo, this.to)))
      return pn.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return pn.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, t.content);
    return r ? pn.fromReplace(e, this.from, this.to, r) : pn.fail("Content does not fit in gap");
  }
  getMap() {
    return new Kr([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new Gn(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return t.deletedAcross && r.deletedAcross || i < t.pos || s > r.pos ? null : new Gn(t.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Gn(t.from, t.to, t.gapFrom, t.gapTo, me.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
Zn.jsonID("replaceAround", Gn);
function F4(n, e, t) {
  let r = n.resolve(e), i = t - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function WB(n, e, t, r) {
  let i = [], s = [], o, l;
  n.doc.nodesBetween(e, t, (a, c, u) => {
    if (!a.isInline)
      return;
    let h = a.marks;
    if (!r.isInSet(h) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), d = Math.min(c + a.nodeSize, t), p = r.addToSet(h);
      for (let m = 0; m < h.length; m++)
        h[m].isInSet(p) || (o && o.to == f && o.mark.eq(h[m]) ? o.to = d : i.push(o = new us(f, d, h[m])));
      l && l.to == f ? l.to = d : s.push(l = new Xs(f, d, r));
    }
  }), i.forEach((a) => n.step(a)), s.forEach((a) => n.step(a));
}
function jB(n, e, t, r) {
  let i = [], s = 0;
  n.doc.nodesBetween(e, t, (o, l) => {
    if (!o.isInline)
      return;
    s++;
    let a = null;
    if (r instanceof Zm) {
      let c = o.marks, u;
      for (; u = r.isInSet(c); )
        (a || (a = [])).push(u), c = u.removeFromSet(c);
    } else r ? r.isInSet(o.marks) && (a = [r]) : a = o.marks;
    if (a && a.length) {
      let c = Math.min(l + o.nodeSize, t);
      for (let u = 0; u < a.length; u++) {
        let h = a[u], f;
        for (let d = 0; d < i.length; d++) {
          let p = i[d];
          p.step == s - 1 && h.eq(i[d].style) && (f = p);
        }
        f ? (f.to = c, f.step = s) : i.push({ style: h, from: Math.max(l, e), to: c, step: s });
      }
    }
  }), i.forEach((o) => n.step(new us(o.from, o.to, o.style)));
}
function r3(n, e, t, r = t.contentMatch, i = !0) {
  let s = n.doc.nodeAt(e), o = [], l = e + 1;
  for (let a = 0; a < s.childCount; a++) {
    let c = s.child(a), u = l + c.nodeSize, h = r.matchType(c.type);
    if (!h)
      o.push(new Cn(l, u, me.empty));
    else {
      r = h;
      for (let f = 0; f < c.marks.length; f++)
        t.allowsMarkType(c.marks[f].type) || n.step(new us(l, u, c.marks[f]));
      if (i && c.isText && t.whitespace != "pre") {
        let f, d = /\r?\n|\r/g, p;
        for (; f = d.exec(c.text); )
          p || (p = new me(ce.from(t.schema.text(" ", t.allowedMarks(c.marks))), 0, 0)), o.push(new Cn(l + f.index, l + f.index + f[0].length, p));
      }
    }
    l = u;
  }
  if (!r.validEnd) {
    let a = r.fillBefore(ce.empty, !0);
    n.replace(l, l, new me(a, 0, 0));
  }
  for (let a = o.length - 1; a >= 0; a--)
    n.step(o[a]);
}
function UB(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function r1(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let r = n.depth; ; --r) {
    let i = n.$from.node(r), s = n.$from.index(r), o = n.$to.indexAfter(r);
    if (r < n.depth && i.canReplace(s, o, t))
      return r;
    if (r == 0 || i.type.spec.isolating || !UB(i, s, o))
      break;
  }
  return null;
}
function KB(n, e, t) {
  let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), l = i.after(s + 1), a = o, c = l, u = ce.empty, h = 0;
  for (let p = s, m = !1; p > t; p--)
    m || r.index(p) > 0 ? (m = !0, u = ce.from(r.node(p).copy(u)), h++) : a--;
  let f = ce.empty, d = 0;
  for (let p = s, m = !1; p > t; p--)
    m || i.after(p + 1) < i.end(p) ? (m = !0, f = ce.from(i.node(p).copy(f)), d++) : c++;
  n.step(new Gn(a, c, o, l, new me(u.append(f), h, d), u.size - h, !0));
}
function i3(n, e, t = null, r = n) {
  let i = GB(n, e), s = i && YB(r, e);
  return s ? i.map(M6).concat({ type: e, attrs: t }).concat(s.map(M6)) : null;
}
function M6(n) {
  return { type: n, attrs: null };
}
function GB(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.contentMatchAt(r).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return t.canReplaceWith(r, i, o) ? s : null;
}
function YB(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.child(r), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let a = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let c = r; a && c < i; c++)
    a = a.matchType(t.child(c).type);
  return !a || !a.validEnd ? null : o;
}
function JB(n, e, t) {
  let r = ce.empty;
  for (let o = t.length - 1; o >= 0; o--) {
    if (r.size) {
      let l = t[o].type.contentMatch.matchFragment(r);
      if (!l || !l.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = ce.from(t[o].type.create(t[o].attrs, r));
  }
  let i = e.start, s = e.end;
  n.step(new Gn(i, s, i, s, new me(r, 0, 0), t.length, !0));
}
function XB(n, e, t, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = n.steps.length;
  n.doc.nodesBetween(e, t, (o, l) => {
    let a = typeof i == "function" ? i(o) : i;
    if (o.isTextblock && !o.hasMarkup(r, a) && ZB(n.doc, n.mapping.slice(s).map(l), r)) {
      let c = null;
      if (r.schema.linebreakReplacement) {
        let d = r.whitespace == "pre", p = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        d && !p ? c = !1 : !d && p && (c = !0);
      }
      c === !1 && uC(n, o, l, s), r3(n, n.mapping.slice(s).map(l, 1), r, void 0, c === null);
      let u = n.mapping.slice(s), h = u.map(l, 1), f = u.map(l + o.nodeSize, 1);
      return n.step(new Gn(h, f, h + 1, f - 1, new me(ce.from(r.create(a, null, o.marks)), 0, 0), 1, !0)), c === !0 && cC(n, o, l, s), !1;
    }
  });
}
function cC(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.isText) {
      let o, l = /\r?\n|\r/g;
      for (; o = l.exec(i.text); ) {
        let a = n.mapping.slice(r).map(t + 1 + s + o.index);
        n.replaceWith(a, a + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function uC(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = n.mapping.slice(r).map(t + 1 + s);
      n.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function ZB(n, e, t) {
  let r = n.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, t);
}
function QB(n, e, t, r, i) {
  let s = n.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  t || (t = s.type);
  let o = t.create(r, null, i || s.marks);
  if (s.isLeaf)
    return n.replaceWith(e, e + s.nodeSize, o);
  if (!t.validContent(s.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new Gn(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new me(ce.from(o), 0, 0), 1, !0));
}
function Hh(n, e, t = 1, r) {
  let i = n.resolve(e), s = i.depth - t, o = r && r[r.length - 1] || i.parent;
  if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let c = i.depth - 1, u = t - 2; c > s; c--, u--) {
    let h = i.node(c), f = i.index(c);
    if (h.type.spec.isolating)
      return !1;
    let d = h.content.cutByIndex(f, h.childCount), p = r && r[u + 1];
    p && (d = d.replaceChild(0, p.type.create(p.attrs)));
    let m = r && r[u] || h;
    if (!h.canReplace(f + 1, h.childCount) || !m.type.validContent(d))
      return !1;
  }
  let l = i.indexAfter(s), a = r && r[0];
  return i.node(s).canReplaceWith(l, l, a ? a.type : i.node(s + 1).type);
}
function ez(n, e, t = 1, r) {
  let i = n.doc.resolve(e), s = ce.empty, o = ce.empty;
  for (let l = i.depth, a = i.depth - t, c = t - 1; l > a; l--, c--) {
    s = ce.from(i.node(l).copy(s));
    let u = r && r[c];
    o = ce.from(u ? u.type.create(u.attrs, o) : i.node(l).copy(o));
  }
  n.step(new Cn(e, e, new me(s.append(o), t, t), !0));
}
function i1(n, e) {
  let t = n.resolve(e), r = t.index();
  return nz(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
}
function tz(n, e) {
  e.content.size || n.type.compatibleContent(e.type);
  let t = n.contentMatchAt(n.childCount), { linebreakReplacement: r } = n.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let s = e.child(i), o = s.type == r ? n.type.schema.nodes.text : s.type;
    if (t = t.matchType(o), !t || !n.type.allowsMarks(s.marks))
      return !1;
  }
  return t.validEnd;
}
function nz(n, e) {
  return !!(n && e && !n.isLeaf && tz(n, e));
}
function rz(n, e, t) {
  let r = null, { linebreakReplacement: i } = n.doc.type.schema, s = n.doc.resolve(e - t), o = s.node().type;
  if (i && o.inlineContent) {
    let u = o.whitespace == "pre", h = !!o.contentMatch.matchType(i);
    u && !h ? r = !1 : !u && h && (r = !0);
  }
  let l = n.steps.length;
  if (r === !1) {
    let u = n.doc.resolve(e + t);
    uC(n, u.node(), u.before(), l);
  }
  o.inlineContent && r3(n, e + t - 1, o, s.node().contentMatchAt(s.index()), r == null);
  let a = n.mapping.slice(l), c = a.map(e - t);
  if (n.step(new Cn(c, a.map(e + t, -1), me.empty, !0)), r === !0) {
    let u = n.doc.resolve(c);
    cC(n, u.node(), u.before(), n.steps.length);
  }
  return n;
}
function iz(n, e, t) {
  let r = n.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), t))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.before(i + 1);
      if (s > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.after(i + 1);
      if (s < r.node(i).childCount)
        return null;
    }
  return null;
}
function hC(n, e, t) {
  let r = n.resolve(e);
  if (!t.content.size)
    return e;
  let i = t.content;
  for (let s = 0; s < t.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let l = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, a = r.index(o) + (l > 0 ? 1 : 0), c = r.node(o), u = !1;
      if (s == 1)
        u = c.canReplace(a, a, i);
      else {
        let h = c.contentMatchAt(a).findWrapping(i.firstChild.type);
        u = h && c.canReplaceWith(a, a, h[0]);
      }
      if (u)
        return l == 0 ? r.pos : l < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function s1(n, e, t = e, r = me.empty) {
  if (e == t && !r.size)
    return null;
  let i = n.resolve(e), s = n.resolve(t);
  return fC(i, s, r) ? new Cn(e, t, r) : new sz(i, s, r).fit();
}
function fC(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class sz {
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = ce.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = ce.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, o = r.depth, l = i.depth;
    for (; o && l && s.childCount == 1; )
      s = s.firstChild.content, o--, l--;
    let a = new me(s, o, l);
    return e > -1 ? new Gn(r.pos, e, this.$to.pos, this.$to.end(), a, t) : a.size || r.pos != this.$to.pos ? new Cn(r.pos, i.pos, a) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = t.firstChild;
      if (t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      t = s.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = Bg(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let l = this.depth; l >= 0; l--) {
          let { type: a, match: c } = this.frontier[l], u, h = null;
          if (t == 1 && (o ? c.matchType(o.type) || (h = c.fillBefore(ce.from(o), !1)) : s && a.compatibleContent(s.type)))
            return { sliceDepth: r, frontierDepth: l, parent: s, inject: h };
          if (t == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: l, parent: s, wrap: u };
          if (s && c.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = Bg(e, t);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new me(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = Bg(e, t);
    if (i.childCount <= 1 && t > 0) {
      let s = e.size - t <= t + i.size;
      this.unplaced = new me(ih(e, t - 1, 1), t - 1, s ? t - 1 : r);
    } else
      this.unplaced = new me(ih(e, t, 1), t, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: s }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (s)
      for (let m = 0; m < s.length; m++)
        this.openFrontierNode(s[m]);
    let o = this.unplaced, l = r ? r.content : o.content, a = o.openStart - e, c = 0, u = [], { match: h, type: f } = this.frontier[t];
    if (i) {
      for (let m = 0; m < i.childCount; m++)
        u.push(i.child(m));
      h = h.matchFragment(i);
    }
    let d = l.size + e - (o.content.size - o.openEnd);
    for (; c < l.childCount; ) {
      let m = l.child(c), g = h.matchType(m.type);
      if (!g)
        break;
      c++, (c > 1 || a == 0 || m.content.size) && (h = g, u.push(dC(m.mark(f.allowedMarks(m.marks)), c == 1 ? a : 0, c == l.childCount ? d : -1)));
    }
    let p = c == l.childCount;
    p || (d = -1), this.placed = sh(this.placed, t, ce.from(u)), this.frontier[t].match = h, p && d < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let m = 0, g = l; m < d; m++) {
      let b = g.lastChild;
      this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), g = b.content;
    }
    this.unplaced = p ? e == 0 ? me.empty : new me(ih(o.content, e - 1, 1), e - 1, d < 0 ? o.openEnd : e - 1) : new me(ih(o.content, e, c), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !zg(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
      let { match: r, type: i } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = zg(e, t, i, r, s);
      if (o) {
        for (let l = t - 1; l >= 0; l--) {
          let { match: a, type: c } = this.frontier[l], u = zg(e, l, c, a, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: t, fit: o, move: s ? e.doc.resolve(e.after(t + 1)) : e };
      }
    }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = sh(this.placed, t.depth, t.fit)), e = t.move;
    for (let r = t.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, t = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = sh(this.placed, this.depth, ce.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(ce.empty, !0);
    t.childCount && (this.placed = sh(this.placed, this.frontier.length, t));
  }
}
function ih(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(ih(n.firstChild.content, e - 1, t)));
}
function sh(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(sh(n.lastChild.content, e - 1, t)));
}
function Bg(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function dC(n, e, t) {
  if (e <= 0)
    return n;
  let r = n.content;
  return e > 1 && (r = r.replaceChild(0, dC(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(ce.empty, !0)))), n.copy(r);
}
function zg(n, e, t, r, i) {
  let s = n.node(e), o = i ? n.indexAfter(e) : n.index(e);
  if (o == s.childCount && !t.compatibleContent(s.type))
    return null;
  let l = r.fillBefore(s.content, !0, o);
  return l && !oz(t, s.content, o) ? l : null;
}
function oz(n, e, t) {
  for (let r = t; r < e.childCount; r++)
    if (!n.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function lz(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function az(n, e, t, r) {
  if (!r.size)
    return n.deleteRange(e, t);
  let i = n.doc.resolve(e), s = n.doc.resolve(t);
  if (fC(i, s, r))
    return n.step(new Cn(e, t, r));
  let o = mC(i, n.doc.resolve(t));
  o[o.length - 1] == 0 && o.pop();
  let l = -(i.depth + 1);
  o.unshift(l);
  for (let f = i.depth, d = i.pos - 1; f > 0; f--, d--) {
    let p = i.node(f).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    o.indexOf(f) > -1 ? l = f : i.before(f) == d && o.splice(1, 0, -f);
  }
  let a = o.indexOf(l), c = [], u = r.openStart;
  for (let f = r.content, d = 0; ; d++) {
    let p = f.firstChild;
    if (c.push(p), d == r.openStart)
      break;
    f = p.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let d = c[f], p = lz(d.type);
    if (p && !d.sameMarkup(i.node(Math.abs(l) - 1)))
      u = f;
    else if (p || !d.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let d = (f + u + 1) % (r.openStart + 1), p = c[d];
    if (p)
      for (let m = 0; m < o.length; m++) {
        let g = o[(m + a) % o.length], b = !0;
        g < 0 && (b = !1, g = -g);
        let w = i.node(g - 1), k = i.index(g - 1);
        if (w.canReplaceWith(k, k, p.type, p.marks))
          return n.replace(i.before(g), b ? s.after(g) : t, new me(pC(r.content, 0, r.openStart, d), d, r.openEnd));
      }
  }
  let h = n.steps.length;
  for (let f = o.length - 1; f >= 0 && (n.replace(e, t, r), !(n.steps.length > h)); f--) {
    let d = o[f];
    d < 0 || (e = i.before(d), t = s.after(d));
  }
}
function pC(n, e, t, r, i) {
  if (e < t) {
    let s = n.firstChild;
    n = n.replaceChild(0, s.copy(pC(s.content, e + 1, t, r, s)));
  }
  if (e > r) {
    let s = i.contentMatchAt(0), o = s.fillBefore(n).append(n);
    n = o.append(s.matchFragment(o).fillBefore(ce.empty, !0));
  }
  return n;
}
function cz(n, e, t, r) {
  if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let i = iz(n.doc, e, r.type);
    i != null && (e = t = i);
  }
  n.replaceRange(e, t, new me(ce.from(r), 0, 0));
}
function uz(n, e, t) {
  let r = n.doc.resolve(e), i = n.doc.resolve(t), s = mC(r, i);
  for (let o = 0; o < s.length; o++) {
    let l = s[o], a = o == s.length - 1;
    if (a && l == 0 || r.node(l).type.contentMatch.validEnd)
      return n.delete(r.start(l), i.end(l));
    if (l > 0 && (a || r.node(l - 1).canReplace(r.index(l - 1), i.indexAfter(l - 1))))
      return n.delete(r.before(l), i.after(l));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && t > r.end(o) && i.end(o) - t != i.depth - o && r.start(o - 1) == i.start(o - 1) && r.node(o - 1).canReplace(r.index(o - 1), i.index(o - 1)))
      return n.delete(r.before(o), t);
  n.delete(e, t);
}
function mC(n, e) {
  let t = [], r = Math.min(n.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let s = n.start(i);
    if (s < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && t.push(i);
  }
  return t;
}
class mc extends Zn {
  /**
  Construct an attribute step.
  */
  constructor(e, t, r) {
    super(), this.pos = e, this.attr = t, this.value = r;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return pn.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in t.attrs)
      r[s] = t.attrs[s];
    r[this.attr] = this.value;
    let i = t.type.create(r, null, t.marks);
    return pn.fromReplace(e, this.pos, this.pos + 1, new me(ce.from(i), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return Kr.empty;
  }
  invert(e) {
    return new mc(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new mc(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new mc(t.pos, t.attr, t.value);
  }
}
Zn.jsonID("attr", mc);
class wf extends Zn {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      t[i] = e.attrs[i];
    t[this.attr] = this.value;
    let r = e.type.create(t, e.content, e.marks);
    return pn.ok(r);
  }
  getMap() {
    return Kr.empty;
  }
  invert(e) {
    return new wf(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new wf(t.attr, t.value);
  }
}
Zn.jsonID("docAttr", wf);
let Dc = class extends Error {
};
Dc = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
Dc.prototype = Object.create(Error.prototype);
Dc.prototype.constructor = Dc;
Dc.prototype.name = "TransformError";
class gC {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new vf();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new Dc(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, r = me.empty) {
    let i = s1(this.doc, e, t, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, r) {
    return this.replace(e, t, new me(ce.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, me.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, r) {
    return az(this, e, t, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, r) {
    return cz(this, e, t, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return uz(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return KB(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return rz(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return JB(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, r, i = null) {
    return XB(this, e, t, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, r = null, i) {
    return QB(this, e, t, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, r) {
    return this.step(new mc(e, t, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new wf(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new Go(e, t)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (t instanceof nt)
      t.isInSet(r.marks) && this.step(new va(e, t));
    else {
      let i = r.marks, s, o = [];
      for (; s = t.isInSet(i); )
        o.push(new va(e, s)), i = s.removeFromSet(i);
      for (let l = o.length - 1; l >= 0; l--)
        this.step(o[l]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, t = 1, r) {
    return ez(this, e, t, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, r) {
    return WB(this, e, t, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, r) {
    return jB(this, e, t, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, r) {
    return r3(this, e, t, r), this;
  }
}
const Fg = /* @__PURE__ */ Object.create(null);
class Ge {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, r) {
    this.$anchor = e, this.$head = t, this.ranges = r || [new yC(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = me.empty) {
    let r = t.content.lastChild, i = null;
    for (let l = 0; l < t.openEnd; l++)
      i = r, r = r.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let l = 0; l < o.length; l++) {
      let { $from: a, $to: c } = o[l], u = e.mapping.slice(s);
      e.replaceRange(u.map(a.pos), u.map(c.pos), l ? me.empty : t), l == 0 && O6(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let r = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: l } = i[s], a = e.mapping.slice(r), c = a.map(o.pos), u = a.map(l.pos);
      s ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, t), O6(e, r, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, r = !1) {
    let i = e.parent.inlineContent ? new Ee(e) : Qa(e.node(0), e.parent, e.pos, e.index(), t, r);
    if (i)
      return i;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = t < 0 ? Qa(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, r) : Qa(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, r);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new Er(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Qa(e, e, 0, 0, 1) || new Er(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Qa(e, e, e.content.size, e.childCount, -1) || new Er(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = Fg[t.type];
    if (!r)
      throw new RangeError(`No selection type ${t.type} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in Fg)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Fg[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Ee.between(this.$anchor, this.$head).getBookmark();
  }
}
Ge.prototype.visible = !0;
let yC = class {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}, T6 = !1;
function A6(n) {
  !T6 && !n.parent.inlineContent && (T6 = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class Ee extends Ge {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    A6(e), A6(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    if (!r.parent.inlineContent)
      return Ge.near(r);
    let i = e.resolve(t.map(this.anchor));
    return new Ee(i.parent.inlineContent ? i : r, r);
  }
  replace(e, t = me.empty) {
    if (super.replace(e, t), t == me.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof Ee && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new o1(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Ee(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, r = t) {
    let i = e.resolve(t);
    return new this(i, r == t ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, r) {
    let i = e.pos - t.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let s = Ge.findFrom(t, r, !0) || Ge.findFrom(t, -r, !0);
      if (s)
        t = s.$head;
      else
        return Ge.near(t, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = t : (e = (Ge.findFrom(e, -r, !0) || Ge.findFrom(e, r, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new Ee(e, t);
  }
}
Ge.jsonID("text", Ee);
class o1 {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new o1(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Ee.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class $e extends Ge {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, r), this.node = t;
  }
  map(e, t) {
    let { deleted: r, pos: i } = t.mapResult(this.anchor), s = e.resolve(i);
    return r ? Ge.near(s) : new $e(s);
  }
  content() {
    return new me(ce.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof $e && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new s3(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new $e(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new $e(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
$e.prototype.visible = !1;
Ge.jsonID("node", $e);
class s3 {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: r } = e.mapResult(this.anchor);
    return t ? new o1(r, r) : new s3(r);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), r = t.nodeAfter;
    return r && $e.isSelectable(r) ? new $e(t) : Ge.near(t);
  }
}
class Er extends Ge {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = me.empty) {
    if (t == me.empty) {
      e.delete(0, e.doc.content.size);
      let r = Ge.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Er(e);
  }
  map(e) {
    return new Er(e);
  }
  eq(e) {
    return e instanceof Er;
  }
  getBookmark() {
    return hz;
  }
}
Ge.jsonID("all", Er);
const hz = {
  map() {
    return this;
  },
  resolve(n) {
    return new Er(n);
  }
};
function Qa(n, e, t, r, i, s = !1) {
  if (e.inlineContent)
    return Ee.create(n, t);
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let l = e.child(o);
    if (l.isAtom) {
      if (!s && $e.isSelectable(l))
        return $e.create(n, t - (i < 0 ? l.nodeSize : 0));
    } else {
      let a = Qa(n, l, t + i, i < 0 ? l.childCount : 0, i, s);
      if (a)
        return a;
    }
    t += l.nodeSize * i;
  }
  return null;
}
function O6(n, e, t) {
  let r = n.steps.length - 1;
  if (r < e)
    return;
  let i = n.steps[r];
  if (!(i instanceof Cn || i instanceof Gn))
    return;
  let s = n.mapping.maps[r], o;
  s.forEach((l, a, c, u) => {
    o == null && (o = u);
  }), n.setSelection(Ge.near(n.doc.resolve(o), t));
}
const E6 = 1, Gd = 2, I6 = 4;
let fz = class extends gC {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | E6) & ~Gd, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & E6) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Gd, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return nt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Gd) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~Gd, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let r = this.selection;
    return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || nt.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, r) {
    let i = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = t), r = r ?? t, !e)
        return this.deleteRange(t, r);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(t);
        s = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(t, r, i.text(e, s)), this.selection.empty || this.setSelection(Ge.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= I6, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & I6) > 0;
  }
};
function D6(n, e) {
  return !e || !n ? n : n.bind(e);
}
class oh {
  constructor(e, t, r) {
    this.name = e, this.init = D6(t.init, r), this.apply = D6(t.apply, r);
  }
}
const dz = [
  new oh("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new oh("selection", {
    init(n, e) {
      return n.selection || Ge.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new oh("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, r) {
      return r.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new oh("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
let Hg = class {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = dz.slice(), t && t.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new oh(r.key, r.spec.state, r));
    });
  }
}, o3 = class lh {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != t) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let l = this.config.plugins[o];
        if (l.spec.appendTransaction) {
          let a = i ? i[o].n : 0, c = i ? i[o].state : this, u = a < t.length && l.spec.appendTransaction.call(l, a ? t.slice(a) : t, c, r);
          if (u && r.filterTransaction(u, o)) {
            if (u.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < o ? { state: r, n: t.length } : { state: this, n: 0 });
            }
            t.push(u), r = r.applyInner(u), s = !0;
          }
          i && (i[o] = { state: r, n: t.length });
        }
      }
      if (!s)
        return { state: r, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new lh(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let s = r[i];
      t[s.name] = s.apply(e, this[s.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new fz(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new Hg(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new lh(t);
    for (let i = 0; i < t.fields.length; i++)
      r[t.fields[i].name] = t.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new Hg(this.schema, e.plugins), r = t.fields, i = new lh(t);
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name;
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], s = i.spec.state;
        s && s.toJSON && (t[r] = s.toJSON.call(i, this[i.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, r) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new Hg(e.schema, e.plugins), s = new lh(i);
    return i.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = eo.fromJSON(e.schema, t.doc);
      else if (o.name == "selection")
        s.selection = Ge.fromJSON(s.doc, t.selection);
      else if (o.name == "storedMarks")
        t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let l in r) {
            let a = r[l], c = a.spec.state;
            if (a.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(t, l)) {
              s[o.name] = c.fromJSON.call(a, e, t[l], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
};
function bC(n, e, t) {
  for (let r in n) {
    let i = n[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = bC(i, e, {})), t[r] = i;
  }
  return t;
}
class Ut {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && bC(e.props, this, this.props), this.key = e.key ? e.key.key : vC("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const $g = /* @__PURE__ */ Object.create(null);
function vC(n) {
  return n in $g ? n + "$" + ++$g[n] : ($g[n] = 0, n + "$");
}
class en {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = vC(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const l3 = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function wC(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const xC = (n, e, t) => {
  let r = wC(n, t);
  if (!r)
    return !1;
  let i = a3(r);
  if (!i) {
    let o = r.blockRange(), l = o && r1(o);
    return l == null ? !1 : (e && e(n.tr.lift(o, l).scrollIntoView()), !0);
  }
  let s = i.nodeBefore;
  if (MC(n, i, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (Nc(s, "end") || $e.isSelectable(s)))
    for (let o = r.depth; ; o--) {
      let l = s1(n.doc, r.before(o), r.after(o), me.empty);
      if (l && l.slice.size < l.to - l.from) {
        if (e) {
          let a = n.tr.step(l);
          a.setSelection(Nc(s, "end") ? Ge.findFrom(a.doc.resolve(a.mapping.map(i.pos, -1)), -1) : $e.create(a.doc, i.pos - s.nodeSize)), e(a.scrollIntoView());
        }
        return !0;
      }
      if (o == 1 || r.node(o - 1).childCount > 1)
        break;
    }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, pz = (n, e, t) => {
  let r = wC(n, t);
  if (!r)
    return !1;
  let i = a3(r);
  return i ? mz(n, i, e) : !1;
};
function mz(n, e, t) {
  let r = e.nodeBefore, i = r, s = e.pos - 1;
  for (; !i.isTextblock; s--) {
    if (i.type.spec.isolating)
      return !1;
    let u = i.lastChild;
    if (!u)
      return !1;
    i = u;
  }
  let o = e.nodeAfter, l = o, a = e.pos + 1;
  for (; !l.isTextblock; a++) {
    if (l.type.spec.isolating)
      return !1;
    let u = l.firstChild;
    if (!u)
      return !1;
    l = u;
  }
  let c = s1(n.doc, s, a, me.empty);
  if (!c || c.from != s || c instanceof Cn && c.slice.size >= a - s)
    return !1;
  if (t) {
    let u = n.tr.step(c);
    u.setSelection(Ee.create(u.doc, s)), t(u.scrollIntoView());
  }
  return !0;
}
function Nc(n, e, t = !1) {
  for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (t && r.childCount != 1)
      return !1;
  }
  return !1;
}
const kC = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0)
      return !1;
    s = a3(r);
  }
  let o = s && s.nodeBefore;
  return !o || !$e.isSelectable(o) ? !1 : (e && e(n.tr.setSelection($e.create(n.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function a3(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function gz(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const yz = (n, e, t) => {
  let r = gz(n, t);
  if (!r)
    return !1;
  let i = SC(r);
  if (!i)
    return !1;
  let s = i.nodeAfter;
  if (MC(n, i, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (Nc(s, "start") || $e.isSelectable(s))) {
    let o = s1(n.doc, r.before(), r.after(), me.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let l = n.tr.step(o);
        l.setSelection(Nc(s, "start") ? Ge.findFrom(l.doc.resolve(l.mapping.map(i.pos)), 1) : $e.create(l.doc, l.mapping.map(i.pos))), e(l.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, bz = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size)
      return !1;
    s = SC(r);
  }
  let o = s && s.nodeAfter;
  return !o || !$e.isSelectable(o) ? !1 : (e && e(n.tr.setSelection($e.create(n.doc, s.pos)).scrollIntoView()), !0);
};
function SC(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const vz = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function c3(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const CC = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(r))
    return !1;
  let i = t.node(-1), s = t.indexAfter(-1), o = c3(i.contentMatchAt(s));
  if (!o || !i.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let l = t.after(), a = n.tr.replaceWith(l, l, o.createAndFill());
    a.setSelection(Ge.near(a.doc.resolve(l), 1)), e(a.scrollIntoView());
  }
  return !0;
}, wz = (n, e) => {
  let t = n.selection, { $from: r, $to: i } = t;
  if (t instanceof Er || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let s = c3(i.parent.contentMatchAt(i.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, l = n.tr.insert(o, s.createAndFill());
    l.setSelection(Ee.create(l.doc, o + 1)), e(l.scrollIntoView());
  }
  return !0;
}, xz = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let s = t.before();
    if (Hh(n.doc, s))
      return e && e(n.tr.split(s).scrollIntoView()), !0;
  }
  let r = t.blockRange(), i = r && r1(r);
  return i == null ? !1 : (e && e(n.tr.lift(r, i).scrollIntoView()), !0);
};
function kz(n) {
  return (e, t) => {
    let { $from: r, $to: i } = e.selection;
    if (e.selection instanceof $e && e.selection.node.isBlock)
      return !r.parentOffset || !Hh(e.doc, r.pos) ? !1 : (t && t(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let s = [], o, l, a = !1, c = !1;
    for (let d = r.depth; ; d--)
      if (r.node(d).isBlock) {
        a = r.end(d) == r.pos + (r.depth - d), c = r.start(d) == r.pos - (r.depth - d), l = c3(r.node(d - 1).contentMatchAt(r.indexAfter(d - 1))), s.unshift(a && l ? { type: l } : null), o = d;
        break;
      } else {
        if (d == 1)
          return !1;
        s.unshift(null);
      }
    let u = e.tr;
    (e.selection instanceof Ee || e.selection instanceof Er) && u.deleteSelection();
    let h = u.mapping.map(r.pos), f = Hh(u.doc, h, s.length, s);
    if (f || (s[0] = l ? { type: l } : null, f = Hh(u.doc, h, s.length, s)), !f)
      return !1;
    if (u.split(h, s.length, s), !a && c && r.node(o).type != l) {
      let d = u.mapping.map(r.before(o)), p = u.doc.resolve(d);
      l && r.node(o - 1).canReplaceWith(p.index(), p.index() + 1, l) && u.setNodeMarkup(u.mapping.map(r.before(o)), l);
    }
    return t && t(u.scrollIntoView()), !0;
  };
}
const Sz = kz(), Cz = (n, e) => (e && e(n.tr.setSelection(new Er(n.doc))), !0);
function Mz(n, e, t) {
  let r = e.nodeBefore, i = e.nodeAfter, s = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || i1(n.doc, e.pos)) ? !1 : (t && t(n.tr.join(e.pos).scrollIntoView()), !0);
}
function MC(n, e, t, r) {
  let i = e.nodeBefore, s = e.nodeAfter, o, l, a = i.type.spec.isolating || s.type.spec.isolating;
  if (!a && Mz(n, e, t))
    return !0;
  let c = !a && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (o = (l = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && l.matchType(o[0] || s.type).validEnd) {
    if (t) {
      let d = e.pos + s.nodeSize, p = ce.empty;
      for (let b = o.length - 1; b >= 0; b--)
        p = ce.from(o[b].create(null, p));
      p = ce.from(i.copy(p));
      let m = n.tr.step(new Gn(e.pos - 1, d, e.pos, d, new me(p, 1, 0), o.length, !0)), g = m.doc.resolve(d + 2 * o.length);
      g.nodeAfter && g.nodeAfter.type == i.type && i1(m.doc, g.pos) && m.join(g.pos), t(m.scrollIntoView());
    }
    return !0;
  }
  let u = s.type.spec.isolating || r > 0 && a ? null : Ge.findFrom(e, 1), h = u && u.$from.blockRange(u.$to), f = h && r1(h);
  if (f != null && f >= e.depth)
    return t && t(n.tr.lift(h, f).scrollIntoView()), !0;
  if (c && Nc(s, "start", !0) && Nc(i, "end")) {
    let d = i, p = [];
    for (; p.push(d), !d.isTextblock; )
      d = d.lastChild;
    let m = s, g = 1;
    for (; !m.isTextblock; m = m.firstChild)
      g++;
    if (d.canReplace(d.childCount, d.childCount, m.content)) {
      if (t) {
        let b = ce.empty;
        for (let k = p.length - 1; k >= 0; k--)
          b = ce.from(p[k].copy(b));
        let w = n.tr.step(new Gn(e.pos - p.length, e.pos + s.nodeSize, e.pos + g, e.pos + s.nodeSize - g, new me(b, p.length, 0), 0, !0));
        t(w.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function TC(n) {
  return function(e, t) {
    let r = e.selection, i = n < 0 ? r.$from : r.$to, s = i.depth;
    for (; i.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return i.node(s).isTextblock ? (t && t(e.tr.setSelection(Ee.create(e.doc, n < 0 ? i.start(s) : i.end(s)))), !0) : !1;
  };
}
const Tz = TC(-1), Az = TC(1);
function u3(n, e = null) {
  return function(t, r) {
    let { $from: i, $to: s } = t.selection, o = i.blockRange(s), l = o && i3(o, n, e);
    return l ? (r && r(t.tr.wrap(o, l).scrollIntoView()), !0) : !1;
  };
}
function xf(n, e = null) {
  return function(t, r) {
    let i = !1;
    for (let s = 0; s < t.selection.ranges.length && !i; s++) {
      let { $from: { pos: o }, $to: { pos: l } } = t.selection.ranges[s];
      t.doc.nodesBetween(o, l, (a, c) => {
        if (i)
          return !1;
        if (!(!a.isTextblock || a.hasMarkup(n, e)))
          if (a.type == n)
            i = !0;
          else {
            let u = t.doc.resolve(c), h = u.index();
            i = u.parent.canReplaceWith(h, h + 1, n);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let s = t.tr;
      for (let o = 0; o < t.selection.ranges.length; o++) {
        let { $from: { pos: l }, $to: { pos: a } } = t.selection.ranges[o];
        s.setBlockType(l, a, n, e);
      }
      r(s.scrollIntoView());
    }
    return !0;
  };
}
function Oz(n, e, t, r) {
  for (let i = 0; i < e.length; i++) {
    let { $from: s, $to: o } = e[i], l = s.depth == 0 ? n.inlineContent && n.type.allowsMarkType(t) : !1;
    if (n.nodesBetween(s.pos, o.pos, (a, c) => {
      if (l)
        return !1;
      l = a.inlineContent && a.type.allowsMarkType(t);
    }), l)
      return !0;
  }
  return !1;
}
function l1(n, e = null, t) {
  return function(r, i) {
    let { empty: s, $cursor: o, ranges: l } = r.selection;
    if (s && !o || !Oz(r.doc, l, n))
      return !1;
    if (i)
      if (o)
        n.isInSet(r.storedMarks || o.marks()) ? i(r.tr.removeStoredMark(n)) : i(r.tr.addStoredMark(n.create(e)));
      else {
        let a, c = r.tr;
        a = !l.some((u) => r.doc.rangeHasMark(u.$from.pos, u.$to.pos, n));
        for (let u = 0; u < l.length; u++) {
          let { $from: h, $to: f } = l[u];
          if (!a)
            c.removeMark(h.pos, f.pos, n);
          else {
            let d = h.pos, p = f.pos, m = h.nodeAfter, g = f.nodeBefore, b = m && m.isText ? /^\s*/.exec(m.text)[0].length : 0, w = g && g.isText ? /\s*$/.exec(g.text)[0].length : 0;
            d + b < p && (d += b, p -= w), c.addMark(d, p, n.create(e));
          }
        }
        i(c.scrollIntoView());
      }
    return !0;
  };
}
function Xc(...n) {
  return function(e, t, r) {
    for (let i = 0; i < n.length; i++)
      if (n[i](e, t, r))
        return !0;
    return !1;
  };
}
let Vg = Xc(l3, xC, kC), N6 = Xc(l3, yz, bz);
const Ks = {
  Enter: Xc(vz, wz, xz, Sz),
  "Mod-Enter": CC,
  Backspace: Vg,
  "Mod-Backspace": Vg,
  "Shift-Backspace": Vg,
  Delete: N6,
  "Mod-Delete": N6,
  "Mod-a": Cz
}, AC = {
  "Ctrl-h": Ks.Backspace,
  "Alt-Backspace": Ks["Mod-Backspace"],
  "Ctrl-d": Ks.Delete,
  "Ctrl-Alt-Backspace": Ks["Mod-Delete"],
  "Alt-Delete": Ks["Mod-Delete"],
  "Alt-d": Ks["Mod-Delete"],
  "Ctrl-a": Tz,
  "Ctrl-e": Az
};
for (let n in Ks)
  AC[n] = Ks[n];
const Ez = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform ? os.platform() == "darwin" : !1, Iz = Ez ? AC : Ks;
class Rr {
  /**
  Create an input rule. The rule applies when the user typed
  something and the text directly in front of the cursor matches
  `match`, which should end with `$`.
  
  The `handler` can be a string, in which case the matched text, or
  the first matched group in the regexp, is replaced by that
  string.
  
  Or a it can be a function, which will be called with the match
  array produced by
  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  as well as the start and end of the matched range, and which can
  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
  rule's effect, or null to indicate the input was not handled.
  */
  constructor(e, t, r = {}) {
    this.match = e, this.match = e, this.handler = typeof t == "string" ? Dz(t) : t, this.undoable = r.undoable !== !1, this.inCode = r.inCode || !1, this.inCodeMark = r.inCodeMark !== !1;
  }
}
function Dz(n) {
  return function(e, t, r, i) {
    let s = n;
    if (t[1]) {
      let o = t[0].lastIndexOf(t[1]);
      s += t[0].slice(o + t[1].length), r += o;
      let l = r - i;
      l > 0 && (s = t[0].slice(o - l, o) + s, r = i);
    }
    return e.tr.insertText(s, r, i);
  };
}
const Nz = (n, e) => {
  let t = n.plugins;
  for (let r = 0; r < t.length; r++) {
    let i = t[r], s;
    if (i.spec.isInputRules && (s = i.getState(n))) {
      if (e) {
        let o = n.tr, l = s.transform;
        for (let a = l.steps.length - 1; a >= 0; a--)
          o.step(l.steps[a].invert(l.docs[a]));
        if (s.text) {
          let a = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, n.schema.text(s.text, a));
        } else
          o.delete(s.from, s.to);
        e(o);
      }
      return !0;
    }
  }
  return !1;
};
new Rr(/--$/, "—", { inCodeMark: !1 });
new Rr(/\.\.\.$/, "…", { inCodeMark: !1 });
new Rr(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“", { inCodeMark: !1 });
new Rr(/"$/, "”", { inCodeMark: !1 });
new Rr(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘", { inCodeMark: !1 });
new Rr(/'$/, "’", { inCodeMark: !1 });
function h3(n, e, t = null, r) {
  return new Rr(n, (i, s, o, l) => {
    let a = t instanceof Function ? t(s) : t, c = i.tr.delete(o, l), u = c.doc.resolve(o), h = u.blockRange(), f = h && i3(h, e, a);
    if (!f)
      return null;
    c.wrap(h, f);
    let d = c.doc.resolve(o - 1).nodeBefore;
    return d && d.type == e && i1(c.doc, o - 1) && (!r || r(s, d)) && c.join(o - 1), c;
  });
}
function f3(n, e, t = null) {
  return new Rr(n, (r, i, s, o) => {
    let l = r.doc.resolve(s), a = t instanceof Function ? t(i) : t;
    return l.node(-1).canReplaceWith(l.index(-1), l.indexAfter(-1), e) ? r.tr.delete(s, o).setBlockType(s, s, e, a) : null;
  });
}
const cl = typeof navigator < "u" ? navigator : null, R6 = typeof document < "u" ? document : null, Sl = cl && cl.userAgent || "", H4 = /Edge\/(\d+)/.exec(Sl), OC = /MSIE \d/.exec(Sl), $4 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Sl), a1 = !!(OC || $4 || H4), Rz = OC ? document.documentMode : $4 ? +$4[1] : H4 ? +H4[1] : 0, EC = !a1 && /gecko\/(\d+)/i.test(Sl), Pz = EC && +(/Firefox\/(\d+)/.exec(Sl) || [0, 0])[1], V4 = !a1 && /Chrome\/(\d+)/.exec(Sl), _z = !!V4, Lz = V4 ? +V4[1] : 0, IC = !a1 && !!cl && /Apple Computer/.test(cl.vendor), DC = IC && (/Mobile\/\w+/.test(Sl) || !!cl && cl.maxTouchPoints > 2), Bz = DC || (cl ? /Mac/.test(cl.platform) : !1), zz = /Android \d/.test(Sl), NC = !!R6 && "webkitFontSmoothing" in R6.documentElement.style, Fz = NC ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
var Yd = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  android: zz,
  chrome: _z,
  chrome_version: Lz,
  gecko: EC,
  gecko_version: Pz,
  ie: a1,
  ie_version: Rz,
  ios: DC,
  mac: Bz,
  safari: IC,
  webkit: NC,
  webkit_version: Fz
});
function qg(n, e, t, r, i, s) {
  if (n.composing) return !1;
  const o = n.state, l = o.doc.resolve(e);
  if (l.parent.type.spec.code) return !1;
  const a = l.parent.textBetween(
    Math.max(0, l.parentOffset - 500),
    l.parentOffset,
    void 0,
    "￼"
  ) + r;
  for (let c of i) {
    const u = c, h = u.match.exec(a), f = h && h[0] && u.handler(o, h, e - (h[0].length - r.length), t);
    if (f)
      return u.undoable !== !1 && f.setMeta(s, { transform: f, from: e, to: t, text: r }), n.dispatch(f), !0;
  }
  return !1;
}
const Hz = new en("MILKDOWN_CUSTOM_INPUTRULES");
function $z({ rules: n }) {
  const e = new Ut({
    key: Hz,
    isInputRules: !0,
    state: {
      init() {
        return null;
      },
      apply(t, r) {
        const i = t.getMeta(this);
        return i || (t.selectionSet || t.docChanged ? null : r);
      }
    },
    props: {
      handleTextInput(t, r, i, s) {
        return qg(t, r, i, s, n, e);
      },
      handleDOMEvents: {
        compositionend: (t) => (setTimeout(() => {
          const { $cursor: r } = t.state.selection;
          r && qg(t, r.pos, r.pos, "", n, e);
        }), !1)
      },
      handleKeyDown(t, r) {
        if (r.key !== "Enter") return !1;
        const { $cursor: i } = t.state.selection;
        return i ? qg(t, i.pos, i.pos, `
`, n, e) : !1;
      }
    }
  });
  return e;
}
function ld(n, e, t = {}) {
  return new Rr(n, (r, i, s, o) => {
    var l, a, c, u;
    const { tr: h } = r, f = i.length;
    let d = i[f - 1], p = i[0], m = [], g = o;
    const b = {
      group: d,
      fullMatch: p,
      start: s,
      end: o
    }, w = (l = t.updateCaptured) == null ? void 0 : l.call(t, b);
    if (Object.assign(b, w), { group: d, fullMatch: p, start: s, end: o } = b, p === null || d?.trim() === "") return null;
    if (d) {
      const k = p.search(/\S/), C = s + p.indexOf(d), M = C + d.length;
      m = (a = h.storedMarks) != null ? a : [], M < o && h.delete(M, o), C > s && h.delete(s + k, C), g = s + k + d.length;
      const T = (c = t.getAttr) == null ? void 0 : c.call(t, i);
      h.addMark(s, g, e.create(T)), h.setStoredMarks(m), (u = t.beforeDispatch) == null || u.call(t, { match: i, start: s, end: o, tr: h });
    }
    return h;
  });
}
function Vz(n, e, t = {}) {
  return new Rr(n, (r, i, s, o) => {
    var l, a, c;
    const { tr: u } = r;
    let h = i[1], f = i[0];
    const d = {
      group: h,
      fullMatch: f,
      start: s,
      end: o
    }, p = (l = t.updateCaptured) == null ? void 0 : l.call(t, d);
    if (Object.assign(d, p), { group: h, fullMatch: f, start: s, end: o } = d, f === null || !h || h.trim() === "") return null;
    const m = (a = t.getAttr) == null ? void 0 : a.call(t, i), g = e.createAndFill(m);
    return g && (u.replaceRangeWith(
      e.isBlock ? u.doc.resolve(s).before() : s,
      o,
      g
    ), (c = t.beforeDispatch) == null || c.call(t, {
      match: [f, h ?? ""],
      start: s,
      end: o,
      tr: u
    })), u;
  });
}
var qz = Object.defineProperty, Wz = Object.defineProperties, jz = Object.getOwnPropertyDescriptors, P6 = Object.getOwnPropertySymbols, Uz = Object.prototype.hasOwnProperty, Kz = Object.prototype.propertyIsEnumerable, _6 = (n, e, t) => e in n ? qz(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Gz = (n, e) => {
  for (var t in e || (e = {}))
    Uz.call(e, t) && _6(n, t, e[t]);
  if (P6)
    for (var t of P6(e))
      Kz.call(e, t) && _6(n, t, e[t]);
  return n;
}, Yz = (n, e) => Wz(n, jz(e));
function L6(n = 0, e = 0, t = 0) {
  return Math.min(Math.max(n, e), t);
}
function c1(n, e, t) {
  const i = n.state.doc.content.size, s = L6(e, 0, i), o = L6(t, 0, i), l = n.coordsAtPos(s), a = n.coordsAtPos(o, -1), c = Math.min(l.top, a.top), u = Math.max(l.bottom, a.bottom), h = Math.min(l.left, a.left), f = Math.max(l.right, a.right), d = f - h, p = u - c, b = {
    top: c,
    bottom: u,
    left: h,
    right: f,
    width: d,
    height: p,
    x: h,
    y: c
  };
  return Yz(Gz({}, b), {
    toJSON: () => b
  });
}
function RC(n) {
  return Object.assign(Object.create(n), n).setTime(Date.now());
}
function Jz(n, e) {
  return Array.isArray(n) && n.includes(e.type) || e.type === n;
}
function PC(n) {
  if (n.content.childCount === 1) {
    const e = n.content.firstChild;
    if (e?.type.name === "text" && e.marks.length === 0) return e;
    if (e?.type.name === "paragraph" && e.childCount === 1) {
      const t = e.firstChild;
      if (t?.type.name === "text" && t.marks.length === 0) return t;
    }
  }
  return !1;
}
function gs(n) {
  return (e) => {
    for (let t = e.depth; t > 0; t -= 1) {
      const r = e.node(t);
      if (n(r)) {
        const i = e.before(t), s = e.after(t);
        return {
          from: i,
          to: s,
          node: r
        };
      }
    }
  };
}
function Xz(n, e) {
  return gs((t) => t.type === e)(n);
}
function Zz(n, e) {
  const t = e.nodes[n];
  if (!t) throw PR("node", n);
  return t;
}
function d3(n) {
  return (e) => {
    for (let t = e.depth; t > 0; t--) {
      const r = e.node(t);
      if (n(r))
        return {
          pos: t > 0 ? e.before(t) : 0,
          start: e.start(t),
          depth: t,
          node: r
        };
    }
  };
}
function Qz(n) {
  return (e) => d3(n)(e.$from);
}
function eF(n, e) {
  if (!(n instanceof $e)) return;
  const { node: t, $from: r } = n;
  if (Jz(e, t))
    return {
      node: t,
      pos: r.pos,
      start: r.start(r.depth),
      depth: r.depth
    };
}
const _C = (n, e) => {
  const { selection: t, doc: r } = n;
  if (t instanceof $e)
    return {
      hasNode: t.node.type === e,
      pos: t.from,
      target: t.node
    };
  const { from: i, to: s } = t;
  let o = !1, l = -1, a = null;
  return r.nodesBetween(i, s, (c, u) => a ? !1 : c.type === e ? (o = !0, l = u, a = c, !1) : !0), {
    hasNode: o,
    pos: l,
    target: a
  };
};
var oo = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, kf = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, tF = typeof navigator < "u" && /Mac/.test(navigator.platform), nF = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Pn = 0; Pn < 10; Pn++) oo[48 + Pn] = oo[96 + Pn] = String(Pn);
for (var Pn = 1; Pn <= 24; Pn++) oo[Pn + 111] = "F" + Pn;
for (var Pn = 65; Pn <= 90; Pn++)
  oo[Pn] = String.fromCharCode(Pn + 32), kf[Pn] = String.fromCharCode(Pn);
for (var Wg in oo) kf.hasOwnProperty(Wg) || (kf[Wg] = oo[Wg]);
function LC(n) {
  var e = tF && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || nF && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? kf : oo)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
const rF = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), iF = typeof navigator < "u" && /Win/.test(navigator.platform);
function sF(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let r, i, s, o;
  for (let l = 0; l < e.length - 1; l++) {
    let a = e[l];
    if (/^(cmd|meta|m)$/i.test(a))
      o = !0;
    else if (/^a(lt)?$/i.test(a))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(a))
      i = !0;
    else if (/^s(hift)?$/i.test(a))
      s = !0;
    else if (/^mod$/i.test(a))
      rF ? o = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + a);
  }
  return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Meta-" + t), s && (t = "Shift-" + t), t;
}
function oF(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[sF(t)] = n[t];
  return e;
}
function jg(n, e, t = !0) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
}
function BC(n) {
  return new Ut({ props: { handleKeyDown: p3(n) } });
}
function p3(n) {
  let e = oF(n);
  return function(t, r) {
    let i = LC(r), s, o = e[jg(i, r)];
    if (o && o(t.state, t.dispatch, t))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let l = e[jg(i, r, !1)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(iF && r.ctrlKey && r.altKey) && (s = oo[r.keyCode]) && s != i) {
        let l = e[jg(s, r)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const _n = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, Rc = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let q4 = null;
const js = function(n, e, t) {
  let r = q4 || (q4 = document.createRange());
  return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r;
}, lF = function() {
  q4 = null;
}, wa = function(n, e, t, r) {
  return t && (B6(n, e, t, r, -1) || B6(n, e, t, r, 1));
}, aF = /^(img|br|input|textarea|hr)$/i;
function B6(n, e, t, r, i) {
  for (var s; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : li(n))) {
      let o = n.parentNode;
      if (!o || o.nodeType != 1 || ad(n) || aF.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = _n(n) + (i < 0 ? 0 : 1), n = o;
    } else if (n.nodeType == 1) {
      let o = n.childNodes[e + (i < 0 ? -1 : 0)];
      if (o.nodeType == 1 && o.contentEditable == "false")
        if (!((s = o.pmViewDesc) === null || s === void 0) && s.ignoreForSelection)
          e += i;
        else
          return !1;
      else
        n = o, e = i < 0 ? li(n) : 0;
    } else
      return !1;
  }
}
function li(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function cF(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e - 1], e = li(n);
    } else if (n.parentNode && !ad(n))
      e = _n(n), n = n.parentNode;
    else
      return null;
  }
}
function uF(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e < n.nodeValue.length)
      return n;
    if (n.nodeType == 1 && e < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e], e = 0;
    } else if (n.parentNode && !ad(n))
      e = _n(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
function hF(n, e, t) {
  for (let r = e == 0, i = e == li(n); r || i; ) {
    if (n == t)
      return !0;
    let s = _n(n);
    if (n = n.parentNode, !n)
      return !1;
    r = r && s == 0, i = i && s == li(n);
  }
}
function ad(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const u1 = function(n) {
  return n.focusNode && wa(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function Yl(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function fF(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function dF(n, e, t) {
  if (n.caretPositionFromPoint)
    try {
      let r = n.caretPositionFromPoint(e, t);
      if (r)
        return { node: r.offsetNode, offset: Math.min(li(r.offsetNode), r.offset) };
    } catch {
    }
  if (n.caretRangeFromPoint) {
    let r = n.caretRangeFromPoint(e, t);
    if (r)
      return { node: r.startContainer, offset: Math.min(li(r.startContainer), r.startOffset) };
  }
}
const vs = typeof navigator < "u" ? navigator : null, z6 = typeof document < "u" ? document : null, Cl = vs && vs.userAgent || "", W4 = /Edge\/(\d+)/.exec(Cl), zC = /MSIE \d/.exec(Cl), j4 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Cl), Ir = !!(zC || j4 || W4), nl = zC ? document.documentMode : j4 ? +j4[1] : W4 ? +W4[1] : 0, di = !Ir && /gecko\/(\d+)/i.test(Cl);
di && +(/Firefox\/(\d+)/.exec(Cl) || [0, 0])[1];
const U4 = !Ir && /Chrome\/(\d+)/.exec(Cl), Kn = !!U4, FC = U4 ? +U4[1] : 0, fr = !Ir && !!vs && /Apple Computer/.test(vs.vendor), Pc = fr && (/Mobile\/\w+/.test(Cl) || !!vs && vs.maxTouchPoints > 2), ii = Pc || (vs ? /Mac/.test(vs.platform) : !1), pF = vs ? /Win/.test(vs.platform) : !1, Zs = /Android \d/.test(Cl), cd = !!z6 && "webkitFontSmoothing" in z6.documentElement.style, mF = cd ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function gF(n) {
  let e = n.defaultView && n.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function Ls(n, e) {
  return typeof n == "number" ? n : n[e];
}
function yF(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * r
  };
}
function F6(n, e, t) {
  let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, s = n.dom.ownerDocument;
  for (let o = t || n.dom; o; ) {
    if (o.nodeType != 1) {
      o = Rc(o);
      continue;
    }
    let l = o, a = l == s.body, c = a ? gF(s) : yF(l), u = 0, h = 0;
    if (e.top < c.top + Ls(r, "top") ? h = -(c.top - e.top + Ls(i, "top")) : e.bottom > c.bottom - Ls(r, "bottom") && (h = e.bottom - e.top > c.bottom - c.top ? e.top + Ls(i, "top") - c.top : e.bottom - c.bottom + Ls(i, "bottom")), e.left < c.left + Ls(r, "left") ? u = -(c.left - e.left + Ls(i, "left")) : e.right > c.right - Ls(r, "right") && (u = e.right - c.right + Ls(i, "right")), u || h)
      if (a)
        s.defaultView.scrollBy(u, h);
      else {
        let d = l.scrollLeft, p = l.scrollTop;
        h && (l.scrollTop += h), u && (l.scrollLeft += u);
        let m = l.scrollLeft - d, g = l.scrollTop - p;
        e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g };
      }
    let f = a ? "fixed" : getComputedStyle(o).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    o = f == "absolute" ? o.offsetParent : Rc(o);
  }
}
function bF(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i;
  for (let s = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let l = n.root.elementFromPoint(s, o);
    if (!l || l == n.dom || !n.dom.contains(l))
      continue;
    let a = l.getBoundingClientRect();
    if (a.top >= t - 20) {
      r = l, i = a.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: HC(n.dom) };
}
function HC(n) {
  let e = [], t = n.ownerDocument;
  for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = Rc(r))
    ;
  return e;
}
function vF({ refDOM: n, refTop: e, stack: t }) {
  let r = n ? n.getBoundingClientRect().top : 0;
  $C(t, r == 0 ? 0 : r - e);
}
function $C(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: r, top: i, left: s } = n[t];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s);
  }
}
let Ka = null;
function wF(n) {
  if (n.setActive)
    return n.setActive();
  if (Ka)
    return n.focus(Ka);
  let e = HC(n);
  n.focus(Ka == null ? {
    get preventScroll() {
      return Ka = { preventScroll: !0 }, !0;
    }
  } : void 0), Ka || (Ka = !1, $C(e, 0));
}
function VC(n, e) {
  let t, r = 2e8, i, s = 0, o = e.top, l = e.top, a, c;
  for (let u = n.firstChild, h = 0; u; u = u.nextSibling, h++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = js(u).getClientRects();
    else
      continue;
    for (let d = 0; d < f.length; d++) {
      let p = f[d];
      if (p.top <= o && p.bottom >= l) {
        o = Math.max(p.bottom, o), l = Math.min(p.top, l);
        let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
        if (m < r) {
          t = u, r = m, i = m && t.nodeType == 3 ? {
            left: p.right < e.left ? p.right : p.left,
            top: e.top
          } : e, u.nodeType == 1 && m && (s = h + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
          continue;
        }
      } else p.top > e.top && !a && p.left <= e.left && p.right >= e.left && (a = u, c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top });
      !t && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (s = h + 1);
    }
  }
  return !t && a && (t = a, i = c, r = 0), t && t.nodeType == 3 ? xF(t, i) : !t || r && t.nodeType == 1 ? { node: n, offset: s } : VC(t, i);
}
function xF(n, e) {
  let t = n.nodeValue.length, r = document.createRange();
  for (let i = 0; i < t; i++) {
    r.setEnd(n, i + 1), r.setStart(n, i);
    let s = Ro(r, 1);
    if (s.top != s.bottom && m3(e, s))
      return { node: n, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function m3(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function kF(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function SF(n, e, t) {
  let { node: r, offset: i } = VC(e, t), s = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect();
    s = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(r, i, s);
}
function CF(n, e, t, r) {
  let i = -1;
  for (let s = e, o = !1; s != n.dom; ) {
    let l = n.docView.nearestDesc(s, !0), a;
    if (!l)
      return null;
    if (l.dom.nodeType == 1 && (l.node.isBlock && l.parent || !l.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((a = l.dom.getBoundingClientRect()).width || a.height) && (l.node.isBlock && l.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(l.dom.nodeName) && (!o && a.left > r.left || a.top > r.top ? i = l.posBefore : (!o && a.right < r.left || a.bottom < r.top) && (i = l.posAfter), o = !0), !l.contentDOM && i < 0 && !l.node.isText))
      return (l.node.isBlock ? r.top < (a.top + a.bottom) / 2 : r.left < (a.left + a.right) / 2) ? l.posBefore : l.posAfter;
    s = l.dom.parentNode;
  }
  return i > -1 ? i : n.docView.posFromDOM(e, t, -1);
}
function qC(n, e, t) {
  let r = n.childNodes.length;
  if (r && t.top < t.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = i; ; ) {
      let o = n.childNodes[s];
      if (o.nodeType == 1) {
        let l = o.getClientRects();
        for (let a = 0; a < l.length; a++) {
          let c = l[a];
          if (m3(e, c))
            return qC(o, e, c);
        }
      }
      if ((s = (s + 1) % r) == i)
        break;
    }
  return n;
}
function MF(n, e) {
  let t = n.dom.ownerDocument, r, i = 0, s = dF(t, e.left, e.top);
  s && ({ node: r, offset: i } = s);
  let o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), l;
  if (!o || !n.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = n.dom.getBoundingClientRect();
    if (!m3(e, c) || (o = qC(n.dom, e, c), !o))
      return null;
  }
  if (fr)
    for (let c = o; r && c; c = Rc(c))
      c.draggable && (r = void 0);
  if (o = kF(o, e), r) {
    if (di && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let u = r.childNodes[i], h;
      u.nodeName == "IMG" && (h = u.getBoundingClientRect()).right <= e.left && h.bottom > e.top && i++;
    }
    let c;
    cd && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--, r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? l = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (l = CF(n, r, i, e));
  }
  l == null && (l = SF(n, o, e));
  let a = n.docView.nearestDesc(o, !0);
  return { pos: l, inside: a ? a.posAtStart - a.border : -1 };
}
function H6(n) {
  return n.top < n.bottom || n.left < n.right;
}
function Ro(n, e) {
  let t = n.getClientRects();
  if (t.length) {
    let r = t[e < 0 ? 0 : t.length - 1];
    if (H6(r))
      return r;
  }
  return Array.prototype.find.call(t, H6) || n.getBoundingClientRect();
}
const TF = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function WC(n, e, t) {
  let { node: r, offset: i, atom: s } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = cd || di;
  if (r.nodeType == 3)
    if (o && (TF.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) {
      let a = Ro(js(r, i, i), t);
      if (di && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let c = Ro(js(r, i - 1, i - 1), -1);
        if (c.top == a.top) {
          let u = Ro(js(r, i, i + 1), -1);
          if (u.top != a.top)
            return Ru(u, u.left < c.left);
        }
      }
      return a;
    } else {
      let a = i, c = i, u = t < 0 ? 1 : -1;
      return t < 0 && !i ? (c++, u = -1) : t >= 0 && i == r.nodeValue.length ? (a--, u = 1) : t < 0 ? a-- : c++, Ru(Ro(js(r, a, c), u), u < 0);
    }
  if (!n.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (t < 0 || i == li(r))) {
      let a = r.childNodes[i - 1];
      if (a.nodeType == 1)
        return Ug(a.getBoundingClientRect(), !1);
    }
    if (s == null && i < li(r)) {
      let a = r.childNodes[i];
      if (a.nodeType == 1)
        return Ug(a.getBoundingClientRect(), !0);
    }
    return Ug(r.getBoundingClientRect(), t >= 0);
  }
  if (s == null && i && (t < 0 || i == li(r))) {
    let a = r.childNodes[i - 1], c = a.nodeType == 3 ? js(a, li(a) - (o ? 0 : 1)) : a.nodeType == 1 && (a.nodeName != "BR" || !a.nextSibling) ? a : null;
    if (c)
      return Ru(Ro(c, 1), !1);
  }
  if (s == null && i < li(r)) {
    let a = r.childNodes[i];
    for (; a.pmViewDesc && a.pmViewDesc.ignoreForCoords; )
      a = a.nextSibling;
    let c = a ? a.nodeType == 3 ? js(a, 0, o ? 0 : 1) : a.nodeType == 1 ? a : null : null;
    if (c)
      return Ru(Ro(c, -1), !0);
  }
  return Ru(Ro(r.nodeType == 3 ? js(r) : r, -t), t >= 0);
}
function Ru(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function Ug(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function jC(n, e, t) {
  let r = n.state, i = n.root.activeElement;
  r != e && n.updateState(e), i != n.dom && n.focus();
  try {
    return t();
  } finally {
    r != e && n.updateState(r), i != n.dom && i && i.focus();
  }
}
function AF(n, e, t) {
  let r = e.selection, i = t == "up" ? r.$from : r.$to;
  return jC(n, e, () => {
    let { node: s } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let l = n.docView.nearestDesc(s, !0);
      if (!l)
        break;
      if (l.node.isBlock) {
        s = l.contentDOM || l.dom;
        break;
      }
      s = l.dom.parentNode;
    }
    let o = WC(n, i.pos, 1);
    for (let l = s.firstChild; l; l = l.nextSibling) {
      let a;
      if (l.nodeType == 1)
        a = l.getClientRects();
      else if (l.nodeType == 3)
        a = js(l, 0, l.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < a.length; c++) {
        let u = a[c];
        if (u.bottom > u.top + 1 && (t == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const OF = /[\u0590-\u08ac]/;
function EF(n, e, t) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, s = !i, o = i == r.parent.content.size, l = n.domSelection();
  return l ? !OF.test(r.parent.textContent) || !l.modify ? t == "left" || t == "backward" ? s : o : jC(n, e, () => {
    let { focusNode: a, focusOffset: c, anchorNode: u, anchorOffset: h } = n.domSelectionRange(), f = l.caretBidiLevel;
    l.modify("move", t, "character");
    let d = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: p, focusOffset: m } = n.domSelectionRange(), g = p && !d.contains(p.nodeType == 1 ? p : p.parentNode) || a == p && c == m;
    try {
      l.collapse(u, h), a && (a != u || c != h) && l.extend && l.extend(a, c);
    } catch {
    }
    return f != null && (l.caretBidiLevel = f), g;
  }) : r.pos == r.start() || r.pos == r.end();
}
let $6 = null, V6 = null, q6 = !1;
function IF(n, e, t) {
  return $6 == e && V6 == t ? q6 : ($6 = e, V6 = t, q6 = t == "up" || t == "down" ? AF(n, e, t) : EF(n, e, t));
}
const pi = 0, W6 = 1, Zl = 2, ws = 3;
class ud {
  constructor(e, t, r, i) {
    this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = pi, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, r = this.posAtStart; ; t++) {
      let i = this.children[t];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = t > _n(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (i == null && t == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i), o;
      if (s && (!t || s.node))
        if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          r = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let r = t; r; r = r.parent)
      if (r == this)
        return t;
  }
  posFromDOM(e, t, r) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i);
      if (s)
        return s.localPosFromDOM(e, t, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, r = 0; t < this.children.length; t++) {
      let i = this.children[t], s = r + i.size;
      if (r == e && s != r) {
        for (; !i.border && i.children.length; )
          for (let o = 0; o < i.children.length; o++) {
            let l = i.children[o];
            if (l.size) {
              i = l;
              break;
            }
          }
        return i;
      }
      if (e < s)
        return i.descAt(e - r - i.border);
      r = s;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r], l = s + o.size;
      if (l > e || o instanceof KC) {
        i = e - s;
        break;
      }
      s = l;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, t);
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof UC && s.side >= 0; r--)
      ;
    if (t <= 0) {
      let s, o = !0;
      for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = !1)
        ;
      return s && t && o && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : { node: this.contentDOM, offset: s ? _n(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, t) : { node: this.contentDOM, offset: s ? _n(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, s = -1;
    for (let o = r, l = 0; ; l++) {
      let a = this.children[l], c = o + a.size;
      if (i == -1 && e <= c) {
        let u = o + a.border;
        if (e >= u && t <= c - a.border && a.node && a.contentDOM && this.contentDOM.contains(a.contentDOM))
          return a.parseRange(e, t, u);
        e = o;
        for (let h = l; h > 0; h--) {
          let f = this.children[h - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            i = _n(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (c > t || l == this.children.length - 1)) {
        t = c;
        for (let u = l + 1; u < this.children.length; u++) {
          let h = this.children[u];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            s = _n(h.dom);
            break;
          }
          t += h.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = c;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: r } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || r == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, r, i = !1) {
    let s = Math.min(e, t), o = Math.max(e, t);
    for (let d = 0, p = 0; d < this.children.length; d++) {
      let m = this.children[d], g = p + m.size;
      if (s > p && o < g)
        return m.setSelection(e - p - m.border, t - p - m.border, r, i);
      p = g;
    }
    let l = this.domFromPos(e, e ? -1 : 1), a = t == e ? l : this.domFromPos(t, t ? -1 : 1), c = r.root.getSelection(), u = r.domSelectionRange(), h = !1;
    if ((di || fr) && e == t) {
      let { node: d, offset: p } = l;
      if (d.nodeType == 3) {
        if (h = !!(p && d.nodeValue[p - 1] == `
`), h && p == d.nodeValue.length)
          for (let m = d, g; m; m = m.parentNode) {
            if (g = m.nextSibling) {
              g.nodeName == "BR" && (l = a = { node: g.parentNode, offset: _n(g) + 1 });
              break;
            }
            let b = m.pmViewDesc;
            if (b && b.node && b.node.isBlock)
              break;
          }
      } else {
        let m = d.childNodes[p - 1];
        h = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (di && u.focusNode && u.focusNode != a.node && u.focusNode.nodeType == 1) {
      let d = u.focusNode.childNodes[u.focusOffset];
      d && d.contentEditable == "false" && (i = !0);
    }
    if (!(i || h && fr) && wa(l.node, l.offset, u.anchorNode, u.anchorOffset) && wa(a.node, a.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == t) && !(h && di)) {
      c.collapse(l.node, l.offset);
      try {
        e != t && c.extend(a.node, a.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > t) {
        let p = l;
        l = a, a = p;
      }
      let d = document.createRange();
      d.setEnd(a.node, a.offset), d.setStart(l.node, l.offset), c.removeAllRanges(), c.addRange(d);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i], o = r + s.size;
      if (r == o ? e <= o && t >= r : e < o && t > r) {
        let l = r + s.border, a = o - s.border;
        if (e >= l && t <= a) {
          this.dirty = e == r || t == o ? Zl : W6, e == l && t == a && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = ws : s.markDirty(e - l, t - l);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? Zl : ws;
      }
      r = o;
    }
    this.dirty = Zl;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let r = e == 1 ? Zl : W6;
      t.dirty < r && (t.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class UC extends ud {
  constructor(e, t, r, i) {
    let s, o = t.type.toDOM;
    if (typeof o == "function" && (o = o(r, () => {
      if (!s)
        return i;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !t.type.spec.raw) {
      if (o.nodeType != 1) {
        let l = document.createElement("span");
        l.appendChild(o), o = l;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = t, this.widget = t, s = this;
  }
  matchesWidget(e) {
    return this.dirty == pi && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class DF extends ud {
  constructor(e, t, r, i) {
    super(e, [], t, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class xa extends ud {
  constructor(e, t, r, i, s) {
    super(e, [], r, i), this.mark = t, this.spec = s;
  }
  static create(e, t, r, i) {
    let s = i.nodeViews[t.type.name], o = s && s(t, i, r);
    return (!o || !o.dom) && (o = wl.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new xa(e, t, o.dom, o.contentDOM || o.dom, o);
  }
  parseRule() {
    return this.dirty & ws || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != ws && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != pi) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = pi;
    }
  }
  slice(e, t, r) {
    let i = xa.create(this.parent, this.mark, !0, r), s = this.children, o = this.size;
    t < o && (s = G4(s, t, o, r)), e > 0 && (s = G4(s, 0, e, r));
    for (let l = 0; l < s.length; l++)
      s[l].parent = i;
    return i.children = s, i;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class rl extends ud {
  constructor(e, t, r, i, s, o, l, a, c) {
    super(e, [], s, o), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = l;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, r, i, s, o) {
    let l = s.nodeViews[t.type.name], a, c = l && l(t, s, () => {
      if (!a)
        return o;
      if (a.parent)
        return a.parent.posBeforeChild(a);
    }, r, i), u = c && c.dom, h = c && c.contentDOM;
    if (t.isText) {
      if (!u)
        u = document.createTextNode(t.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: h } = wl.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
    !h && !t.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), t.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = JC(u, r, t), c ? a = new NF(e, t, r, i, u, h || null, f, c, s, o + 1) : t.isText ? new h1(e, t, r, i, u, f, s) : new rl(e, t, r, i, u, h || null, f, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let r = this.children[t];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => ce.empty);
    }
    return e;
  }
  matchesNode(e, t, r) {
    return this.dirty == pi && e.eq(this.node) && tm(t, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let r = this.node.inlineContent, i = t, s = e.composing ? this.localCompositionInfo(e, t) : null, o = s && s.pos > -1 ? s : null, l = s && s.pos < 0, a = new PF(this, o && o.node, e);
    BF(this.node, this.innerDeco, (c, u, h) => {
      c.spec.marks ? a.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !h && a.syncToMarks(u == this.node.childCount ? nt.none : this.node.child(u).marks, r, e), a.placeWidget(c, e, i);
    }, (c, u, h, f) => {
      a.syncToMarks(c.marks, r, e);
      let d;
      a.findNodeMatch(c, u, h, f) || l && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (d = a.findIndexWithChild(s.node)) > -1 && a.updateNodeAt(c, u, h, d, e) || a.updateNextNode(c, u, h, e, f, i) || a.addNode(c, u, h, e, i), i += c.nodeSize;
    }), a.syncToMarks([], r, e), this.node.isTextblock && a.addTextblockHacks(), a.destroyRest(), (a.changed || this.dirty == Zl) && (o && this.protectLocalComposition(e, o), GC(this.contentDOM, this.children, e), Pc && zF(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof Ee) || r < t || i > t + this.node.content.size)
      return null;
    let s = e.input.compositionNode;
    if (!s || !this.dom.contains(s.parentNode))
      return null;
    if (this.node.inlineContent) {
      let o = s.nodeValue, l = FF(this.node.content, o, r - t, i - t);
      return l < 0 ? null : { node: s, pos: l, text: o };
    } else
      return { node: s, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: r, text: i }) {
    if (this.getDesc(t))
      return;
    let s = t;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new DF(this, s, t, i);
    e.input.compositionNodes.push(o), this.children = G4(this.children, r, r + i.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, r, i) {
    return this.dirty == ws || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, i), !0);
  }
  updateInner(e, t, r, i) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = pi;
  }
  updateOuterDeco(e) {
    if (tm(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = YC(this.dom, this.nodeDOM, K4(this.outerDeco, this.node, t), K4(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function j6(n, e, t, r, i) {
  JC(r, e, n);
  let s = new rl(void 0, n, e, t, r, r, r, i, 0);
  return s.contentDOM && s.updateChildren(i, 0), s;
}
class h1 extends rl {
  constructor(e, t, r, i, s, o, l) {
    super(e, t, r, i, s, null, o, l, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, r, i) {
    return this.dirty == ws || this.dirty != pi && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != pi || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = pi, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, r) {
    let i = this.node.cut(e, t), s = document.createTextNode(i.text);
    return new h1(this.parent, i, this.outerDeco, this.innerDeco, s, s, r);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = ws);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class KC extends ud {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == pi && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class NF extends rl {
  constructor(e, t, r, i, s, o, l, a, c, u) {
    super(e, t, r, i, s, o, l, c, u), this.spec = a;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, r, i) {
    if (this.dirty == ws)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let s = this.spec.update(e, t, r);
      return s && this.updateInner(e, t, r, i), s;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, t, r.root) : super.setSelection(e, t, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function GC(n, e, t) {
  let r = n.firstChild, i = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], l = o.dom;
    if (l.parentNode == n) {
      for (; l != r; )
        r = U6(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, n.insertBefore(l, r);
    if (o instanceof xa) {
      let a = r ? r.previousSibling : n.lastChild;
      GC(o.contentDOM, o.children, t), r = a ? a.nextSibling : n.firstChild;
    }
  }
  for (; r; )
    r = U6(r), i = !0;
  i && t.trackWrites == n && (t.trackWrites = null);
}
const $h = function(n) {
  n && (this.nodeName = n);
};
$h.prototype = /* @__PURE__ */ Object.create(null);
const Ql = [new $h()];
function K4(n, e, t) {
  if (n.length == 0)
    return Ql;
  let r = t ? Ql[0] : new $h(), i = [r];
  for (let s = 0; s < n.length; s++) {
    let o = n[s].type.attrs;
    if (o) {
      o.nodeName && i.push(r = new $h(o.nodeName));
      for (let l in o) {
        let a = o[l];
        a != null && (t && i.length == 1 && i.push(r = new $h(e.isInline ? "span" : "div")), l == "class" ? r.class = (r.class ? r.class + " " : "") + a : l == "style" ? r.style = (r.style ? r.style + ";" : "") + a : l != "nodeName" && (r[l] = a));
      }
    }
  }
  return i;
}
function YC(n, e, t, r) {
  if (t == Ql && r == Ql)
    return e;
  let i = e;
  for (let s = 0; s < r.length; s++) {
    let o = r[s], l = t[s];
    if (s) {
      let a;
      l && l.nodeName == o.nodeName && i != n && (a = i.parentNode) && a.nodeName.toLowerCase() == o.nodeName || (a = document.createElement(o.nodeName), a.pmIsDeco = !0, a.appendChild(i), l = Ql[0]), i = a;
    }
    RF(i, l || Ql[0], o);
  }
  return i;
}
function RF(n, e, t) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r);
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]);
  if (e.class != t.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && n.classList.remove(r[s]);
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && n.classList.add(i[s]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        n.style.removeProperty(i[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function JC(n, e, t) {
  return YC(n, n, Ql, K4(e, t, n.nodeType != 1));
}
function tm(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function U6(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class PF {
  constructor(e, t, r) {
    this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = _F(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let r = e; r < t; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, r) {
    let i = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = pi, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let l = -1;
      for (let a = this.index; a < Math.min(this.index + 3, this.top.children.length); a++) {
        let c = this.top.children[a];
        if (c.matchesMark(e[s]) && !this.isLocked(c.dom)) {
          l = a;
          break;
        }
      }
      if (l > -1)
        l > this.index && (this.changed = !0, this.destroyBetween(this.index, l)), this.top = this.top.children[this.index];
      else {
        let a = xa.create(this.top, e[s], t, r);
        this.top.children.splice(this.index, 0, a), this.top = a, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, r, i) {
    let s = -1, o;
    if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, r))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let l = this.index, a = Math.min(this.top.children.length, l + 5); l < a; l++) {
        let c = this.top.children[l];
        if (c.matchesNode(e, t, r) && !this.preMatch.matched.has(c)) {
          s = l;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, t, r, i, s) {
    let o = this.top.children[i];
    return o.dirty == ws && o.dom == o.contentDOM && (o.dirty = Zl), o.update(e, t, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, r, i, s, o) {
    for (let l = this.index; l < this.top.children.length; l++) {
      let a = this.top.children[l];
      if (a instanceof rl) {
        let c = this.preMatch.matched.get(a);
        if (c != null && c != s)
          return !1;
        let u = a.dom, h, f = this.isLocked(u) && !(e.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == e.text && a.dirty != ws && tm(t, a.outerDeco));
        if (!f && a.update(e, t, r, i))
          return this.destroyBetween(this.index, l), a.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (h = this.recreateWrapper(a, e, t, r, i, o)))
          return this.destroyBetween(this.index, l), this.top.children[this.index] = h, h.contentDOM && (h.dirty = Zl, h.updateChildren(i, o + 1), h.dirty = pi), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, r, i, s, o) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !tm(r, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let l = rl.create(this.top, t, r, i, s, o);
    if (l.contentDOM) {
      l.children = e.children, e.children = [];
      for (let a of l.children)
        a.parent = l;
    }
    return e.destroy(), l;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, r, i, s) {
    let o = rl.create(this.top, e, t, r, i, s);
    o.contentDOM && o.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0;
  }
  placeWidget(e, t, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new UC(this.top, e, t, r);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof xa; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof h1) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((fr || Kn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new KC(this.top, [], r, null);
      t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function _F(n, e) {
  let t = e, r = t.children.length, i = n.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e: for (; i > 0; ) {
    let l;
    for (; ; )
      if (r) {
        let c = t.children[r - 1];
        if (c instanceof xa)
          t = c, r = c.children.length;
        else {
          l = c, r--;
          break;
        }
      } else {
        if (t == e)
          break e;
        r = t.parent.children.indexOf(t), t = t.parent;
      }
    let a = l.node;
    if (a) {
      if (a != n.child(i - 1))
        break;
      --i, s.set(l, i), o.push(l);
    }
  }
  return { index: i, matched: s, matches: o.reverse() };
}
function LF(n, e) {
  return n.type.side - e.type.side;
}
function BF(n, e, t, r) {
  let i = e.locals(n), s = 0;
  if (i.length == 0) {
    for (let c = 0; c < n.childCount; c++) {
      let u = n.child(c);
      r(u, i, e.forChild(s, u), c), s += u.nodeSize;
    }
    return;
  }
  let o = 0, l = [], a = null;
  for (let c = 0; ; ) {
    let u, h;
    for (; o < i.length && i[o].to == s; ) {
      let g = i[o++];
      g.widget && (u ? (h || (h = [u])).push(g) : u = g);
    }
    if (u)
      if (h) {
        h.sort(LF);
        for (let g = 0; g < h.length; g++)
          t(h[g], c, !!a);
      } else
        t(u, c, !!a);
    let f, d;
    if (a)
      d = -1, f = a, a = null;
    else if (c < n.childCount)
      d = c, f = n.child(c++);
    else
      break;
    for (let g = 0; g < l.length; g++)
      l[g].to <= s && l.splice(g--, 1);
    for (; o < i.length && i[o].from <= s && i[o].to > s; )
      l.push(i[o++]);
    let p = s + f.nodeSize;
    if (f.isText) {
      let g = p;
      o < i.length && i[o].from < g && (g = i[o].from);
      for (let b = 0; b < l.length; b++)
        l[b].to < g && (g = l[b].to);
      g < p && (a = f.cut(g - s), f = f.cut(0, g - s), p = g, d = -1);
    } else
      for (; o < i.length && i[o].to < p; )
        o++;
    let m = f.isInline && !f.isLeaf ? l.filter((g) => !g.inline) : l.slice();
    r(f, m, e.forChild(s, f), d), s = p;
  }
}
function zF(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function FF(n, e, t, r) {
  for (let i = 0, s = 0; i < n.childCount && s <= r; ) {
    let o = n.child(i++), l = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let a = o.text;
    for (; i < n.childCount; ) {
      let c = n.child(i++);
      if (s += c.nodeSize, !c.isText)
        break;
      a += c.text;
    }
    if (s >= t) {
      if (s >= r && a.slice(r - e.length - l, r - l) == e)
        return r - e.length;
      let c = l < r ? a.lastIndexOf(e, r - l - 1) : -1;
      if (c >= 0 && c + e.length + l >= t)
        return l + c;
      if (t == r && a.length >= r + e.length - l && a.slice(r - l, r - l + e.length) == e)
        return r;
    }
  }
  return -1;
}
function G4(n, e, t, r, i) {
  let s = [];
  for (let o = 0, l = 0; o < n.length; o++) {
    let a = n[o], c = l, u = l += a.size;
    c >= t || u <= e ? s.push(a) : (c < e && s.push(a.slice(0, e - c, r)), i && (s.push(i), i = void 0), u > t && s.push(a.slice(t - c, a.size, r)));
  }
  return s;
}
function g3(n, e = null) {
  let t = n.domSelectionRange(), r = n.state.doc;
  if (!t.focusNode)
    return null;
  let i = n.docView.nearestDesc(t.focusNode), s = i && i.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (o < 0)
    return null;
  let l = r.resolve(o), a, c;
  if (u1(t)) {
    for (a = o; i && !i.node; )
      i = i.parent;
    let h = i.node;
    if (i && h.isAtom && $e.isSelectable(h) && i.parent && !(h.isInline && hF(t.focusNode, t.focusOffset, i.dom))) {
      let f = i.posBefore;
      c = new $e(o == f ? l : r.resolve(f));
    }
  } else {
    if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
      let h = o, f = o;
      for (let d = 0; d < t.rangeCount; d++) {
        let p = t.getRangeAt(d);
        h = Math.min(h, n.docView.posFromDOM(p.startContainer, p.startOffset, 1)), f = Math.max(f, n.docView.posFromDOM(p.endContainer, p.endOffset, -1));
      }
      if (h < 0)
        return null;
      [a, o] = f == n.state.selection.anchor ? [f, h] : [h, f], l = r.resolve(o);
    } else
      a = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (a < 0)
      return null;
  }
  let u = r.resolve(a);
  if (!c) {
    let h = e == "pointer" || n.state.selection.head < l.pos && !s ? 1 : -1;
    c = y3(n, u, l, h);
  }
  return c;
}
function XC(n) {
  return n.editable ? n.hasFocus() : QC(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function to(n, e = !1) {
  let t = n.state.selection;
  if (ZC(n, t), !!XC(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && Kn) {
      let r = n.domSelectionRange(), i = n.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && wa(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      $F(n);
    else {
      let { anchor: r, head: i } = t, s, o;
      K6 && !(t instanceof Ee) && (t.$from.parent.inlineContent || (s = G6(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = G6(n, t.to))), n.docView.setSelection(r, i, n, e), K6 && (s && Y6(s), o && Y6(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && HF(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const K6 = fr || Kn && FC < 63;
function G6(n, e) {
  let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, s = r ? t.childNodes[r - 1] : null;
  if (fr && i && i.contentEditable == "false")
    return Kg(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return Kg(i);
    if (s)
      return Kg(s);
  }
}
function Kg(n) {
  return n.contentEditable = "true", fr && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function Y6(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function HF(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!XC(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function $F(n) {
  let e = n.domSelection();
  if (!e)
    return;
  let t = n.cursorWrapper.dom, r = t.nodeName == "IMG";
  r ? e.collapse(t.parentNode, _n(t) + 1) : e.collapse(t, 0), !r && !n.state.selection.visible && Ir && nl <= 11 && (t.disabled = !0, t.disabled = !1);
}
function ZC(n, e) {
  if (e instanceof $e) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (J6(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    J6(n);
}
function J6(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function y3(n, e, t, r) {
  return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || Ee.between(e, t, r);
}
function X6(n) {
  return n.editable && !n.hasFocus() ? !1 : QC(n);
}
function QC(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function VF(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return wa(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function Y4(n, e) {
  let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), s = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && Ge.findFrom(s, e);
}
function Bo(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Z6(n, e, t) {
  let r = n.state.selection;
  if (r instanceof Ee)
    if (t.indexOf("s") > -1) {
      let { $head: i } = r, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let o = n.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return Bo(n, new Ee(r.$anchor, o));
    } else if (r.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = Y4(n.state, e);
        return i && i instanceof $e ? Bo(n, i) : !1;
      } else if (!(ii && t.indexOf("m") > -1)) {
        let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
        if (!s || s.isText)
          return !1;
        let l = e < 0 ? i.pos - s.nodeSize : i.pos;
        return s.isAtom || (o = n.docView.descAt(l)) && !o.contentDOM ? $e.isSelectable(s) ? Bo(n, new $e(e < 0 ? n.state.doc.resolve(i.pos - s.nodeSize) : i)) : cd ? Bo(n, new Ee(n.state.doc.resolve(e < 0 ? l : l + s.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof $e && r.node.isInline)
      return Bo(n, new Ee(e > 0 ? r.$to : r.$from));
    {
      let i = Y4(n.state, e);
      return i ? Bo(n, i) : !1;
    }
  }
}
function nm(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function Vh(n, e) {
  let t = n.pmViewDesc;
  return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
}
function Ga(n, e) {
  return e < 0 ? qF(n) : WF(n);
}
function qF(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i, s, o = !1;
  for (di && t.nodeType == 1 && r < nm(t) && Vh(t.childNodes[r], -1) && (o = !0); ; )
    if (r > 0) {
      if (t.nodeType != 1)
        break;
      {
        let l = t.childNodes[r - 1];
        if (Vh(l, -1))
          i = t, s = --r;
        else if (l.nodeType == 3)
          t = l, r = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (eM(t))
        break;
      {
        let l = t.previousSibling;
        for (; l && Vh(l, -1); )
          i = t.parentNode, s = _n(l), l = l.previousSibling;
        if (l)
          t = l, r = nm(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = 0;
        }
      }
    }
  o ? J4(n, t, r) : i && J4(n, i, s);
}
function WF(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i = nm(t), s, o;
  for (; ; )
    if (r < i) {
      if (t.nodeType != 1)
        break;
      let l = t.childNodes[r];
      if (Vh(l, 1))
        s = t, o = ++r;
      else
        break;
    } else {
      if (eM(t))
        break;
      {
        let l = t.nextSibling;
        for (; l && Vh(l, 1); )
          s = l.parentNode, o = _n(l) + 1, l = l.nextSibling;
        if (l)
          t = l, r = 0, i = nm(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = i = 0;
        }
      }
    }
  s && J4(n, s, o);
}
function eM(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function jF(n, e) {
  for (; n && e == n.childNodes.length && !ad(n); )
    e = _n(n) + 1, n = n.parentNode;
  for (; n && e < n.childNodes.length; ) {
    let t = n.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = 0;
  }
}
function UF(n, e) {
  for (; n && !e && !ad(n); )
    e = _n(n), n = n.parentNode;
  for (; n && e; ) {
    let t = n.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = n.childNodes.length;
  }
}
function J4(n, e, t) {
  if (e.nodeType != 3) {
    let s, o;
    (o = jF(e, t)) ? (e = o, t = 0) : (s = UF(e, t)) && (e = s, t = s.nodeValue.length);
  }
  let r = n.domSelection();
  if (!r)
    return;
  if (u1(r)) {
    let s = document.createRange();
    s.setEnd(e, t), s.setStart(e, t), r.removeAllRanges(), r.addRange(s);
  } else r.extend && r.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: i } = n;
  setTimeout(() => {
    n.state == i && to(n);
  }, 50);
}
function Q6(n, e) {
  let t = n.state.doc.resolve(e);
  if (!(Kn || pF) && t.parent.inlineContent) {
    let i = n.coordsAtPos(e);
    if (e > t.start()) {
      let s = n.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left < i.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let s = n.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
}
function ew(n, e, t) {
  let r = n.state.selection;
  if (r instanceof Ee && !r.empty || t.indexOf("s") > -1 || ii && t.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = r;
  if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Y4(n.state, e);
    if (o && o instanceof $e)
      return Bo(n, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s, l = r instanceof Er ? Ge.near(o, e) : Ge.findFrom(o, e);
    return l ? Bo(n, l) : !1;
  }
  return !1;
}
function tw(n, e) {
  if (!(n.state.selection instanceof Ee))
    return !0;
  let { $head: t, $anchor: r, empty: i } = n.state.selection;
  if (!t.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (s && !s.isText) {
    let o = n.state.tr;
    return e < 0 ? o.delete(t.pos - s.nodeSize, t.pos) : o.delete(t.pos, t.pos + s.nodeSize), n.dispatch(o), !0;
  }
  return !1;
}
function nw(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function KF(n) {
  if (!fr || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    nw(n, r, "true"), setTimeout(() => nw(n, r, "false"), 20);
  }
  return !1;
}
function GF(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function YF(n, e) {
  let t = e.keyCode, r = GF(e);
  if (t == 8 || ii && t == 72 && r == "c")
    return tw(n, -1) || Ga(n, -1);
  if (t == 46 && !e.shiftKey || ii && t == 68 && r == "c")
    return tw(n, 1) || Ga(n, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || ii && t == 66 && r == "c") {
    let i = t == 37 ? Q6(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return Z6(n, i, r) || Ga(n, i);
  } else if (t == 39 || ii && t == 70 && r == "c") {
    let i = t == 39 ? Q6(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return Z6(n, i, r) || Ga(n, i);
  } else {
    if (t == 38 || ii && t == 80 && r == "c")
      return ew(n, -1, r) || Ga(n, -1);
    if (t == 40 || ii && t == 78 && r == "c")
      return KF(n) || ew(n, 1, r) || Ga(n, 1);
    if (r == (ii ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function b3(n, e) {
  n.someProp("transformCopied", (d) => {
    e = d(e, n);
  });
  let t = [], { content: r, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--;
    let d = r.firstChild;
    t.push(d.type.name, d.attrs != d.type.defaultAttrs ? d.attrs : null), r = d.content;
  }
  let o = n.someProp("clipboardSerializer") || wl.fromSchema(n.state.schema), l = oM(), a = l.createElement("div");
  a.appendChild(o.serializeFragment(r, { document: l }));
  let c = a.firstChild, u, h = 0;
  for (; c && c.nodeType == 1 && (u = sM[c.nodeName.toLowerCase()]); ) {
    for (let d = u.length - 1; d >= 0; d--) {
      let p = l.createElement(u[d]);
      for (; a.firstChild; )
        p.appendChild(a.firstChild);
      a.appendChild(p), h++;
    }
    c = a.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${s}${h ? ` -${h}` : ""} ${JSON.stringify(t)}`);
  let f = n.someProp("clipboardTextSerializer", (d) => d(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: a, text: f, slice: e };
}
function tM(n, e, t, r, i) {
  let s = i.parent.type.spec.code, o, l;
  if (!t && !e)
    return null;
  let a = !!e && (r || s || !t);
  if (a) {
    if (n.someProp("transformPastedText", (f) => {
      e = f(e, s || r, n);
    }), s)
      return l = new me(ce.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0), n.someProp("transformPasted", (f) => {
        l = f(l, n, !0);
      }), l;
    let h = n.someProp("clipboardTextParser", (f) => f(e, i, r, n));
    if (h)
      l = h;
    else {
      let f = i.marks(), { schema: d } = n.state, p = wl.fromSchema(d);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
        let g = o.appendChild(document.createElement("p"));
        m && g.appendChild(p.serializeNode(d.text(m, f)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (h) => {
      t = h(t, n);
    }), o = QF(t), cd && eH(o);
  let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let h = +u[3]; h > 0; h--) {
      let f = o.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      o = f;
    }
  if (l || (l = (n.someProp("clipboardParser") || n.someProp("domParser") || ll.fromSchema(n.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(a || u),
    context: i,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !JF.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    l = tH(rw(l, +u[1], +u[2]), u[4]);
  else if (l = me.maxOpen(XF(l.content, i), !0), l.openStart || l.openEnd) {
    let h = 0, f = 0;
    for (let d = l.content.firstChild; h < l.openStart && !d.type.spec.isolating; h++, d = d.firstChild)
      ;
    for (let d = l.content.lastChild; f < l.openEnd && !d.type.spec.isolating; f++, d = d.lastChild)
      ;
    l = rw(l, h, f);
  }
  return n.someProp("transformPasted", (h) => {
    l = h(l, n, a);
  }), l;
}
const JF = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function XF(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let i = e.node(t).contentMatchAt(e.index(t)), s, o = [];
    if (n.forEach((l) => {
      if (!o)
        return;
      let a = i.findWrapping(l.type), c;
      if (!a)
        return o = null;
      if (c = o.length && s.length && rM(a, s, l, o[o.length - 1], 0))
        o[o.length - 1] = c;
      else {
        o.length && (o[o.length - 1] = iM(o[o.length - 1], s.length));
        let u = nM(l, a);
        o.push(u), i = i.matchType(u.type), s = a;
      }
    }), o)
      return ce.from(o);
  }
  return n;
}
function nM(n, e, t = 0) {
  for (let r = e.length - 1; r >= t; r--)
    n = e[r].create(null, ce.from(n));
  return n;
}
function rM(n, e, t, r, i) {
  if (i < n.length && i < e.length && n[i] == e[i]) {
    let s = rM(n, e, t, r.lastChild, i + 1);
    if (s)
      return r.copy(r.content.replaceChild(r.childCount - 1, s));
    if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1]))
      return r.copy(r.content.append(ce.from(nM(t, n, i + 1))));
  }
}
function iM(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, iM(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(ce.empty, !0);
  return n.copy(t.append(r));
}
function X4(n, e, t, r, i, s) {
  let o = e < 0 ? n.firstChild : n.lastChild, l = o.content;
  return n.childCount > 1 && (s = 0), i < r - 1 && (l = X4(l, e, t, r, i + 1, s)), i >= t && (l = e < 0 ? o.contentMatchAt(0).fillBefore(l, s <= i).append(l) : l.append(o.contentMatchAt(o.childCount).fillBefore(ce.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(l));
}
function rw(n, e, t) {
  return e < n.openStart && (n = new me(X4(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new me(X4(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const sM = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let iw = null;
function oM() {
  return iw || (iw = document.implementation.createHTMLDocument("title"));
}
let Gg = null;
function ZF(n) {
  let e = window.trustedTypes;
  return e ? (Gg || (Gg = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), Gg.createHTML(n)) : n;
}
function QF(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = oM().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i;
  if ((i = r && sM[r[1].toLowerCase()]) && (n = i.map((s) => "<" + s + ">").join("") + n + i.map((s) => "</" + s + ">").reverse().join("")), t.innerHTML = ZF(n), i)
    for (let s = 0; s < i.length; s++)
      t = t.querySelector(i[s]) || t;
  return t;
}
function eH(n) {
  let e = n.querySelectorAll(Kn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r);
  }
}
function tH(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: i, openStart: s, openEnd: o } = n;
  for (let l = r.length - 2; l >= 0; l -= 2) {
    let a = t.nodes[r[l]];
    if (!a || a.hasRequiredAttrs())
      break;
    i = ce.from(a.create(r[l + 1], i)), s++, o++;
  }
  return new me(i, s, o);
}
const dr = {}, pr = {}, nH = { touchstart: !0, touchmove: !0 };
let rH = class {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
};
function iH(n) {
  for (let e in dr) {
    let t = dr[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (r) => {
      oH(n, r) && !v3(n, r) && (n.editable || !(r.type in pr)) && t(n, r);
    }, nH[e] ? { passive: !0 } : void 0);
  }
  fr && n.dom.addEventListener("input", () => null), Z4(n);
}
function Yo(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function sH(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function Z4(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (r) => v3(n, r));
  });
}
function v3(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let r = t[e.type];
    return r ? r(n, e) || e.defaultPrevented : !1;
  });
}
function oH(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function lH(n, e) {
  !v3(n, e) && dr[e.type] && (n.editable || !(e.type in pr)) && dr[e.type](n, e);
}
pr.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !aM(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(Zs && Kn && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), Pc && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let r = Date.now();
      n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", (i) => i(n, Yl(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else n.someProp("handleKeyDown", (r) => r(n, t)) || YF(n, t) ? t.preventDefault() : Yo(n, "key");
};
pr.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
pr.keypress = (n, e) => {
  let t = e;
  if (aM(n, t) || !t.charCode || t.ctrlKey && !t.altKey || ii && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (i) => i(n, t))) {
    t.preventDefault();
    return;
  }
  let r = n.state.selection;
  if (!(r instanceof Ee) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(t.charCode), s = () => n.state.tr.insertText(i).scrollIntoView();
    !/[\r\n]/.test(i) && !n.someProp("handleTextInput", (o) => o(n, r.$from.pos, r.$to.pos, i, s)) && n.dispatch(s()), t.preventDefault();
  }
};
function f1(n) {
  return { left: n.clientX, top: n.clientY };
}
function aH(n, e) {
  let t = e.x - n.clientX, r = e.y - n.clientY;
  return t * t + r * r < 100;
}
function w3(n, e, t, r, i) {
  if (r == -1)
    return !1;
  let s = n.state.doc.resolve(r);
  for (let o = s.depth + 1; o > 0; o--)
    if (n.someProp(e, (l) => o > s.depth ? l(n, t, s.nodeAfter, s.before(o), i, !0) : l(n, t, s.node(o), s.before(o), i, !1)))
      return !0;
  return !1;
}
function gc(n, e, t) {
  if (n.focused || n.focus(), n.state.selection.eq(e))
    return;
  let r = n.state.tr.setSelection(e);
  r.setMeta("pointer", !0), n.dispatch(r);
}
function cH(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), r = t.nodeAfter;
  return r && r.isAtom && $e.isSelectable(r) ? (gc(n, new $e(t)), !0) : !1;
}
function uH(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, r, i;
  t instanceof $e && (r = t.node);
  let s = n.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let l = o > s.depth ? s.nodeAfter : s.node(o);
    if ($e.isSelectable(l)) {
      r && t.$from.depth > 0 && o >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i = s.before(t.$from.depth) : i = s.before(o);
      break;
    }
  }
  return i != null ? (gc(n, $e.create(n.state.doc, i)), !0) : !1;
}
function hH(n, e, t, r, i) {
  return w3(n, "handleClickOn", e, t, r) || n.someProp("handleClick", (s) => s(n, e, r)) || (i ? uH(n, t) : cH(n, t));
}
function fH(n, e, t, r) {
  return w3(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", (i) => i(n, e, r));
}
function dH(n, e, t, r) {
  return w3(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", (i) => i(n, e, r)) || pH(n, t, r);
}
function pH(n, e, t) {
  if (t.button != 0)
    return !1;
  let r = n.state.doc;
  if (e == -1)
    return r.inlineContent ? (gc(n, Ee.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s), l = i.before(s);
    if (o.inlineContent)
      gc(n, Ee.create(r, l + 1, l + 1 + o.content.size));
    else if ($e.isSelectable(o))
      gc(n, $e.create(r, l));
    else
      continue;
    return !0;
  }
}
function x3(n) {
  return rm(n);
}
const lM = ii ? "metaKey" : "ctrlKey";
dr.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let r = x3(n), i = Date.now(), s = "singleClick";
  i - n.input.lastClick.time < 500 && aH(t, n.input.lastClick) && !t[lM] && n.input.lastClick.button == t.button && (n.input.lastClick.type == "singleClick" ? s = "doubleClick" : n.input.lastClick.type == "doubleClick" && (s = "tripleClick")), n.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: s, button: t.button };
  let o = n.posAtCoords(f1(t));
  o && (s == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new mH(n, o, t, !!r)) : (s == "doubleClick" ? fH : dH)(n, o.pos, o.inside, t) ? t.preventDefault() : Yo(n, "pointer"));
};
class mH {
  constructor(e, t, r, i) {
    this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[lM], this.allowDefault = r.shiftKey;
    let s, o;
    if (t.inside > -1)
      s = e.state.doc.nodeAt(t.inside), o = t.inside;
    else {
      let u = e.state.doc.resolve(t.pos);
      s = u.parent, o = u.depth ? u.before() : 0;
    }
    const l = i ? null : r.target, a = l ? e.docView.nearestDesc(l, !0) : null;
    this.target = a && a.dom.nodeType == 1 ? a.dom : null;
    let { selection: c } = e.state;
    (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof $e && c.from <= o && c.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && di && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Yo(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => to(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(f1(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Yo(this.view, "pointer") : hH(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    fr && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Kn && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (gc(this.view, Ge.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : Yo(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Yo(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
dr.touchstart = (n) => {
  n.input.lastTouch = Date.now(), x3(n), Yo(n, "pointer");
};
dr.touchmove = (n) => {
  n.input.lastTouch = Date.now(), Yo(n, "pointer");
};
dr.contextmenu = (n) => x3(n);
function aM(n, e) {
  return n.composing ? !0 : fr && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const gH = Zs ? 5e3 : -1;
pr.compositionstart = pr.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$to;
    if (e.selection instanceof Ee && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), rm(n, !0), n.markCursor = null;
    else if (rm(n, !e.selection.empty), di && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let r = n.domSelectionRange();
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          let l = n.domSelection();
          l && l.collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, s = -1;
      }
    }
    n.input.composing = !0;
  }
  cM(n, gH);
};
pr.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, cM(n, 20));
};
function cM(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => rm(n), e));
}
function uM(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = bH()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function yH(n) {
  let e = n.domSelectionRange();
  if (!e.focusNode)
    return null;
  let t = cF(e.focusNode, e.focusOffset), r = uF(e.focusNode, e.focusOffset);
  if (t && r && t != r) {
    let i = r.pmViewDesc, s = n.domObserver.lastChangedTextNode;
    if (t == s || r == s)
      return s;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (n.input.compositionNode == r) {
      let o = t.pmViewDesc;
      if (!(!o || !o.isText(t.nodeValue)))
        return r;
    }
  }
  return t || r;
}
function bH() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function rm(n, e = !1) {
  if (!(Zs && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), uM(n), e || n.docView && n.docView.dirty) {
      let t = g3(n), r = n.state.selection;
      return t && !t.eq(r) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function vH(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const Sf = Ir && nl < 15 || Pc && mF < 604;
dr.copy = pr.cut = (n, e) => {
  let t = e, r = n.state.selection, i = t.type == "cut";
  if (r.empty)
    return;
  let s = Sf ? null : t.clipboardData, o = r.content(), { dom: l, text: a } = b3(n, o);
  s ? (t.preventDefault(), s.clearData(), s.setData("text/html", l.innerHTML), s.setData("text/plain", a)) : vH(n, l), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function wH(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function xH(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = n.input.shiftKey && n.input.lastKeyCode != 45;
  setTimeout(() => {
    n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? Cf(n, r.value, null, i, e) : Cf(n, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function Cf(n, e, t, r, i) {
  let s = tM(n, e, t, r, n.state.selection.$from);
  if (n.someProp("handlePaste", (a) => a(n, i, s || me.empty)))
    return !0;
  if (!s)
    return !1;
  let o = wH(s), l = o ? n.state.tr.replaceSelectionWith(o, r) : n.state.tr.replaceSelection(s);
  return n.dispatch(l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function hM(n) {
  let e = n.getData("text/plain") || n.getData("Text");
  if (e)
    return e;
  let t = n.getData("text/uri-list");
  return t ? t.replace(/\r?\n/g, " ") : "";
}
pr.paste = (n, e) => {
  let t = e;
  if (n.composing && !Zs)
    return;
  let r = Sf ? null : t.clipboardData, i = n.input.shiftKey && n.input.lastKeyCode != 45;
  r && Cf(n, hM(r), r.getData("text/html"), i, t) ? t.preventDefault() : xH(n, t);
};
class fM {
  constructor(e, t, r) {
    this.slice = e, this.move = t, this.node = r;
  }
}
const kH = ii ? "altKey" : "ctrlKey";
function dM(n, e) {
  let t = n.someProp("dragCopies", (r) => !r(e));
  return t ?? !e[kH];
}
dr.dragstart = (n, e) => {
  let t = e, r = n.input.mouseDown;
  if (r && r.done(), !t.dataTransfer)
    return;
  let i = n.state.selection, s = i.empty ? null : n.posAtCoords(f1(t)), o;
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof $e ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      o = $e.create(n.state.doc, r.mightDrag.pos);
    else if (t.target && t.target.nodeType == 1) {
      let h = n.docView.nearestDesc(t.target, !0);
      h && h.node.type.spec.draggable && h != n.docView && (o = $e.create(n.state.doc, h.posBefore));
    }
  }
  let l = (o || n.state.selection).content(), { dom: a, text: c, slice: u } = b3(n, l);
  (!t.dataTransfer.files.length || !Kn || FC > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Sf ? "Text" : "text/html", a.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Sf || t.dataTransfer.setData("text/plain", c), n.dragging = new fM(u, dM(n, t), o);
};
dr.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
pr.dragover = pr.dragenter = (n, e) => e.preventDefault();
pr.drop = (n, e) => {
  let t = e, r = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let i = n.posAtCoords(f1(t));
  if (!i)
    return;
  let s = n.state.doc.resolve(i.pos), o = r && r.slice;
  o ? n.someProp("transformPasted", (p) => {
    o = p(o, n, !1);
  }) : o = tM(n, hM(t.dataTransfer), Sf ? null : t.dataTransfer.getData("text/html"), !1, s);
  let l = !!(r && dM(n, t));
  if (n.someProp("handleDrop", (p) => p(n, t, o || me.empty, l))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let a = o ? hC(n.state.doc, s.pos, o) : s.pos;
  a == null && (a = s.pos);
  let c = n.state.tr;
  if (l) {
    let { node: p } = r;
    p ? p.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(a), h = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = c.doc;
  if (h ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(f))
    return;
  let d = c.doc.resolve(u);
  if (h && $e.isSelectable(o.content.firstChild) && d.nodeAfter && d.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new $e(d));
  else {
    let p = c.mapping.map(a);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((m, g, b, w) => p = w), c.setSelection(y3(n, d, c.doc.resolve(p)));
  }
  n.focus(), n.dispatch(c.setMeta("uiEvent", "drop"));
};
dr.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && to(n);
  }, 20));
};
dr.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
dr.beforeinput = (n, e) => {
  if (Kn && Zs && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: r } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (s) => s(n, Yl(8, "Backspace")))))
        return;
      let { $cursor: i } = n.state.selection;
      i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in pr)
  dr[n] = pr[n];
function Mf(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
let sw = class pM {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || la, this.side = this.spec.side || 0;
  }
  map(e, t, r, i) {
    let { pos: s, deleted: o } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new mr(s - r, s - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof pM && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Mf(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
};
class il {
  constructor(e, t) {
    this.attrs = e, this.spec = t || la;
  }
  map(e, t, r, i) {
    let s = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return s >= o ? null : new mr(s, o, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof il && Mf(this.attrs, e.attrs) && Mf(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof il;
  }
  destroy() {
  }
}
let SH = class mM {
  constructor(e, t) {
    this.attrs = e, this.spec = t || la;
  }
  map(e, t, r, i) {
    let s = e.mapResult(t.from + i, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(t.to + i, -1);
    return o.deleted || o.pos <= s.pos ? null : new mr(s.pos - r, o.pos - r, this);
  }
  valid(e, t) {
    let { index: r, offset: i } = e.content.findIndex(t.from), s;
    return i == t.from && !(s = e.child(r)).isText && i + s.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof mM && Mf(this.attrs, e.attrs) && Mf(this.spec, e.spec);
  }
  destroy() {
  }
}, mr = class ah {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.type = r;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new ah(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, r) {
    return this.type.map(e, this, t, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, r) {
    return new ah(e, e, new sw(t, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, r, i) {
    return new ah(e, t, new il(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, r, i) {
    return new ah(e, t, new SH(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof il;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof sw;
  }
};
const ec = [], la = {};
class It {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : ec, this.children = t.length ? t : ec;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? im(t, e, 0, la) : qn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, r) {
    let i = [];
    return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i;
  }
  findInner(e, t, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let l = this.local[o];
      l.from <= t && l.to >= e && (!s || s(l.spec)) && r.push(l.copy(l.from + i, l.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < t && this.children[o + 1] > e) {
        let l = this.children[o] + 1;
        this.children[o + 2].findInner(e - l, t - l, r, i + l, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, r) {
    return this == qn || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || la);
  }
  /**
  @internal
  */
  mapInner(e, t, r, i, s) {
    let o;
    for (let l = 0; l < this.local.length; l++) {
      let a = this.local[l].map(e, r, i);
      a && a.type.valid(t, a) ? (o || (o = [])).push(a) : s.onRemove && s.onRemove(this.local[l].spec);
    }
    return this.children.length ? CH(this.children, o || [], e, t, r, i, s) : o ? new It(o.sort(aa), ec) : qn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == qn ? It.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, r) {
    let i, s = 0;
    e.forEach((l, a) => {
      let c = a + r, u;
      if (u = yM(t, l, c)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < a; )
          s += 3;
        i[s] == a ? i[s + 2] = i[s + 2].addInner(l, u, c + 1) : i.splice(s, 0, a, a + l.nodeSize, im(u, l, c + 1, la)), s += 3;
      }
    });
    let o = gM(s ? bM(t) : t, -r);
    for (let l = 0; l < o.length; l++)
      o[l].type.valid(e, o[l]) || o.splice(l--, 1);
    return new It(o.length ? this.local.concat(o).sort(aa) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == qn ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let r = this.children, i = this.local;
    for (let s = 0; s < r.length; s += 3) {
      let o, l = r[s] + t, a = r[s + 1] + t;
      for (let u = 0, h; u < e.length; u++)
        (h = e[u]) && h.from > l && h.to < a && (e[u] = null, (o || (o = [])).push(h));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[s + 2].removeInner(o, l + 1);
      c != qn ? r[s + 2] = c : (r.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let l = 0; l < i.length; l++)
            i[l].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(l--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new It(i, r) : qn;
  }
  forChild(e, t) {
    if (this == qn)
      return this;
    if (t.isLeaf)
      return It.empty;
    let r, i;
    for (let l = 0; l < this.children.length; l += 3)
      if (this.children[l] >= e) {
        this.children[l] == e && (r = this.children[l + 2]);
        break;
      }
    let s = e + 1, o = s + t.content.size;
    for (let l = 0; l < this.local.length; l++) {
      let a = this.local[l];
      if (a.from < o && a.to > s && a.type instanceof il) {
        let c = Math.max(s, a.from) - s, u = Math.min(o, a.to) - s;
        c < u && (i || (i = [])).push(a.copy(c, u));
      }
    }
    if (i) {
      let l = new It(i.sort(aa), ec);
      return r ? new Wo([l, r]) : l;
    }
    return r || qn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof It) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return k3(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == qn)
      return ec;
    if (e.inlineContent || !this.local.some(il.is))
      return this.local;
    let t = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof il || t.push(this.local[r]);
    return t;
  }
  forEachSet(e) {
    e(this);
  }
}
It.empty = new It([], []);
It.removeOverlap = k3;
const qn = It.empty;
class Wo {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const r = this.members.map((i) => i.map(e, t, la));
    return Wo.from(r);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return It.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, t);
      s != qn && (s instanceof Wo ? r = r.concat(s.members) : r.push(s));
    }
    return Wo.from(r);
  }
  eq(e) {
    if (!(e instanceof Wo) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!t)
          t = s;
        else {
          r && (t = t.slice(), r = !1);
          for (let o = 0; o < s.length; o++)
            t.push(s[o]);
        }
    }
    return t ? k3(r ? t : t.sort(aa)) : ec;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return qn;
      case 1:
        return e[0];
      default:
        return new Wo(e.every((t) => t instanceof It) ? e : e.reduce((t, r) => t.concat(r instanceof It ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let t = 0; t < this.members.length; t++)
      this.members[t].forEachSet(e);
  }
}
function CH(n, e, t, r, i, s, o) {
  let l = n.slice();
  for (let c = 0, u = s; c < t.maps.length; c++) {
    let h = 0;
    t.maps[c].forEach((f, d, p, m) => {
      let g = m - p - (d - f);
      for (let b = 0; b < l.length; b += 3) {
        let w = l[b + 1];
        if (w < 0 || f > w + u - h)
          continue;
        let k = l[b] + u - h;
        d >= k ? l[b + 1] = f <= k ? -2 : -1 : f >= u && g && (l[b] += g, l[b + 1] += g);
      }
      h += g;
    }), u = t.maps[c].map(u, -1);
  }
  let a = !1;
  for (let c = 0; c < l.length; c += 3)
    if (l[c + 1] < 0) {
      if (l[c + 1] == -2) {
        a = !0, l[c + 1] = -1;
        continue;
      }
      let u = t.map(n[c] + s), h = u - i;
      if (h < 0 || h >= r.content.size) {
        a = !0;
        continue;
      }
      let f = t.map(n[c + 1] + s, -1), d = f - i, { index: p, offset: m } = r.content.findIndex(h), g = r.maybeChild(p);
      if (g && m == h && m + g.nodeSize == d) {
        let b = l[c + 2].mapInner(t, g, u + 1, n[c] + s + 1, o);
        b != qn ? (l[c] = h, l[c + 1] = d, l[c + 2] = b) : (l[c + 1] = -2, a = !0);
      } else
        a = !0;
    }
  if (a) {
    let c = MH(l, n, e, t, i, s, o), u = im(c, r, 0, o);
    e = u.local;
    for (let h = 0; h < l.length; h += 3)
      l[h + 1] < 0 && (l.splice(h, 3), h -= 3);
    for (let h = 0, f = 0; h < u.children.length; h += 3) {
      let d = u.children[h];
      for (; f < l.length && l[f] < d; )
        f += 3;
      l.splice(f, 0, u.children[h], u.children[h + 1], u.children[h + 2]);
    }
  }
  return new It(e.sort(aa), l);
}
function gM(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let r = 0; r < n.length; r++) {
    let i = n[r];
    t.push(new mr(i.from + e, i.to + e, i.type));
  }
  return t;
}
function MH(n, e, t, r, i, s, o) {
  function l(a, c) {
    for (let u = 0; u < a.local.length; u++) {
      let h = a.local[u].map(r, i, c);
      h ? t.push(h) : o.onRemove && o.onRemove(a.local[u].spec);
    }
    for (let u = 0; u < a.children.length; u += 3)
      l(a.children[u + 2], a.children[u] + c + 1);
  }
  for (let a = 0; a < n.length; a += 3)
    n[a + 1] == -1 && l(n[a + 2], e[a] + s + 1);
  return t;
}
function yM(n, e, t) {
  if (e.isLeaf)
    return null;
  let r = t + e.nodeSize, i = null;
  for (let s = 0, o; s < n.length; s++)
    (o = n[s]) && o.from > t && o.to < r && ((i || (i = [])).push(o), n[s] = null);
  return i;
}
function bM(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function im(n, e, t, r) {
  let i = [], s = !1;
  e.forEach((l, a) => {
    let c = yM(n, l, a + t);
    if (c) {
      s = !0;
      let u = im(c, l, t + a + 1, r);
      u != qn && i.push(a, a + l.nodeSize, u);
    }
  });
  let o = gM(s ? bM(n) : n, -t).sort(aa);
  for (let l = 0; l < o.length; l++)
    o[l].type.valid(e, o[l]) || (r.onRemove && r.onRemove(o[l].spec), o.splice(l--, 1));
  return o.length || i.length ? new It(o, i) : qn;
}
function aa(n, e) {
  return n.from - e.from || n.to - e.to;
}
function k3(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let r = e[t];
    if (r.from != r.to)
      for (let i = t + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == n && (e = n.slice()), e[i] = s.copy(s.from, r.to), ow(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, s.from), ow(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function ow(n, e, t) {
  for (; e < n.length && aa(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function Yg(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let r = t(n.state);
    r && r != qn && e.push(r);
  }), n.cursorWrapper && e.push(It.create(n.state.doc, [n.cursorWrapper.deco])), Wo.from(e);
}
const TH = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, AH = Ir && nl <= 11;
class OH {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
let EH = class {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new OH(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      Ir && nl <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), AH && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, TH)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (X6(this.view)) {
      if (this.suppressingSelectionUpdates)
        return to(this.view);
      if (Ir && nl <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && wa(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), r;
    for (let s = e.focusNode; s; s = Rc(s))
      t.add(s);
    for (let s = e.anchorNode; s; s = Rc(s))
      if (t.has(s)) {
        r = s;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && X6(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, l = !1, a = [];
    if (e.editable)
      for (let u = 0; u < t.length; u++) {
        let h = this.registerMutation(t[u], a);
        h && (s = s < 0 ? h.from : Math.min(h.from, s), o = o < 0 ? h.to : Math.max(h.to, o), h.typeOver && (l = !0));
      }
    if (di && a.length) {
      let u = a.filter((h) => h.nodeName == "BR");
      if (u.length == 2) {
        let [h, f] = u;
        h.parentNode && h.parentNode.parentNode == f.parentNode ? f.remove() : h.remove();
      } else {
        let { focusNode: h } = this.currentSelection;
        for (let f of u) {
          let d = f.parentNode;
          d && d.nodeName == "LI" && (!h || NH(e, h) != d) && f.remove();
        }
      }
    }
    let c = null;
    s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && u1(r) && (c = g3(e)) && c.eq(Ge.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, to(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), IH(e)), this.handleDOMChange(s, o, l, a), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || to(e), this.currentSelection.set(r));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let h = e.addedNodes[u];
        t.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, s = e.nextSibling;
      if (Ir && nl <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: h, nextSibling: f } = e.addedNodes[u];
          (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (s = f);
        }
      let o = i && i.parentNode == e.target ? _n(i) + 1 : 0, l = r.localPosFromDOM(e.target, o, -1), a = s && s.parentNode == e.target ? _n(s) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, a, 1);
      return { from: l, to: c };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}, lw = /* @__PURE__ */ new WeakMap(), aw = !1;
function IH(n) {
  if (!lw.has(n) && (lw.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = di, aw)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), aw = !0;
  }
}
function cw(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.domAtPos(n.state.selection.anchor);
  return wa(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s };
}
function DH(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return cw(n, i);
  }
  let t;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", r, !0), t ? cw(n, t) : null;
}
function NH(n, e) {
  for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) {
    let r = n.docView.nearestDesc(t, !0);
    if (r && r.node.isBlock)
      return t;
  }
  return null;
}
function RH(n, e, t) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: l } = n.docView.parseRange(e, t), a = n.domSelectionRange(), c, u = a.anchorNode;
  if (u && n.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: a.anchorOffset }], u1(a) || c.push({ node: a.focusNode, offset: a.focusOffset })), Kn && n.input.lastKeyCode === 8)
    for (let g = s; g > i; g--) {
      let b = r.childNodes[g - 1], w = b.pmViewDesc;
      if (b.nodeName == "BR" && !w) {
        s = g;
        break;
      }
      if (!w || w.size)
        break;
    }
  let h = n.state.doc, f = n.someProp("domParser") || ll.fromSchema(n.state.schema), d = h.resolve(o), p = null, m = f.parse(r, {
    topNode: d.parent,
    topMatch: d.parent.contentMatchAt(d.index()),
    topOpen: !0,
    from: i,
    to: s,
    preserveWhitespace: d.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: PH,
    context: d
  });
  if (c && c[0].pos != null) {
    let g = c[0].pos, b = c[1] && c[1].pos;
    b == null && (b = g), p = { anchor: g + o, head: b + o };
  }
  return { doc: m, sel: p, from: o, to: l };
}
function PH(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (fr && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || fr && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const _H = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function LH(n, e, t, r, i) {
  let s = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
  if (n.input.compositionPendingChanges = 0, e < 0) {
    let B = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, $ = g3(n, B);
    if ($ && !n.state.selection.eq($)) {
      if (Kn && Zs && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (V) => V(n, Yl(13, "Enter"))))
        return;
      let R = n.state.tr.setSelection($);
      B == "pointer" ? R.setMeta("pointer", !0) : B == "key" && R.scrollIntoView(), s && R.setMeta("composition", s), n.dispatch(R);
    }
    return;
  }
  let o = n.state.doc.resolve(e), l = o.sharedDepth(t);
  e = o.before(l + 1), t = n.state.doc.resolve(t).after(l + 1);
  let a = n.state.selection, c = RH(n, e, t), u = n.state.doc, h = u.slice(c.from, c.to), f, d;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (f = n.state.selection.to, d = "end") : (f = n.state.selection.from, d = "start"), n.input.lastKeyCode = null;
  let p = FH(h.content, c.doc.content, c.from, f, d);
  if (p && n.input.domChangeCount++, (Pc && n.input.lastIOSEnter > Date.now() - 225 || Zs) && i.some((B) => B.nodeType == 1 && !_H.test(B.nodeName)) && (!p || p.endA >= p.endB) && n.someProp("handleKeyDown", (B) => B(n, Yl(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!p)
    if (r && a instanceof Ee && !a.empty && a.$head.sameParent(a.$anchor) && !n.composing && !(c.sel && c.sel.anchor != c.sel.head))
      p = { start: a.from, endA: a.to, endB: a.to };
    else {
      if (c.sel) {
        let B = uw(n, n.state.doc, c.sel);
        if (B && !B.eq(n.state.selection)) {
          let $ = n.state.tr.setSelection(B);
          s && $.setMeta("composition", s), n.dispatch($);
        }
      }
      return;
    }
  n.state.selection.from < n.state.selection.to && p.start == p.endB && n.state.selection instanceof Ee && (p.start > n.state.selection.from && p.start <= n.state.selection.from + 2 && n.state.selection.from >= c.from ? p.start = n.state.selection.from : p.endA < n.state.selection.to && p.endA >= n.state.selection.to - 2 && n.state.selection.to <= c.to && (p.endB += n.state.selection.to - p.endA, p.endA = n.state.selection.to)), Ir && nl <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > c.from && c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == "  " && (p.start--, p.endA--, p.endB--);
  let m = c.doc.resolveNoCache(p.start - c.from), g = c.doc.resolveNoCache(p.endB - c.from), b = u.resolve(p.start), w = m.sameParent(g) && m.parent.inlineContent && b.end() >= p.endA, k;
  if ((Pc && n.input.lastIOSEnter > Date.now() - 225 && (!w || i.some((B) => B.nodeName == "DIV" || B.nodeName == "P")) || !w && m.pos < c.doc.content.size && (!m.sameParent(g) || !m.parent.inlineContent) && !/\S/.test(c.doc.textBetween(m.pos, g.pos, "", "")) && (k = Ge.findFrom(c.doc.resolve(m.pos + 1), 1, !0)) && k.head > m.pos) && n.someProp("handleKeyDown", (B) => B(n, Yl(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > p.start && zH(u, p.start, p.endA, m, g) && n.someProp("handleKeyDown", (B) => B(n, Yl(8, "Backspace")))) {
    Zs && Kn && n.domObserver.suppressSelectionUpdates();
    return;
  }
  Kn && p.endB == p.start && (n.input.lastChromeDelete = Date.now()), Zs && !w && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == p.endA && (p.endB -= 2, g = c.doc.resolveNoCache(p.endB - c.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(B) {
      return B(n, Yl(13, "Enter"));
    });
  }, 20));
  let C = p.start, M = p.endA, T = (B) => {
    let $ = B || n.state.tr.replace(C, M, c.doc.slice(p.start - c.from, p.endB - c.from));
    if (c.sel) {
      let R = uw(n, $.doc, c.sel);
      R && !(Kn && n.composing && R.empty && (p.start != p.endB || n.input.lastChromeDelete < Date.now() - 100) && (R.head == C || R.head == $.mapping.map(M) - 1) || Ir && R.empty && R.head == C) && $.setSelection(R);
    }
    return s && $.setMeta("composition", s), $.scrollIntoView();
  }, N;
  if (w) {
    if (m.pos == g.pos) {
      Ir && nl <= 11 && m.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => to(n), 20));
      let B = T(n.state.tr.delete(C, M)), $ = u.resolve(p.start).marksAcross(u.resolve(p.endA));
      $ && B.ensureMarks($), n.dispatch(B);
    } else if (
      // Adding or removing a mark
      p.endA == p.endB && (N = BH(m.parent.content.cut(m.parentOffset, g.parentOffset), b.parent.content.cut(b.parentOffset, p.endA - b.start())))
    ) {
      let B = T(n.state.tr);
      N.type == "add" ? B.addMark(C, M, N.mark) : B.removeMark(C, M, N.mark), n.dispatch(B);
    } else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let B = m.parent.textBetween(m.parentOffset, g.parentOffset), $ = () => T(n.state.tr.insertText(B, C, M));
      n.someProp("handleTextInput", (R) => R(n, C, M, B, $)) || n.dispatch($());
    }
  } else
    n.dispatch(T());
}
function uw(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : y3(n, e.resolve(t.anchor), e.resolve(t.head));
}
function BH(n, e) {
  let t = n.firstChild.marks, r = e.firstChild.marks, i = t, s = r, o, l, a;
  for (let u = 0; u < r.length; u++)
    i = r[u].removeFromSet(i);
  for (let u = 0; u < t.length; u++)
    s = t[u].removeFromSet(s);
  if (i.length == 1 && s.length == 0)
    l = i[0], o = "add", a = (u) => u.mark(l.addToSet(u.marks));
  else if (i.length == 0 && s.length == 1)
    l = s[0], o = "remove", a = (u) => u.mark(l.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(a(e.child(u)));
  if (ce.from(c).eq(n))
    return { mark: l, type: o };
}
function zH(n, e, t, r, i) {
  if (
    // The content must have shrunk
    t - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Jg(r, !0, !1) < i.pos
  )
    return !1;
  let s = n.resolve(e);
  if (!r.parent.isTextblock) {
    let l = s.nodeAfter;
    return l != null && t == e + l.nodeSize;
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = n.resolve(Jg(s, !0, !0));
  return !o.parent.isTextblock || o.pos > t || Jg(o, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
}
function Jg(n, e, t) {
  let r = n.depth, i = e ? n.end() : n.pos;
  for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount); )
    r--, i++, e = !1;
  if (t) {
    let s = n.node(r).maybeChild(n.indexAfter(r));
    for (; s && !s.isLeaf; )
      s = s.firstChild, i++;
  }
  return i;
}
function FH(n, e, t, r, i) {
  let s = n.findDiffStart(e, t);
  if (s == null)
    return null;
  let { a: o, b: l } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (i == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    r -= o + a - s;
  }
  if (o < s && n.size < e.size) {
    let a = r <= s && r >= o ? s - r : 0;
    s -= a, s && s < e.size && hw(e.textBetween(s - 1, s + 1)) && (s += a ? 1 : -1), l = s + (l - o), o = s;
  } else if (l < s) {
    let a = r <= s && r >= l ? s - r : 0;
    s -= a, s && s < n.size && hw(n.textBetween(s - 1, s + 1)) && (s += a ? 1 : -1), o = s + (o - l), l = s;
  }
  return { start: s, endA: o, endB: l };
}
function hw(n) {
  if (n.length != 2)
    return !1;
  let e = n.charCodeAt(0), t = n.charCodeAt(1);
  return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
}
let S3 = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new rH(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(gw), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = pw(this), dw(this), this.nodeViews = mw(this), this.docView = j6(this.state.doc, fw(this), Yg(this), this.dom, this), this.domObserver = new EH(this, (r, i, s, o) => LH(this, r, i, s, o)), this.domObserver.start(), iH(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Z4(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(gw), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let r in this._props)
      t[r] = this._props[r];
    t.state = this.state;
    for (let r in e)
      t[r] = e[r];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    var r;
    let i = this.state, s = !1, o = !1;
    e.storedMarks && this.composing && (uM(this), o = !0), this.state = e;
    let l = i.plugins != e.plugins || this._props.plugins != t.plugins;
    if (l || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let d = mw(this);
      $H(d, this.nodeViews) && (this.nodeViews = d, s = !0);
    }
    (l || t.handleDOMEvents != this._props.handleDOMEvents) && Z4(this), this.editable = pw(this), dw(this);
    let a = Yg(this), c = fw(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", h = s || !this.docView.matchesNode(e.doc, c, a);
    (h || !e.selection.eq(i.selection)) && (o = !0);
    let f = u == "preserve" && o && this.dom.style.overflowAnchor == null && bF(this);
    if (o) {
      this.domObserver.stop();
      let d = h && (Ir || Kn) && !this.composing && !i.selection.empty && !e.selection.empty && HH(i.selection, e.selection);
      if (h) {
        let p = Kn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = yH(this)), (s || !this.docView.update(e.doc, c, a, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = j6(e.doc, c, a, this.dom, this)), p && !this.trackWrites && (d = !0);
      }
      d || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && VF(this)) ? to(this, d) : (ZC(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && vF(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof $e) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && F6(this, t.getBoundingClientRect(), e);
      } else
        F6(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let r = this.directPlugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let r = this.state.plugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, t) {
    let r = e.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let s = r.from + (this.state.doc.content.size - t.doc.content.size);
      (s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s);
    }
    this.dragging = new fM(e.slice, e.move, i < 0 ? void 0 : $e.create(this.state.doc, i));
  }
  someProp(e, t) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = t ? t(r) : r))
      return i;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let l = this.directPlugins[o].props[e];
      if (l != null && (i = t ? t(l) : l))
        return i;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let l = s[o].props[e];
        if (l != null && (i = t ? t(l) : l))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Ir) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && wF(this.dom), to(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return MF(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return WC(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, r = -1) {
    let i = this.docView.posFromDOM(e, t, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return IF(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return Cf(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return Cf(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return b3(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (sH(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Yg(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, lF());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return lH(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? fr && this.root.nodeType === 11 && fF(this.dom.ownerDocument) == this.dom && DH(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
S3.prototype.dispatch = function(n) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, n) : this.updateState(this.state.apply(n));
};
function fw(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let r in t)
        r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
  }), e.translate || (e.translate = "no"), [mr.node(0, n.state.doc.content.size, e)];
}
function dw(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: mr.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function pw(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function HH(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function mw(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function $H(n, e) {
  let t = 0, r = 0;
  for (let i in n) {
    if (n[i] != e[i])
      return !0;
    t++;
  }
  for (let i in e)
    r++;
  return t != r;
}
function gw(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
function Ml(n, e) {
  return n.meta = {
    package: "@milkdown/core",
    group: "System",
    ...e
  }, n;
}
const vM = {
  text: (n, e, t, r) => {
    const i = n.value;
    return /^[^*_\\]*\s+$/.test(i) ? i : t.safe(i, { ...r, encode: [] });
  },
  strong: (n, e, t, r) => {
    const i = n.marker || t.options.strong || "*", s = t.enter("strong"), o = t.createTracker(r);
    let l = o.move(i + i);
    return l += o.move(
      t.containerPhrasing(n, {
        before: l,
        after: i,
        ...o.current()
      })
    ), l += o.move(i + i), s(), l;
  },
  emphasis: (n, e, t, r) => {
    const i = n.marker || t.options.emphasis || "*", s = t.enter("emphasis"), o = t.createTracker(r);
    let l = o.move(i);
    return l += o.move(
      t.containerPhrasing(n, {
        before: l,
        after: i,
        ...o.current()
      })
    ), l += o.move(i), s(), l;
  }
}, Ct = at({}, "editorView"), ch = at({}, "editorState"), Xg = at([], "initTimer"), Q4 = at({}, "editor"), Tf = at([], "inputRules"), lo = at([], "prosePlugins"), Af = at(
  [],
  "remarkPlugins"
), Of = at([], "nodeView"), Ef = at([], "markView"), ca = at(
  P4().use(A4).use(D4),
  "remark"
), qh = at(
  {
    handlers: vM,
    encode: []
  },
  "remarkStringifyOptions"
), tp = bo("ConfigReady");
function VH(n) {
  const e = (t) => (t.record(tp), async () => (await n(t), t.done(tp), () => {
    t.clearTimer(tp);
  }));
  return Ml(e, {
    displayName: "Config"
  }), e;
}
const ua = bo("InitReady");
function qH(n) {
  const e = (t) => (t.inject(Q4, n).inject(lo, []).inject(Af, []).inject(Tf, []).inject(Of, []).inject(Ef, []).inject(qh, {
    handlers: vM,
    encode: []
  }).inject(ca, P4().use(A4).use(D4)).inject(Xg, [tp]).record(ua), async () => {
    await t.waitTimers(Xg);
    const r = t.get(qh);
    return t.set(
      ca,
      P4().use(A4).use(D4, r)
    ), t.done(ua), () => {
      t.remove(Q4).remove(lo).remove(Af).remove(Tf).remove(Of).remove(Ef).remove(qh).remove(ca).remove(Xg).clearTimer(ua);
    };
  });
  return Ml(e, {
    displayName: "Init"
  }), e;
}
const mi = bo("SchemaReady"), Zg = at([], "schemaTimer"), gi = at({}, "schema"), Wh = at([], "nodes"), jh = at([], "marks");
function yw(n) {
  return {
    ...n,
    parseDOM: n.parseDOM?.map((e) => ({ priority: n.priority, ...e }))
  };
}
const wM = (n) => (n.inject(gi, {}).inject(Wh, []).inject(jh, []).inject(Zg, [ua]).record(mi), async () => {
  await n.waitTimers(Zg);
  const e = n.get(ca), r = n.get(Af).reduce(
    (l, a) => l.use(a.plugin, a.options),
    e
  );
  n.set(ca, r);
  const i = Object.fromEntries(
    n.get(Wh).map(([l, a]) => [l, yw(a)])
  ), s = Object.fromEntries(
    n.get(jh).map(([l, a]) => [l, yw(a)])
  ), o = new xS({ nodes: i, marks: s });
  return n.set(gi, o), n.done(mi), () => {
    n.remove(gi).remove(Wh).remove(jh).remove(Zg).clearTimer(mi);
  };
});
Ml(wM, {
  displayName: "Schema"
});
class xM {
  constructor() {
    this.#t = new iS(), this.#e = null, this.setCtx = (e) => {
      this.#e = e;
    }, this.chain = () => {
      if (this.#e == null) throw Sg();
      const e = this.#e, t = [], r = this.get.bind(this), i = {
        run: () => {
          const o = Xc(...t), l = e.get(Ct);
          return o(l.state, l.dispatch, l);
        },
        inline: (o) => (t.push(o), i),
        pipe: s.bind(this)
      };
      function s(o, l) {
        const a = r(o);
        return t.push(a(l)), i;
      }
      return i;
    };
  }
  #t;
  #e;
  get ctx() {
    return this.#e;
  }
  /// Register a command into the manager.
  create(e, t) {
    const r = e.create(this.#t.sliceMap);
    return r.set(t), r;
  }
  get(e) {
    return this.#t.get(e).get();
  }
  remove(e) {
    return this.#t.remove(e);
  }
  call(e, t) {
    if (this.#e == null) throw Sg();
    const i = this.get(e)(t), s = this.#e.get(Ct);
    return i(s.state, s.dispatch, s);
  }
  /// Call an inline command.
  inline(e) {
    if (this.#e == null) throw Sg();
    const t = this.#e.get(Ct);
    return e(t.state, t.dispatch, t);
  }
}
function WH(n = "cmdKey") {
  return at((() => () => !1), n);
}
const Me = at(new xM(), "commands"), Qg = at([mi], "commandsTimer"), Uh = bo("CommandsReady"), kM = (n) => {
  const e = new xM();
  return e.setCtx(n), n.inject(Me, e).inject(Qg, [mi]).record(Uh), async () => (await n.waitTimers(Qg), n.done(Uh), () => {
    n.remove(Me).remove(Qg).clearTimer(Uh);
  });
};
Ml(kM, {
  displayName: "Commands"
});
function jH(n) {
  const e = Xc(
    Nz,
    l3,
    pz,
    kC
  );
  return n.Backspace = e, n;
}
class SM {
  constructor() {
    this.#t = null, this.#e = [], this.setCtx = (e) => {
      this.#t = e;
    }, this.add = (e) => (this.#e.push(e), () => {
      this.#e = this.#e.filter((t) => t !== e);
    }), this.addObjectKeymap = (e) => {
      const t = [];
      return Object.entries(e).forEach(([r, i]) => {
        if (typeof i == "function") {
          const s = {
            key: r,
            onRun: () => i
          };
          this.#e.push(s), t.push(() => {
            this.#e = this.#e.filter((o) => o !== s);
          });
        } else
          this.#e.push(i), t.push(() => {
            this.#e = this.#e.filter((s) => s !== i);
          });
      }), () => {
        t.forEach((r) => r());
      };
    }, this.addBaseKeymap = () => {
      const e = jH(Iz);
      return this.addObjectKeymap(e);
    }, this.build = () => {
      const e = {};
      return this.#e.forEach((r) => {
        e[r.key] = [...e[r.key] || [], r];
      }), Object.fromEntries(
        Object.entries(e).map(([r, i]) => {
          const s = i.sort(
            (l, a) => (a.priority ?? 50) - (l.priority ?? 50)
          );
          return [r, (l, a, c) => {
            const u = this.#t;
            if (u == null) throw Xm();
            const h = s.map((d) => d.onRun(u));
            return Xc(...h)(l, a, c);
          }];
        })
      );
    };
  }
  #t;
  #e;
  get ctx() {
    return this.#t;
  }
}
const sm = at(new SM(), "keymap"), e2 = at([mi], "keymapTimer"), Kh = bo("KeymapReady"), UH = (n) => {
  const e = new SM();
  return e.setCtx(n), n.inject(sm, e).inject(e2, [mi]).record(Kh), async () => (await n.waitTimers(e2), n.done(Kh), () => {
    n.remove(sm).remove(e2).clearTimer(Kh);
  });
}, np = bo("ParserReady"), CM = (() => {
  throw Xm();
}), ha = at(CM, "parser"), t2 = at([], "parserTimer"), MM = (n) => (n.inject(ha, CM).inject(t2, [mi]).record(np), async () => {
  await n.waitTimers(t2);
  const e = n.get(ca), t = n.get(gi);
  return n.set(ha, FB.create(t, e)), n.done(np), () => {
    n.remove(ha).remove(t2).clearTimer(np);
  };
});
Ml(MM, {
  displayName: "Parser"
});
const Gh = bo("SerializerReady"), n2 = at(
  [],
  "serializerTimer"
), TM = (() => {
  throw Xm();
}), yc = at(
  TM,
  "serializer"
), AM = (n) => (n.inject(yc, TM).inject(n2, [mi]).record(Gh), async () => {
  await n.waitTimers(n2);
  const e = n.get(ca), t = n.get(gi);
  return n.set(yc, $B.create(t, e)), n.done(Gh), () => {
    n.remove(yc).remove(n2).clearTimer(Gh);
  };
});
Ml(AM, {
  displayName: "Serializer"
});
const rp = at("", "defaultValue"), ip = at(
  (n) => n,
  "stateOptions"
), r2 = at(
  [],
  "editorStateTimer"
), sp = bo("EditorStateReady");
function KH(n, e, t) {
  if (typeof n == "string") return e(n);
  if (n.type === "html")
    return ll.fromSchema(t).parse(n.dom);
  if (n.type === "json")
    return eo.fromJSON(t, n.value);
  throw OR(n);
}
const GH = new en("MILKDOWN_STATE_TRACKER"), OM = (n) => (n.inject(rp, "").inject(ch, {}).inject(ip, (e) => e).inject(r2, [
  np,
  Gh,
  Uh,
  Kh
]).record(sp), async () => {
  await n.waitTimers(r2);
  const e = n.get(gi), t = n.get(ha), r = n.get(Tf), i = n.get(ip), s = n.get(lo), o = n.get(rp), l = KH(o, t, e), a = n.get(sm), c = a.addBaseKeymap(), u = [
    ...s,
    new Ut({
      key: GH,
      state: {
        init: () => {
        },
        apply: (d, p, m, g) => {
          n.set(ch, g);
        }
      }
    }),
    $z({ rules: r }),
    BC(a.build())
  ];
  n.set(lo, u);
  const h = i({
    schema: e,
    doc: l,
    plugins: u
  }), f = o3.create(h);
  return n.set(ch, f), n.done(sp), () => {
    c(), n.remove(rp).remove(ch).remove(ip).remove(r2).clearTimer(sp);
  };
});
Ml(OM, {
  displayName: "EditorState"
});
const op = bo("EditorViewReady"), i2 = at(
  [],
  "editorViewTimer"
), Yh = at(
  {},
  "editorViewOptions"
), lp = at(null, "root"), ey = at(null, "rootDOM"), ty = at(
  {},
  "rootAttrs"
);
function YH(n, e) {
  const t = document.createElement("div");
  t.className = "milkdown", n.appendChild(t), e.set(ey, t);
  const r = e.get(ty);
  return Object.entries(r).forEach(
    ([i, s]) => t.setAttribute(i, s)
  ), t;
}
function JH(n) {
  n.classList.add("editor"), n.setAttribute("role", "textbox");
}
const XH = new en("MILKDOWN_VIEW_CLEAR"), EM = (n) => (n.inject(lp, document.body).inject(Ct, {}).inject(Yh, {}).inject(ey, null).inject(ty, {}).inject(i2, [sp]).record(op), async () => {
  await n.wait(ua);
  const e = n.get(lp) || document.body, t = typeof e == "string" ? document.querySelector(e) : e;
  n.update(lo, (a) => [
    new Ut({
      key: XH,
      view: (c) => {
        const u = t ? YH(t, n) : void 0;
        return (() => {
          if (u && t) {
            const f = c.dom;
            t.replaceChild(u, f), u.appendChild(f);
          }
        })(), {
          destroy: () => {
            u?.parentNode && u?.parentNode.replaceChild(c.dom, u), u?.remove();
          }
        };
      }
    }),
    ...a
  ]), await n.waitTimers(i2);
  const r = n.get(ch), i = n.get(Yh), s = Object.fromEntries(n.get(Of)), o = Object.fromEntries(n.get(Ef)), l = new S3(t, {
    state: r,
    nodeViews: s,
    markViews: o,
    ...i
  });
  return JH(l.dom), n.set(Ct, l), n.done(op), () => {
    l?.destroy(), n.remove(lp).remove(Ct).remove(Yh).remove(ey).remove(ty).remove(i2).clearTimer(op);
  };
});
Ml(EM, {
  displayName: "EditorView"
});
var om = /* @__PURE__ */ ((n) => (n.Idle = "Idle", n.OnCreate = "OnCreate", n.Created = "Created", n.OnDestroy = "OnDestroy", n.Destroyed = "Destroyed", n))(om || {});
class C3 {
  constructor() {
    this.#t = !1, this.#e = "Idle", this.#r = [], this.#n = () => {
    }, this.#a = new iS(), this.#i = new HR(), this.#s = /* @__PURE__ */ new Map(), this.#o = /* @__PURE__ */ new Map(), this.#l = new U5(this.#a, this.#i), this.#c = () => {
      const e = VH(async (r) => {
        await Promise.all(this.#r.map((i) => i(r)));
      }), t = [
        wM,
        MM,
        AM,
        kM,
        UH,
        OM,
        EM,
        qH(this),
        e
      ];
      this.#u(t, this.#o);
    }, this.#u = (e, t) => {
      e.forEach((r) => {
        const i = this.#l.produce(
          this.#t ? r.meta : void 0
        ), s = r(i);
        t.set(r, { ctx: i, handler: s, cleanup: void 0 });
      });
    }, this.#h = (e, t = !1) => Promise.all(
      [e].flat().map((r) => {
        const s = this.#s.get(r)?.cleanup;
        return t ? this.#s.delete(r) : this.#s.set(r, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        }), typeof s == "function" ? s() : s;
      })
    ), this.#d = async () => {
      await Promise.all(
        [...this.#o.entries()].map(([e, { cleanup: t }]) => typeof t == "function" ? t() : t)
      ), this.#o.clear();
    }, this.#f = (e) => {
      this.#e = e, this.#n(e);
    }, this.#p = (e) => [...e.entries()].map(async ([t, r]) => {
      const { ctx: i, handler: s } = r;
      if (!s) return;
      const o = await s();
      e.set(t, { ctx: i, handler: s, cleanup: o });
    }), this.enableInspector = (e = !0) => (this.#t = e, this), this.onStatusChange = (e) => (this.#n = e, this), this.config = (e) => (this.#r.push(e), this), this.removeConfig = (e) => (this.#r = this.#r.filter((t) => t !== e), this), this.use = (e) => {
      const t = [e].flat();
      return t.flat().forEach((r) => {
        this.#s.set(r, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        });
      }), this.#e === "Created" && this.#u(t, this.#s), this;
    }, this.remove = async (e) => this.#e === "OnCreate" ? (console.warn(
      "[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code."
    ), new Promise((t) => {
      setTimeout(() => {
        t(this.remove(e));
      }, 50);
    })) : (await this.#h([e].flat(), !0), this), this.create = async () => this.#e === "OnCreate" ? this : (this.#e === "Created" && await this.destroy(), this.#f(
      "OnCreate"
      /* OnCreate */
    ), this.#c(), this.#u([...this.#s.keys()], this.#s), await Promise.all(
      [
        this.#p(this.#o),
        this.#p(this.#s)
      ].flat()
    ), this.#f(
      "Created"
      /* Created */
    ), this), this.destroy = async (e = !1) => this.#e === "Destroyed" || this.#e === "OnDestroy" ? this : this.#e === "OnCreate" ? new Promise((t) => {
      setTimeout(() => {
        t(this.destroy(e));
      }, 50);
    }) : (e && (this.#r = []), this.#f(
      "OnDestroy"
      /* OnDestroy */
    ), await this.#h([...this.#s.keys()], e), await this.#d(), this.#f(
      "Destroyed"
      /* Destroyed */
    ), this), this.action = (e) => e(this.#l), this.inspect = () => this.#t ? [...this.#o.values(), ...this.#s.values()].map(({ ctx: e }) => e?.inspector?.read()).filter((e) => !!e) : (console.warn(
      "[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first."
    ), []);
  }
  /// Create a new editor instance.
  static make() {
    return new C3();
  }
  #t;
  #e;
  #r;
  #n;
  #a;
  #i;
  #s;
  #o;
  #l;
  #c;
  #u;
  #h;
  #d;
  #f;
  #p;
  /// Get the ctx of the editor.
  get ctx() {
    return this.#l;
  }
  /// Get the status of the editor.
  get status() {
    return this.#e;
  }
}
var IM = typeof global == "object" && global && global.Object === Object && global, ZH = typeof self == "object" && self && self.Object === Object && self, Pa = IM || ZH || Function("return this")(), lm = Pa.Symbol, DM = Object.prototype, QH = DM.hasOwnProperty, e$ = DM.toString, Pu = lm ? lm.toStringTag : void 0;
function t$(n) {
  var e = QH.call(n, Pu), t = n[Pu];
  try {
    n[Pu] = void 0;
    var r = !0;
  } catch {
  }
  var i = e$.call(n);
  return r && (e ? n[Pu] = t : delete n[Pu]), i;
}
var n$ = Object.prototype, r$ = n$.toString;
function i$(n) {
  return r$.call(n);
}
var s$ = "[object Null]", o$ = "[object Undefined]", bw = lm ? lm.toStringTag : void 0;
function hd(n) {
  return n == null ? n === void 0 ? o$ : s$ : bw && bw in Object(n) ? t$(n) : i$(n);
}
function Zc(n) {
  return n != null && typeof n == "object";
}
var l$ = "[object Symbol]";
function a$(n) {
  return typeof n == "symbol" || Zc(n) && hd(n) == l$;
}
var ny = Array.isArray, c$ = /\s/;
function u$(n) {
  for (var e = n.length; e-- && c$.test(n.charAt(e)); )
    ;
  return e;
}
var h$ = /^\s+/;
function f$(n) {
  return n && n.slice(0, u$(n) + 1).replace(h$, "");
}
function Qr(n) {
  var e = typeof n;
  return n != null && (e == "object" || e == "function");
}
var vw = NaN, d$ = /^[-+]0x[0-9a-f]+$/i, p$ = /^0b[01]+$/i, m$ = /^0o[0-7]+$/i, g$ = parseInt;
function ww(n) {
  if (typeof n == "number")
    return n;
  if (a$(n))
    return vw;
  if (Qr(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = Qr(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = f$(n);
  var t = p$.test(n);
  return t || m$.test(n) ? g$(n.slice(2), t ? 2 : 8) : d$.test(n) ? vw : +n;
}
function NM(n) {
  return n;
}
var y$ = "[object AsyncFunction]", b$ = "[object Function]", v$ = "[object GeneratorFunction]", w$ = "[object Proxy]";
function M3(n) {
  if (!Qr(n))
    return !1;
  var e = hd(n);
  return e == b$ || e == v$ || e == y$ || e == w$;
}
var s2 = Pa["__core-js_shared__"], xw = (function() {
  var n = /[^.]+$/.exec(s2 && s2.keys && s2.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
})();
function x$(n) {
  return !!xw && xw in n;
}
var k$ = Function.prototype, S$ = k$.toString;
function C$(n) {
  if (n != null) {
    try {
      return S$.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var M$ = /[\\^$.*+?()[\]{}|]/g, T$ = /^\[object .+?Constructor\]$/, A$ = Function.prototype, O$ = Object.prototype, E$ = A$.toString, I$ = O$.hasOwnProperty, D$ = RegExp(
  "^" + E$.call(I$).replace(M$, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function N$(n) {
  if (!Qr(n) || x$(n))
    return !1;
  var e = M3(n) ? D$ : T$;
  return e.test(C$(n));
}
function R$(n, e) {
  return n?.[e];
}
function T3(n, e) {
  var t = R$(n, e);
  return N$(t) ? t : void 0;
}
var kw = Object.create, P$ = /* @__PURE__ */ (function() {
  function n() {
  }
  return function(e) {
    if (!Qr(e))
      return {};
    if (kw)
      return kw(e);
    n.prototype = e;
    var t = new n();
    return n.prototype = void 0, t;
  };
})();
function RM(n, e, t) {
  switch (t.length) {
    case 0:
      return n.call(e);
    case 1:
      return n.call(e, t[0]);
    case 2:
      return n.call(e, t[0], t[1]);
    case 3:
      return n.call(e, t[0], t[1], t[2]);
  }
  return n.apply(e, t);
}
function _$(n, e) {
  var t = -1, r = n.length;
  for (e || (e = Array(r)); ++t < r; )
    e[t] = n[t];
  return e;
}
var L$ = 800, B$ = 16, z$ = Date.now;
function F$(n) {
  var e = 0, t = 0;
  return function() {
    var r = z$(), i = B$ - (r - t);
    if (t = r, i > 0) {
      if (++e >= L$)
        return arguments[0];
    } else
      e = 0;
    return n.apply(void 0, arguments);
  };
}
function H$(n) {
  return function() {
    return n;
  };
}
var am = (function() {
  try {
    var n = T3(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
})(), $$ = am ? function(n, e) {
  return am(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: H$(e),
    writable: !0
  });
} : NM, V$ = F$($$), q$ = 9007199254740991, W$ = /^(?:0|[1-9]\d*)$/;
function PM(n, e) {
  var t = typeof n;
  return e = e ?? q$, !!e && (t == "number" || t != "symbol" && W$.test(n)) && n > -1 && n % 1 == 0 && n < e;
}
function A3(n, e, t) {
  e == "__proto__" && am ? am(n, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : n[e] = t;
}
function d1(n, e) {
  return n === e || n !== n && e !== e;
}
var j$ = Object.prototype, U$ = j$.hasOwnProperty;
function K$(n, e, t) {
  var r = n[e];
  (!(U$.call(n, e) && d1(r, t)) || t === void 0 && !(e in n)) && A3(n, e, t);
}
function G$(n, e, t, r) {
  var i = !t;
  t || (t = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var l = e[s], a = void 0;
    a === void 0 && (a = n[l]), i ? A3(t, l, a) : K$(t, l, a);
  }
  return t;
}
var Sw = Math.max;
function Y$(n, e, t) {
  return e = Sw(e === void 0 ? n.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, s = Sw(r.length - e, 0), o = Array(s); ++i < s; )
      o[i] = r[e + i];
    i = -1;
    for (var l = Array(e + 1); ++i < e; )
      l[i] = r[i];
    return l[e] = t(o), RM(n, this, l);
  };
}
function _M(n, e) {
  return V$(Y$(n, e, NM), n + "");
}
var J$ = 9007199254740991;
function LM(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= J$;
}
function O3(n) {
  return n != null && LM(n.length) && !M3(n);
}
function X$(n, e, t) {
  if (!Qr(t))
    return !1;
  var r = typeof e;
  return (r == "number" ? O3(t) && PM(e, t.length) : r == "string" && e in t) ? d1(t[e], n) : !1;
}
function Z$(n) {
  return _M(function(e, t) {
    var r = -1, i = t.length, s = i > 1 ? t[i - 1] : void 0, o = i > 2 ? t[2] : void 0;
    for (s = n.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && X$(t[0], t[1], o) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i; ) {
      var l = t[r];
      l && n(e, l, r, s);
    }
    return e;
  });
}
var Q$ = Object.prototype;
function BM(n) {
  var e = n && n.constructor, t = typeof e == "function" && e.prototype || Q$;
  return n === t;
}
function eV(n, e) {
  for (var t = -1, r = Array(n); ++t < n; )
    r[t] = e(t);
  return r;
}
var tV = "[object Arguments]";
function Cw(n) {
  return Zc(n) && hd(n) == tV;
}
var zM = Object.prototype, nV = zM.hasOwnProperty, rV = zM.propertyIsEnumerable, ry = Cw(/* @__PURE__ */ (function() {
  return arguments;
})()) ? Cw : function(n) {
  return Zc(n) && nV.call(n, "callee") && !rV.call(n, "callee");
};
function iV() {
  return !1;
}
var FM = typeof exports == "object" && exports && !exports.nodeType && exports, Mw = FM && typeof module == "object" && module && !module.nodeType && module, sV = Mw && Mw.exports === FM, Tw = sV ? Pa.Buffer : void 0, oV = Tw ? Tw.isBuffer : void 0, HM = oV || iV, lV = "[object Arguments]", aV = "[object Array]", cV = "[object Boolean]", uV = "[object Date]", hV = "[object Error]", fV = "[object Function]", dV = "[object Map]", pV = "[object Number]", mV = "[object Object]", gV = "[object RegExp]", yV = "[object Set]", bV = "[object String]", vV = "[object WeakMap]", wV = "[object ArrayBuffer]", xV = "[object DataView]", kV = "[object Float32Array]", SV = "[object Float64Array]", CV = "[object Int8Array]", MV = "[object Int16Array]", TV = "[object Int32Array]", AV = "[object Uint8Array]", OV = "[object Uint8ClampedArray]", EV = "[object Uint16Array]", IV = "[object Uint32Array]", Vt = {};
Vt[kV] = Vt[SV] = Vt[CV] = Vt[MV] = Vt[TV] = Vt[AV] = Vt[OV] = Vt[EV] = Vt[IV] = !0;
Vt[lV] = Vt[aV] = Vt[wV] = Vt[cV] = Vt[xV] = Vt[uV] = Vt[hV] = Vt[fV] = Vt[dV] = Vt[pV] = Vt[mV] = Vt[gV] = Vt[yV] = Vt[bV] = Vt[vV] = !1;
function DV(n) {
  return Zc(n) && LM(n.length) && !!Vt[hd(n)];
}
function NV(n) {
  return function(e) {
    return n(e);
  };
}
var $M = typeof exports == "object" && exports && !exports.nodeType && exports, Jh = $M && typeof module == "object" && module && !module.nodeType && module, RV = Jh && Jh.exports === $M, o2 = RV && IM.process, Aw = (function() {
  try {
    var n = Jh && Jh.require && Jh.require("util").types;
    return n || o2 && o2.binding && o2.binding("util");
  } catch {
  }
})(), Ow = Aw && Aw.isTypedArray, VM = Ow ? NV(Ow) : DV;
function PV(n, e) {
  var t = ny(n), r = !t && ry(n), i = !t && !r && HM(n), s = !t && !r && !i && VM(n), o = t || r || i || s, l = o ? eV(n.length, String) : [], a = l.length;
  for (var c in n)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    PM(c, a)) || l.push(c);
  return l;
}
function _V(n, e) {
  return function(t) {
    return n(e(t));
  };
}
function LV(n) {
  var e = [];
  if (n != null)
    for (var t in Object(n))
      e.push(t);
  return e;
}
var BV = Object.prototype, zV = BV.hasOwnProperty;
function FV(n) {
  if (!Qr(n))
    return LV(n);
  var e = BM(n), t = [];
  for (var r in n)
    r == "constructor" && (e || !zV.call(n, r)) || t.push(r);
  return t;
}
function qM(n) {
  return O3(n) ? PV(n) : FV(n);
}
var If = T3(Object, "create");
function HV() {
  this.__data__ = If ? If(null) : {}, this.size = 0;
}
function $V(n) {
  var e = this.has(n) && delete this.__data__[n];
  return this.size -= e ? 1 : 0, e;
}
var VV = "__lodash_hash_undefined__", qV = Object.prototype, WV = qV.hasOwnProperty;
function jV(n) {
  var e = this.__data__;
  if (If) {
    var t = e[n];
    return t === VV ? void 0 : t;
  }
  return WV.call(e, n) ? e[n] : void 0;
}
var UV = Object.prototype, KV = UV.hasOwnProperty;
function GV(n) {
  var e = this.__data__;
  return If ? e[n] !== void 0 : KV.call(e, n);
}
var YV = "__lodash_hash_undefined__";
function JV(n, e) {
  var t = this.__data__;
  return this.size += this.has(n) ? 0 : 1, t[n] = If && e === void 0 ? YV : e, this;
}
function ka(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
ka.prototype.clear = HV;
ka.prototype.delete = $V;
ka.prototype.get = jV;
ka.prototype.has = GV;
ka.prototype.set = JV;
function XV() {
  this.__data__ = [], this.size = 0;
}
function p1(n, e) {
  for (var t = n.length; t--; )
    if (d1(n[t][0], e))
      return t;
  return -1;
}
var ZV = Array.prototype, QV = ZV.splice;
function eq(n) {
  var e = this.__data__, t = p1(e, n);
  if (t < 0)
    return !1;
  var r = e.length - 1;
  return t == r ? e.pop() : QV.call(e, t, 1), --this.size, !0;
}
function tq(n) {
  var e = this.__data__, t = p1(e, n);
  return t < 0 ? void 0 : e[t][1];
}
function nq(n) {
  return p1(this.__data__, n) > -1;
}
function rq(n, e) {
  var t = this.__data__, r = p1(t, n);
  return r < 0 ? (++this.size, t.push([n, e])) : t[r][1] = e, this;
}
function vo(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
vo.prototype.clear = XV;
vo.prototype.delete = eq;
vo.prototype.get = tq;
vo.prototype.has = nq;
vo.prototype.set = rq;
var WM = T3(Pa, "Map");
function iq() {
  this.size = 0, this.__data__ = {
    hash: new ka(),
    map: new (WM || vo)(),
    string: new ka()
  };
}
function sq(n) {
  var e = typeof n;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null;
}
function m1(n, e) {
  var t = n.__data__;
  return sq(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function oq(n) {
  var e = m1(this, n).delete(n);
  return this.size -= e ? 1 : 0, e;
}
function lq(n) {
  return m1(this, n).get(n);
}
function aq(n) {
  return m1(this, n).has(n);
}
function cq(n, e) {
  var t = m1(this, n), r = t.size;
  return t.set(n, e), this.size += t.size == r ? 0 : 1, this;
}
function Qc(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
Qc.prototype.clear = iq;
Qc.prototype.delete = oq;
Qc.prototype.get = lq;
Qc.prototype.has = aq;
Qc.prototype.set = cq;
var jM = _V(Object.getPrototypeOf, Object), uq = "[object Object]", hq = Function.prototype, fq = Object.prototype, UM = hq.toString, dq = fq.hasOwnProperty, pq = UM.call(Object);
function mq(n) {
  if (!Zc(n) || hd(n) != uq)
    return !1;
  var e = jM(n);
  if (e === null)
    return !0;
  var t = dq.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && UM.call(t) == pq;
}
function gq() {
  this.__data__ = new vo(), this.size = 0;
}
function yq(n) {
  var e = this.__data__, t = e.delete(n);
  return this.size = e.size, t;
}
function bq(n) {
  return this.__data__.get(n);
}
function vq(n) {
  return this.__data__.has(n);
}
var wq = 200;
function xq(n, e) {
  var t = this.__data__;
  if (t instanceof vo) {
    var r = t.__data__;
    if (!WM || r.length < wq - 1)
      return r.push([n, e]), this.size = ++t.size, this;
    t = this.__data__ = new Qc(r);
  }
  return t.set(n, e), this.size = t.size, this;
}
function eu(n) {
  var e = this.__data__ = new vo(n);
  this.size = e.size;
}
eu.prototype.clear = gq;
eu.prototype.delete = yq;
eu.prototype.get = bq;
eu.prototype.has = vq;
eu.prototype.set = xq;
var KM = typeof exports == "object" && exports && !exports.nodeType && exports, Ew = KM && typeof module == "object" && module && !module.nodeType && module, kq = Ew && Ew.exports === KM, Iw = kq ? Pa.Buffer : void 0;
Iw && Iw.allocUnsafe;
function Sq(n, e) {
  return n.slice();
}
var Dw = Pa.Uint8Array;
function Cq(n) {
  var e = new n.constructor(n.byteLength);
  return new Dw(e).set(new Dw(n)), e;
}
function Mq(n, e) {
  var t = Cq(n.buffer);
  return new n.constructor(t, n.byteOffset, n.length);
}
function Tq(n) {
  return typeof n.constructor == "function" && !BM(n) ? P$(jM(n)) : {};
}
function Aq(n) {
  return function(e, t, r) {
    for (var i = -1, s = Object(e), o = r(e), l = o.length; l--; ) {
      var a = o[++i];
      if (t(s[a], a, s) === !1)
        break;
    }
    return e;
  };
}
var Oq = Aq(), l2 = function() {
  return Pa.Date.now();
}, Eq = "Expected a function", Iq = Math.max, Dq = Math.min;
function g1(n, e, t) {
  var r, i, s, o, l, a, c = 0, u = !1, h = !1, f = !0;
  if (typeof n != "function")
    throw new TypeError(Eq);
  e = ww(e) || 0, Qr(t) && (u = !!t.leading, h = "maxWait" in t, s = h ? Iq(ww(t.maxWait) || 0, e) : s, f = "trailing" in t ? !!t.trailing : f);
  function d(T) {
    var N = r, B = i;
    return r = i = void 0, c = T, o = n.apply(B, N), o;
  }
  function p(T) {
    return c = T, l = setTimeout(b, e), u ? d(T) : o;
  }
  function m(T) {
    var N = T - a, B = T - c, $ = e - N;
    return h ? Dq($, s - B) : $;
  }
  function g(T) {
    var N = T - a, B = T - c;
    return a === void 0 || N >= e || N < 0 || h && B >= s;
  }
  function b() {
    var T = l2();
    if (g(T))
      return w(T);
    l = setTimeout(b, m(T));
  }
  function w(T) {
    return l = void 0, f && r ? d(T) : (r = i = void 0, o);
  }
  function k() {
    l !== void 0 && clearTimeout(l), c = 0, r = a = i = l = void 0;
  }
  function C() {
    return l === void 0 ? o : w(l2());
  }
  function M() {
    var T = l2(), N = g(T);
    if (r = arguments, i = this, a = T, N) {
      if (l === void 0)
        return p(a);
      if (h)
        return clearTimeout(l), l = setTimeout(b, e), d(a);
    }
    return l === void 0 && (l = setTimeout(b, e)), o;
  }
  return M.cancel = k, M.flush = C, M;
}
function iy(n, e, t) {
  (t !== void 0 && !d1(n[e], t) || t === void 0 && !(e in n)) && A3(n, e, t);
}
function Nq(n) {
  return Zc(n) && O3(n);
}
function sy(n, e) {
  if (!(e === "constructor" && typeof n[e] == "function") && e != "__proto__")
    return n[e];
}
function Rq(n) {
  return G$(n, qM(n));
}
function Pq(n, e, t, r, i, s, o) {
  var l = sy(n, t), a = sy(e, t), c = o.get(a);
  if (c) {
    iy(n, t, c);
    return;
  }
  var u = s ? s(l, a, t + "", n, e, o) : void 0, h = u === void 0;
  if (h) {
    var f = ny(a), d = !f && HM(a), p = !f && !d && VM(a);
    u = a, f || d || p ? ny(l) ? u = l : Nq(l) ? u = _$(l) : d ? (h = !1, u = Sq(a)) : p ? (h = !1, u = Mq(a)) : u = [] : mq(a) || ry(a) ? (u = l, ry(l) ? u = Rq(l) : (!Qr(l) || M3(l)) && (u = Tq(a))) : h = !1;
  }
  h && (o.set(a, u), i(u, a, r, s, o), o.delete(a)), iy(n, t, u);
}
function E3(n, e, t, r, i) {
  n !== e && Oq(e, function(s, o) {
    if (i || (i = new eu()), Qr(s))
      Pq(n, e, o, t, E3, r, i);
    else {
      var l = r ? r(sy(n, o), s, o + "", n, e, i) : void 0;
      l === void 0 && (l = s), iy(n, o, l);
    }
  }, qM);
}
function GM(n, e, t, r, i, s) {
  return Qr(n) && Qr(e) && (s.set(e, n), E3(n, e, void 0, GM, s), s.delete(e)), n;
}
var _q = Z$(function(n, e, t, r) {
  E3(n, e, t, r);
}), Lq = _M(function(n) {
  return n.push(void 0, GM), RM(_q, void 0, n);
}), Bq = "Expected a function";
function y1(n, e, t) {
  var r = !0, i = !0;
  if (typeof n != "function")
    throw new TypeError(Bq);
  return Qr(t) && (r = "leading" in t ? !!t.leading : r, i = "trailing" in t ? !!t.trailing : i), g1(n, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
const zq = 1024;
let Fq = 0, ai = class {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
};
class st {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = Fq++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = gr.match(e)), (t) => {
      let r = e(t);
      return r === void 0 ? null : [this, r];
    };
  }
}
st.closedBy = new st({ deserialize: (n) => n.split(" ") });
st.openedBy = new st({ deserialize: (n) => n.split(" ") });
st.group = new st({ deserialize: (n) => n.split(" ") });
st.isolate = new st({ deserialize: (n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
} });
st.contextHash = new st({ perNode: !0 });
st.lookAhead = new st({ perNode: !0 });
st.mounted = new st({ perNode: !0 });
class Df {
  constructor(e, t, r) {
    this.tree = e, this.overlay = t, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[st.mounted.id];
  }
}
const Hq = /* @__PURE__ */ Object.create(null);
class gr {
  /**
  @internal
  */
  constructor(e, t, r, i = 0) {
    this.name = e, this.props = t, this.id = r, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : Hq, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new gr(e.name || "", t, e.id, r);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[s[0].id] = s[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(st.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let i of r.split(" "))
        t[i] = e[r];
    return (r) => {
      for (let i = r.prop(st.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = t[s < 0 ? r.name : i[s]];
        if (o)
          return o;
      }
    };
  }
}
gr.none = new gr(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class I3 {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let r of this.types) {
      let i = null;
      for (let s of e) {
        let o = s(r);
        o && (i || (i = Object.assign({}, r.props)), i[o[0].id] = o[1]);
      }
      t.push(i ? new gr(r.name, i, r.id, r.flags) : r);
    }
    return new I3(t);
  }
}
const Jd = /* @__PURE__ */ new WeakMap(), Nw = /* @__PURE__ */ new WeakMap();
var Zt;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Zt || (Zt = {}));
class zt {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, r, i, s) {
    if (this.type = e, this.children = t, this.positions = r, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of s)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Df.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (t && (t += ","), t += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new cm(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, r = 0) {
    let i = Jd.get(this) || this.topNode, s = new cm(i);
    return s.moveTo(e, t), Jd.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Yn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let r = Nf(Jd.get(this) || this.topNode, e, t, !1);
    return Jd.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let r = Nf(Nw.get(this) || this.topNode, e, t, !0);
    return Nw.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return qq(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: r, from: i = 0, to: s = this.length } = e, o = e.mode || 0, l = (o & Zt.IncludeAnonymous) > 0;
    for (let a = this.cursor(o | Zt.IncludeAnonymous); ; ) {
      let c = !1;
      if (a.from <= s && a.to >= i && (!l && a.type.isAnonymous || t(a) !== !1)) {
        if (a.firstChild())
          continue;
        c = !0;
      }
      for (; c && r && (l || !a.type.isAnonymous) && r(a), !a.nextSibling(); ) {
        if (!a.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : R3(gr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, r, i) => new zt(this.type, t, r, i, this.propValues), e.makeTree || ((t, r, i) => new zt(gr.none, t, r, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return Wq(e);
  }
}
zt.empty = new zt(gr.none, [], [], 0);
class D3 {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new D3(this.buffer, this.index);
  }
}
class ul {
  /**
  Create a tree buffer.
  */
  constructor(e, t, r) {
    this.buffer = e, this.length = t, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return gr.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[t], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, r == e)
      return s;
    let o = [];
    for (; e < r; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, r, i, s) {
    let { buffer: o } = this, l = -1;
    for (let a = e; a != t && !(YM(s, i, o[a + 1], o[a + 2]) && (l = a, r > 0)); a = o[a + 3])
      ;
    return l;
  }
  /**
  @internal
  */
  slice(e, t, r) {
    let i = this.buffer, s = new Uint16Array(t - e), o = 0;
    for (let l = e, a = 0; l < t; ) {
      s[a++] = i[l++], s[a++] = i[l++] - r;
      let c = s[a++] = i[l++] - r;
      s[a++] = i[l++] - e, o = Math.max(o, c);
    }
    return new ul(s, o, this.set);
  }
}
function YM(n, e, t, r) {
  switch (n) {
    case -2:
      return t < e;
    case -1:
      return r >= e && t < e;
    case 0:
      return t < e && r > e;
    case 1:
      return t <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function Nf(n, e, t, r) {
  for (var i; n.from == n.to || (t < 1 ? n.from >= e : n.from > e) || (t > -1 ? n.to <= e : n.to < e); ) {
    let o = !r && n instanceof Yn && n.index < 0 ? null : n.parent;
    if (!o)
      return n;
    n = o;
  }
  let s = r ? 0 : Zt.IgnoreOverlays;
  if (r)
    for (let o = n, l = o.parent; l; o = l, l = o.parent)
      o instanceof Yn && o.index < 0 && ((i = l.enter(e, t, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (n = l);
  for (; ; ) {
    let o = n.enter(e, t, s);
    if (!o)
      return n;
    n = o;
  }
}
class JM {
  cursor(e = 0) {
    return new cm(this, e);
  }
  getChild(e, t = null, r = null) {
    let i = Rw(this, e, t, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, t = null, r = null) {
    return Rw(this, e, t, r);
  }
  resolve(e, t = 0) {
    return Nf(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Nf(this, e, t, !0);
  }
  matchContext(e) {
    return oy(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), r = this;
    for (; t; ) {
      let i = t.lastChild;
      if (!i || i.to != t.to)
        break;
      i.type.isError && i.from == i.to ? (r = t, t = i.prevSibling) : t = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Yn extends JM {
  constructor(e, t, r, i) {
    super(), this._tree = e, this.from = t, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, r, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: a } = o._tree, c = t > 0 ? l.length : -1; e != c; e += t) {
        let u = l[e], h = a[e] + o.from;
        if (YM(i, r, h, h + u.length)) {
          if (u instanceof ul) {
            if (s & Zt.ExcludeBuffers)
              continue;
            let f = u.findChild(0, u.buffer.length, t, r - h, i);
            if (f > -1)
              return new hs(new $q(o, u, e, h), null, f);
          } else if (s & Zt.IncludeAnonymous || !u.type.isAnonymous || N3(u)) {
            let f;
            if (!(s & Zt.IgnoreMounts) && (f = Df.get(u)) && !f.overlay)
              return new Yn(f.tree, h, e, o);
            let d = new Yn(u, h, e, o);
            return s & Zt.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(t < 0 ? u.children.length - 1 : 0, t, r, i);
          }
        }
      }
      if (s & Zt.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    let i;
    if (!(r & Zt.IgnoreOverlays) && (i = Df.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: l } of i.overlay)
        if ((t > 0 ? o <= s : o < s) && (t < 0 ? l >= s : l > s))
          return new Yn(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function Rw(n, e, t, r) {
  let i = n.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (t != null) {
    for (let o = !1; !o; )
      if (o = i.type.is(t), !i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return r == null ? s : [];
  }
}
function oy(n, e, t = e.length - 1) {
  for (let r = n; t >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[t] && e[t] != r.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class $q {
  constructor(e, t, r, i) {
    this.parent = e, this.buffer = t, this.index = r, this.start = i;
  }
}
class hs extends JM {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, r) {
    super(), this.context = e, this._parent = t, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, t, r) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.context.start, r);
    return s < 0 ? null : new hs(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    if (r & Zt.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return s < 0 ? null : new hs(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new hs(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new hs(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: r } = this.context, i = this.index + 4, s = r.buffer[this.index + 3];
    if (s > i) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(i, s, o)), t.push(0);
    }
    return new zt(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function XM(n) {
  if (!n.length)
    return null;
  let e = 0, t = n[0];
  for (let s = 1; s < n.length; s++) {
    let o = n[s];
    (o.from > t.from || o.to < t.to) && (t = o, e = s);
  }
  let r = t instanceof Yn && t.index < 0 ? null : t.parent, i = n.slice();
  return r ? i[e] = r : i.splice(e, 1), new Vq(i, t);
}
class Vq {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return XM(this.heads);
  }
}
function qq(n, e, t) {
  let r = n.resolveInner(e, t), i = null;
  for (let s = r instanceof Yn ? r : r.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [r])).push(o.resolve(e, t)), s = o;
    } else {
      let o = Df.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let l = new Yn(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [r])).push(Nf(l, e, t, !1));
      }
    }
  return i ? XM(i) : r;
}
class cm {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Yn)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return this.type = t || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Yn ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, r, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.buffer.start, r);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, r = this.mode) {
    return this.buffer ? r & Zt.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Zt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Zt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(t.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = t.buffer[this.index + 3];
      if (i < (r < 0 ? t.buffer.length : t.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, r, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: t, parent: r } = i);
    } else
      ({ index: t, _parent: r } = this._tree);
    for (; r; { index: t, _parent: r } = r)
      if (t > -1)
        for (let s = t + e, o = e < 0 ? -1 : r._tree.children.length; s != o; s += e) {
          let l = r._tree.children[s];
          if (this.mode & Zt.IncludeAnonymous || l instanceof ul || !l.type.isAnonymous || N3(l))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, r = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == i) {
            if (i == this.index)
              return o;
            t = o, r = s + 1;
            break e;
          }
        i = this.stack[--s];
      }
    for (let i = r; i < this.stack.length; i++)
      t = new hs(this.buffer, t, this.stack[i]);
    return this.bufferNode = new hs(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && t && t(this), i = this.type.isAnonymous, !r)
          return;
        if (this.nextSibling())
          break;
        this.parent(), r--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return oy(this.node.parent, e);
    let { buffer: t } = this.buffer, { types: r } = t.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return oy(this._tree, e, i);
      let o = r[t.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function N3(n) {
  return n.children.some((e) => e instanceof ul || !e.type.isAnonymous || N3(e));
}
function Wq(n) {
  var e;
  let { buffer: t, nodeSet: r, maxBufferLength: i = zq, reused: s = [], minRepeatType: o = r.types.length } = n, l = Array.isArray(t) ? new D3(t, t.length) : t, a = r.types, c = 0, u = 0;
  function h(M, T, N, B, $, R) {
    let { id: V, start: z, end: ue, size: ie } = l, he = u, Ce = c;
    for (; ie < 0; )
      if (l.next(), ie == -1) {
        let Ie = s[V];
        N.push(Ie), B.push(z - M);
        return;
      } else if (ie == -3) {
        c = V;
        return;
      } else if (ie == -4) {
        u = V;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${ie}`);
    let ye = a[V], be, ze, I = z - M;
    if (ue - z <= i && (ze = g(l.pos - T, $))) {
      let Ie = new Uint16Array(ze.size - ze.skip), Ve = l.pos - ze.size, O = Ie.length;
      for (; l.pos > Ve; )
        O = b(ze.start, Ie, O);
      be = new ul(Ie, ue - ze.start, r), I = ze.start - M;
    } else {
      let Ie = l.pos - ie;
      l.next();
      let Ve = [], O = [], pt = V >= o ? V : -1, Ue = 0, et = ue;
      for (; l.pos > Ie; )
        pt >= 0 && l.id == pt && l.size >= 0 ? (l.end <= et - i && (p(Ve, O, z, Ue, l.end, et, pt, he, Ce), Ue = Ve.length, et = l.end), l.next()) : R > 2500 ? f(z, Ie, Ve, O) : h(z, Ie, Ve, O, pt, R + 1);
      if (pt >= 0 && Ue > 0 && Ue < Ve.length && p(Ve, O, z, Ue, z, et, pt, he, Ce), Ve.reverse(), O.reverse(), pt > -1 && Ue > 0) {
        let Tt = d(ye, Ce);
        be = R3(ye, Ve, O, 0, Ve.length, 0, ue - z, Tt, Tt);
      } else
        be = m(ye, Ve, O, ue - z, he - ue, Ce);
    }
    N.push(be), B.push(I);
  }
  function f(M, T, N, B) {
    let $ = [], R = 0, V = -1;
    for (; l.pos > T; ) {
      let { id: z, start: ue, end: ie, size: he } = l;
      if (he > 4)
        l.next();
      else {
        if (V > -1 && ue < V)
          break;
        V < 0 && (V = ie - i), $.push(z, ue, ie), R++, l.next();
      }
    }
    if (R) {
      let z = new Uint16Array(R * 4), ue = $[$.length - 2];
      for (let ie = $.length - 3, he = 0; ie >= 0; ie -= 3)
        z[he++] = $[ie], z[he++] = $[ie + 1] - ue, z[he++] = $[ie + 2] - ue, z[he++] = he;
      N.push(new ul(z, $[2] - ue, r)), B.push(ue - M);
    }
  }
  function d(M, T) {
    return (N, B, $) => {
      let R = 0, V = N.length - 1, z, ue;
      if (V >= 0 && (z = N[V]) instanceof zt) {
        if (!V && z.type == M && z.length == $)
          return z;
        (ue = z.prop(st.lookAhead)) && (R = B[V] + z.length + ue);
      }
      return m(M, N, B, $, R, T);
    };
  }
  function p(M, T, N, B, $, R, V, z, ue) {
    let ie = [], he = [];
    for (; M.length > B; )
      ie.push(M.pop()), he.push(T.pop() + N - $);
    M.push(m(r.types[V], ie, he, R - $, z - R, ue)), T.push($ - N);
  }
  function m(M, T, N, B, $, R, V) {
    if (R) {
      let z = [st.contextHash, R];
      V = V ? [z].concat(V) : [z];
    }
    if ($ > 25) {
      let z = [st.lookAhead, $];
      V = V ? [z].concat(V) : [z];
    }
    return new zt(M, T, N, B, V);
  }
  function g(M, T) {
    let N = l.fork(), B = 0, $ = 0, R = 0, V = N.end - i, z = { size: 0, start: 0, skip: 0 };
    e: for (let ue = N.pos - M; N.pos > ue; ) {
      let ie = N.size;
      if (N.id == T && ie >= 0) {
        z.size = B, z.start = $, z.skip = R, R += 4, B += 4, N.next();
        continue;
      }
      let he = N.pos - ie;
      if (ie < 0 || he < ue || N.start < V)
        break;
      let Ce = N.id >= o ? 4 : 0, ye = N.start;
      for (N.next(); N.pos > he; ) {
        if (N.size < 0)
          if (N.size == -3)
            Ce += 4;
          else
            break e;
        else N.id >= o && (Ce += 4);
        N.next();
      }
      $ = ye, B += ie, R += Ce;
    }
    return (T < 0 || B == M) && (z.size = B, z.start = $, z.skip = R), z.size > 4 ? z : void 0;
  }
  function b(M, T, N) {
    let { id: B, start: $, end: R, size: V } = l;
    if (l.next(), V >= 0 && B < o) {
      let z = N;
      if (V > 4) {
        let ue = l.pos - (V - 4);
        for (; l.pos > ue; )
          N = b(M, T, N);
      }
      T[--N] = z, T[--N] = R - M, T[--N] = $ - M, T[--N] = B;
    } else V == -3 ? c = B : V == -4 && (u = B);
    return N;
  }
  let w = [], k = [];
  for (; l.pos > 0; )
    h(n.start || 0, n.bufferStart || 0, w, k, -1, 0);
  let C = (e = n.length) !== null && e !== void 0 ? e : w.length ? k[0] + w[0].length : 0;
  return new zt(a[n.topID], w.reverse(), k.reverse(), C);
}
const Pw = /* @__PURE__ */ new WeakMap();
function ap(n, e) {
  if (!n.isAnonymous || e instanceof ul || e.type != n)
    return 1;
  let t = Pw.get(e);
  if (t == null) {
    t = 1;
    for (let r of e.children) {
      if (r.type != n || !(r instanceof zt)) {
        t = 1;
        break;
      }
      t += ap(n, r);
    }
    Pw.set(e, t);
  }
  return t;
}
function R3(n, e, t, r, i, s, o, l, a) {
  let c = 0;
  for (let p = r; p < i; p++)
    c += ap(n, e[p]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], f = [];
  function d(p, m, g, b, w) {
    for (let k = g; k < b; ) {
      let C = k, M = m[k], T = ap(n, p[k]);
      for (k++; k < b; k++) {
        let N = ap(n, p[k]);
        if (T + N >= u)
          break;
        T += N;
      }
      if (k == C + 1) {
        if (T > u) {
          let N = p[C];
          d(N.children, N.positions, 0, N.children.length, m[C] + w);
          continue;
        }
        h.push(p[C]);
      } else {
        let N = m[k - 1] + p[k - 1].length - M;
        h.push(R3(n, p, m, C, k, M, N, null, a));
      }
      f.push(M + w - s);
    }
  }
  return d(e, t, r, i, 0), (l || a)(h, f, o);
}
class $ue {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, r) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(t, r);
  }
  getBuffer(e, t) {
    let r = this.map.get(e);
    return r && r.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof hs ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof Yn && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof hs ? this.getBuffer(e.context.buffer, e.index) : e instanceof Yn ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class no {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, r, i, s = !1, o = !1) {
    this.from = e, this.to = t, this.tree = r, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], r = !1) {
    let i = [new no(0, e.length, e, 0, !1, r)];
    for (let s of t)
      s.to > e.length && i.push(s);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, r = 128) {
    if (!t.length)
      return e;
    let i = [], s = 1, o = e.length ? e[0] : null;
    for (let l = 0, a = 0, c = 0; ; l++) {
      let u = l < t.length ? t[l] : null, h = u ? u.fromA : 1e9;
      if (h - a >= r)
        for (; o && o.from < h; ) {
          let f = o;
          if (a >= f.from || h <= f.to || c) {
            let d = Math.max(f.from, a) - c, p = Math.min(f.to, h) - c;
            f = d >= p ? null : new no(d, p, f.tree, f.offset + c, l > 0, !!u);
          }
          if (f && i.push(f), o.to > h)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!u)
        break;
      a = u.toA, c = u.toA - u.toB;
    }
    return i;
  }
}
let ZM = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, r) {
    return typeof e == "string" && (e = new jq(e)), r = r ? r.length ? r.map((i) => new ai(i.from, i.to)) : [new ai(0, 0)] : [new ai(0, e.length)], this.createParse(e, t || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, r) {
    let i = this.startParse(e, t, r);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
};
class jq {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function que(n) {
  return (e, t, r, i) => new Kq(e, n, t, r, i);
}
class _w {
  constructor(e, t, r, i, s) {
    this.parser = e, this.parse = t, this.overlay = r, this.target = i, this.from = s;
  }
}
function Lw(n) {
  if (!n.length || n.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(n));
}
class Uq {
  constructor(e, t, r, i, s, o, l) {
    this.parser = e, this.predicate = t, this.mounts = r, this.index = i, this.start = s, this.target = o, this.prev = l, this.depth = 0, this.ranges = [];
  }
}
const ly = new st({ perNode: !0 });
class Kq {
  constructor(e, t, r, i, s) {
    this.nest = t, this.input = r, this.fragments = i, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new zt(r.type, r.children, r.positions, r.length, r.propValues.concat([[ly, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[st.mounted.id] = new Df(t, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new Jq(this.fragments), t = null, r = null, i = new cm(new Yn(this.baseTree, this.ranges[0].from, 0, null), Zt.IncludeAnonymous | Zt.IgnoreMounts);
    e: for (let s, o; ; ) {
      let l = !0, a;
      if (this.stoppedAt != null && i.from >= this.stoppedAt)
        l = !1;
      else if (e.hasNode(i)) {
        if (t) {
          let c = t.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
          if (c)
            for (let u of c.mount.overlay) {
              let h = u.from + c.pos, f = u.to + c.pos;
              h >= i.from && f <= i.to && !t.ranges.some((d) => d.from < f && d.to > h) && t.ranges.push({ from: h, to: f });
            }
        }
        l = !1;
      } else if (r && (o = Gq(r.ranges, i.from, i.to)))
        l = o != 2;
      else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
        i.tree || Yq(i);
        let c = e.findMounts(i.from, s.parser);
        if (typeof s.overlay == "function")
          t = new Uq(s.parser, s.overlay, c, this.inner.length, i.from, i.tree, t);
        else {
          let u = Fw(this.ranges, s.overlay || (i.from < i.to ? [new ai(i.from, i.to)] : []));
          u.length && Lw(u), (u.length || !s.overlay) && this.inner.push(new _w(s.parser, u.length ? s.parser.startParse(this.input, Hw(c, u), u) : s.parser.startParse(""), s.overlay ? s.overlay.map((h) => new ai(h.from - i.from, h.to - i.from)) : null, i.tree, u.length ? u[0].from : i.from)), s.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : l = !1;
        }
      } else if (t && (a = t.predicate(i)) && (a === !0 && (a = new ai(i.from, i.to)), a.from < a.to)) {
        let c = t.ranges.length - 1;
        c >= 0 && t.ranges[c].to == a.from ? t.ranges[c] = { from: t.ranges[c].from, to: a.to } : t.ranges.push(a);
      }
      if (l && i.firstChild())
        t && t.depth++, r && r.depth++;
      else
        for (; !i.nextSibling(); ) {
          if (!i.parent())
            break e;
          if (t && !--t.depth) {
            let c = Fw(this.ranges, t.ranges);
            c.length && (Lw(c), this.inner.splice(t.index, 0, new _w(t.parser, t.parser.startParse(this.input, Hw(t.mounts, c), c), t.ranges.map((u) => new ai(u.from - t.start, u.to - t.start)), t.target, c[0].from))), t = t.prev;
          }
          r && !--r.depth && (r = r.prev);
        }
    }
  }
}
function Gq(n, e, t) {
  for (let r of n) {
    if (r.from >= t)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= t ? 2 : 1;
  }
  return 0;
}
function Bw(n, e, t, r, i, s) {
  if (e < t) {
    let o = n.buffer[e + 1];
    r.push(n.slice(e, t, o)), i.push(o - s);
  }
}
function Yq(n) {
  let { node: e } = n, t = [], r = e.context.buffer;
  do
    t.push(n.index), n.parent();
  while (!n.tree);
  let i = n.tree, s = i.children.indexOf(r), o = i.children[s], l = o.buffer, a = [s];
  function c(u, h, f, d, p, m) {
    let g = t[m], b = [], w = [];
    Bw(o, u, g, b, w, d);
    let k = l[g + 1], C = l[g + 2];
    a.push(b.length);
    let M = m ? c(g + 4, l[g + 3], o.set.types[l[g]], k, C - k, m - 1) : e.toTree();
    return b.push(M), w.push(k - d), Bw(o, l[g + 3], h, b, w, d), new zt(f, b, w, p);
  }
  i.children[s] = c(0, l.length, gr.none, 0, o.length, t.length - 1);
  for (let u of a) {
    let h = n.tree.children[u], f = n.tree.positions[u];
    n.yield(new Yn(h, f + n.from, u, n._tree));
  }
}
class zw {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Zt.IncludeAnonymous | Zt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, r = e - this.offset;
    for (; !this.done && t.from < r; )
      t.to >= e && t.enter(r, 1, Zt.IgnoreOverlays | Zt.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof zt)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
class Jq {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (t = r.tree.prop(ly)) !== null && t !== void 0 ? t : r.to, this.inner = new zw(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(ly)) !== null && e !== void 0 ? e : t.to, this.inner = new zw(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(st.mounted);
        if (o && o.parser == t)
          for (let l = this.fragI; l < this.fragments.length; l++) {
            let a = this.fragments[l];
            if (a.from >= s.to)
              break;
            a.tree == this.curFrag.tree && i.push({
              frag: a,
              pos: s.from - a.offset,
              mount: o
            });
          }
      }
    }
    return i;
  }
}
function Fw(n, e) {
  let t = null, r = e;
  for (let i = 1, s = 0; i < n.length; i++) {
    let o = n[i - 1].to, l = n[i].from;
    for (; s < r.length; s++) {
      let a = r[s];
      if (a.from >= l)
        break;
      a.to <= o || (t || (r = t = e.slice()), a.from < o ? (t[s] = new ai(a.from, o), a.to > l && t.splice(s + 1, 0, new ai(l, a.to))) : a.to > l ? t[s--] = new ai(l, a.to) : t.splice(s--, 1));
    }
  }
  return r;
}
function Xq(n, e, t, r) {
  let i = 0, s = 0, o = !1, l = !1, a = -1e9, c = [];
  for (; ; ) {
    let u = i == n.length ? 1e9 : o ? n[i].to : n[i].from, h = s == e.length ? 1e9 : l ? e[s].to : e[s].from;
    if (o != l) {
      let f = Math.max(a, t), d = Math.min(u, h, r);
      f < d && c.push(new ai(f, d));
    }
    if (a = Math.min(u, h), a == 1e9)
      break;
    u == a && (o ? (o = !1, i++) : o = !0), h == a && (l ? (l = !1, s++) : l = !0);
  }
  return c;
}
function Hw(n, e) {
  let t = [];
  for (let { pos: r, mount: i, frag: s } of n) {
    let o = r + (i.overlay ? i.overlay[0].from : 0), l = o + i.tree.length, a = Math.max(s.from, o), c = Math.min(s.to, l);
    if (i.overlay) {
      let u = i.overlay.map((f) => new ai(f.from + r, f.to + r)), h = Xq(e, u, a, c);
      for (let f = 0, d = a; ; f++) {
        let p = f == h.length, m = p ? c : h[f].from;
        if (m > d && t.push(new no(d, m, i.tree, -o, s.from >= d || s.openStart, s.to <= m || s.openEnd)), p)
          break;
        d = h[f].to;
      }
    } else
      t.push(new no(a, c, i.tree, -o, s.from >= o || s.openStart, s.to <= l || s.openEnd));
  }
  return t;
}
let ay = [], QM = [];
(() => {
  let n = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, t = 0; e < n.length; e++)
    (e % 2 ? QM : ay).push(t = t + n[e]);
})();
function Zq(n) {
  if (n < 768) return !1;
  for (let e = 0, t = ay.length; ; ) {
    let r = e + t >> 1;
    if (n < ay[r]) t = r;
    else if (n >= QM[r]) e = r + 1;
    else return !0;
    if (e == t) return !1;
  }
}
function $w(n) {
  return n >= 127462 && n <= 127487;
}
const Vw = 8205;
function Qq(n, e, t = !0, r = !0) {
  return (t ? eT : eW)(n, e, r);
}
function eT(n, e, t) {
  if (e == n.length) return e;
  e && tT(n.charCodeAt(e)) && nT(n.charCodeAt(e - 1)) && e--;
  let r = a2(n, e);
  for (e += qw(r); e < n.length; ) {
    let i = a2(n, e);
    if (r == Vw || i == Vw || t && Zq(i))
      e += qw(i), r = i;
    else if ($w(i)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && $w(a2(n, o)); )
        s++, o -= 2;
      if (s % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function eW(n, e, t) {
  for (; e > 0; ) {
    let r = eT(n, e - 2, t);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function a2(n, e) {
  let t = n.charCodeAt(e);
  if (!nT(t) || e + 1 == n.length) return t;
  let r = n.charCodeAt(e + 1);
  return tT(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function tT(n) {
  return n >= 56320 && n < 57344;
}
function nT(n) {
  return n >= 55296 && n < 56320;
}
function qw(n) {
  return n < 65536 ? 1 : 2;
}
let dt = class rT {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, r) {
    [e, t] = _c(this, e, t);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      i,
      1
      /* Open.From */
    ), cp.from(i, this.length - (t - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = _c(this, e, t);
    let r = [];
    return this.decompose(e, t, r, 0), cp.from(r, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Xh(this), s = new Xh(e);
    for (let o = t, l = t; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (l += i.value.length, i.done || l >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Xh(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new iT(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new sT(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? rT.empty : e.length <= 32 ? new an(e) : cp.from(an.split(e, []));
  }
};
class an extends dt {
  constructor(e, t = tW(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], l = i + o.length;
      if ((t ? r : l) >= e)
        return new nW(i, l, r, o);
      i = l + 1, r++;
    }
  }
  decompose(e, t, r, i) {
    let s = e <= 0 && t >= this.length ? this : new an(Ww(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = r.pop(), l = up(s.text, o.text.slice(), 0, s.length);
      if (l.length <= 32)
        r.push(new an(l, o.length + s.length));
      else {
        let a = l.length >> 1;
        r.push(new an(l.slice(0, a)), new an(l.slice(a)));
      }
    } else
      r.push(s);
  }
  replace(e, t, r) {
    if (!(r instanceof an))
      return super.replace(e, t, r);
    [e, t] = _c(this, e, t);
    let i = up(this.text, up(r.text, Ww(this.text, 0, e)), t), s = this.length + r.length - (t - e);
    return i.length <= 32 ? new an(i, s) : cp.from(an.split(i, []), s);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = _c(this, e, t);
    let i = "";
    for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
      let l = this.text[o], a = s + l.length;
      s > e && o && (i += r), e < a && t > s && (i += l.slice(Math.max(0, e - s), t - s)), s = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let r = [], i = -1;
    for (let s of e)
      r.push(s), i += s.length + 1, r.length == 32 && (t.push(new an(r, i)), r = [], i = -1);
    return i > -1 && t.push(new an(r, i)), t;
  }
}
let cp = class tc extends dt {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], l = i + o.length, a = r + o.lines - 1;
      if ((t ? a : l) >= e)
        return o.lineInner(e, t, r, i);
      i = l + 1, r = a + 1;
    }
  }
  decompose(e, t, r, i) {
    for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
      let l = this.children[s], a = o + l.length;
      if (e <= a && t >= o) {
        let c = i & ((o <= e ? 1 : 0) | (a >= t ? 2 : 0));
        o >= e && a <= t && !c ? r.push(l) : l.decompose(e - o, t - o, r, c);
      }
      o = a + 1;
    }
  }
  replace(e, t, r) {
    if ([e, t] = _c(this, e, t), r.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], l = s + o.length;
        if (e >= s && t <= l) {
          let a = o.replace(e - s, t - s, r), c = this.lines - o.lines + a.lines;
          if (a.lines < c >> 4 && a.lines > c >> 6) {
            let u = this.children.slice();
            return u[i] = a, new tc(u, this.length - (t - e) + r.length);
          }
          return super.replace(s, l, a);
        }
        s = l + 1;
      }
    return super.replace(e, t, r);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = _c(this, e, t);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
      let l = this.children[s], a = o + l.length;
      o > e && s && (i += r), e < a && t > o && (i += l.sliceString(e - o, t - o, r)), o = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof tc))
      return 0;
    let r = 0, [i, s, o, l] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += t, s += t) {
      if (i == o || s == l)
        return r;
      let a = this.children[i], c = e.children[s];
      if (a != c)
        return r + a.scanIdentical(c, t);
      r += a.length + 1;
    }
  }
  static from(e, t = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let d of e)
      r += d.lines;
    if (r < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new an(d, t);
    }
    let i = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), s = i << 1, o = i >> 1, l = [], a = 0, c = -1, u = [];
    function h(d) {
      let p;
      if (d.lines > s && d instanceof tc)
        for (let m of d.children)
          h(m);
      else d.lines > o && (a > o || !a) ? (f(), l.push(d)) : d instanceof an && a && (p = u[u.length - 1]) instanceof an && d.lines + p.lines <= 32 ? (a += d.lines, c += d.length + 1, u[u.length - 1] = new an(p.text.concat(d.text), p.length + 1 + d.length)) : (a + d.lines > i && f(), a += d.lines, c += d.length + 1, u.push(d));
    }
    function f() {
      a != 0 && (l.push(u.length == 1 ? u[0] : tc.from(u, c)), c = -1, a = u.length = 0);
    }
    for (let d of e)
      h(d);
    return f(), l.length == 1 ? l[0] : new tc(l, t);
  }
};
dt.empty = /* @__PURE__ */ new an([""], 0);
function tW(n) {
  let e = -1;
  for (let t of n)
    e += t.length + 1;
  return e;
}
function up(n, e, t = 0, r = 1e9) {
  for (let i = 0, s = 0, o = !0; s < n.length && i <= r; s++) {
    let l = n[s], a = i + l.length;
    a >= t && (a > r && (l = l.slice(0, r - i)), i < t && (l = l.slice(t - i)), o ? (e[e.length - 1] += l, o = !1) : e.push(l)), i = a + 1;
  }
  return e;
}
function Ww(n, e, t) {
  return up(n, [""], e, t);
}
class Xh {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof an ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], s = this.offsets[r], o = s >> 1, l = i instanceof an ? i.text.length : i.children.length;
      if (o == (t > 0 ? l : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[r] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof an) {
        let a = i.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[r] += t, a.length > Math.max(0, e))
          return this.value = e == 0 ? a : t > 0 ? a.slice(e) : a.slice(0, a.length - e), this;
        e -= a.length;
      } else {
        let a = i.children[o + (t < 0 ? -1 : 0)];
        e > a.length ? (e -= a.length, this.offsets[r] += t) : (t < 0 && this.offsets[r]--, this.nodes.push(a), this.offsets.push(t > 0 ? 1 : (a instanceof an ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class iT {
  constructor(e, t, r) {
    this.value = "", this.done = !1, this.cursor = new Xh(e, t > r ? -1 : 1), this.pos = t > r ? e.length : 0, this.from = Math.min(t, r), this.to = Math.max(t, r);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let r = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * t, this.value = i.length <= r ? i : t < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class sT {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: r, value: i } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (dt.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Xh.prototype[Symbol.iterator] = iT.prototype[Symbol.iterator] = sT.prototype[Symbol.iterator] = function() {
  return this;
});
class nW {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.number = r, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function _c(n, e, t) {
  return e = Math.max(0, Math.min(n.length, e)), [e, Math.max(e, Math.min(n.length, t))];
}
function zn(n, e, t = !0, r = !0) {
  return Qq(n, e, t, r);
}
function rW(n) {
  return n >= 56320 && n < 57344;
}
function iW(n) {
  return n >= 55296 && n < 56320;
}
function Sr(n, e) {
  let t = n.charCodeAt(e);
  if (!iW(t) || e + 1 == n.length)
    return t;
  let r = n.charCodeAt(e + 1);
  return rW(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function P3(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
function ls(n) {
  return n < 65536 ? 1 : 2;
}
const cy = /\r\n?|\n/;
var Bn = /* @__PURE__ */ (function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
})(Bn || (Bn = {}));
class ys {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t + 1];
      e += r < 0 ? this.sections[t] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, r = 0, i = 0; t < this.sections.length; ) {
      let s = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(r, i, s), i += s) : i += o, r += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    uy(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new ys(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : oT(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : hy(this, e, t);
  }
  mapPos(e, t = -1, r = Bn.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], a = this.sections[o++], c = i + l;
      if (a < 0) {
        if (c > e)
          return s + (e - i);
        s += l;
      } else {
        if (r != Bn.Simple && c >= e && (r == Bn.TrackDel && i < e && c > e || r == Bn.TrackBefore && i < e || r == Bn.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !l)
          return e == i || t < 0 ? s : s + a;
        s += a;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= t; ) {
      let s = this.sections[r++], o = this.sections[r++], l = i + s;
      if (o >= 0 && i <= t && l >= e)
        return i < e && l > t ? "cover" : !0;
      i = l;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ys(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new ys(e);
  }
}
class wn extends ys {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return uy(this, (t, r, i, s, o) => e = e.replace(i, i + (r - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return hy(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), r = [];
    for (let i = 0, s = 0; i < t.length; i += 2) {
      let o = t[i], l = t[i + 1];
      if (l >= 0) {
        t[i] = l, t[i + 1] = o;
        let a = i >> 1;
        for (; r.length < a; )
          r.push(dt.empty);
        r.push(o ? e.slice(s, s + o) : dt.empty);
      }
      s += o;
    }
    return new wn(t, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : oT(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : hy(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    uy(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ys.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], r = [], i = [], s = new Rf(this);
    e: for (let o = 0, l = 0; ; ) {
      let a = o == e.length ? 1e9 : e[o++];
      for (; l < a || l == a && s.len == 0; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, a - l);
        Wn(i, u, -1);
        let h = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        Wn(t, u, h), h > 0 && Jo(r, t, s.text), s.forward(u), l += u;
      }
      let c = e[o++];
      for (; l < c; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, c - l);
        Wn(t, u, -1), Wn(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), l += u;
      }
    }
    return {
      changes: new wn(t, r),
      filtered: ys.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t], i = this.sections[t + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, r) {
    let i = [], s = [], o = 0, l = null;
    function a(u = !1) {
      if (!u && !i.length)
        return;
      o < t && Wn(i, t - o, -1);
      let h = new wn(i, s);
      l = l ? l.compose(h.map(l)) : h, i = [], s = [], o = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let h of u)
          c(h);
      else if (u instanceof wn) {
        if (u.length != t)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${t})`);
        a(), l = l ? l.compose(u.map(l)) : u;
      } else {
        let { from: h, to: f = h, insert: d } = u;
        if (h > f || h < 0 || f > t)
          throw new RangeError(`Invalid change range ${h} to ${f} (in doc of length ${t})`);
        let p = d ? typeof d == "string" ? dt.of(d.split(r || cy)) : d : dt.empty, m = p.length;
        if (h == f && m == 0)
          return;
        h < o && a(), h > o && Wn(i, h - o, -1), Wn(i, f - h, m), Jo(s, i, p), o = f;
      }
    }
    return c(e), a(!l), l;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new wn(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], r = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        t.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          t.push(s[0], 0);
        else {
          for (; r.length < i; )
            r.push(dt.empty);
          r[i] = dt.of(s.slice(1)), t.push(s[0], r[i].length);
        }
      }
    }
    return new wn(t, r);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new wn(e, t);
  }
}
function Wn(n, e, t, r = !1) {
  if (e == 0 && t <= 0)
    return;
  let i = n.length - 2;
  i >= 0 && t <= 0 && t == n[i + 1] ? n[i] += e : i >= 0 && e == 0 && n[i] == 0 ? n[i + 1] += t : r ? (n[i] += e, n[i + 1] += t) : n.push(e, t);
}
function Jo(n, e, t) {
  if (t.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < n.length)
    n[n.length - 1] = n[n.length - 1].append(t);
  else {
    for (; n.length < r; )
      n.push(dt.empty);
    n.push(t);
  }
}
function uy(n, e, t) {
  let r = n.inserted;
  for (let i = 0, s = 0, o = 0; o < n.sections.length; ) {
    let l = n.sections[o++], a = n.sections[o++];
    if (a < 0)
      i += l, s += l;
    else {
      let c = i, u = s, h = dt.empty;
      for (; c += l, u += a, a && r && (h = h.append(r[o - 2 >> 1])), !(t || o == n.sections.length || n.sections[o + 1] < 0); )
        l = n.sections[o++], a = n.sections[o++];
      e(i, c, s, u, h), i = c, s = u;
    }
  }
}
function hy(n, e, t, r = !1) {
  let i = [], s = r ? [] : null, o = new Rf(n), l = new Rf(e);
  for (let a = -1; ; ) {
    if (o.done && l.len || l.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && l.ins == -1) {
      let c = Math.min(o.len, l.len);
      Wn(i, c, -1), o.forward(c), l.forward(c);
    } else if (l.ins >= 0 && (o.ins < 0 || a == o.i || o.off == 0 && (l.len < o.len || l.len == o.len && !t))) {
      let c = l.len;
      for (Wn(i, l.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && a < o.i && o.len <= u && (Wn(i, 0, o.ins), s && Jo(s, i, o.text), a = o.i), o.forward(u), c -= u;
      }
      l.next();
    } else if (o.ins >= 0) {
      let c = 0, u = o.len;
      for (; u; )
        if (l.ins == -1) {
          let h = Math.min(u, l.len);
          c += h, u -= h, l.forward(h);
        } else if (l.ins == 0 && l.len < u)
          u -= l.len, l.next();
        else
          break;
      Wn(i, c, a < o.i ? o.ins : 0), s && a < o.i && Jo(s, i, o.text), a = o.i, o.forward(o.len - u);
    } else {
      if (o.done && l.done)
        return s ? wn.createSet(i, s) : ys.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function oT(n, e, t = !1) {
  let r = [], i = t ? [] : null, s = new Rf(n), o = new Rf(e);
  for (let l = !1; ; ) {
    if (s.done && o.done)
      return i ? wn.createSet(r, i) : ys.create(r);
    if (s.ins == 0)
      Wn(r, s.len, 0, l), s.next();
    else if (o.len == 0 && !o.done)
      Wn(r, 0, o.ins, l), i && Jo(i, r, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(s.len2, o.len), c = r.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          Wn(r, a, u, l), i && u && Jo(i, r, o.text);
        } else o.ins == -1 ? (Wn(r, s.off ? 0 : s.len, a, l), i && Jo(i, r, s.textBit(a))) : (Wn(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, l), i && !o.off && Jo(i, r, o.text));
        l = (s.ins > a || o.ins >= 0 && o.len > a) && (l || r.length > c), s.forward2(a), o.forward(a);
      }
    }
  }
}
class Rf {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? dt.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, r = this.i - 2 >> 1;
    return r >= t.length && !e ? dt.empty : t[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class ea {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.flags = r;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let r, i;
    return this.empty ? r = i = e.mapPos(this.from, t) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new ea(r, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return G.range(e, t);
    let r = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return G.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return G.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new ea(e, t, r);
  }
}
class G {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : G.create(this.ranges.map((r) => r.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new G([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return G.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let r = this.ranges.slice();
    return r[t] = e, G.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new G(e.ranges.map((t) => ea.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new G([G.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= r : s.from < r)
        return G.normalized(e.slice(), t);
      r = s.to;
    }
    return new G(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, r, i) {
    return ea.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, r, i) {
    let s = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return t < e ? ea.create(t, e, 48 | s) : ea.create(e, t, (t > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let r = e[t];
    e.sort((i, s) => i.from - s.from), t = e.indexOf(r);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let l = o.from, a = Math.max(s.to, o.to);
        i <= t && t--, e.splice(--i, 2, s.anchor > s.head ? G.range(a, l) : G.range(l, a));
      }
    }
    return new G(e, t);
  }
}
function lT(n, e) {
  for (let t of n.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let _3 = 0;
class ke {
  constructor(e, t, r, i, s) {
    this.combine = e, this.compareInput = t, this.compare = r, this.isStatic = i, this.id = _3++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new ke(e.combine || ((t) => t), e.compareInput || ((t, r) => t === r), e.compare || (e.combine ? (t, r) => t === r : L3), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new hp([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new hp(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new hp(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (r) => r), this.compute([e], (r) => t(r.field(e)));
  }
}
function L3(n, e) {
  return n == e || n.length == e.length && n.every((t, r) => t === e[r]);
}
class hp {
  constructor(e, t, r, i) {
    this.dependencies = e, this.facet = t, this.type = r, this.value = i, this.id = _3++;
  }
  dynamicSlot(e) {
    var t;
    let r = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, l = this.type == 2, a = !1, c = !1, u = [];
    for (let h of this.dependencies)
      h == "doc" ? a = !0 : h == "selection" ? c = !0 : (((t = e[h.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 && u.push(e[h.id]);
    return {
      create(h) {
        return h.values[o] = r(h), 1;
      },
      update(h, f) {
        if (a && f.docChanged || c && (f.docChanged || f.selection) || fy(h, u)) {
          let d = r(h);
          if (l ? !jw(d, h.values[o], i) : !i(d, h.values[o]))
            return h.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (h, f) => {
        let d, p = f.config.address[s];
        if (p != null) {
          let m = hm(f, p);
          if (this.dependencies.every((g) => g instanceof ke ? f.facet(g) === h.facet(g) : g instanceof On ? f.field(g, !1) == h.field(g, !1) : !0) || (l ? jw(d = r(h), m, i) : i(d = r(h), m)))
            return h.values[o] = m, 0;
        } else
          d = r(h);
        return h.values[o] = d, 1;
      }
    };
  }
}
function jw(n, e, t) {
  if (n.length != e.length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (!t(n[r], e[r]))
      return !1;
  return !0;
}
function fy(n, e) {
  let t = !1;
  for (let r of e)
    Zh(n, r) & 1 && (t = !0);
  return t;
}
function sW(n, e, t) {
  let r = t.map((a) => n[a.id]), i = t.map((a) => a.type), s = r.filter((a) => !(a & 1)), o = n[e.id] >> 1;
  function l(a) {
    let c = [];
    for (let u = 0; u < r.length; u++) {
      let h = hm(a, r[u]);
      if (i[u] == 2)
        for (let f of h)
          c.push(f);
      else
        c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(a) {
      for (let c of r)
        Zh(a, c);
      return a.values[o] = l(a), 1;
    },
    update(a, c) {
      if (!fy(a, s))
        return 0;
      let u = l(a);
      return e.compare(u, a.values[o]) ? 0 : (a.values[o] = u, 1);
    },
    reconfigure(a, c) {
      let u = fy(a, r), h = c.config.facets[e.id], f = c.facet(e);
      if (h && !u && L3(t, h))
        return a.values[o] = f, 0;
      let d = l(a);
      return e.compare(d, f) ? (a.values[o] = f, 0) : (a.values[o] = d, 1);
    }
  };
}
const Xd = /* @__PURE__ */ ke.define({ static: !0 });
class On {
  constructor(e, t, r, i, s) {
    this.id = e, this.createF = t, this.updateF = r, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new On(_3++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(Xd).find((r) => r.field == this);
    return (t?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (r) => (r.values[t] = this.create(r), 1),
      update: (r, i) => {
        let s = r.values[t], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (r.values[t] = o, 1);
      },
      reconfigure: (r, i) => {
        let s = r.facet(Xd), o = i.facet(Xd), l;
        return (l = s.find((a) => a.field == this)) && l != o.find((a) => a.field == this) ? (r.values[t] = l.create(r), 1) : i.config.address[this.id] != null ? (r.values[t] = i.field(this), 0) : (r.values[t] = this.create(r), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Xd.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Jl = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function _u(n) {
  return (e) => new aT(e, n);
}
const Tl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ _u(Jl.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ _u(Jl.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ _u(Jl.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ _u(Jl.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ _u(Jl.lowest)
};
class aT {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class Lc {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new dy(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Lc.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class dy {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class um {
  constructor(e, t, r, i, s, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = r, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, r) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of oW(e, t, o))
      f instanceof On ? i.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let l = /* @__PURE__ */ Object.create(null), a = [], c = [];
    for (let f of i)
      l[f.id] = c.length << 1, c.push((d) => f.slot(d));
    let u = r?.config.facets;
    for (let f in s) {
      let d = s[f], p = d[0].facet, m = u && u[f] || [];
      if (d.every(
        (g) => g.type == 0
        /* Provider.Static */
      ))
        if (l[p.id] = a.length << 1 | 1, L3(m, d))
          a.push(r.facet(p));
        else {
          let g = p.combine(d.map((b) => b.value));
          a.push(r && p.compare(g, r.facet(p)) ? r.facet(p) : g);
        }
      else {
        for (let g of d)
          g.type == 0 ? (l[g.id] = a.length << 1 | 1, a.push(g.value)) : (l[g.id] = c.length << 1, c.push((b) => g.dynamicSlot(b)));
        l[p.id] = c.length << 1, c.push((g) => sW(g, p, d));
      }
    }
    let h = c.map((f) => f(l));
    return new um(e, o, h, l, a, s);
  }
}
function oW(n, e, t) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, l) {
    let a = i.get(o);
    if (a != null) {
      if (a <= l)
        return;
      let c = r[a].indexOf(o);
      c > -1 && r[a].splice(c, 1), o instanceof dy && t.delete(o.compartment);
    }
    if (i.set(o, l), Array.isArray(o))
      for (let c of o)
        s(c, l);
    else if (o instanceof dy) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      t.set(o.compartment, c), s(c, l);
    } else if (o instanceof aT)
      s(o.inner, o.prec);
    else if (o instanceof On)
      r[l].push(o), o.provides && s(o.provides, l);
    else if (o instanceof hp)
      r[l].push(o), o.facet.extensions && s(o.facet.extensions, Jl.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, l);
    }
  }
  return s(n, Jl.default), r.reduce((o, l) => o.concat(l));
}
function Zh(n, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, r = n.status[t];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  n.status[t] = 4;
  let i = n.computeSlot(n, n.config.dynamicSlots[t]);
  return n.status[t] = 2 | i;
}
function hm(n, e) {
  return e & 1 ? n.config.staticValues[e >> 1] : n.values[e >> 1];
}
const cT = /* @__PURE__ */ ke.define(), py = /* @__PURE__ */ ke.define({
  combine: (n) => n.some((e) => e),
  static: !0
}), uT = /* @__PURE__ */ ke.define({
  combine: (n) => n.length ? n[0] : void 0,
  static: !0
}), hT = /* @__PURE__ */ ke.define(), fT = /* @__PURE__ */ ke.define(), dT = /* @__PURE__ */ ke.define(), pT = /* @__PURE__ */ ke.define({
  combine: (n) => n.length ? n[0] : !1
});
class wo {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new lW();
  }
}
class lW {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new wo(this, e);
  }
}
class aW {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new Xe(this, e);
  }
}
class Xe {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new Xe(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new aW(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let r = [];
    for (let i of e) {
      let s = i.map(t);
      s && r.push(s);
    }
    return r;
  }
}
Xe.reconfigure = /* @__PURE__ */ Xe.define();
Xe.appendConfig = /* @__PURE__ */ Xe.define();
class mn {
  constructor(e, t, r, i, s, o) {
    this.startState = e, this.changes = t, this.selection = r, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, r && lT(r, t.newLength), s.some((l) => l.type == mn.time) || (this.annotations = s.concat(mn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, r, i, s, o) {
    return new mn(e, t, r, i, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(mn.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
mn.time = /* @__PURE__ */ wo.define();
mn.userEvent = /* @__PURE__ */ wo.define();
mn.addToHistory = /* @__PURE__ */ wo.define();
mn.remote = /* @__PURE__ */ wo.define();
function cW(n, e) {
  let t = [];
  for (let r = 0, i = 0; ; ) {
    let s, o;
    if (r < n.length && (i == e.length || e[i] >= n[r]))
      s = n[r++], o = n[r++];
    else if (i < e.length)
      s = e[i++], o = e[i++];
    else
      return t;
    !t.length || t[t.length - 1] < s ? t.push(s, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function mT(n, e, t) {
  var r;
  let i, s, o;
  return t ? (i = e.changes, s = wn.empty(e.changes.length), o = n.changes.compose(e.changes)) : (i = e.changes.map(n.changes), s = n.changes.mapDesc(e.changes, !0), o = n.changes.compose(i)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (r = n.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: Xe.mapEffects(n.effects, i).concat(Xe.mapEffects(e.effects, s)),
    annotations: n.annotations.length ? n.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: n.scrollIntoView || e.scrollIntoView
  };
}
function my(n, e, t) {
  let r = e.selection, i = bc(e.annotations);
  return e.userEvent && (i = i.concat(mn.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof wn ? e.changes : wn.of(e.changes || [], t, n.facet(uT)),
    selection: r && (r instanceof G ? r : G.single(r.anchor, r.head)),
    effects: bc(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function gT(n, e, t) {
  let r = my(n, e.length ? e[0] : {}, n.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1);
    let o = !!e[s].sequential;
    r = mT(r, my(n, e[s], o ? r.changes.newLength : n.doc.length), o);
  }
  let i = mn.create(n, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return hW(t ? uW(i) : i);
}
function uW(n) {
  let e = n.startState, t = !0;
  for (let i of e.facet(hT)) {
    let s = i(n);
    if (s === !1) {
      t = !1;
      break;
    }
    Array.isArray(s) && (t = t === !0 ? s : cW(t, s));
  }
  if (t !== !0) {
    let i, s;
    if (t === !1)
      s = n.changes.invertedDesc, i = wn.empty(e.doc.length);
    else {
      let o = n.changes.filter(t);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    n = mn.create(e, i, n.selection && n.selection.map(s), Xe.mapEffects(n.effects, s), n.annotations, n.scrollIntoView);
  }
  let r = e.facet(fT);
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](n);
    s instanceof mn ? n = s : Array.isArray(s) && s.length == 1 && s[0] instanceof mn ? n = s[0] : n = gT(e, bc(s), !1);
  }
  return n;
}
function hW(n) {
  let e = n.startState, t = e.facet(dT), r = n;
  for (let i = t.length - 1; i >= 0; i--) {
    let s = t[i](n);
    s && Object.keys(s).length && (r = mT(r, my(e, s, n.changes.newLength), !0));
  }
  return r == n ? n : mn.create(e, n.changes, n.selection, r.effects, r.annotations, r.scrollIntoView);
}
const fW = [];
function bc(n) {
  return n == null ? fW : Array.isArray(n) ? n : [n];
}
var jt = /* @__PURE__ */ (function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
})(jt || (jt = {}));
const dW = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let gy;
try {
  gy = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function pW(n) {
  if (gy)
    return gy.test(n);
  for (let e = 0; e < n.length; e++) {
    let t = n[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || dW.test(t)))
      return !0;
  }
  return !1;
}
function mW(n) {
  return (e) => {
    if (!/\S/.test(e))
      return jt.Space;
    if (pW(e))
      return jt.Word;
    for (let t = 0; t < n.length; t++)
      if (e.indexOf(n[t]) > -1)
        return jt.Word;
    return jt.Other;
  };
}
class ct {
  constructor(e, t, r, i, s, o) {
    this.config = e, this.doc = t, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      Zh(this, l << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Zh(this, r), hm(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return gT(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: r, compartments: i } = t;
    for (let l of e.effects)
      l.is(Lc.reconfigure) ? (t && (i = /* @__PURE__ */ new Map(), t.compartments.forEach((a, c) => i.set(c, a)), t = null), i.set(l.value.compartment, l.value.extension)) : l.is(Xe.reconfigure) ? (t = null, r = l.value) : l.is(Xe.appendConfig) && (t = null, r = bc(r).concat(l.value));
    let s;
    t ? s = e.startState.values.slice() : (t = um.resolve(r, i, this), s = new ct(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (a, c) => c.reconfigure(a, this), null).values);
    let o = e.startState.facet(py) ? e.newSelection : e.newSelection.asSingle();
    new ct(t, e.newDoc, o, s, (l, a) => a.update(l, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: G.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, r = e(t.ranges[0]), i = this.changes(r.changes), s = [r.range], o = bc(r.effects);
    for (let l = 1; l < t.ranges.length; l++) {
      let a = e(t.ranges[l]), c = this.changes(a.changes), u = c.map(i);
      for (let f = 0; f < l; f++)
        s[f] = s[f].map(u);
      let h = i.mapDesc(c, !0);
      s.push(a.range.map(h)), i = i.compose(u), o = Xe.mapEffects(o, u).concat(Xe.mapEffects(bc(a.effects), h));
    }
    return {
      changes: i,
      selection: G.create(s, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof wn ? e : wn.of(e, this.doc.length, this.facet(ct.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return dt.of(e.split(this.facet(ct.lineSeparator) || cy));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (Zh(this, t), hm(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof On && this.config.address[i.id] != null && (t[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = r[s], l = e[s];
          i.push(o.init((a) => o.spec.fromJSON(l, a)));
        }
    }
    return ct.create({
      doc: e.doc,
      selection: G.fromJSON(e.selection),
      extensions: t.extensions ? i.concat([t.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = um.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof dt ? e.doc : dt.of((e.doc || "").split(t.staticFacet(ct.lineSeparator) || cy)), i = e.selection ? e.selection instanceof G ? e.selection : G.single(e.selection.anchor, e.selection.head) : G.single(0);
    return lT(i, r.length), t.staticFacet(py) || (i = i.asSingle()), new ct(t, r, i, t.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(ct.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(ct.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(pT);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let r of this.facet(ct.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > t.length ? r : t[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, r = -1) {
    let i = [];
    for (let s of this.facet(cT))
      for (let o of s(this, t, r))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return mW(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: r, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - r, l = e - r;
    for (; o > 0; ) {
      let a = zn(t, o, !1);
      if (s(t.slice(a, o)) != jt.Word)
        break;
      o = a;
    }
    for (; l < i; ) {
      let a = zn(t, l);
      if (s(t.slice(l, a)) != jt.Word)
        break;
      l = a;
    }
    return o == l ? null : G.range(o + r, l + r);
  }
}
ct.allowMultipleSelections = py;
ct.tabSize = /* @__PURE__ */ ke.define({
  combine: (n) => n.length ? n[0] : 4
});
ct.lineSeparator = uT;
ct.readOnly = pT;
ct.phrases = /* @__PURE__ */ ke.define({
  compare(n, e) {
    let t = Object.keys(n), r = Object.keys(e);
    return t.length == r.length && t.every((i) => n[i] == e[i]);
  }
});
ct.languageData = cT;
ct.changeFilter = hT;
ct.transactionFilter = fT;
ct.transactionExtender = dT;
Lc.reconfigure = /* @__PURE__ */ Xe.define();
function Ms(n, e, t = {}) {
  let r = {};
  for (let i of n)
    for (let s of Object.keys(i)) {
      let o = i[s], l = r[s];
      if (l === void 0)
        r[s] = o;
      else if (!(l === o || o === void 0)) if (Object.hasOwnProperty.call(t, s))
        r[s] = t[s](l, o);
      else
        throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class Sa {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return Pf.create(e, t, this);
  }
}
Sa.prototype.startSide = Sa.prototype.endSide = 0;
Sa.prototype.point = !1;
Sa.prototype.mapMode = Bn.TrackDel;
class Pf {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.value = r;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Pf(e, t, r);
  }
}
function yy(n, e) {
  return n.from - e.from || n.value.startSide - e.value.startSide;
}
class B3 {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, r, i = 0) {
    let s = r ? this.to : this.from;
    for (let o = i, l = s.length; ; ) {
      if (o == l)
        return o;
      let a = o + l >> 1, c = s[a] - e || (r ? this.value[a].endSide : this.value[a].startSide) - t;
      if (a == o)
        return c >= 0 ? o : l;
      c >= 0 ? l = a : o = a + 1;
    }
  }
  between(e, t, r, i) {
    for (let s = this.findIndex(t, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, t) {
    let r = [], i = [], s = [], o = -1, l = -1;
    for (let a = 0; a < this.value.length; a++) {
      let c = this.value[a], u = this.from[a] + e, h = this.to[a] + e, f, d;
      if (u == h) {
        let p = t.mapPos(u, c.startSide, c.mapMode);
        if (p == null || (f = d = p, c.startSide != c.endSide && (d = t.mapPos(u, c.endSide), d < f)))
          continue;
      } else if (f = t.mapPos(u, c.startSide), d = t.mapPos(h, c.endSide), f > d || f == d && c.startSide > 0 && c.endSide <= 0)
        continue;
      (d - f || c.endSide - c.startSide) < 0 || (o < 0 && (o = f), c.point && (l = Math.max(l, d - f)), r.push(c), i.push(f - o), s.push(d - o));
    }
    return { mapped: r.length ? new B3(i, s, r, l) : null, pos: o };
  }
}
class ht {
  constructor(e, t, r, i) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = r, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, t, r, i) {
    return new ht(e, t, r, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: r = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (r && (t = t.slice().sort(yy)), this.isEmpty)
      return t.length ? ht.of(t) : this;
    let l = new yT(this, null, -1).goto(0), a = 0, c = [], u = new ao();
    for (; l.value || a < t.length; )
      if (a < t.length && (l.from - t[a].from || l.startSide - t[a].value.startSide) >= 0) {
        let h = t[a++];
        u.addInner(h.from, h.to, h.value) || c.push(h);
      } else l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (a == t.length || this.chunkEnd(l.chunkIndex) < t[a].from) && (!o || i > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) && u.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || i > l.to || s < l.from || o(l.from, l.to, l.value)) && (u.addInner(l.from, l.to, l.value) || c.push(Pf.create(l.from, l.to, l.value))), l.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? ht.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: i, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], r = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], a = this.chunk[o], c = e.touchesRange(l, l + a.length);
      if (c === !1)
        i = Math.max(i, a.maxPoint), t.push(a), r.push(e.mapPos(l));
      else if (c === !0) {
        let { mapped: u, pos: h } = a.map(l, e);
        u && (i = Math.max(i, u.maxPoint), t.push(u), r.push(h));
      }
    }
    let s = this.nextLayer.map(e);
    return t.length == 0 ? s : new ht(r, t, s || ht.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (t >= s && e <= s + o.length && o.between(s, e - s, t - s, r) === !1)
          return;
      }
      this.nextLayer.between(e, t, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return _f.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return _f.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, r, i, s = -1) {
    let o = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), l = t.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), a = Uw(o, l, r), c = new Lu(o, a, s), u = new Lu(l, a, s);
    r.iterGaps((h, f, d) => Kw(c, h, u, f, d, i)), r.empty && r.length == 0 && Kw(c, 0, u, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, r = 0, i) {
    i == null && (i = 999999999);
    let s = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0), o = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let l = Uw(s, o), a = new Lu(s, l, 0).goto(r), c = new Lu(o, l, 0).goto(r);
    for (; ; ) {
      if (a.to != c.to || !by(a.active, c.active) || a.point && (!c.point || !a.point.eq(c.point)))
        return !1;
      if (a.to > i)
        return !0;
      a.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, r, i, s = -1) {
    let o = new Lu(e, null, s).goto(t), l = t, a = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, r);
      if (o.point) {
        let u = o.activeForPoint(o.to), h = o.pointFrom < t ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, a);
        i.point(l, c, o.point, u, h, o.pointRank), a = Math.min(o.openEnd(c), u.length);
      } else c > l && (i.span(l, c, o.active, a), a = o.openEnd(c));
      if (o.to > r)
        return a + (o.point && o.to > r ? 1 : 0);
      l = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let r = new ao();
    for (let i of e instanceof Pf ? [e] : t ? gW(e) : e)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return ht.empty;
    let t = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != ht.empty; i = i.nextLayer)
        t = new ht(i.chunkPos, i.chunk, t, Math.max(i.maxPoint, t.maxPoint));
    return t;
  }
}
ht.empty = /* @__PURE__ */ new ht([], [], null, -1);
function gW(n) {
  if (n.length > 1)
    for (let e = n[0], t = 1; t < n.length; t++) {
      let r = n[t];
      if (yy(e, r) > 0)
        return n.slice().sort(yy);
      e = r;
    }
  return n;
}
ht.empty.nextLayer = ht.empty;
class ao {
  finishChunk(e) {
    this.chunks.push(new B3(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, r) {
    this.addInner(e, t, r) || (this.nextLayer || (this.nextLayer = new ao())).add(e, t, r);
  }
  /**
  @internal
  */
  addInner(e, t, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = t, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let r = t.value.length - 1;
    return this.last = t.value[r], this.lastFrom = t.from[r] + e, this.lastTo = t.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(ht.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = ht.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function Uw(n, e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let s of n)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let l = r.get(s.chunk[o]);
      l != null && (t ? t.mapPos(l) : l) == s.chunkPos[o] && !t?.touchesRange(l, l + s.chunk[o].length) && i.add(s.chunk[o]);
    }
  return i;
}
class yT {
  constructor(e, t, r, i = 0) {
    this.layer = e, this.skip = t, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], r = e + t.from[this.rangeIndex];
        if (this.from = r, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class _f {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, r = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && i.push(new yT(o, t, r, s));
    return i.length == 1 ? i[0] : new _f(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let r of this.heap)
      r.goto(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      c2(this.heap, r);
    return this.next(), this;
  }
  forward(e, t) {
    for (let r of this.heap)
      r.forward(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      c2(this.heap, r);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), c2(this.heap, 0);
    }
  }
}
function c2(n, e) {
  for (let t = n[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= n.length)
      break;
    let i = n[r];
    if (r + 1 < n.length && i.compare(n[r + 1]) >= 0 && (i = n[r + 1], r++), t.compare(i) < 0)
      break;
    n[r] = t, n[e] = i, e = r;
  }
}
class Lu {
  constructor(e, t, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = _f.from(e, t, r);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Zd(this.active, e), Zd(this.activeTo, e), Zd(this.activeRank, e), this.minActive = Gw(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: r, to: i, rank: s } = this.cursor;
    for (; t < this.activeRank.length && (s - this.activeRank[t] || i - this.activeTo[t]) > 0; )
      t++;
    Qd(this.active, t, r), Qd(this.activeTo, t, i), Qd(this.activeRank, t, s), e && Qd(e, t, this.cursor.from), this.minActive = Gw(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && Zd(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(r), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && t.push(this.active[r]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      t++;
    return t;
  }
}
function Kw(n, e, t, r, i, s) {
  n.goto(e), t.goto(r);
  let o = r + i, l = r, a = r - e;
  for (; ; ) {
    let c = n.to + a - t.to, u = c || n.endSide - t.endSide, h = u < 0 ? n.to + a : t.to, f = Math.min(h, o);
    if (n.point || t.point ? n.point && t.point && (n.point == t.point || n.point.eq(t.point)) && by(n.activeForPoint(n.to), t.activeForPoint(t.to)) || s.comparePoint(l, f, n.point, t.point) : f > l && !by(n.active, t.active) && s.compareRange(l, f, n.active, t.active), h > o)
      break;
    (c || n.openEnd != t.openEnd) && s.boundChange && s.boundChange(h), l = h, u <= 0 && n.next(), u >= 0 && t.next();
  }
}
function by(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] != e[t] && !n[t].eq(e[t]))
      return !1;
  return !0;
}
function Zd(n, e) {
  for (let t = e, r = n.length - 1; t < r; t++)
    n[t] = n[t + 1];
  n.pop();
}
function Qd(n, e, t) {
  for (let r = n.length - 1; r >= e; r--)
    n[r + 1] = n[r];
  n[e] = t;
}
function Gw(n, e) {
  let t = -1, r = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - r || n[i].endSide - n[t].endSide) < 0 && (t = i, r = e[i]);
  return t;
}
function tu(n, e, t = n.length) {
  let r = 0;
  for (let i = 0; i < t && i < n.length; )
    n.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = zn(n, i));
  return r;
}
function vy(n, e, t, r) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == n.length)
      break;
    s += n.charCodeAt(i) == 9 ? t - s % t : 1, i = zn(n, i);
  }
  return r === !0 ? -1 : n.length;
}
const wy = "ͼ", Yw = typeof Symbol > "u" ? "__" + wy : Symbol.for(wy), xy = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), Jw = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class hl {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: r } = t || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, l, a, c) {
      let u = [], h = /^@(\w+)\b/.exec(o[0]), f = h && h[1] == "keyframes";
      if (h && l == null) return a.push(o[0] + ";");
      for (let d in l) {
        let p = l[d];
        if (/&/.test(d))
          s(
            d.split(/,\s*/).map((m) => o.map((g) => m.replace(/&/, g))).reduce((m, g) => m.concat(g)),
            p,
            a
          );
        else if (p && typeof p == "object") {
          if (!h) throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          s(i(d), p, u, f);
        } else p != null && u.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + p + ";");
      }
      (u.length || f) && a.push((r && !h && !c ? o.map(r) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e) s(i(o), e[o], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = Jw[Yw] || 1;
    return Jw[Yw] = e + 1, wy + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, r) {
    let i = e[xy], s = r && r.nonce;
    i ? s && i.setNonce(s) : i = new yW(e, s), i.mount(Array.isArray(t) ? t : [t], e);
  }
}
let Xw = /* @__PURE__ */ new Map();
class yW {
  constructor(e, t) {
    let r = e.ownerDocument || e, i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = Xw.get(r);
      if (s) return e[xy] = s;
      this.sheet = new i.CSSStyleSheet(), Xw.set(r, this);
    } else
      this.styleTag = r.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[xy] = this;
  }
  mount(e, t) {
    let r = this.sheet, i = 0, s = 0;
    for (let o = 0; o < e.length; o++) {
      let l = e[o], a = this.modules.indexOf(l);
      if (a < s && a > -1 && (this.modules.splice(a, 1), s--, a = -1), a == -1) {
        if (this.modules.splice(s++, 0, l), r) for (let c = 0; c < l.rules.length; c++)
          r.insertRule(l.rules[c], i++);
      } else {
        for (; s < a; ) i += this.modules[s++].rules.length;
        i += l.rules.length, s++;
      }
    }
    if (r)
      t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
    else {
      let o = "";
      for (let a = 0; a < this.modules.length; a++)
        o += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = o;
      let l = t.head || t;
      this.styleTag.parentNode != l && l.insertBefore(this.styleTag, l.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
function Ot() {
  var n = arguments[0];
  typeof n == "string" && (n = document.createElement(n));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) {
      var i = t[r];
      typeof i == "string" ? n.setAttribute(r, i) : i != null && (n[r] = i);
    }
    e++;
  }
  for (; e < arguments.length; e++) bT(n, arguments[e]);
  return n;
}
function bT(n, e) {
  if (typeof e == "string")
    n.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    n.appendChild(e);
  else if (Array.isArray(e))
    for (var t = 0; t < e.length; t++) bT(n, e[t]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
function Lf(n) {
  let e;
  return n.nodeType == 11 ? e = n.getSelection ? n : n.ownerDocument : e = n, e.getSelection();
}
function ky(n, e) {
  return e ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function fp(n, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return ky(n, e.anchorNode);
  } catch {
    return !1;
  }
}
function Bf(n) {
  return n.nodeType == 3 ? Ma(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function Qh(n, e, t, r) {
  return t ? Zw(n, e, t, r, -1) || Zw(n, e, t, r, 1) : !1;
}
function Ca(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}
function fm(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
function Zw(n, e, t, r, i) {
  for (; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : xs(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let s = n.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = Ca(n) + (i < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (i < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      e = i < 0 ? xs(n) : 0;
    } else
      return !1;
  }
}
function xs(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function b1(n, e) {
  let t = e ? n.left : n.right;
  return { left: t, right: t, top: n.top, bottom: n.bottom };
}
function bW(n) {
  let e = n.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function vT(n, e) {
  let t = e.width / n.offsetWidth, r = e.height / n.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - n.offsetWidth) < 1) && (t = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - n.offsetHeight) < 1) && (r = 1), { scaleX: t, scaleY: r };
}
function vW(n, e, t, r, i, s, o, l) {
  let a = n.ownerDocument, c = a.defaultView || window;
  for (let u = n, h = !1; u && !h; )
    if (u.nodeType == 1) {
      let f, d = u == a.body, p = 1, m = 1;
      if (d)
        f = bW(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let w = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: m } = vT(u, w)), f = {
          left: w.left,
          right: w.left + u.clientWidth * p,
          top: w.top,
          bottom: w.top + u.clientHeight * m
        };
      }
      let g = 0, b = 0;
      if (i == "nearest")
        e.top < f.top ? (b = e.top - (f.top + o), t > 0 && e.bottom > f.bottom + b && (b = e.bottom - f.bottom + o)) : e.bottom > f.bottom && (b = e.bottom - f.bottom + o, t < 0 && e.top - b < f.top && (b = e.top - (f.top + o)));
      else {
        let w = e.bottom - e.top, k = f.bottom - f.top;
        b = (i == "center" && w <= k ? e.top + w / 2 - k / 2 : i == "start" || i == "center" && t < 0 ? e.top - o : e.bottom - k + o) - f.top;
      }
      if (r == "nearest" ? e.left < f.left ? (g = e.left - (f.left + s), t > 0 && e.right > f.right + g && (g = e.right - f.right + s)) : e.right > f.right && (g = e.right - f.right + s, t < 0 && e.left < f.left + g && (g = e.left - (f.left + s))) : g = (r == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : r == "start" == l ? e.left - s : e.right - (f.right - f.left) + s) - f.left, g || b)
        if (d)
          c.scrollBy(g, b);
        else {
          let w = 0, k = 0;
          if (b) {
            let C = u.scrollTop;
            u.scrollTop += b / m, k = (u.scrollTop - C) * m;
          }
          if (g) {
            let C = u.scrollLeft;
            u.scrollLeft += g / p, w = (u.scrollLeft - C) * p;
          }
          e = {
            left: e.left - w,
            top: e.top - k,
            right: e.right - w,
            bottom: e.bottom - k
          }, w && Math.abs(w - g) < 1 && (r = "nearest"), k && Math.abs(k - b) < 1 && (i = "nearest");
        }
      if (d)
        break;
      (e.top < f.top || e.bottom > f.bottom || e.left < f.left || e.right > f.right) && (e = {
        left: Math.max(e.left, f.left),
        right: Math.min(e.right, f.right),
        top: Math.max(e.top, f.top),
        bottom: Math.min(e.bottom, f.bottom)
      }), u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function wW(n) {
  let e = n.ownerDocument, t, r;
  for (let i = n.parentNode; i && !(i == e.body || t && r); )
    if (i.nodeType == 1)
      !r && i.scrollHeight > i.clientHeight && (r = i), !t && i.scrollWidth > i.clientWidth && (t = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: t, y: r };
}
class xW {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: r } = e;
    this.set(t, Math.min(e.anchorOffset, t ? xs(t) : 0), r, Math.min(e.focusOffset, r ? xs(r) : 0));
  }
  set(e, t, r, i) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = r, this.focusOffset = i;
  }
}
let Ya = null;
function wT(n) {
  if (n.setActive)
    return n.setActive();
  if (Ya)
    return n.focus(Ya);
  let e = [];
  for (let t = n; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (n.focus(Ya == null ? {
    get preventScroll() {
      return Ya = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ya) {
    Ya = !1;
    for (let t = 0; t < e.length; ) {
      let r = e[t++], i = e[t++], s = e[t++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
}
let Qw;
function Ma(n, e, t = e) {
  let r = Qw || (Qw = document.createRange());
  return r.setEnd(n, t), r.setStart(n, e), r;
}
function vc(n, e, t, r) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let s = new KeyboardEvent("keydown", i);
  s.synthetic = !0, n.dispatchEvent(s);
  let o = new KeyboardEvent("keyup", i);
  return o.synthetic = !0, n.dispatchEvent(o), s.defaultPrevented || o.defaultPrevented;
}
function kW(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function xT(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function SW(n, e) {
  let t = e.focusNode, r = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, xs(t)); ; )
    if (r) {
      if (t.nodeType != 1)
        return !1;
      let i = t.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (t = i, r = xs(t));
    } else {
      if (t == n)
        return !0;
      r = Ca(t), t = t.parentNode;
    }
}
function kT(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
function ST(n, e) {
  for (let t = n, r = e; ; ) {
    if (t.nodeType == 3 && r > 0)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r - 1], r = xs(t);
    } else if (t.parentNode && !fm(t))
      r = Ca(t), t = t.parentNode;
    else
      return null;
  }
}
function CT(n, e) {
  for (let t = n, r = e; ; ) {
    if (t.nodeType == 3 && r < t.nodeValue.length)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r], r = 0;
    } else if (t.parentNode && !fm(t))
      r = Ca(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
class Un {
  constructor(e, t, r = !0) {
    this.node = e, this.offset = t, this.precise = r;
  }
  static before(e, t) {
    return new Un(e.parentNode, Ca(e), t);
  }
  static after(e, t) {
    return new Un(e.parentNode, Ca(e) + 1, t);
  }
}
const z3 = [];
class Dt {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return t;
      t += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let r = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
            let l = Dt.get(s);
            (!l || !l.parent && l.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : r.firstChild, t && !t.written && t.node == r && s != o.dom && (t.written = !0), o.dom.parentNode == r)
          for (; s && s != o.dom; )
            s = ex(s);
        else
          r.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : r.firstChild, s && t && t.node == r && (t.written = !0); s; )
        s = ex(s);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, t), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[t];
    else {
      let i = xs(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !Dt.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == r)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, r = 0) {
    let i = -1, s = -1, o = -1, l = -1;
    for (let a = 0, c = r, u = r; a < this.children.length; a++) {
      let h = this.children[a], f = c + h.length;
      if (c < e && f > t)
        return h.domBoundsAround(e, t, c);
      if (f >= e && i == -1 && (i = a, s = c), c > t && h.dom.parentNode == this.dom) {
        o = a, l = u;
        break;
      }
      u = f, c = f + h.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? r + this.length : l,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, r = z3) {
    this.markDirty();
    for (let i = e; i < t; i++) {
      let s = this.children[i];
      s.parent == this && r.indexOf(s) < 0 && s.destroy();
    }
    r.length < 250 ? this.children.splice(e, t - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(t));
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new MT(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, r, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
Dt.prototype.breakAfter = 0;
function ex(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class MT {
  constructor(e, t, r) {
    this.children = e, this.pos = t, this.i = r, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function TT(n, e, t, r, i, s, o, l, a) {
  let { children: c } = n, u = c.length ? c[e] : null, h = s.length ? s[s.length - 1] : null, f = h ? h.breakAfter : o;
  if (!(e == r && u && !o && !f && s.length < 2 && u.merge(t, i, s.length ? h : null, t == 0, l, a))) {
    if (r < c.length) {
      let d = c[r];
      d && (i < d.length || d.breakAfter && h?.breakAfter) ? (e == r && (d = d.split(i), i = 0), !f && h && d.merge(0, i, h, !0, 0, a) ? s[s.length - 1] = d : ((i || d.children.length && !d.children[0].length) && d.merge(0, i, null, !1, 0, a), s.push(d))) : d?.breakAfter && (h ? h.breakAfter = 1 : o = 1), r++;
    }
    for (u && (u.breakAfter = o, t > 0 && (!o && s.length && u.merge(t, u.length, s[0], !1, l, 0) ? u.breakAfter = s.shift().breakAfter : (t < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(t, u.length, null, !1, l, 0), e++)); e < r && s.length; )
      if (c[r - 1].become(s[s.length - 1]))
        r--, s.pop(), a = s.length ? 0 : l;
      else if (c[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : a;
      else
        break;
    !s.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, l, a) && e--, (e < r || s.length) && n.replaceChildren(e, r, s);
  }
}
function AT(n, e, t, r, i, s) {
  let o = n.childCursor(), { i: l, off: a } = o.findPos(t, 1), { i: c, off: u } = o.findPos(e, -1), h = e - t;
  for (let f of r)
    h += f.length;
  n.length += h, TT(n, c, u, l, a, r, 0, i, s);
}
let Cr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Sy = typeof document < "u" ? document : { documentElement: { style: {} } };
const Cy = /* @__PURE__ */ /Edge\/(\d+)/.exec(Cr.userAgent), OT = /* @__PURE__ */ /MSIE \d/.test(Cr.userAgent), My = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Cr.userAgent), v1 = !!(OT || My || Cy), tx = !v1 && /* @__PURE__ */ /gecko\/(\d+)/i.test(Cr.userAgent), u2 = !v1 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Cr.userAgent), CW = "webkitFontSmoothing" in Sy.documentElement.style, ET = !v1 && /* @__PURE__ */ /Apple Computer/.test(Cr.vendor), nx = ET && (/* @__PURE__ */ /Mobile\/\w+/.test(Cr.userAgent) || Cr.maxTouchPoints > 2);
var xe = {
  mac: nx || /* @__PURE__ */ /Mac/.test(Cr.platform),
  windows: /* @__PURE__ */ /Win/.test(Cr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Cr.platform),
  ie: v1,
  ie_version: OT ? Sy.documentMode || 6 : My ? +My[1] : Cy ? +Cy[1] : 0,
  gecko: tx,
  gecko_version: tx ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Cr.userAgent) || [0, 0])[1] : 0,
  chrome: !!u2,
  chrome_version: u2 ? +u2[1] : 0,
  ios: nx,
  android: /* @__PURE__ */ /Android\b/.test(Cr.userAgent),
  safari: ET,
  webkit_version: CW ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Cr.userAgent) || [0, 0])[1] : 0,
  tabSize: Sy.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const MW = 256;
class Bi extends Dt {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, r) {
    return this.flags & 8 || r && (!(r instanceof Bi) || this.length - (t - e) + r.length > MW || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new Bi(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Un(this.dom, e);
  }
  domBoundsAround(e, t, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return TW(this.dom, e, t);
  }
}
class co extends Dt {
  constructor(e, t = [], r = 0) {
    super(), this.mark = e, this.children = t, this.length = r;
    for (let i of t)
      i.setParent(this);
  }
  setAttrs(e) {
    if (xT(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof co && r.mark.eq(this.mark)) || e && s <= 0 || t < this.length && o <= 0) ? !1 : (AT(this, e, t, r ? r.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], r = 0, i = -1, s = 0;
    for (let l of this.children) {
      let a = r + l.length;
      a > e && t.push(r < e ? l.split(e - r) : l), i < 0 && r >= e && (i = s), r = a, s++;
    }
    let o = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new co(this.mark, t, o);
  }
  domAtPos(e) {
    return IT(this, e);
  }
  coordsAt(e, t) {
    return NT(this, e, t);
  }
}
function TW(n, e, t) {
  let r = n.nodeValue.length;
  e > r && (e = r);
  let i = e, s = e, o = 0;
  e == 0 && t < 0 || e == r && t >= 0 ? xe.chrome || xe.gecko || (e ? (i--, o = 1) : s < r && (s++, o = -1)) : t < 0 ? i-- : s < r && s++;
  let l = Ma(n, i, s).getClientRects();
  if (!l.length)
    return null;
  let a = l[(o ? o < 0 : t >= 0) ? 0 : l.length - 1];
  return xe.safari && !o && a.width == 0 && (a = Array.prototype.find.call(l, (c) => c.width) || a), o ? b1(a, o < 0) : a || null;
}
class Xo extends Dt {
  static create(e, t, r) {
    return new Xo(e, t, r);
  }
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let t = Xo.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof Xo) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof Xo && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return dt.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, r = t && t.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : dt.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Un.before(this.dom) : Un.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    if (r)
      return r;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let l = o ? i.length - 1 : 0; s = i[l], !(e > 0 ? l == 0 : l == i.length - 1 || s.top < s.bottom); l += o ? -1 : 1)
      ;
    return b1(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Bc extends Dt {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Bc && e.side == this.side;
  }
  split() {
    return new Bc(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Un.before(this.dom) : Un.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return dt.empty;
  }
  get isHidden() {
    return !0;
  }
}
Bi.prototype.children = Xo.prototype.children = Bc.prototype.children = z3;
function IT(n, e) {
  let t = n.dom, { children: r } = n, i = 0;
  for (let s = 0; i < r.length; i++) {
    let o = r[i], l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == t)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = r[s - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < r.length; s++) {
    let o = r[s];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new Un(t, 0);
}
function DT(n, e, t) {
  let r, { children: i } = n;
  t > 0 && e instanceof co && i.length && (r = i[i.length - 1]) instanceof co && r.mark.eq(e.mark) ? DT(r, e.children[0], t - 1) : (i.push(e), e.setParent(n)), n.length += e.length;
}
function NT(n, e, t) {
  let r = null, i = -1, s = null, o = -1;
  function l(c, u) {
    for (let h = 0, f = 0; h < c.children.length && f <= u; h++) {
      let d = c.children[h], p = f + d.length;
      p >= u && (d.children.length ? l(d, u - f) : (!s || s.isHidden && (t > 0 || OW(s, d))) && (p > u || f == p && d.getSide() > 0) ? (s = d, o = u - f) : (f < u || f == p && d.getSide() < 0 && !d.isHidden) && (r = d, i = u - f)), f = p;
    }
  }
  l(n, e);
  let a = (t < 0 ? r : s) || r || s;
  return a ? a.coordsAt(Math.max(0, a == r ? i : o), t) : AW(n);
}
function AW(n) {
  let e = n.dom.lastChild;
  if (!e)
    return n.dom.getBoundingClientRect();
  let t = Bf(e);
  return t[t.length - 1] || null;
}
function OW(n, e) {
  let t = n.coordsAt(0, 1), r = e.coordsAt(0, 1);
  return t && r && r.top < t.bottom;
}
function Ty(n, e) {
  for (let t in n)
    t == "class" && e.class ? e.class += " " + n.class : t == "style" && e.style ? e.style += ";" + n.style : e[t] = n[t];
  return e;
}
const rx = /* @__PURE__ */ Object.create(null);
function dm(n, e, t) {
  if (n == e)
    return !0;
  n || (n = rx), e || (e = rx);
  let r = Object.keys(n), i = Object.keys(e);
  if (r.length - (t && r.indexOf(t) > -1 ? 1 : 0) != i.length - (t && i.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let s of r)
    if (s != t && (i.indexOf(s) == -1 || n[s] !== e[s]))
      return !1;
  return !0;
}
function Ay(n, e, t) {
  let r = !1;
  if (e)
    for (let i in e)
      t && i in t || (r = !0, i == "style" ? n.style.cssText = "" : n.removeAttribute(i));
  if (t)
    for (let i in t)
      e && e[i] == t[i] || (r = !0, i == "style" ? n.style.cssText = t[i] : n.setAttribute(i, t[i]));
  return r;
}
function EW(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < n.attributes.length; t++) {
    let r = n.attributes[t];
    e[r.name] = r.value;
  }
  return e;
}
class xo {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var ur = /* @__PURE__ */ (function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
})(ur || (ur = {}));
class He extends Sa {
  constructor(e, t, r, i) {
    super(), this.startSide = e, this.endSide = t, this.widget = r, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new fd(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return t += r && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new fl(e, t, t, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, r, i;
    if (e.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = RT(e, t);
      r = (s ? t ? -3e8 : -1 : 5e8) - 1, i = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new fl(e, r, i, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new dd(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return ht.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
He.none = ht.empty;
class fd extends He {
  constructor(e) {
    let { start: t, end: r } = RT(e);
    super(t ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, r;
    return this == e || e instanceof fd && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && dm(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
fd.prototype.point = !1;
class dd extends He {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof dd && this.spec.class == e.spec.class && dm(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
dd.prototype.mapMode = Bn.TrackBefore;
dd.prototype.point = !0;
class fl extends He {
  constructor(e, t, r, i, s, o) {
    super(t, r, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? t <= 0 ? Bn.TrackBefore : Bn.TrackAfter : Bn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? ur.WidgetRange : this.startSide <= 0 ? ur.WidgetBefore : ur.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof fl && IW(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
fl.prototype.point = !0;
function RT(n, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: r } = n;
  return t == null && (t = n.inclusive), r == null && (r = n.inclusive), { start: t ?? e, end: r ?? e };
}
function IW(n, e) {
  return n == e || !!(n && e && n.compare(e));
}
function dp(n, e, t, r = 0) {
  let i = t.length - 1;
  i >= 0 && t[i] + r >= n ? t[i] = Math.max(t[i], e) : t.push(n, e);
}
class dn extends Dt {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, r, i, s, o) {
    if (r) {
      if (!(r instanceof dn))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), AT(this, e, t, r ? r.children.slice() : [], s, o), !0;
  }
  split(e) {
    let t = new dn();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: r, off: i } = this.childPos(e);
    i && (t.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let s = r; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    dm(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    DT(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, r = e.spec.class;
    t && (this.attrs = Ty(t, this.attrs || {})), r && (this.attrs = Ty({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return IT(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var r;
    this.dom ? this.flags & 4 && (xT(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Ay(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let i = this.dom.lastChild;
    for (; i && Dt.get(i) instanceof co; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = Dt.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!xe.ios || !this.children.some((s) => s instanceof Bi))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let r of this.children) {
      if (!(r instanceof Bi) || /[^ -~]/.test(r.text))
        return null;
      let i = Bf(r.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, t = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let r = NT(this, e, t);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = r.bottom - r.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return e instanceof dn && this.children.length == 0 && e.children.length == 0 && dm(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let s = e.children[r], o = i + s.length;
      if (o >= t) {
        if (s instanceof dn)
          return s;
        if (o > t)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class ro extends Dt {
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof ro) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Un.before(this.dom) : Un.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let r = new ro(this.widget, t, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return z3;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : dt.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof ro && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    return r || (this.widget instanceof Oy ? null : b1(this.dom.getBoundingClientRect(), this.length ? e == 0 : t <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: r } = this.deco;
    return t == r ? !1 : e < 0 ? t < 0 : r > 0;
  }
}
class Oy extends xo {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class ef {
  constructor(e, t, r, i) {
    this.doc = e, this.pos = t, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof ro && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new dn()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(e0(new Bc(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof ro) && this.getLine();
  }
  buildText(e, t, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - r)), this.getLine().append(e0(new Bi(this.text.slice(this.textOff, this.textOff + i)), t), r), this.atCursorPos = !0, this.textOff += i, e -= i, r = 0;
    }
  }
  span(e, t, r, i) {
    this.buildText(t - e, r, i), this.pos = t, this.openStart < 0 && (this.openStart = i);
  }
  point(e, t, r, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof fl) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = t - e;
    if (r instanceof fl)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new ro(r.widget || zc.block, l, r));
      else {
        let a = Xo.create(r.widget || zc.inline, l, l ? 0 : r.startSide), c = this.atCursorPos && !a.isEditable && s <= i.length && (e < t || r.startSide > 0), u = !a.isEditable && (e < t || s > i.length || r.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !c && !a.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (h.append(e0(new Bc(1), i), s), s = i.length + Math.max(0, s - i.length)), h.append(e0(a, i), s), this.atCursorPos = u, this.pendingBuffer = u ? e < t || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, r, i, s) {
    let o = new ef(e, t, r, s);
    return o.openEnd = ht.spans(i, t, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function e0(n, e) {
  for (let t of e)
    n = new co(t, [n], n.length);
  return n;
}
class zc extends xo {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
zc.inline = /* @__PURE__ */ new zc("span");
zc.block = /* @__PURE__ */ new zc("div");
var Wt = /* @__PURE__ */ (function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
})(Wt || (Wt = {}));
const Ta = Wt.LTR, F3 = Wt.RTL;
function PT(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    e.push(1 << +n[t]);
  return e;
}
const DW = /* @__PURE__ */ PT("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), NW = /* @__PURE__ */ PT("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Ey = /* @__PURE__ */ Object.create(null), Gi = [];
for (let n of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ n.charCodeAt(0), t = /* @__PURE__ */ n.charCodeAt(1);
  Ey[e] = t, Ey[t] = -e;
}
function _T(n) {
  return n <= 247 ? DW[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? NW[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
const RW = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Zo {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? F3 : Ta;
  }
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.level = r;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, r, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= t && l.to >= t) {
        if (l.level == r)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? l.from < t : l.to > t : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function LT(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++) {
    let r = n[t], i = e[t];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !LT(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const Et = [];
function PW(n, e, t, r, i) {
  for (let s = 0; s <= r.length; s++) {
    let o = s ? r[s - 1].to : e, l = s < r.length ? r[s].from : t, a = s ? 256 : i;
    for (let c = o, u = a, h = a; c < l; c++) {
      let f = _T(n.charCodeAt(c));
      f == 512 ? f = u : f == 8 && h == 4 && (f = 16), Et[c] = f == 4 ? 2 : f, f & 7 && (h = f), u = f;
    }
    for (let c = o, u = a, h = a; c < l; c++) {
      let f = Et[c];
      if (f == 128)
        c < l - 1 && u == Et[c + 1] && u & 24 ? f = Et[c] = u : Et[c] = 256;
      else if (f == 64) {
        let d = c + 1;
        for (; d < l && Et[d] == 64; )
          d++;
        let p = c && u == 8 || d < t && Et[d] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let m = c; m < d; m++)
          Et[m] = p;
        c = d - 1;
      } else f == 8 && h == 1 && (Et[c] = 1);
      u = f, f & 7 && (h = f);
    }
  }
}
function _W(n, e, t, r, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, l = 0, a = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e, u = o < r.length ? r[o].from : t;
    for (let h = c, f, d, p; h < u; h++)
      if (d = Ey[f = n.charCodeAt(h)])
        if (d < 0) {
          for (let m = l - 3; m >= 0; m -= 3)
            if (Gi[m + 1] == -d) {
              let g = Gi[m + 2], b = g & 2 ? i : g & 4 ? g & 1 ? s : i : 0;
              b && (Et[h] = Et[Gi[m]] = b), l = m;
              break;
            }
        } else {
          if (Gi.length == 189)
            break;
          Gi[l++] = h, Gi[l++] = f, Gi[l++] = a;
        }
      else if ((p = Et[h]) == 2 || p == 1) {
        let m = p == i;
        a = m ? 0 : 1;
        for (let g = l - 3; g >= 0; g -= 3) {
          let b = Gi[g + 2];
          if (b & 2)
            break;
          if (m)
            Gi[g + 2] |= 2;
          else {
            if (b & 4)
              break;
            Gi[g + 2] |= 4;
          }
        }
      }
  }
}
function LW(n, e, t, r) {
  for (let i = 0, s = r; i <= t.length; i++) {
    let o = i ? t[i - 1].to : n, l = i < t.length ? t[i].from : e;
    for (let a = o; a < l; ) {
      let c = Et[a];
      if (c == 256) {
        let u = a + 1;
        for (; ; )
          if (u == l) {
            if (i == t.length)
              break;
            u = t[i++].to, l = i < t.length ? t[i].from : e;
          } else if (Et[u] == 256)
            u++;
          else
            break;
        let h = s == 1, f = (u < e ? Et[u] : r) == 1, d = h == f ? h ? 1 : 2 : r;
        for (let p = u, m = i, g = m ? t[m - 1].to : n; p > a; )
          p == g && (p = t[--m].from, g = m ? t[m - 1].to : n), Et[--p] = d;
        a = u;
      } else
        s = c, a++;
    }
  }
}
function Iy(n, e, t, r, i, s, o) {
  let l = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let a = e, c = 0; a < t; ) {
      let u = !0, h = !1;
      if (c == s.length || a < s[c].from) {
        let m = Et[a];
        m != l && (u = !1, h = m == 16);
      }
      let f = !u && l == 1 ? [] : null, d = u ? r : r + 1, p = a;
      e: for (; ; )
        if (c < s.length && p == s[c].from) {
          if (h)
            break e;
          let m = s[c];
          if (!u)
            for (let g = m.to, b = c + 1; ; ) {
              if (g == t)
                break e;
              if (b < s.length && s[b].from == g)
                g = s[b++].to;
              else {
                if (Et[g] == l)
                  break e;
                break;
              }
            }
          if (c++, f)
            f.push(m);
          else {
            m.from > a && o.push(new Zo(a, m.from, d));
            let g = m.direction == Ta != !(d % 2);
            Dy(n, g ? r + 1 : r, i, m.inner, m.from, m.to, o), a = m.to;
          }
          p = m.to;
        } else {
          if (p == t || (u ? Et[p] != l : Et[p] == l))
            break;
          p++;
        }
      f ? Iy(n, a, p, r + 1, i, f, o) : a < p && o.push(new Zo(a, p, d)), a = p;
    }
  else
    for (let a = t, c = s.length; a > e; ) {
      let u = !0, h = !1;
      if (!c || a > s[c - 1].to) {
        let m = Et[a - 1];
        m != l && (u = !1, h = m == 16);
      }
      let f = !u && l == 1 ? [] : null, d = u ? r : r + 1, p = a;
      e: for (; ; )
        if (c && p == s[c - 1].to) {
          if (h)
            break e;
          let m = s[--c];
          if (!u)
            for (let g = m.from, b = c; ; ) {
              if (g == e)
                break e;
              if (b && s[b - 1].to == g)
                g = s[--b].from;
              else {
                if (Et[g - 1] == l)
                  break e;
                break;
              }
            }
          if (f)
            f.push(m);
          else {
            m.to < a && o.push(new Zo(m.to, a, d));
            let g = m.direction == Ta != !(d % 2);
            Dy(n, g ? r + 1 : r, i, m.inner, m.from, m.to, o), a = m.from;
          }
          p = m.from;
        } else {
          if (p == e || (u ? Et[p - 1] != l : Et[p - 1] == l))
            break;
          p--;
        }
      f ? Iy(n, p, a, r + 1, i, f, o) : p < a && o.push(new Zo(p, a, d)), a = p;
    }
}
function Dy(n, e, t, r, i, s, o) {
  let l = e % 2 ? 2 : 1;
  PW(n, i, s, r, l), _W(n, i, s, r, l), LW(i, s, r, l), Iy(n, i, s, e, t, r, o);
}
function BW(n, e, t) {
  if (!n)
    return [new Zo(0, 0, e == F3 ? 1 : 0)];
  if (e == Ta && !t.length && !RW.test(n))
    return BT(n.length);
  if (t.length)
    for (; n.length > Et.length; )
      Et[Et.length] = 256;
  let r = [], i = e == Ta ? 0 : 1;
  return Dy(n, i, i, t, 0, n.length, r), r;
}
function BT(n) {
  return [new Zo(0, n, 0)];
}
let zT = "";
function zW(n, e, t, r, i) {
  var s;
  let o = r.head - n.from, l = Zo.find(e, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc), a = e[l], c = a.side(i, t);
  if (o == c) {
    let f = l += i ? 1 : -1;
    if (f < 0 || f >= e.length)
      return null;
    a = e[l = f], o = a.side(!i, t), c = a.side(i, t);
  }
  let u = zn(n.text, o, a.forward(i, t));
  (u < a.from || u > a.to) && (u = c), zT = n.text.slice(Math.min(o, u), Math.max(o, u));
  let h = l == (i ? e.length - 1 : 0) ? null : e[l + (i ? 1 : -1)];
  return h && u == c && h.level + (i ? 0 : 1) < a.level ? G.cursor(h.side(!i, t) + n.from, h.forward(i, t) ? 1 : -1, h.level) : G.cursor(u + n.from, a.forward(i, t) ? -1 : 1, a.level);
}
function FW(n, e, t) {
  for (let r = e; r < t; r++) {
    let i = _T(n.charCodeAt(r));
    if (i == 1)
      return Ta;
    if (i == 2 || i == 4)
      return F3;
  }
  return Ta;
}
const FT = /* @__PURE__ */ ke.define(), HT = /* @__PURE__ */ ke.define(), $T = /* @__PURE__ */ ke.define(), VT = /* @__PURE__ */ ke.define(), Ny = /* @__PURE__ */ ke.define(), qT = /* @__PURE__ */ ke.define(), WT = /* @__PURE__ */ ke.define(), H3 = /* @__PURE__ */ ke.define(), $3 = /* @__PURE__ */ ke.define(), jT = /* @__PURE__ */ ke.define({
  combine: (n) => n.some((e) => e)
}), UT = /* @__PURE__ */ ke.define({
  combine: (n) => n.some((e) => e)
}), KT = /* @__PURE__ */ ke.define();
class wc {
  constructor(e, t = "nearest", r = "nearest", i = 5, s = 5, o = !1) {
    this.range = e, this.y = t, this.x = r, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new wc(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new wc(G.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const t0 = /* @__PURE__ */ Xe.define({ map: (n, e) => n.map(e) }), GT = /* @__PURE__ */ Xe.define();
function Ar(n, e, t) {
  let r = n.facet(VT);
  r.length ? r[0](e) : window.onerror && window.onerror(String(e), t, void 0, void 0, e) || (t ? console.error(t + ":", e) : console.error(e));
}
const Ys = /* @__PURE__ */ ke.define({ combine: (n) => n.length ? n[0] : !0 });
let HW = 0;
const fc = /* @__PURE__ */ ke.define({
  combine(n) {
    return n.filter((e, t) => {
      for (let r = 0; r < t; r++)
        if (n[r].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class gn {
  constructor(e, t, r, i, s) {
    this.id = e, this.create = t, this.domEventHandlers = r, this.domEventObservers = i, this.baseExtensions = s(this), this.extension = this.baseExtensions.concat(fc.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(fc.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: r, eventObservers: i, provide: s, decorations: o } = t || {};
    return new gn(HW++, e, r, i, (l) => {
      let a = [];
      return o && a.push(zf.of((c) => {
        let u = c.plugin(l);
        return u ? o(u) : He.none;
      })), s && a.push(s(l)), a;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return gn.define((r, i) => new e(r, i), t);
  }
}
class h2 {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (r) {
            if (Ar(t.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (t) {
        Ar(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Ar(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const YT = /* @__PURE__ */ ke.define(), V3 = /* @__PURE__ */ ke.define(), zf = /* @__PURE__ */ ke.define(), JT = /* @__PURE__ */ ke.define(), w1 = /* @__PURE__ */ ke.define(), XT = /* @__PURE__ */ ke.define();
function ix(n, e) {
  let t = n.state.facet(XT);
  if (!t.length)
    return t;
  let r = t.map((s) => s instanceof Function ? s(n) : s), i = [];
  return ht.spans(r, e.from, e.to, {
    point() {
    },
    span(s, o, l, a) {
      let c = s - e.from, u = o - e.from, h = i;
      for (let f = l.length - 1; f >= 0; f--, a--) {
        let d = l[f].spec.bidiIsolate, p;
        if (d == null && (d = FW(e.text, c, u)), a > 0 && h.length && (p = h[h.length - 1]).to == c && p.direction == d)
          p.to = u, h = p.inner;
        else {
          let m = { from: c, to: u, direction: d, inner: [] };
          h.push(m), h = m.inner;
        }
      }
    }
  }), i;
}
const ZT = /* @__PURE__ */ ke.define();
function q3(n) {
  let e = 0, t = 0, r = 0, i = 0;
  for (let s of n.state.facet(ZT)) {
    let o = s(n);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: t, top: r, bottom: i };
}
const uh = /* @__PURE__ */ ke.define();
class yi {
  constructor(e, t, r, i) {
    this.fromA = e, this.toA = t, this.fromB = r, this.toB = i;
  }
  join(e) {
    return new yi(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, r = this;
    for (; t > 0; t--) {
      let i = e[t - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, r), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let r = [];
    for (let i = 0, s = 0, o = 0, l = 0; ; i++) {
      let a = i == e.length ? null : e[i], c = o - l, u = a ? a.fromB : 1e9;
      for (; s < t.length && t[s] < u; ) {
        let h = t[s], f = t[s + 1], d = Math.max(l, h), p = Math.min(u, f);
        if (d <= p && new yi(d + c, p + c, d, p).addToSet(r), f > u)
          break;
        s += 2;
      }
      if (!a)
        return r;
      new yi(a.fromA, a.toA, a.fromB, a.toB).addToSet(r), o = a.toA, l = a.toB;
    }
  }
}
class pm {
  constructor(e, t, r) {
    this.view = e, this.state = t, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = wn.empty(this.startState.doc.length);
    for (let s of r)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, l, a) => i.push(new yi(s, o, l, a))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new pm(e, t, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class sx extends Dt {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = He.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new dn()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new yi(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? i = this.domChanged.newSel.head : !KW(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? VW(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      r = new yi(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (xe.ie || xe.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, l = this.updateDeco(), a = jW(o, l, e.changes);
    return r = yi.extendWithRanges(r, a), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = xe.chrome || xe.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof ro && o.widget instanceof Oy && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, t, r) {
    let i = r ? r.range.addToSet(e.slice()) : e, s = this.childCursor(t);
    for (let o = i.length - 1; ; o--) {
      let l = o >= 0 ? i[o] : null;
      if (!l)
        break;
      let { fromA: a, toA: c, fromB: u, toB: h } = l, f, d, p, m;
      if (r && r.range.fromB < h && r.range.toB > u) {
        let C = ef.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), M = ef.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
        d = C.breakAtStart, p = C.openStart, m = M.openEnd;
        let T = this.compositionView(r);
        M.breakAtStart ? T.breakAfter = 1 : M.content.length && T.merge(T.length, T.length, M.content[0], !1, M.openStart, 0) && (T.breakAfter = M.content[0].breakAfter, M.content.shift()), C.content.length && T.merge(0, 0, C.content[C.content.length - 1], !0, 0, C.openEnd) && C.content.pop(), f = C.content.concat(T).concat(M.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: m } = ef.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
      let { i: g, off: b } = s.findPos(c, 1), { i: w, off: k } = s.findPos(a, -1);
      TT(this, w, k, g, b, f, d, p, m);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(GT) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let t = new Bi(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: i } of e.marks)
      t = new co(i, [t], t.length);
    let r = new dn();
    return r.append(t, 0), r;
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (a) => a.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let l = Dt.get(s);
      l && l != o && (l.dom = null), o.setDOM(s);
    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
    t(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      r = i.childPos(r.off, 1), i = i.children[r.i], t(s >= 0 ? e.marks[s].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, s = !i && !(this.view.state.facet(Ys) || this.dom.tabIndex > -1) && fp(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || t || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, a = this.moveToLine(this.domAtPos(l.anchor)), c = l.empty ? a : this.moveToLine(this.domAtPos(l.head));
    if (xe.gecko && l.empty && !this.hasComposition && $W(a)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => a.node.insertBefore(h, a.node.childNodes[a.offset] || null)), a = c = new Un(h, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || (!Qh(a.node, a.offset, u.anchorNode, u.anchorOffset) || !Qh(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, l)) && (this.view.observer.ignore(() => {
      xe.android && xe.chrome && this.dom.contains(u.focusNode) && UW(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Lf(this.view.root);
      if (h) if (l.empty) {
        if (xe.gecko) {
          let f = qW(a.node, a.offset);
          if (f && f != 3) {
            let d = (f == 1 ? ST : CT)(a.node, a.offset);
            d && (a = new Un(d.node, d.offset));
          }
        }
        h.collapse(a.node, a.offset), l.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = l.bidiLevel);
      } else if (h.extend) {
        h.collapse(a.node, a.offset);
        try {
          h.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let f = document.createRange();
        l.anchor > l.head && ([a, c] = [c, a]), f.setEnd(c.node, c.offset), f.setStart(a.node, a.offset), h.removeAllRanges(), h.addRange(f);
      }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(a, c)), this.impreciseAnchor = a.precise ? null : new Un(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new Un(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && Qh(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, r = Lf(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!r || !t.empty || !t.assoc || !r.modify)
      return;
    let o = dn.find(this, t.head);
    if (!o)
      return;
    let l = o.posAtStart;
    if (t.head == l || t.head == l + o.length)
      return;
    let a = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!a || !c || a.bottom > c.top)
      return;
    let u = this.domAtPos(t.head + t.assoc);
    r.collapse(u.node, u.offset), r.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != t.from && r.collapse(i, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, r;
    if (e.node != t)
      return e;
    for (let i = e.offset; !r && i < t.childNodes.length; i++) {
      let s = Dt.get(t.childNodes[i]);
      s instanceof dn && (r = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let s = Dt.get(t.childNodes[i]);
      s instanceof dn && (r = s.domAtPos(s.length));
    }
    return r ? new Un(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let r = Dt.get(t);
      if (r && r.rootView == this)
        return r;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, t) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: r } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let i = this.children[t];
      if (r < i.length || i instanceof dn)
        break;
      t++, r = 0;
    }
    return this.children[t].domAtPos(r);
  }
  coordsAt(e, t) {
    let r = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let l = this.children[o], a = s - l.breakAfter, c = a - l.length;
      if (a < e)
        break;
      if (c <= e && (c < e || l.covers(-1)) && (a > e || l.covers(1)) && (!r || l instanceof dn && !(r instanceof dn && t >= 0)))
        r = l, i = c;
      else if (r && c == e && a == e && l instanceof ro && Math.abs(t) < 2) {
        if (l.deco.startSide < 0)
          break;
        o && (r = null);
      }
      s = c;
    }
    return r ? r.coordsAt(e - i, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: r } = this.childPos(e, 1), i = this.children[t];
    if (!(i instanceof dn))
      return null;
    for (; i.children.length; ) {
      let { i: l, off: a } = i.childPos(r, 1);
      for (; ; l++) {
        if (l == i.children.length)
          return null;
        if ((i = i.children[l]).length)
          break;
      }
      r = a;
    }
    if (!(i instanceof Bi))
      return null;
    let s = zn(i.text, r);
    if (s == r)
      return null;
    let o = Ma(i.dom, r, s).getClientRects();
    for (let l = 0; l < o.length; l++) {
      let a = o[l];
      if (l == o.length - 1 || a.top < a.bottom && a.left < a.right)
        return a;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: r, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, a = this.view.textDirection == Wt.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let h = this.children[u], f = c + h.length;
      if (f > i)
        break;
      if (c >= r) {
        let d = h.dom.getBoundingClientRect();
        if (t.push(d.height), o) {
          let p = h.dom.lastChild, m = p ? Bf(p) : [];
          if (m.length) {
            let g = m[m.length - 1], b = a ? g.right - d.left : d.right - g.left;
            b > l && (l = b, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + h.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? Wt.RTL : Wt.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof dn) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, r, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Bf(e.firstChild)[0];
      t = e.getBoundingClientRect().height, r = s ? s.width / 27 : 7, i = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: r, textHeight: i };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new MT(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let s = i == t.viewports.length ? null : t.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > r) {
        let l = (t.lineBlockAt(o).bottom - t.lineBlockAt(r).top) / this.view.scaleY;
        e.push(He.replace({
          widget: new Oy(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!s)
        break;
      r = s.to + 1;
    }
    return He.set(e);
  }
  updateDeco() {
    let e = 1, t = this.view.state.facet(zf).map((s) => (this.dynamicDecorationMap[e++] = typeof s == "function") ? s(this.view) : s), r = !1, i = this.view.state.facet(JT).map((s, o) => {
      let l = typeof s == "function";
      return l && (r = !0), l ? s(this.view) : s;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = r, t.push(ht.join(i))), this.decorations = [
      this.editContextFormatting,
      ...t,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(KT))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (u) {
        Ar(this.view.state, u, "scroll handler");
      }
    let { range: t } = e, r = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), i;
    if (!r)
      return;
    !t.empty && (i = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let s = q3(this.view), o = {
      left: r.left - s.left,
      top: r.top - s.top,
      right: r.right + s.right,
      bottom: r.bottom + s.bottom
    }, { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM;
    vW(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, a), -a), this.view.textDirection == Wt.LTR);
  }
}
function $W(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
function QT(n, e) {
  let t = n.observer.selectionRange;
  if (!t.focusNode)
    return null;
  let r = ST(t.focusNode, t.focusOffset), i = CT(t.focusNode, t.focusOffset), s = r || i;
  if (i && r && i.node != r.node) {
    let l = Dt.get(i.node);
    if (!l || l instanceof Bi && l.text != i.node.nodeValue)
      s = i;
    else if (n.docView.lastCompositionAfterCursor) {
      let a = Dt.get(r.node);
      !a || a instanceof Bi && a.text != r.node.nodeValue || (s = i);
    }
  }
  if (n.docView.lastCompositionAfterCursor = s != r, !s)
    return null;
  let o = e - s.offset;
  return { from: o, to: o + s.node.nodeValue.length, node: s.node };
}
function VW(n, e, t) {
  let r = QT(n, t);
  if (!r)
    return null;
  let { node: i, from: s, to: o } = r, l = i.nodeValue;
  if (/[\n\r]/.test(l) || n.state.doc.sliceString(r.from, r.to) != l)
    return null;
  let a = e.invertedDesc, c = new yi(a.mapPos(s), a.mapPos(o), s, o), u = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let f = Dt.get(h);
    if (f instanceof co)
      u.push({ node: h, deco: f.mark });
    else {
      if (f instanceof dn || h.nodeName == "DIV" && h.parentNode == n.contentDOM)
        return { range: c, text: i, marks: u, line: h };
      if (h != n.contentDOM)
        u.push({ node: h, deco: new fd({
          inclusive: !0,
          attributes: EW(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function qW(n, e) {
  return n.nodeType != 1 ? 0 : (e && n.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < n.childNodes.length && n.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let WW = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    dp(e, t, this.changes);
  }
  comparePoint(e, t) {
    dp(e, t, this.changes);
  }
  boundChange(e) {
    dp(e, e, this.changes);
  }
};
function jW(n, e, t) {
  let r = new WW();
  return ht.compare(n, e, t, r), r.changes;
}
function UW(n, e) {
  for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function KW(n, e) {
  let t = !1;
  return e && n.iterChangedRanges((r, i) => {
    r < e.to && i > e.from && (t = !0);
  }), t;
}
function GW(n, e, t = 1) {
  let r = n.charCategorizer(e), i = n.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return G.cursor(e);
  s == 0 ? t = 1 : s == i.length && (t = -1);
  let o = s, l = s;
  t < 0 ? o = zn(i.text, s, !1) : l = zn(i.text, s);
  let a = r(i.text.slice(o, l));
  for (; o > 0; ) {
    let c = zn(i.text, o, !1);
    if (r(i.text.slice(c, o)) != a)
      break;
    o = c;
  }
  for (; l < i.length; ) {
    let c = zn(i.text, l);
    if (r(i.text.slice(l, c)) != a)
      break;
    l = c;
  }
  return G.range(o + i.from, l + i.from);
}
function YW(n, e) {
  return e.left > n ? e.left - n : Math.max(0, n - e.right);
}
function JW(n, e) {
  return e.top > n ? e.top - n : Math.max(0, n - e.bottom);
}
function f2(n, e) {
  return n.top < e.bottom - 1 && n.bottom > e.top + 1;
}
function ox(n, e) {
  return e < n.top ? { top: e, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function lx(n, e) {
  return e > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: e } : n;
}
function Ry(n, e, t) {
  let r, i, s, o, l = !1, a, c, u, h;
  for (let p = n.firstChild; p; p = p.nextSibling) {
    let m = Bf(p);
    for (let g = 0; g < m.length; g++) {
      let b = m[g];
      i && f2(i, b) && (b = ox(lx(b, i.bottom), i.top));
      let w = YW(e, b), k = JW(t, b);
      if (w == 0 && k == 0)
        return p.nodeType == 3 ? ax(p, e, t) : Ry(p, e, t);
      (!r || o > k || o == k && s > w) && (r = p, i = b, s = w, o = k, l = w ? e < b.left ? g > 0 : g < m.length - 1 : !0), w == 0 ? t > b.bottom && (!u || u.bottom < b.bottom) ? (a = p, u = b) : t < b.top && (!h || h.top > b.top) && (c = p, h = b) : u && f2(u, b) ? u = lx(u, b.bottom) : h && f2(h, b) && (h = ox(h, b.top));
    }
  }
  if (u && u.bottom >= t ? (r = a, i = u) : h && h.top <= t && (r = c, i = h), !r)
    return { node: n, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3)
    return ax(r, f, t);
  if (l && r.contentEditable != "false")
    return Ry(r, f, t);
  let d = Array.prototype.indexOf.call(n.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: n, offset: d };
}
function ax(n, e, t) {
  let r = n.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let l = 0; l < r; l++) {
    let a = Ma(n, l, l + 1).getClientRects();
    for (let c = 0; c < a.length; c++) {
      let u = a[c];
      if (u.top == u.bottom)
        continue;
      o || (o = e - u.left);
      let h = (u.top > t ? u.top - t : t - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && h < s) {
        let f = e >= (u.left + u.right) / 2, d = f;
        if ((xe.chrome || xe.gecko) && Ma(n, l).getBoundingClientRect().left == u.right && (d = !f), h <= 0)
          return { node: n, offset: l + (d ? 1 : 0) };
        i = l + (d ? 1 : 0), s = h;
      }
    }
  }
  return { node: n, offset: i > -1 ? i : o > 0 ? n.nodeValue.length : 0 };
}
function eA(n, e, t, r = -1) {
  var i, s;
  let o = n.contentDOM.getBoundingClientRect(), l = o.top + n.viewState.paddingTop, a, { docHeight: c } = n.viewState, { x: u, y: h } = e, f = h - l;
  if (f < 0)
    return 0;
  if (f > c)
    return n.state.doc.length;
  for (let C = n.viewState.heightOracle.textHeight / 2, M = !1; a = n.elementAtHeight(f), a.type != ur.Text; )
    for (; f = r > 0 ? a.bottom + C : a.top - C, !(f >= 0 && f <= c); ) {
      if (M)
        return t ? null : 0;
      M = !0, r = -r;
    }
  h = l + f;
  let d = a.from;
  if (d < n.viewport.from)
    return n.viewport.from == 0 ? 0 : t ? null : cx(n, o, a, u, h);
  if (d > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : t ? null : cx(n, o, a, u, h);
  let p = n.dom.ownerDocument, m = n.root.elementFromPoint ? n.root : p, g = m.elementFromPoint(u, h);
  g && !n.contentDOM.contains(g) && (g = null), g || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), g = m.elementFromPoint(u, h), g && !n.contentDOM.contains(g) && (g = null));
  let b, w = -1;
  if (g && ((i = n.docView.nearest(g)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let C = p.caretPositionFromPoint(u, h);
      C && ({ offsetNode: b, offset: w } = C);
    } else if (p.caretRangeFromPoint) {
      let C = p.caretRangeFromPoint(u, h);
      C && ({ startContainer: b, startOffset: w } = C, (!n.contentDOM.contains(b) || xe.safari && XW(b, w, u) || xe.chrome && ZW(b, w, u)) && (b = void 0));
    }
    b && (w = Math.min(xs(b), w));
  }
  if (!b || !n.docView.dom.contains(b)) {
    let C = dn.find(n.docView, d);
    if (!C)
      return f > a.top + a.height / 2 ? a.to : a.from;
    ({ node: b, offset: w } = Ry(C.dom, u, h));
  }
  let k = n.docView.nearest(b);
  if (!k)
    return null;
  if (k.isWidget && ((s = k.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let C = k.dom.getBoundingClientRect();
    return e.y < C.top || e.y <= C.bottom && e.x <= (C.left + C.right) / 2 ? k.posAtStart : k.posAtEnd;
  } else
    return k.localPosFromDOM(b, w) + k.posAtStart;
}
function cx(n, e, t, r, i) {
  let s = Math.round((r - e.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
    let l = n.viewState.heightOracle.textHeight, a = Math.floor((i - t.top - (n.defaultLineHeight - l) * 0.5) / l);
    s += a * n.viewState.heightOracle.lineLength;
  }
  let o = n.state.sliceDoc(t.from, t.to);
  return t.from + vy(o, s, n.state.tabSize);
}
function XW(n, e, t) {
  let r, i = n;
  if (n.nodeType != 3 || e != (r = n.nodeValue.length))
    return !1;
  for (; ; ) {
    let s = i.nextSibling;
    if (s) {
      if (s.nodeName == "BR")
        break;
      return !1;
    } else {
      let o = i.parentNode;
      if (!o || o.nodeName == "DIV")
        break;
      i = o;
    }
  }
  return Ma(n, r - 1, r).getBoundingClientRect().right > t;
}
function ZW(n, e, t) {
  if (e != 0)
    return !1;
  for (let i = n; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let r = n.nodeType == 1 ? n.getBoundingClientRect() : Ma(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return t - r.left > 5;
}
function Py(n, e, t) {
  let r = n.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    let i;
    for (let s of r.type) {
      if (s.from > e)
        break;
      if (!(s.to < e)) {
        if (s.from < e && s.to > e)
          return s;
        (!i || s.type == ur.Text && (i.type != s.type || (t < 0 ? s.from < e : s.to > e))) && (i = s);
      }
    }
    return i || r;
  }
  return r;
}
function QW(n, e, t, r) {
  let i = Py(n, e.head, e.assoc || -1), s = !r || i.type != ur.Text || !(n.lineWrapping || i.widgetLineBreaks) ? null : n.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = n.dom.getBoundingClientRect(), l = n.textDirectionAt(i.from), a = n.posAtCoords({
      x: t == (l == Wt.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (a != null)
      return G.cursor(a, t ? -1 : 1);
  }
  return G.cursor(t ? i.to : i.from, t ? -1 : 1);
}
function ux(n, e, t, r) {
  let i = n.state.doc.lineAt(e.head), s = n.bidiSpans(i), o = n.textDirectionAt(i.from);
  for (let l = e, a = null; ; ) {
    let c = zW(i, s, o, l, t), u = zT;
    if (!c) {
      if (i.number == (t ? n.state.doc.lines : 1))
        return l;
      u = `
`, i = n.state.doc.line(i.number + (t ? 1 : -1)), s = n.bidiSpans(i), c = n.visualLineSide(i, !t);
    }
    if (a) {
      if (!a(u))
        return l;
    } else {
      if (!r)
        return c;
      a = r(u);
    }
    l = c;
  }
}
function ej(n, e, t) {
  let r = n.state.charCategorizer(e), i = r(t);
  return (s) => {
    let o = r(s);
    return i == jt.Space && (i = o), i == o;
  };
}
function tj(n, e, t, r) {
  let i = e.head, s = t ? 1 : -1;
  if (i == (t ? n.state.doc.length : 0))
    return G.cursor(i, e.assoc);
  let o = e.goalColumn, l, a = n.contentDOM.getBoundingClientRect(), c = n.coordsAtPos(i, e.assoc || -1), u = n.documentTop;
  if (c)
    o == null && (o = c.left - a.left), l = s < 0 ? c.top : c.bottom;
  else {
    let d = n.viewState.lineBlockAt(i);
    o == null && (o = Math.min(a.right - a.left, n.defaultCharacterWidth * (i - d.from))), l = (s < 0 ? d.top : d.bottom) + u;
  }
  let h = a.left + o, f = r ?? n.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = l + (f + d) * s, m = eA(n, { x: h, y: p }, !1, s);
    if (p < a.top || p > a.bottom || (s < 0 ? m < i : m > i)) {
      let g = n.docView.coordsForChar(m), b = !g || p < g.top ? -1 : 1;
      return G.cursor(m, b, void 0, o);
    }
  }
}
function pp(n, e, t) {
  for (; ; ) {
    let r = 0;
    for (let i of n)
      i.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let a = r || t || (e - s < o - e ? -1 : 1);
          e = a < 0 ? s : o, r = a;
        }
      });
    if (!r)
      return e;
  }
}
function tA(n, e) {
  let t = null;
  for (let r = 0; r < e.ranges.length; r++) {
    let i = e.ranges[r], s = null;
    if (i.empty) {
      let o = pp(n, i.from, 0);
      o != i.from && (s = G.cursor(o, -1));
    } else {
      let o = pp(n, i.from, -1), l = pp(n, i.to, 1);
      (o != i.from || l != i.to) && (s = G.range(i.from == i.anchor ? o : l, i.from == i.head ? o : l));
    }
    s && (t || (t = e.ranges.slice()), t[r] = s);
  }
  return t ? G.create(t, e.mainIndex) : e;
}
function d2(n, e, t) {
  let r = pp(n.state.facet(w1).map((i) => i(n)), t.from, e.head > t.from ? -1 : 1);
  return r == t.from ? t : G.cursor(r, r < t.from ? 1 : -1);
}
const hh = "￿";
class nj {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(ct.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += hh;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == t)
        break;
      let l = Dt.get(i), a = Dt.get(o);
      (l && a ? l.breakAfter : (l ? l.breakAfter : fm(i)) || fm(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(r, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, t.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, l;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (l = i.exec(t)) && (s = l.index, o = l[0].length), this.append(t.slice(r, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= o - 1);
      r = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Dt.get(e), r = t && t.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == t && (r.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (rj(e, r.node, r.offset) ? t : 0));
  }
}
function rj(n, e, t) {
  for (; ; ) {
    if (!e || t < xs(e))
      return !1;
    if (e == n)
      return !0;
    t = Ca(e) + 1, e = e.parentNode;
  }
}
class hx {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class ij {
  constructor(e, t, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = t > -1;
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, r, 0))) {
      let l = s || o ? [] : lj(e), a = new nj(l, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = aj(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, a = s && s.node == l.focusNode && s.offset == l.focusOffset || !ky(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), c = o && o.node == l.anchorNode && o.offset == l.anchorOffset || !ky(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset), u = e.viewport;
      if ((xe.ios || xe.chrome) && e.state.selection.main.empty && a != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let h = Math.min(a, c), f = Math.max(a, c), d = u.from - h, p = u.to - f;
        (d == 0 || d == 1 || h == 0) && (p == 0 || p == -1 || f == e.state.doc.length) && (a = 0, c = e.state.doc.length);
      }
      this.newSel = G.single(c, a);
    }
  }
}
function nA(n, e) {
  let t, { newSel: r } = e, i = n.state.selection.main, s = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds, a = i.from, c = null;
    (s === 8 || xe.android && e.text.length < l - o) && (a = i.to, c = "end");
    let u = oj(n.state.doc.sliceString(o, l, hh), e.text, a - o, c);
    u && (xe.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == hh + hh && u.toB--, t = {
      from: o + u.from,
      to: o + u.toA,
      insert: dt.of(e.text.slice(u.from, u.toB).split(hh))
    });
  } else r && (!n.hasFocus && n.state.facet(Ys) || r.main.eq(i)) && (r = null);
  if (!t && !r)
    return !1;
  if (!t && e.typeOver && !i.empty && r && r.main.empty ? t = { from: i.from, to: i.to, insert: n.state.doc.slice(i.from, i.to) } : (xe.mac || xe.android) && t && t.from == t.to && t.from == i.head - 1 && /^\. ?$/.test(t.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (r && t.insert.length == 2 && (r = G.single(r.main.anchor - 1, r.main.head - 1)), t = { from: t.from, to: t.to, insert: dt.of([t.insert.toString().replace(".", " ")]) }) : t && t.from >= i.from && t.to <= i.to && (t.from != i.from || t.to != i.to) && i.to - i.from - (t.to - t.from) <= 4 ? t = {
    from: i.from,
    to: i.to,
    insert: n.state.doc.slice(i.from, t.from).append(t.insert).append(n.state.doc.slice(t.to, i.to))
  } : xe.chrome && t && t.from == t.to && t.from == i.head && t.insert.toString() == `
 ` && n.lineWrapping && (r && (r = G.single(r.main.anchor - 1, r.main.head - 1)), t = { from: i.from, to: i.to, insert: dt.of([" "]) }), t)
    return W3(n, t, r, s);
  if (r && !r.main.eq(i)) {
    let o = !1, l = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (o = !0), l = n.inputState.lastSelectionOrigin, l == "select.pointer" && (r = tA(n.state.facet(w1).map((a) => a(n)), r))), n.dispatch({ selection: r, scrollIntoView: o, userEvent: l }), !0;
  } else
    return !1;
}
function W3(n, e, t, r = -1) {
  if (xe.ios && n.inputState.flushIOSKey(e))
    return !0;
  let i = n.state.selection.main;
  if (xe.android && (e.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == i.from || e.from == i.from - 1 && n.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && vc(n.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && vc(n.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && vc(n.contentDOM, "Delete", 46)))
    return !0;
  let s = e.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let o, l = () => o || (o = sj(n, e, t));
  return n.state.facet(qT).some((a) => a(n, e.from, e.to, s, l)) || n.dispatch(l()), !0;
}
function sj(n, e, t) {
  let r, i = n.state, s = i.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && n.inputState.composing < 0) {
    let l = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", a = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    r = i.replaceSelection(n.state.toText(l + e.insert.sliceString(0, void 0, n.state.lineBreak) + a));
  } else {
    let l = i.changes(e), a = t && t.main.to <= l.newLength ? t.main : void 0;
    if (i.selection.ranges.length > 1 && n.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = n.state.sliceDoc(e.from, e.to), u, h = t && QT(n, t.main.head);
      if (h) {
        let p = e.insert.length - (e.to - e.from);
        u = { from: h.from, to: h.to - p };
      } else
        u = n.state.doc.lineAt(s.head);
      let f = s.to - e.to, d = s.to - s.from;
      r = i.changeByRange((p) => {
        if (p.from == s.from && p.to == s.to)
          return { changes: l, range: a || p.map(l) };
        let m = p.to - f, g = m - c.length;
        if (p.to - p.from != d || n.state.sliceDoc(g, m) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= u.from && p.from <= u.to)
          return { range: p };
        let b = i.changes({ from: g, to: m, insert: e.insert }), w = p.to - s.to;
        return {
          changes: b,
          range: a ? G.range(Math.max(0, a.anchor + w), Math.max(0, a.head + w)) : p.map(b)
        };
      });
    } else
      r = {
        changes: l,
        selection: a && i.selection.replaceRange(a)
      };
  }
  let o = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, o += ".compose", n.inputState.compositionFirstChange && (o += ".start", n.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: o, scrollIntoView: !0 });
}
function oj(n, e, t, r) {
  let i = Math.min(n.length, e.length), s = 0;
  for (; s < i && n.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && n.length == e.length)
    return null;
  let o = n.length, l = e.length;
  for (; o > 0 && l > 0 && n.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (r == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    t -= o + a - s;
  }
  if (o < s && n.length < e.length) {
    let a = t <= s && t >= o ? s - t : 0;
    s -= a, l = s + (l - o), o = s;
  } else if (l < s) {
    let a = t <= s && t >= l ? s - t : 0;
    s -= a, o = s + (o - l), l = s;
  }
  return { from: s, toA: o, toB: l };
}
function lj(n) {
  let e = [];
  if (n.root.activeElement != n.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s } = n.observer.selectionRange;
  return t && (e.push(new hx(t, r)), (i != t || s != r) && e.push(new hx(i, s))), e;
}
function aj(n, e) {
  if (n.length == 0)
    return null;
  let t = n[0].pos, r = n.length == 2 ? n[1].pos : t;
  return t > -1 && r > -1 ? G.single(t + e, r + e) : null;
}
class cj {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, xe.safari && e.contentDOM.addEventListener("input", () => null), xe.gecko && Mj(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !yj(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, t) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers)
        i(this.view, t);
      for (let i of r.handlers) {
        if (t.defaultPrevented)
          break;
        if (i(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = uj(e), r = this.handlers, i = this.view.contentDOM;
    for (let s in t)
      if (s != "scroll") {
        let o = !t[s].handlers.length, l = r[s];
        l && o != !l.handlers.length && (i.removeEventListener(s, this.handleEvent), l = null), l || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in r)
      s != "scroll" && !t[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && iA.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), xe.android && xe.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return xe.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = rA.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || hj.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return !t || t.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, vc(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : xe.safari && !xe.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function fx(n, e) {
  return (t, r) => {
    try {
      return e.call(n, r, t);
    } catch (i) {
      Ar(t.state, i);
    }
  };
}
function uj(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of n) {
    let i = r.spec, s = i && i.plugin.domEventHandlers, o = i && i.plugin.domEventObservers;
    if (s)
      for (let l in s) {
        let a = s[l];
        a && t(l).handlers.push(fx(r.value, a));
      }
    if (o)
      for (let l in o) {
        let a = o[l];
        a && t(l).observers.push(fx(r.value, a));
      }
  }
  for (let r in zi)
    t(r).handlers.push(zi[r]);
  for (let r in vi)
    t(r).observers.push(vi[r]);
  return e;
}
const rA = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], hj = "dthko", iA = [16, 17, 18, 20, 91, 92, 224, 225], n0 = 6;
function r0(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function fj(n, e) {
  return Math.max(Math.abs(n.clientX - e.clientX), Math.abs(n.clientY - e.clientY));
}
class dj {
  constructor(e, t, r, i) {
    this.view = e, this.startEvent = t, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParents = wW(e.contentDOM), this.atoms = e.state.facet(w1).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(ct.allowMultipleSelections) && pj(e, t), this.dragging = gj(e, t) && lA(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && fj(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let t = 0, r = 0, i = 0, s = 0, o = this.view.win.innerWidth, l = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: s, bottom: l } = this.scrollParents.y.getBoundingClientRect());
    let a = q3(this.view);
    e.clientX - a.left <= i + n0 ? t = -r0(i - e.clientX) : e.clientX + a.right >= o - n0 && (t = r0(e.clientX - o)), e.clientY - a.top <= s + n0 ? r = -r0(s - e.clientY) : e.clientY + a.bottom >= l - n0 && (r = r0(e.clientY - l)), this.setScrollSpeed(t, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: t } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), t && this.scrollParents.y && (this.scrollParents.y.scrollTop += t, t = 0), (e || t) && this.view.win.scrollBy(e, t), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(e) {
    let { view: t } = this, r = tA(this.atoms, this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((t) => t.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function pj(n, e) {
  let t = n.state.facet(FT);
  return t.length ? t[0](e) : xe.mac ? e.metaKey : e.ctrlKey;
}
function mj(n, e) {
  let t = n.state.facet(HT);
  return t.length ? t[0](e) : xe.mac ? !e.altKey : !e.ctrlKey;
}
function gj(n, e) {
  let { main: t } = n.state.selection;
  if (t.empty)
    return !1;
  let r = Lf(n.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function yj(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, r; t != n.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (r = Dt.get(t)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const zi = /* @__PURE__ */ Object.create(null), vi = /* @__PURE__ */ Object.create(null), sA = xe.ie && xe.ie_version < 15 || xe.ios && xe.webkit_version < 604;
function bj(n) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    n.focus(), t.remove(), oA(n, t.value);
  }, 50);
}
function x1(n, e, t) {
  for (let r of n.facet(e))
    t = r(t, n);
  return t;
}
function oA(n, e) {
  e = x1(n.state, H3, e);
  let { state: t } = n, r, i = 1, s = t.toText(e), o = s.lines == t.selection.ranges.length;
  if (_y != null && t.selection.ranges.every((a) => a.empty) && _y == s.toString()) {
    let a = -1;
    r = t.changeByRange((c) => {
      let u = t.doc.lineAt(c.from);
      if (u.from == a)
        return { range: c };
      a = u.from;
      let h = t.toText((o ? s.line(i++).text : e) + t.lineBreak);
      return {
        changes: { from: u.from, insert: h },
        range: G.cursor(c.from + h.length)
      };
    });
  } else o ? r = t.changeByRange((a) => {
    let c = s.line(i++);
    return {
      changes: { from: a.from, to: a.to, insert: c.text },
      range: G.cursor(a.from + c.length)
    };
  }) : r = t.replaceSelection(s);
  n.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
vi.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
zi.keydown = (n, e) => (n.inputState.setSelectionOrigin("select"), e.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
vi.touchstart = (n, e) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
vi.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
zi.mousedown = (n, e) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let r of n.state.facet($T))
    if (t = r(n, e), t)
      break;
  if (!t && e.button == 0 && (t = xj(n, e)), t) {
    let r = !n.hasFocus;
    n.inputState.startMouseSelection(new dj(n, e, t, r)), r && n.observer.ignore(() => {
      wT(n.contentDOM);
      let s = n.root.activeElement;
      s && !s.contains(n.contentDOM) && s.blur();
    });
    let i = n.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  } else
    n.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function dx(n, e, t, r) {
  if (r == 1)
    return G.cursor(e, t);
  if (r == 2)
    return GW(n.state, e, t);
  {
    let i = dn.find(n.docView, e), s = n.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, l = i ? i.posAtEnd : s.to;
    return l < n.state.doc.length && l == s.to && l++, G.range(o, l);
  }
}
let px = (n, e, t) => e >= t.top && e <= t.bottom && n >= t.left && n <= t.right;
function vj(n, e, t, r) {
  let i = dn.find(n.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && px(t, r, o))
    return -1;
  let l = i.coordsAt(s, 1);
  return l && px(t, r, l) ? 1 : o && o.bottom >= r ? -1 : 1;
}
function mx(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: vj(n, t, e.clientX, e.clientY) };
}
const wj = xe.ie && xe.ie_version <= 11;
let gx = null, yx = 0, bx = 0;
function lA(n) {
  if (!wj)
    return n.detail;
  let e = gx, t = bx;
  return gx = n, bx = Date.now(), yx = !e || t > Date.now() - 400 && Math.abs(e.clientX - n.clientX) < 2 && Math.abs(e.clientY - n.clientY) < 2 ? (yx + 1) % 3 : 1;
}
function xj(n, e) {
  let t = mx(n, e), r = lA(e), i = n.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), i = i.map(s.changes));
    },
    get(s, o, l) {
      let a = mx(n, s), c, u = dx(n, a.pos, a.bias, r);
      if (t.pos != a.pos && !o) {
        let h = dx(n, t.pos, t.bias, r), f = Math.min(h.from, u.from), d = Math.max(h.to, u.to);
        u = f < u.from ? G.range(f, d) : G.range(d, f);
      }
      return o ? i.replaceRange(i.main.extend(u.from, u.to)) : l && r == 1 && i.ranges.length > 1 && (c = kj(i, a.pos)) ? c : l ? i.addRange(u) : G.create([u]);
    }
  };
}
function kj(n, e) {
  for (let t = 0; t < n.ranges.length; t++) {
    let { from: r, to: i } = n.ranges[t];
    if (r <= e && i >= e)
      return G.create(n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)), n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0));
  }
  return null;
}
zi.dragstart = (n, e) => {
  let { selection: { main: t } } = n.state;
  if (e.target.draggable) {
    let i = n.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= t.to || o <= t.from) && (t = G.range(s, o));
    }
  }
  let { inputState: r } = n;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", x1(n.state, $3, n.state.sliceDoc(t.from, t.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
zi.dragend = (n) => (n.inputState.draggedContent = null, !1);
function vx(n, e, t, r) {
  if (t = x1(n.state, H3, t), !t)
    return;
  let i = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = n.inputState, o = r && s && mj(n, e) ? { from: s.from, to: s.to } : null, l = { from: i, insert: t }, a = n.state.changes(o ? [o, l] : l);
  n.focus(), n.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(i, -1), head: a.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
zi.drop = (n, e) => {
  if (!e.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let r = Array(t.length), i = 0, s = () => {
      ++i == t.length && vx(n, e, r.filter((o) => o != null).join(n.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (r[o] = l.result), s();
      }, l.readAsText(t[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return vx(n, e, r, !0), !0;
  }
  return !1;
};
zi.paste = (n, e) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let t = sA ? null : e.clipboardData;
  return t ? (oA(n, t.getData("text/plain") || t.getData("text/uri-list")), !0) : (bj(n), !1);
};
function Sj(n, e) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let r = t.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), n.focus();
  }, 50);
}
function Cj(n) {
  let e = [], t = [], r = !1;
  for (let i of n.selection.ranges)
    i.empty || (e.push(n.sliceDoc(i.from, i.to)), t.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of n.selection.ranges) {
      let o = n.doc.lineAt(s);
      o.number > i && (e.push(o.text), t.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })), i = o.number;
    }
    r = !0;
  }
  return { text: x1(n, $3, e.join(n.lineBreak)), ranges: t, linewise: r };
}
let _y = null;
zi.copy = zi.cut = (n, e) => {
  let { text: t, ranges: r, linewise: i } = Cj(n.state);
  if (!t && !i)
    return !1;
  _y = i ? t : null, e.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = sA ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", t), !0) : (Sj(n, t), !1);
};
const aA = /* @__PURE__ */ wo.define();
function cA(n, e) {
  let t = [];
  for (let r of n.facet(WT)) {
    let i = r(n, e);
    i && t.push(i);
  }
  return t.length ? n.update({ effects: t, annotations: aA.of(!0) }) : null;
}
function uA(n) {
  setTimeout(() => {
    let e = n.hasFocus;
    if (e != n.inputState.notifiedFocused) {
      let t = cA(n.state, e);
      t ? n.dispatch(t) : n.update([]);
    }
  }, 10);
}
vi.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), uA(n);
};
vi.blur = (n) => {
  n.observer.clearSelectionRange(), uA(n);
};
vi.compositionstart = vi.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
vi.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, xe.chrome && xe.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
vi.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
zi.beforeinput = (n, e) => {
  var t, r;
  if (e.inputType == "insertReplacementText" && n.observer.editContext) {
    let s = (t = e.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain"), o = e.getTargetRanges();
    if (s && o.length) {
      let l = o[0], a = n.posAtDOM(l.startContainer, l.startOffset), c = n.posAtDOM(l.endContainer, l.endOffset);
      return W3(n, { from: a, to: c, insert: n.state.toText(s) }, null), !0;
    }
  }
  let i;
  if (xe.chrome && xe.android && (i = rA.find((s) => s.inputType == e.inputType)) && (n.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let s = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > s + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return xe.ios && e.inputType == "deleteContentForward" && n.observer.flushSoon(), xe.safari && e.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => vi.compositionend(n, e), 20), !1;
};
const wx = /* @__PURE__ */ new Set();
function Mj(n) {
  wx.has(n) || (wx.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
const xx = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Fc = !1;
function kx() {
  Fc = !1;
}
class Tj {
  constructor(e) {
    this.lineWrapping = e, this.doc = dt.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, t) {
    let r = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((t - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return xx.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (t = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, r, i, s, o) {
    let l = xx.indexOf(e) > -1, a = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = t, this.charWidth = r, this.textHeight = i, this.lineLength = s, a) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return a;
  }
}
class Aj {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class as {
  /**
  @internal
  */
  constructor(e, t, r, i, s) {
    this.from = e, this.length = t, this.top = r, this.height = i, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? ur.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof fl ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new as(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var qt = /* @__PURE__ */ (function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
})(qt || (qt = {}));
const mp = 1e-3;
class hr {
  constructor(e, t, r = 2) {
    this.length = e, this.height = t, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > mp && (Fc = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, r) {
    return hr.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, r, i) {
    let s = this, o = r.doc;
    for (let l = i.length - 1; l >= 0; l--) {
      let { fromA: a, toA: c, fromB: u, toB: h } = i[l], f = s.lineAt(a, qt.ByPosNoHeight, r.setDoc(t), 0, 0), d = f.to >= c ? f : s.lineAt(c, qt.ByPosNoHeight, r, 0, 0);
      for (h += d.to - c, c = d.to; l > 0 && f.from <= i[l - 1].toA; )
        a = i[l - 1].fromA, u = i[l - 1].fromB, l--, a < f.from && (f = s.lineAt(a, qt.ByPosNoHeight, r, 0, 0));
      u += f.from - a, a = f.from;
      let p = j3.build(r.setDoc(o), e, u, h);
      s = mm(s, s.replace(a, c, p));
    }
    return s.updateHeight(r, 0);
  }
  static empty() {
    return new Wr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, r = e.length, i = 0, s = 0;
    for (; ; )
      if (t == r)
        if (i > s * 2) {
          let l = e[t - 1];
          l.break ? e.splice(--t, 1, l.left, null, l.right) : e.splice(--t, 1, l.left, l.right), r += 1 + l.break, i -= l.size;
        } else if (s > i * 2) {
          let l = e[r];
          l.break ? e.splice(r, 1, l.left, null, l.right) : e.splice(r, 1, l.left, l.right), r += 2 + l.break, s -= l.size;
        } else
          break;
      else if (i < s) {
        let l = e[t++];
        l && (i += l.size);
      } else {
        let l = e[--r];
        l && (s += l.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, r++), new Oj(hr.of(e.slice(0, t)), o, hr.of(e.slice(r)));
  }
}
function mm(n, e) {
  return n == e ? n : (n.constructor != e.constructor && (Fc = !0), e);
}
hr.prototype.size = 1;
class hA extends hr {
  constructor(e, t, r) {
    super(e, t), this.deco = r;
  }
  blockAt(e, t, r, i) {
    return new as(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, t, r, i, s) {
    return this.blockAt(0, r, i, s);
  }
  forEachLine(e, t, r, i, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, r, i, s));
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Wr extends hA {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, r, i) {
    return new as(i, this.length, r, this.height, this.breaks);
  }
  replace(e, t, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof Wr || i instanceof Rn && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Rn ? i = new Wr(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : hr.of(r);
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more ? this.setHeight(i.heights[i.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Rn extends hr {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let r = e.doc.lineAt(t).number, i = e.doc.lineAt(t + this.length).number, s = i - r + 1, o, l = 0;
    if (e.lineWrapping) {
      let a = Math.min(this.height, e.lineHeight * s);
      o = a / s, this.length > s + 1 && (l = (this.height - a) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: r, lastLine: i, perLine: o, perChar: l };
  }
  blockAt(e, t, r, i) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: a } = this.heightMetrics(t, i);
    if (t.lineWrapping) {
      let c = i + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), u = t.doc.lineAt(c), h = l + u.length * a, f = Math.max(r, e - h / 2);
      return new as(u.from, u.length, f, h, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - r) / l))), { from: u, length: h } = t.doc.line(s + c);
      return new as(u, h, r + l * c, l, 0);
    }
  }
  lineAt(e, t, r, i, s) {
    if (t == qt.ByHeight)
      return this.blockAt(e, r, i, s);
    if (t == qt.ByPosNoHeight) {
      let { from: d, to: p } = r.doc.lineAt(e);
      return new as(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: a } = this.heightMetrics(r, s), c = r.doc.lineAt(e), u = l + c.length * a, h = c.number - o, f = i + l * h + a * (c.from - s - h);
    return new as(c.from, c.length, Math.max(i, Math.min(f, i + this.height - u)), u, 0);
  }
  forEachLine(e, t, r, i, s, o) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: l, perLine: a, perChar: c } = this.heightMetrics(r, s);
    for (let u = e, h = i; u <= t; ) {
      let f = r.doc.lineAt(u);
      if (u == e) {
        let p = f.number - l;
        h += a * p + c * (e - s - p);
      }
      let d = a + c * f.length;
      o(new as(f.from, f.length, h, d, 0)), h += d, u = f.to + 1;
    }
  }
  replace(e, t, r) {
    let i = this.length - t;
    if (i > 0) {
      let s = r[r.length - 1];
      s instanceof Rn ? r[r.length - 1] = new Rn(s.length + i) : r.push(null, new Rn(i - 1));
    }
    if (e > 0) {
      let s = r[0];
      s instanceof Rn ? r[0] = new Rn(e + s.length) : r.unshift(new Rn(e - 1), null);
    }
    return hr.of(r);
  }
  decomposeLeft(e, t) {
    t.push(new Rn(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new Rn(this.length - e - 1));
  }
  updateHeight(e, t = 0, r = !1, i) {
    let s = t + this.length;
    if (i && i.from <= t + this.length && i.more) {
      let o = [], l = Math.max(t, i.from), a = -1;
      for (i.from > t && o.push(new Rn(i.from - t - 1).updateHeight(e, t)); l <= s && i.more; ) {
        let u = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let h = i.heights[i.index++];
        a == -1 ? a = h : Math.abs(h - a) >= mp && (a = -2);
        let f = new Wr(u, h);
        f.outdated = !1, o.push(f), l += u + 1;
      }
      l <= s && o.push(null, new Rn(s - l).updateHeight(e, l));
      let c = hr.of(o);
      return (a < 0 || Math.abs(c.height - this.height) >= mp || Math.abs(a - this.heightMetrics(e, t).perLine) >= mp) && (Fc = !0), mm(this, c);
    } else (r || this.outdated) && (this.setHeight(e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class Oj extends hr {
  constructor(e, t, r) {
    super(e.length + t + r.length, e.height + r.height, t | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, r, i) {
    let s = r + this.left.height;
    return e < s ? this.left.blockAt(e, t, r, i) : this.right.blockAt(e, t, s, i + this.left.length + this.break);
  }
  lineAt(e, t, r, i, s) {
    let o = i + this.left.height, l = s + this.left.length + this.break, a = t == qt.ByHeight ? e < o : e < l, c = a ? this.left.lineAt(e, t, r, i, s) : this.right.lineAt(e, t, r, o, l);
    if (this.break || (a ? c.to < l : c.from > l))
      return c;
    let u = t == qt.ByPosNoHeight ? qt.ByPosNoHeight : qt.ByPos;
    return a ? c.join(this.right.lineAt(l, u, r, o, l)) : this.left.lineAt(l, u, r, i, s).join(c);
  }
  forEachLine(e, t, r, i, s, o) {
    let l = i + this.left.height, a = s + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, t, r, i, s, o), t >= a && this.right.forEachLine(e, t, r, l, a, o);
    else {
      let c = this.lineAt(a, qt.ByPos, r, i, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, s, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, r, l, a, o);
    }
  }
  replace(e, t, r) {
    let i = this.left.length + this.break;
    if (t < i)
      return this.balanced(this.left.replace(e, t, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, t - i, r));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of r)
      s.push(l);
    if (e > 0 && Sx(s, o - 1), t < this.length) {
      let l = s.length;
      this.decomposeRight(t, s), Sx(s, l);
    }
    return hr.of(s);
  }
  decomposeLeft(e, t) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (r++, e >= r && t.push(null)), e > r && this.right.decomposeLeft(e - r, t);
  }
  decomposeRight(e, t) {
    let r = this.left.length, i = r + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, t);
    e < r && this.left.decomposeRight(e, t), this.break && e < i && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? hr.of(this.break ? [e, null, t] : [e, t]) : (this.left = mm(this.left, e), this.right = mm(this.right, t), this.setHeight(e.height + t.height), this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, r = !1, i) {
    let { left: s, right: o } = this, l = t + s.length + this.break, a = null;
    return i && i.from <= t + s.length && i.more ? a = s = s.updateHeight(e, t, r, i) : s.updateHeight(e, t, r), i && i.from <= l + o.length && i.more ? a = o = o.updateHeight(e, l, r, i) : o.updateHeight(e, l, r), a ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function Sx(n, e) {
  let t, r;
  n[e] == null && (t = n[e - 1]) instanceof Rn && (r = n[e + 1]) instanceof Rn && n.splice(e - 1, 3, new Rn(t.length + 1 + r.length));
}
const Ej = 5;
class j3 {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let r = Math.min(t, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof Wr ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new Wr(r - this.pos, -1)), this.writtenTo = r, t > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, r) {
    if (e < t || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, s = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = t - e;
      r.block ? this.addBlock(new hA(o, i, r)) : (o || s || i >= Ej) && this.addLineDeco(i, s, o);
    } else t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Wr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let r = new Rn(t - e);
    return this.oracle.doc.lineAt(e).to == t && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Wr)
      return e;
    let t = new Wr(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += t, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof Wr) && !this.isCovered ? this.nodes.push(new Wr(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes)
      i instanceof Wr && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, r, i) {
    let s = new j3(r, e);
    return ht.spans(t, r, i, s, 0), s.finish(r);
  }
}
function Ij(n, e, t) {
  let r = new Dj();
  return ht.compare(n, e, t, r, 0), r.changes;
}
class Dj {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, r, i) {
    (e < t || r && r.heightRelevant || i && i.heightRelevant) && dp(e, t, this.changes, 5);
  }
}
function Nj(n, e) {
  let t = n.getBoundingClientRect(), r = n.ownerDocument, i = r.defaultView || window, s = Math.max(0, t.left), o = Math.min(i.innerWidth, t.right), l = Math.max(0, t.top), a = Math.min(i.innerHeight, t.bottom);
  for (let c = n.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let u = c, h = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
        let f = u.getBoundingClientRect();
        s = Math.max(s, f.left), o = Math.min(o, f.right), l = Math.max(l, f.top), a = Math.min(c == n.parentNode ? i.innerHeight : a, f.bottom);
      }
      c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: l - (t.top + e),
    bottom: Math.max(l, a) - (t.top + e)
  };
}
function Rj(n) {
  let e = n.getBoundingClientRect(), t = n.ownerDocument.defaultView || window;
  return e.left < t.innerWidth && e.right > 0 && e.top < t.innerHeight && e.bottom > 0;
}
function Pj(n, e) {
  let t = n.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class p2 {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.size = r, this.displaySize = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r], s = t[r];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return He.replace({
      widget: new _j(this.displaySize * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class _j extends xo {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class Cx {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = Mx, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Wt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(V3).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new Tj(t), this.stateDeco = e.facet(zf).filter((r) => typeof r != "function"), this.heightMap = hr.empty().applyChanges(this.stateDeco, dt.empty, this.heightOracle.setDoc(e.doc), [new yi(0, 0, 0, e.doc.length)]);
    for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = He.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? t.head : t.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new i0(s, o));
      }
    }
    return this.viewports = e.sort((r, i) => r.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? Mx : new U3(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(fh(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(zf).filter((u) => typeof u != "function");
    let i = e.changedRanges, s = yi.extendWithRanges(i, Ij(r, this.stateDeco, e ? e.changes : wn.empty(this.state.doc.length))), o = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    kx(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), (this.heightMap.height != o || Fc) && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = o);
    let a = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < a.from || t.range.head > a.to) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, t));
    let c = a.from != this.viewport.from || a.to != this.viewport.to;
    this.viewport = a, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(UT) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, r = window.getComputedStyle(t), i = this.heightOracle, s = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? Wt.RTL : Wt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), l = t.getBoundingClientRect(), a = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (l.width && l.height) {
      let { scaleX: C, scaleY: M } = vT(t, l);
      (C > 5e-3 && Math.abs(this.scaleX - C) > 5e-3 || M > 5e-3 && Math.abs(this.scaleY - M) > 5e-3) && (this.scaleX = C, this.scaleY = M, c |= 16, o = a = !0);
    }
    let h = (parseInt(r.paddingTop) || 0) * this.scaleY, f = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != f) && (this.paddingTop = h, this.paddingBottom = f, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (a = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
    let d = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != d && (this.scrollAnchorHeight = -1, this.scrollTop = d), this.scrolledToBottom = kT(e.scrollDOM);
    let p = (this.printing ? Pj : Nj)(t, this.paddingTop), m = p.top - this.pixelViewport.top, g = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let b = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (b != this.inView && (this.inView = b, b && (a = !0)), !this.inView && !this.scrollTarget && !Rj(e.dom))
      return 0;
    let w = l.width;
    if ((this.contentDOMWidth != w || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), a) {
      let C = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(C) && (o = !0), o || i.lineWrapping && Math.abs(w - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: M, charWidth: T, textHeight: N } = e.docView.measureTextSize();
        o = M > 0 && i.refresh(s, M, T, N, Math.max(5, w / T), C), o && (e.docView.minWidth = 0, c |= 16);
      }
      m > 0 && g > 0 ? u = Math.max(m, g) : m < 0 && g < 0 && (u = Math.min(m, g)), kx();
      for (let M of this.viewports) {
        let T = M.from == this.viewport.from ? C : e.docView.measureVisibleLineHeights(M);
        this.heightMap = (o ? hr.empty().applyChanges(this.stateDeco, dt.empty, this.heightOracle, [new yi(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new Aj(M.from, T));
      }
      Fc && (c |= 2);
    }
    let k = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return k && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || k) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: l } = this, a = new i0(i.lineAt(o - r * 1e3, qt.ByHeight, s, 0, 0).from, i.lineAt(l + (1 - r) * 1e3, qt.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < a.from || c > a.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, qt.ByPos, s, 0, 0), f;
        t.y == "center" ? f = (h.top + h.bottom) / 2 - u / 2 : t.y == "start" || t.y == "nearest" && c < a.from ? f = h.top : f = h.bottom - u, a = new i0(i.lineAt(f - 1e3 / 2, qt.ByHeight, s, 0, 0).from, i.lineAt(f + u + 1e3 / 2, qt.ByHeight, s, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, t) {
    let r = t.mapPos(e.from, -1), i = t.mapPos(e.to, 1);
    return new i0(this.heightMap.lineAt(r, qt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, qt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, qt.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, qt.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || i <= o - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || s >= l + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && i > o - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let r = [];
    for (let i of e)
      t.touchesRange(i.from, i.to) || r.push(new p2(t.mapPos(i.from), t.mapPos(i.to), i.size, i.displaySize));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != Wt.LTR && !r)
      return [];
    let l = [], a = (u, h, f, d) => {
      if (h - u < s)
        return;
      let p = this.state.selection.main, m = [p.from];
      p.empty || m.push(p.to);
      for (let b of m)
        if (b > u && b < h) {
          a(u, b - 10, f, d), a(b + 10, h, f, d);
          return;
        }
      let g = Bj(e, (b) => b.from >= f.from && b.to <= f.to && Math.abs(b.from - u) < s && Math.abs(b.to - h) < s && !m.some((w) => b.from < w && b.to > w));
      if (!g) {
        if (h < f.to && t && r && t.visibleRanges.some((k) => k.from <= h && k.to >= h)) {
          let k = t.moveToLineBoundary(G.cursor(h), !1, !0).head;
          k > u && (h = k);
        }
        let b = this.gapSize(f, u, h, d), w = r || b < 2e6 ? b : 2e6;
        g = new p2(u, h, b, w);
      }
      l.push(g);
    }, c = (u) => {
      if (u.length < o || u.type != ur.Text)
        return;
      let h = Lj(u.from, u.to, this.stateDeco);
      if (h.total < o)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, d, p;
      if (r) {
        let m = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, b;
        if (f != null) {
          let w = o0(h, f), k = ((this.visibleBottom - this.visibleTop) / 2 + m) / u.height;
          g = w - k, b = w + k;
        } else
          g = (this.visibleTop - u.top - m) / u.height, b = (this.visibleBottom - u.top + m) / u.height;
        d = s0(h, g), p = s0(h, b);
      } else {
        let m = h.total * this.heightOracle.charWidth, g = i * this.heightOracle.charWidth, b = 0;
        if (m > 2e6)
          for (let T of e)
            T.from >= u.from && T.from < u.to && T.size != T.displaySize && T.from * this.heightOracle.charWidth + b < this.pixelViewport.left && (b = T.size - T.displaySize);
        let w = this.pixelViewport.left + b, k = this.pixelViewport.right + b, C, M;
        if (f != null) {
          let T = o0(h, f), N = ((k - w) / 2 + g) / m;
          C = T - N, M = T + N;
        } else
          C = (w - g) / m, M = (k + g) / m;
        d = s0(h, C), p = s0(h, M);
      }
      d > u.from && a(u.from, d, u, h), p < u.to && a(p, u.to, u, h);
    };
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(c) : c(u);
    return l;
  }
  gapSize(e, t, r, i) {
    let s = o0(i, r) - o0(i, t);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    p2.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = He.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let r = [];
    ht.spans(t, this.viewport.from, this.viewport.to, {
      span(s, o) {
        r.push({ from: s, to: o });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (r.length != this.visibleRanges.length)
      i = 12;
    else
      for (let s = 0; s < r.length && !(i & 8); s++) {
        let o = this.visibleRanges[s], l = r[s];
        (o.from != l.from || o.to != l.to) && (i |= 4, e && e.mapPos(o.from, -1) == l.from && e.mapPos(o.to, 1) == l.to || (i |= 8));
      }
    return this.visibleRanges = r, i;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || fh(this.heightMap.lineAt(e, qt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t) => t.top <= e && t.bottom >= e) || fh(this.heightMap.lineAt(this.scaler.fromDOM(e), qt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return fh(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class i0 {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function Lj(n, e, t) {
  let r = [], i = n, s = 0;
  return ht.spans(t, n, e, {
    span() {
    },
    point(o, l) {
      o > i && (r.push({ from: i, to: o }), s += o - i), i = l;
    }
  }, 20), i < e && (r.push({ from: i, to: e }), s += e - i), { total: s, ranges: r };
}
function s0({ total: n, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(n * t);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i], l = o - s;
    if (r <= l)
      return s + r;
    r -= l;
  }
}
function o0(n, e) {
  let t = 0;
  for (let { from: r, to: i } of n.ranges) {
    if (e <= i) {
      t += e - r;
      break;
    }
    t += i - r;
  }
  return t / n.total;
}
function Bj(n, e) {
  for (let t of n)
    if (e(t))
      return t;
}
const Mx = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
class U3 {
  constructor(e, t, r) {
    let i = 0, s = 0, o = 0;
    this.viewports = r.map(({ from: l, to: a }) => {
      let c = t.lineAt(l, qt.ByPos, e, 0, 0).top, u = t.lineAt(a, qt.ByPos, e, 0, 0).bottom;
      return i += u - c, { from: l, to: a, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (t.height - i);
    for (let l of this.viewports)
      l.domTop = o + (l.top - s) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return i + (e - r) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      r = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return r + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      r = s.bottom, i = s.domBottom;
    }
  }
  eq(e) {
    return e instanceof U3 ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((t, r) => t.from == e.viewports[r].from && t.to == e.viewports[r].to) : !1;
  }
}
function fh(n, e) {
  if (e.scale == 1)
    return n;
  let t = e.toDOM(n.top), r = e.toDOM(n.bottom);
  return new as(n.from, n.length, t, r - t, Array.isArray(n._content) ? n._content.map((i) => fh(i, e)) : n._content);
}
const l0 = /* @__PURE__ */ ke.define({ combine: (n) => n.join(" ") }), Ly = /* @__PURE__ */ ke.define({ combine: (n) => n.indexOf(!0) > -1 }), By = /* @__PURE__ */ hl.newName(), fA = /* @__PURE__ */ hl.newName(), dA = /* @__PURE__ */ hl.newName(), pA = { "&light": "." + fA, "&dark": "." + dA };
function zy(n, e, t) {
  return new hl(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return n;
        if (!t || !t[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return t[i];
      }) : n + " " + r;
    }
  });
}
const zj = /* @__PURE__ */ zy("." + By, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, pA), Fj = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, m2 = xe.ie && xe.ie_version <= 11;
class Hj {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new xW(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let r of t)
        this.queue.push(r);
      (xe.ie && xe.ie_version <= 11 || xe.ios && e.composing) && t.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && xe.android && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(xe.chrome && xe.chrome_version < 126) && (this.editContext = new Vj(e), e.state.facet(Ys) && (e.contentDOM.editContext = this.editContext.editContext)), m2 && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, r) => t != e[r]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(Ys) ? r.root.activeElement != this.dom : !fp(this.dom, i))
      return;
    let s = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (xe.ie && xe.ie_version <= 11 || xe.android && xe.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Qh(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = Lf(e.root);
    if (!t)
      return !1;
    let r = xe.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && $j(this.view, t) || t;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let i = fp(this.dom, r);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && SW(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = t)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, Fj), m2 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), m2 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && vc(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, r = -1, i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (i = !0), t == -1 ? { from: t, to: r } = o : (t = Math.min(o.from, t), r = Math.max(o.to, r)));
    }
    return { from: t, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: t, typeOver: r } = this.processRecords(), i = this.selectionChanged && fp(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new ij(this.view, e, t, r);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = nA(this.view, t);
    return this.view.state == r && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let r = Tx(t, e.previousSibling || e.target.previousSibling, -1), i = Tx(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? t.posAfter(r) : t.posAtStart,
        to: i ? t.posBefore(i) : t.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Ys) != e.state.facet(Ys) && (e.view.contentDOM.editContext = e.state.facet(Ys) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, t, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function Tx(n, e, t) {
  for (; e; ) {
    let r = Dt.get(e);
    if (r && r.parent == n)
      return r;
    let i = e.parentNode;
    e = i != n.dom ? i : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function Ax(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.docView.domAtPos(n.state.selection.main.anchor);
  return Qh(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s };
}
function $j(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return Ax(n, i);
  }
  let t = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.contentDOM.addEventListener("beforeinput", r, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", r, !0), t ? Ax(n, t) : null;
}
class Vj {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let t = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (r) => {
      let i = e.state.selection.main, { anchor: s, head: o } = i, l = this.toEditorPos(r.updateRangeStart), a = this.toEditorPos(r.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: r.updateRangeStart, editorBase: l, drifted: !1 });
      let c = { from: l, to: a, insert: dt.of(r.text.split(`
`)) };
      if (c.from == this.from && s < this.from ? c.from = s : c.to == this.to && s > this.to && (c.to = s), c.from == c.to && !c.insert.length) {
        let u = G.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
        u.main.eq(i) || e.dispatch({ selection: u, userEvent: "select" });
        return;
      }
      if ((xe.mac || xe.android) && c.from == o - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (c = { from: l, to: a, insert: dt.of([r.text.replace(".", " ")]) }), this.pendingContextChange = c, !e.state.readOnly) {
        let u = this.to - this.from + (c.to - c.from + c.insert.length);
        W3(e, c, G.single(this.toEditorPos(r.selectionStart, u), this.toEditorPos(r.selectionEnd, u)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
    }, this.handlers.characterboundsupdate = (r) => {
      let i = [], s = null;
      for (let o = this.toEditorPos(r.rangeStart), l = this.toEditorPos(r.rangeEnd); o < l; o++) {
        let a = e.coordsForChar(o);
        s = a && new DOMRect(a.left, a.top, a.right - a.left, a.bottom - a.top) || s || new DOMRect(), i.push(s);
      }
      t.updateCharacterBounds(r.rangeStart, i);
    }, this.handlers.textformatupdate = (r) => {
      let i = [];
      for (let s of r.getTextFormats()) {
        let o = s.underlineStyle, l = s.underlineThickness;
        if (o != "None" && l != "None") {
          let a = this.toEditorPos(s.rangeStart), c = this.toEditorPos(s.rangeEnd);
          if (a < c) {
            let u = `text-decoration: underline ${o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${l == "Thin" ? 1 : 2}px`;
            i.push(He.mark({ attributes: { style: u } }).range(a, c));
          }
        }
      }
      e.dispatch({ effects: GT.of(He.set(i)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: r } = this.composing;
        this.composing = null, r && this.reset(e.state);
      }
    };
    for (let r in this.handlers)
      t.addEventListener(r, this.handlers[r]);
    this.measureReq = { read: (r) => {
      this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
      let i = Lf(r.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let t = 0, r = !1, i = this.pendingContextChange;
    return e.changes.iterChanges((s, o, l, a, c) => {
      if (r)
        return;
      let u = c.length - (o - s);
      if (i && o >= i.to)
        if (i.from == s && i.to == o && i.insert.eq(c)) {
          i = this.pendingContextChange = null, t += u, this.to += u;
          return;
        } else
          i = null, this.revertPending(e.state);
      if (s += t, o += t, o <= this.from)
        this.from += u, this.to += u;
      else if (s < this.to) {
        if (s < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
          r = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(s), this.toContextPos(o), c.toString()), this.to += u;
      }
      t += u;
    }), i && !r && this.revertPending(e.state), !r;
  }
  update(e) {
    let t = this.pendingContextChange, r = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || t) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: t } = e.selection.main;
    this.from = Math.max(
      0,
      t - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      t + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let t = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.from + t.insert.length), e.doc.sliceString(t.from, t.to));
  }
  setSelection(e) {
    let { main: t } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))), i = this.toContextPos(t.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
  }
  rangeIsValid(e) {
    let { head: t } = e.selection.main;
    return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, t = this.to - this.from) {
    e = Math.min(e, t);
    let r = this.composing;
    return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let t = this.composing;
    return t && t.drifted ? t.contextBase + (e - t.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class we {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var t;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((s) => r(s, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || kW(e.parent) || document, this.viewState = new Cx(e.state || ct.create(e)), e.scrollTo && e.scrollTo.is(t0) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(fc).map((i) => new h2(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new Hj(this), this.inputState = new cj(this), this.inputState.ensureHandlers(this.plugins), this.docView = new sx(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((t = document.fonts) === null || t === void 0) && t.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof mn ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, r = !1, i, s = this.state;
    for (let f of e) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, l = 0, a = null;
    e.some((f) => f.annotation(aA)) ? (this.inputState.notifiedFocused = o, l = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, a = cA(s, o), a || (l = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(ct.phrases) != this.state.facet(ct.phrases))
      return this.setState(s);
    i = pm.create(this, s, e), i.flags |= l;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (h && (h = h.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          h = new wc(d.empty ? d : G.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(t0) && (h = d.value.clip(this.state));
      }
      this.viewState.update(i, h), this.bidiCache = gm.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), t = this.docView.update(i), this.state.facet(uh) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(l0) != i.state.facet(l0) && (this.viewState.mustMeasureContent = !0), (t || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), t && this.docViewUpdate(), !i.empty)
      for (let f of this.state.facet(Ny))
        try {
          f(i);
        } catch (d) {
          Ar(this.state, d, "update listener");
        }
    (a || u) && Promise.resolve().then(() => {
      a && this.state == a.startState && this.dispatch(a), u && !nA(this, u) && c.force && vc(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new Cx(e), this.plugins = e.facet(fc).map((r) => new h2(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new sx(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(fc), r = e.state.facet(fc);
    if (t != r) {
      let i = [];
      for (let s of r) {
        let o = t.indexOf(s);
        if (o < 0)
          i.push(new h2(s));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, i.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    t != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let t = e.value;
      if (t && t.docViewUpdate)
        try {
          t.docViewUpdate(this);
        } catch (r) {
          Ar(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (kT(r))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(i);
            s = d.from, o = d.top;
          }
        this.updateState = 1;
        let a = this.viewState.measure(this);
        if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        a & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return Ar(this.state, p), Ox;
          }
        }), h = pm.create(this, this.state, []), f = !1;
        h.flags |= a, t ? t.flags |= a : t = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), f = this.docView.update(h), f && this.docViewUpdate());
        for (let d = 0; d < c.length; d++)
          if (u[d] != Ox)
            try {
              let p = c[d];
              p.write && p.write(u[d], this);
            } catch (p) {
              Ar(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                i = i + p, r.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let l of this.state.facet(Ny))
        l(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return By + " " + (this.state.facet(Ly) ? dA : fA) + " " + this.state.facet(l0);
  }
  updateAttrs() {
    let e = Ex(this, YT, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Ys) ? "true" : "false",
      class: "cm-content",
      style: `${xe.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), Ex(this, V3, t);
    let r = this.observer.ignore(() => {
      let i = Ay(this.contentDOM, this.contentAttrs, t), s = Ay(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, r;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(we.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(uh);
    let e = this.state.facet(we.cspNonce);
    hl.mount(this.root, this.styleModules.concat(zj).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.plugin != e) && this.pluginMap.set(e, t = this.plugins.find((r) => r.plugin == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, r) {
    return d2(this, e, ux(this, e, t, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return d2(this, e, ux(this, e, t, (r) => ej(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = r[t ? r.length - 1 : 0];
    return G.cursor(s.side(t, i) + e.from, s.forward(!t, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, r = !0) {
    return QW(this, e, t, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, r) {
    return d2(this, e, tj(this, e, t, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), eA(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, t);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[Zo.find(s, e - i.from, -1, t)];
    return b1(r, o.dir == Wt.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(jT) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > qj)
      return BT(e.length);
    let t = this.textDirectionAt(e.from), r;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t && (s.fresh || LT(s.isolates, r = ix(this, e))))
        return s.order;
    r || (r = ix(this, e));
    let i = BW(e.text, t, r);
    return this.bidiCache.push(new gm(e.from, e.to, t, r, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || xe.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      wT(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return t0.of(new wc(typeof e == "number" ? G.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return t0.of(new wc(G.cursor(r.from), "start", "start", r.top - e, t, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return gn.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return gn.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let r = hl.newName(), i = [l0.of(r), uh.of(zy(`.${r}`, e))];
    return t && t.dark && i.push(Ly.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Tl.lowest(uh.of(zy("." + By, e, pA)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let r = e.querySelector(".cm-content"), i = r && Dt.get(r) || Dt.get(e);
    return ((t = i?.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
we.styleModule = uh;
we.inputHandler = qT;
we.clipboardInputFilter = H3;
we.clipboardOutputFilter = $3;
we.scrollHandler = KT;
we.focusChangeEffect = WT;
we.perLineTextDirection = jT;
we.exceptionSink = VT;
we.updateListener = Ny;
we.editable = Ys;
we.mouseSelectionStyle = $T;
we.dragMovesSelection = HT;
we.clickAddsSelectionRange = FT;
we.decorations = zf;
we.outerDecorations = JT;
we.atomicRanges = w1;
we.bidiIsolatedRanges = XT;
we.scrollMargins = ZT;
we.darkTheme = Ly;
we.cspNonce = /* @__PURE__ */ ke.define({ combine: (n) => n.length ? n[0] : "" });
we.contentAttributes = V3;
we.editorAttributes = YT;
we.lineWrapping = /* @__PURE__ */ we.contentAttributes.of({ class: "cm-lineWrapping" });
we.announce = /* @__PURE__ */ Xe.define();
const qj = 4096, Ox = {};
class gm {
  constructor(e, t, r, i, s, o) {
    this.from = e, this.to = t, this.dir = r, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh))
      return e;
    let r = [], i = e.length ? e[e.length - 1].dir : Wt.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i && !t.touchesRange(o.from, o.to) && r.push(new gm(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function Ex(n, e, t) {
  for (let r = n.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let s = r[i], o = typeof s == "function" ? s(n) : s;
    o && Ty(o, t);
  }
  return t;
}
const Wj = xe.mac ? "mac" : xe.windows ? "win" : xe.linux ? "linux" : "key";
function jj(n, e) {
  const t = n.split(/-(?!$)/);
  let r = t[t.length - 1];
  r == "Space" && (r = " ");
  let i, s, o, l;
  for (let a = 0; a < t.length - 1; ++a) {
    const c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      l = !0;
    else if (/^a(lt)?$/i.test(c))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? l = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (r = "Alt-" + r), s && (r = "Ctrl-" + r), l && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function a0(n, e, t) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t !== !1 && e.shiftKey && (n = "Shift-" + n), n;
}
const Uj = /* @__PURE__ */ Tl.default(/* @__PURE__ */ we.domEventHandlers({
  keydown(n, e) {
    return gA(mA(e.state), n, e, "editor");
  }
})), nu = /* @__PURE__ */ ke.define({ enables: Uj }), Ix = /* @__PURE__ */ new WeakMap();
function mA(n) {
  let e = n.facet(nu), t = Ix.get(e);
  return t || Ix.set(e, t = Yj(e.reduce((r, i) => r.concat(i), []))), t;
}
function Kj(n, e, t) {
  return gA(mA(n.state), e, n, t);
}
let jo = null;
const Gj = 4e3;
function Yj(n, e = Wj) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (o, l) => {
    let a = r[o];
    if (a == null)
      r[o] = l;
    else if (a != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, l, a, c, u) => {
    var h, f;
    let d = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), p = l.split(/ (?!$)/).map((b) => jj(b, e));
    for (let b = 1; b < p.length; b++) {
      let w = p.slice(0, b).join(" ");
      i(w, !0), d[w] || (d[w] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(k) => {
          let C = jo = { view: k, prefix: w, scope: o };
          return setTimeout(() => {
            jo == C && (jo = null);
          }, Gj), !0;
        }]
      });
    }
    let m = p.join(" ");
    i(m, !1);
    let g = d[m] || (d[m] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (h = d._any) === null || h === void 0 ? void 0 : h.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    a && g.run.push(a), c && (g.preventDefault = !0), u && (g.stopPropagation = !0);
  };
  for (let o of n) {
    let l = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of l) {
        let u = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: h } = o;
        for (let f in u)
          u[f].run.push((d) => h(d, Fy));
      }
    let a = o[e] || o.key;
    if (a)
      for (let c of l)
        s(c, a, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + a, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
let Fy = null;
function gA(n, e, t, r) {
  Fy = e;
  let i = LC(e), s = Sr(i, 0), o = ls(s) == i.length && i != " ", l = "", a = !1, c = !1, u = !1;
  jo && jo.view == t && jo.scope == r && (l = jo.prefix + " ", iA.indexOf(e.keyCode) < 0 && (c = !0, jo = null));
  let h = /* @__PURE__ */ new Set(), f = (g) => {
    if (g) {
      for (let b of g.run)
        if (!h.has(b) && (h.add(b), b(t)))
          return g.stopPropagation && (u = !0), !0;
      g.preventDefault && (g.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, d = n[r], p, m;
  return d && (f(d[l + a0(i, e, !o)]) ? a = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(xe.windows && e.ctrlKey && e.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(xe.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (p = oo[e.keyCode]) && p != i ? (f(d[l + a0(p, e, !0)]) || e.shiftKey && (m = kf[e.keyCode]) != i && m != p && f(d[l + a0(m, e, !1)])) && (a = !0) : o && e.shiftKey && f(d[l + a0(i, e, !0)]) && (a = !0), !a && f(d._any) && (a = !0)), c && (a = !0), a && u && e.stopPropagation(), Fy = null, a;
}
class pd {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, r, i, s) {
    this.className = e, this.left = t, this.top = r, this.width = i, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let s = yA(e);
      return [new pd(t, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return Jj(e, t, r);
  }
}
function yA(n) {
  let e = n.scrollDOM.getBoundingClientRect();
  return { left: (n.textDirection == Wt.LTR ? e.left : e.right - n.scrollDOM.clientWidth * n.scaleX) - n.scrollDOM.scrollLeft * n.scaleX, top: e.top - n.scrollDOM.scrollTop * n.scaleY };
}
function Dx(n, e, t, r) {
  let i = n.coordsAtPos(e, t * 2);
  if (!i)
    return r;
  let s = n.dom.getBoundingClientRect(), o = (i.top + i.bottom) / 2, l = n.posAtCoords({ x: s.left + 1, y: o }), a = n.posAtCoords({ x: s.right - 1, y: o });
  return l == null || a == null ? r : { from: Math.max(r.from, Math.min(l, a)), to: Math.min(r.to, Math.max(l, a)) };
}
function Jj(n, e, t) {
  if (t.to <= n.viewport.from || t.from >= n.viewport.to)
    return [];
  let r = Math.max(t.from, n.viewport.from), i = Math.min(t.to, n.viewport.to), s = n.textDirection == Wt.LTR, o = n.contentDOM, l = o.getBoundingClientRect(), a = yA(n), c = o.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = l.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), f = l.right - (u ? parseInt(u.paddingRight) : 0), d = Py(n, r, 1), p = Py(n, i, -1), m = d.type == ur.Text ? d : null, g = p.type == ur.Text ? p : null;
  if (m && (n.lineWrapping || d.widgetLineBreaks) && (m = Dx(n, r, 1, m)), g && (n.lineWrapping || p.widgetLineBreaks) && (g = Dx(n, i, -1, g)), m && g && m.from == g.from && m.to == g.to)
    return w(k(t.from, t.to, m));
  {
    let M = m ? k(t.from, null, m) : C(d, !1), T = g ? k(null, t.to, g) : C(p, !0), N = [];
    return (m || d).to < (g || p).from - (m && g ? 1 : 0) || d.widgetLineBreaks > 1 && M.bottom + n.defaultLineHeight / 2 < T.top ? N.push(b(h, M.bottom, f, T.top)) : M.bottom < T.top && n.elementAtHeight((M.bottom + T.top) / 2).type == ur.Text && (M.bottom = T.top = (M.bottom + T.top) / 2), w(M).concat(N).concat(w(T));
  }
  function b(M, T, N, B) {
    return new pd(e, M - a.left, T - a.top, N - M, B - T);
  }
  function w({ top: M, bottom: T, horizontal: N }) {
    let B = [];
    for (let $ = 0; $ < N.length; $ += 2)
      B.push(b(N[$], M, N[$ + 1], T));
    return B;
  }
  function k(M, T, N) {
    let B = 1e9, $ = -1e9, R = [];
    function V(ie, he, Ce, ye, be) {
      let ze = n.coordsAtPos(ie, ie == N.to ? -2 : 2), I = n.coordsAtPos(Ce, Ce == N.from ? 2 : -2);
      !ze || !I || (B = Math.min(ze.top, I.top, B), $ = Math.max(ze.bottom, I.bottom, $), be == Wt.LTR ? R.push(s && he ? h : ze.left, s && ye ? f : I.right) : R.push(!s && ye ? h : I.left, !s && he ? f : ze.right));
    }
    let z = M ?? N.from, ue = T ?? N.to;
    for (let ie of n.visibleRanges)
      if (ie.to > z && ie.from < ue)
        for (let he = Math.max(ie.from, z), Ce = Math.min(ie.to, ue); ; ) {
          let ye = n.state.doc.lineAt(he);
          for (let be of n.bidiSpans(ye)) {
            let ze = be.from + ye.from, I = be.to + ye.from;
            if (ze >= Ce)
              break;
            I > he && V(Math.max(ze, he), M == null && ze <= z, Math.min(I, Ce), T == null && I >= ue, be.dir);
          }
          if (he = ye.to + 1, he >= Ce)
            break;
        }
    return R.length == 0 && V(z, M == null, ue, T == null, n.textDirection), { top: B, bottom: $, horizontal: R };
  }
  function C(M, T) {
    let N = l.top + (T ? M.top : M.bottom);
    return { top: N, bottom: N, horizontal: [] };
  }
}
function Xj(n, e) {
  return n.constructor == e.constructor && n.eq(e);
}
class Zj {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(gp) != e.state.facet(gp) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, r = e.facet(gp);
    for (; t < r.length && r[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, r) => !Xj(t, this.drawn[r]))) {
      let t = this.dom.firstChild, r = 0;
      for (let i of e)
        i.update && t && i.constructor && this.drawn[r].constructor && i.update(t, this.drawn[r]) ? (t = t.nextSibling, r++) : this.dom.insertBefore(i.draw(), t);
      for (; t; ) {
        let i = t.nextSibling;
        t.remove(), t = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const gp = /* @__PURE__ */ ke.define();
function bA(n) {
  return [
    gn.define((e) => new Zj(e, n)),
    gp.of(n)
  ];
}
const Ff = /* @__PURE__ */ ke.define({
  combine(n) {
    return Ms(n, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function vA(n = {}) {
  return [
    Ff.of(n),
    Qj,
    eU,
    tU,
    UT.of(!0)
  ];
}
function wA(n) {
  return n.startState.facet(Ff) != n.state.facet(Ff);
}
const Qj = /* @__PURE__ */ bA({
  above: !0,
  markers(n) {
    let { state: e } = n, t = e.facet(Ff), r = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty || t.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = i.empty ? i : G.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let a of pd.forRange(n, o, l))
          r.push(a);
      }
    }
    return r;
  },
  update(n, e) {
    n.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = wA(n);
    return t && Nx(n.state, e), n.docChanged || n.selectionSet || t;
  },
  mount(n, e) {
    Nx(e.state, n);
  },
  class: "cm-cursorLayer"
});
function Nx(n, e) {
  e.style.animationDuration = n.facet(Ff).cursorBlinkRate + "ms";
}
const eU = /* @__PURE__ */ bA({
  above: !1,
  markers(n) {
    return n.state.selection.ranges.map((e) => e.empty ? [] : pd.forRange(n, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(n, e) {
    return n.docChanged || n.selectionSet || n.viewportChanged || wA(n);
  },
  class: "cm-selectionLayer"
}), tU = /* @__PURE__ */ Tl.highest(/* @__PURE__ */ we.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), xA = /* @__PURE__ */ Xe.define({
  map(n, e) {
    return n == null ? null : e.mapPos(n);
  }
}), dh = /* @__PURE__ */ On.define({
  create() {
    return null;
  },
  update(n, e) {
    return n != null && (n = e.changes.mapPos(n)), e.effects.reduce((t, r) => r.is(xA) ? r.value : t, n);
  }
}), nU = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var e;
    let t = n.state.field(dh);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(dh) != t || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, e = n.state.field(dh), t = e != null && n.coordsAtPos(e);
    if (!t)
      return null;
    let r = n.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - r.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: t.top - r.top + n.scrollDOM.scrollTop * n.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      n ? (this.cursor.style.left = n.left / e + "px", this.cursor.style.top = n.top / t + "px", this.cursor.style.height = n.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(dh) != n && this.view.dispatch({ effects: xA.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function rU() {
  return [dh, nU];
}
function Rx(n, e, t, r, i) {
  e.lastIndex = 0;
  for (let s = n.iterRange(t, r), o = t, l; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; l = e.exec(s.value); )
        i(o + l.index, l);
}
function iU(n, e) {
  let t = n.visibleRanges;
  if (t.length == 1 && t[0].from == n.viewport.from && t[0].to == n.viewport.to)
    return t;
  let r = [];
  for (let { from: i, to: s } of t)
    i = Math.max(n.state.doc.lineAt(i).from, i - e), s = Math.min(n.state.doc.lineAt(s).to, s + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = s : r.push({ from: i, to: s });
  return r;
}
class sU {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: r, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, i)
      this.addMatch = (l, a, c, u) => i(u, c, c + l[0].length, l, a);
    else if (typeof r == "function")
      this.addMatch = (l, a, c, u) => {
        let h = r(l, a, c);
        h && u(c, c + l[0].length, h);
      };
    else if (r)
      this.addMatch = (l, a, c, u) => u(c, c + l[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new ao(), r = t.add.bind(t);
    for (let { from: i, to: s } of iU(e, this.maxLength))
      Rx(e.state.doc, this.regexp, i, s, (o, l) => this.addMatch(l, e, o, r));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let r = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, o, l, a) => {
      a >= e.view.viewport.from && l <= e.view.viewport.to && (r = Math.min(l, r), i = Math.max(a, i));
    }), e.viewportMoved || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, t.map(e.changes), r, i) : t;
  }
  updateRange(e, t, r, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, r), l = Math.min(s.to, i);
      if (l >= o) {
        let a = e.state.doc.lineAt(o), c = a.to < l ? e.state.doc.lineAt(l) : a, u = Math.max(s.from, a.from), h = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > a.from; o--)
            if (this.boundary.test(a.text[o - 1 - a.from])) {
              u = o;
              break;
            }
          for (; l < c.to; l++)
            if (this.boundary.test(c.text[l - c.from])) {
              h = l;
              break;
            }
        }
        let f = [], d, p = (m, g, b) => f.push(b.range(m, g));
        if (a == c)
          for (this.regexp.lastIndex = u - a.from; (d = this.regexp.exec(a.text)) && d.index < h - a.from; )
            this.addMatch(d, e, d.index + a.from, p);
        else
          Rx(e.state.doc, this.regexp, u, h, (m, g) => this.addMatch(g, e, m, p));
        t = t.update({ filterFrom: u, filterTo: h, filter: (m, g) => m < u || g > h, add: f });
      }
    }
    return t;
  }
}
const Hy = /x/.unicode != null ? "gu" : "g", oU = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, Hy), lU = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let g2 = null;
function aU() {
  var n;
  if (g2 == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    g2 = ((n = e.tabSize) !== null && n !== void 0 ? n : e.MozTabSize) != null;
  }
  return g2 || !1;
}
const yp = /* @__PURE__ */ ke.define({
  combine(n) {
    let e = Ms(n, {
      render: null,
      specialChars: oU,
      addSpecialChars: null
    });
    return (e.replaceTabs = !aU()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Hy)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Hy)), e;
  }
});
function cU(n = {}) {
  return [yp.of(n), uU()];
}
let Px = null;
function uU() {
  return Px || (Px = gn.fromClass(class {
    constructor(n) {
      this.view = n, this.decorations = He.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(n.state.facet(yp)), this.decorations = this.decorator.createDeco(n);
    }
    makeDecorator(n) {
      return new sU({
        regexp: n.specialChars,
        decoration: (e, t, r) => {
          let { doc: i } = t.state, s = Sr(e[0], 0);
          if (s == 9) {
            let o = i.lineAt(r), l = t.state.tabSize, a = tu(o.text, l, r - o.from);
            return He.replace({
              widget: new pU((l - a % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = He.replace({ widget: new dU(n, s) }));
        },
        boundary: n.replaceTabs ? void 0 : /[^]/
      });
    }
    update(n) {
      let e = n.state.facet(yp);
      n.startState.facet(yp) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(n.view)) : this.decorations = this.decorator.updateDeco(n, this.decorations);
    }
  }, {
    decorations: (n) => n.decorations
  }));
}
const hU = "•";
function fU(n) {
  return n >= 32 ? hU : n == 10 ? "␤" : String.fromCharCode(9216 + n);
}
class dU extends xo {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = fU(this.code), r = e.state.phrase("Control character") + " " + (lU[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, t);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = t, s.title = r, s.setAttribute("aria-label", r), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class pU extends xo {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function mU() {
  return yU;
}
const gU = /* @__PURE__ */ He.line({ class: "cm-activeLine" }), yU = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.docChanged || n.selectionSet) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = -1, t = [];
    for (let r of n.state.selection.ranges) {
      let i = n.lineBlockAt(r.head);
      i.from > e && (t.push(gU.range(i.from)), e = i.from);
    }
    return He.set(t);
  }
}, {
  decorations: (n) => n.decorations
}), $y = 2e3;
function bU(n, e, t) {
  let r = Math.min(e.line, t.line), i = Math.max(e.line, t.line), s = [];
  if (e.off > $y || t.off > $y || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), l = Math.max(e.off, t.off);
    for (let a = r; a <= i; a++) {
      let c = n.doc.line(a);
      c.length <= l && s.push(G.range(c.from + o, c.to + l));
    }
  } else {
    let o = Math.min(e.col, t.col), l = Math.max(e.col, t.col);
    for (let a = r; a <= i; a++) {
      let c = n.doc.line(a), u = vy(c.text, o, n.tabSize, !0);
      if (u < 0)
        s.push(G.cursor(c.to));
      else {
        let h = vy(c.text, l, n.tabSize);
        s.push(G.range(c.from + u, c.from + h));
      }
    }
  }
  return s;
}
function vU(n, e) {
  let t = n.coordsAtPos(n.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / n.defaultCharacterWidth)) : -1;
}
function _x(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = n.state.doc.lineAt(t), i = t - r.from, s = i > $y ? -1 : i == r.length ? vU(n, e.clientX) : tu(r.text, n.state.tabSize, t - r.from);
  return { line: r.number, col: s, off: i };
}
function wU(n, e) {
  let t = _x(n, e), r = n.state.selection;
  return t ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(t.line).from), o = i.state.doc.lineAt(s);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, r = r.map(i.changes);
      }
    },
    get(i, s, o) {
      let l = _x(n, i);
      if (!l)
        return r;
      let a = bU(n.state, t, l);
      return a.length ? o ? G.create(a.concat(r.ranges)) : G.create(a) : r;
    }
  } : null;
}
function xU(n) {
  let e = ((t) => t.altKey && t.button == 0);
  return we.mouseSelectionStyle.of((t, r) => e(r) ? wU(t, r) : null);
}
const kU = {
  Alt: [18, (n) => !!n.altKey],
  Control: [17, (n) => !!n.ctrlKey],
  Shift: [16, (n) => !!n.shiftKey],
  Meta: [91, (n) => !!n.metaKey]
}, SU = { style: "cursor: crosshair" };
function CU(n = {}) {
  let [e, t] = kU[n.key || "Alt"], r = gn.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || t(i));
      },
      keyup(i) {
        (i.keyCode == e || !t(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(t(i));
      }
    }
  });
  return [
    r,
    we.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(r)) === null || s === void 0) && s.isDown ? SU : null;
    })
  ];
}
const Bu = "-10000px";
class kA {
  constructor(e, t, r, i) {
    this.facet = t, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = r(o, s));
  }
  update(e, t) {
    var r;
    let i = e.state.facet(this.facet), s = i.filter((a) => a);
    if (i === this.input) {
      for (let a of this.tooltipViews)
        a.update && a.update(e);
      return !1;
    }
    let o = [], l = t ? [] : null;
    for (let a = 0; a < s.length; a++) {
      let c = s[a], u = -1;
      if (c) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let f = this.tooltips[h];
          f && f.create == c.create && (u = h);
        }
        if (u < 0)
          o[a] = this.createTooltipView(c, a ? o[a - 1] : null), l && (l[a] = !!c.above);
        else {
          let h = o[a] = this.tooltipViews[u];
          l && (l[a] = t[u]), h.update && h.update(e);
        }
      }
    }
    for (let a of this.tooltipViews)
      o.indexOf(a) < 0 && (this.removeTooltipView(a), (r = a.destroy) === null || r === void 0 || r.call(a));
    return t && (l.forEach((a, c) => t[c] = a), t.length = l.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function MU(n) {
  let e = n.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const y2 = /* @__PURE__ */ ke.define({
  combine: (n) => {
    var e, t, r;
    return {
      position: xe.ios ? "absolute" : ((e = n.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = n.find((i) => i.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((r = n.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || MU
    };
  }
}), Lx = /* @__PURE__ */ new WeakMap(), K3 = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = n.state.facet(y2);
    this.position = e.position, this.parent = e.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new kA(n, G3, (t, r) => this.createTooltip(t, r), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(n, this.above);
    e && this.observeIntersection();
    let t = e || n.geometryChanged, r = n.state.facet(y2);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      t = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      t = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(n, e) {
    let t = n.create(this.view), r = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), n.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", t.dom.appendChild(i);
    }
    return t.dom.style.position = this.position, t.dom.style.top = Bu, t.dom.style.left = "0px", this.container.insertBefore(t.dom, r), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var n, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (n = r.destroy) === null || n === void 0 || n.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = 1, e = 1, t = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: s } = this.manager.tooltipViews[0];
      if (xe.gecko)
        t = s.offsetParent != this.container.ownerDocument.body;
      else if (s.style.top == Bu && s.style.left == "0px") {
        let o = s.getBoundingClientRect();
        t = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (t || this.position == "absolute")
      if (this.parent) {
        let s = this.parent.getBoundingClientRect();
        s.width && s.height && (n = s.width / this.parent.offsetWidth, e = s.height / this.parent.offsetHeight);
      } else
        ({ scaleX: n, scaleY: e } = this.view.viewState);
    let r = this.view.scrollDOM.getBoundingClientRect(), i = q3(this.view);
    return {
      visible: {
        left: r.left + i.left,
        top: r.top + i.top,
        right: r.right - i.right,
        bottom: r.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((s, o) => {
        let l = this.manager.tooltipViews[o];
        return l.getCoords ? l.getCoords(s.pos) : this.view.coordsAtPos(s.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: s }) => s.getBoundingClientRect()),
      space: this.view.state.facet(y2).tooltipSpace(this.view),
      scaleX: n,
      scaleY: e,
      makeAbsolute: t
    };
  }
  writeMeasure(n) {
    var e;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { visible: t, space: r, scaleX: i, scaleY: s } = n, o = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let a = this.manager.tooltips[l], c = this.manager.tooltipViews[l], { dom: u } = c, h = n.pos[l], f = n.size[l];
      if (!h || a.clip !== !1 && (h.bottom <= Math.max(t.top, r.top) || h.top >= Math.min(t.bottom, r.bottom) || h.right < Math.max(t.left, r.left) - 0.1 || h.left > Math.min(t.right, r.right) + 0.1)) {
        u.style.top = Bu;
        continue;
      }
      let d = a.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = d ? 7 : 0, m = f.right - f.left, g = (e = Lx.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top, b = c.offset || AU, w = this.view.textDirection == Wt.LTR, k = f.width > r.right - r.left ? w ? r.left : r.right - f.width : w ? Math.max(r.left, Math.min(h.left - (d ? 14 : 0) + b.x, r.right - m)) : Math.min(Math.max(r.left, h.left - m + (d ? 14 : 0) - b.x), r.right - m), C = this.above[l];
      !a.strictSide && (C ? h.top - g - p - b.y < r.top : h.bottom + g + p + b.y > r.bottom) && C == r.bottom - h.bottom > h.top - r.top && (C = this.above[l] = !C);
      let M = (C ? h.top - r.top : r.bottom - h.bottom) - p;
      if (M < g && c.resize !== !1) {
        if (M < this.view.defaultLineHeight) {
          u.style.top = Bu;
          continue;
        }
        Lx.set(c, g), u.style.height = (g = M) / s + "px";
      } else u.style.height && (u.style.height = "");
      let T = C ? h.top - g - p - b.y : h.bottom + p + b.y, N = k + m;
      if (c.overlap !== !0)
        for (let B of o)
          B.left < N && B.right > k && B.top < T + g && B.bottom > T && (T = C ? B.top - g - 2 - p : B.bottom + p + 2);
      if (this.position == "absolute" ? (u.style.top = (T - n.parent.top) / s + "px", Bx(u, (k - n.parent.left) / i)) : (u.style.top = T / s + "px", Bx(u, k / i)), d) {
        let B = h.left + (w ? b.x : -b.x) - (k + 14 - 7);
        d.style.left = B / i + "px";
      }
      c.overlap !== !0 && o.push({ left: k, top: T, right: N, bottom: T + g }), u.classList.toggle("cm-tooltip-above", C), u.classList.toggle("cm-tooltip-below", !C), c.positioned && c.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = Bu;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function Bx(n, e) {
  let t = parseInt(n.style.left, 10);
  (isNaN(t) || Math.abs(e - t) > 1) && (n.style.left = e + "px");
}
const TU = /* @__PURE__ */ we.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), AU = { x: 0, y: 0 }, G3 = /* @__PURE__ */ ke.define({
  enables: [K3, TU]
}), ym = /* @__PURE__ */ ke.define({
  combine: (n) => n.reduce((e, t) => e.concat(t), [])
});
class k1 {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new k1(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new kA(e, ym, (t, r) => this.createHostedView(t, r), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (t === void 0)
          t = i;
        else if (t !== i)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const OU = /* @__PURE__ */ G3.compute([ym], (n) => {
  let e = n.facet(ym);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var r;
      return (r = t.end) !== null && r !== void 0 ? r : t.pos;
    })),
    create: k1.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class EU {
  constructor(e, t, r, i, s) {
    this.view = e, this.source = t, this.field = r, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, r = e.docView.nearest(t.target);
    if (!r)
      return;
    let i, s = 1;
    if (r instanceof Xo)
      i = r.posAtStart;
    else {
      if (i = e.posAtCoords(t), i == null)
        return;
      let l = e.coordsAtPos(i);
      if (!l || t.y < l.top || t.y > l.bottom || t.x < l.left - e.defaultCharacterWidth || t.x > l.right + e.defaultCharacterWidth)
        return;
      let a = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), c = a && a.dir == Wt.RTL ? -1 : 1;
      s = t.x < l.left ? -c : c;
    }
    let o = this.source(e, i, s);
    if (o?.then) {
      let l = this.pending = { pos: i };
      o.then((a) => {
        this.pending == l && (this.pending = null, a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) }));
      }, (a) => Ar(e.state, a, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(K3), t = e ? e.manager.tooltips.findIndex((r) => r.create == k1.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: s } = this;
    if (i.length && s && !IU(s.dom, e) || this.pending) {
      let { pos: o } = i[0] || this.pending, l = (r = (t = i[0]) === null || t === void 0 ? void 0 : t.end) !== null && r !== void 0 ? r : o;
      (o == l ? this.view.posAtCoords(this.lastMove) != o : !DU(this.view, o, l, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (r) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const c0 = 4;
function IU(n, e) {
  let { left: t, right: r, top: i, bottom: s } = n.getBoundingClientRect(), o;
  if (o = n.querySelector(".cm-tooltip-arrow")) {
    let l = o.getBoundingClientRect();
    i = Math.min(l.top, i), s = Math.max(l.bottom, s);
  }
  return e.clientX >= t - c0 && e.clientX <= r + c0 && e.clientY >= i - c0 && e.clientY <= s + c0;
}
function DU(n, e, t, r, i, s) {
  let o = n.scrollDOM.getBoundingClientRect(), l = n.documentTop + n.documentPadding.top + n.contentHeight;
  if (o.left > r || o.right < r || o.top > i || Math.min(o.bottom, l) < i)
    return !1;
  let a = n.posAtCoords({ x: r, y: i }, !1);
  return a >= e && a <= t;
}
function NU(n, e = {}) {
  let t = Xe.define(), r = On.define({
    create() {
      return [];
    },
    update(i, s) {
      if (i.length && (e.hideOnChange && (s.docChanged || s.selection) ? i = [] : e.hideOn && (i = i.filter((o) => !e.hideOn(s, o))), s.docChanged)) {
        let o = [];
        for (let l of i) {
          let a = s.changes.mapPos(l.pos, -1, Bn.TrackDel);
          if (a != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), l);
            c.pos = a, c.end != null && (c.end = s.changes.mapPos(c.end)), o.push(c);
          }
        }
        i = o;
      }
      for (let o of s.effects)
        o.is(t) && (i = o.value), o.is(RU) && (i = []);
      return i;
    },
    provide: (i) => ym.from(i)
  });
  return {
    active: r,
    extension: [
      r,
      gn.define((i) => new EU(
        i,
        n,
        r,
        t,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      OU
    ]
  };
}
function SA(n, e) {
  let t = n.plugin(K3);
  if (!t)
    return null;
  let r = t.manager.tooltips.indexOf(e);
  return r < 0 ? null : t.manager.tooltipViews[r];
}
const RU = /* @__PURE__ */ Xe.define(), zx = /* @__PURE__ */ ke.define({
  combine(n) {
    let e, t;
    for (let r of n)
      e = e || r.topContainer, t = t || r.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Hf(n, e) {
  let t = n.plugin(CA), r = t ? t.specs.indexOf(e) : -1;
  return r > -1 ? t.panels[r] : null;
}
const CA = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.input = n.state.facet($f), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(n));
    let e = n.state.facet(zx);
    this.top = new u0(n, !0, e.topContainer), this.bottom = new u0(n, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(n) {
    let e = n.state.facet(zx);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new u0(n.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new u0(n.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = n.state.facet($f);
    if (t != this.input) {
      let r = t.filter((a) => a), i = [], s = [], o = [], l = [];
      for (let a of r) {
        let c = this.specs.indexOf(a), u;
        c < 0 ? (u = a(n.view), l.push(u)) : (u = this.panels[c], u.update && u.update(n)), i.push(u), (u.top ? s : o).push(u);
      }
      this.specs = r, this.panels = i, this.top.sync(s), this.bottom.sync(o);
      for (let a of l)
        a.dom.classList.add("cm-panel"), a.mount && a.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(n);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (n) => we.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class u0 {
  constructor(e, t, r) {
    this.view = e, this.top = t, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = Fx(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = Fx(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function Fx(n) {
  let e = n.nextSibling;
  return n.remove(), e;
}
const $f = /* @__PURE__ */ ke.define({
  enables: CA
});
class uo extends Sa {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
uo.prototype.elementClass = "";
uo.prototype.toDOM = void 0;
uo.prototype.mapMode = Bn.TrackBefore;
uo.prototype.startSide = uo.prototype.endSide = -1;
uo.prototype.point = !0;
const bp = /* @__PURE__ */ ke.define(), PU = /* @__PURE__ */ ke.define(), _U = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => ht.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {},
  side: "before"
}, tf = /* @__PURE__ */ ke.define();
function LU(n) {
  return [MA(), tf.of({ ..._U, ...n })];
}
const Hx = /* @__PURE__ */ ke.define({
  combine: (n) => n.some((e) => e)
});
function MA(n) {
  return [
    BU
  ];
}
const BU = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.domAfter = null, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = n.state.facet(tf).map((e) => new Vx(n, e)), this.fixed = !n.state.facet(Hx);
    for (let e of this.gutters)
      e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
    this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  getDOMAfter() {
    return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
  }
  update(n) {
    if (this.updateGutters(n)) {
      let e = this.prevViewport, t = n.view.viewport, r = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(r < (t.to - t.from) * 0.8);
    }
    if (n.geometryChanged) {
      let e = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
    }
    this.view.state.facet(Hx) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let e = this.dom.nextSibling;
    n && (this.dom.remove(), this.domAfter && this.domAfter.remove());
    let t = ht.iter(this.view.state.facet(bp), this.view.viewport.from), r = [], i = this.gutters.map((s) => new zU(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(s.type)) {
        let o = !0;
        for (let l of s.type)
          if (l.type == ur.Text && o) {
            Vy(t, r, l.from);
            for (let a of i)
              a.line(this.view, l, r);
            o = !1;
          } else if (l.widget)
            for (let a of i)
              a.widget(this.view, l);
      } else if (s.type == ur.Text) {
        Vy(t, r, s.from);
        for (let o of i)
          o.line(this.view, s, r);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    n && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
  }
  updateGutters(n) {
    let e = n.startState.facet(tf), t = n.state.facet(tf), r = n.docChanged || n.heightChanged || n.viewportChanged || !ht.eq(n.startState.facet(bp), n.state.facet(bp), n.view.viewport.from, n.view.viewport.to);
    if (e == t)
      for (let i of this.gutters)
        i.update(n) && (r = !0);
    else {
      r = !0;
      let i = [];
      for (let s of t) {
        let o = e.indexOf(s);
        o < 0 ? i.push(new Vx(this.view, s)) : (this.gutters[o].update(n), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        s.config.side == "after" ? this.getDOMAfter().appendChild(s.dom) : this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove(), this.domAfter && this.domAfter.remove();
  }
}, {
  provide: (n) => we.scrollMargins.of((e) => {
    let t = e.plugin(n);
    if (!t || t.gutters.length == 0 || !t.fixed)
      return null;
    let r = t.dom.offsetWidth * e.scaleX, i = t.domAfter ? t.domAfter.offsetWidth * e.scaleX : 0;
    return e.textDirection == Wt.LTR ? { left: r, right: i } : { right: r, left: i };
  })
});
function $x(n) {
  return Array.isArray(n) ? n : [n];
}
function Vy(n, e, t) {
  for (; n.value && n.from <= t; )
    n.from == t && e.push(n.value), n.next();
}
class zU {
  constructor(e, t, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = ht.iter(e.markers, t.from);
  }
  addElement(e, t, r) {
    let { gutter: i } = this, s = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == i.elements.length) {
      let l = new TA(e, o, s, r);
      i.elements.push(l), i.dom.appendChild(l.dom);
    } else
      i.elements[this.i].update(e, o, s, r);
    this.height = t.bottom, this.i++;
  }
  line(e, t, r) {
    let i = [];
    Vy(this.cursor, i, t.from), r.length && (i = i.concat(r));
    let s = this.gutter.config.lineMarker(e, t, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, i);
  }
  widget(e, t) {
    let r = this.gutter.config.widgetMarker(e, t.widget, t), i = r ? [r] : null;
    for (let s of e.state.facet(PU)) {
      let o = s(e, t.widget, t);
      o && (i || (i = [])).push(o);
    }
    i && this.addElement(e, t, i);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class Vx {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in t.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let a = s.getBoundingClientRect();
          o = (a.top + a.bottom) / 2;
        } else
          o = i.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[r](e, l, i) && i.preventDefault();
      });
    this.markers = $x(t.markers(e)), t.initialSpacer && (this.spacer = new TA(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = $x(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !ht.eq(this.markers, t, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class TA {
  constructor(e, t, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, r, i);
  }
  update(e, t, r, i) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), FU(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, t) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o, a = s < t.length ? t[s++] : null, c = !1;
      if (a) {
        let u = a.elementClass;
        u && (r += " " + u);
        for (let h = o; h < this.markers.length; h++)
          if (this.markers[h].compare(a)) {
            l = h, c = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(i);
          let h = i.nextSibling;
          i.remove(), i = h;
        }
      }
      if (!a)
        break;
      a.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(a.toDOM(e), i)), c && o++;
    }
    this.dom.className = r, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function FU(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].compare(e[t]))
      return !1;
  return !0;
}
const HU = /* @__PURE__ */ ke.define(), $U = /* @__PURE__ */ ke.define(), dc = /* @__PURE__ */ ke.define({
  combine(n) {
    return Ms(n, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let r = Object.assign({}, e);
        for (let i in t) {
          let s = r[i], o = t[i];
          r[i] = s ? (l, a, c) => s(l, a, c) || o(l, a, c) : o;
        }
        return r;
      }
    });
  }
});
class b2 extends uo {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function v2(n, e) {
  return n.state.facet(dc).formatNumber(e, n.state);
}
const VU = /* @__PURE__ */ tf.compute([dc], (n) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(HU);
  },
  lineMarker(e, t, r) {
    return r.some((i) => i.toDOM) ? null : new b2(v2(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: (e, t, r) => {
    for (let i of e.state.facet($U)) {
      let s = i(e, t, r);
      if (s)
        return s;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(dc) != e.state.facet(dc),
  initialSpacer(e) {
    return new b2(v2(e, qx(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let r = v2(t.view, qx(t.view.state.doc.lines));
    return r == e.number ? e : new b2(r);
  },
  domEventHandlers: n.facet(dc).domEventHandlers,
  side: "before"
}));
function qU(n = {}) {
  return [
    dc.of(n),
    MA(),
    VU
  ];
}
function qx(n) {
  let e = 9;
  for (; e < n; )
    e = e * 10 + 9;
  return e;
}
const WU = /* @__PURE__ */ new class extends uo {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), jU = /* @__PURE__ */ bp.compute(["selection"], (n) => {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.head).from;
    i > t && (t = i, e.push(WU.range(i)));
  }
  return ht.of(e);
});
function UU() {
  return jU;
}
let KU = 0;
class oi {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.set = t, this.base = r, this.modified = i, this.id = KU++;
  }
  toString() {
    let { name: e } = this;
    for (let t of this.modified)
      t.name && (e = `${t.name}(${e})`);
    return e;
  }
  static define(e, t) {
    let r = typeof e == "string" ? e : "?";
    if (e instanceof oi && (t = e), t?.base)
      throw new Error("Can not derive from a modified tag");
    let i = new oi(r, [], null, []);
    if (i.set.push(i), t)
      for (let s of t.set)
        i.set.push(s);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let t = new bm(e);
    return (r) => r.modified.indexOf(t) > -1 ? r : bm.get(r.base || r, r.modified.concat(t).sort((i, s) => i.id - s.id));
  }
}
let GU = 0;
class bm {
  constructor(e) {
    this.name = e, this.instances = [], this.id = GU++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let r = t[0].instances.find((l) => l.base == e && YU(t, l.modified));
    if (r)
      return r;
    let i = [], s = new oi(e.name, i, e, t);
    for (let l of t)
      l.instances.push(s);
    let o = JU(t);
    for (let l of e.set)
      if (!l.modified.length)
        for (let a of o)
          i.push(bm.get(l, a));
    return s;
  }
}
function YU(n, e) {
  return n.length == e.length && n.every((t, r) => t == e[r]);
}
function JU(n) {
  let e = [[]];
  for (let t = 0; t < n.length; t++)
    for (let r = 0, i = e.length; r < i; r++)
      e.push(e[r].concat(n[t]));
  return e.sort((t, r) => r.length - t.length);
}
function XU(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    Array.isArray(r) || (r = [r]);
    for (let i of t.split(" "))
      if (i) {
        let s = [], o = 2, l = i;
        for (let h = 0; ; ) {
          if (l == "..." && h > 0 && h + 3 == i.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), h += f[0].length, h == i.length)
            break;
          let d = i[h++];
          if (h == i.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + i);
          l = i.slice(h);
        }
        let a = s.length - 1, c = s[a];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let u = new vm(r, o, a > 0 ? s.slice(0, a) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return AA.add(e);
}
const AA = new st();
class vm {
  constructor(e, t, r, i) {
    this.tags = e, this.mode = t, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
vm.empty = new vm([], 2, null);
function OA(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let s of n)
    if (!Array.isArray(s.tag))
      t[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        t[o.id] = s.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let l of s)
        for (let a of l.set) {
          let c = t[a.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function ZU(n, e) {
  let t = null;
  for (let r of n) {
    let i = r.style(e);
    i && (t = t ? t + " " + i : i);
  }
  return t;
}
function QU(n, e, t, r = 0, i = n.length) {
  let s = new eK(r, Array.isArray(e) ? e : [e], t);
  s.highlightRange(n.cursor(), r, i, "", s.highlighters), s.flush(i);
}
class eK {
  constructor(e, t, r) {
    this.at = e, this.highlighters = t, this.span = r, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, r, i, s) {
    let { type: o, from: l, to: a } = e;
    if (l >= r || a <= t)
      return;
    o.isTop && (s = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let c = i, u = tK(e) || vm.empty, h = ZU(s, u.tags);
    if (h && (c && (c += " "), c += h, u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(t, l), c), u.opaque)
      return;
    let f = e.tree && e.tree.prop(st.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + l, 1), p = this.highlighters.filter((g) => !g.scope || g.scope(f.tree.type)), m = e.firstChild();
      for (let g = 0, b = l; ; g++) {
        let w = g < f.overlay.length ? f.overlay[g] : null, k = w ? w.from + l : a, C = Math.max(t, b), M = Math.min(r, k);
        if (C < M && m)
          for (; e.from < M && (this.highlightRange(e, C, M, i, s), this.startSpan(Math.min(M, e.to), c), !(e.to >= k || !e.nextSibling())); )
            ;
        if (!w || k > r)
          break;
        b = w.to + l, b > t && (this.highlightRange(d.cursor(), Math.max(t, w.from + l), Math.min(r, b), "", p), this.startSpan(Math.min(r, b), c));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      f && (i = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, t, r, i, s), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function tK(n) {
  let e = n.type.prop(AA);
  for (; e && e.context && !n.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const ge = oi.define, h0 = ge(), zo = ge(), Wx = ge(zo), jx = ge(zo), Fo = ge(), f0 = ge(Fo), w2 = ge(Fo), Qi = ge(), Rl = ge(Qi), Yi = ge(), Ji = ge(), qy = ge(), zu = ge(qy), d0 = ge(), U = {
  /**
  A comment.
  */
  comment: h0,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: ge(h0),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: ge(h0),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: ge(h0),
  /**
  Any kind of identifier.
  */
  name: zo,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: ge(zo),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: Wx,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: ge(Wx),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: jx,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: ge(jx),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: ge(zo),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: ge(zo),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: ge(zo),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: ge(zo),
  /**
  A literal value.
  */
  literal: Fo,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: f0,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: ge(f0),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: ge(f0),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: ge(f0),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: w2,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: ge(w2),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: ge(w2),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: ge(Fo),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: ge(Fo),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: ge(Fo),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: ge(Fo),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: ge(Fo),
  /**
  A language keyword.
  */
  keyword: Yi,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: ge(Yi),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: ge(Yi),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: ge(Yi),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: ge(Yi),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: ge(Yi),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: ge(Yi),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: ge(Yi),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: ge(Yi),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: ge(Yi),
  /**
  An operator.
  */
  operator: Ji,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: ge(Ji),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: ge(Ji),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: ge(Ji),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: ge(Ji),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: ge(Ji),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: ge(Ji),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: ge(Ji),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: ge(Ji),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: ge(Ji),
  /**
  Program or markup punctuation.
  */
  punctuation: qy,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: ge(qy),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: zu,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: ge(zu),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: ge(zu),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: ge(zu),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: ge(zu),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Qi,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Rl,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: ge(Rl),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: ge(Rl),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: ge(Rl),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: ge(Rl),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: ge(Rl),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: ge(Rl),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: ge(Qi),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: ge(Qi),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: ge(Qi),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: ge(Qi),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: ge(Qi),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: ge(Qi),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: ge(Qi),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: ge(Qi),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: ge(),
  /**
  Deleted text.
  */
  deleted: ge(),
  /**
  Changed text.
  */
  changed: ge(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: ge(),
  /**
  Metadata or meta-instruction.
  */
  meta: d0,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: ge(d0),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: ge(d0),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: ge(d0),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: oi.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: oi.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: oi.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: oi.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: oi.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: oi.defineModifier("special")
};
for (let n in U) {
  let e = U[n];
  e instanceof oi && (e.name = n);
}
OA([
  { tag: U.link, class: "tok-link" },
  { tag: U.heading, class: "tok-heading" },
  { tag: U.emphasis, class: "tok-emphasis" },
  { tag: U.strong, class: "tok-strong" },
  { tag: U.keyword, class: "tok-keyword" },
  { tag: U.atom, class: "tok-atom" },
  { tag: U.bool, class: "tok-bool" },
  { tag: U.url, class: "tok-url" },
  { tag: U.labelName, class: "tok-labelName" },
  { tag: U.inserted, class: "tok-inserted" },
  { tag: U.deleted, class: "tok-deleted" },
  { tag: U.literal, class: "tok-literal" },
  { tag: U.string, class: "tok-string" },
  { tag: U.number, class: "tok-number" },
  { tag: [U.regexp, U.escape, U.special(U.string)], class: "tok-string2" },
  { tag: U.variableName, class: "tok-variableName" },
  { tag: U.local(U.variableName), class: "tok-variableName tok-local" },
  { tag: U.definition(U.variableName), class: "tok-variableName tok-definition" },
  { tag: U.special(U.variableName), class: "tok-variableName2" },
  { tag: U.definition(U.propertyName), class: "tok-propertyName tok-definition" },
  { tag: U.typeName, class: "tok-typeName" },
  { tag: U.namespace, class: "tok-namespace" },
  { tag: U.className, class: "tok-className" },
  { tag: U.macroName, class: "tok-macroName" },
  { tag: U.propertyName, class: "tok-propertyName" },
  { tag: U.operator, class: "tok-operator" },
  { tag: U.comment, class: "tok-comment" },
  { tag: U.meta, class: "tok-meta" },
  { tag: U.invalid, class: "tok-invalid" },
  { tag: U.punctuation, class: "tok-punctuation" }
]);
var x2;
const ta = /* @__PURE__ */ new st();
function EA(n) {
  return ke.define({
    combine: n ? (e) => e.concat(n) : void 0
  });
}
const nK = /* @__PURE__ */ new st();
class ci {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], i = "") {
    this.data = e, this.name = i, ct.prototype.hasOwnProperty("tree") || Object.defineProperty(ct.prototype, "tree", { get() {
      return Fn(this);
    } }), this.parser = t, this.extension = [
      dl.of(this),
      ct.languageData.of((s, o, l) => {
        let a = Ux(s, o, l), c = a.type.prop(ta);
        if (!c)
          return [];
        let u = s.facet(c), h = a.type.prop(nK);
        if (h) {
          let f = a.resolve(o - a.from, l);
          for (let d of h)
            if (d.test(f, s)) {
              let p = s.facet(d.facet);
              return d.type == "replace" ? p : p.concat(u);
            }
        }
        return u;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return Ux(e, t, r).type.prop(ta) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(dl);
    if (t?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], i = (s, o) => {
      if (s.prop(ta) == this.data) {
        r.push({ from: o, to: o + s.length });
        return;
      }
      let l = s.prop(st.mounted);
      if (l) {
        if (l.tree.prop(ta) == this.data) {
          if (l.overlay)
            for (let a of l.overlay)
              r.push({ from: a.from + o, to: a.to + o });
          else
            r.push({ from: o, to: o + s.length });
          return;
        } else if (l.overlay) {
          let a = r.length;
          if (i(l.tree, l.overlay[0].from + o), r.length > a)
            return;
        }
      }
      for (let a = 0; a < s.children.length; a++) {
        let c = s.children[a];
        c instanceof zt && i(c, s.positions[a] + o);
      }
    };
    return i(Fn(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
ci.setState = /* @__PURE__ */ Xe.define();
function Ux(n, e, t) {
  let r = n.facet(dl), i = Fn(n).topNode;
  if (!r || r.allowsNesting)
    for (let s = i; s; s = s.enter(e, t, Zt.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
class Wy extends ci {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = EA(e.languageData);
    return new Wy(t, e.parser.configure({
      props: [ta.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new Wy(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Fn(n) {
  let e = n.field(ci.state, !1);
  return e ? e.tree : zt.empty;
}
class rK {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let Fu = null;
class Hc {
  constructor(e, t, r = [], i, s, o, l, a) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = l, this.scheduleOn = a, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Hc(e, t, [], zt.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new rK(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != zt.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(no.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(no.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = Fu;
    Fu = this;
    try {
      return e();
    } finally {
      Fu = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = Kx(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let a = [];
      if (e.iterChangedRanges((c, u, h, f) => a.push({ fromA: c, toA: u, fromB: h, toB: f })), r = no.applyChanges(r, a), i = zt.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
          u < h && l.push({ from: u, to: h });
        }
      }
    }
    return new Hc(this.parser, t, r, i, s, o, l, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: s } = this.skipped[r];
      i < e.to && s > e.from && (this.fragments = Kx(this.fragments, i, s), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends ZM {
      createParse(t, r, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let a = Fu;
            if (a) {
              for (let c of i)
                a.tempSkipped.push(c);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new zt(gr.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Fu;
  }
}
function Kx(n, e, t) {
  return no.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class $c {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new $c(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = Hc.create(e.facet(dl).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new $c(r);
  }
}
ci.state = /* @__PURE__ */ On.define({
  create: $c.init,
  update(n, e) {
    for (let t of e.effects)
      if (t.is(ci.setState))
        return t.value;
    return e.startState.facet(dl) != e.state.facet(dl) ? $c.init(e.state) : n.apply(e);
  }
});
let IA = (n) => {
  let e = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (IA = (n) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const k2 = typeof navigator < "u" && (!((x2 = navigator.scheduling) === null || x2 === void 0) && x2.isInputPending) ? () => navigator.scheduling.isInputPending() : null, iK = /* @__PURE__ */ gn.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(ci.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(ci.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = IA(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, s = r.field(ci.state);
    if (s.tree == s.context.tree && s.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !k2 ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = s.context.treeLen < i && r.doc.length > i + 1e3, a = s.context.work(() => k2 && k2() || Date.now() > o, i + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (a || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: ci.setState.of(new $c(s.context)) })), this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Ar(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), dl = /* @__PURE__ */ ke.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    ci.state,
    iK,
    we.contentAttributes.compute([n], (e) => {
      let t = e.facet(n);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class sK {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
class q {
  constructor(e, t, r, i, s, o = void 0) {
    this.name = e, this.alias = t, this.extensions = r, this.filename = i, this.loadFunc = s, this.support = o, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: t, support: r } = e;
    if (!t) {
      if (!r)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      t = () => Promise.resolve(r);
    }
    return new q(e.name, (e.alias || []).concat(e.name).map((i) => i.toLowerCase()), e.extensions || [], e.filename, t, r);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, t) {
    for (let i of e)
      if (i.filename && i.filename.test(t))
        return i;
    let r = /\.([^.]+)$/.exec(t);
    if (r) {
      for (let i of e)
        if (i.extensions.indexOf(r[1]) > -1)
          return i;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, t, r = !0) {
    t = t.toLowerCase();
    for (let i of e)
      if (i.alias.some((s) => s == t))
        return i;
    if (r)
      for (let i of e)
        for (let s of i.alias) {
          let o = t.indexOf(s);
          if (o > -1 && (s.length > 2 || !/\w/.test(t[o - 1]) && !/\w/.test(t[o + s.length])))
            return i;
        }
    return null;
  }
}
const oK = /* @__PURE__ */ ke.define(), S1 = /* @__PURE__ */ ke.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let e = n[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return e;
  }
});
function Aa(n) {
  let e = n.facet(S1);
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
}
function Vf(n, e) {
  let t = "", r = n.tabSize, i = n.facet(S1)[0];
  if (i == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    t += i;
  return t;
}
function Y3(n, e) {
  n instanceof ct && (n = new C1(n));
  for (let r of n.state.facet(oK)) {
    let i = r(n, e);
    if (i !== void 0)
      return i;
  }
  let t = Fn(n.state);
  return t.length >= e ? lK(n, t, e) : null;
}
class C1 {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Aa(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= r.from && i <= r.to ? s && i == e ? { text: "", from: e } : (t < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, t);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), s = this.countColumn(r, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return tu(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const DA = /* @__PURE__ */ new st();
function lK(n, e, t) {
  let r = e.resolveStack(t), i = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
  if (i != r.node) {
    let s = [];
    for (let o = i; o && !(o.from < r.node.from || o.to > r.node.to || o.from == r.node.from && o.type == r.node.type); o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      r = { node: s[o], next: r };
  }
  return NA(r, n, t);
}
function NA(n, e, t) {
  for (let r = n; r; r = r.next) {
    let i = cK(r.node);
    if (i)
      return i(J3.create(e, t, r));
  }
  return 0;
}
function aK(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function cK(n) {
  let e = n.type.prop(DA);
  if (e)
    return e;
  let t = n.firstChild, r;
  if (t && (r = t.type.prop(st.closedBy))) {
    let i = n.lastChild, s = i && r.indexOf(i.name) > -1;
    return (o) => RA(o, !0, 1, void 0, s && !aK(o) ? i.from : void 0);
  }
  return n.parent == null ? uK : null;
}
function uK() {
  return 0;
}
class J3 extends C1 {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new J3(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (hK(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return NA(this.context.next, this.base, this.pos);
  }
}
function hK(n, e) {
  for (let t = e; t; t = t.parent)
    if (n == t)
      return !0;
  return !1;
}
function fK(n) {
  let e = n.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let i = n.options.simulateBreak, s = n.state.doc.lineAt(t.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let l = t.to; ; ) {
    let a = e.childAfter(l);
    if (!a || a == r)
      return null;
    if (!a.type.isSkipped) {
      if (a.from >= o)
        return null;
      let c = /^ */.exec(s.text.slice(t.to - s.from))[0].length;
      return { from: t.from, to: t.to + c };
    }
    l = a.to;
  }
}
function Uue({ closing: n, align: e = !0, units: t = 1 }) {
  return (r) => RA(r, e, t, n);
}
function RA(n, e, t, r, i) {
  let s = n.textAfter, o = s.match(/^\s*/)[0].length, l = r && s.slice(o, o + r.length) == r || i == n.pos + o, a = e ? fK(n) : null;
  return a ? l ? n.column(a.from) : n.column(a.to) : n.baseIndent + (l ? 0 : n.unit * t);
}
const Kue = (n) => n.baseIndent;
function Gue({ except: n, units: e = 1 } = {}) {
  return (t) => {
    let r = n && n.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const dK = 200;
function pK() {
  return ct.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let e = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!e.length)
      return n;
    let t = n.newDoc, { head: r } = n.newSelection.main, i = t.lineAt(r);
    if (r > i.from + dK)
      return n;
    let s = t.sliceString(i.from, r);
    if (!e.some((c) => c.test(s)))
      return n;
    let { state: o } = n, l = -1, a = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == l)
        continue;
      l = u.from;
      let h = Y3(o, u.from);
      if (h == null)
        continue;
      let f = /^\s*/.exec(u.text)[0], d = Vf(o, h);
      f != d && a.push({ from: u.from, to: u.from + f.length, insert: d });
    }
    return a.length ? [n, { changes: a, sequential: !0 }] : n;
  });
}
const mK = /* @__PURE__ */ ke.define(), gK = /* @__PURE__ */ new st();
function Yue(n) {
  let e = n.firstChild, t = n.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? n.to : t.from } : null;
}
function yK(n, e, t) {
  let r = Fn(n);
  if (r.length < t)
    return null;
  let i = r.resolveStack(t, 1), s = null;
  for (let o = i; o; o = o.next) {
    let l = o.node;
    if (l.to <= t || l.from > t)
      continue;
    if (s && l.from < e)
      break;
    let a = l.type.prop(gK);
    if (a && (l.to < r.length - 50 || r.length == n.doc.length || !bK(l))) {
      let c = a(l, n);
      c && c.from <= t && c.from >= e && c.to > t && (s = c);
    }
  }
  return s;
}
function bK(n) {
  let e = n.lastChild;
  return e && e.to == n.to && e.type.isError;
}
function wm(n, e, t) {
  for (let r of n.facet(mK)) {
    let i = r(n, e, t);
    if (i)
      return i;
  }
  return yK(n, e, t);
}
function PA(n, e) {
  let t = e.mapPos(n.from, 1), r = e.mapPos(n.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const M1 = /* @__PURE__ */ Xe.define({ map: PA }), md = /* @__PURE__ */ Xe.define({ map: PA });
function _A(n) {
  let e = [];
  for (let { head: t } of n.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(n.lineBlockAt(t));
  return e;
}
const Oa = /* @__PURE__ */ On.define({
  create() {
    return He.none;
  },
  update(n, e) {
    e.isUserEvent("delete") && e.changes.iterChangedRanges((t, r) => n = Gx(n, t, r)), n = n.map(e.changes);
    for (let t of e.effects)
      if (t.is(M1) && !vK(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(zA), i = r ? He.replace({ widget: new TK(r(e.state, t.value)) }) : Yx;
        n = n.update({ add: [i.range(t.value.from, t.value.to)] });
      } else t.is(md) && (n = n.update({
        filter: (r, i) => t.value.from != r || t.value.to != i,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    return e.selection && (n = Gx(n, e.selection.main.head)), n;
  },
  provide: (n) => we.decorations.from(n),
  toJSON(n, e) {
    let t = [];
    return n.between(0, e.doc.length, (r, i) => {
      t.push(r, i);
    }), t;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < n.length; ) {
      let r = n[t++], i = n[t++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Yx.range(r, i));
    }
    return He.set(e, !0);
  }
});
function Gx(n, e, t = e) {
  let r = !1;
  return n.between(e, t, (i, s) => {
    i < t && s > e && (r = !0);
  }), r ? n.update({
    filterFrom: e,
    filterTo: t,
    filter: (i, s) => i >= t || s <= e
  }) : n;
}
function xm(n, e, t) {
  var r;
  let i = null;
  return (r = n.field(Oa, !1)) === null || r === void 0 || r.between(e, t, (s, o) => {
    (!i || i.from > s) && (i = { from: s, to: o });
  }), i;
}
function vK(n, e, t) {
  let r = !1;
  return n.between(e, e, (i, s) => {
    i == e && s == t && (r = !0);
  }), r;
}
function LA(n, e) {
  return n.field(Oa, !1) ? e : e.concat(Xe.appendConfig.of(FA()));
}
const wK = (n) => {
  for (let e of _A(n)) {
    let t = wm(n.state, e.from, e.to);
    if (t)
      return n.dispatch({ effects: LA(n.state, [M1.of(t), BA(n, t)]) }), !0;
  }
  return !1;
}, xK = (n) => {
  if (!n.state.field(Oa, !1))
    return !1;
  let e = [];
  for (let t of _A(n)) {
    let r = xm(n.state, t.from, t.to);
    r && e.push(md.of(r), BA(n, r, !1));
  }
  return e.length && n.dispatch({ effects: e }), e.length > 0;
};
function BA(n, e, t = !0) {
  let r = n.state.doc.lineAt(e.from).number, i = n.state.doc.lineAt(e.to).number;
  return we.announce.of(`${n.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${n.state.phrase("to")} ${i}.`);
}
const kK = (n) => {
  let { state: e } = n, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = n.lineBlockAt(r), s = wm(e, i.from, i.to);
    s && t.push(M1.of(s)), r = (s ? n.lineBlockAt(s.to) : i).to + 1;
  }
  return t.length && n.dispatch({ effects: LA(n.state, t) }), !!t.length;
}, SK = (n) => {
  let e = n.state.field(Oa, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, n.state.doc.length, (r, i) => {
    t.push(md.of({ from: r, to: i }));
  }), n.dispatch({ effects: t }), !0;
}, CK = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: wK },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: xK },
  { key: "Ctrl-Alt-[", run: kK },
  { key: "Ctrl-Alt-]", run: SK }
], MK = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, zA = /* @__PURE__ */ ke.define({
  combine(n) {
    return Ms(n, MK);
  }
});
function FA(n) {
  return [Oa, EK];
}
function HA(n, e) {
  let { state: t } = n, r = t.facet(zA), i = (o) => {
    let l = n.lineBlockAt(n.posAtDOM(o.target)), a = xm(n.state, l.from, l.to);
    a && n.dispatch({ effects: md.of(a) }), o.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(n, i, e);
  let s = document.createElement("span");
  return s.textContent = r.placeholderText, s.setAttribute("aria-label", t.phrase("folded code")), s.title = t.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
}
const Yx = /* @__PURE__ */ He.replace({ widget: /* @__PURE__ */ new class extends xo {
  toDOM(n) {
    return HA(n, null);
  }
}() });
class TK extends xo {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return HA(e, this.value);
  }
}
const AK = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class S2 extends uo {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function OK(n = {}) {
  let e = { ...AK, ...n }, t = new S2(e, !0), r = new S2(e, !1), i = gn.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(dl) != o.state.facet(dl) || o.startState.field(Oa, !1) != o.state.field(Oa, !1) || Fn(o.startState) != Fn(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let l = new ao();
      for (let a of o.viewportLineBlocks) {
        let c = xm(o.state, a.from, a.to) ? r : wm(o.state, a.from, a.to) ? t : null;
        c && l.add(a.from, a.from, c);
      }
      return l.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    i,
    LU({
      class: "cm-foldGutter",
      markers(o) {
        var l;
        return ((l = o.plugin(i)) === null || l === void 0 ? void 0 : l.markers) || ht.empty;
      },
      initialSpacer() {
        return new S2(e, !1);
      },
      domEventHandlers: {
        ...s,
        click: (o, l, a) => {
          if (s.click && s.click(o, l, a))
            return !0;
          let c = xm(o.state, l.from, l.to);
          if (c)
            return o.dispatch({ effects: md.of(c) }), !0;
          let u = wm(o.state, l.from, l.to);
          return u ? (o.dispatch({ effects: M1.of(u) }), !0) : !1;
        }
      }
    }),
    FA()
  ];
}
const EK = /* @__PURE__ */ we.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class gd {
  constructor(e, t) {
    this.specs = e;
    let r;
    function i(l) {
      let a = hl.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + a] = l, a;
    }
    const s = typeof t.all == "string" ? t.all : t.all ? i(t.all) : void 0, o = t.scope;
    this.scope = o instanceof ci ? (l) => l.prop(ta) == o.data : o ? (l) => l == o : void 0, this.style = OA(e.map((l) => ({
      tag: l.tag,
      class: l.class || i(Object.assign({}, l, { tag: null }))
    })), {
      all: s
    }).style, this.module = r ? new hl(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new gd(e, t || {});
  }
}
const jy = /* @__PURE__ */ ke.define(), $A = /* @__PURE__ */ ke.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function C2(n) {
  let e = n.facet(jy);
  return e.length ? e : n.facet($A);
}
function VA(n, e) {
  let t = [DK], r;
  return n instanceof gd && (n.module && t.push(we.styleModule.of(n.module)), r = n.themeType), e?.fallback ? t.push($A.of(n)) : r ? t.push(jy.computeN([we.darkTheme], (i) => i.facet(we.darkTheme) == (r == "dark") ? [n] : [])) : t.push(jy.of(n)), t;
}
class IK {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Fn(e.state), this.decorations = this.buildDeco(e, C2(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = Fn(e.state), r = C2(e.state), i = r != C2(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    t.length < s.to && !i && t.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (t != this.tree || e.viewportChanged || i) && (this.tree = t, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = s.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return He.none;
    let r = new ao();
    for (let { from: i, to: s } of e.visibleRanges)
      QU(this.tree, t, (o, l, a) => {
        r.add(o, l, this.markCache[a] || (this.markCache[a] = He.mark({ class: a })));
      }, i, s);
    return r.finish();
  }
}
const DK = /* @__PURE__ */ Tl.high(/* @__PURE__ */ gn.fromClass(IK, {
  decorations: (n) => n.decorations
})), NK = /* @__PURE__ */ gd.define([
  {
    tag: U.meta,
    color: "#404740"
  },
  {
    tag: U.link,
    textDecoration: "underline"
  },
  {
    tag: U.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: U.emphasis,
    fontStyle: "italic"
  },
  {
    tag: U.strong,
    fontWeight: "bold"
  },
  {
    tag: U.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: U.keyword,
    color: "#708"
  },
  {
    tag: [U.atom, U.bool, U.url, U.contentSeparator, U.labelName],
    color: "#219"
  },
  {
    tag: [U.literal, U.inserted],
    color: "#164"
  },
  {
    tag: [U.string, U.deleted],
    color: "#a11"
  },
  {
    tag: [U.regexp, U.escape, /* @__PURE__ */ U.special(U.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ U.definition(U.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ U.local(U.variableName),
    color: "#30a"
  },
  {
    tag: [U.typeName, U.namespace],
    color: "#085"
  },
  {
    tag: U.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ U.special(U.variableName), U.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ U.definition(U.propertyName),
    color: "#00c"
  },
  {
    tag: U.comment,
    color: "#940"
  },
  {
    tag: U.invalid,
    color: "#f00"
  }
]), RK = /* @__PURE__ */ we.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), qA = 1e4, WA = "()[]{}", jA = /* @__PURE__ */ ke.define({
  combine(n) {
    return Ms(n, {
      afterCursor: !0,
      brackets: WA,
      maxScanDistance: qA,
      renderMatch: LK
    });
  }
}), PK = /* @__PURE__ */ He.mark({ class: "cm-matchingBracket" }), _K = /* @__PURE__ */ He.mark({ class: "cm-nonmatchingBracket" });
function LK(n) {
  let e = [], t = n.matched ? PK : _K;
  return e.push(t.range(n.start.from, n.start.to)), n.end && e.push(t.range(n.end.from, n.end.to)), e;
}
const BK = /* @__PURE__ */ On.define({
  create() {
    return He.none;
  },
  update(n, e) {
    if (!e.docChanged && !e.selection)
      return n;
    let t = [], r = e.state.facet(jA);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = fs(e.state, i.head, -1, r) || i.head > 0 && fs(e.state, i.head - 1, 1, r) || r.afterCursor && (fs(e.state, i.head, 1, r) || i.head < e.state.doc.length && fs(e.state, i.head + 1, -1, r));
      s && (t = t.concat(r.renderMatch(s, e.state)));
    }
    return He.set(t, !0);
  },
  provide: (n) => we.decorations.from(n)
}), zK = [
  BK,
  RK
];
function FK(n = {}) {
  return [jA.of(n), zK];
}
const HK = /* @__PURE__ */ new st();
function Uy(n, e, t) {
  let r = n.prop(e < 0 ? st.openedBy : st.closedBy);
  if (r)
    return r;
  if (n.name.length == 1) {
    let i = t.indexOf(n.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [t[i + e]];
  }
  return null;
}
function Ky(n) {
  let e = n.type.prop(HK);
  return e ? e(n.node) : n;
}
function fs(n, e, t, r = {}) {
  let i = r.maxScanDistance || qA, s = r.brackets || WA, o = Fn(n), l = o.resolveInner(e, t);
  for (let a = l; a; a = a.parent) {
    let c = Uy(a.type, t, s);
    if (c && a.from < a.to) {
      let u = Ky(a);
      if (u && (t > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return $K(n, e, t, a, u, c, s);
    }
  }
  return VK(n, e, t, o, l.type, i, s);
}
function $K(n, e, t, r, i, s, o) {
  let l = r.parent, a = { from: i.from, to: i.to }, c = 0, u = l?.cursor();
  if (u && (t < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (t < 0 ? u.to <= r.from : u.from >= r.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let h = Ky(u);
          return { start: a, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (Uy(u.type, t, o))
          c++;
        else if (Uy(u.type, -t, o)) {
          if (c == 0) {
            let h = Ky(u);
            return {
              start: a,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? u.prevSibling() : u.nextSibling());
  return { start: a, matched: !1 };
}
function VK(n, e, t, r, i, s, o) {
  let l = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1), a = o.indexOf(l);
  if (a < 0 || a % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, u = n.doc.iterRange(e, t > 0 ? n.doc.length : 0), h = 0;
  for (let f = 0; !u.next().done && f <= s; ) {
    let d = u.value;
    t < 0 && (f += d.length);
    let p = e + f * t;
    for (let m = t > 0 ? 0 : d.length - 1, g = t > 0 ? d.length : -1; m != g; m += t) {
      let b = o.indexOf(d[m]);
      if (!(b < 0 || r.resolveInner(p + m, 1).type != i))
        if (b % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: c, end: { from: p + m, to: p + m + 1 }, matched: b >> 1 == a >> 1 };
          h--;
        }
    }
    t > 0 && (f += d.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
function Jx(n, e, t, r = 0, i = 0) {
  e == null && (e = n.search(/[^\s\u00a0]/), e == -1 && (e = n.length));
  let s = i;
  for (let o = r; o < e; o++)
    n.charCodeAt(o) == 9 ? s += t - s % t : s++;
  return s;
}
class UA {
  /**
  Create a stream.
  */
  constructor(e, t, r, i) {
    this.string = e, this.tabSize = t, this.indentUnit = r, this.overrideIndent = i, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(e) {
    let t = this.string.charAt(this.pos), r;
    if (typeof e == "string" ? r = t == e : r = t && (e instanceof RegExp ? e.test(t) : e(t)), r)
      return ++this.pos, t;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(e) {
    let t = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > t;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(e) {
    let t = this.string.indexOf(e, this.pos);
    if (t > -1)
      return this.pos = t, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(e) {
    this.pos -= e;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = Jx(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : Jx(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(e, t, r) {
    if (typeof e == "string") {
      let i = (o) => r ? o.toLowerCase() : o, s = this.string.substr(this.pos, e.length);
      return i(s) == i(e) ? (t !== !1 && (this.pos += e.length), !0) : null;
    } else {
      let i = this.string.slice(this.pos).match(e);
      return i && i.index > 0 ? null : (i && t !== !1 && (this.pos += i[0].length), i);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function qK(n) {
  return {
    name: n.name || "",
    token: n.token,
    blankLine: n.blankLine || (() => {
    }),
    startState: n.startState || (() => !0),
    copyState: n.copyState || WK,
    indent: n.indent || (() => null),
    languageData: n.languageData || {},
    tokenTable: n.tokenTable || Q3,
    mergeTokens: n.mergeTokens !== !1
  };
}
function WK(n) {
  if (typeof n != "object")
    return n;
  let e = {};
  for (let t in n) {
    let r = n[t];
    e[t] = r instanceof Array ? r.slice() : r;
  }
  return e;
}
const Xx = /* @__PURE__ */ new WeakMap();
class X3 extends ci {
  constructor(e) {
    let t = EA(e.languageData), r = qK(e), i, s = new class extends ZM {
      createParse(o, l, a) {
        return new UK(i, o, l, a);
      }
    }();
    super(t, s, [], e.name), this.topNode = YK(t, this), i = this, this.streamParser = r, this.stateAfter = new st({ perNode: !0 }), this.tokenTable = e.tokenTable ? new JA(r.tokenTable) : GK;
  }
  /**
  Define a stream language.
  */
  static define(e) {
    return new X3(e);
  }
  /**
  @internal
  */
  getIndent(e) {
    let t, { overrideIndentation: r } = e.options;
    r && (t = Xx.get(e.state), t != null && t < e.pos - 1e4 && (t = void 0));
    let i = Z3(this, e.node.tree, e.node.from, e.node.from, t ?? e.pos), s, o;
    if (i ? (o = i.state, s = i.pos + 1) : (o = this.streamParser.startState(e.unit), s = e.node.from), e.pos - s > 1e4)
      return null;
    for (; s < e.pos; ) {
      let a = e.state.doc.lineAt(s), c = Math.min(e.pos, a.to);
      if (a.length) {
        let u = r ? r(a.from) : -1, h = new UA(a.text, e.state.tabSize, e.unit, u < 0 ? void 0 : u);
        for (; h.pos < c - a.from; )
          GA(this.streamParser.token, h, o);
      } else
        this.streamParser.blankLine(o, e.unit);
      if (c == e.pos)
        break;
      s = a.to + 1;
    }
    let l = e.lineAt(e.pos);
    return r && t == null && Xx.set(e.state, l.from), this.streamParser.indent(o, /^\s*(.*)/.exec(l.text)[1], e);
  }
  get allowsNesting() {
    return !1;
  }
}
function Z3(n, e, t, r, i) {
  let s = t >= r && t + e.length <= i && e.prop(n.stateAfter);
  if (s)
    return { state: n.streamParser.copyState(s), pos: t + e.length };
  for (let o = e.children.length - 1; o >= 0; o--) {
    let l = e.children[o], a = t + e.positions[o], c = l instanceof zt && a < i && Z3(n, l, a, r, i);
    if (c)
      return c;
  }
  return null;
}
function KA(n, e, t, r, i) {
  if (i && t <= 0 && r >= e.length)
    return e;
  !i && t == 0 && e.type == n.topNode && (i = !0);
  for (let s = e.children.length - 1; s >= 0; s--) {
    let o = e.positions[s], l = e.children[s], a;
    if (o < r && l instanceof zt) {
      if (!(a = KA(n, l, t - o, r - o, i)))
        break;
      return i ? new zt(e.type, e.children.slice(0, s).concat(a), e.positions.slice(0, s + 1), o + a.length) : a;
    }
  }
  return null;
}
function jK(n, e, t, r, i) {
  for (let s of e) {
    let o = s.from + (s.openStart ? 25 : 0), l = s.to - (s.openEnd ? 25 : 0), a = o <= t && l > t && Z3(n, s.tree, 0 - s.offset, t, l), c;
    if (a && a.pos <= r && (c = KA(n, s.tree, t + s.offset, a.pos + s.offset, !1)))
      return { state: a.state, tree: c };
  }
  return { state: n.streamParser.startState(i ? Aa(i) : 4), tree: zt.empty };
}
class UK {
  constructor(e, t, r, i) {
    this.lang = e, this.input = t, this.fragments = r, this.ranges = i, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = i[i.length - 1].to;
    let s = Hc.get(), o = i[0].from, { state: l, tree: a } = jK(e, r, o, this.to, s?.state);
    this.state = l, this.parsedPos = this.chunkStart = o + a.length;
    for (let c = 0; c < a.children.length; c++)
      this.chunks.push(a.children[c]), this.chunkPos.push(a.positions[c]);
    s && this.parsedPos < s.viewport.from - 1e5 && i.some((c) => c.from <= s.viewport.from && c.to >= s.viewport.from) && (this.state = this.lang.streamParser.startState(Aa(s.state)), s.skipUntilInView(this.parsedPos, s.viewport.from), this.parsedPos = s.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let e = Hc.get(), t = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), r = Math.min(
      t,
      this.chunkStart + 512
      /* C.ChunkSize */
    );
    for (e && (r = Math.min(r, e.viewport.to)); this.parsedPos < r; )
      this.parseLine(e);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= t ? this.finish() : e && this.parsedPos >= e.viewport.to ? (e.skipUntilInView(this.parsedPos, t), this.finish()) : null;
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let t = this.input.chunk(e);
    if (this.input.lineChunks)
      t == `
` && (t = "");
    else {
      let r = t.indexOf(`
`);
      r > -1 && (t = t.slice(0, r));
    }
    return e + t.length <= this.to ? t : t.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos, t = this.lineAfter(e), r = e + t.length;
    for (let i = this.rangeIndex; ; ) {
      let s = this.ranges[i].to;
      if (s >= r || (t = t.slice(0, s - (r - t.length)), i++, i == this.ranges.length))
        break;
      let o = this.ranges[i].from, l = this.lineAfter(o);
      t += l, r = o + l.length;
    }
    return { line: t, end: r };
  }
  skipGapsTo(e, t, r) {
    for (; ; ) {
      let i = this.ranges[this.rangeIndex].to, s = e + t;
      if (r > 0 ? i > s : i >= s)
        break;
      let o = this.ranges[++this.rangeIndex].from;
      t += o - i;
    }
    return t;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(e, t, r, i) {
    let s = 4;
    if (this.ranges.length > 1) {
      i = this.skipGapsTo(t, i, 1), t += i;
      let l = this.chunk.length;
      i = this.skipGapsTo(r, i, -1), r += i, s += this.chunk.length - l;
    }
    let o = this.chunk.length - 4;
    return this.lang.streamParser.mergeTokens && s == 4 && o >= 0 && this.chunk[o] == e && this.chunk[o + 2] == t ? this.chunk[o + 2] = r : this.chunk.push(e, t, r, s), i;
  }
  parseLine(e) {
    let { line: t, end: r } = this.nextLine(), i = 0, { streamParser: s } = this.lang, o = new UA(t, e ? e.state.tabSize : 4, e ? Aa(e.state) : 2);
    if (o.eol())
      s.blankLine(this.state, o.indentUnit);
    else
      for (; !o.eol(); ) {
        let l = GA(s.token, o, this.state);
        if (l && (i = this.emitToken(this.lang.tokenTable.resolve(l), this.parsedPos + o.start, this.parsedPos + o.pos, i)), o.start > 1e4)
          break;
      }
    this.parsedPos = r, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = zt.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: KK,
      topID: 0,
      maxBufferLength: 512,
      reused: this.chunkReused
    });
    e = new zt(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(e), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new zt(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}
function GA(n, e, t) {
  e.start = e.pos;
  for (let r = 0; r < 10; r++) {
    let i = n(e, t);
    if (e.pos > e.start)
      return i;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const Q3 = /* @__PURE__ */ Object.create(null), qf = [gr.none], KK = /* @__PURE__ */ new I3(qf), Zx = [], Qx = /* @__PURE__ */ Object.create(null), YA = /* @__PURE__ */ Object.create(null);
for (let [n, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  YA[n] = /* @__PURE__ */ XA(Q3, e);
class JA {
  constructor(e) {
    this.extra = e, this.table = Object.assign(/* @__PURE__ */ Object.create(null), YA);
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = XA(this.extra, e)) : 0;
  }
}
const GK = /* @__PURE__ */ new JA(Q3);
function M2(n, e) {
  Zx.indexOf(n) > -1 || (Zx.push(n), console.warn(e));
}
function XA(n, e) {
  let t = [];
  for (let l of e.split(" ")) {
    let a = [];
    for (let c of l.split(".")) {
      let u = n[c] || U[c];
      u ? typeof u == "function" ? a.length ? a = a.map(u) : M2(c, `Modifier ${c} used at start of tag`) : a.length ? M2(c, `Tag ${c} used as modifier`) : a = Array.isArray(u) ? u : [u] : M2(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of a)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + t.map((l) => l.id), s = Qx[i];
  if (s)
    return s.id;
  let o = Qx[i] = gr.define({
    id: qf.length,
    name: r,
    props: [XU({ [r]: t })]
  });
  return qf.push(o), o.id;
}
function YK(n, e) {
  let t = gr.define({ id: qf.length, name: "Document", props: [
    ta.add(() => n),
    DA.add(() => (r) => e.getIndent(r))
  ], top: !0 });
  return qf.push(t), t;
}
Wt.RTL, Wt.LTR;
function Z(n) {
  return new sK(X3.define(n));
}
function Eo(n) {
  return import("./index-AhZZbarQ.js").then((e) => e.sql({ dialect: e[n] }));
}
const JK = [
  // New-style language modes
  /* @__PURE__ */ q.of({
    name: "C",
    extensions: ["c", "h", "ino"],
    load() {
      return import("./index-CgtkgqHZ.js").then((n) => n.cpp());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "C++",
    alias: ["cpp"],
    extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
    load() {
      return import("./index-CgtkgqHZ.js").then((n) => n.cpp());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CQL",
    alias: ["cassandra"],
    extensions: ["cql"],
    load() {
      return Eo("Cassandra");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CSS",
    extensions: ["css"],
    load() {
      return import("./index-BI3Rel7B.js").then((n) => n.css());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Go",
    extensions: ["go"],
    load() {
      return import("./index-DNj08t0y.js").then((n) => n.go());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "HTML",
    alias: ["xhtml"],
    extensions: ["html", "htm", "handlebars", "hbs"],
    load() {
      return import("./index-DTvYKKoZ.js").then((n) => n.html());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Java",
    extensions: ["java"],
    load() {
      return import("./index-DF4Nh78i.js").then((n) => n.java());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JavaScript",
    alias: ["ecmascript", "js", "node"],
    extensions: ["js", "mjs", "cjs"],
    load() {
      return import("./index-BScPUHkS.js").then((n) => n.javascript());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JSON",
    alias: ["json5"],
    extensions: ["json", "map"],
    load() {
      return import("./index-Chr0yxsu.js").then((n) => n.json());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JSX",
    extensions: ["jsx"],
    load() {
      return import("./index-BScPUHkS.js").then((n) => n.javascript({ jsx: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "LESS",
    extensions: ["less"],
    load() {
      return import("./index-BtlcK-pO.js").then((n) => n.less());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Liquid",
    extensions: ["liquid"],
    load() {
      return import("./index-GEUOofND.js").then((n) => n.liquid());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MariaDB SQL",
    load() {
      return Eo("MariaSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Markdown",
    extensions: ["md", "markdown", "mkd"],
    load() {
      return import("./index-IjnE6y_D.js").then((n) => n.markdown());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MS SQL",
    load() {
      return Eo("MSSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MySQL",
    load() {
      return Eo("MySQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PHP",
    extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
    load() {
      return import("./index-Dz4LlJfY.js").then((n) => n.php());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PLSQL",
    extensions: ["pls"],
    load() {
      return Eo("PLSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PostgreSQL",
    load() {
      return Eo("PostgreSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Python",
    extensions: ["BUILD", "bzl", "py", "pyw"],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return import("./index-CBwkF9o7.js").then((n) => n.python());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Rust",
    extensions: ["rs"],
    load() {
      return import("./index-CB5CKEaY.js").then((n) => n.rust());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Sass",
    extensions: ["sass"],
    load() {
      return import("./index-B-YoCbOy.js").then((n) => n.sass({ indented: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SCSS",
    extensions: ["scss"],
    load() {
      return import("./index-B-YoCbOy.js").then((n) => n.sass());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SQL",
    extensions: ["sql"],
    load() {
      return Eo("StandardSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SQLite",
    load() {
      return Eo("SQLite");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TSX",
    extensions: ["tsx"],
    load() {
      return import("./index-BScPUHkS.js").then((n) => n.javascript({ jsx: !0, typescript: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TypeScript",
    alias: ["ts"],
    extensions: ["ts", "mts", "cts"],
    load() {
      return import("./index-BScPUHkS.js").then((n) => n.javascript({ typescript: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "WebAssembly",
    extensions: ["wat", "wast"],
    load() {
      return import("./index-BYa-fef_.js").then((n) => n.wast());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "XML",
    alias: ["rss", "wsdl", "xsd"],
    extensions: ["xml", "xsl", "xsd", "svg"],
    load() {
      return import("./index-CKZVqd25.js").then((n) => n.xml());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "YAML",
    alias: ["yml"],
    extensions: ["yaml", "yml"],
    load() {
      return import("./index-Bx_hSG9T.js").then((n) => n.yaml());
    }
  }),
  // Legacy modes ported from CodeMirror 5
  /* @__PURE__ */ q.of({
    name: "APL",
    extensions: ["dyalog", "apl"],
    load() {
      return import("./apl-B2DGVGxc.js").then((n) => Z(n.apl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PGP",
    alias: ["asciiarmor"],
    extensions: ["asc", "pgp", "sig"],
    load() {
      return import("./asciiarmor-2LVJmxlE.js").then((n) => Z(n.asciiArmor));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ASN.1",
    extensions: ["asn", "asn1"],
    load() {
      return import("./asn1-jKiBa2Ya.js").then((n) => Z(n.asn1({})));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Asterisk",
    filename: /^extensions\.conf$/i,
    load() {
      return import("./asterisk-DS281yxp.js").then((n) => Z(n.asterisk));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Brainfuck",
    extensions: ["b", "bf"],
    load() {
      return import("./brainfuck-C_p9pTT8.js").then((n) => Z(n.brainfuck));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Cobol",
    extensions: ["cob", "cpy"],
    load() {
      return import("./cobol-BlTKFDRj.js").then((n) => Z(n.cobol));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "C#",
    alias: ["csharp", "cs"],
    extensions: ["cs"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.csharp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Clojure",
    extensions: ["clj", "cljc", "cljx"],
    load() {
      return import("./clojure-CCKyeQKf.js").then((n) => Z(n.clojure));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ClojureScript",
    extensions: ["cljs"],
    load() {
      return import("./clojure-CCKyeQKf.js").then((n) => Z(n.clojure));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Closure Stylesheets (GSS)",
    extensions: ["gss"],
    load() {
      return import("./css-BkF-NPzE.js").then((n) => Z(n.gss));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CMake",
    extensions: ["cmake", "cmake.in"],
    filename: /^CMakeLists\.txt$/,
    load() {
      return import("./cmake-CuaCgAKt.js").then((n) => Z(n.cmake));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CoffeeScript",
    alias: ["coffee", "coffee-script"],
    extensions: ["coffee"],
    load() {
      return import("./coffeescript-BVCvwO8I.js").then((n) => Z(n.coffeeScript));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Common Lisp",
    alias: ["lisp"],
    extensions: ["cl", "lisp", "el"],
    load() {
      return import("./commonlisp-D_kxz07b.js").then((n) => Z(n.commonLisp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Cypher",
    extensions: ["cyp", "cypher"],
    load() {
      return import("./cypher-BMq4Fwjl.js").then((n) => Z(n.cypher));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Cython",
    extensions: ["pyx", "pxd", "pxi"],
    load() {
      return import("./python-BkR3uSy8.js").then((n) => Z(n.cython));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Crystal",
    extensions: ["cr"],
    load() {
      return import("./crystal-D309uH6_.js").then((n) => Z(n.crystal));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "D",
    extensions: ["d"],
    load() {
      return import("./d-BZcgY6La.js").then((n) => Z(n.d));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Dart",
    extensions: ["dart"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.dart));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "diff",
    extensions: ["diff", "patch"],
    load() {
      return import("./diff-Cg9d_RX2.js").then((n) => Z(n.diff));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Dockerfile",
    filename: /^Dockerfile$/,
    load() {
      return import("./dockerfile-DIy8NleC.js").then((n) => Z(n.dockerFile));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "DTD",
    extensions: ["dtd"],
    load() {
      return import("./dtd-CtLokQ-U.js").then((n) => Z(n.dtd));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Dylan",
    extensions: ["dylan", "dyl", "intr"],
    load() {
      return import("./dylan-QYeExnWK.js").then((n) => Z(n.dylan));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "EBNF",
    load() {
      return import("./ebnf-DUPDuY4r.js").then((n) => Z(n.ebnf));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ECL",
    extensions: ["ecl"],
    load() {
      return import("./ecl-CiXN-g_D.js").then((n) => Z(n.ecl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "edn",
    extensions: ["edn"],
    load() {
      return import("./clojure-CCKyeQKf.js").then((n) => Z(n.clojure));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Eiffel",
    extensions: ["e"],
    load() {
      return import("./eiffel-yQhjl4T1.js").then((n) => Z(n.eiffel));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Elm",
    extensions: ["elm"],
    load() {
      return import("./elm-CNT9vbN0.js").then((n) => Z(n.elm));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Erlang",
    extensions: ["erl"],
    load() {
      return import("./erlang-CFOYdy9e.js").then((n) => Z(n.erlang));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Esper",
    load() {
      return import("./sql-CfG5lQ3l.js").then((n) => Z(n.esper));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Factor",
    extensions: ["factor"],
    load() {
      return import("./factor-DDOC7X6P.js").then((n) => Z(n.factor));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "FCL",
    load() {
      return import("./fcl-CPC2WYrI.js").then((n) => Z(n.fcl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Forth",
    extensions: ["forth", "fth", "4th"],
    load() {
      return import("./forth-BmxRyE9S.js").then((n) => Z(n.forth));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Fortran",
    extensions: ["f", "for", "f77", "f90", "f95"],
    load() {
      return import("./fortran-9bvPyrOW.js").then((n) => Z(n.fortran));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "F#",
    alias: ["fsharp"],
    extensions: ["fs"],
    load() {
      return import("./mllike-BSnXJBGA.js").then((n) => Z(n.fSharp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Gas",
    extensions: ["s"],
    load() {
      return import("./gas-cpmYfFX2.js").then((n) => Z(n.gas));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Gherkin",
    extensions: ["feature"],
    load() {
      return import("./gherkin-CJuwpceU.js").then((n) => Z(n.gherkin));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Groovy",
    extensions: ["groovy", "gradle"],
    filename: /^Jenkinsfile$/,
    load() {
      return import("./groovy-DZeT_VM-.js").then((n) => Z(n.groovy));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Haskell",
    extensions: ["hs"],
    load() {
      return import("./haskell-CxiO_7JL.js").then((n) => Z(n.haskell));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Haxe",
    extensions: ["hx"],
    load() {
      return import("./haxe-70NVW1pR.js").then((n) => Z(n.haxe));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "HXML",
    extensions: ["hxml"],
    load() {
      return import("./haxe-70NVW1pR.js").then((n) => Z(n.hxml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "HTTP",
    load() {
      return import("./http-D9LttvKF.js").then((n) => Z(n.http));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "IDL",
    extensions: ["pro"],
    load() {
      return import("./idl-B6TRFYjl.js").then((n) => Z(n.idl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JSON-LD",
    alias: ["jsonld"],
    extensions: ["jsonld"],
    load() {
      return import("./javascript-DOuB9oqA.js").then((n) => Z(n.jsonld));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Jinja2",
    extensions: ["j2", "jinja", "jinja2"],
    load() {
      return import("./jinja2-DnB6dQmV.js").then((n) => Z(n.jinja2));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Julia",
    extensions: ["jl"],
    load() {
      return import("./julia-DpvXAuO6.js").then((n) => Z(n.julia));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Kotlin",
    extensions: ["kt", "kts"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.kotlin));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "LiveScript",
    alias: ["ls"],
    extensions: ["ls"],
    load() {
      return import("./livescript-CanGTf8u.js").then((n) => Z(n.liveScript));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Lua",
    extensions: ["lua"],
    load() {
      return import("./lua-XplVlWi_.js").then((n) => Z(n.lua));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "mIRC",
    extensions: ["mrc"],
    load() {
      return import("./mirc-CFBPAOaF.js").then((n) => Z(n.mirc));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Mathematica",
    extensions: ["m", "nb", "wl", "wls"],
    load() {
      return import("./mathematica-jaRHnSxC.js").then((n) => Z(n.mathematica));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Modelica",
    extensions: ["mo"],
    load() {
      return import("./modelica-vUgVs--1.js").then((n) => Z(n.modelica));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MUMPS",
    extensions: ["mps"],
    load() {
      return import("./mumps-CQoS1kWX.js").then((n) => Z(n.mumps));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Mbox",
    extensions: ["mbox"],
    load() {
      return import("./mbox-BctzC1hL.js").then((n) => Z(n.mbox));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Nginx",
    filename: /nginx.*\.conf$/i,
    load() {
      return import("./nginx-zDPm3Z74.js").then((n) => Z(n.nginx));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "NSIS",
    extensions: ["nsh", "nsi"],
    load() {
      return import("./nsis-fePjrhq7.js").then((n) => Z(n.nsis));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "NTriples",
    extensions: ["nt", "nq"],
    load() {
      return import("./ntriples-CsNjv2QF.js").then((n) => Z(n.ntriples));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Objective-C",
    alias: ["objective-c", "objc"],
    extensions: ["m"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.objectiveC));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Objective-C++",
    alias: ["objective-c++", "objc++"],
    extensions: ["mm"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.objectiveCpp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "OCaml",
    extensions: ["ml", "mli", "mll", "mly"],
    load() {
      return import("./mllike-BSnXJBGA.js").then((n) => Z(n.oCaml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Octave",
    extensions: ["m"],
    load() {
      return import("./octave-C8PmmSRH.js").then((n) => Z(n.octave));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Oz",
    extensions: ["oz"],
    load() {
      return import("./oz-Ce8aN8oE.js").then((n) => Z(n.oz));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Pascal",
    extensions: ["p", "pas"],
    load() {
      return import("./pascal-De0D6mP7.js").then((n) => Z(n.pascal));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Perl",
    extensions: ["pl", "pm"],
    load() {
      return import("./perl-B4bSCe1C.js").then((n) => Z(n.perl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Pig",
    extensions: ["pig"],
    load() {
      return import("./pig-D24Z8EXi.js").then((n) => Z(n.pig));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PowerShell",
    extensions: ["ps1", "psd1", "psm1"],
    load() {
      return import("./powershell-DkYVfTzP.js").then((n) => Z(n.powerShell));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Properties files",
    alias: ["ini", "properties"],
    extensions: ["properties", "ini", "in"],
    load() {
      return import("./properties-Dn9wna3M.js").then((n) => Z(n.properties));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ProtoBuf",
    extensions: ["proto"],
    load() {
      return import("./protobuf-BPIjwpzm.js").then((n) => Z(n.protobuf));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Pug",
    alias: ["jade"],
    extensions: ["pug", "jade"],
    load() {
      return import("./pug-TGXr6c5j.js").then((n) => Z(n.pug));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Puppet",
    extensions: ["pp"],
    load() {
      return import("./puppet-nyd4dhjf.js").then((n) => Z(n.puppet));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Q",
    extensions: ["q"],
    load() {
      return import("./q-DXjKs-tC.js").then((n) => Z(n.q));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "R",
    alias: ["rscript"],
    extensions: ["r", "R"],
    load() {
      return import("./r-LKEuhEGI.js").then((n) => Z(n.r));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "RPM Changes",
    load() {
      return import("./rpm-IznJm2Xc.js").then((n) => Z(n.rpmChanges));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "RPM Spec",
    extensions: ["spec"],
    load() {
      return import("./rpm-IznJm2Xc.js").then((n) => Z(n.rpmSpec));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Ruby",
    alias: ["jruby", "macruby", "rake", "rb", "rbx"],
    extensions: ["rb"],
    filename: /^(Gemfile|Rakefile)$/,
    load() {
      return import("./ruby-CcYfvIk6.js").then((n) => Z(n.ruby));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SAS",
    extensions: ["sas"],
    load() {
      return import("./sas-7E8yHoCW.js").then((n) => Z(n.sas));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Scala",
    extensions: ["scala"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.scala));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Scheme",
    extensions: ["scm", "ss"],
    load() {
      return import("./scheme-DjibxsNh.js").then((n) => Z(n.scheme));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Shell",
    alias: ["bash", "sh", "zsh"],
    extensions: ["sh", "ksh", "bash"],
    filename: /^PKGBUILD$/,
    load() {
      return import("./shell-C0C2sNA_.js").then((n) => Z(n.shell));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Sieve",
    extensions: ["siv", "sieve"],
    load() {
      return import("./sieve-Bwz7vjP5.js").then((n) => Z(n.sieve));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Smalltalk",
    extensions: ["st"],
    load() {
      return import("./smalltalk-Bhddl2pB.js").then((n) => Z(n.smalltalk));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Solr",
    load() {
      return import("./solr-BNlsLglM.js").then((n) => Z(n.solr));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SML",
    extensions: ["sml", "sig", "fun", "smackspec"],
    load() {
      return import("./mllike-BSnXJBGA.js").then((n) => Z(n.sml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SPARQL",
    alias: ["sparul"],
    extensions: ["rq", "sparql"],
    load() {
      return import("./sparql-FarWu_Gb.js").then((n) => Z(n.sparql));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Spreadsheet",
    alias: ["excel", "formula"],
    load() {
      return import("./spreadsheet-C-cy4P5N.js").then((n) => Z(n.spreadsheet));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Squirrel",
    extensions: ["nut"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.squirrel));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Stylus",
    extensions: ["styl"],
    load() {
      return import("./stylus-CAdqWld3.js").then((n) => Z(n.stylus));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Swift",
    extensions: ["swift"],
    load() {
      return import("./swift-DSxqR9R6.js").then((n) => Z(n.swift));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "sTeX",
    load() {
      return import("./stex-Du4h4KAU.js").then((n) => Z(n.stex));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "LaTeX",
    alias: ["tex"],
    extensions: ["text", "ltx", "tex"],
    load() {
      return import("./stex-Du4h4KAU.js").then((n) => Z(n.stex));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SystemVerilog",
    extensions: ["v", "sv", "svh"],
    load() {
      return import("./verilog-CiS1jyi5.js").then((n) => Z(n.verilog));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Tcl",
    extensions: ["tcl"],
    load() {
      return import("./tcl-xfoLljhY.js").then((n) => Z(n.tcl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Textile",
    extensions: ["textile"],
    load() {
      return import("./textile-D1AWE-pc.js").then((n) => Z(n.textile));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TiddlyWiki",
    load() {
      return import("./tiddlywiki-5wqsXtSk.js").then((n) => Z(n.tiddlyWiki));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Tiki wiki",
    load() {
      return import("./tiki-__Kn3CeS.js").then((n) => Z(n.tiki));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TOML",
    extensions: ["toml"],
    load() {
      return import("./toml-BHiuTcfn.js").then((n) => Z(n.toml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Troff",
    extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    load() {
      return import("./troff-D2UO-fKf.js").then((n) => Z(n.troff));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TTCN",
    extensions: ["ttcn", "ttcn3", "ttcnpp"],
    load() {
      return import("./ttcn-Bsa4sfRm.js").then((n) => Z(n.ttcn));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TTCN_CFG",
    extensions: ["cfg"],
    load() {
      return import("./ttcn-cfg-Bac_acMi.js").then((n) => Z(n.ttcnCfg));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Turtle",
    extensions: ["ttl"],
    load() {
      return import("./turtle-xwJUxoPV.js").then((n) => Z(n.turtle));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Web IDL",
    extensions: ["webidl"],
    load() {
      return import("./webidl-CjfDENEo.js").then((n) => Z(n.webIDL));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "VB.NET",
    extensions: ["vb"],
    load() {
      return import("./vb-c2kQGd6-.js").then((n) => Z(n.vb));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "VBScript",
    extensions: ["vbs"],
    load() {
      return import("./vbscript-1f_Dhg5H.js").then((n) => Z(n.vbScript));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Velocity",
    extensions: ["vtl"],
    load() {
      return import("./velocity-DJd0pTTC.js").then((n) => Z(n.velocity));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Verilog",
    extensions: ["v"],
    load() {
      return import("./verilog-CiS1jyi5.js").then((n) => Z(n.verilog));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "VHDL",
    extensions: ["vhd", "vhdl"],
    load() {
      return import("./vhdl-T9HkrbI2.js").then((n) => Z(n.vhdl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "XQuery",
    extensions: ["xy", "xquery"],
    load() {
      return import("./xquery-Ct6lEb4B.js").then((n) => Z(n.xQuery));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Yacas",
    extensions: ["ys"],
    load() {
      return import("./yacas-C0absKBh.js").then((n) => Z(n.yacas));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Z80",
    extensions: ["z80"],
    load() {
      return import("./z80-Pki2zAjW.js").then((n) => Z(n.z80));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MscGen",
    extensions: ["mscgen", "mscin", "msc"],
    load() {
      return import("./mscgen-Cpl0NYLN.js").then((n) => Z(n.mscgen));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Xù",
    extensions: ["xu"],
    load() {
      return import("./mscgen-Cpl0NYLN.js").then((n) => Z(n.xu));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MsGenny",
    extensions: ["msgenny"],
    load() {
      return import("./mscgen-Cpl0NYLN.js").then((n) => Z(n.msgenny));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Vue",
    extensions: ["vue"],
    load() {
      return import("./index-De3ONwH9.js").then((n) => n.vue());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Angular Template",
    load() {
      return import("./index-4bsXIDB5.js").then((n) => n.angular());
    }
  })
], XK = "#e5c07b", e8 = "#e06c75", ZK = "#56b6c2", QK = "#ffffff", vp = "#abb2bf", Gy = "#7d8799", eG = "#61afef", tG = "#98c379", t8 = "#d19a66", nG = "#c678dd", rG = "#21252b", n8 = "#2c313a", r8 = "#282c34", T2 = "#353a42", iG = "#3E4451", i8 = "#528bff", sG = /* @__PURE__ */ we.theme({
  "&": {
    color: vp,
    backgroundColor: r8
  },
  ".cm-content": {
    caretColor: i8
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: i8 },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: iG },
  ".cm-panels": { backgroundColor: rG, color: vp },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: r8,
    color: Gy,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: n8
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: T2
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: T2,
    borderBottomColor: T2
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: n8,
      color: vp
    }
  }
}, { dark: !0 }), oG = /* @__PURE__ */ gd.define([
  {
    tag: U.keyword,
    color: nG
  },
  {
    tag: [U.name, U.deleted, U.character, U.propertyName, U.macroName],
    color: e8
  },
  {
    tag: [/* @__PURE__ */ U.function(U.variableName), U.labelName],
    color: eG
  },
  {
    tag: [U.color, /* @__PURE__ */ U.constant(U.name), /* @__PURE__ */ U.standard(U.name)],
    color: t8
  },
  {
    tag: [/* @__PURE__ */ U.definition(U.name), U.separator],
    color: vp
  },
  {
    tag: [U.typeName, U.className, U.number, U.changed, U.annotation, U.modifier, U.self, U.namespace],
    color: XK
  },
  {
    tag: [U.operator, U.operatorKeyword, U.url, U.escape, U.regexp, U.link, /* @__PURE__ */ U.special(U.string)],
    color: ZK
  },
  {
    tag: [U.meta, U.comment],
    color: Gy
  },
  {
    tag: U.strong,
    fontWeight: "bold"
  },
  {
    tag: U.emphasis,
    fontStyle: "italic"
  },
  {
    tag: U.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: U.link,
    color: Gy,
    textDecoration: "underline"
  },
  {
    tag: U.heading,
    fontWeight: "bold",
    color: e8
  },
  {
    tag: [U.atom, U.bool, /* @__PURE__ */ U.special(U.variableName)],
    color: t8
  },
  {
    tag: [U.processingInstruction, U.string, U.inserted],
    color: tG
  },
  {
    tag: U.invalid,
    color: QK
  }
]), lG = [sG, /* @__PURE__ */ VA(oG)];
function Ye(n, e) {
  const t = WH(n), r = (i) => async () => {
    r.key = t, await i.wait(Uh);
    const s = e(i);
    return i.get(Me).create(t, s), r.run = (o) => i.get(Me).call(n, o), () => {
      i.get(Me).remove(t);
    };
  };
  return r;
}
function Qn(n) {
  const e = (t) => async () => {
    await t.wait(mi);
    const r = n(t);
    return t.update(Tf, (i) => [...i, r]), e.inputRule = r, () => {
      t.update(Tf, (i) => i.filter((s) => s !== r));
    };
  };
  return e;
}
function aG(n, e) {
  const t = (r) => async () => {
    const i = e(r);
    return r.update(jh, (s) => [
      ...s.filter((o) => o[0] !== n),
      [n, i]
    ]), t.id = n, t.schema = i, () => {
      r.update(jh, (s) => s.filter(([o]) => o !== n));
    };
  };
  return t.type = (r) => {
    const i = r.get(gi).marks[n];
    if (!i) throw LR(n);
    return i;
  }, t;
}
function eb(n, e) {
  const t = (r) => async () => {
    const i = e(r);
    return r.update(Wh, (s) => [
      ...s.filter((o) => o[0] !== n),
      [n, i]
    ]), t.id = n, t.schema = i, () => {
      r.update(Wh, (s) => s.filter(([o]) => o !== n));
    };
  };
  return t.type = (r) => {
    const i = r.get(gi).nodes[n];
    if (!i) throw _R(n);
    return i;
  }, t;
}
function kn(n) {
  let e;
  const t = (r) => async () => (await r.wait(mi), e = n(r), r.update(lo, (i) => [...i, e]), () => {
    r.update(lo, (i) => i.filter((s) => s !== e));
  });
  return t.plugin = () => e, t.key = () => e.spec.key, t;
}
function ZA(n) {
  const e = (t) => async () => {
    await t.wait(Kh);
    const r = t.get(sm), i = n(t), s = r.addObjectKeymap(i);
    return e.keymap = i, () => {
      s();
    };
  };
  return e;
}
function yd(n, e) {
  const t = (r) => async () => {
    await r.wait(mi);
    const i = e(r);
    return n.type(r) instanceof Zp ? r.update(Of, (s) => [
      ...s,
      [n.id, i]
    ]) : r.update(Ef, (s) => [
      ...s,
      [n.id, i]
    ]), t.view = i, t.type = n, () => {
      n.type(r) instanceof Zp ? r.update(Of, (s) => s.filter((o) => o[0] !== n.id)) : r.update(Ef, (s) => s.filter((o) => o[0] !== n.id));
    };
  };
  return t;
}
function Mt(n, e) {
  const t = at(n, e), r = (i) => (i.inject(t), () => () => {
    i.remove(t);
  });
  return r.key = t, r;
}
function hn(n, e) {
  const t = Mt(e, n), r = eb(n, (s) => s.get(t.key)(s)), i = [t, r];
  return i.id = r.id, i.node = r, i.type = (s) => r.type(s), i.ctx = t, i.key = t.key, i.extendSchema = (s) => {
    const o = s(e);
    return hn(n, o);
  }, i;
}
function ru(n, e) {
  const t = Mt(e, n), r = aG(n, (s) => s.get(t.key)(s)), i = [t, r];
  return i.id = r.id, i.mark = r, i.type = (s) => r.type(s), i.ctx = t, i.key = t.key, i.extendSchema = (s) => {
    const o = s(e);
    return ru(n, o);
  }, i;
}
function Pr(n, e) {
  const t = Object.fromEntries(
    Object.entries(e).map(
      ([o, { shortcuts: l, priority: a }]) => [o, { shortcuts: l, priority: a }]
    )
  ), r = Mt(t, `${n}Keymap`), i = ZA((o) => {
    const l = o.get(r.key), a = Object.entries(e).flatMap(
      ([c, { command: u }]) => {
        const h = l[c], f = [h.shortcuts].flat(), d = h.priority;
        return f.map(
          (p) => [
            p,
            {
              key: p,
              onRun: u,
              priority: d
            }
          ]
        );
      }
    );
    return Object.fromEntries(a);
  }), s = [r, i];
  return s.ctx = r, s.shortcuts = i, s.key = r.key, s.keymap = i.keymap, s;
}
const qi = (n, e = () => ({})) => Mt(e, `${n}Attr`), bd = (n, e = () => ({})) => Mt(e, `${n}Attr`);
function Ts(n, e, t) {
  const r = Mt({}, n), i = (o) => async () => {
    await o.wait(ua);
    const a = {
      plugin: e(o),
      options: o.get(r.key)
    };
    return o.update(Af, (c) => [...c, a]), () => {
      o.update(Af, (c) => c.filter((u) => u !== a));
    };
  }, s = [r, i];
  return s.id = n, s.plugin = i, s.options = r, s;
}
function cG(n) {
  return (e) => {
    const t = e.get(Ct);
    return e.get(gi), e.get(yc)(t.state.doc);
  };
}
function uG(n, e = !1) {
  return (t) => {
    const r = t.get(Ct), s = t.get(ha)(n);
    if (!s) return;
    if (!e) {
      const h = r.state.selection.content();
      return r.dispatch(
        r.state.tr.replaceSelection(
          new me(s.content, h.openStart, h.openEnd)
        ).scrollIntoView()
      );
    }
    const o = t.get(gi), l = wl.fromSchema(o).serializeFragment(s.content), c = ll.fromSchema(o).parseSlice(l), u = PC(c);
    if (u) {
      r.dispatch(r.state.tr.replaceSelectionWith(u, !0));
      return;
    }
    r.dispatch(r.state.tr.replaceSelection(c));
  };
}
function hG(n, e = !1) {
  return (t) => {
    const r = t.get(Ct), s = t.get(ha)(n);
    if (!s) return;
    if (!e) {
      const { state: u } = r;
      return r.dispatch(
        u.tr.replace(
          0,
          u.doc.content.size,
          new me(s.content, 0, 0)
        )
      );
    }
    const o = t.get(gi), l = t.get(ip), a = t.get(lo), c = o3.create({
      schema: o,
      doc: s,
      plugins: a,
      ...l
    });
    r.updateState(c);
  };
}
const Yy = Math.min, xc = Math.max, km = Math.round, bs = (n) => ({
  x: n,
  y: n
}), fG = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, dG = {
  start: "end",
  end: "start"
};
function s8(n, e, t) {
  return xc(n, Yy(e, t));
}
function T1(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function Ea(n) {
  return n.split("-")[0];
}
function A1(n) {
  return n.split("-")[1];
}
function QA(n) {
  return n === "x" ? "y" : "x";
}
function eO(n) {
  return n === "y" ? "height" : "width";
}
const pG = /* @__PURE__ */ new Set(["top", "bottom"]);
function Qo(n) {
  return pG.has(Ea(n)) ? "y" : "x";
}
function tO(n) {
  return QA(Qo(n));
}
function mG(n, e, t) {
  t === void 0 && (t = !1);
  const r = A1(n), i = tO(n), s = eO(i);
  let o = i === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (o = Sm(o)), [o, Sm(o)];
}
function gG(n) {
  const e = Sm(n);
  return [Jy(n), e, Jy(e)];
}
function Jy(n) {
  return n.replace(/start|end/g, (e) => dG[e]);
}
const o8 = ["left", "right"], l8 = ["right", "left"], yG = ["top", "bottom"], bG = ["bottom", "top"];
function vG(n, e, t) {
  switch (n) {
    case "top":
    case "bottom":
      return t ? e ? l8 : o8 : e ? o8 : l8;
    case "left":
    case "right":
      return e ? yG : bG;
    default:
      return [];
  }
}
function wG(n, e, t, r) {
  const i = A1(n);
  let s = vG(Ea(n), t === "start", r);
  return i && (s = s.map((o) => o + "-" + i), e && (s = s.concat(s.map(Jy)))), s;
}
function Sm(n) {
  return n.replace(/left|right|bottom|top/g, (e) => fG[e]);
}
function xG(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function kG(n) {
  return typeof n != "number" ? xG(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function Cm(n) {
  const {
    x: e,
    y: t,
    width: r,
    height: i
  } = n;
  return {
    width: r,
    height: i,
    top: t,
    left: e,
    right: e + r,
    bottom: t + i,
    x: e,
    y: t
  };
}
function a8(n, e, t) {
  let {
    reference: r,
    floating: i
  } = n;
  const s = Qo(e), o = tO(e), l = eO(o), a = Ea(e), c = s === "y", u = r.x + r.width / 2 - i.width / 2, h = r.y + r.height / 2 - i.height / 2, f = r[l] / 2 - i[l] / 2;
  let d;
  switch (a) {
    case "top":
      d = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      d = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      d = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      d = {
        x: r.x - i.width,
        y: h
      };
      break;
    default:
      d = {
        x: r.x,
        y: r.y
      };
  }
  switch (A1(e)) {
    case "start":
      d[o] -= f * (t && c ? -1 : 1);
      break;
    case "end":
      d[o] += f * (t && c ? -1 : 1);
      break;
  }
  return d;
}
const SG = async (n, e, t) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: o
  } = t, l = s.filter(Boolean), a = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let c = await o.getElementRects({
    reference: n,
    floating: e,
    strategy: i
  }), {
    x: u,
    y: h
  } = a8(c, r, a), f = r, d = {}, p = 0;
  for (let m = 0; m < l.length; m++) {
    const {
      name: g,
      fn: b
    } = l[m], {
      x: w,
      y: k,
      data: C,
      reset: M
    } = await b({
      x: u,
      y: h,
      initialPlacement: r,
      placement: f,
      strategy: i,
      middlewareData: d,
      rects: c,
      platform: o,
      elements: {
        reference: n,
        floating: e
      }
    });
    u = w ?? u, h = k ?? h, d = {
      ...d,
      [g]: {
        ...d[g],
        ...C
      }
    }, M && p <= 50 && (p++, typeof M == "object" && (M.placement && (f = M.placement), M.rects && (c = M.rects === !0 ? await o.getElementRects({
      reference: n,
      floating: e,
      strategy: i
    }) : M.rects), {
      x: u,
      y: h
    } = a8(c, f, a)), m = -1);
  }
  return {
    x: u,
    y: h,
    placement: f,
    strategy: i,
    middlewareData: d
  };
};
async function nO(n, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: o,
    elements: l,
    strategy: a
  } = n, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: h = "floating",
    altBoundary: f = !1,
    padding: d = 0
  } = T1(e, n), p = kG(d), g = l[f ? h === "floating" ? "reference" : "floating" : h], b = Cm(await s.getClippingRect({
    element: (t = await (s.isElement == null ? void 0 : s.isElement(g))) == null || t ? g : g.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(l.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: a
  })), w = h === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l.floating)), C = await (s.isElement == null ? void 0 : s.isElement(k)) ? await (s.getScale == null ? void 0 : s.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, M = Cm(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: w,
    offsetParent: k,
    strategy: a
  }) : w);
  return {
    top: (b.top - M.top + p.top) / C.y,
    bottom: (M.bottom - b.bottom + p.bottom) / C.y,
    left: (b.left - M.left + p.left) / C.x,
    right: (M.right - b.right + p.right) / C.x
  };
}
const CG = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: i,
        middlewareData: s,
        rects: o,
        initialPlacement: l,
        platform: a,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: h = !0,
        fallbackPlacements: f,
        fallbackStrategy: d = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: m = !0,
        ...g
      } = T1(n, e);
      if ((t = s.arrow) != null && t.alignmentOffset)
        return {};
      const b = Ea(i), w = Qo(l), k = Ea(l) === l, C = await (a.isRTL == null ? void 0 : a.isRTL(c.floating)), M = f || (k || !m ? [Sm(l)] : gG(l)), T = p !== "none";
      !f && T && M.push(...wG(l, m, p, C));
      const N = [l, ...M], B = await nO(e, g), $ = [];
      let R = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (u && $.push(B[b]), h) {
        const ie = mG(i, o, C);
        $.push(B[ie[0]], B[ie[1]]);
      }
      if (R = [...R, {
        placement: i,
        overflows: $
      }], !$.every((ie) => ie <= 0)) {
        var V, z;
        const ie = (((V = s.flip) == null ? void 0 : V.index) || 0) + 1, he = N[ie];
        if (he && (!(h === "alignment" ? w !== Qo(he) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        R.every((be) => Qo(be.placement) === w ? be.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ie,
              overflows: R
            },
            reset: {
              placement: he
            }
          };
        let Ce = (z = R.filter((ye) => ye.overflows[0] <= 0).sort((ye, be) => ye.overflows[1] - be.overflows[1])[0]) == null ? void 0 : z.placement;
        if (!Ce)
          switch (d) {
            case "bestFit": {
              var ue;
              const ye = (ue = R.filter((be) => {
                if (T) {
                  const ze = Qo(be.placement);
                  return ze === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ze === "y";
                }
                return !0;
              }).map((be) => [be.placement, be.overflows.filter((ze) => ze > 0).reduce((ze, I) => ze + I, 0)]).sort((be, ze) => be[1] - ze[1])[0]) == null ? void 0 : ue[0];
              ye && (Ce = ye);
              break;
            }
            case "initialPlacement":
              Ce = l;
              break;
          }
        if (i !== Ce)
          return {
            reset: {
              placement: Ce
            }
          };
      }
      return {};
    }
  };
}, MG = /* @__PURE__ */ new Set(["left", "top"]);
async function TG(n, e) {
  const {
    placement: t,
    platform: r,
    elements: i
  } = n, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = Ea(t), l = A1(t), a = Qo(t) === "y", c = MG.has(o) ? -1 : 1, u = s && a ? -1 : 1, h = T1(e, n);
  let {
    mainAxis: f,
    crossAxis: d,
    alignmentAxis: p
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return l && typeof p == "number" && (d = l === "end" ? p * -1 : p), a ? {
    x: d * u,
    y: f * c
  } : {
    x: f * c,
    y: d * u
  };
}
const AG = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      var t, r;
      const {
        x: i,
        y: s,
        placement: o,
        middlewareData: l
      } = e, a = await TG(e, n);
      return o === ((t = l.offset) == null ? void 0 : t.placement) && (r = l.arrow) != null && r.alignmentOffset ? {} : {
        x: i + a.x,
        y: s + a.y,
        data: {
          ...a,
          placement: o
        }
      };
    }
  };
}, OG = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r,
        placement: i
      } = e, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: l = {
          fn: (g) => {
            let {
              x: b,
              y: w
            } = g;
            return {
              x: b,
              y: w
            };
          }
        },
        ...a
      } = T1(n, e), c = {
        x: t,
        y: r
      }, u = await nO(e, a), h = Qo(Ea(i)), f = QA(h);
      let d = c[f], p = c[h];
      if (s) {
        const g = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", w = d + u[g], k = d - u[b];
        d = s8(w, d, k);
      }
      if (o) {
        const g = h === "y" ? "top" : "left", b = h === "y" ? "bottom" : "right", w = p + u[g], k = p - u[b];
        p = s8(w, p, k);
      }
      const m = l.fn({
        ...e,
        [f]: d,
        [h]: p
      });
      return {
        ...m,
        data: {
          x: m.x - t,
          y: m.y - r,
          enabled: {
            [f]: s,
            [h]: o
          }
        }
      };
    }
  };
};
function O1() {
  return typeof window < "u";
}
function iu(n) {
  return rO(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Zr(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function ko(n) {
  var e;
  return (e = (rO(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function rO(n) {
  return O1() ? n instanceof Node || n instanceof Zr(n).Node : !1;
}
function Fi(n) {
  return O1() ? n instanceof Element || n instanceof Zr(n).Element : !1;
}
function ks(n) {
  return O1() ? n instanceof HTMLElement || n instanceof Zr(n).HTMLElement : !1;
}
function c8(n) {
  return !O1() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Zr(n).ShadowRoot;
}
const EG = /* @__PURE__ */ new Set(["inline", "contents"]);
function vd(n) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: r,
    display: i
  } = Hi(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !EG.has(i);
}
const IG = /* @__PURE__ */ new Set(["table", "td", "th"]);
function DG(n) {
  return IG.has(iu(n));
}
const NG = [":popover-open", ":modal"];
function E1(n) {
  return NG.some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
const RG = ["transform", "translate", "scale", "rotate", "perspective"], PG = ["transform", "translate", "scale", "rotate", "perspective", "filter"], _G = ["paint", "layout", "strict", "content"];
function tb(n) {
  const e = nb(), t = Fi(n) ? Hi(n) : n;
  return RG.some((r) => t[r] ? t[r] !== "none" : !1) || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || PG.some((r) => (t.willChange || "").includes(r)) || _G.some((r) => (t.contain || "").includes(r));
}
function LG(n) {
  let e = pl(n);
  for (; ks(e) && !Vc(e); ) {
    if (tb(e))
      return e;
    if (E1(e))
      return null;
    e = pl(e);
  }
  return null;
}
function nb() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const BG = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Vc(n) {
  return BG.has(iu(n));
}
function Hi(n) {
  return Zr(n).getComputedStyle(n);
}
function I1(n) {
  return Fi(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function pl(n) {
  if (iu(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    c8(n) && n.host || // Fallback.
    ko(n)
  );
  return c8(e) ? e.host : e;
}
function iO(n) {
  const e = pl(n);
  return Vc(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : ks(e) && vd(e) ? e : iO(e);
}
function sO(n, e, t) {
  var r;
  e === void 0 && (e = []);
  const i = iO(n), s = i === ((r = n.ownerDocument) == null ? void 0 : r.body), o = Zr(i);
  return s ? (Xy(o), e.concat(o, o.visualViewport || [], vd(i) ? i : [], [])) : e.concat(i, sO(i, []));
}
function Xy(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function oO(n) {
  const e = Hi(n);
  let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = ks(n), s = i ? n.offsetWidth : t, o = i ? n.offsetHeight : r, l = km(t) !== s || km(r) !== o;
  return l && (t = s, r = o), {
    width: t,
    height: r,
    $: l
  };
}
function lO(n) {
  return Fi(n) ? n : n.contextElement;
}
function kc(n) {
  const e = lO(n);
  if (!ks(e))
    return bs(1);
  const t = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = oO(e);
  let o = (s ? km(t.width) : t.width) / r, l = (s ? km(t.height) : t.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: o,
    y: l
  };
}
const zG = /* @__PURE__ */ bs(0);
function aO(n) {
  const e = Zr(n);
  return !nb() || !e.visualViewport ? zG : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function FG(n, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== Zr(n) ? !1 : e;
}
function Wf(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const i = n.getBoundingClientRect(), s = lO(n);
  let o = bs(1);
  e && (r ? Fi(r) && (o = kc(r)) : o = kc(n));
  const l = FG(s, t, r) ? aO(s) : bs(0);
  let a = (i.left + l.x) / o.x, c = (i.top + l.y) / o.y, u = i.width / o.x, h = i.height / o.y;
  if (s) {
    const f = Zr(s), d = r && Fi(r) ? Zr(r) : r;
    let p = f, m = Xy(p);
    for (; m && r && d !== p; ) {
      const g = kc(m), b = m.getBoundingClientRect(), w = Hi(m), k = b.left + (m.clientLeft + parseFloat(w.paddingLeft)) * g.x, C = b.top + (m.clientTop + parseFloat(w.paddingTop)) * g.y;
      a *= g.x, c *= g.y, u *= g.x, h *= g.y, a += k, c += C, p = Zr(m), m = Xy(p);
    }
  }
  return Cm({
    width: u,
    height: h,
    x: a,
    y: c
  });
}
function D1(n, e) {
  const t = I1(n).scrollLeft;
  return e ? e.left + t : Wf(ko(n)).left + t;
}
function cO(n, e) {
  const t = n.getBoundingClientRect(), r = t.left + e.scrollLeft - D1(n, t), i = t.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function HG(n) {
  let {
    elements: e,
    rect: t,
    offsetParent: r,
    strategy: i
  } = n;
  const s = i === "fixed", o = ko(r), l = e ? E1(e.floating) : !1;
  if (r === o || l && s)
    return t;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = bs(1);
  const u = bs(0), h = ks(r);
  if ((h || !h && !s) && ((iu(r) !== "body" || vd(o)) && (a = I1(r)), ks(r))) {
    const d = Wf(r);
    c = kc(r), u.x = d.x + r.clientLeft, u.y = d.y + r.clientTop;
  }
  const f = o && !h && !s ? cO(o, a) : bs(0);
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - a.scrollLeft * c.x + u.x + f.x,
    y: t.y * c.y - a.scrollTop * c.y + u.y + f.y
  };
}
function $G(n) {
  return Array.from(n.getClientRects());
}
function VG(n) {
  const e = ko(n), t = I1(n), r = n.ownerDocument.body, i = xc(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = xc(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -t.scrollLeft + D1(n);
  const l = -t.scrollTop;
  return Hi(r).direction === "rtl" && (o += xc(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: o,
    y: l
  };
}
const u8 = 25;
function qG(n, e) {
  const t = Zr(n), r = ko(n), i = t.visualViewport;
  let s = r.clientWidth, o = r.clientHeight, l = 0, a = 0;
  if (i) {
    s = i.width, o = i.height;
    const u = nb();
    (!u || u && e === "fixed") && (l = i.offsetLeft, a = i.offsetTop);
  }
  const c = D1(r);
  if (c <= 0) {
    const u = r.ownerDocument, h = u.body, f = getComputedStyle(h), d = u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, p = Math.abs(r.clientWidth - h.clientWidth - d);
    p <= u8 && (s -= p);
  } else c <= u8 && (s += c);
  return {
    width: s,
    height: o,
    x: l,
    y: a
  };
}
const WG = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function jG(n, e) {
  const t = Wf(n, !0, e === "fixed"), r = t.top + n.clientTop, i = t.left + n.clientLeft, s = ks(n) ? kc(n) : bs(1), o = n.clientWidth * s.x, l = n.clientHeight * s.y, a = i * s.x, c = r * s.y;
  return {
    width: o,
    height: l,
    x: a,
    y: c
  };
}
function h8(n, e, t) {
  let r;
  if (e === "viewport")
    r = qG(n, t);
  else if (e === "document")
    r = VG(ko(n));
  else if (Fi(e))
    r = jG(e, t);
  else {
    const i = aO(n);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return Cm(r);
}
function uO(n, e) {
  const t = pl(n);
  return t === e || !Fi(t) || Vc(t) ? !1 : Hi(t).position === "fixed" || uO(t, e);
}
function UG(n, e) {
  const t = e.get(n);
  if (t)
    return t;
  let r = sO(n, []).filter((l) => Fi(l) && iu(l) !== "body"), i = null;
  const s = Hi(n).position === "fixed";
  let o = s ? pl(n) : n;
  for (; Fi(o) && !Vc(o); ) {
    const l = Hi(o), a = tb(o);
    !a && l.position === "fixed" && (i = null), (s ? !a && !i : !a && l.position === "static" && !!i && WG.has(i.position) || vd(o) && !a && uO(n, o)) ? r = r.filter((u) => u !== o) : i = l, o = pl(o);
  }
  return e.set(n, r), r;
}
function KG(n) {
  let {
    element: e,
    boundary: t,
    rootBoundary: r,
    strategy: i
  } = n;
  const o = [...t === "clippingAncestors" ? E1(e) ? [] : UG(e, this._c) : [].concat(t), r], l = o[0], a = o.reduce((c, u) => {
    const h = h8(e, u, i);
    return c.top = xc(h.top, c.top), c.right = Yy(h.right, c.right), c.bottom = Yy(h.bottom, c.bottom), c.left = xc(h.left, c.left), c;
  }, h8(e, l, i));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function GG(n) {
  const {
    width: e,
    height: t
  } = oO(n);
  return {
    width: e,
    height: t
  };
}
function YG(n, e, t) {
  const r = ks(e), i = ko(e), s = t === "fixed", o = Wf(n, !0, s, e);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = bs(0);
  function c() {
    a.x = D1(i);
  }
  if (r || !r && !s)
    if ((iu(e) !== "body" || vd(i)) && (l = I1(e)), r) {
      const d = Wf(e, !0, s, e);
      a.x = d.x + e.clientLeft, a.y = d.y + e.clientTop;
    } else i && c();
  s && !r && i && c();
  const u = i && !r && !s ? cO(i, l) : bs(0), h = o.left + l.scrollLeft - a.x - u.x, f = o.top + l.scrollTop - a.y - u.y;
  return {
    x: h,
    y: f,
    width: o.width,
    height: o.height
  };
}
function A2(n) {
  return Hi(n).position === "static";
}
function f8(n, e) {
  if (!ks(n) || Hi(n).position === "fixed")
    return null;
  if (e)
    return e(n);
  let t = n.offsetParent;
  return ko(n) === t && (t = t.ownerDocument.body), t;
}
function hO(n, e) {
  const t = Zr(n);
  if (E1(n))
    return t;
  if (!ks(n)) {
    let i = pl(n);
    for (; i && !Vc(i); ) {
      if (Fi(i) && !A2(i))
        return i;
      i = pl(i);
    }
    return t;
  }
  let r = f8(n, e);
  for (; r && DG(r) && A2(r); )
    r = f8(r, e);
  return r && Vc(r) && A2(r) && !tb(r) ? t : r || LG(n) || t;
}
const JG = async function(n) {
  const e = this.getOffsetParent || hO, t = this.getDimensions, r = await t(n.floating);
  return {
    reference: YG(n.reference, await e(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function XG(n) {
  return Hi(n).direction === "rtl";
}
const ZG = {
  convertOffsetParentRelativeRectToViewportRelativeRect: HG,
  getDocumentElement: ko,
  getClippingRect: KG,
  getOffsetParent: hO,
  getElementRects: JG,
  getClientRects: $G,
  getDimensions: GG,
  getScale: kc,
  isElement: Fi,
  isRTL: XG
}, ml = AG, d8 = OG, Mm = CG, $i = (n, e, t) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: ZG,
    ...t
  }, s = {
    ...i.platform,
    _c: r
  };
  return SG(n, e, {
    ...i,
    platform: s
  });
};
function wd(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-block",
      ...e
    }
  }), n;
}
const QG = (n) => !gs((t) => t.type.name === "table")(n), N1 = Mt(
  { filterNodes: QG },
  "blockConfig"
);
wd(N1, {
  displayName: "Ctx<blockConfig>"
});
function eY(n, e, t) {
  if (!n.dom.parentElement) return null;
  try {
    const i = n.posAtCoords({
      left: e.x,
      top: e.y
    })?.inside;
    if (i == null || i < 0) return null;
    let s = n.state.doc.resolve(i), o = n.state.doc.nodeAt(i), l = n.nodeDOM(i);
    const a = (u) => {
      const h = s.depth >= 1 && s.index(s.depth) === 0;
      if (!(u || h)) return;
      const d = s.before(s.depth);
      o = n.state.doc.nodeAt(d), l = n.nodeDOM(d), s = n.state.doc.resolve(d), t(s, o) || a(!0);
    }, c = t(s, o);
    return a(!c), !l || !o ? null : { node: o, $pos: s, el: l };
  } catch {
    return null;
  }
}
const p8 = Yd.ie && Yd.ie_version < 15 || Yd.ios && Yd.webkit_version < 604, m8 = 20;
class tY {
  constructor() {
    this.#e = () => {
      if (!this.#n) return null;
      const e = this.#n, t = this.#o;
      if (t && $e.isSelectable(e.node)) {
        const r = $e.create(
          t.state.doc,
          e.$pos.pos
        );
        return t.dispatch(t.state.tr.setSelection(r)), t.focus(), this.#r = r, r;
      }
      return null;
    }, this.#r = null, this.#n = null, this.#a = void 0, this.#i = !1, this.#c = () => {
      this.#l?.({ type: "hide" }), this.#n = null;
    }, this.#u = (e) => {
      this.#n = e, this.#l?.({ type: "show", active: e });
    }, this.bind = (e, t) => {
      this.#t = e, this.#l = t;
    }, this.addEvent = (e) => {
      e.addEventListener("mousedown", this.#h), e.addEventListener("mouseup", this.#d), e.addEventListener("dragstart", this.#f);
    }, this.removeEvent = (e) => {
      e.removeEventListener("mousedown", this.#h), e.removeEventListener("mouseup", this.#d), e.removeEventListener("dragstart", this.#f);
    }, this.unBind = () => {
      this.#l = void 0;
    }, this.#h = () => {
      this.#a = this.#n?.el.getBoundingClientRect(), this.#e();
    }, this.#d = () => {
      if (!this.#i) {
        requestAnimationFrame(() => {
          this.#a && this.#o?.focus();
        });
        return;
      }
      this.#i = !1, this.#r = null;
    }, this.#f = (e) => {
      this.#i = !0;
      const t = this.#o;
      if (!t) return;
      t.dom.dataset.dragging = "true";
      const r = this.#r;
      if (e.dataTransfer && r) {
        const i = r.content();
        e.dataTransfer.effectAllowed = "copyMove";
        const { dom: s, text: o } = t.serializeForClipboard(i);
        e.dataTransfer.clearData(), e.dataTransfer.setData(
          p8 ? "Text" : "text/html",
          s.innerHTML
        ), p8 || e.dataTransfer.setData("text/plain", o);
        const l = this.#n?.el;
        l && e.dataTransfer.setDragImage(l, 0, 0), t.dragging = {
          slice: i,
          move: !0
        };
      }
    }, this.keydownCallback = (e) => (this.#c(), this.#i = !1, e.dom.dataset.dragging = "false", !1), this.#p = y1((e, t) => {
      if (!e.editable) return;
      const r = e.dom.getBoundingClientRect(), i = r.left + r.width / 2;
      if (!(e.root.elementFromPoint(i, t.clientY) instanceof Element)) {
        this.#c();
        return;
      }
      const o = this.#s;
      if (!o) return;
      const l = eY(
        e,
        { x: i, y: t.clientY },
        o
      );
      if (!l) {
        this.#c();
        return;
      }
      this.#u(l);
    }, 200), this.mousemoveCallback = (e, t) => (e.composing || !e.editable || this.#p(e, t), !1), this.dragoverCallback = (e, t) => {
      if (this.#i) {
        const r = this.#o?.dom.parentElement;
        if (!r) return !1;
        const i = r.scrollHeight > r.clientHeight, s = r.getBoundingClientRect();
        if (i) {
          if (r.scrollTop > 0 && Math.abs(t.y - s.y) < m8) {
            const a = r.scrollTop > 10 ? r.scrollTop - 10 : 0;
            return r.scrollTop = a, !1;
          }
          const o = Math.round(e.dom.getBoundingClientRect().height);
          if (Math.round(r.scrollTop + s.height) < o && Math.abs(t.y - (s.height + s.y)) < m8) {
            const a = r.scrollTop + 10;
            return r.scrollTop = a, !1;
          }
        }
      }
      return !1;
    }, this.dragenterCallback = (e) => {
      e.dragging && (this.#i = !0, e.dom.dataset.dragging = "true");
    }, this.dragleaveCallback = (e, t) => {
      const r = t.clientX, i = t.clientY;
      (r < 0 || i < 0 || r > window.innerWidth || i > window.innerHeight) && (this.#n = null, this.#m(e));
    }, this.dropCallback = (e) => (this.#m(e), !1), this.dragendCallback = (e) => {
      this.#m(e);
    }, this.#m = (e) => {
      this.#i = !1, e.dom.dataset.dragging = "false";
    };
  }
  /// @internal
  #t;
  #e;
  #r;
  #n;
  #a;
  #i;
  /// @internal
  get #s() {
    try {
      return this.#t?.get(N1.key).filterNodes;
    } catch {
      return;
    }
  }
  /// @internal
  get #o() {
    return this.#t?.get(Ct);
  }
  /// @internal
  #l;
  #c;
  #u;
  #h;
  #d;
  #f;
  #p;
  #m;
}
const rb = Mt(() => new tY(), "blockService"), R1 = Mt(
  {},
  "blockServiceInstance"
);
wd(rb, {
  displayName: "Ctx<blockService>"
});
wd(R1, {
  displayName: "Ctx<blockServiceInstance>"
});
const P1 = Mt({}, "blockSpec");
wd(P1, {
  displayName: "Ctx<blockSpec>"
});
const ib = kn((n) => {
  const e = new en("MILKDOWN_BLOCK"), r = n.get(rb.key)();
  n.set(R1.key, r);
  const i = n.get(P1.key);
  return new Ut({
    key: e,
    ...i,
    props: {
      ...i.props,
      handleDOMEvents: {
        drop: (s) => r.dropCallback(s),
        pointermove: (s, o) => r.mousemoveCallback(s, o),
        keydown: (s) => r.keydownCallback(s),
        dragover: (s, o) => r.dragoverCallback(s, o),
        dragleave: (s, o) => r.dragleaveCallback(s, o),
        dragenter: (s) => r.dragenterCallback(s),
        dragend: (s) => r.dragendCallback(s)
      }
    }
  });
});
wd(ib, {
  displayName: "Prose<block>"
});
class nY {
  constructor(e) {
    this.#n = null, this.#i = !1, this.update = () => {
      requestAnimationFrame(() => {
        if (!this.#i)
          try {
            this.#h(), this.#i = !0;
          } catch {
          }
      });
    }, this.destroy = () => {
      this.#r?.unBind(), this.#r?.removeEvent(this.#t), this.#t.remove();
    }, this.show = (t) => {
      const r = t.el, i = this.#e.get(Ct).dom, s = {
        ctx: this.#e,
        active: t,
        editorDom: i,
        blockDom: this.#t
      }, o = {
        contextElement: r,
        getBoundingClientRect: () => this.#c ? this.#c(s) : r.getBoundingClientRect()
      }, l = [Mm()];
      if (this.#l) {
        const a = this.#l(s), c = ml(a);
        l.push(c);
      }
      $i(o, this.#t, {
        placement: this.#u ? this.#u(s) : "left",
        middleware: [...l, ...this.#s],
        ...this.#o
      }).then(({ x: a, y: c }) => {
        Object.assign(this.#t.style, {
          left: `${a}px`,
          top: `${c}px`
        }), this.#t.dataset.show = "true";
      }).catch(console.error);
    }, this.hide = () => {
      this.#t.dataset.show = "false";
    }, this.#e = e.ctx, this.#t = e.content, this.#l = e.getOffset, this.#c = e.getPosition, this.#u = e.getPlacement, this.#s = e.middleware ?? [], this.#o = e.floatingUIOptions ?? {}, this.#a = e.root, this.hide();
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  #n;
  /// @internal
  #a;
  #i;
  /// @internal
  #s;
  /// @internal
  #o;
  /// @internal
  #l;
  /// @internal
  #c;
  /// @internal
  #u;
  /// The context of current active node.
  get active() {
    return this.#n;
  }
  /// @internal
  #h() {
    const e = this.#e.get(Ct);
    (this.#a ?? e.dom.parentElement ?? document.body).appendChild(this.#t);
    const r = this.#e.get(R1.key);
    r.bind(this.#e, (i) => {
      i.type === "hide" ? (this.hide(), this.#n = null) : i.type === "show" && (this.show(i.active), this.#n = i.active);
    }), this.#r = r, this.#r.addEvent(this.#t), this.#t.draggable = !0;
  }
}
const _1 = [
  P1,
  N1,
  rb,
  R1,
  ib
];
_1.key = P1.key;
_1.pluginKey = ib.key;
function rY(n, e) {
  return function(t, r) {
    let { $from: i, $to: s, node: o } = t.selection;
    if (o && o.isBlock || i.depth < 2 || !i.sameParent(s))
      return !1;
    let l = i.node(-1);
    if (l.type != n)
      return !1;
    if (i.parent.content.size == 0 && i.node(-1).childCount == i.indexAfter(-1)) {
      if (i.depth == 3 || i.node(-3).type != n || i.index(-2) != i.node(-2).childCount - 1)
        return !1;
      if (r) {
        let h = ce.empty, f = i.index(-1) ? 1 : i.index(-2) ? 2 : 3;
        for (let b = i.depth - f; b >= i.depth - 3; b--)
          h = ce.from(i.node(b).copy(h));
        let d = i.indexAfter(-1) < i.node(-2).childCount ? 1 : i.indexAfter(-2) < i.node(-3).childCount ? 2 : 3;
        h = h.append(ce.from(n.createAndFill()));
        let p = i.before(i.depth - (f - 1)), m = t.tr.replace(p, i.after(-d), new me(h, 4 - f, 0)), g = -1;
        m.doc.nodesBetween(p, m.doc.content.size, (b, w) => {
          if (g > -1)
            return !1;
          b.isTextblock && b.content.size == 0 && (g = w + 1);
        }), g > -1 && m.setSelection(Ge.near(m.doc.resolve(g))), r(m.scrollIntoView());
      }
      return !0;
    }
    let a = s.pos == i.end() ? l.contentMatchAt(0).defaultType : null, c = t.tr.delete(i.pos, s.pos), u = a ? [null, { type: a }] : void 0;
    return Hh(c.doc, i.pos, 2, u) ? (r && r(c.split(i.pos, 2, u).scrollIntoView()), !0) : !1;
  };
}
function iY(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == n);
    return s ? t ? r.node(s.depth - 1).type == n ? sY(e, t, n, s) : oY(e, t, s) : !0 : !1;
  };
}
function sY(n, e, t, r) {
  let i = n.tr, s = r.end, o = r.$to.end(r.depth);
  s < o && (i.step(new Gn(s - 1, o, s, o, new me(ce.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new fS(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
  const l = r1(r);
  if (l == null)
    return !1;
  i.lift(r, l);
  let a = i.doc.resolve(i.mapping.map(s, -1) - 1);
  return i1(i.doc, a.pos) && a.nodeBefore.type == a.nodeAfter.type && i.join(a.pos), e(i.scrollIntoView()), !0;
}
function oY(n, e, t) {
  let r = n.tr, i = t.parent;
  for (let d = t.end, p = t.endIndex - 1, m = t.startIndex; p > m; p--)
    d -= i.child(p).nodeSize, r.delete(d - 1, d + 1);
  let s = r.doc.resolve(t.start), o = s.nodeAfter;
  if (r.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize)
    return !1;
  let l = t.startIndex == 0, a = t.endIndex == i.childCount, c = s.node(-1), u = s.index(-1);
  if (!c.canReplace(u + (l ? 0 : 1), u + 1, o.content.append(a ? ce.empty : ce.from(i))))
    return !1;
  let h = s.pos, f = h + o.nodeSize;
  return r.step(new Gn(h - (l ? 1 : 0), f + (a ? 1 : 0), h + 1, f - 1, new me((l ? ce.empty : ce.from(i.copy(ce.empty))).append(a ? ce.empty : ce.from(i.copy(ce.empty))), l ? 0 : 1, a ? 0 : 1), l ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function lY(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (c) => c.childCount > 0 && c.firstChild.type == n);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let l = s.parent, a = l.child(o - 1);
    if (a.type != n)
      return !1;
    if (t) {
      let c = a.lastChild && a.lastChild.type == l.type, u = ce.from(c ? n.create() : null), h = new me(ce.from(n.create(null, ce.from(l.type.create(null, u)))), c ? 3 : 1, 0), f = s.start, d = s.end;
      t(e.tr.step(new Gn(f - (c ? 3 : 1), d, f, d, h, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function aY(n) {
  const e = /* @__PURE__ */ new Map();
  if (!n || !n.type)
    throw new Error("mdast-util-definitions expected node");
  return kl(n, "definition", function(r) {
    const i = g8(r.identifier);
    i && !e.get(i) && e.set(i, r);
  }), t;
  function t(r) {
    const i = g8(r);
    return e.get(i);
  }
}
function g8(n) {
  return String(n || "").toUpperCase();
}
function cY() {
  return function(n) {
    const e = aY(n);
    kl(n, function(t, r, i) {
      if (t.type === "definition" && i !== void 0 && typeof r == "number")
        return i.children.splice(r, 1), [I4, r];
      if (t.type === "imageReference" || t.type === "linkReference") {
        const s = e(t.identifier);
        if (s && i && typeof r == "number")
          return i.children[r] = t.type === "imageReference" ? { type: "image", url: s.url, title: s.title, alt: t.alt } : {
            type: "link",
            url: s.url,
            title: s.title,
            children: t.children
          }, [I4, r];
      }
    });
  };
}
function fO(n, e) {
  if (!(e.childCount >= 1 && e.lastChild?.type.name === "hardbreak")) {
    n.next(e.content);
    return;
  }
  const r = [];
  e.content.forEach((i, s, o) => {
    o !== e.childCount - 1 && r.push(i);
  }), n.next(ce.fromArray(r));
}
function K(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/preset-commonmark",
      ...e
    }
  }), n;
}
const sb = bd("emphasis");
K(sb, {
  displayName: "Attr<emphasis>",
  group: "Emphasis"
});
const _a = ru("emphasis", (n) => ({
  attrs: {
    marker: {
      default: n.get(qh).emphasis || "*",
      validate: "string"
    }
  },
  parseDOM: [
    { tag: "i" },
    { tag: "em" },
    { style: "font-style", getAttrs: (e) => e === "italic" }
  ],
  toDOM: (e) => ["em", n.get(sb.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "emphasis",
    runner: (e, t, r) => {
      e.openMark(r, { marker: t.marker }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "emphasis",
    runner: (e, t) => {
      e.withMark(t, "emphasis", void 0, {
        marker: t.attrs.marker
      });
    }
  }
}));
K(_a.mark, {
  displayName: "MarkSchema<emphasis>",
  group: "Emphasis"
});
K(_a.ctx, {
  displayName: "MarkSchemaCtx<emphasis>",
  group: "Emphasis"
});
const L1 = Ye("ToggleEmphasis", (n) => () => l1(_a.type(n)));
K(L1, {
  displayName: "Command<toggleEmphasisCommand>",
  group: "Emphasis"
});
const dO = Qn((n) => ld(/(?:^|[^*])\*([^*]+)\*$/, _a.type(n), {
  getAttr: () => ({
    marker: "*"
  }),
  updateCaptured: ({ fullMatch: e, start: t }) => e.startsWith("*") ? {} : { fullMatch: e.slice(1), start: t + 1 }
}));
K(dO, {
  displayName: "InputRule<emphasis>|Star",
  group: "Emphasis"
});
const pO = Qn((n) => ld(/\b_(?![_\s])(.*?[^_\s])_\b/, _a.type(n), {
  getAttr: () => ({
    marker: "_"
  }),
  updateCaptured: ({ fullMatch: e, start: t }) => e.startsWith("_") ? {} : { fullMatch: e.slice(1), start: t + 1 }
}));
K(pO, {
  displayName: "InputRule<emphasis>|Underscore",
  group: "Emphasis"
});
const ob = Pr("emphasisKeymap", {
  ToggleEmphasis: {
    shortcuts: "Mod-i",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(L1.key);
    }
  }
});
K(ob.ctx, {
  displayName: "KeymapCtx<emphasis>",
  group: "Emphasis"
});
K(ob.shortcuts, {
  displayName: "Keymap<emphasis>",
  group: "Emphasis"
});
const lb = bd("strong");
K(lb, {
  displayName: "Attr<strong>",
  group: "Strong"
});
const su = ru("strong", (n) => ({
  attrs: {
    marker: {
      default: n.get(qh).strong || "*",
      validate: "string"
    }
  },
  parseDOM: [
    // This works around a Google Docs misbehavior where
    // pasted content will be inexplicably wrapped in `<b>`
    // tags with a font-weight normal.
    {
      tag: "b",
      getAttrs: (e) => e.style.fontWeight != "normal" && null
    },
    { tag: "strong" },
    { style: "font-style", getAttrs: (e) => e === "bold" },
    { style: "font-weight=400", clearMark: (e) => e.type.name == "strong" },
    {
      style: "font-weight",
      getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
    }
  ],
  toDOM: (e) => ["strong", n.get(lb.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "strong",
    runner: (e, t, r) => {
      e.openMark(r, { marker: t.marker }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strong",
    runner: (e, t) => {
      e.withMark(t, "strong", void 0, {
        marker: t.attrs.marker
      });
    }
  }
}));
K(su.mark, {
  displayName: "MarkSchema<strong>",
  group: "Strong"
});
K(su.ctx, {
  displayName: "MarkSchemaCtx<strong>",
  group: "Strong"
});
const B1 = Ye("ToggleStrong", (n) => () => l1(su.type(n)));
K(B1, {
  displayName: "Command<toggleStrongCommand>",
  group: "Strong"
});
const mO = Qn((n) => ld(
  new RegExp("(?<![\\w:/])(?:\\*\\*|__)([^*_]+?)(?:\\*\\*|__)(?![\\w/])$"),
  su.type(n),
  {
    getAttr: (e) => ({
      marker: e[0].startsWith("*") ? "*" : "_"
    })
  }
));
K(mO, {
  displayName: "InputRule<strong>",
  group: "Strong"
});
const ab = Pr("strongKeymap", {
  ToggleBold: {
    shortcuts: ["Mod-b"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(B1.key);
    }
  }
});
K(ab.ctx, {
  displayName: "KeymapCtx<strong>",
  group: "Strong"
});
K(ab.shortcuts, {
  displayName: "Keymap<strong>",
  group: "Strong"
});
const cb = bd("inlineCode");
K(cb, {
  displayName: "Attr<inlineCode>",
  group: "InlineCode"
});
const Qs = ru("inlineCode", (n) => ({
  priority: 100,
  code: !0,
  parseDOM: [{ tag: "code" }],
  toDOM: (e) => ["code", n.get(cb.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "inlineCode",
    runner: (e, t, r) => {
      e.openMark(r), e.addText(t.value), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "inlineCode",
    runner: (e, t, r) => {
      e.withMark(t, "inlineCode", r.text || "");
    }
  }
}));
K(Qs.mark, {
  displayName: "MarkSchema<inlineCode>",
  group: "InlineCode"
});
K(Qs.ctx, {
  displayName: "MarkSchemaCtx<inlineCode>",
  group: "InlineCode"
});
const z1 = Ye(
  "ToggleInlineCode",
  (n) => () => (e, t) => {
    const { selection: r, tr: i } = e;
    if (r.empty) return !1;
    const { from: s, to: o } = r;
    return e.doc.rangeHasMark(s, o, Qs.type(n)) ? (t?.(i.removeMark(s, o, Qs.type(n))), !0) : (Object.keys(e.schema.marks).filter(
      (c) => c !== Qs.type.name
    ).map((c) => e.schema.marks[c]).forEach((c) => {
      i.removeMark(s, o, c);
    }), t?.(i.addMark(s, o, Qs.type(n).create())), !0);
  }
);
K(z1, {
  displayName: "Command<toggleInlineCodeCommand>",
  group: "InlineCode"
});
const gO = Qn((n) => ld(/(?:`)([^`]+)(?:`)$/, Qs.type(n)));
K(gO, {
  displayName: "InputRule<inlineCodeInputRule>",
  group: "InlineCode"
});
const ub = Pr("inlineCodeKeymap", {
  ToggleInlineCode: {
    shortcuts: "Mod-e",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(z1.key);
    }
  }
});
K(ub.ctx, {
  displayName: "KeymapCtx<inlineCode>",
  group: "InlineCode"
});
K(ub.shortcuts, {
  displayName: "Keymap<inlineCode>",
  group: "InlineCode"
});
const hb = bd("link");
K(hb, {
  displayName: "Attr<link>",
  group: "Link"
});
const Ri = ru("link", (n) => ({
  attrs: {
    href: { validate: "string" },
    title: { default: null, validate: "string|null" }
  },
  parseDOM: [
    {
      tag: "a[href]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return {
          href: e.getAttribute("href"),
          title: e.getAttribute("title")
        };
      }
    }
  ],
  toDOM: (e) => ["a", { ...n.get(hb.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: (e) => e.type === "link",
    runner: (e, t, r) => {
      const i = t.url, s = t.title;
      e.openMark(r, { href: i, title: s }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "link",
    runner: (e, t) => {
      e.withMark(t, "link", void 0, {
        title: t.attrs.title,
        url: t.attrs.href
      });
    }
  }
}));
K(Ri.mark, {
  displayName: "MarkSchema<link>",
  group: "Link"
});
const yO = Ye(
  "ToggleLink",
  (n) => (e = {}) => l1(Ri.type(n), e)
);
K(yO, {
  displayName: "Command<toggleLinkCommand>",
  group: "Link"
});
const bO = Ye(
  "UpdateLink",
  (n) => (e = {}) => (t, r) => {
    if (!r) return !1;
    let i, s = -1;
    const { selection: o } = t, { from: l, to: a } = o;
    if (t.doc.nodesBetween(l, l === a ? a + 1 : a, (p, m) => {
      if (Ri.type(n).isInSet(p.marks))
        return i = p, s = m, !1;
    }), !i) return !1;
    const c = i.marks.find(({ type: p }) => p === Ri.type(n));
    if (!c) return !1;
    const u = s, h = s + i.nodeSize, { tr: f } = t, d = Ri.type(n).create({ ...c.attrs, ...e });
    return d ? (r(
      f.removeMark(u, h, c).addMark(u, h, d).setSelection(new Ee(f.selection.$anchor)).scrollIntoView()
    ), !0) : !1;
  }
);
K(bO, {
  displayName: "Command<updateLinkCommand>",
  group: "Link"
});
const vO = eb("doc", () => ({
  content: "block+",
  parseMarkdown: {
    match: ({ type: n }) => n === "root",
    runner: (n, e, t) => {
      n.injectRoot(e, t);
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "doc",
    runner: (n, e) => {
      n.openNode("root"), n.next(e.content);
    }
  }
}));
K(vO, {
  displayName: "NodeSchema<doc>",
  group: "Doc"
});
function uY(n) {
  return X5(
    n,
    (e) => e.type === "html" && ["<br />", "<br>", "<br >", "<br/>"].includes(
      e.value?.trim()
    ),
    (e, t) => {
      if (!t.length) return;
      const r = t[t.length - 1];
      if (!r) return;
      const i = r.children.indexOf(e);
      i !== -1 && r.children.splice(i, 1);
    },
    !0
  );
}
const F1 = Ts(
  "remark-preserve-empty-line",
  () => () => uY
);
K(F1.plugin, {
  displayName: "Remark<remarkPreserveEmptyLine>",
  group: "Remark"
});
K(F1.options, {
  displayName: "RemarkConfig<remarkPreserveEmptyLine>",
  group: "Remark"
});
const fb = qi("paragraph");
K(fb, {
  displayName: "Attr<paragraph>",
  group: "Paragraph"
});
const As = hn("paragraph", (n) => ({
  content: "inline*",
  group: "block",
  parseDOM: [{ tag: "p" }],
  toDOM: (e) => ["p", n.get(fb.key)(e), 0],
  parseMarkdown: {
    match: (e) => e.type === "paragraph",
    runner: (e, t, r) => {
      e.openNode(r), t.children ? e.next(t.children) : e.addText(t.value || ""), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "paragraph",
    runner: (e, t) => {
      const i = n.get(Ct).state?.doc.lastChild;
      e.openNode("paragraph"), (!t.content || t.content.size === 0) && t !== i && hY(n) ? e.addNode("html", void 0, "<br />") : fO(e, t), e.closeNode();
    }
  }
}));
function hY(n) {
  let e = !1;
  try {
    n.get(F1.id), e = !0;
  } catch {
    e = !1;
  }
  return e;
}
K(As.node, {
  displayName: "NodeSchema<paragraph>",
  group: "Paragraph"
});
K(As.ctx, {
  displayName: "NodeSchemaCtx<paragraph>",
  group: "Paragraph"
});
const db = Ye(
  "TurnIntoText",
  (n) => () => xf(As.type(n))
);
K(db, {
  displayName: "Command<turnIntoTextCommand>",
  group: "Paragraph"
});
const pb = Pr("paragraphKeymap", {
  TurnIntoText: {
    shortcuts: "Mod-Alt-0",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(db.key);
    }
  }
});
K(pb.ctx, {
  displayName: "KeymapCtx<paragraph>",
  group: "Paragraph"
});
K(pb.shortcuts, {
  displayName: "Keymap<paragraph>",
  group: "Paragraph"
});
const fY = Array(6).fill(0).map((n, e) => e + 1);
function dY(n) {
  return n.textContent.toLowerCase().trim().replace(/\s+/g, "-");
}
const H1 = Mt(
  dY,
  "headingIdGenerator"
);
K(H1, {
  displayName: "Ctx<HeadingIdGenerator>",
  group: "Heading"
});
const mb = qi("heading");
K(mb, {
  displayName: "Attr<heading>",
  group: "Heading"
});
const Ur = hn("heading", (n) => {
  const e = n.get(H1.key);
  return {
    content: "inline*",
    group: "block",
    defining: !0,
    attrs: {
      id: {
        default: "",
        validate: "string"
      },
      level: {
        default: 1,
        validate: "number"
      }
    },
    parseDOM: fY.map((t) => ({
      tag: `h${t}`,
      getAttrs: (r) => {
        if (!(r instanceof HTMLElement)) throw Vi(r);
        return { level: t, id: r.id };
      }
    })),
    toDOM: (t) => [
      `h${t.attrs.level}`,
      {
        ...n.get(mb.key)(t),
        id: t.attrs.id || e(t)
      },
      0
    ],
    parseMarkdown: {
      match: ({ type: t }) => t === "heading",
      runner: (t, r, i) => {
        const s = r.depth;
        t.openNode(i, { level: s }), t.next(r.children), t.closeNode();
      }
    },
    toMarkdown: {
      match: (t) => t.type.name === "heading",
      runner: (t, r) => {
        t.openNode("heading", void 0, { depth: r.attrs.level }), fO(t, r), t.closeNode();
      }
    }
  };
});
K(Ur.node, {
  displayName: "NodeSchema<heading>",
  group: "Heading"
});
K(Ur.ctx, {
  displayName: "NodeSchemaCtx<heading>",
  group: "Heading"
});
const wO = Qn((n) => f3(
  /^(?<hashes>#+)\s$/,
  Ur.type(n),
  (e) => {
    const t = e.groups?.hashes?.length || 0, r = n.get(Ct), { $from: i } = r.state.selection, s = i.node();
    if (s.type.name === "heading") {
      let o = Number(s.attrs.level) + Number(t);
      return o > 6 && (o = 6), { level: o };
    }
    return { level: t };
  }
));
K(wO, {
  displayName: "InputRule<wrapInHeadingInputRule>",
  group: "Heading"
});
const Ho = Ye("WrapInHeading", (n) => (e) => (e ??= 1, e < 1 ? xf(As.type(n)) : xf(Ur.type(n), { level: e })));
K(Ho, {
  displayName: "Command<wrapInHeadingCommand>",
  group: "Heading"
});
const gb = Ye(
  "DowngradeHeading",
  (n) => () => (e, t, r) => {
    const { $from: i } = e.selection, s = i.node();
    if (s.type !== Ur.type(n) || !e.selection.empty || i.parentOffset !== 0)
      return !1;
    const o = s.attrs.level - 1;
    return o ? (t?.(
      e.tr.setNodeMarkup(e.selection.$from.before(), void 0, {
        ...s.attrs,
        level: o
      })
    ), !0) : xf(As.type(n))(e, t, r);
  }
);
K(gb, {
  displayName: "Command<downgradeHeadingCommand>",
  group: "Heading"
});
const yb = Pr("headingKeymap", {
  TurnIntoH1: {
    shortcuts: "Mod-Alt-1",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 1);
    }
  },
  TurnIntoH2: {
    shortcuts: "Mod-Alt-2",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 2);
    }
  },
  TurnIntoH3: {
    shortcuts: "Mod-Alt-3",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 3);
    }
  },
  TurnIntoH4: {
    shortcuts: "Mod-Alt-4",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 4);
    }
  },
  TurnIntoH5: {
    shortcuts: "Mod-Alt-5",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 5);
    }
  },
  TurnIntoH6: {
    shortcuts: "Mod-Alt-6",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 6);
    }
  },
  DowngradeHeading: {
    shortcuts: ["Delete", "Backspace"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(gb.key);
    }
  }
});
K(yb.ctx, {
  displayName: "KeymapCtx<heading>",
  group: "Heading"
});
K(yb.shortcuts, {
  displayName: "Keymap<heading>",
  group: "Heading"
});
const bb = qi("blockquote");
K(bb, {
  displayName: "Attr<blockquote>",
  group: "Blockquote"
});
const ou = hn(
  "blockquote",
  (n) => ({
    content: "block+",
    group: "block",
    defining: !0,
    parseDOM: [{ tag: "blockquote" }],
    toDOM: (e) => ["blockquote", n.get(bb.key)(e), 0],
    parseMarkdown: {
      match: ({ type: e }) => e === "blockquote",
      runner: (e, t, r) => {
        e.openNode(r).next(t.children).closeNode();
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === "blockquote",
      runner: (e, t) => {
        e.openNode("blockquote").next(t.content).closeNode();
      }
    }
  })
);
K(ou.node, {
  displayName: "NodeSchema<blockquote>",
  group: "Blockquote"
});
K(ou.ctx, {
  displayName: "NodeSchemaCtx<blockquote>",
  group: "Blockquote"
});
const xO = Qn(
  (n) => h3(/^\s*>\s$/, ou.type(n))
);
K(xO, {
  displayName: "InputRule<wrapInBlockquoteInputRule>",
  group: "Blockquote"
});
const vb = Ye(
  "WrapInBlockquote",
  (n) => () => u3(ou.type(n))
);
K(vb, {
  displayName: "Command<wrapInBlockquoteCommand>",
  group: "Blockquote"
});
const wb = Pr("blockquoteKeymap", {
  WrapInBlockquote: {
    shortcuts: "Mod-Shift-b",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(vb.key);
    }
  }
});
K(wb.ctx, {
  displayName: "KeymapCtx<blockquote>",
  group: "Blockquote"
});
K(wb.shortcuts, {
  displayName: "Keymap<blockquote>",
  group: "Blockquote"
});
const xb = qi("codeBlock", () => ({
  pre: {},
  code: {}
}));
K(xb, {
  displayName: "Attr<codeBlock>",
  group: "CodeBlock"
});
const Ss = hn("code_block", (n) => ({
  content: "text*",
  group: "block",
  marks: "",
  defining: !0,
  code: !0,
  attrs: {
    language: {
      default: "",
      validate: "string"
    }
  },
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return { language: e.dataset.language };
      }
    }
  ],
  toDOM: (e) => {
    const t = n.get(xb.key)(e), r = e.attrs.language, i = r && r.length > 0 ? { "data-language": r } : void 0;
    return [
      "pre",
      {
        ...t.pre,
        ...i
      },
      ["code", t.code, 0]
    ];
  },
  parseMarkdown: {
    match: ({ type: e }) => e === "code",
    runner: (e, t, r) => {
      const i = t.lang ?? "", s = t.value;
      e.openNode(r, { language: i }), s && e.addText(s), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "code_block",
    runner: (e, t) => {
      e.addNode("code", void 0, t.content.firstChild?.text || "", {
        lang: t.attrs.language
      });
    }
  }
}));
K(Ss.node, {
  displayName: "NodeSchema<codeBlock>",
  group: "CodeBlock"
});
K(Ss.ctx, {
  displayName: "NodeSchemaCtx<codeBlock>",
  group: "CodeBlock"
});
const kO = Qn(
  (n) => f3(
    /^```(?<language>[a-z]*)?[\s\n]$/,
    Ss.type(n),
    (e) => ({
      language: e.groups?.language ?? ""
    })
  )
);
K(kO, {
  displayName: "InputRule<createCodeBlockInputRule>",
  group: "CodeBlock"
});
const kb = Ye(
  "CreateCodeBlock",
  (n) => (e = "") => xf(Ss.type(n), { language: e })
);
K(kb, {
  displayName: "Command<createCodeBlockCommand>",
  group: "CodeBlock"
});
const pY = Ye(
  "UpdateCodeBlockLanguage",
  () => ({ pos: n, language: e } = {
    pos: -1,
    language: ""
  }) => (t, r) => n >= 0 ? (r?.(t.tr.setNodeAttribute(n, "language", e)), !0) : !1
);
K(pY, {
  displayName: "Command<updateCodeBlockLanguageCommand>",
  group: "CodeBlock"
});
const Sb = Pr("codeBlockKeymap", {
  CreateCodeBlock: {
    shortcuts: "Mod-Alt-c",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(kb.key);
    }
  }
});
K(Sb.ctx, {
  displayName: "KeymapCtx<codeBlock>",
  group: "CodeBlock"
});
K(Sb.shortcuts, {
  displayName: "Keymap<codeBlock>",
  group: "CodeBlock"
});
const Cb = qi("image");
K(Cb, {
  displayName: "Attr<image>",
  group: "Image"
});
const La = hn("image", (n) => ({
  inline: !0,
  group: "inline",
  selectable: !0,
  draggable: !0,
  marks: "",
  atom: !0,
  defining: !0,
  isolating: !0,
  attrs: {
    src: { default: "", validate: "string" },
    alt: { default: "", validate: "string" },
    title: { default: "", validate: "string" }
  },
  parseDOM: [
    {
      tag: "img[src]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return {
          src: e.getAttribute("src") || "",
          alt: e.getAttribute("alt") || "",
          title: e.getAttribute("title") || e.getAttribute("alt") || ""
        };
      }
    }
  ],
  toDOM: (e) => ["img", { ...n.get(Cb.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: ({ type: e }) => e === "image",
    runner: (e, t, r) => {
      const i = t.url, s = t.alt, o = t.title;
      e.addNode(r, {
        src: i,
        alt: s,
        title: o
      });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "image",
    runner: (e, t) => {
      e.addNode("image", void 0, void 0, {
        title: t.attrs.title,
        url: t.attrs.src,
        alt: t.attrs.alt
      });
    }
  }
}));
K(La.node, {
  displayName: "NodeSchema<image>",
  group: "Image"
});
K(La.ctx, {
  displayName: "NodeSchemaCtx<image>",
  group: "Image"
});
const SO = Ye(
  "InsertImage",
  (n) => (e = {}) => (t, r) => {
    if (!r) return !0;
    const { src: i = "", alt: s = "", title: o = "" } = e, l = La.type(n).create({ src: i, alt: s, title: o });
    return l && r(t.tr.replaceSelectionWith(l).scrollIntoView()), !0;
  }
);
K(SO, {
  displayName: "Command<insertImageCommand>",
  group: "Image"
});
const CO = Ye(
  "UpdateImage",
  (n) => (e = {}) => (t, r) => {
    const i = eF(
      t.selection,
      La.type(n)
    );
    if (!i) return !1;
    const { node: s, pos: o } = i, l = { ...s.attrs }, { src: a, alt: c, title: u } = e;
    return a !== void 0 && (l.src = a), c !== void 0 && (l.alt = c), u !== void 0 && (l.title = u), r?.(
      t.tr.setNodeMarkup(o, void 0, l).scrollIntoView()
    ), !0;
  }
);
K(CO, {
  displayName: "Command<updateImageCommand>",
  group: "Image"
});
const mY = Qn(
  (n) => new Rr(
    /!\[(?<alt>.*?)]\((?<filename>.*?)\s*(?="|\))"?(?<title>[^"]+)?"?\)/,
    (e, t, r, i) => {
      const [s, o, l = "", a] = t;
      return s ? e.tr.replaceWith(
        r,
        i,
        La.type(n).create({ src: l, alt: o, title: a })
      ) : null;
    }
  )
);
K(mY, {
  displayName: "InputRule<insertImageInputRule>",
  group: "Image"
});
const Tm = qi("hardbreak", (n) => ({
  "data-type": "hardbreak",
  "data-is-inline": n.attrs.isInline
}));
K(Tm, {
  displayName: "Attr<hardbreak>",
  group: "Hardbreak"
});
const fa = hn("hardbreak", (n) => ({
  inline: !0,
  group: "inline",
  attrs: {
    isInline: {
      default: !1,
      validate: "boolean"
    }
  },
  selectable: !1,
  parseDOM: [
    { tag: "br" },
    {
      tag: 'span[data-type="hardbreak"]',
      getAttrs: () => ({ isInline: !0 })
    }
  ],
  toDOM: (e) => e.attrs.isInline ? ["span", n.get(Tm.key)(e), " "] : ["br", n.get(Tm.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "break",
    runner: (e, t, r) => {
      e.addNode(r, {
        isInline: !!t.data?.isInline
      });
    }
  },
  leafText: () => `
`,
  toMarkdown: {
    match: (e) => e.type.name === "hardbreak",
    runner: (e, t) => {
      t.attrs.isInline ? e.addNode("text", void 0, `
`) : e.addNode("break");
    }
  }
}));
K(fa.node, {
  displayName: "NodeSchema<hardbreak>",
  group: "Hardbreak"
});
K(fa.ctx, {
  displayName: "NodeSchemaCtx<hardbreak>",
  group: "Hardbreak"
});
const Mb = Ye(
  "InsertHardbreak",
  (n) => () => (e, t) => {
    const { selection: r, tr: i } = e;
    if (!(r instanceof Ee)) return !1;
    if (r.empty) {
      const s = r.$from.node();
      if (s.childCount > 0 && s.lastChild?.type.name === "hardbreak")
        return t?.(
          i.replaceRangeWith(
            r.to - 1,
            r.to,
            e.schema.node("paragraph")
          ).setSelection(Ge.near(i.doc.resolve(r.to))).scrollIntoView()
        ), !0;
    }
    return t?.(
      i.setMeta("hardbreak", !0).replaceSelectionWith(fa.type(n).create()).scrollIntoView()
    ), !0;
  }
);
K(Mb, {
  displayName: "Command<insertHardbreakCommand>",
  group: "Hardbreak"
});
const Tb = Pr("hardbreakKeymap", {
  InsertHardbreak: {
    shortcuts: "Shift-Enter",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Mb.key);
    }
  }
});
K(Tb.ctx, {
  displayName: "KeymapCtx<hardbreak>",
  group: "Hardbreak"
});
K(Tb.shortcuts, {
  displayName: "Keymap<hardbreak>",
  group: "Hardbreak"
});
const Ab = qi("hr");
K(Ab, {
  displayName: "Attr<hr>",
  group: "Hr"
});
const lu = hn("hr", (n) => ({
  group: "block",
  parseDOM: [{ tag: "hr" }],
  toDOM: (e) => ["hr", n.get(Ab.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "thematicBreak",
    runner: (e, t, r) => {
      e.addNode(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "hr",
    runner: (e) => {
      e.addNode("thematicBreak");
    }
  }
}));
K(lu.node, {
  displayName: "NodeSchema<hr>",
  group: "Hr"
});
K(lu.ctx, {
  displayName: "NodeSchemaCtx<hr>",
  group: "Hr"
});
const MO = Qn(
  (n) => new Rr(/^(?:---|___\s|\*\*\*\s)$/, (e, t, r, i) => {
    const { tr: s } = e;
    return t[0] && s.replaceWith(r - 1, i, lu.type(n).create()), s;
  })
);
K(MO, {
  displayName: "InputRule<insertHrInputRule>",
  group: "Hr"
});
const TO = Ye(
  "InsertHr",
  (n) => () => (e, t) => {
    if (!t) return !0;
    const r = As.node.type(n).create(), { tr: i, selection: s } = e, { from: o } = s, l = lu.type(n).create();
    if (!l) return !0;
    const a = i.replaceSelectionWith(l).insert(o, r), c = Ge.findFrom(a.doc.resolve(o), 1, !0);
    return c && t(a.setSelection(c).scrollIntoView()), !0;
  }
);
K(TO, {
  displayName: "Command<insertHrCommand>",
  group: "Hr"
});
const Ob = qi("bulletList");
K(Ob, {
  displayName: "Attr<bulletList>",
  group: "BulletList"
});
const Ba = hn("bullet_list", (n) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    spread: {
      default: !1,
      validate: "boolean"
    }
  },
  parseDOM: [
    {
      tag: "ul",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return {
          spread: e.dataset.spread === "true"
        };
      }
    }
  ],
  toDOM: (e) => [
    "ul",
    {
      ...n.get(Ob.key)(e),
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: t }) => e === "list" && !t,
    runner: (e, t, r) => {
      const i = t.spread != null ? `${t.spread}` : "false";
      e.openNode(r, { spread: i }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "bullet_list",
    runner: (e, t) => {
      e.openNode("list", void 0, {
        ordered: !1,
        spread: t.attrs.spread
      }).next(t.content).closeNode();
    }
  }
}));
K(Ba.node, {
  displayName: "NodeSchema<bulletList>",
  group: "BulletList"
});
K(Ba.ctx, {
  displayName: "NodeSchemaCtx<bulletList>",
  group: "BulletList"
});
const AO = Qn(
  (n) => h3(/^\s*([-+*])\s$/, Ba.type(n))
);
K(AO, {
  displayName: "InputRule<wrapInBulletListInputRule>",
  group: "BulletList"
});
const Eb = Ye(
  "WrapInBulletList",
  (n) => () => u3(Ba.type(n))
);
K(Eb, {
  displayName: "Command<wrapInBulletListCommand>",
  group: "BulletList"
});
const Ib = Pr("bulletListKeymap", {
  WrapInBulletList: {
    shortcuts: "Mod-Alt-8",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Eb.key);
    }
  }
});
K(Ib.ctx, {
  displayName: "KeymapCtx<bulletListKeymap>",
  group: "BulletList"
});
K(Ib.shortcuts, {
  displayName: "Keymap<bulletListKeymap>",
  group: "BulletList"
});
const Db = qi("orderedList");
K(Db, {
  displayName: "Attr<orderedList>",
  group: "OrderedList"
});
const za = hn("ordered_list", (n) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    order: {
      default: 1,
      validate: "number"
    },
    spread: {
      default: !1,
      validate: "boolean"
    }
  },
  parseDOM: [
    {
      tag: "ol",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return {
          spread: e.dataset.spread,
          order: e.hasAttribute("start") ? Number(e.getAttribute("start")) : 1
        };
      }
    }
  ],
  toDOM: (e) => [
    "ol",
    {
      ...n.get(Db.key)(e),
      ...e.attrs.order === 1 ? {} : e.attrs.order,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: t }) => e === "list" && !!t,
    runner: (e, t, r) => {
      const i = t.spread != null ? `${t.spread}` : "true";
      e.openNode(r, { spread: i }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "ordered_list",
    runner: (e, t) => {
      e.openNode("list", void 0, {
        ordered: !0,
        start: 1,
        spread: t.attrs.spread === "true"
      }), e.next(t.content), e.closeNode();
    }
  }
}));
K(za.node, {
  displayName: "NodeSchema<orderedList>",
  group: "OrderedList"
});
K(za.ctx, {
  displayName: "NodeSchemaCtx<orderedList>",
  group: "OrderedList"
});
const OO = Qn(
  (n) => h3(
    /^\s*(\d+)\.\s$/,
    za.type(n),
    (e) => ({ order: Number(e[1]) }),
    (e, t) => t.childCount + t.attrs.order === Number(e[1])
  )
);
K(OO, {
  displayName: "InputRule<wrapInOrderedListInputRule>",
  group: "OrderedList"
});
const Nb = Ye(
  "WrapInOrderedList",
  (n) => () => u3(za.type(n))
);
K(Nb, {
  displayName: "Command<wrapInOrderedListCommand>",
  group: "OrderedList"
});
const Rb = Pr("orderedListKeymap", {
  WrapInOrderedList: {
    shortcuts: "Mod-Alt-7",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Nb.key);
    }
  }
});
K(Rb.ctx, {
  displayName: "KeymapCtx<orderedList>",
  group: "OrderedList"
});
K(Rb.shortcuts, {
  displayName: "Keymap<orderedList>",
  group: "OrderedList"
});
const Pb = qi("listItem");
K(Pb, {
  displayName: "Attr<listItem>",
  group: "ListItem"
});
const Wi = hn("list_item", (n) => ({
  group: "listItem",
  content: "paragraph block*",
  attrs: {
    label: {
      default: "•",
      validate: "string"
    },
    listType: {
      default: "bullet",
      validate: "string"
    },
    spread: {
      default: !0,
      validate: "boolean"
    }
  },
  defining: !0,
  parseDOM: [
    {
      tag: "li",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return {
          label: e.dataset.label,
          listType: e.dataset.listType,
          spread: e.dataset.spread === "true"
        };
      }
    }
  ],
  toDOM: (e) => [
    "li",
    {
      ...n.get(Pb.key)(e),
      "data-label": e.attrs.label,
      "data-list-type": e.attrs.listType,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "listItem",
    runner: (e, t, r) => {
      const i = t.label != null ? `${t.label}.` : "•", s = t.label != null ? "ordered" : "bullet", o = t.spread != null ? `${t.spread}` : "true";
      e.openNode(r, { label: i, listType: s, spread: o }), e.next(t.children), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "list_item",
    runner: (e, t) => {
      e.openNode("listItem", void 0, {
        spread: t.attrs.spread
      }), e.next(t.content), e.closeNode();
    }
  }
}));
K(Wi.node, {
  displayName: "NodeSchema<listItem>",
  group: "ListItem"
});
K(Wi.ctx, {
  displayName: "NodeSchemaCtx<listItem>",
  group: "ListItem"
});
const _b = Ye(
  "SinkListItem",
  (n) => () => lY(Wi.type(n))
);
K(_b, {
  displayName: "Command<sinkListItemCommand>",
  group: "ListItem"
});
const Lb = Ye(
  "LiftListItem",
  (n) => () => iY(Wi.type(n))
);
K(Lb, {
  displayName: "Command<liftListItemCommand>",
  group: "ListItem"
});
const Bb = Ye(
  "SplitListItem",
  (n) => () => rY(Wi.type(n))
);
K(Bb, {
  displayName: "Command<splitListItemCommand>",
  group: "ListItem"
});
function gY(n) {
  return (e, t, r) => {
    const { selection: i } = e;
    if (!(i instanceof Ee)) return !1;
    const { empty: s, $from: o } = i;
    return !s || o.parentOffset !== 0 || o.node(-1).type !== Wi.type(n) ? !1 : xC(e, t, r);
  };
}
const zb = Ye(
  "LiftFirstListItem",
  (n) => () => gY(n)
);
K(zb, {
  displayName: "Command<liftFirstListItemCommand>",
  group: "ListItem"
});
const Fb = Pr("listItemKeymap", {
  NextListItem: {
    shortcuts: "Enter",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Bb.key);
    }
  },
  SinkListItem: {
    shortcuts: ["Tab", "Mod-]"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(_b.key);
    }
  },
  LiftListItem: {
    shortcuts: ["Shift-Tab", "Mod-["],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Lb.key);
    }
  },
  LiftFirstListItem: {
    shortcuts: ["Backspace", "Delete"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(zb.key);
    }
  }
});
K(Fb.ctx, {
  displayName: "KeymapCtx<listItem>",
  group: "ListItem"
});
K(Fb.shortcuts, {
  displayName: "Keymap<listItem>",
  group: "ListItem"
});
const EO = eb("text", () => ({
  group: "inline",
  parseMarkdown: {
    match: ({ type: n }) => n === "text",
    runner: (n, e) => {
      n.addText(e.value);
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "text",
    runner: (n, e) => {
      n.addNode("text", void 0, e.text);
    }
  }
}));
K(EO, {
  displayName: "NodeSchema<text>",
  group: "Text"
});
const Hb = qi("html");
K(Hb, {
  displayName: "Attr<html>",
  group: "Html"
});
const $b = hn("html", (n) => ({
  atom: !0,
  group: "inline",
  inline: !0,
  attrs: {
    value: {
      default: "",
      validate: "string"
    }
  },
  toDOM: (e) => {
    const t = document.createElement("span"), r = {
      ...n.get(Hb.key)(e),
      "data-value": e.attrs.value,
      "data-type": "html"
    };
    return t.textContent = e.attrs.value, ["span", r, e.attrs.value];
  },
  parseDOM: [
    {
      tag: 'span[data-type="html"]',
      getAttrs: (e) => ({
        value: e.dataset.value ?? ""
      })
    }
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "html",
    runner: (e, t, r) => {
      e.addNode(r, { value: t.value });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "html",
    runner: (e, t) => {
      e.addNode("html", void 0, t.attrs.value);
    }
  }
}));
K($b.node, {
  displayName: "NodeSchema<html>",
  group: "Html"
});
K($b.ctx, {
  displayName: "NodeSchemaCtx<html>",
  group: "Html"
});
const yY = [
  vO,
  fb,
  As,
  H1,
  mb,
  Ur,
  Tm,
  fa,
  bb,
  ou,
  xb,
  Ss,
  Ab,
  lu,
  Cb,
  La,
  Ob,
  Ba,
  Db,
  za,
  Pb,
  Wi,
  sb,
  _a,
  lb,
  su,
  cb,
  Qs,
  hb,
  Ri,
  Hb,
  $b,
  EO
].flat(), bY = [
  xO,
  AO,
  OO,
  kO,
  MO,
  wO
].flat(), vY = [
  dO,
  pO,
  gO,
  mO
], nc = Ye(
  "IsMarkSelected",
  () => (n) => (e) => {
    if (!n) return !1;
    const { doc: t, selection: r } = e;
    return t.rangeHasMark(r.from, r.to, n);
  }
), IO = Ye(
  "IsNoteSelected",
  () => (n) => (e) => n ? _C(e, n).hasNode : !1
), Dn = Ye(
  "ClearTextInCurrentBlock",
  () => () => (n, e) => {
    let t = n.tr;
    const { $from: r, $to: i } = t.selection, { pos: s } = r, { pos: o } = i, l = s - r.node().content.size;
    return l < 0 ? !1 : (t = t.deleteRange(l, o), e?.(t), !0);
  }
), $s = Ye(
  "SetBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    const s = e.tr, { from: o, to: l } = s.selection;
    try {
      s.setBlockType(o, l, r, i);
    } catch {
      return !1;
    }
    return t?.(s), !0;
  }
), ph = Ye(
  "WrapInBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    let s = e.tr;
    try {
      const { $from: o, $to: l } = s.selection, a = o.blockRange(l), c = a && i3(a, r, i);
      if (!c) return !1;
      s = s.wrap(a, c);
    } catch {
      return !1;
    }
    return t?.(s), !0;
  }
), mh = Ye(
  "AddBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    const s = e.tr;
    try {
      const o = r instanceof eo ? r : r.createAndFill(i);
      if (!o) return !1;
      s.replaceSelectionWith(o);
    } catch {
      return !1;
    }
    return t?.(s), !0;
  }
), DO = Ye(
  "SelectTextNearPos",
  () => (n) => (e, t) => {
    const { pos: r } = n ?? {};
    if (r == null) return !1;
    const i = (o, l, a) => Math.min(Math.max(o, l), a), s = e.tr;
    try {
      const o = e.doc.resolve(i(r, 0, e.doc.content.size));
      s.setSelection(Ee.near(o));
    } catch {
      return !1;
    }
    return t?.(s.scrollIntoView()), !0;
  }
), wY = [
  db,
  vb,
  Ho,
  gb,
  kb,
  Mb,
  TO,
  SO,
  CO,
  Nb,
  Eb,
  _b,
  Bb,
  Lb,
  zb,
  L1,
  z1,
  B1,
  yO,
  bO,
  nc,
  IO,
  Dn,
  $s,
  ph,
  mh,
  DO
], xY = [
  wb,
  Sb,
  Tb,
  yb,
  Fb,
  Rb,
  Ib,
  pb,
  ob,
  ub,
  ab
].flat(), Vb = Ts(
  "remarkAddOrderInList",
  () => () => (n) => {
    kl(n, "list", (e) => {
      if (e.ordered) {
        const t = e.start ?? 1;
        e.children.forEach((r, i) => {
          r.label = i + t;
        });
      }
    });
  }
);
K(Vb.plugin, {
  displayName: "Remark<remarkAddOrderInListPlugin>",
  group: "Remark"
});
K(Vb.options, {
  displayName: "RemarkConfig<remarkAddOrderInListPlugin>",
  group: "Remark"
});
const qb = Ts(
  "remarkLineBreak",
  () => () => (n) => {
    const e = /[\t ]*(?:\r?\n|\r)/g;
    kl(
      n,
      "text",
      (t, r, i) => {
        if (!t.value || typeof t.value != "string") return;
        const s = [];
        let o = 0;
        e.lastIndex = 0;
        let l = e.exec(t.value);
        for (; l; ) {
          const c = l.index;
          o !== c && s.push({
            type: "text",
            value: t.value.slice(o, c)
          }), s.push({ type: "break", data: { isInline: !0 } }), o = c + l[0].length, l = e.exec(t.value);
        }
        if (s.length > 0 && i && typeof r == "number")
          return o < t.value.length && s.push({ type: "text", value: t.value.slice(o) }), i.children.splice(r, 1, ...s), r + s.length;
      }
    );
  }
);
K(qb.plugin, {
  displayName: "Remark<remarkLineBreak>",
  group: "Remark"
});
K(qb.options, {
  displayName: "RemarkConfig<remarkLineBreak>",
  group: "Remark"
});
const Wb = Ts(
  "remarkInlineLink",
  () => cY
);
K(Wb.plugin, {
  displayName: "Remark<remarkInlineLinkPlugin>",
  group: "Remark"
});
K(Wb.options, {
  displayName: "RemarkConfig<remarkInlineLinkPlugin>",
  group: "Remark"
});
const kY = (n) => !!n.children, SY = (n) => n.type === "html";
function CY(n, e) {
  return t(n, 0, null)[0];
  function t(r, i, s) {
    if (kY(r)) {
      const o = [];
      for (let l = 0, a = r.children.length; l < a; l++) {
        const c = r.children[l];
        if (c) {
          const u = t(c, l, r);
          if (u)
            for (let h = 0, f = u.length; h < f; h++) {
              const d = u[h];
              d && o.push(d);
            }
        }
      }
      r.children = o;
    }
    return e(r, i, s);
  }
}
const MY = ["root", "blockquote", "listItem"], jb = Ts(
  "remarkHTMLTransformer",
  () => () => (n) => {
    CY(n, (e, t, r) => SY(e) ? (r && MY.includes(r.type) && (e.children = [{ ...e }], delete e.value, e.type = "paragraph"), [e]) : [e]);
  }
);
K(jb.plugin, {
  displayName: "Remark<remarkHtmlTransformer>",
  group: "Remark"
});
K(jb.options, {
  displayName: "RemarkConfig<remarkHtmlTransformer>",
  group: "Remark"
});
const Ub = Ts(
  "remarkMarker",
  () => () => (n, e) => {
    const t = (r) => e.value.charAt(r.position.start.offset);
    kl(
      n,
      (r) => ["strong", "emphasis"].includes(r.type),
      (r) => {
        r.marker = t(r);
      }
    );
  }
);
K(Ub.plugin, {
  displayName: "Remark<remarkMarker>",
  group: "Remark"
});
K(Ub.options, {
  displayName: "RemarkConfig<remarkMarker>",
  group: "Remark"
});
const NO = kn(() => {
  let n = !1;
  const e = new en(
    "MILKDOWN_INLINE_NODES_CURSOR"
  ), t = new Ut({
    key: e,
    state: {
      init() {
        return !1;
      },
      apply(r) {
        if (!r.selection.empty) return !1;
        const i = r.selection.$from, s = i.nodeBefore, o = i.nodeAfter;
        return !!(s && o && s.isInline && !s.isText && o.isInline && !o.isText);
      }
    },
    props: {
      handleDOMEvents: {
        compositionend: (r, i) => n ? (n = !1, requestAnimationFrame(() => {
          if (t.getState(r.state)) {
            const o = r.state.selection.from;
            i.preventDefault(), r.dispatch(r.state.tr.insertText(i.data || "", o));
          }
        }), !0) : !1,
        compositionstart: (r) => (t.getState(r.state) && (n = !0), !1),
        beforeinput: (r, i) => {
          if (t.getState(r.state) && i instanceof InputEvent && i.data && !n) {
            const o = r.state.selection.from;
            return i.preventDefault(), r.dispatch(r.state.tr.insertText(i.data || "", o)), !0;
          }
          return !1;
        }
      },
      decorations(r) {
        if (t.getState(r)) {
          const o = r.selection.$from.pos, l = document.createElement("span"), a = mr.widget(o, l, {
            side: -1
          }), c = document.createElement("span"), u = mr.widget(o, c);
          return setTimeout(() => {
            l.contentEditable = "true", c.contentEditable = "true";
          }), It.create(r.doc, [a, u]);
        }
        return It.empty;
      }
    }
  });
  return t;
});
K(NO, {
  displayName: "Prose<inlineNodesCursorPlugin>",
  group: "Prose"
});
const RO = kn((n) => new Ut({
  key: new en("MILKDOWN_HARDBREAK_MARKS"),
  appendTransaction: (e, t, r) => {
    if (!e.length) return;
    const [i] = e;
    if (!i) return;
    const [s] = i.steps;
    if (i.getMeta("hardbreak")) {
      if (!(s instanceof Cn)) return;
      const { from: a } = s;
      return r.tr.setNodeMarkup(
        a,
        fa.type(n),
        void 0,
        []
      );
    }
    if (s instanceof Xs) {
      let a = r.tr;
      const { from: c, to: u } = s;
      return r.doc.nodesBetween(c, u, (h, f) => {
        h.type === fa.type(n) && (a = a.setNodeMarkup(
          f,
          fa.type(n),
          void 0,
          []
        ));
      }), a;
    }
  }
}));
K(RO, {
  displayName: "Prose<hardbreakClearMarkPlugin>",
  group: "Prose"
});
const Kb = Mt(
  ["table", "code_block"],
  "hardbreakFilterNodes"
);
K(Kb, {
  displayName: "Ctx<hardbreakFilterNodes>",
  group: "Prose"
});
const PO = kn((n) => {
  const e = n.get(Kb.key);
  return new Ut({
    key: new en("MILKDOWN_HARDBREAK_FILTER"),
    filterTransaction: (t, r) => {
      const i = t.getMeta("hardbreak"), [s] = t.steps;
      if (i && s) {
        const { from: o } = s, l = r.doc.resolve(o);
        let a = l.depth, c = !0;
        for (; a > 0; )
          e.includes(l.node(a).type.name) && (c = !1), a--;
        return c;
      }
      return !0;
    }
  });
});
K(PO, {
  displayName: "Prose<hardbreakFilterPlugin>",
  group: "Prose"
});
const _O = kn((n) => {
  const e = new en("MILKDOWN_HEADING_ID"), t = (r) => {
    if (r.composing) return;
    const i = n.get(H1.key), s = r.state.tr.setMeta("addToHistory", !1);
    let o = !1;
    const l = {};
    r.state.doc.descendants((a, c) => {
      if (a.type === Ur.type(n)) {
        if (a.textContent.trim().length === 0) return;
        const u = a.attrs;
        let h = i(a);
        l[h] ? (l[h] += 1, h += `-#${l[h]}`) : l[h] = 1, u.id !== h && (o = !0, s.setMeta(e, !0).setNodeMarkup(c, void 0, {
          ...u,
          id: h
        }));
      }
    }), o && r.dispatch(s);
  };
  return new Ut({
    key: e,
    view: (r) => (t(r), {
      update: (i, s) => {
        i.state.doc.eq(s.doc) || t(i);
      }
    })
  });
});
K(_O, {
  displayName: "Prose<syncHeadingIdPlugin>",
  group: "Prose"
});
const LO = kn((n) => {
  const e = (t, r, i) => {
    if (!i.selection || t.some(
      (h) => h.getMeta("addToHistory") === !1 || !h.isGeneric
    ))
      return null;
    const s = za.type(n), o = Ba.type(n), l = Wi.type(n), a = (h, f) => {
      let d = !1;
      const p = `${f + 1}.`;
      return h.label !== p && (h.label = p, d = !0), d;
    };
    let c = i.tr, u = !1;
    return i.doc.descendants(
      (h, f, d, p) => {
        if (h.type === o) {
          const m = h.maybeChild(0);
          m?.type === l && m.attrs.listType === "ordered" && (u = !0, c.setNodeMarkup(f, s, { spread: "true" }), h.descendants(
            (g, b, w, k) => {
              if (g.type === l) {
                const C = { ...g.attrs };
                a(C, k) && (c = c.setNodeMarkup(b, void 0, C));
              }
              return !1;
            }
          ));
        } else if (h.type === l && d?.type === s) {
          const m = { ...h.attrs };
          let g = !1;
          m.listType !== "ordered" && (m.listType = "ordered", g = !0), d?.maybeChild(0) && (g = a(m, p)), g && (c = c.setNodeMarkup(f, void 0, m), u = !0);
        }
      }
    ), u ? c.setMeta("addToHistory", !1) : null;
  };
  return new Ut({
    key: new en("MILKDOWN_KEEP_LIST_ORDER"),
    appendTransaction: e
  });
});
K(LO, {
  displayName: "Prose<syncListOrderPlugin>",
  group: "Prose"
});
const TY = [
  RO,
  Kb,
  PO,
  NO,
  Vb,
  Wb,
  qb,
  jb,
  Ub,
  F1,
  _O,
  LO
].flat(), AY = [
  yY,
  bY,
  vY,
  wY,
  xY,
  TY
].flat();
/**
* @vue/shared v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Gb(n) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const t of n.split(",")) e[t] = 1;
  return (t) => t in e;
}
const Bt = {}, nf = [], Pi = () => {
}, OY = () => !1, $1 = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // uppercase letter
(n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97), Yb = (n) => n.startsWith("onUpdate:"), Xn = Object.assign, Jb = (n, e) => {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}, EY = Object.prototype.hasOwnProperty, vt = (n, e) => EY.call(n, e), Ze = Array.isArray, rf = (n) => V1(n) === "[object Map]", IY = (n) => V1(n) === "[object Set]", tt = (n) => typeof n == "function", An = (n) => typeof n == "string", au = (n) => typeof n == "symbol", un = (n) => n !== null && typeof n == "object", BO = (n) => (un(n) || tt(n)) && tt(n.then) && tt(n.catch), DY = Object.prototype.toString, V1 = (n) => DY.call(n), NY = (n) => V1(n).slice(8, -1), RY = (n) => V1(n) === "[object Object]", Xb = (n) => An(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n, sf = /* @__PURE__ */ Gb(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), q1 = (n) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = n(t));
}, PY = /-(\w)/g, gl = q1(
  (n) => n.replace(PY, (e, t) => t ? t.toUpperCase() : "")
), _Y = /\B([A-Z])/g, Fa = q1(
  (n) => n.replace(_Y, "-$1").toLowerCase()
), zO = q1((n) => n.charAt(0).toUpperCase() + n.slice(1)), O2 = q1(
  (n) => n ? `on${zO(n)}` : ""
), sl = (n, e) => !Object.is(n, e), E2 = (n, ...e) => {
  for (let t = 0; t < n.length; t++)
    n[t](...e);
}, jf = (n, e, t, r = !1) => {
  Object.defineProperty(n, e, {
    configurable: !0,
    enumerable: !1,
    writable: r,
    value: t
  });
}, LY = (n) => {
  const e = parseFloat(n);
  return isNaN(e) ? n : e;
};
let y8;
const da = () => y8 || (y8 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Zb(n) {
  if (Ze(n)) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
      const r = n[t], i = An(r) ? HY(r) : Zb(r);
      if (i)
        for (const s in i)
          e[s] = i[s];
    }
    return e;
  } else if (An(n) || un(n))
    return n;
}
const BY = /;(?![^(]*\))/g, zY = /:([^]+)/, FY = /\/\*[^]*?\*\//g;
function HY(n) {
  const e = {};
  return n.replace(FY, "").split(BY).forEach((t) => {
    if (t) {
      const r = t.split(zY);
      r.length > 1 && (e[r[0].trim()] = r[1].trim());
    }
  }), e;
}
function Qb(n) {
  let e = "";
  if (An(n))
    e = n;
  else if (Ze(n))
    for (let t = 0; t < n.length; t++) {
      const r = Qb(n[t]);
      r && (e += r + " ");
    }
  else if (un(n))
    for (const t in n)
      n[t] && (e += t + " ");
  return e.trim();
}
const $Y = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", VY = /* @__PURE__ */ Gb($Y);
function FO(n) {
  return !!n || n === "";
}
/**
* @vue/reactivity v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let xr;
class qY {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = xr, !e && xr && (this.index = (xr.scopes || (xr.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, t;
      if (this.scopes)
        for (e = 0, t = this.scopes.length; e < t; e++)
          this.scopes[e].pause();
      for (e = 0, t = this.effects.length; e < t; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, t;
      if (this.scopes)
        for (e = 0, t = this.scopes.length; e < t; e++)
          this.scopes[e].resume();
      for (e = 0, t = this.effects.length; e < t; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const t = xr;
      try {
        return xr = this, e();
      } finally {
        xr = t;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = xr, xr = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (xr = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let t, r;
      for (t = 0, r = this.effects.length; t < r; t++)
        this.effects[t].stop();
      for (this.effects.length = 0, t = 0, r = this.cleanups.length; t < r; t++)
        this.cleanups[t]();
      if (this.cleanups.length = 0, this.scopes) {
        for (t = 0, r = this.scopes.length; t < r; t++)
          this.scopes[t].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function WY() {
  return xr;
}
let Lt;
const I2 = /* @__PURE__ */ new WeakSet();
class HO {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, xr && xr.active && xr.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, I2.has(this) && (I2.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || VO(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, b8(this), qO(this);
    const e = Lt, t = _i;
    Lt = this, _i = !0;
    try {
      return this.fn();
    } finally {
      WO(this), Lt = e, _i = t, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        nv(e);
      this.deps = this.depsTail = void 0, b8(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? I2.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Zy(this) && this.run();
  }
  get dirty() {
    return Zy(this);
  }
}
let $O = 0, of, lf;
function VO(n, e = !1) {
  if (n.flags |= 8, e) {
    n.next = lf, lf = n;
    return;
  }
  n.next = of, of = n;
}
function ev() {
  $O++;
}
function tv() {
  if (--$O > 0)
    return;
  if (lf) {
    let e = lf;
    for (lf = void 0; e; ) {
      const t = e.next;
      e.next = void 0, e.flags &= -9, e = t;
    }
  }
  let n;
  for (; of; ) {
    let e = of;
    for (of = void 0; e; ) {
      const t = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (r) {
          n || (n = r);
        }
      e = t;
    }
  }
  if (n) throw n;
}
function qO(n) {
  for (let e = n.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function WO(n) {
  let e, t = n.depsTail, r = t;
  for (; r; ) {
    const i = r.prevDep;
    r.version === -1 ? (r === t && (t = i), nv(r), jY(r)) : e = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = i;
  }
  n.deps = e, n.depsTail = t;
}
function Zy(n) {
  for (let e = n.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (jO(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!n._dirty;
}
function jO(n) {
  if (n.flags & 4 && !(n.flags & 16) || (n.flags &= -17, n.globalVersion === Uf) || (n.globalVersion = Uf, !n.isSSR && n.flags & 128 && (!n.deps && !n._dirty || !Zy(n))))
    return;
  n.flags |= 2;
  const e = n.dep, t = Lt, r = _i;
  Lt = n, _i = !0;
  try {
    qO(n);
    const i = n.fn(n._value);
    (e.version === 0 || sl(i, n._value)) && (n.flags |= 128, n._value = i, e.version++);
  } catch (i) {
    throw e.version++, i;
  } finally {
    Lt = t, _i = r, WO(n), n.flags &= -3;
  }
}
function nv(n, e = !1) {
  const { dep: t, prevSub: r, nextSub: i } = n;
  if (r && (r.nextSub = i, n.prevSub = void 0), i && (i.prevSub = r, n.nextSub = void 0), t.subs === n && (t.subs = r, !r && t.computed)) {
    t.computed.flags &= -5;
    for (let s = t.computed.deps; s; s = s.nextDep)
      nv(s, !0);
  }
  !e && !--t.sc && t.map && t.map.delete(t.key);
}
function jY(n) {
  const { prevDep: e, nextDep: t } = n;
  e && (e.nextDep = t, n.prevDep = void 0), t && (t.prevDep = e, n.nextDep = void 0);
}
let _i = !0;
const UO = [];
function ho() {
  UO.push(_i), _i = !1;
}
function fo() {
  const n = UO.pop();
  _i = n === void 0 ? !0 : n;
}
function b8(n) {
  const { cleanup: e } = n;
  if (n.cleanup = void 0, e) {
    const t = Lt;
    Lt = void 0;
    try {
      e();
    } finally {
      Lt = t;
    }
  }
}
let Uf = 0;
class UY {
  constructor(e, t) {
    this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class rv {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(e) {
    if (!Lt || !_i || Lt === this.computed)
      return;
    let t = this.activeLink;
    if (t === void 0 || t.sub !== Lt)
      t = this.activeLink = new UY(Lt, this), Lt.deps ? (t.prevDep = Lt.depsTail, Lt.depsTail.nextDep = t, Lt.depsTail = t) : Lt.deps = Lt.depsTail = t, KO(t);
    else if (t.version === -1 && (t.version = this.version, t.nextDep)) {
      const r = t.nextDep;
      r.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = r), t.prevDep = Lt.depsTail, t.nextDep = void 0, Lt.depsTail.nextDep = t, Lt.depsTail = t, Lt.deps === t && (Lt.deps = r);
    }
    return t;
  }
  trigger(e) {
    this.version++, Uf++, this.notify(e);
  }
  notify(e) {
    ev();
    try {
      for (let t = this.subs; t; t = t.prevSub)
        t.sub.notify() && t.sub.dep.notify();
    } finally {
      tv();
    }
  }
}
function KO(n) {
  if (n.dep.sc++, n.sub.flags & 4) {
    const e = n.dep.computed;
    if (e && !n.dep.subs) {
      e.flags |= 20;
      for (let r = e.deps; r; r = r.nextDep)
        KO(r);
    }
    const t = n.dep.subs;
    t !== n && (n.prevSub = t, t && (t.nextSub = n)), n.dep.subs = n;
  }
}
const Qy = /* @__PURE__ */ new WeakMap(), pa = Symbol(
  ""
), e5 = Symbol(
  ""
), Kf = Symbol(
  ""
);
function jn(n, e, t) {
  if (_i && Lt) {
    let r = Qy.get(n);
    r || Qy.set(n, r = /* @__PURE__ */ new Map());
    let i = r.get(t);
    i || (r.set(t, i = new rv()), i.map = r, i.key = t), i.track();
  }
}
function Js(n, e, t, r, i, s) {
  const o = Qy.get(n);
  if (!o) {
    Uf++;
    return;
  }
  const l = (a) => {
    a && a.trigger();
  };
  if (ev(), e === "clear")
    o.forEach(l);
  else {
    const a = Ze(n), c = a && Xb(t);
    if (a && t === "length") {
      const u = Number(r);
      o.forEach((h, f) => {
        (f === "length" || f === Kf || !au(f) && f >= u) && l(h);
      });
    } else
      switch ((t !== void 0 || o.has(void 0)) && l(o.get(t)), c && l(o.get(Kf)), e) {
        case "add":
          a ? c && l(o.get("length")) : (l(o.get(pa)), rf(n) && l(o.get(e5)));
          break;
        case "delete":
          a || (l(o.get(pa)), rf(n) && l(o.get(e5)));
          break;
        case "set":
          rf(n) && l(o.get(pa));
          break;
      }
  }
  tv();
}
function Ja(n) {
  const e = bt(n);
  return e === n ? e : (jn(e, "iterate", Kf), Li(n) ? e : e.map(sr));
}
function iv(n) {
  return jn(n = bt(n), "iterate", Kf), n;
}
const KY = {
  __proto__: null,
  [Symbol.iterator]() {
    return D2(this, Symbol.iterator, sr);
  },
  concat(...n) {
    return Ja(this).concat(
      ...n.map((e) => Ze(e) ? Ja(e) : e)
    );
  },
  entries() {
    return D2(this, "entries", (n) => (n[1] = sr(n[1]), n));
  },
  every(n, e) {
    return Bs(this, "every", n, e, void 0, arguments);
  },
  filter(n, e) {
    return Bs(this, "filter", n, e, (t) => t.map(sr), arguments);
  },
  find(n, e) {
    return Bs(this, "find", n, e, sr, arguments);
  },
  findIndex(n, e) {
    return Bs(this, "findIndex", n, e, void 0, arguments);
  },
  findLast(n, e) {
    return Bs(this, "findLast", n, e, sr, arguments);
  },
  findLastIndex(n, e) {
    return Bs(this, "findLastIndex", n, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(n, e) {
    return Bs(this, "forEach", n, e, void 0, arguments);
  },
  includes(...n) {
    return N2(this, "includes", n);
  },
  indexOf(...n) {
    return N2(this, "indexOf", n);
  },
  join(n) {
    return Ja(this).join(n);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...n) {
    return N2(this, "lastIndexOf", n);
  },
  map(n, e) {
    return Bs(this, "map", n, e, void 0, arguments);
  },
  pop() {
    return Hu(this, "pop");
  },
  push(...n) {
    return Hu(this, "push", n);
  },
  reduce(n, ...e) {
    return v8(this, "reduce", n, e);
  },
  reduceRight(n, ...e) {
    return v8(this, "reduceRight", n, e);
  },
  shift() {
    return Hu(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(n, e) {
    return Bs(this, "some", n, e, void 0, arguments);
  },
  splice(...n) {
    return Hu(this, "splice", n);
  },
  toReversed() {
    return Ja(this).toReversed();
  },
  toSorted(n) {
    return Ja(this).toSorted(n);
  },
  toSpliced(...n) {
    return Ja(this).toSpliced(...n);
  },
  unshift(...n) {
    return Hu(this, "unshift", n);
  },
  values() {
    return D2(this, "values", sr);
  }
};
function D2(n, e, t) {
  const r = iv(n), i = r[e]();
  return r !== n && !Li(n) && (i._next = i.next, i.next = () => {
    const s = i._next();
    return s.value && (s.value = t(s.value)), s;
  }), i;
}
const GY = Array.prototype;
function Bs(n, e, t, r, i, s) {
  const o = iv(n), l = o !== n && !Li(n), a = o[e];
  if (a !== GY[e]) {
    const h = a.apply(n, s);
    return l ? sr(h) : h;
  }
  let c = t;
  o !== n && (l ? c = function(h, f) {
    return t.call(this, sr(h), f, n);
  } : t.length > 2 && (c = function(h, f) {
    return t.call(this, h, f, n);
  }));
  const u = a.call(o, c, r);
  return l && i ? i(u) : u;
}
function v8(n, e, t, r) {
  const i = iv(n);
  let s = t;
  return i !== n && (Li(n) ? t.length > 3 && (s = function(o, l, a) {
    return t.call(this, o, l, a, n);
  }) : s = function(o, l, a) {
    return t.call(this, o, sr(l), a, n);
  }), i[e](s, ...r);
}
function N2(n, e, t) {
  const r = bt(n);
  jn(r, "iterate", Kf);
  const i = r[e](...t);
  return (i === -1 || i === !1) && av(t[0]) ? (t[0] = bt(t[0]), r[e](...t)) : i;
}
function Hu(n, e, t = []) {
  ho(), ev();
  const r = bt(n)[e].apply(n, t);
  return tv(), fo(), r;
}
const YY = /* @__PURE__ */ Gb("__proto__,__v_isRef,__isVue"), GO = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((n) => n !== "arguments" && n !== "caller").map((n) => Symbol[n]).filter(au)
);
function JY(n) {
  au(n) || (n = String(n));
  const e = bt(this);
  return jn(e, "has", n), e.hasOwnProperty(n);
}
class YO {
  constructor(e = !1, t = !1) {
    this._isReadonly = e, this._isShallow = t;
  }
  get(e, t, r) {
    if (t === "__v_skip") return e.__v_skip;
    const i = this._isReadonly, s = this._isShallow;
    if (t === "__v_isReactive")
      return !i;
    if (t === "__v_isReadonly")
      return i;
    if (t === "__v_isShallow")
      return s;
    if (t === "__v_raw")
      return r === (i ? s ? oJ : QO : s ? ZO : XO).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(r) ? e : void 0;
    const o = Ze(e);
    if (!i) {
      let a;
      if (o && (a = KY[t]))
        return a;
      if (t === "hasOwnProperty")
        return JY;
    }
    const l = Reflect.get(
      e,
      t,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Jn(e) ? e : r
    );
    return (au(t) ? GO.has(t) : YY(t)) || (i || jn(e, "get", t), s) ? l : Jn(l) ? o && Xb(t) ? l : l.value : un(l) ? i ? eE(l) : ov(l) : l;
  }
}
class JO extends YO {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, t, r, i) {
    let s = e[t];
    if (!this._isShallow) {
      const a = Ia(s);
      if (!Li(r) && !Ia(r) && (s = bt(s), r = bt(r)), !Ze(e) && Jn(s) && !Jn(r))
        return a ? !1 : (s.value = r, !0);
    }
    const o = Ze(e) && Xb(t) ? Number(t) < e.length : vt(e, t), l = Reflect.set(
      e,
      t,
      r,
      Jn(e) ? e : i
    );
    return e === bt(i) && (o ? sl(r, s) && Js(e, "set", t, r) : Js(e, "add", t, r)), l;
  }
  deleteProperty(e, t) {
    const r = vt(e, t);
    e[t];
    const i = Reflect.deleteProperty(e, t);
    return i && r && Js(e, "delete", t, void 0), i;
  }
  has(e, t) {
    const r = Reflect.has(e, t);
    return (!au(t) || !GO.has(t)) && jn(e, "has", t), r;
  }
  ownKeys(e) {
    return jn(
      e,
      "iterate",
      Ze(e) ? "length" : pa
    ), Reflect.ownKeys(e);
  }
}
class XY extends YO {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, t) {
    return !0;
  }
  deleteProperty(e, t) {
    return !0;
  }
}
const ZY = /* @__PURE__ */ new JO(), QY = /* @__PURE__ */ new XY(), eJ = /* @__PURE__ */ new JO(!0);
const t5 = (n) => n, p0 = (n) => Reflect.getPrototypeOf(n);
function tJ(n, e, t) {
  return function(...r) {
    const i = this.__v_raw, s = bt(i), o = rf(s), l = n === "entries" || n === Symbol.iterator && o, a = n === "keys" && o, c = i[n](...r), u = t ? t5 : e ? n5 : sr;
    return !e && jn(
      s,
      "iterate",
      a ? e5 : pa
    ), {
      // iterator protocol
      next() {
        const { value: h, done: f } = c.next();
        return f ? { value: h, done: f } : {
          value: l ? [u(h[0]), u(h[1])] : u(h),
          done: f
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function m0(n) {
  return function(...e) {
    return n === "delete" ? !1 : n === "clear" ? void 0 : this;
  };
}
function nJ(n, e) {
  const t = {
    get(i) {
      const s = this.__v_raw, o = bt(s), l = bt(i);
      n || (sl(i, l) && jn(o, "get", i), jn(o, "get", l));
      const { has: a } = p0(o), c = e ? t5 : n ? n5 : sr;
      if (a.call(o, i))
        return c(s.get(i));
      if (a.call(o, l))
        return c(s.get(l));
      s !== o && s.get(i);
    },
    get size() {
      const i = this.__v_raw;
      return !n && jn(bt(i), "iterate", pa), Reflect.get(i, "size", i);
    },
    has(i) {
      const s = this.__v_raw, o = bt(s), l = bt(i);
      return n || (sl(i, l) && jn(o, "has", i), jn(o, "has", l)), i === l ? s.has(i) : s.has(i) || s.has(l);
    },
    forEach(i, s) {
      const o = this, l = o.__v_raw, a = bt(l), c = e ? t5 : n ? n5 : sr;
      return !n && jn(a, "iterate", pa), l.forEach((u, h) => i.call(s, c(u), c(h), o));
    }
  };
  return Xn(
    t,
    n ? {
      add: m0("add"),
      set: m0("set"),
      delete: m0("delete"),
      clear: m0("clear")
    } : {
      add(i) {
        !e && !Li(i) && !Ia(i) && (i = bt(i));
        const s = bt(this);
        return p0(s).has.call(s, i) || (s.add(i), Js(s, "add", i, i)), this;
      },
      set(i, s) {
        !e && !Li(s) && !Ia(s) && (s = bt(s));
        const o = bt(this), { has: l, get: a } = p0(o);
        let c = l.call(o, i);
        c || (i = bt(i), c = l.call(o, i));
        const u = a.call(o, i);
        return o.set(i, s), c ? sl(s, u) && Js(o, "set", i, s) : Js(o, "add", i, s), this;
      },
      delete(i) {
        const s = bt(this), { has: o, get: l } = p0(s);
        let a = o.call(s, i);
        a || (i = bt(i), a = o.call(s, i)), l && l.call(s, i);
        const c = s.delete(i);
        return a && Js(s, "delete", i, void 0), c;
      },
      clear() {
        const i = bt(this), s = i.size !== 0, o = i.clear();
        return s && Js(
          i,
          "clear",
          void 0,
          void 0
        ), o;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((i) => {
    t[i] = tJ(i, n, e);
  }), t;
}
function sv(n, e) {
  const t = nJ(n, e);
  return (r, i, s) => i === "__v_isReactive" ? !n : i === "__v_isReadonly" ? n : i === "__v_raw" ? r : Reflect.get(
    vt(t, i) && i in r ? t : r,
    i,
    s
  );
}
const rJ = {
  get: /* @__PURE__ */ sv(!1, !1)
}, iJ = {
  get: /* @__PURE__ */ sv(!1, !0)
}, sJ = {
  get: /* @__PURE__ */ sv(!0, !1)
};
const XO = /* @__PURE__ */ new WeakMap(), ZO = /* @__PURE__ */ new WeakMap(), QO = /* @__PURE__ */ new WeakMap(), oJ = /* @__PURE__ */ new WeakMap();
function lJ(n) {
  switch (n) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function aJ(n) {
  return n.__v_skip || !Object.isExtensible(n) ? 0 : lJ(NY(n));
}
function ov(n) {
  return Ia(n) ? n : lv(
    n,
    !1,
    ZY,
    rJ,
    XO
  );
}
function cJ(n) {
  return lv(
    n,
    !1,
    eJ,
    iJ,
    ZO
  );
}
function eE(n) {
  return lv(
    n,
    !0,
    QY,
    sJ,
    QO
  );
}
function lv(n, e, t, r, i) {
  if (!un(n) || n.__v_raw && !(e && n.__v_isReactive))
    return n;
  const s = aJ(n);
  if (s === 0)
    return n;
  const o = i.get(n);
  if (o)
    return o;
  const l = new Proxy(
    n,
    s === 2 ? r : t
  );
  return i.set(n, l), l;
}
function af(n) {
  return Ia(n) ? af(n.__v_raw) : !!(n && n.__v_isReactive);
}
function Ia(n) {
  return !!(n && n.__v_isReadonly);
}
function Li(n) {
  return !!(n && n.__v_isShallow);
}
function av(n) {
  return n ? !!n.__v_raw : !1;
}
function bt(n) {
  const e = n && n.__v_raw;
  return e ? bt(e) : n;
}
function uJ(n) {
  return !vt(n, "__v_skip") && Object.isExtensible(n) && jf(n, "__v_skip", !0), n;
}
const sr = (n) => un(n) ? ov(n) : n, n5 = (n) => un(n) ? eE(n) : n;
function Jn(n) {
  return n ? n.__v_isRef === !0 : !1;
}
function Ae(n) {
  return tE(n, !1);
}
function Am(n) {
  return tE(n, !0);
}
function tE(n, e) {
  return Jn(n) ? n : new hJ(n, e);
}
class hJ {
  constructor(e, t) {
    this.dep = new rv(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : bt(e), this._value = t ? e : sr(e), this.__v_isShallow = t;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    const t = this._rawValue, r = this.__v_isShallow || Li(e) || Ia(e);
    e = r ? e : bt(e), sl(e, t) && (this._rawValue = e, this._value = r ? e : sr(e), this.dep.trigger());
  }
}
function fJ(n) {
  return Jn(n) ? n.value : n;
}
const dJ = {
  get: (n, e, t) => e === "__v_raw" ? n : fJ(Reflect.get(n, e, t)),
  set: (n, e, t, r) => {
    const i = n[e];
    return Jn(i) && !Jn(t) ? (i.value = t, !0) : Reflect.set(n, e, t, r);
  }
};
function nE(n) {
  return af(n) ? n : new Proxy(n, dJ);
}
class pJ {
  constructor(e, t, r) {
    this.fn = e, this.setter = t, this._value = void 0, this.dep = new rv(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Uf - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !t, this.isSSR = r;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Lt !== this)
      return VO(this, !0), !0;
  }
  get value() {
    const e = this.dep.track();
    return jO(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
function mJ(n, e, t = !1) {
  let r, i;
  return tt(n) ? r = n : (r = n.get, i = n.set), new pJ(r, i, t);
}
const g0 = {}, Om = /* @__PURE__ */ new WeakMap();
let Wl;
function gJ(n, e = !1, t = Wl) {
  if (t) {
    let r = Om.get(t);
    r || Om.set(t, r = []), r.push(n);
  }
}
function yJ(n, e, t = Bt) {
  const { immediate: r, deep: i, once: s, scheduler: o, augmentJob: l, call: a } = t, c = (C) => i ? C : Li(C) || i === !1 || i === 0 ? Uo(C, 1) : Uo(C);
  let u, h, f, d, p = !1, m = !1;
  if (Jn(n) ? (h = () => n.value, p = Li(n)) : af(n) ? (h = () => c(n), p = !0) : Ze(n) ? (m = !0, p = n.some((C) => af(C) || Li(C)), h = () => n.map((C) => {
    if (Jn(C))
      return C.value;
    if (af(C))
      return c(C);
    if (tt(C))
      return a ? a(C, 2) : C();
  })) : tt(n) ? e ? h = a ? () => a(n, 2) : n : h = () => {
    if (f) {
      ho();
      try {
        f();
      } finally {
        fo();
      }
    }
    const C = Wl;
    Wl = u;
    try {
      return a ? a(n, 3, [d]) : n(d);
    } finally {
      Wl = C;
    }
  } : h = Pi, e && i) {
    const C = h, M = i === !0 ? 1 / 0 : i;
    h = () => Uo(C(), M);
  }
  const g = WY(), b = () => {
    u.stop(), g && g.active && Jb(g.effects, u);
  };
  if (s && e) {
    const C = e;
    e = (...M) => {
      C(...M), b();
    };
  }
  let w = m ? new Array(n.length).fill(g0) : g0;
  const k = (C) => {
    if (!(!(u.flags & 1) || !u.dirty && !C))
      if (e) {
        const M = u.run();
        if (i || p || (m ? M.some((T, N) => sl(T, w[N])) : sl(M, w))) {
          f && f();
          const T = Wl;
          Wl = u;
          try {
            const N = [
              M,
              // pass undefined as the old value when it's changed for the first time
              w === g0 ? void 0 : m && w[0] === g0 ? [] : w,
              d
            ];
            w = M, a ? a(e, 3, N) : (
              // @ts-expect-error
              e(...N)
            );
          } finally {
            Wl = T;
          }
        }
      } else
        u.run();
  };
  return l && l(k), u = new HO(h), u.scheduler = o ? () => o(k, !1) : k, d = (C) => gJ(C, !1, u), f = u.onStop = () => {
    const C = Om.get(u);
    if (C) {
      if (a)
        a(C, 4);
      else
        for (const M of C) M();
      Om.delete(u);
    }
  }, e ? r ? k(!0) : w = u.run() : o ? o(k.bind(null, !0), !0) : u.run(), b.pause = u.pause.bind(u), b.resume = u.resume.bind(u), b.stop = b, b;
}
function Uo(n, e = 1 / 0, t) {
  if (e <= 0 || !un(n) || n.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(n)))
    return n;
  if (t.add(n), e--, Jn(n))
    Uo(n.value, e, t);
  else if (Ze(n))
    for (let r = 0; r < n.length; r++)
      Uo(n[r], e, t);
  else if (IY(n) || rf(n))
    n.forEach((r) => {
      Uo(r, e, t);
    });
  else if (RY(n)) {
    for (const r in n)
      Uo(n[r], e, t);
    for (const r of Object.getOwnPropertySymbols(n))
      Object.prototype.propertyIsEnumerable.call(n, r) && Uo(n[r], e, t);
  }
  return n;
}
/**
* @vue/runtime-core v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function xd(n, e, t, r) {
  try {
    return r ? n(...r) : n();
  } catch (i) {
    W1(i, e, t);
  }
}
function Cs(n, e, t, r) {
  if (tt(n)) {
    const i = xd(n, e, t, r);
    return i && BO(i) && i.catch((s) => {
      W1(s, e, t);
    }), i;
  }
  if (Ze(n)) {
    const i = [];
    for (let s = 0; s < n.length; s++)
      i.push(Cs(n[s], e, t, r));
    return i;
  }
}
function W1(n, e, t, r = !0) {
  const i = e ? e.vnode : null, { errorHandler: s, throwUnhandledErrorInProduction: o } = e && e.appContext.config || Bt;
  if (e) {
    let l = e.parent;
    const a = e.proxy, c = `https://vuejs.org/error-reference/#runtime-${t}`;
    for (; l; ) {
      const u = l.ec;
      if (u) {
        for (let h = 0; h < u.length; h++)
          if (u[h](n, a, c) === !1)
            return;
      }
      l = l.parent;
    }
    if (s) {
      ho(), xd(s, null, 10, [
        n,
        a,
        c
      ]), fo();
      return;
    }
  }
  bJ(n, t, i, r, o);
}
function bJ(n, e, t, r = !0, i = !1) {
  if (i)
    throw n;
  console.error(n);
}
const or = [];
let ns = -1;
const Sc = [];
let $o = null, rc = 0;
const rE = /* @__PURE__ */ Promise.resolve();
let Em = null;
function vJ(n) {
  const e = Em || rE;
  return n ? e.then(this ? n.bind(this) : n) : e;
}
function wJ(n) {
  let e = ns + 1, t = or.length;
  for (; e < t; ) {
    const r = e + t >>> 1, i = or[r], s = Gf(i);
    s < n || s === n && i.flags & 2 ? e = r + 1 : t = r;
  }
  return e;
}
function cv(n) {
  if (!(n.flags & 1)) {
    const e = Gf(n), t = or[or.length - 1];
    !t || // fast path when the job id is larger than the tail
    !(n.flags & 2) && e >= Gf(t) ? or.push(n) : or.splice(wJ(e), 0, n), n.flags |= 1, iE();
  }
}
function iE() {
  Em || (Em = rE.then(oE));
}
function xJ(n) {
  Ze(n) ? Sc.push(...n) : $o && n.id === -1 ? $o.splice(rc + 1, 0, n) : n.flags & 1 || (Sc.push(n), n.flags |= 1), iE();
}
function w8(n, e, t = ns + 1) {
  for (; t < or.length; t++) {
    const r = or[t];
    if (r && r.flags & 2) {
      if (n && r.id !== n.uid)
        continue;
      or.splice(t, 1), t--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2);
    }
  }
}
function sE(n) {
  if (Sc.length) {
    const e = [...new Set(Sc)].sort(
      (t, r) => Gf(t) - Gf(r)
    );
    if (Sc.length = 0, $o) {
      $o.push(...e);
      return;
    }
    for ($o = e, rc = 0; rc < $o.length; rc++) {
      const t = $o[rc];
      t.flags & 4 && (t.flags &= -2), t.flags & 8 || t(), t.flags &= -2;
    }
    $o = null, rc = 0;
  }
}
const Gf = (n) => n.id == null ? n.flags & 2 ? -1 : 1 / 0 : n.id;
function oE(n) {
  try {
    for (ns = 0; ns < or.length; ns++) {
      const e = or[ns];
      e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), xd(
        e,
        e.i,
        e.i ? 15 : 14
      ), e.flags & 4 || (e.flags &= -2));
    }
  } finally {
    for (; ns < or.length; ns++) {
      const e = or[ns];
      e && (e.flags &= -2);
    }
    ns = -1, or.length = 0, sE(), Em = null, (or.length || Sc.length) && oE();
  }
}
let cs, gh = [], r5 = !1;
function j1(n, ...e) {
  cs ? cs.emit(n, ...e) : r5 || gh.push({ event: n, args: e });
}
function lE(n, e) {
  var t, r;
  cs = n, cs ? (cs.enabled = !0, gh.forEach(({ event: i, args: s }) => cs.emit(i, ...s)), gh = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((r = (t = window.navigator) == null ? void 0 : t.userAgent) != null && r.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {
    lE(s, e);
  }), setTimeout(() => {
    cs || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, r5 = !0, gh = []);
  }, 3e3)) : (r5 = !0, gh = []);
}
function kJ(n, e) {
  j1("app:init", n, e, {
    Fragment: Ln,
    Text: Cd,
    Comment: Da,
    Static: xp
  });
}
function SJ(n) {
  j1("app:unmount", n);
}
const CJ = /* @__PURE__ */ uv(
  "component:added"
  /* COMPONENT_ADDED */
), aE = /* @__PURE__ */ uv(
  "component:updated"
  /* COMPONENT_UPDATED */
), MJ = /* @__PURE__ */ uv(
  "component:removed"
  /* COMPONENT_REMOVED */
), TJ = (n) => {
  cs && typeof cs.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !cs.cleanupBuffer(n) && MJ(n);
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function uv(n) {
  return (e) => {
    j1(
      n,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
function AJ(n, e, t) {
  j1(
    "component:emit",
    n.appContext.app,
    n,
    e,
    t
  );
}
let ds = null, cE = null;
function Im(n) {
  const e = ds;
  return ds = n, cE = n && n.type.__scopeId || null, e;
}
function OJ(n, e = ds, t) {
  if (!e || n._n)
    return n;
  const r = (...i) => {
    r._d && E8(-1);
    const s = Im(e);
    let o;
    try {
      o = n(...i);
    } finally {
      Im(s), r._d && E8(1);
    }
    return __VUE_PROD_DEVTOOLS__ && aE(e), o;
  };
  return r._n = !0, r._c = !0, r._d = !0, r;
}
function Pl(n, e, t, r) {
  const i = n.dirs, s = e && e.dirs;
  for (let o = 0; o < i.length; o++) {
    const l = i[o];
    s && (l.oldValue = s[o].value);
    let a = l.dir[r];
    a && (ho(), Cs(a, t, 8, [
      n.el,
      l,
      n,
      e
    ]), fo());
  }
}
const EJ = Symbol("_vte"), IJ = (n) => n.__isTeleport;
function hv(n, e) {
  n.shapeFlag & 6 && n.component ? (n.transition = e, hv(n.component.subTree, e)) : n.shapeFlag & 128 ? (n.ssContent.transition = e.clone(n.ssContent), n.ssFallback.transition = e.clone(n.ssFallback)) : n.transition = e;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function $n(n, e) {
  return tt(n) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Xn({ name: n.name }, e, { setup: n })
  ) : n;
}
function uE(n) {
  n.ids = [n.ids[0] + n.ids[2]++ + "-", 0, 0];
}
function cf(n, e, t, r, i = !1) {
  if (Ze(n)) {
    n.forEach(
      (p, m) => cf(
        p,
        e && (Ze(e) ? e[m] : e),
        t,
        r,
        i
      )
    );
    return;
  }
  if (uf(r) && !i) {
    r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && cf(n, e, t, r.component.subTree);
    return;
  }
  const s = r.shapeFlag & 4 ? yv(r.component) : r.el, o = i ? null : s, { i: l, r: a } = n, c = e && e.r, u = l.refs === Bt ? l.refs = {} : l.refs, h = l.setupState, f = bt(h), d = h === Bt ? () => !1 : (p) => vt(f, p);
  if (c != null && c !== a && (An(c) ? (u[c] = null, d(c) && (h[c] = null)) : Jn(c) && (c.value = null)), tt(a))
    xd(a, l, 12, [o, u]);
  else {
    const p = An(a), m = Jn(a);
    if (p || m) {
      const g = () => {
        if (n.f) {
          const b = p ? d(a) ? h[a] : u[a] : a.value;
          i ? Ze(b) && Jb(b, s) : Ze(b) ? b.includes(s) || b.push(s) : p ? (u[a] = [s], d(a) && (h[a] = u[a])) : (a.value = [s], n.k && (u[n.k] = a.value));
        } else p ? (u[a] = o, d(a) && (h[a] = o)) : m && (a.value = o, n.k && (u[n.k] = o));
      };
      o ? (g.id = -1, qr(g, t)) : g();
    }
  }
}
da().requestIdleCallback;
da().cancelIdleCallback;
const uf = (n) => !!n.type.__asyncLoader, hE = (n) => n.type.__isKeepAlive;
function DJ(n, e) {
  fE(n, "a", e);
}
function NJ(n, e) {
  fE(n, "da", e);
}
function fE(n, e, t = ar) {
  const r = n.__wdc || (n.__wdc = () => {
    let i = t;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return n();
  });
  if (U1(e, r, t), t) {
    let i = t.parent;
    for (; i && i.parent; )
      hE(i.parent.vnode) && RJ(r, e, t, i), i = i.parent;
  }
}
function RJ(n, e, t, r) {
  const i = U1(
    e,
    n,
    r,
    !0
    /* prepend */
  );
  Sd(() => {
    Jb(r[e], i);
  }, t);
}
function U1(n, e, t = ar, r = !1) {
  if (t) {
    const i = t[n] || (t[n] = []), s = e.__weh || (e.__weh = (...o) => {
      ho();
      const l = Md(t), a = Cs(e, t, n, o);
      return l(), fo(), a;
    });
    return r ? i.unshift(s) : i.push(s), s;
  }
}
const So = (n) => (e, t = ar) => {
  (!Yf || n === "sp") && U1(n, (...r) => e(...r), t);
}, PJ = So("bm"), kd = So("m"), _J = So(
  "bu"
), LJ = So("u"), BJ = So(
  "bum"
), Sd = So("um"), zJ = So(
  "sp"
), FJ = So("rtg"), HJ = So("rtc");
function $J(n, e = ar) {
  U1("ec", n, e);
}
const VJ = Symbol.for("v-ndc"), i5 = (n) => n ? IE(n) ? yv(n) : i5(n.parent) : null, hf = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Xn(/* @__PURE__ */ Object.create(null), {
    $: (n) => n,
    $el: (n) => n.vnode.el,
    $data: (n) => n.data,
    $props: (n) => n.props,
    $attrs: (n) => n.attrs,
    $slots: (n) => n.slots,
    $refs: (n) => n.refs,
    $parent: (n) => i5(n.parent),
    $root: (n) => i5(n.root),
    $host: (n) => n.ce,
    $emit: (n) => n.emit,
    $options: (n) => __VUE_OPTIONS_API__ ? pE(n) : n.type,
    $forceUpdate: (n) => n.f || (n.f = () => {
      cv(n.update);
    }),
    $nextTick: (n) => n.n || (n.n = vJ.bind(n.proxy)),
    $watch: (n) => __VUE_OPTIONS_API__ ? hX.bind(n) : Pi
  })
), R2 = (n, e) => n !== Bt && !n.__isScriptSetup && vt(n, e), qJ = {
  get({ _: n }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: t, setupState: r, data: i, props: s, accessCache: o, type: l, appContext: a } = n;
    let c;
    if (e[0] !== "$") {
      const d = o[e];
      if (d !== void 0)
        switch (d) {
          case 1:
            return r[e];
          case 2:
            return i[e];
          case 4:
            return t[e];
          case 3:
            return s[e];
        }
      else {
        if (R2(r, e))
          return o[e] = 1, r[e];
        if (i !== Bt && vt(i, e))
          return o[e] = 2, i[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (c = n.propsOptions[0]) && vt(c, e)
        )
          return o[e] = 3, s[e];
        if (t !== Bt && vt(t, e))
          return o[e] = 4, t[e];
        (!__VUE_OPTIONS_API__ || s5) && (o[e] = 0);
      }
    }
    const u = hf[e];
    let h, f;
    if (u)
      return e === "$attrs" && jn(n.attrs, "get", ""), u(n);
    if (
      // css module (injected by vue-loader)
      (h = l.__cssModules) && (h = h[e])
    )
      return h;
    if (t !== Bt && vt(t, e))
      return o[e] = 4, t[e];
    if (
      // global properties
      f = a.config.globalProperties, vt(f, e)
    )
      return f[e];
  },
  set({ _: n }, e, t) {
    const { data: r, setupState: i, ctx: s } = n;
    return R2(i, e) ? (i[e] = t, !0) : r !== Bt && vt(r, e) ? (r[e] = t, !0) : vt(n.props, e) || e[0] === "$" && e.slice(1) in n ? !1 : (s[e] = t, !0);
  },
  has({
    _: { data: n, setupState: e, accessCache: t, ctx: r, appContext: i, propsOptions: s }
  }, o) {
    let l;
    return !!t[o] || n !== Bt && vt(n, o) || R2(e, o) || (l = s[0]) && vt(l, o) || vt(r, o) || vt(hf, o) || vt(i.config.globalProperties, o);
  },
  defineProperty(n, e, t) {
    return t.get != null ? n._.accessCache[e] = 0 : vt(t, "value") && this.set(n, e, t.value, null), Reflect.defineProperty(n, e, t);
  }
};
function x8(n) {
  return Ze(n) ? n.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : n;
}
let s5 = !0;
function WJ(n) {
  const e = pE(n), t = n.proxy, r = n.ctx;
  s5 = !1, e.beforeCreate && k8(e.beforeCreate, n, "bc");
  const {
    // state
    data: i,
    computed: s,
    methods: o,
    watch: l,
    provide: a,
    inject: c,
    // lifecycle
    created: u,
    beforeMount: h,
    mounted: f,
    beforeUpdate: d,
    updated: p,
    activated: m,
    deactivated: g,
    beforeDestroy: b,
    beforeUnmount: w,
    destroyed: k,
    unmounted: C,
    render: M,
    renderTracked: T,
    renderTriggered: N,
    errorCaptured: B,
    serverPrefetch: $,
    // public API
    expose: R,
    inheritAttrs: V,
    // assets
    components: z,
    directives: ue,
    filters: ie
  } = e;
  if (c && jJ(c, r, null), o)
    for (const ye in o) {
      const be = o[ye];
      tt(be) && (r[ye] = be.bind(t));
    }
  if (i) {
    const ye = i.call(t, t);
    un(ye) && (n.data = ov(ye));
  }
  if (s5 = !0, s)
    for (const ye in s) {
      const be = s[ye], ze = tt(be) ? be.bind(t, t) : tt(be.get) ? be.get.bind(t, t) : Pi, I = !tt(be) && tt(be.set) ? be.set.bind(t) : Pi, Ie = Na({
        get: ze,
        set: I
      });
      Object.defineProperty(r, ye, {
        enumerable: !0,
        configurable: !0,
        get: () => Ie.value,
        set: (Ve) => Ie.value = Ve
      });
    }
  if (l)
    for (const ye in l)
      dE(l[ye], r, t, ye);
  if (a) {
    const ye = tt(a) ? a.call(t) : a;
    Reflect.ownKeys(ye).forEach((be) => {
      XJ(be, ye[be]);
    });
  }
  u && k8(u, n, "c");
  function Ce(ye, be) {
    Ze(be) ? be.forEach((ze) => ye(ze.bind(t))) : be && ye(be.bind(t));
  }
  if (Ce(PJ, h), Ce(kd, f), Ce(_J, d), Ce(LJ, p), Ce(DJ, m), Ce(NJ, g), Ce($J, B), Ce(HJ, T), Ce(FJ, N), Ce(BJ, w), Ce(Sd, C), Ce(zJ, $), Ze(R))
    if (R.length) {
      const ye = n.exposed || (n.exposed = {});
      R.forEach((be) => {
        Object.defineProperty(ye, be, {
          get: () => t[be],
          set: (ze) => t[be] = ze,
          enumerable: !0
        });
      });
    } else n.exposed || (n.exposed = {});
  M && n.render === Pi && (n.render = M), V != null && (n.inheritAttrs = V), z && (n.components = z), ue && (n.directives = ue), $ && uE(n);
}
function jJ(n, e, t = Pi) {
  Ze(n) && (n = o5(n));
  for (const r in n) {
    const i = n[r];
    let s;
    un(i) ? "default" in i ? s = wp(
      i.from || r,
      i.default,
      !0
    ) : s = wp(i.from || r) : s = wp(i), Jn(s) ? Object.defineProperty(e, r, {
      enumerable: !0,
      configurable: !0,
      get: () => s.value,
      set: (o) => s.value = o
    }) : e[r] = s;
  }
}
function k8(n, e, t) {
  Cs(
    Ze(n) ? n.map((r) => r.bind(e.proxy)) : n.bind(e.proxy),
    e,
    t
  );
}
function dE(n, e, t, r) {
  let i = r.includes(".") ? TE(t, r) : () => t[r];
  if (An(n)) {
    const s = e[n];
    tt(s) && Mc(i, s);
  } else if (tt(n))
    Mc(i, n.bind(t));
  else if (un(n))
    if (Ze(n))
      n.forEach((s) => dE(s, e, t, r));
    else {
      const s = tt(n.handler) ? n.handler.bind(t) : e[n.handler];
      tt(s) && Mc(i, s, n);
    }
}
function pE(n) {
  const e = n.type, { mixins: t, extends: r } = e, {
    mixins: i,
    optionsCache: s,
    config: { optionMergeStrategies: o }
  } = n.appContext, l = s.get(e);
  let a;
  return l ? a = l : !i.length && !t && !r ? a = e : (a = {}, i.length && i.forEach(
    (c) => Dm(a, c, o, !0)
  ), Dm(a, e, o)), un(e) && s.set(e, a), a;
}
function Dm(n, e, t, r = !1) {
  const { mixins: i, extends: s } = e;
  s && Dm(n, s, t, !0), i && i.forEach(
    (o) => Dm(n, o, t, !0)
  );
  for (const o in e)
    if (!(r && o === "expose")) {
      const l = UJ[o] || t && t[o];
      n[o] = l ? l(n[o], e[o]) : e[o];
    }
  return n;
}
const UJ = {
  data: S8,
  props: C8,
  emits: C8,
  // objects
  methods: yh,
  computed: yh,
  // lifecycle
  beforeCreate: ir,
  created: ir,
  beforeMount: ir,
  mounted: ir,
  beforeUpdate: ir,
  updated: ir,
  beforeDestroy: ir,
  beforeUnmount: ir,
  destroyed: ir,
  unmounted: ir,
  activated: ir,
  deactivated: ir,
  errorCaptured: ir,
  serverPrefetch: ir,
  // assets
  components: yh,
  directives: yh,
  // watch
  watch: GJ,
  // provide / inject
  provide: S8,
  inject: KJ
};
function S8(n, e) {
  return e ? n ? function() {
    return Xn(
      tt(n) ? n.call(this, this) : n,
      tt(e) ? e.call(this, this) : e
    );
  } : e : n;
}
function KJ(n, e) {
  return yh(o5(n), o5(e));
}
function o5(n) {
  if (Ze(n)) {
    const e = {};
    for (let t = 0; t < n.length; t++)
      e[n[t]] = n[t];
    return e;
  }
  return n;
}
function ir(n, e) {
  return n ? [...new Set([].concat(n, e))] : e;
}
function yh(n, e) {
  return n ? Xn(/* @__PURE__ */ Object.create(null), n, e) : e;
}
function C8(n, e) {
  return n ? Ze(n) && Ze(e) ? [.../* @__PURE__ */ new Set([...n, ...e])] : Xn(
    /* @__PURE__ */ Object.create(null),
    x8(n),
    x8(e ?? {})
  ) : e;
}
function GJ(n, e) {
  if (!n) return e;
  if (!e) return n;
  const t = Xn(/* @__PURE__ */ Object.create(null), n);
  for (const r in e)
    t[r] = ir(n[r], e[r]);
  return t;
}
function mE() {
  return {
    app: null,
    config: {
      isNativeTag: OY,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let YJ = 0;
function JJ(n, e) {
  return function(r, i = null) {
    tt(r) || (r = Xn({}, r)), i != null && !un(i) && (i = null);
    const s = mE(), o = /* @__PURE__ */ new WeakSet(), l = [];
    let a = !1;
    const c = s.app = {
      _uid: YJ++,
      _component: r,
      _props: i,
      _container: null,
      _context: s,
      _instance: null,
      version: N8,
      get config() {
        return s.config;
      },
      set config(u) {
      },
      use(u, ...h) {
        return o.has(u) || (u && tt(u.install) ? (o.add(u), u.install(c, ...h)) : tt(u) && (o.add(u), u(c, ...h))), c;
      },
      mixin(u) {
        return __VUE_OPTIONS_API__ && (s.mixins.includes(u) || s.mixins.push(u)), c;
      },
      component(u, h) {
        return h ? (s.components[u] = h, c) : s.components[u];
      },
      directive(u, h) {
        return h ? (s.directives[u] = h, c) : s.directives[u];
      },
      mount(u, h, f) {
        if (!a) {
          const d = c._ceVNode || Di(r, i);
          return d.appContext = s, f === !0 ? f = "svg" : f === !1 && (f = void 0), n(d, u, f), a = !0, c._container = u, u.__vue_app__ = c, __VUE_PROD_DEVTOOLS__ && (c._instance = d.component, kJ(c, N8)), yv(d.component);
        }
      },
      onUnmount(u) {
        l.push(u);
      },
      unmount() {
        a && (Cs(
          l,
          c._instance,
          16
        ), n(null, c._container), __VUE_PROD_DEVTOOLS__ && (c._instance = null, SJ(c)), delete c._container.__vue_app__);
      },
      provide(u, h) {
        return s.provides[u] = h, c;
      },
      runWithContext(u) {
        const h = Cc;
        Cc = c;
        try {
          return u();
        } finally {
          Cc = h;
        }
      }
    };
    return c;
  };
}
let Cc = null;
function XJ(n, e) {
  if (ar) {
    let t = ar.provides;
    const r = ar.parent && ar.parent.provides;
    r === t && (t = ar.provides = Object.create(r)), t[n] = e;
  }
}
function wp(n, e, t = !1) {
  const r = AX();
  if (r || Cc) {
    let i = Cc ? Cc._context.provides : r ? r.parent == null || r.ce ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
    if (i && n in i)
      return i[n];
    if (arguments.length > 1)
      return t && tt(e) ? e.call(r && r.proxy) : e;
  }
}
const gE = {}, yE = () => Object.create(gE), bE = (n) => Object.getPrototypeOf(n) === gE;
function ZJ(n, e, t, r = !1) {
  const i = {}, s = yE();
  n.propsDefaults = /* @__PURE__ */ Object.create(null), vE(n, e, i, s);
  for (const o in n.propsOptions[0])
    o in i || (i[o] = void 0);
  t ? n.props = r ? i : cJ(i) : n.type.props ? n.props = i : n.props = s, n.attrs = s;
}
function QJ(n, e, t, r) {
  const {
    props: i,
    attrs: s,
    vnode: { patchFlag: o }
  } = n, l = bt(i), [a] = n.propsOptions;
  let c = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (r || o > 0) && !(o & 16)
  ) {
    if (o & 8) {
      const u = n.vnode.dynamicProps;
      for (let h = 0; h < u.length; h++) {
        let f = u[h];
        if (K1(n.emitsOptions, f))
          continue;
        const d = e[f];
        if (a)
          if (vt(s, f))
            d !== s[f] && (s[f] = d, c = !0);
          else {
            const p = gl(f);
            i[p] = l5(
              a,
              l,
              p,
              d,
              n,
              !1
            );
          }
        else
          d !== s[f] && (s[f] = d, c = !0);
      }
    }
  } else {
    vE(n, e, i, s) && (c = !0);
    let u;
    for (const h in l)
      (!e || // for camelCase
      !vt(e, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((u = Fa(h)) === h || !vt(e, u))) && (a ? t && // for camelCase
      (t[h] !== void 0 || // for kebab-case
      t[u] !== void 0) && (i[h] = l5(
        a,
        l,
        h,
        void 0,
        n,
        !0
      )) : delete i[h]);
    if (s !== l)
      for (const h in s)
        (!e || !vt(e, h)) && (delete s[h], c = !0);
  }
  c && Js(n.attrs, "set", "");
}
function vE(n, e, t, r) {
  const [i, s] = n.propsOptions;
  let o = !1, l;
  if (e)
    for (let a in e) {
      if (sf(a))
        continue;
      const c = e[a];
      let u;
      i && vt(i, u = gl(a)) ? !s || !s.includes(u) ? t[u] = c : (l || (l = {}))[u] = c : K1(n.emitsOptions, a) || (!(a in r) || c !== r[a]) && (r[a] = c, o = !0);
    }
  if (s) {
    const a = bt(t), c = l || Bt;
    for (let u = 0; u < s.length; u++) {
      const h = s[u];
      t[h] = l5(
        i,
        a,
        h,
        c[h],
        n,
        !vt(c, h)
      );
    }
  }
  return o;
}
function l5(n, e, t, r, i, s) {
  const o = n[t];
  if (o != null) {
    const l = vt(o, "default");
    if (l && r === void 0) {
      const a = o.default;
      if (o.type !== Function && !o.skipFactory && tt(a)) {
        const { propsDefaults: c } = i;
        if (t in c)
          r = c[t];
        else {
          const u = Md(i);
          r = c[t] = a.call(
            null,
            e
          ), u();
        }
      } else
        r = a;
      i.ce && i.ce._setProp(t, r);
    }
    o[
      0
      /* shouldCast */
    ] && (s && !l ? r = !1 : o[
      1
      /* shouldCastTrue */
    ] && (r === "" || r === Fa(t)) && (r = !0));
  }
  return r;
}
const eX = /* @__PURE__ */ new WeakMap();
function wE(n, e, t = !1) {
  const r = __VUE_OPTIONS_API__ && t ? eX : e.propsCache, i = r.get(n);
  if (i)
    return i;
  const s = n.props, o = {}, l = [];
  let a = !1;
  if (__VUE_OPTIONS_API__ && !tt(n)) {
    const u = (h) => {
      a = !0;
      const [f, d] = wE(h, e, !0);
      Xn(o, f), d && l.push(...d);
    };
    !t && e.mixins.length && e.mixins.forEach(u), n.extends && u(n.extends), n.mixins && n.mixins.forEach(u);
  }
  if (!s && !a)
    return un(n) && r.set(n, nf), nf;
  if (Ze(s))
    for (let u = 0; u < s.length; u++) {
      const h = gl(s[u]);
      M8(h) && (o[h] = Bt);
    }
  else if (s)
    for (const u in s) {
      const h = gl(u);
      if (M8(h)) {
        const f = s[u], d = o[h] = Ze(f) || tt(f) ? { type: f } : Xn({}, f), p = d.type;
        let m = !1, g = !0;
        if (Ze(p))
          for (let b = 0; b < p.length; ++b) {
            const w = p[b], k = tt(w) && w.name;
            if (k === "Boolean") {
              m = !0;
              break;
            } else k === "String" && (g = !1);
          }
        else
          m = tt(p) && p.name === "Boolean";
        d[
          0
          /* shouldCast */
        ] = m, d[
          1
          /* shouldCastTrue */
        ] = g, (m || vt(d, "default")) && l.push(h);
      }
    }
  const c = [o, l];
  return un(n) && r.set(n, c), c;
}
function M8(n) {
  return n[0] !== "$" && !sf(n);
}
const fv = (n) => n === "_" || n === "__" || n === "_ctx" || n === "$stable", dv = (n) => Ze(n) ? n.map(is) : [is(n)], tX = (n, e, t) => {
  if (e._n)
    return e;
  const r = OJ((...i) => dv(e(...i)), t);
  return r._c = !1, r;
}, xE = (n, e, t) => {
  const r = n._ctx;
  for (const i in n) {
    if (fv(i)) continue;
    const s = n[i];
    if (tt(s))
      e[i] = tX(i, s, r);
    else if (s != null) {
      const o = dv(s);
      e[i] = () => o;
    }
  }
}, kE = (n, e) => {
  const t = dv(e);
  n.slots.default = () => t;
}, SE = (n, e, t) => {
  for (const r in e)
    (t || !fv(r)) && (n[r] = e[r]);
}, nX = (n, e, t) => {
  const r = n.slots = yE();
  if (n.vnode.shapeFlag & 32) {
    const i = e.__;
    i && jf(r, "__", i, !0);
    const s = e._;
    s ? (SE(r, e, t), t && jf(r, "_", s, !0)) : xE(e, r);
  } else e && kE(n, e);
}, rX = (n, e, t) => {
  const { vnode: r, slots: i } = n;
  let s = !0, o = Bt;
  if (r.shapeFlag & 32) {
    const l = e._;
    l ? t && l === 1 ? s = !1 : SE(i, e, t) : (s = !e.$stable, xE(e, i)), o = e;
  } else e && (kE(n, e), o = { default: 1 });
  if (s)
    for (const l in i)
      !fv(l) && o[l] == null && delete i[l];
};
function iX() {
  typeof __VUE_OPTIONS_API__ != "boolean" && (da().__VUE_OPTIONS_API__ = !0), typeof __VUE_PROD_DEVTOOLS__ != "boolean" && (da().__VUE_PROD_DEVTOOLS__ = !1), typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" && (da().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1);
}
const qr = bX;
function sX(n) {
  return oX(n);
}
function oX(n, e) {
  iX();
  const t = da();
  t.__VUE__ = !0, __VUE_PROD_DEVTOOLS__ && lE(t.__VUE_DEVTOOLS_GLOBAL_HOOK__, t);
  const {
    insert: r,
    remove: i,
    patchProp: s,
    createElement: o,
    createText: l,
    createComment: a,
    setText: c,
    setElementText: u,
    parentNode: h,
    nextSibling: f,
    setScopeId: d = Pi,
    insertStaticContent: p
  } = n, m = (E, P, W, Q = null, J = null, Y = null, ae = void 0, re = null, oe = !!P.dynamicChildren) => {
    if (E === P)
      return;
    E && !$u(E, P) && (Q = Tt(E), Ve(E, J, Y, !0), E = null), P.patchFlag === -2 && (oe = !1, P.dynamicChildren = null);
    const { type: te, ref: De, shapeFlag: de } = P;
    switch (te) {
      case Cd:
        g(E, P, W, Q);
        break;
      case Da:
        b(E, P, W, Q);
        break;
      case xp:
        E == null && w(P, W, Q, ae);
        break;
      case Ln:
        z(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        );
        break;
      default:
        de & 1 ? M(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        ) : de & 6 ? ue(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        ) : (de & 64 || de & 128) && te.process(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe,
          Gt
        );
    }
    De != null && J ? cf(De, E && E.ref, Y, P || E, !P) : De == null && E && E.ref != null && cf(E.ref, null, Y, E, !0);
  }, g = (E, P, W, Q) => {
    if (E == null)
      r(
        P.el = l(P.children),
        W,
        Q
      );
    else {
      const J = P.el = E.el;
      P.children !== E.children && c(J, P.children);
    }
  }, b = (E, P, W, Q) => {
    E == null ? r(
      P.el = a(P.children || ""),
      W,
      Q
    ) : P.el = E.el;
  }, w = (E, P, W, Q) => {
    [E.el, E.anchor] = p(
      E.children,
      P,
      W,
      Q,
      E.el,
      E.anchor
    );
  }, k = ({ el: E, anchor: P }, W, Q) => {
    let J;
    for (; E && E !== P; )
      J = f(E), r(E, W, Q), E = J;
    r(P, W, Q);
  }, C = ({ el: E, anchor: P }) => {
    let W;
    for (; E && E !== P; )
      W = f(E), i(E), E = W;
    i(P);
  }, M = (E, P, W, Q, J, Y, ae, re, oe) => {
    P.type === "svg" ? ae = "svg" : P.type === "math" && (ae = "mathml"), E == null ? T(
      P,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe
    ) : $(
      E,
      P,
      J,
      Y,
      ae,
      re,
      oe
    );
  }, T = (E, P, W, Q, J, Y, ae, re) => {
    let oe, te;
    const { props: De, shapeFlag: de, transition: Te, dirs: Pe } = E;
    if (oe = E.el = o(
      E.type,
      Y,
      De && De.is,
      De
    ), de & 8 ? u(oe, E.children) : de & 16 && B(
      E.children,
      oe,
      null,
      Q,
      J,
      P2(E, Y),
      ae,
      re
    ), Pe && Pl(E, null, Q, "created"), N(oe, E, E.scopeId, ae, Q), De) {
      for (const X in De)
        X !== "value" && !sf(X) && s(oe, X, null, De[X], Y, Q);
      "value" in De && s(oe, "value", null, De.value, Y), (te = De.onVnodeBeforeMount) && Xi(te, Q, E);
    }
    __VUE_PROD_DEVTOOLS__ && (jf(oe, "__vnode", E, !0), jf(oe, "__vueParentComponent", Q, !0)), Pe && Pl(E, null, Q, "beforeMount");
    const F = lX(J, Te);
    F && Te.beforeEnter(oe), r(oe, P, W), ((te = De && De.onVnodeMounted) || F || Pe) && qr(() => {
      te && Xi(te, Q, E), F && Te.enter(oe), Pe && Pl(E, null, Q, "mounted");
    }, J);
  }, N = (E, P, W, Q, J) => {
    if (W && d(E, W), Q)
      for (let Y = 0; Y < Q.length; Y++)
        d(E, Q[Y]);
    if (J) {
      let Y = J.subTree;
      if (P === Y || OE(Y.type) && (Y.ssContent === P || Y.ssFallback === P)) {
        const ae = J.vnode;
        N(
          E,
          ae,
          ae.scopeId,
          ae.slotScopeIds,
          J.parent
        );
      }
    }
  }, B = (E, P, W, Q, J, Y, ae, re, oe = 0) => {
    for (let te = oe; te < E.length; te++) {
      const De = E[te] = re ? Vo(E[te]) : is(E[te]);
      m(
        null,
        De,
        P,
        W,
        Q,
        J,
        Y,
        ae,
        re
      );
    }
  }, $ = (E, P, W, Q, J, Y, ae) => {
    const re = P.el = E.el;
    __VUE_PROD_DEVTOOLS__ && (re.__vnode = P);
    let { patchFlag: oe, dynamicChildren: te, dirs: De } = P;
    oe |= E.patchFlag & 16;
    const de = E.props || Bt, Te = P.props || Bt;
    let Pe;
    if (W && _l(W, !1), (Pe = Te.onVnodeBeforeUpdate) && Xi(Pe, W, P, E), De && Pl(P, E, W, "beforeUpdate"), W && _l(W, !0), (de.innerHTML && Te.innerHTML == null || de.textContent && Te.textContent == null) && u(re, ""), te ? R(
      E.dynamicChildren,
      te,
      re,
      W,
      Q,
      P2(P, J),
      Y
    ) : ae || be(
      E,
      P,
      re,
      null,
      W,
      Q,
      P2(P, J),
      Y,
      !1
    ), oe > 0) {
      if (oe & 16)
        V(re, de, Te, W, J);
      else if (oe & 2 && de.class !== Te.class && s(re, "class", null, Te.class, J), oe & 4 && s(re, "style", de.style, Te.style, J), oe & 8) {
        const F = P.dynamicProps;
        for (let X = 0; X < F.length; X++) {
          const pe = F[X], _e = de[pe], je = Te[pe];
          (je !== _e || pe === "value") && s(re, pe, _e, je, J, W);
        }
      }
      oe & 1 && E.children !== P.children && u(re, P.children);
    } else !ae && te == null && V(re, de, Te, W, J);
    ((Pe = Te.onVnodeUpdated) || De) && qr(() => {
      Pe && Xi(Pe, W, P, E), De && Pl(P, E, W, "updated");
    }, Q);
  }, R = (E, P, W, Q, J, Y, ae) => {
    for (let re = 0; re < P.length; re++) {
      const oe = E[re], te = P[re], De = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oe.type === Ln || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !$u(oe, te) || // - In the case of a component, it could contain anything.
        oe.shapeFlag & 198) ? h(oe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          W
        )
      );
      m(
        oe,
        te,
        De,
        null,
        Q,
        J,
        Y,
        ae,
        !0
      );
    }
  }, V = (E, P, W, Q, J) => {
    if (P !== W) {
      if (P !== Bt)
        for (const Y in P)
          !sf(Y) && !(Y in W) && s(
            E,
            Y,
            P[Y],
            null,
            J,
            Q
          );
      for (const Y in W) {
        if (sf(Y)) continue;
        const ae = W[Y], re = P[Y];
        ae !== re && Y !== "value" && s(E, Y, re, ae, J, Q);
      }
      "value" in W && s(E, "value", P.value, W.value, J);
    }
  }, z = (E, P, W, Q, J, Y, ae, re, oe) => {
    const te = P.el = E ? E.el : l(""), De = P.anchor = E ? E.anchor : l("");
    let { patchFlag: de, dynamicChildren: Te, slotScopeIds: Pe } = P;
    Pe && (re = re ? re.concat(Pe) : Pe), E == null ? (r(te, W, Q), r(De, W, Q), B(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      P.children || [],
      W,
      De,
      J,
      Y,
      ae,
      re,
      oe
    )) : de > 0 && de & 64 && Te && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    E.dynamicChildren ? (R(
      E.dynamicChildren,
      Te,
      W,
      J,
      Y,
      ae,
      re
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (P.key != null || J && P === J.subTree) && CE(
      E,
      P,
      !0
      /* shallow */
    )) : be(
      E,
      P,
      W,
      De,
      J,
      Y,
      ae,
      re,
      oe
    );
  }, ue = (E, P, W, Q, J, Y, ae, re, oe) => {
    P.slotScopeIds = re, E == null ? P.shapeFlag & 512 ? J.ctx.activate(
      P,
      W,
      Q,
      ae,
      oe
    ) : ie(
      P,
      W,
      Q,
      J,
      Y,
      ae,
      oe
    ) : he(E, P, oe);
  }, ie = (E, P, W, Q, J, Y, ae) => {
    const re = E.component = TX(
      E,
      Q,
      J
    );
    if (hE(E) && (re.ctx.renderer = Gt), OX(re, !1, ae), re.asyncDep) {
      if (J && J.registerDep(re, Ce, ae), !E.el) {
        const oe = re.subTree = Di(Da);
        b(null, oe, P, W), E.placeholder = oe.el;
      }
    } else
      Ce(
        re,
        E,
        P,
        W,
        J,
        Y,
        ae
      );
  }, he = (E, P, W) => {
    const Q = P.component = E.component;
    if (gX(E, P, W))
      if (Q.asyncDep && !Q.asyncResolved) {
        ye(Q, P, W);
        return;
      } else
        Q.next = P, Q.update();
    else
      P.el = E.el, Q.vnode = P;
  }, Ce = (E, P, W, Q, J, Y, ae) => {
    const re = () => {
      if (E.isMounted) {
        let { next: de, bu: Te, u: Pe, parent: F, vnode: X } = E;
        {
          const _t = ME(E);
          if (_t) {
            de && (de.el = X.el, ye(E, de, ae)), _t.asyncDep.then(() => {
              E.isUnmounted || re();
            });
            return;
          }
        }
        let pe = de, _e;
        _l(E, !1), de ? (de.el = X.el, ye(E, de, ae)) : de = X, Te && E2(Te), (_e = de.props && de.props.onVnodeBeforeUpdate) && Xi(_e, F, de, X), _l(E, !0);
        const je = A8(E), kt = E.subTree;
        E.subTree = je, m(
          kt,
          je,
          // parent may have changed if it's in a teleport
          h(kt.el),
          // anchor may have changed if it's in a fragment
          Tt(kt),
          E,
          J,
          Y
        ), de.el = je.el, pe === null && yX(E, je.el), Pe && qr(Pe, J), (_e = de.props && de.props.onVnodeUpdated) && qr(
          () => Xi(_e, F, de, X),
          J
        ), __VUE_PROD_DEVTOOLS__ && aE(E);
      } else {
        let de;
        const { el: Te, props: Pe } = P, { bm: F, m: X, parent: pe, root: _e, type: je } = E, kt = uf(P);
        _l(E, !1), F && E2(F), !kt && (de = Pe && Pe.onVnodeBeforeMount) && Xi(de, pe, P), _l(E, !0);
        {
          _e.ce && // @ts-expect-error _def is private
          _e.ce._def.shadowRoot !== !1 && _e.ce._injectChildStyle(je);
          const _t = E.subTree = A8(E);
          m(
            null,
            _t,
            W,
            Q,
            E,
            J,
            Y
          ), P.el = _t.el;
        }
        if (X && qr(X, J), !kt && (de = Pe && Pe.onVnodeMounted)) {
          const _t = P;
          qr(
            () => Xi(de, pe, _t),
            J
          );
        }
        (P.shapeFlag & 256 || pe && uf(pe.vnode) && pe.vnode.shapeFlag & 256) && E.a && qr(E.a, J), E.isMounted = !0, __VUE_PROD_DEVTOOLS__ && CJ(E), P = W = Q = null;
      }
    };
    E.scope.on();
    const oe = E.effect = new HO(re);
    E.scope.off();
    const te = E.update = oe.run.bind(oe), De = E.job = oe.runIfDirty.bind(oe);
    De.i = E, De.id = E.uid, oe.scheduler = () => cv(De), _l(E, !0), te();
  }, ye = (E, P, W) => {
    P.component = E;
    const Q = E.vnode.props;
    E.vnode = P, E.next = null, QJ(E, P.props, Q, W), rX(E, P.children, W), ho(), w8(E), fo();
  }, be = (E, P, W, Q, J, Y, ae, re, oe = !1) => {
    const te = E && E.children, De = E ? E.shapeFlag : 0, de = P.children, { patchFlag: Te, shapeFlag: Pe } = P;
    if (Te > 0) {
      if (Te & 128) {
        I(
          te,
          de,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        );
        return;
      } else if (Te & 256) {
        ze(
          te,
          de,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        );
        return;
      }
    }
    Pe & 8 ? (De & 16 && et(te, J, Y), de !== te && u(W, de)) : De & 16 ? Pe & 16 ? I(
      te,
      de,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe
    ) : et(te, J, Y, !0) : (De & 8 && u(W, ""), Pe & 16 && B(
      de,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe
    ));
  }, ze = (E, P, W, Q, J, Y, ae, re, oe) => {
    E = E || nf, P = P || nf;
    const te = E.length, De = P.length, de = Math.min(te, De);
    let Te;
    for (Te = 0; Te < de; Te++) {
      const Pe = P[Te] = oe ? Vo(P[Te]) : is(P[Te]);
      m(
        E[Te],
        Pe,
        W,
        null,
        J,
        Y,
        ae,
        re,
        oe
      );
    }
    te > De ? et(
      E,
      J,
      Y,
      !0,
      !1,
      de
    ) : B(
      P,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe,
      de
    );
  }, I = (E, P, W, Q, J, Y, ae, re, oe) => {
    let te = 0;
    const De = P.length;
    let de = E.length - 1, Te = De - 1;
    for (; te <= de && te <= Te; ) {
      const Pe = E[te], F = P[te] = oe ? Vo(P[te]) : is(P[te]);
      if ($u(Pe, F))
        m(
          Pe,
          F,
          W,
          null,
          J,
          Y,
          ae,
          re,
          oe
        );
      else
        break;
      te++;
    }
    for (; te <= de && te <= Te; ) {
      const Pe = E[de], F = P[Te] = oe ? Vo(P[Te]) : is(P[Te]);
      if ($u(Pe, F))
        m(
          Pe,
          F,
          W,
          null,
          J,
          Y,
          ae,
          re,
          oe
        );
      else
        break;
      de--, Te--;
    }
    if (te > de) {
      if (te <= Te) {
        const Pe = Te + 1, F = Pe < De ? P[Pe].el : Q;
        for (; te <= Te; )
          m(
            null,
            P[te] = oe ? Vo(P[te]) : is(P[te]),
            W,
            F,
            J,
            Y,
            ae,
            re,
            oe
          ), te++;
      }
    } else if (te > Te)
      for (; te <= de; )
        Ve(E[te], J, Y, !0), te++;
    else {
      const Pe = te, F = te, X = /* @__PURE__ */ new Map();
      for (te = F; te <= Te; te++) {
        const xt = P[te] = oe ? Vo(P[te]) : is(P[te]);
        xt.key != null && X.set(xt.key, te);
      }
      let pe, _e = 0;
      const je = Te - F + 1;
      let kt = !1, _t = 0;
      const Yt = new Array(je);
      for (te = 0; te < je; te++) Yt[te] = 0;
      for (te = Pe; te <= de; te++) {
        const xt = E[te];
        if (_e >= je) {
          Ve(xt, J, Y, !0);
          continue;
        }
        let mt;
        if (xt.key != null)
          mt = X.get(xt.key);
        else
          for (pe = F; pe <= Te; pe++)
            if (Yt[pe - F] === 0 && $u(xt, P[pe])) {
              mt = pe;
              break;
            }
        mt === void 0 ? Ve(xt, J, Y, !0) : (Yt[mt - F] = te + 1, mt >= _t ? _t = mt : kt = !0, m(
          xt,
          P[mt],
          W,
          null,
          J,
          Y,
          ae,
          re,
          oe
        ), _e++);
      }
      const on = kt ? aX(Yt) : nf;
      for (pe = on.length - 1, te = je - 1; te >= 0; te--) {
        const xt = F + te, mt = P[xt], Vn = P[xt + 1], En = xt + 1 < De ? (
          // #13559, fallback to el placeholder for unresolved async component
          Vn.el || Vn.placeholder
        ) : Q;
        Yt[te] === 0 ? m(
          null,
          mt,
          W,
          En,
          J,
          Y,
          ae,
          re,
          oe
        ) : kt && (pe < 0 || te !== on[pe] ? Ie(mt, W, En, 2) : pe--);
      }
    }
  }, Ie = (E, P, W, Q, J = null) => {
    const { el: Y, type: ae, transition: re, children: oe, shapeFlag: te } = E;
    if (te & 6) {
      Ie(E.component.subTree, P, W, Q);
      return;
    }
    if (te & 128) {
      E.suspense.move(P, W, Q);
      return;
    }
    if (te & 64) {
      ae.move(E, P, W, Gt);
      return;
    }
    if (ae === Ln) {
      r(Y, P, W);
      for (let de = 0; de < oe.length; de++)
        Ie(oe[de], P, W, Q);
      r(E.anchor, P, W);
      return;
    }
    if (ae === xp) {
      k(E, P, W);
      return;
    }
    if (Q !== 2 && te & 1 && re)
      if (Q === 0)
        re.beforeEnter(Y), r(Y, P, W), qr(() => re.enter(Y), J);
      else {
        const { leave: de, delayLeave: Te, afterLeave: Pe } = re, F = () => {
          E.ctx.isUnmounted ? i(Y) : r(Y, P, W);
        }, X = () => {
          de(Y, () => {
            F(), Pe && Pe();
          });
        };
        Te ? Te(Y, F, X) : X();
      }
    else
      r(Y, P, W);
  }, Ve = (E, P, W, Q = !1, J = !1) => {
    const {
      type: Y,
      props: ae,
      ref: re,
      children: oe,
      dynamicChildren: te,
      shapeFlag: De,
      patchFlag: de,
      dirs: Te,
      cacheIndex: Pe
    } = E;
    if (de === -2 && (J = !1), re != null && (ho(), cf(re, null, W, E, !0), fo()), Pe != null && (P.renderCache[Pe] = void 0), De & 256) {
      P.ctx.deactivate(E);
      return;
    }
    const F = De & 1 && Te, X = !uf(E);
    let pe;
    if (X && (pe = ae && ae.onVnodeBeforeUnmount) && Xi(pe, P, E), De & 6)
      Ue(E.component, W, Q);
    else {
      if (De & 128) {
        E.suspense.unmount(W, Q);
        return;
      }
      F && Pl(E, null, P, "beforeUnmount"), De & 64 ? E.type.remove(
        E,
        P,
        W,
        Gt,
        Q
      ) : te && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !te.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (Y !== Ln || de > 0 && de & 64) ? et(
        te,
        P,
        W,
        !1,
        !0
      ) : (Y === Ln && de & 384 || !J && De & 16) && et(oe, P, W), Q && O(E);
    }
    (X && (pe = ae && ae.onVnodeUnmounted) || F) && qr(() => {
      pe && Xi(pe, P, E), F && Pl(E, null, P, "unmounted");
    }, W);
  }, O = (E) => {
    const { type: P, el: W, anchor: Q, transition: J } = E;
    if (P === Ln) {
      pt(W, Q);
      return;
    }
    if (P === xp) {
      C(E);
      return;
    }
    const Y = () => {
      i(W), J && !J.persisted && J.afterLeave && J.afterLeave();
    };
    if (E.shapeFlag & 1 && J && !J.persisted) {
      const { leave: ae, delayLeave: re } = J, oe = () => ae(W, Y);
      re ? re(E.el, Y, oe) : oe();
    } else
      Y();
  }, pt = (E, P) => {
    let W;
    for (; E !== P; )
      W = f(E), i(E), E = W;
    i(P);
  }, Ue = (E, P, W) => {
    const {
      bum: Q,
      scope: J,
      job: Y,
      subTree: ae,
      um: re,
      m: oe,
      a: te,
      parent: De,
      slots: { __: de }
    } = E;
    T8(oe), T8(te), Q && E2(Q), De && Ze(de) && de.forEach((Te) => {
      De.renderCache[Te] = void 0;
    }), J.stop(), Y && (Y.flags |= 8, Ve(ae, E, P, W)), re && qr(re, P), qr(() => {
      E.isUnmounted = !0;
    }, P), P && P.pendingBranch && !P.isUnmounted && E.asyncDep && !E.asyncResolved && E.suspenseId === P.pendingId && (P.deps--, P.deps === 0 && P.resolve()), __VUE_PROD_DEVTOOLS__ && TJ(E);
  }, et = (E, P, W, Q = !1, J = !1, Y = 0) => {
    for (let ae = Y; ae < E.length; ae++)
      Ve(E[ae], P, W, Q, J);
  }, Tt = (E) => {
    if (E.shapeFlag & 6)
      return Tt(E.component.subTree);
    if (E.shapeFlag & 128)
      return E.suspense.next();
    const P = f(E.anchor || E.el), W = P && P[EJ];
    return W ? f(W) : P;
  };
  let Ht = !1;
  const sn = (E, P, W) => {
    E == null ? P._vnode && Ve(P._vnode, null, null, !0) : m(
      P._vnode || null,
      E,
      P,
      null,
      null,
      null,
      W
    ), P._vnode = E, Ht || (Ht = !0, w8(), sE(), Ht = !1);
  }, Gt = {
    p: m,
    um: Ve,
    m: Ie,
    r: O,
    mt: ie,
    mc: B,
    pc: be,
    pbc: R,
    n: Tt,
    o: n
  };
  return {
    render: sn,
    hydrate: void 0,
    createApp: JJ(sn)
  };
}
function P2({ type: n, props: e }, t) {
  return t === "svg" && n === "foreignObject" || t === "mathml" && n === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t;
}
function _l({ effect: n, job: e }, t) {
  t ? (n.flags |= 32, e.flags |= 4) : (n.flags &= -33, e.flags &= -5);
}
function lX(n, e) {
  return (!n || n && !n.pendingBranch) && e && !e.persisted;
}
function CE(n, e, t = !1) {
  const r = n.children, i = e.children;
  if (Ze(r) && Ze(i))
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      let l = i[s];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = i[s] = Vo(i[s]), l.el = o.el), !t && l.patchFlag !== -2 && CE(o, l)), l.type === Cd && (l.el = o.el), l.type === Da && !l.el && (l.el = o.el);
    }
}
function aX(n) {
  const e = n.slice(), t = [0];
  let r, i, s, o, l;
  const a = n.length;
  for (r = 0; r < a; r++) {
    const c = n[r];
    if (c !== 0) {
      if (i = t[t.length - 1], n[i] < c) {
        e[r] = i, t.push(r);
        continue;
      }
      for (s = 0, o = t.length - 1; s < o; )
        l = s + o >> 1, n[t[l]] < c ? s = l + 1 : o = l;
      c < n[t[s]] && (s > 0 && (e[r] = t[s - 1]), t[s] = r);
    }
  }
  for (s = t.length, o = t[s - 1]; s-- > 0; )
    t[s] = o, o = e[o];
  return t;
}
function ME(n) {
  const e = n.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : ME(e);
}
function T8(n) {
  if (n)
    for (let e = 0; e < n.length; e++)
      n[e].flags |= 8;
}
const cX = Symbol.for("v-scx"), uX = () => wp(cX);
function cu(n, e) {
  return pv(n, null, e);
}
function Mc(n, e, t) {
  return pv(n, e, t);
}
function pv(n, e, t = Bt) {
  const { immediate: r, deep: i, flush: s, once: o } = t, l = Xn({}, t), a = e && r || !e && s !== "post";
  let c;
  if (Yf) {
    if (s === "sync") {
      const d = uX();
      c = d.__watcherHandles || (d.__watcherHandles = []);
    } else if (!a) {
      const d = () => {
      };
      return d.stop = Pi, d.resume = Pi, d.pause = Pi, d;
    }
  }
  const u = ar;
  l.call = (d, p, m) => Cs(d, u, p, m);
  let h = !1;
  s === "post" ? l.scheduler = (d) => {
    qr(d, u && u.suspense);
  } : s !== "sync" && (h = !0, l.scheduler = (d, p) => {
    p ? d() : cv(d);
  }), l.augmentJob = (d) => {
    e && (d.flags |= 4), h && (d.flags |= 2, u && (d.id = u.uid, d.i = u));
  };
  const f = yJ(n, e, l);
  return Yf && (c ? c.push(f) : a && f()), f;
}
function hX(n, e, t) {
  const r = this.proxy, i = An(n) ? n.includes(".") ? TE(r, n) : () => r[n] : n.bind(r, r);
  let s;
  tt(e) ? s = e : (s = e.handler, t = e);
  const o = Md(this), l = pv(i, s.bind(r), t);
  return o(), l;
}
function TE(n, e) {
  const t = e.split(".");
  return () => {
    let r = n;
    for (let i = 0; i < t.length && r; i++)
      r = r[t[i]];
    return r;
  };
}
const fX = (n, e) => e === "modelValue" || e === "model-value" ? n.modelModifiers : n[`${e}Modifiers`] || n[`${gl(e)}Modifiers`] || n[`${Fa(e)}Modifiers`];
function dX(n, e, ...t) {
  if (n.isUnmounted) return;
  const r = n.vnode.props || Bt;
  let i = t;
  const s = e.startsWith("update:"), o = s && fX(r, e.slice(7));
  o && (o.trim && (i = t.map((u) => An(u) ? u.trim() : u)), o.number && (i = t.map(LY))), __VUE_PROD_DEVTOOLS__ && AJ(n, e, i);
  let l, a = r[l = O2(e)] || // also try camelCase event handler (#2249)
  r[l = O2(gl(e))];
  !a && s && (a = r[l = O2(Fa(e))]), a && Cs(
    a,
    n,
    6,
    i
  );
  const c = r[l + "Once"];
  if (c) {
    if (!n.emitted)
      n.emitted = {};
    else if (n.emitted[l])
      return;
    n.emitted[l] = !0, Cs(
      c,
      n,
      6,
      i
    );
  }
}
function AE(n, e, t = !1) {
  const r = e.emitsCache, i = r.get(n);
  if (i !== void 0)
    return i;
  const s = n.emits;
  let o = {}, l = !1;
  if (__VUE_OPTIONS_API__ && !tt(n)) {
    const a = (c) => {
      const u = AE(c, e, !0);
      u && (l = !0, Xn(o, u));
    };
    !t && e.mixins.length && e.mixins.forEach(a), n.extends && a(n.extends), n.mixins && n.mixins.forEach(a);
  }
  return !s && !l ? (un(n) && r.set(n, null), null) : (Ze(s) ? s.forEach((a) => o[a] = null) : Xn(o, s), un(n) && r.set(n, o), o);
}
function K1(n, e) {
  return !n || !$1(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), vt(n, e[0].toLowerCase() + e.slice(1)) || vt(n, Fa(e)) || vt(n, e));
}
function A8(n) {
  const {
    type: e,
    vnode: t,
    proxy: r,
    withProxy: i,
    propsOptions: [s],
    slots: o,
    attrs: l,
    emit: a,
    render: c,
    renderCache: u,
    props: h,
    data: f,
    setupState: d,
    ctx: p,
    inheritAttrs: m
  } = n, g = Im(n);
  let b, w;
  try {
    if (t.shapeFlag & 4) {
      const C = i || r, M = C;
      b = is(
        c.call(
          M,
          C,
          u,
          h,
          d,
          f,
          p
        )
      ), w = l;
    } else {
      const C = e;
      b = is(
        C.length > 1 ? C(
          h,
          { attrs: l, slots: o, emit: a }
        ) : C(
          h,
          null
        )
      ), w = e.props ? l : pX(l);
    }
  } catch (C) {
    W1(C, n, 1), b = Di(Da);
  }
  let k = b;
  if (w && m !== !1) {
    const C = Object.keys(w), { shapeFlag: M } = k;
    C.length && M & 7 && (s && C.some(Yb) && (w = mX(
      w,
      s
    )), k = qc(k, w, !1, !0));
  }
  return t.dirs && (k = qc(k, null, !1, !0), k.dirs = k.dirs ? k.dirs.concat(t.dirs) : t.dirs), t.transition && hv(k, t.transition), b = k, Im(g), b;
}
const pX = (n) => {
  let e;
  for (const t in n)
    (t === "class" || t === "style" || $1(t)) && ((e || (e = {}))[t] = n[t]);
  return e;
}, mX = (n, e) => {
  const t = {};
  for (const r in n)
    (!Yb(r) || !(r.slice(9) in e)) && (t[r] = n[r]);
  return t;
};
function gX(n, e, t) {
  const { props: r, children: i, component: s } = n, { props: o, children: l, patchFlag: a } = e, c = s.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (t && a >= 0) {
    if (a & 1024)
      return !0;
    if (a & 16)
      return r ? O8(r, o, c) : !!o;
    if (a & 8) {
      const u = e.dynamicProps;
      for (let h = 0; h < u.length; h++) {
        const f = u[h];
        if (o[f] !== r[f] && !K1(c, f))
          return !0;
      }
    }
  } else
    return (i || l) && (!l || !l.$stable) ? !0 : r === o ? !1 : r ? o ? O8(r, o, c) : !0 : !!o;
  return !1;
}
function O8(n, e, t) {
  const r = Object.keys(e);
  if (r.length !== Object.keys(n).length)
    return !0;
  for (let i = 0; i < r.length; i++) {
    const s = r[i];
    if (e[s] !== n[s] && !K1(t, s))
      return !0;
  }
  return !1;
}
function yX({ vnode: n, parent: e }, t) {
  for (; e; ) {
    const r = e.subTree;
    if (r.suspense && r.suspense.activeBranch === n && (r.el = n.el), r === n)
      (n = e.vnode).el = t, e = e.parent;
    else
      break;
  }
}
const OE = (n) => n.__isSuspense;
function bX(n, e) {
  e && e.pendingBranch ? Ze(n) ? e.effects.push(...n) : e.effects.push(n) : xJ(n);
}
const Ln = Symbol.for("v-fgt"), Cd = Symbol.for("v-txt"), Da = Symbol.for("v-cmt"), xp = Symbol.for("v-stc");
let el = null, mv = 1;
function E8(n, e = !1) {
  mv += n, n < 0 && el && e && (el.hasOnce = !0);
}
function Nm(n) {
  return n ? n.__v_isVNode === !0 : !1;
}
function $u(n, e) {
  return n.type === e.type && n.key === e.key;
}
const EE = ({ key: n }) => n ?? null, kp = ({
  ref: n,
  ref_key: e,
  ref_for: t
}) => (typeof n == "number" && (n = "" + n), n != null ? An(n) || Jn(n) || tt(n) ? { i: ds, r: n, k: e, f: !!t } : n : null);
function vX(n, e = null, t = null, r = 0, i = null, s = n === Ln ? 0 : 1, o = !1, l = !1) {
  const a = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n,
    props: e,
    key: e && EE(e),
    ref: e && kp(e),
    scopeId: cE,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: r,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: ds
  };
  return l ? (gv(a, t), s & 128 && n.normalize(a)) : t && (a.shapeFlag |= An(t) ? 8 : 16), mv > 0 && // avoid a block node from tracking itself
  !o && // has current parent block
  el && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (a.patchFlag > 0 || s & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  a.patchFlag !== 32 && el.push(a), a;
}
const Di = wX;
function wX(n, e = null, t = null, r = 0, i = null, s = !1) {
  if ((!n || n === VJ) && (n = Da), Nm(n)) {
    const l = qc(
      n,
      e,
      !0
      /* mergeRef: true */
    );
    return t && gv(l, t), mv > 0 && !s && el && (l.shapeFlag & 6 ? el[el.indexOf(n)] = l : el.push(l)), l.patchFlag = -2, l;
  }
  if (NX(n) && (n = n.__vccOpts), e) {
    e = xX(e);
    let { class: l, style: a } = e;
    l && !An(l) && (e.class = Qb(l)), un(a) && (av(a) && !Ze(a) && (a = Xn({}, a)), e.style = Zb(a));
  }
  const o = An(n) ? 1 : OE(n) ? 128 : IJ(n) ? 64 : un(n) ? 4 : tt(n) ? 2 : 0;
  return vX(
    n,
    e,
    t,
    r,
    i,
    o,
    s,
    !0
  );
}
function xX(n) {
  return n ? av(n) || bE(n) ? Xn({}, n) : n : null;
}
function qc(n, e, t = !1, r = !1) {
  const { props: i, ref: s, patchFlag: o, children: l, transition: a } = n, c = e ? SX(i || {}, e) : i, u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n.type,
    props: c,
    key: c && EE(c),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && s ? Ze(s) ? s.concat(kp(e)) : [s, kp(e)] : kp(e)
    ) : s,
    scopeId: n.scopeId,
    slotScopeIds: n.slotScopeIds,
    children: l,
    target: n.target,
    targetStart: n.targetStart,
    targetAnchor: n.targetAnchor,
    staticCount: n.staticCount,
    shapeFlag: n.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && n.type !== Ln ? o === -1 ? 16 : o | 16 : o,
    dynamicProps: n.dynamicProps,
    dynamicChildren: n.dynamicChildren,
    appContext: n.appContext,
    dirs: n.dirs,
    transition: a,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: n.component,
    suspense: n.suspense,
    ssContent: n.ssContent && qc(n.ssContent),
    ssFallback: n.ssFallback && qc(n.ssFallback),
    placeholder: n.placeholder,
    el: n.el,
    anchor: n.anchor,
    ctx: n.ctx,
    ce: n.ce
  };
  return a && r && hv(
    u,
    a.clone(u)
  ), u;
}
function kX(n = " ", e = 0) {
  return Di(Cd, null, n, e);
}
function is(n) {
  return n == null || typeof n == "boolean" ? Di(Da) : Ze(n) ? Di(
    Ln,
    null,
    // #3666, avoid reference pollution when reusing vnode
    n.slice()
  ) : Nm(n) ? Vo(n) : Di(Cd, null, String(n));
}
function Vo(n) {
  return n.el === null && n.patchFlag !== -1 || n.memo ? n : qc(n);
}
function gv(n, e) {
  let t = 0;
  const { shapeFlag: r } = n;
  if (e == null)
    e = null;
  else if (Ze(e))
    t = 16;
  else if (typeof e == "object")
    if (r & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), gv(n, i()), i._c && (i._d = !0));
      return;
    } else {
      t = 32;
      const i = e._;
      !i && !bE(e) ? e._ctx = ds : i === 3 && ds && (ds.slots._ === 1 ? e._ = 1 : (e._ = 2, n.patchFlag |= 1024));
    }
  else tt(e) ? (e = { default: e, _ctx: ds }, t = 32) : (e = String(e), r & 64 ? (t = 16, e = [kX(e)]) : t = 8);
  n.children = e, n.shapeFlag |= t;
}
function SX(...n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = n[t];
    for (const i in r)
      if (i === "class")
        e.class !== r.class && (e.class = Qb([e.class, r.class]));
      else if (i === "style")
        e.style = Zb([e.style, r.style]);
      else if ($1(i)) {
        const s = e[i], o = r[i];
        o && s !== o && !(Ze(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o);
      } else i !== "" && (e[i] = r[i]);
  }
  return e;
}
function Xi(n, e, t, r = null) {
  Cs(n, e, 7, [
    t,
    r
  ]);
}
const CX = mE();
let MX = 0;
function TX(n, e, t) {
  const r = n.type, i = (e ? e.appContext : n.appContext) || CX, s = {
    uid: MX++,
    vnode: n,
    type: r,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new qY(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: wE(r, i),
    emitsOptions: AE(r, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Bt,
    // inheritAttrs
    inheritAttrs: r.inheritAttrs,
    // state
    ctx: Bt,
    data: Bt,
    props: Bt,
    attrs: Bt,
    slots: Bt,
    refs: Bt,
    setupState: Bt,
    setupContext: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return s.ctx = { _: s }, s.root = e ? e.root : s, s.emit = dX.bind(null, s), n.ce && n.ce(s), s;
}
let ar = null;
const AX = () => ar || ds;
let Rm, a5;
{
  const n = da(), e = (t, r) => {
    let i;
    return (i = n[t]) || (i = n[t] = []), i.push(r), (s) => {
      i.length > 1 ? i.forEach((o) => o(s)) : i[0](s);
    };
  };
  Rm = e(
    "__VUE_INSTANCE_SETTERS__",
    (t) => ar = t
  ), a5 = e(
    "__VUE_SSR_SETTERS__",
    (t) => Yf = t
  );
}
const Md = (n) => {
  const e = ar;
  return Rm(n), n.scope.on(), () => {
    n.scope.off(), Rm(e);
  };
}, I8 = () => {
  ar && ar.scope.off(), Rm(null);
};
function IE(n) {
  return n.vnode.shapeFlag & 4;
}
let Yf = !1;
function OX(n, e = !1, t = !1) {
  e && a5(e);
  const { props: r, children: i } = n.vnode, s = IE(n);
  ZJ(n, r, s, e), nX(n, i, t || e);
  const o = s ? EX(n, e) : void 0;
  return e && a5(!1), o;
}
function EX(n, e) {
  const t = n.type;
  n.accessCache = /* @__PURE__ */ Object.create(null), n.proxy = new Proxy(n.ctx, qJ);
  const { setup: r } = t;
  if (r) {
    ho();
    const i = n.setupContext = r.length > 1 ? DX(n) : null, s = Md(n), o = xd(
      r,
      n,
      0,
      [
        n.props,
        i
      ]
    ), l = BO(o);
    if (fo(), s(), (l || n.sp) && !uf(n) && uE(n), l) {
      if (o.then(I8, I8), e)
        return o.then((a) => {
          D8(n, a);
        }).catch((a) => {
          W1(a, n, 0);
        });
      n.asyncDep = o;
    } else
      D8(n, o);
  } else
    DE(n);
}
function D8(n, e, t) {
  tt(e) ? n.type.__ssrInlineRender ? n.ssrRender = e : n.render = e : un(e) && (__VUE_PROD_DEVTOOLS__ && (n.devtoolsRawSetupState = e), n.setupState = nE(e)), DE(n);
}
function DE(n, e, t) {
  const r = n.type;
  if (n.render || (n.render = r.render || Pi), __VUE_OPTIONS_API__) {
    const i = Md(n);
    ho();
    try {
      WJ(n);
    } finally {
      fo(), i();
    }
  }
}
const IX = {
  get(n, e) {
    return jn(n, "get", ""), n[e];
  }
};
function DX(n) {
  const e = (t) => {
    n.exposed = t || {};
  };
  return {
    attrs: new Proxy(n.attrs, IX),
    slots: n.slots,
    emit: n.emit,
    expose: e
  };
}
function yv(n) {
  return n.exposed ? n.exposeProxy || (n.exposeProxy = new Proxy(nE(uJ(n.exposed)), {
    get(e, t) {
      if (t in e)
        return e[t];
      if (t in hf)
        return hf[t](n);
    },
    has(e, t) {
      return t in e || t in hf;
    }
  })) : n.proxy;
}
function NX(n) {
  return tt(n) && "__vccOpts" in n;
}
const Na = (n, e) => mJ(n, e, Yf);
function j(n, e, t) {
  const r = arguments.length;
  return r === 2 ? un(e) && !Ze(e) ? Nm(e) ? Di(n, null, [e]) : Di(n, e) : Di(n, null, e) : (r > 3 ? t = Array.prototype.slice.call(arguments, 2) : r === 3 && Nm(t) && (t = [t]), Di(n, e, t));
}
const N8 = "3.5.18";
/**
* @vue/runtime-dom v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let c5;
const R8 = typeof window < "u" && window.trustedTypes;
if (R8)
  try {
    c5 = /* @__PURE__ */ R8.createPolicy("vue", {
      createHTML: (n) => n
    });
  } catch {
  }
const NE = c5 ? (n) => c5.createHTML(n) : (n) => n, RX = "http://www.w3.org/2000/svg", PX = "http://www.w3.org/1998/Math/MathML", Us = typeof document < "u" ? document : null, P8 = Us && /* @__PURE__ */ Us.createElement("template"), _X = {
  insert: (n, e, t) => {
    e.insertBefore(n, t || null);
  },
  remove: (n) => {
    const e = n.parentNode;
    e && e.removeChild(n);
  },
  createElement: (n, e, t, r) => {
    const i = e === "svg" ? Us.createElementNS(RX, n) : e === "mathml" ? Us.createElementNS(PX, n) : t ? Us.createElement(n, { is: t }) : Us.createElement(n);
    return n === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple), i;
  },
  createText: (n) => Us.createTextNode(n),
  createComment: (n) => Us.createComment(n),
  setText: (n, e) => {
    n.nodeValue = e;
  },
  setElementText: (n, e) => {
    n.textContent = e;
  },
  parentNode: (n) => n.parentNode,
  nextSibling: (n) => n.nextSibling,
  querySelector: (n) => Us.querySelector(n),
  setScopeId(n, e) {
    n.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(n, e, t, r, i, s) {
    const o = t ? t.previousSibling : e.lastChild;
    if (i && (i === s || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), t), !(i === s || !(i = i.nextSibling)); )
        ;
    else {
      P8.innerHTML = NE(
        r === "svg" ? `<svg>${n}</svg>` : r === "mathml" ? `<math>${n}</math>` : n
      );
      const l = P8.content;
      if (r === "svg" || r === "mathml") {
        const a = l.firstChild;
        for (; a.firstChild; )
          l.appendChild(a.firstChild);
        l.removeChild(a);
      }
      e.insertBefore(l, t);
    }
    return [
      // first
      o ? o.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
}, LX = Symbol("_vtc");
function BX(n, e, t) {
  const r = n[LX];
  r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? n.removeAttribute("class") : t ? n.setAttribute("class", e) : n.className = e;
}
const _8 = Symbol("_vod"), zX = Symbol("_vsh"), FX = Symbol(""), HX = /(^|;)\s*display\s*:/;
function $X(n, e, t) {
  const r = n.style, i = An(t);
  let s = !1;
  if (t && !i) {
    if (e)
      if (An(e))
        for (const o of e.split(";")) {
          const l = o.slice(0, o.indexOf(":")).trim();
          t[l] == null && Sp(r, l, "");
        }
      else
        for (const o in e)
          t[o] == null && Sp(r, o, "");
    for (const o in t)
      o === "display" && (s = !0), Sp(r, o, t[o]);
  } else if (i) {
    if (e !== t) {
      const o = r[FX];
      o && (t += ";" + o), r.cssText = t, s = HX.test(t);
    }
  } else e && n.removeAttribute("style");
  _8 in n && (n[_8] = s ? r.display : "", n[zX] && (r.display = "none"));
}
const L8 = /\s*!important$/;
function Sp(n, e, t) {
  if (Ze(t))
    t.forEach((r) => Sp(n, e, r));
  else if (t == null && (t = ""), e.startsWith("--"))
    n.setProperty(e, t);
  else {
    const r = VX(n, e);
    L8.test(t) ? n.setProperty(
      Fa(r),
      t.replace(L8, ""),
      "important"
    ) : n[r] = t;
  }
}
const B8 = ["Webkit", "Moz", "ms"], _2 = {};
function VX(n, e) {
  const t = _2[e];
  if (t)
    return t;
  let r = gl(e);
  if (r !== "filter" && r in n)
    return _2[e] = r;
  r = zO(r);
  for (let i = 0; i < B8.length; i++) {
    const s = B8[i] + r;
    if (s in n)
      return _2[e] = s;
  }
  return e;
}
const z8 = "http://www.w3.org/1999/xlink";
function F8(n, e, t, r, i, s = VY(e)) {
  r && e.startsWith("xlink:") ? t == null ? n.removeAttributeNS(z8, e.slice(6, e.length)) : n.setAttributeNS(z8, e, t) : t == null || s && !FO(t) ? n.removeAttribute(e) : n.setAttribute(
    e,
    s ? "" : au(t) ? String(t) : t
  );
}
function H8(n, e, t, r, i) {
  if (e === "innerHTML" || e === "textContent") {
    t != null && (n[e] = e === "innerHTML" ? NE(t) : t);
    return;
  }
  const s = n.tagName;
  if (e === "value" && s !== "PROGRESS" && // custom elements may use _value internally
  !s.includes("-")) {
    const l = s === "OPTION" ? n.getAttribute("value") || "" : n.value, a = t == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      n.type === "checkbox" ? "on" : ""
    ) : String(t);
    (l !== a || !("_value" in n)) && (n.value = a), t == null && n.removeAttribute(e), n._value = t;
    return;
  }
  let o = !1;
  if (t === "" || t == null) {
    const l = typeof n[e];
    l === "boolean" ? t = FO(t) : t == null && l === "string" ? (t = "", o = !0) : l === "number" && (t = 0, o = !0);
  }
  try {
    n[e] = t;
  } catch {
  }
  o && n.removeAttribute(i || e);
}
function qX(n, e, t, r) {
  n.addEventListener(e, t, r);
}
function WX(n, e, t, r) {
  n.removeEventListener(e, t, r);
}
const $8 = Symbol("_vei");
function jX(n, e, t, r, i = null) {
  const s = n[$8] || (n[$8] = {}), o = s[e];
  if (r && o)
    o.value = r;
  else {
    const [l, a] = UX(e);
    if (r) {
      const c = s[e] = YX(
        r,
        i
      );
      qX(n, l, c, a);
    } else o && (WX(n, l, o, a), s[e] = void 0);
  }
}
const V8 = /(?:Once|Passive|Capture)$/;
function UX(n) {
  let e;
  if (V8.test(n)) {
    e = {};
    let r;
    for (; r = n.match(V8); )
      n = n.slice(0, n.length - r[0].length), e[r[0].toLowerCase()] = !0;
  }
  return [n[2] === ":" ? n.slice(3) : Fa(n.slice(2)), e];
}
let L2 = 0;
const KX = /* @__PURE__ */ Promise.resolve(), GX = () => L2 || (KX.then(() => L2 = 0), L2 = Date.now());
function YX(n, e) {
  const t = (r) => {
    if (!r._vts)
      r._vts = Date.now();
    else if (r._vts <= t.attached)
      return;
    Cs(
      JX(r, t.value),
      e,
      5,
      [r]
    );
  };
  return t.value = n, t.attached = GX(), t;
}
function JX(n, e) {
  if (Ze(e)) {
    const t = n.stopImmediatePropagation;
    return n.stopImmediatePropagation = () => {
      t.call(n), n._stopped = !0;
    }, e.map(
      (r) => (i) => !i._stopped && r && r(i)
    );
  } else
    return e;
}
const q8 = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // lowercase letter
n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123, XX = (n, e, t, r, i, s) => {
  const o = i === "svg";
  e === "class" ? BX(n, r, o) : e === "style" ? $X(n, t, r) : $1(e) ? Yb(e) || jX(n, e, t, r, s) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : ZX(n, e, r, o)) ? (H8(n, e, r), !n.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && F8(n, e, r, o, s, e !== "value")) : /* #11081 force set props for possible async custom element */ n._isVueCE && (/[A-Z]/.test(e) || !An(r)) ? H8(n, gl(e), r, s, e) : (e === "true-value" ? n._trueValue = r : e === "false-value" && (n._falseValue = r), F8(n, e, r, o));
};
function ZX(n, e, t, r) {
  if (r)
    return !!(e === "innerHTML" || e === "textContent" || e in n && q8(e) && tt(t));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "form" || e === "list" && n.tagName === "INPUT" || e === "type" && n.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = n.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return q8(e) && An(t) ? !1 : e in n;
}
const QX = /* @__PURE__ */ Xn({ patchProp: XX }, _X);
let W8;
function eZ() {
  return W8 || (W8 = sX(QX));
}
const ji = (...n) => {
  const e = eZ().createApp(...n), { mount: t } = e;
  return e.mount = (r) => {
    const i = nZ(r);
    if (!i) return;
    const s = e._component;
    !tt(s) && !s.render && !s.template && (s.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
    const o = t(i, !1, tZ(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o;
  }, e;
};
function tZ(n) {
  if (n instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && n instanceof MathMLElement)
    return "mathml";
}
function nZ(n) {
  return An(n) ? document.querySelector(n) : n;
}
function rZ(n) {
  const e = Mt(
    {},
    `${n}_SLASH_SPEC`
  ), t = kn((i) => {
    const s = i.get(e.key);
    return new Ut({
      key: new en(`${n}_SLASH`),
      ...s
    });
  }), r = [e, t];
  return r.key = e.key, r.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Ctx<slashSpec>|${n}`
  }, t.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Prose<slash>|${n}`
  }, r;
}
class iZ {
  constructor(e) {
    this.#t = !1, this.onShow = () => {
    }, this.onHide = () => {
    }, this.#c = (t, r) => {
      const { state: i, composing: s } = t, { selection: o, doc: l } = i, { ranges: a } = o, c = Math.min(...a.map((d) => d.$from.pos)), u = Math.max(...a.map((d) => d.$to.pos)), h = r && r.doc.eq(l) && r.selection.eq(o);
      if (this.#t || ((this.#n ?? t.dom.parentElement ?? document.body).appendChild(this.element), this.#t = !0), s || h) return;
      if (!this.#s(t, r)) {
        this.hide();
        return;
      }
      $i({
        getBoundingClientRect: () => c1(t, c, u)
      }, this.element, {
        placement: "bottom-start",
        middleware: [Mm(), ml(this.#l), ...this.#e],
        ...this.#r
      }).then(({ x: d, y: p }) => {
        Object.assign(this.element.style, {
          left: `${d}px`,
          top: `${p}px`
        });
      }).catch(console.error), this.show();
    }, this.update = (t, r) => {
      this.#o(t, r);
    }, this.getContent = (t, r = (i) => i.type.name === "paragraph") => {
      const { selection: i } = t.state, { empty: s, $from: o } = i, l = t.state.selection instanceof Ee;
      if (typeof document > "u") return;
      const a = this.element.contains(document.activeElement), c = !t.hasFocus() && !a, u = !t.editable, f = !Qz(r)(t.state.selection);
      if (!(c || u || !s || !l || f))
        return o.parent.textBetween(
          Math.max(0, o.parentOffset - 500),
          o.parentOffset,
          void 0,
          "￼"
        );
    }, this.destroy = () => {
      this.#o.cancel();
    }, this.show = () => {
      this.element.dataset.show = "true", this.onShow();
    }, this.hide = () => {
      this.element.dataset.show = "false", this.onHide();
    }, this.element = e.content, this.#a = e.debounce ?? 200, this.#s = e.shouldShow ?? this.#u, this.#i = e.trigger ?? "/", this.#l = e.offset, this.#e = e.middleware ?? [], this.#r = e.floatingUIOptions ?? {}, this.#n = e.root, this.#o = g1(this.#c, this.#a);
  }
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  /// @internal
  #n;
  /// @internal
  #a;
  /// @internal
  #i;
  /// @internal
  #s;
  /// @internal
  #o;
  /// The offset to get the block. Default is 0.
  #l;
  #c;
  /// @internal
  #u(e) {
    const t = this.getContent(e);
    if (!t) return !1;
    const r = t.at(-1);
    return r ? Array.isArray(this.#i) ? this.#i.includes(r) : this.#i === r : !1;
  }
}
function RE(n) {
  var e, t, r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var i = n.length;
    for (e = 0; e < i; e++) n[e] && (t = RE(n[e])) && (r && (r += " "), r += t);
  } else for (t in n) n[t] && (r && (r += " "), r += t);
  return r;
}
function Hn() {
  for (var n, e, t = 0, r = "", i = arguments.length; t < i; t++) (n = arguments[t]) && (e = RE(n)) && (r && (r += " "), r += e);
  return r;
}
/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
const {
  entries: PE,
  setPrototypeOf: j8,
  isFrozen: sZ,
  getPrototypeOf: oZ,
  getOwnPropertyDescriptor: lZ
} = Object;
let {
  freeze: yr,
  seal: wi,
  create: _E
} = Object, {
  apply: u5,
  construct: h5
} = typeof Reflect < "u" && Reflect;
yr || (yr = function(e) {
  return e;
});
wi || (wi = function(e) {
  return e;
});
u5 || (u5 = function(e, t, r) {
  return e.apply(t, r);
});
h5 || (h5 = function(e, t) {
  return new e(...t);
});
const y0 = br(Array.prototype.forEach), aZ = br(Array.prototype.lastIndexOf), U8 = br(Array.prototype.pop), Vu = br(Array.prototype.push), cZ = br(Array.prototype.splice), Cp = br(String.prototype.toLowerCase), B2 = br(String.prototype.toString), K8 = br(String.prototype.match), qu = br(String.prototype.replace), uZ = br(String.prototype.indexOf), hZ = br(String.prototype.trim), Oi = br(Object.prototype.hasOwnProperty), tr = br(RegExp.prototype.test), Wu = fZ(TypeError);
function br(n) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      r[i - 1] = arguments[i];
    return u5(n, e, r);
  };
}
function fZ(n) {
  return function() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return h5(n, t);
  };
}
function ot(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Cp;
  j8 && j8(n, null);
  let r = e.length;
  for (; r--; ) {
    let i = e[r];
    if (typeof i == "string") {
      const s = t(i);
      s !== i && (sZ(e) || (e[r] = s), i = s);
    }
    n[i] = !0;
  }
  return n;
}
function dZ(n) {
  for (let e = 0; e < n.length; e++)
    Oi(n, e) || (n[e] = null);
  return n;
}
function Vs(n) {
  const e = _E(null);
  for (const [t, r] of PE(n))
    Oi(n, t) && (Array.isArray(r) ? e[t] = dZ(r) : r && typeof r == "object" && r.constructor === Object ? e[t] = Vs(r) : e[t] = r);
  return e;
}
function ju(n, e) {
  for (; n !== null; ) {
    const r = lZ(n, e);
    if (r) {
      if (r.get)
        return br(r.get);
      if (typeof r.value == "function")
        return br(r.value);
    }
    n = oZ(n);
  }
  function t() {
    return null;
  }
  return t;
}
const G8 = yr(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), z2 = yr(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), F2 = yr(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), pZ = yr(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), H2 = yr(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), mZ = yr(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Y8 = yr(["#text"]), J8 = yr(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), $2 = yr(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), X8 = yr(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), b0 = yr(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), gZ = wi(/\{\{[\w\W]*|[\w\W]*\}\}/gm), yZ = wi(/<%[\w\W]*|[\w\W]*%>/gm), bZ = wi(/\$\{[\w\W]*/gm), vZ = wi(/^data-[\-\w.\u00B7-\uFFFF]+$/), wZ = wi(/^aria-[\-\w]+$/), LE = wi(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), xZ = wi(/^(?:\w+script|data):/i), kZ = wi(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), BE = wi(/^html$/i), SZ = wi(/^[a-z][.\w]*(-[.\w]+)+$/i);
var Z8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: wZ,
  ATTR_WHITESPACE: kZ,
  CUSTOM_ELEMENT: SZ,
  DATA_ATTR: vZ,
  DOCTYPE_NAME: BE,
  ERB_EXPR: yZ,
  IS_ALLOWED_URI: LE,
  IS_SCRIPT_OR_DATA: xZ,
  MUSTACHE_EXPR: gZ,
  TMPLIT_EXPR: bZ
});
const Uu = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, CZ = function() {
  return typeof window > "u" ? null : window;
}, MZ = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let r = null;
  const i = "data-tt-policy-suffix";
  t && t.hasAttribute(i) && (r = t.getAttribute(i));
  const s = "dompurify" + (r ? "#" + r : "");
  try {
    return e.createPolicy(s, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
}, Q8 = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function zE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : CZ();
  const e = (Re) => zE(Re);
  if (e.version = "3.2.6", e.removed = [], !n || !n.document || n.document.nodeType !== Uu.document || !n.Element)
    return e.isSupported = !1, e;
  let {
    document: t
  } = n;
  const r = t, i = r.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: o,
    Node: l,
    Element: a,
    NodeFilter: c,
    NamedNodeMap: u = n.NamedNodeMap || n.MozNamedAttrMap,
    HTMLFormElement: h,
    DOMParser: f,
    trustedTypes: d
  } = n, p = a.prototype, m = ju(p, "cloneNode"), g = ju(p, "remove"), b = ju(p, "nextSibling"), w = ju(p, "childNodes"), k = ju(p, "parentNode");
  if (typeof o == "function") {
    const Re = t.createElement("template");
    Re.content && Re.content.ownerDocument && (t = Re.content.ownerDocument);
  }
  let C, M = "";
  const {
    implementation: T,
    createNodeIterator: N,
    createDocumentFragment: B,
    getElementsByTagName: $
  } = t, {
    importNode: R
  } = r;
  let V = Q8();
  e.isSupported = typeof PE == "function" && typeof k == "function" && T && T.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: z,
    ERB_EXPR: ue,
    TMPLIT_EXPR: ie,
    DATA_ATTR: he,
    ARIA_ATTR: Ce,
    IS_SCRIPT_OR_DATA: ye,
    ATTR_WHITESPACE: be,
    CUSTOM_ELEMENT: ze
  } = Z8;
  let {
    IS_ALLOWED_URI: I
  } = Z8, Ie = null;
  const Ve = ot({}, [...G8, ...z2, ...F2, ...H2, ...Y8]);
  let O = null;
  const pt = ot({}, [...J8, ...$2, ...X8, ...b0]);
  let Ue = Object.seal(_E(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), et = null, Tt = null, Ht = !0, sn = !0, Gt = !1, Lr = !0, E = !1, P = !0, W = !1, Q = !1, J = !1, Y = !1, ae = !1, re = !1, oe = !0, te = !1;
  const De = "user-content-";
  let de = !0, Te = !1, Pe = {}, F = null;
  const X = ot({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let pe = null;
  const _e = ot({}, ["audio", "video", "img", "source", "image", "track"]);
  let je = null;
  const kt = ot({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), _t = "http://www.w3.org/1998/Math/MathML", Yt = "http://www.w3.org/2000/svg", on = "http://www.w3.org/1999/xhtml";
  let xt = on, mt = !1, Vn = null;
  const En = ot({}, [_t, Yt, on], B2);
  let Il = ot({}, ["mi", "mo", "mn", "ms", "mtext"]), Dl = ot({}, ["annotation-xml"]);
  const Fd = ot({}, ["title", "style", "font", "a", "script"]);
  let To = null;
  const Hd = ["application/xhtml+xml", "text/html"], $d = "text/html";
  let ln = null, Ps = null;
  const Vd = t.createElement("form"), bu = function(L) {
    return L instanceof RegExp || L instanceof Function;
  }, qa = function() {
    let L = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(Ps && Ps === L)) {
      if ((!L || typeof L != "object") && (L = {}), L = Vs(L), To = // eslint-disable-next-line unicorn/prefer-includes
      Hd.indexOf(L.PARSER_MEDIA_TYPE) === -1 ? $d : L.PARSER_MEDIA_TYPE, ln = To === "application/xhtml+xml" ? B2 : Cp, Ie = Oi(L, "ALLOWED_TAGS") ? ot({}, L.ALLOWED_TAGS, ln) : Ve, O = Oi(L, "ALLOWED_ATTR") ? ot({}, L.ALLOWED_ATTR, ln) : pt, Vn = Oi(L, "ALLOWED_NAMESPACES") ? ot({}, L.ALLOWED_NAMESPACES, B2) : En, je = Oi(L, "ADD_URI_SAFE_ATTR") ? ot(Vs(kt), L.ADD_URI_SAFE_ATTR, ln) : kt, pe = Oi(L, "ADD_DATA_URI_TAGS") ? ot(Vs(_e), L.ADD_DATA_URI_TAGS, ln) : _e, F = Oi(L, "FORBID_CONTENTS") ? ot({}, L.FORBID_CONTENTS, ln) : X, et = Oi(L, "FORBID_TAGS") ? ot({}, L.FORBID_TAGS, ln) : Vs({}), Tt = Oi(L, "FORBID_ATTR") ? ot({}, L.FORBID_ATTR, ln) : Vs({}), Pe = Oi(L, "USE_PROFILES") ? L.USE_PROFILES : !1, Ht = L.ALLOW_ARIA_ATTR !== !1, sn = L.ALLOW_DATA_ATTR !== !1, Gt = L.ALLOW_UNKNOWN_PROTOCOLS || !1, Lr = L.ALLOW_SELF_CLOSE_IN_ATTR !== !1, E = L.SAFE_FOR_TEMPLATES || !1, P = L.SAFE_FOR_XML !== !1, W = L.WHOLE_DOCUMENT || !1, Y = L.RETURN_DOM || !1, ae = L.RETURN_DOM_FRAGMENT || !1, re = L.RETURN_TRUSTED_TYPE || !1, J = L.FORCE_BODY || !1, oe = L.SANITIZE_DOM !== !1, te = L.SANITIZE_NAMED_PROPS || !1, de = L.KEEP_CONTENT !== !1, Te = L.IN_PLACE || !1, I = L.ALLOWED_URI_REGEXP || LE, xt = L.NAMESPACE || on, Il = L.MATHML_TEXT_INTEGRATION_POINTS || Il, Dl = L.HTML_INTEGRATION_POINTS || Dl, Ue = L.CUSTOM_ELEMENT_HANDLING || {}, L.CUSTOM_ELEMENT_HANDLING && bu(L.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ue.tagNameCheck = L.CUSTOM_ELEMENT_HANDLING.tagNameCheck), L.CUSTOM_ELEMENT_HANDLING && bu(L.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ue.attributeNameCheck = L.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), L.CUSTOM_ELEMENT_HANDLING && typeof L.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Ue.allowCustomizedBuiltInElements = L.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), E && (sn = !1), ae && (Y = !0), Pe && (Ie = ot({}, Y8), O = [], Pe.html === !0 && (ot(Ie, G8), ot(O, J8)), Pe.svg === !0 && (ot(Ie, z2), ot(O, $2), ot(O, b0)), Pe.svgFilters === !0 && (ot(Ie, F2), ot(O, $2), ot(O, b0)), Pe.mathMl === !0 && (ot(Ie, H2), ot(O, X8), ot(O, b0))), L.ADD_TAGS && (Ie === Ve && (Ie = Vs(Ie)), ot(Ie, L.ADD_TAGS, ln)), L.ADD_ATTR && (O === pt && (O = Vs(O)), ot(O, L.ADD_ATTR, ln)), L.ADD_URI_SAFE_ATTR && ot(je, L.ADD_URI_SAFE_ATTR, ln), L.FORBID_CONTENTS && (F === X && (F = Vs(F)), ot(F, L.FORBID_CONTENTS, ln)), de && (Ie["#text"] = !0), W && ot(Ie, ["html", "head", "body"]), Ie.table && (ot(Ie, ["tbody"]), delete et.tbody), L.TRUSTED_TYPES_POLICY) {
        if (typeof L.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Wu('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof L.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Wu('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        C = L.TRUSTED_TYPES_POLICY, M = C.createHTML("");
      } else
        C === void 0 && (C = MZ(d, i)), C !== null && typeof M == "string" && (M = C.createHTML(""));
      yr && yr(L), Ps = L;
    }
  }, vu = ot({}, [...z2, ...F2, ...pZ]), wu = ot({}, [...H2, ...mZ]), qd = function(L) {
    let le = k(L);
    (!le || !le.tagName) && (le = {
      namespaceURI: xt,
      tagName: "template"
    });
    const Oe = Cp(L.tagName), At = Cp(le.tagName);
    return Vn[L.namespaceURI] ? L.namespaceURI === Yt ? le.namespaceURI === on ? Oe === "svg" : le.namespaceURI === _t ? Oe === "svg" && (At === "annotation-xml" || Il[At]) : !!vu[Oe] : L.namespaceURI === _t ? le.namespaceURI === on ? Oe === "math" : le.namespaceURI === Yt ? Oe === "math" && Dl[At] : !!wu[Oe] : L.namespaceURI === on ? le.namespaceURI === Yt && !Dl[At] || le.namespaceURI === _t && !Il[At] ? !1 : !wu[Oe] && (Fd[Oe] || !vu[Oe]) : !!(To === "application/xhtml+xml" && Vn[L.namespaceURI]) : !1;
  }, Br = function(L) {
    Vu(e.removed, {
      element: L
    });
    try {
      k(L).removeChild(L);
    } catch {
      g(L);
    }
  }, _s = function(L, le) {
    try {
      Vu(e.removed, {
        attribute: le.getAttributeNode(L),
        from: le
      });
    } catch {
      Vu(e.removed, {
        attribute: null,
        from: le
      });
    }
    if (le.removeAttribute(L), L === "is")
      if (Y || ae)
        try {
          Br(le);
        } catch {
        }
      else
        try {
          le.setAttribute(L, "");
        } catch {
        }
  }, xu = function(L) {
    let le = null, Oe = null;
    if (J)
      L = "<remove></remove>" + L;
    else {
      const tn = K8(L, /^[\r\n\t ]+/);
      Oe = tn && tn[0];
    }
    To === "application/xhtml+xml" && xt === on && (L = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + L + "</body></html>");
    const At = C ? C.createHTML(L) : L;
    if (xt === on)
      try {
        le = new f().parseFromString(At, To);
      } catch {
      }
    if (!le || !le.documentElement) {
      le = T.createDocument(xt, "template", null);
      try {
        le.documentElement.innerHTML = mt ? M : At;
      } catch {
      }
    }
    const bn = le.body || le.documentElement;
    return L && Oe && bn.insertBefore(t.createTextNode(Oe), bn.childNodes[0] || null), xt === on ? $.call(le, W ? "html" : "body")[0] : W ? le.documentElement : bn;
  }, ku = function(L) {
    return N.call(
      L.ownerDocument || L,
      L,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, Wa = function(L) {
    return L instanceof h && (typeof L.nodeName != "string" || typeof L.textContent != "string" || typeof L.removeChild != "function" || !(L.attributes instanceof u) || typeof L.removeAttribute != "function" || typeof L.setAttribute != "function" || typeof L.namespaceURI != "string" || typeof L.insertBefore != "function" || typeof L.hasChildNodes != "function");
  }, Su = function(L) {
    return typeof l == "function" && L instanceof l;
  };
  function ni(Re, L, le) {
    y0(Re, (Oe) => {
      Oe.call(e, L, le, Ps);
    });
  }
  const Cu = function(L) {
    let le = null;
    if (ni(V.beforeSanitizeElements, L, null), Wa(L))
      return Br(L), !0;
    const Oe = ln(L.nodeName);
    if (ni(V.uponSanitizeElement, L, {
      tagName: Oe,
      allowedTags: Ie
    }), P && L.hasChildNodes() && !Su(L.firstElementChild) && tr(/<[/\w!]/g, L.innerHTML) && tr(/<[/\w!]/g, L.textContent) || L.nodeType === Uu.progressingInstruction || P && L.nodeType === Uu.comment && tr(/<[/\w]/g, L.data))
      return Br(L), !0;
    if (!Ie[Oe] || et[Oe]) {
      if (!et[Oe] && Tu(Oe) && (Ue.tagNameCheck instanceof RegExp && tr(Ue.tagNameCheck, Oe) || Ue.tagNameCheck instanceof Function && Ue.tagNameCheck(Oe)))
        return !1;
      if (de && !F[Oe]) {
        const At = k(L) || L.parentNode, bn = w(L) || L.childNodes;
        if (bn && At) {
          const tn = bn.length;
          for (let In = tn - 1; In >= 0; --In) {
            const ri = m(bn[In], !0);
            ri.__removalCount = (L.__removalCount || 0) + 1, At.insertBefore(ri, b(L));
          }
        }
      }
      return Br(L), !0;
    }
    return L instanceof a && !qd(L) || (Oe === "noscript" || Oe === "noembed" || Oe === "noframes") && tr(/<\/no(script|embed|frames)/i, L.innerHTML) ? (Br(L), !0) : (E && L.nodeType === Uu.text && (le = L.textContent, y0([z, ue, ie], (At) => {
      le = qu(le, At, " ");
    }), L.textContent !== le && (Vu(e.removed, {
      element: L.cloneNode()
    }), L.textContent = le)), ni(V.afterSanitizeElements, L, null), !1);
  }, Mu = function(L, le, Oe) {
    if (oe && (le === "id" || le === "name") && (Oe in t || Oe in Vd))
      return !1;
    if (!(sn && !Tt[le] && tr(he, le))) {
      if (!(Ht && tr(Ce, le))) {
        if (!O[le] || Tt[le]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(Tu(L) && (Ue.tagNameCheck instanceof RegExp && tr(Ue.tagNameCheck, L) || Ue.tagNameCheck instanceof Function && Ue.tagNameCheck(L)) && (Ue.attributeNameCheck instanceof RegExp && tr(Ue.attributeNameCheck, le) || Ue.attributeNameCheck instanceof Function && Ue.attributeNameCheck(le)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            le === "is" && Ue.allowCustomizedBuiltInElements && (Ue.tagNameCheck instanceof RegExp && tr(Ue.tagNameCheck, Oe) || Ue.tagNameCheck instanceof Function && Ue.tagNameCheck(Oe)))
          ) return !1;
        } else if (!je[le]) {
          if (!tr(I, qu(Oe, be, ""))) {
            if (!((le === "src" || le === "xlink:href" || le === "href") && L !== "script" && uZ(Oe, "data:") === 0 && pe[L])) {
              if (!(Gt && !tr(ye, qu(Oe, be, "")))) {
                if (Oe)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Tu = function(L) {
    return L !== "annotation-xml" && K8(L, ze);
  }, Au = function(L) {
    ni(V.beforeSanitizeAttributes, L, null);
    const {
      attributes: le
    } = L;
    if (!le || Wa(L))
      return;
    const Oe = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: O,
      forceKeepAttr: void 0
    };
    let At = le.length;
    for (; At--; ) {
      const bn = le[At], {
        name: tn,
        namespaceURI: In,
        value: ri
      } = bn, Ao = ln(tn), ja = ri;
      let vn = tn === "value" ? ja : hZ(ja);
      if (Oe.attrName = Ao, Oe.attrValue = vn, Oe.keepAttr = !0, Oe.forceKeepAttr = void 0, ni(V.uponSanitizeAttribute, L, Oe), vn = Oe.attrValue, te && (Ao === "id" || Ao === "name") && (_s(tn, L), vn = De + vn), P && tr(/((--!?|])>)|<\/(style|title)/i, vn)) {
        _s(tn, L);
        continue;
      }
      if (Oe.forceKeepAttr)
        continue;
      if (!Oe.keepAttr) {
        _s(tn, L);
        continue;
      }
      if (!Lr && tr(/\/>/i, vn)) {
        _s(tn, L);
        continue;
      }
      E && y0([z, ue, ie], (Eu) => {
        vn = qu(vn, Eu, " ");
      });
      const Ou = ln(L.nodeName);
      if (!Mu(Ou, Ao, vn)) {
        _s(tn, L);
        continue;
      }
      if (C && typeof d == "object" && typeof d.getAttributeType == "function" && !In)
        switch (d.getAttributeType(Ou, Ao)) {
          case "TrustedHTML": {
            vn = C.createHTML(vn);
            break;
          }
          case "TrustedScriptURL": {
            vn = C.createScriptURL(vn);
            break;
          }
        }
      if (vn !== ja)
        try {
          In ? L.setAttributeNS(In, tn, vn) : L.setAttribute(tn, vn), Wa(L) ? Br(L) : U8(e.removed);
        } catch {
          _s(tn, L);
        }
    }
    ni(V.afterSanitizeAttributes, L, null);
  }, Wd = function Re(L) {
    let le = null;
    const Oe = ku(L);
    for (ni(V.beforeSanitizeShadowDOM, L, null); le = Oe.nextNode(); )
      ni(V.uponSanitizeShadowNode, le, null), Cu(le), Au(le), le.content instanceof s && Re(le.content);
    ni(V.afterSanitizeShadowDOM, L, null);
  };
  return e.sanitize = function(Re) {
    let L = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, le = null, Oe = null, At = null, bn = null;
    if (mt = !Re, mt && (Re = "<!-->"), typeof Re != "string" && !Su(Re))
      if (typeof Re.toString == "function") {
        if (Re = Re.toString(), typeof Re != "string")
          throw Wu("dirty is not a string, aborting");
      } else
        throw Wu("toString is not a function");
    if (!e.isSupported)
      return Re;
    if (Q || qa(L), e.removed = [], typeof Re == "string" && (Te = !1), Te) {
      if (Re.nodeName) {
        const ri = ln(Re.nodeName);
        if (!Ie[ri] || et[ri])
          throw Wu("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Re instanceof l)
      le = xu("<!---->"), Oe = le.ownerDocument.importNode(Re, !0), Oe.nodeType === Uu.element && Oe.nodeName === "BODY" || Oe.nodeName === "HTML" ? le = Oe : le.appendChild(Oe);
    else {
      if (!Y && !E && !W && // eslint-disable-next-line unicorn/prefer-includes
      Re.indexOf("<") === -1)
        return C && re ? C.createHTML(Re) : Re;
      if (le = xu(Re), !le)
        return Y ? null : re ? M : "";
    }
    le && J && Br(le.firstChild);
    const tn = ku(Te ? Re : le);
    for (; At = tn.nextNode(); )
      Cu(At), Au(At), At.content instanceof s && Wd(At.content);
    if (Te)
      return Re;
    if (Y) {
      if (ae)
        for (bn = B.call(le.ownerDocument); le.firstChild; )
          bn.appendChild(le.firstChild);
      else
        bn = le;
      return (O.shadowroot || O.shadowrootmode) && (bn = R.call(r, bn, !0)), bn;
    }
    let In = W ? le.outerHTML : le.innerHTML;
    return W && Ie["!doctype"] && le.ownerDocument && le.ownerDocument.doctype && le.ownerDocument.doctype.name && tr(BE, le.ownerDocument.doctype.name) && (In = "<!DOCTYPE " + le.ownerDocument.doctype.name + `>
` + In), E && y0([z, ue, ie], (ri) => {
      In = qu(In, ri, " ");
    }), C && re ? C.createHTML(In) : In;
  }, e.setConfig = function() {
    let Re = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    qa(Re), Q = !0;
  }, e.clearConfig = function() {
    Ps = null, Q = !1;
  }, e.isValidAttribute = function(Re, L, le) {
    Ps || qa({});
    const Oe = ln(Re), At = ln(L);
    return Mu(Oe, At, le);
  }, e.addHook = function(Re, L) {
    typeof L == "function" && Vu(V[Re], L);
  }, e.removeHook = function(Re, L) {
    if (L !== void 0) {
      const le = aZ(V[Re], L);
      return le === -1 ? void 0 : cZ(V[Re], le, 1)[0];
    }
    return U8(V[Re]);
  }, e.removeHooks = function(Re) {
    V[Re] = [];
  }, e.removeAllHooks = function() {
    V = Q8();
  }, e;
}
var Ui = zE();
function Wc({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
Wc.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
let TZ = (n) => crypto.getRandomValues(new Uint8Array(n)), AZ = (n, e, t) => {
  let r = (2 << Math.log2(n.length - 1)) - 1, i = -~(1.6 * r * e / n.length);
  return (s = e) => {
    let o = "";
    for (; ; ) {
      let l = t(i), a = i | 0;
      for (; a--; )
        if (o += n[l[a] & r] || "", o.length >= s) return o;
    }
  };
}, FE = (n, e = 21) => AZ(n, e | 0, TZ);
var OZ = Object.defineProperty, ek = Object.getOwnPropertySymbols, EZ = Object.prototype.hasOwnProperty, IZ = Object.prototype.propertyIsEnumerable, tk = (n, e, t) => e in n ? OZ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, DZ = (n, e) => {
  for (var t in e || (e = {}))
    EZ.call(e, t) && tk(n, t, e[t]);
  if (ek)
    for (var t of ek(e))
      IZ.call(e, t) && tk(n, t, e[t]);
  return n;
};
function Td(n, e) {
  return Object.assign(n, {
    meta: DZ({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const NZ = {
  imageIcon: "🌌",
  captionIcon: "💬",
  uploadButton: "Upload file",
  confirmButton: "Confirm ⏎",
  uploadPlaceholderText: "or paste the image link ...",
  captionPlaceholderText: "Image caption",
  onUpload: (n) => Promise.resolve(URL.createObjectURL(n))
}, G1 = Mt(
  NZ,
  "imageBlockConfigCtx"
);
Td(G1, {
  displayName: "Config<image-block>",
  group: "ImageBlock"
});
function RZ(n) {
  return kl(
    n,
    "paragraph",
    (e, t, r) => {
      var i, s;
      if (((i = e.children) == null ? void 0 : i.length) !== 1) return;
      const o = (s = e.children) == null ? void 0 : s[0];
      if (!o || o.type !== "image") return;
      const { url: l, alt: a, title: c } = o, u = {
        type: "image-block",
        url: l,
        alt: a,
        title: c
      };
      r.children.splice(t, 1, u);
    }
  );
}
const bv = Ts(
  "remark-image-block",
  () => () => RZ
);
Td(bv.plugin, {
  displayName: "Remark<remarkImageBlock>",
  group: "ImageBlock"
});
Td(bv.options, {
  displayName: "RemarkConfig<remarkImageBlock>",
  group: "ImageBlock"
});
var PZ = Object.defineProperty, nk = Object.getOwnPropertySymbols, _Z = Object.prototype.hasOwnProperty, LZ = Object.prototype.propertyIsEnumerable, rk = (n, e, t) => e in n ? PZ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, BZ = (n, e) => {
  for (var t in e || (e = {}))
    _Z.call(e, t) && rk(n, t, e[t]);
  if (nk)
    for (var t of nk(e))
      LZ.call(e, t) && rk(n, t, e[t]);
  return n;
};
const f5 = "image-block", Y1 = hn("image-block", () => ({
  inline: !1,
  group: "block",
  selectable: !0,
  draggable: !0,
  isolating: !0,
  marks: "",
  atom: !0,
  priority: 100,
  attrs: {
    src: { default: "", validate: "string" },
    caption: { default: "", validate: "string" },
    ratio: { default: 1, validate: "number" }
  },
  parseDOM: [
    {
      tag: `img[data-type="${f5}"]`,
      getAttrs: (n) => {
        var e;
        if (!(n instanceof HTMLElement)) throw Vi(n);
        return {
          src: n.getAttribute("src") || "",
          caption: n.getAttribute("caption") || "",
          ratio: Number((e = n.getAttribute("ratio")) != null ? e : 1)
        };
      }
    }
  ],
  toDOM: (n) => ["img", BZ({ "data-type": f5 }, n.attrs)],
  parseMarkdown: {
    match: ({ type: n }) => n === "image-block",
    runner: (n, e, t) => {
      const r = e.url, i = e.title;
      let s = Number(e.alt || 1);
      (Number.isNaN(s) || s === 0) && (s = 1), n.addNode(t, {
        src: r,
        caption: i,
        ratio: s
      });
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "image-block",
    runner: (n, e) => {
      n.openNode("paragraph"), n.addNode("image", void 0, void 0, {
        title: e.attrs.caption,
        url: e.attrs.src,
        alt: `${Number.parseFloat(e.attrs.ratio).toFixed(2)}`
      }), n.closeNode();
    }
  }
}));
Td(Y1.node, {
  displayName: "NodeSchema<image-block>",
  group: "ImageBlock"
});
function ff({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
ff.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const zZ = FE("abcdefg", 8), FZ = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setLink: {
      type: Function,
      required: !0
    },
    imageIcon: {
      type: String,
      required: !1
    },
    uploadButton: {
      type: String,
      required: !1
    },
    confirmButton: {
      type: String,
      required: !1
    },
    uploadPlaceholderText: {
      type: String,
      required: !1
    },
    onUpload: {
      type: Function,
      required: !0
    }
  },
  setup({
    readonly: n,
    src: e,
    setLink: t,
    onUpload: r,
    imageIcon: i,
    uploadButton: s,
    confirmButton: o,
    uploadPlaceholderText: l,
    className: a
  }) {
    var c, u;
    const h = Ae(!1), f = Ae(), d = Ae((c = e.value) != null ? c : ""), p = Ae(zZ()), m = Ae(((u = e.value) == null ? void 0 : u.length) !== 0), g = (C) => {
      const T = C.target.value;
      m.value = T.length !== 0, d.value = T;
    }, b = (C) => {
      var M, T;
      C.key === "Enter" && t((T = (M = f.value) == null ? void 0 : M.value) != null ? T : "");
    }, w = () => {
      var C, M;
      t((M = (C = f.value) == null ? void 0 : C.value) != null ? M : "");
    }, k = (C) => {
      var M;
      const T = (M = C.target.files) == null ? void 0 : M[0];
      T && r(T).then((N) => {
        N && (t(N), m.value = !0);
      }).catch((N) => {
        console.error("An error occurred while uploading image"), console.error(N);
      });
    };
    return () => /* @__PURE__ */ j("div", { class: Hn("image-edit", a) }, /* @__PURE__ */ j(ff, { icon: i, class: "image-icon" }), /* @__PURE__ */ j("div", { class: Hn("link-importer", h.value && "focus") }, /* @__PURE__ */ j(
      "input",
      {
        ref: f,
        draggable: "true",
        onDragstart: (C) => {
          C.preventDefault(), C.stopPropagation();
        },
        disabled: n.value,
        class: "link-input-area",
        value: d.value,
        onInput: g,
        onKeydown: b,
        onFocus: () => h.value = !0,
        onBlur: () => h.value = !1
      }
    ), !m.value && /* @__PURE__ */ j("div", { class: "placeholder" }, /* @__PURE__ */ j(
      "input",
      {
        disabled: n.value,
        class: "hidden",
        id: p.value,
        type: "file",
        accept: "image/*",
        onChange: k
      }
    ), /* @__PURE__ */ j("label", { class: "uploader", for: p.value }, /* @__PURE__ */ j(ff, { icon: s })), /* @__PURE__ */ j("span", { class: "text", onClick: () => {
      var C;
      return (C = f.value) == null ? void 0 : C.focus();
    } }, l))), d.value && /* @__PURE__ */ j("div", { class: "confirm", onClick: () => w() }, /* @__PURE__ */ j(ff, { icon: o })));
  }
}), HZ = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    caption: {
      type: Object,
      required: !0
    },
    ratio: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup({ src: n, caption: e, ratio: t, readonly: r, setAttr: i, config: s }) {
    var o;
    const l = Ae(), a = Ae(), c = Ae(!!((o = e.value) != null && o.length)), u = Ae(0), h = () => {
      var w;
      const k = l.value;
      if (!k) return;
      const C = k.closest(".milkdown-image-block");
      if (!C) return;
      const M = C.getBoundingClientRect().width;
      if (!M) return;
      const T = k.height, N = k.width, B = N < M ? T : M * (T / N), $ = (B * ((w = t.value) != null ? w : 1)).toFixed(2);
      k.dataset.origin = B.toFixed(2), k.dataset.height = $, k.style.height = `${$}px`;
    }, f = (w) => {
      w.preventDefault(), w.stopPropagation(), !r.value && (c.value = !c.value);
    }, d = (w) => {
      const C = w.target.value;
      u.value && window.clearTimeout(u.value), u.value = window.setTimeout(() => {
        i("caption", C);
      }, 1e3);
    }, p = (w) => {
      const C = w.target.value;
      u.value && (window.clearTimeout(u.value), u.value = 0), i("caption", C);
    }, m = (w) => {
      w.preventDefault();
      const k = l.value;
      if (!k) return;
      const C = k.getBoundingClientRect().top, M = w.clientY - C, T = Number(M < 100 ? 100 : M).toFixed(2);
      k.dataset.height = T, k.style.height = `${T}px`;
    }, g = () => {
      window.removeEventListener("pointermove", m), window.removeEventListener("pointerup", g);
      const w = l.value;
      if (!w) return;
      const k = Number(w.dataset.origin), C = Number(w.dataset.height), M = Number.parseFloat(
        Number(C / k).toFixed(2)
      );
      Number.isNaN(M) || i("ratio", M);
    }, b = (w) => {
      r.value || (w.preventDefault(), w.stopPropagation(), window.addEventListener("pointermove", m), window.addEventListener("pointerup", g));
    };
    return () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("div", { class: "image-wrapper" }, /* @__PURE__ */ j("div", { class: "operation" }, /* @__PURE__ */ j("div", { class: "operation-item", onPointerdown: f }, /* @__PURE__ */ j(ff, { icon: s.captionIcon }))), /* @__PURE__ */ j(
      "img",
      {
        ref: l,
        "data-type": f5,
        onLoad: h,
        src: n.value,
        alt: e.value
      }
    ), /* @__PURE__ */ j(
      "div",
      {
        ref: a,
        class: "image-resize-handle",
        onPointerdown: b
      }
    )), c.value && /* @__PURE__ */ j(
      "input",
      {
        draggable: "true",
        onDragstart: (w) => {
          w.preventDefault(), w.stopPropagation();
        },
        class: "caption-input",
        placeholder: s?.captionPlaceholderText,
        onInput: d,
        onBlur: p,
        value: e.value
      }
    ));
  }
});
var $Z = Object.defineProperty, ik = Object.getOwnPropertySymbols, VZ = Object.prototype.hasOwnProperty, qZ = Object.prototype.propertyIsEnumerable, sk = (n, e, t) => e in n ? $Z(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, WZ = (n, e) => {
  for (var t in e || (e = {}))
    VZ.call(e, t) && sk(n, t, e[t]);
  if (ik)
    for (var t of ik(e))
      qZ.call(e, t) && sk(n, t, e[t]);
  return n;
};
const jZ = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    caption: {
      type: Object,
      required: !0
    },
    ratio: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { src: e } = n;
    return () => {
      var t;
      return (t = e.value) != null && t.length ? /* @__PURE__ */ j(HZ, WZ({}, n)) : /* @__PURE__ */ j(
        FZ,
        {
          src: n.src,
          selected: n.selected,
          readonly: n.readonly,
          setLink: (r) => n.setAttr("src", r),
          imageIcon: n.config.imageIcon,
          uploadButton: n.config.uploadButton,
          confirmButton: n.config.confirmButton,
          uploadPlaceholderText: n.config.uploadPlaceholderText,
          onUpload: n.config.onUpload
        }
      );
    };
  }
}), HE = yd(
  Y1.node,
  (n) => (e, t, r) => {
    const i = Ae(e.attrs.src), s = Ae(e.attrs.caption), o = Ae(e.attrs.ratio), l = Ae(!1), a = Ae(!t.editable), c = (g, b) => {
      if (!t.editable) return;
      const w = r();
      w != null && t.dispatch(
        t.state.tr.setNodeAttribute(
          w,
          g,
          g === "src" ? Ui.sanitize(b) : b
        )
      );
    }, u = n.get(G1.key), h = ji(jZ, {
      src: i,
      caption: s,
      ratio: o,
      selected: l,
      readonly: a,
      setAttr: c,
      config: u
    }), f = document.createElement("div");
    f.className = "milkdown-image-block", h.mount(f);
    const d = cu(() => {
      l.value ? f.classList.add("selected") : f.classList.remove("selected");
    }), p = u.proxyDomURL, m = (g) => {
      if (!p)
        i.value = g.attrs.src;
      else {
        const b = p(g.attrs.src);
        typeof b == "string" ? i.value = b : b.then((w) => {
          i.value = w;
        }).catch(console.error);
      }
      o.value = g.attrs.ratio, s.value = g.attrs.caption, a.value = !t.editable;
    };
    return m(e), {
      dom: f,
      update: (g) => g.type !== e.type ? !1 : (m(g), !0),
      stopEvent: (g) => g.target instanceof HTMLInputElement,
      selectNode: () => {
        l.value = !0;
      },
      deselectNode: () => {
        l.value = !1;
      },
      destroy: () => {
        d(), h.unmount(), f.remove();
      }
    };
  }
);
Td(HE, {
  displayName: "NodeView<image-block>",
  group: "ImageBlock"
});
const UZ = [
  bv,
  Y1,
  HE,
  G1
].flat();
var d5, p5;
if (typeof WeakMap < "u") {
  let n = /* @__PURE__ */ new WeakMap();
  d5 = (e) => n.get(e), p5 = (e, t) => (n.set(e, t), t);
} else {
  const n = [];
  let t = 0;
  d5 = (r) => {
    for (let i = 0; i < n.length; i += 2)
      if (n[i] == r) return n[i + 1];
  }, p5 = (r, i) => (t == 10 && (t = 0), n[t++] = r, n[t++] = i);
}
var wt = class {
  constructor(n, e, t, r) {
    this.width = n, this.height = e, this.map = t, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(n) {
    for (let e = 0; e < this.map.length; e++) {
      const t = this.map[e];
      if (t != n) continue;
      const r = e % this.width, i = e / this.width | 0;
      let s = r + 1, o = i + 1;
      for (let l = 1; s < this.width && this.map[e + l] == t; l++)
        s++;
      for (let l = 1; o < this.height && this.map[e + this.width * l] == t; l++)
        o++;
      return { left: r, top: i, right: s, bottom: o };
    }
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(n) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == n)
        return e % this.width;
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(n, e, t) {
    const { left: r, right: i, top: s, bottom: o } = this.findCell(n);
    return e == "horiz" ? (t < 0 ? r == 0 : i == this.width) ? null : this.map[s * this.width + (t < 0 ? r - 1 : i)] : (t < 0 ? s == 0 : o == this.height) ? null : this.map[r + this.width * (t < 0 ? s - 1 : o)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(n, e) {
    const {
      left: t,
      right: r,
      top: i,
      bottom: s
    } = this.findCell(n), {
      left: o,
      right: l,
      top: a,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(t, o),
      top: Math.min(i, a),
      right: Math.max(r, l),
      bottom: Math.max(s, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(n) {
    const e = [], t = {};
    for (let r = n.top; r < n.bottom; r++)
      for (let i = n.left; i < n.right; i++) {
        const s = r * this.width + i, o = this.map[s];
        t[o] || (t[o] = !0, !(i == n.left && i && this.map[s - 1] == o || r == n.top && r && this.map[s - this.width] == o) && e.push(o));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(n, e, t) {
    for (let r = 0, i = 0; ; r++) {
      const s = i + t.child(r).nodeSize;
      if (r == n) {
        let o = e + n * this.width;
        const l = (n + 1) * this.width;
        for (; o < l && this.map[o] < i; ) o++;
        return o == l ? s - 1 : this.map[o];
      }
      i = s;
    }
  }
  // Find the table map for the given table node.
  static get(n) {
    return d5(n) || p5(n, KZ(n));
  }
};
function KZ(n) {
  if (n.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + n.type.name);
  const e = GZ(n), t = n.childCount, r = [];
  let i = 0, s = null;
  const o = [];
  for (let c = 0, u = e * t; c < u; c++) r[c] = 0;
  for (let c = 0, u = 0; c < t; c++) {
    const h = n.child(c);
    u++;
    for (let p = 0; ; p++) {
      for (; i < r.length && r[i] != 0; ) i++;
      if (p == h.childCount) break;
      const m = h.child(p), { colspan: g, rowspan: b, colwidth: w } = m.attrs;
      for (let k = 0; k < b; k++) {
        if (k + c >= t) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: b - k
          });
          break;
        }
        const C = i + k * e;
        for (let M = 0; M < g; M++) {
          r[C + M] == 0 ? r[C + M] = u : (s || (s = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: g - M
          });
          const T = w && w[M];
          if (T) {
            const N = (C + M) % e * 2, B = o[N];
            B == null || B != T && o[N + 1] == 1 ? (o[N] = T, o[N + 1] = 1) : B == T && o[N + 1]++;
          }
        }
      }
      i += g, u += m.nodeSize;
    }
    const f = (c + 1) * e;
    let d = 0;
    for (; i < f; ) r[i++] == 0 && d++;
    d && (s || (s = [])).push({ type: "missing", row: c, n: d }), u++;
  }
  (e === 0 || t === 0) && (s || (s = [])).push({ type: "zero_sized" });
  const l = new wt(e, t, r, s);
  let a = !1;
  for (let c = 0; !a && c < o.length; c += 2)
    o[c] != null && o[c + 1] < t && (a = !0);
  return a && YZ(l, o, n), l;
}
function GZ(n) {
  let e = -1, t = !1;
  for (let r = 0; r < n.childCount; r++) {
    const i = n.child(r);
    let s = 0;
    if (t)
      for (let o = 0; o < r; o++) {
        const l = n.child(o);
        for (let a = 0; a < l.childCount; a++) {
          const c = l.child(a);
          o + c.attrs.rowspan > r && (s += c.attrs.colspan);
        }
      }
    for (let o = 0; o < i.childCount; o++) {
      const l = i.child(o);
      s += l.attrs.colspan, l.attrs.rowspan > 1 && (t = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function YZ(n, e, t) {
  n.problems || (n.problems = []);
  const r = {};
  for (let i = 0; i < n.map.length; i++) {
    const s = n.map[i];
    if (r[s]) continue;
    r[s] = !0;
    const o = t.nodeAt(s);
    if (!o)
      throw new RangeError(`No cell with offset ${s} found`);
    let l = null;
    const a = o.attrs;
    for (let c = 0; c < a.colspan; c++) {
      const u = (i + c) % n.width, h = e[u * 2];
      h != null && (!a.colwidth || a.colwidth[c] != h) && ((l || (l = JZ(a)))[c] = h);
    }
    l && n.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: l
    });
  }
}
function JZ(n) {
  if (n.colwidth) return n.colwidth.slice();
  const e = [];
  for (let t = 0; t < n.colspan; t++) e.push(0);
  return e;
}
function ok(n, e) {
  if (typeof n == "string")
    return {};
  const t = n.getAttribute("data-colwidth"), r = t && /^\d+(,\d+)*$/.test(t) ? t.split(",").map((o) => Number(o)) : null, i = Number(n.getAttribute("colspan") || 1), s = {
    colspan: i,
    rowspan: Number(n.getAttribute("rowspan") || 1),
    colwidth: r && r.length == i ? r : null
  };
  for (const o in e) {
    const l = e[o].getFromDOM, a = l && l(n);
    a != null && (s[o] = a);
  }
  return s;
}
function lk(n, e) {
  const t = {};
  n.attrs.colspan != 1 && (t.colspan = n.attrs.colspan), n.attrs.rowspan != 1 && (t.rowspan = n.attrs.rowspan), n.attrs.colwidth && (t["data-colwidth"] = n.attrs.colwidth.join(","));
  for (const r in e) {
    const i = e[r].setDOMAttr;
    i && i(n.attrs[r], t);
  }
  return t;
}
function XZ(n) {
  if (n !== null) {
    if (!Array.isArray(n))
      throw new TypeError("colwidth must be null or an array");
    for (const e of n)
      if (typeof e != "number")
        throw new TypeError("colwidth must be null or an array of numbers");
  }
}
function ZZ(n) {
  const e = n.cellAttributes || {}, t = {
    colspan: { default: 1, validate: "number" },
    rowspan: { default: 1, validate: "number" },
    colwidth: { default: null, validate: XZ }
  };
  for (const r in e)
    t[r] = {
      default: e[r].default,
      validate: e[r].validate
    };
  return {
    table: {
      content: "table_row+",
      tableRole: "table",
      isolating: !0,
      group: n.tableGroup,
      parseDOM: [{ tag: "table" }],
      toDOM() {
        return ["table", ["tbody", 0]];
      }
    },
    table_row: {
      content: "(table_cell | table_header)*",
      tableRole: "row",
      parseDOM: [{ tag: "tr" }],
      toDOM() {
        return ["tr", 0];
      }
    },
    table_cell: {
      content: n.cellContent,
      attrs: t,
      tableRole: "cell",
      isolating: !0,
      parseDOM: [
        { tag: "td", getAttrs: (r) => ok(r, e) }
      ],
      toDOM(r) {
        return ["td", lk(r, e), 0];
      }
    },
    table_header: {
      content: n.cellContent,
      attrs: t,
      tableRole: "header_cell",
      isolating: !0,
      parseDOM: [
        { tag: "th", getAttrs: (r) => ok(r, e) }
      ],
      toDOM(r) {
        return ["th", lk(r, e), 0];
      }
    }
  };
}
function xi(n) {
  let e = n.cached.tableNodeTypes;
  if (!e) {
    e = n.cached.tableNodeTypes = {};
    for (const t in n.nodes) {
      const r = n.nodes[t], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var Ko = new en("selectingCells");
function Ad(n) {
  for (let e = n.depth - 1; e > 0; e--)
    if (n.node(e).type.spec.tableRole == "row")
      return n.node(0).resolve(n.before(e + 1));
  return null;
}
function Ci(n) {
  const e = n.selection.$head;
  for (let t = e.depth; t > 0; t--)
    if (e.node(t).type.spec.tableRole == "row") return !0;
  return !1;
}
function J1(n) {
  const e = n.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const t = Ad(e.$head) || QZ(e.$head);
  if (t)
    return t;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function QZ(n) {
  for (let e = n.nodeAfter, t = n.pos; e; e = e.firstChild, t++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return n.doc.resolve(t);
  }
  for (let e = n.nodeBefore, t = n.pos; e; e = e.lastChild, t--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return n.doc.resolve(t - e.nodeSize);
  }
}
function m5(n) {
  return n.parent.type.spec.tableRole == "row" && !!n.nodeAfter;
}
function eQ(n) {
  return n.node(0).resolve(n.pos + n.nodeAfter.nodeSize);
}
function vv(n, e) {
  return n.depth == e.depth && n.pos >= e.start(-1) && n.pos <= e.end(-1);
}
function $E(n, e, t) {
  const r = n.node(-1), i = wt.get(r), s = n.start(-1), o = i.nextCell(n.pos - s, e, t);
  return o == null ? null : n.node(0).resolve(s + o);
}
function Ra(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan - t };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, t), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function tQ(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan + t };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < t; i++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function nQ(n, e, t) {
  const r = xi(e.type.schema).header_cell;
  for (let i = 0; i < n.height; i++)
    if (e.nodeAt(n.map[t + i * n.width]).type != r)
      return !1;
  return !0;
}
var Rt = class qs extends Ge {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, t = e) {
    const r = e.node(-1), i = wt.get(r), s = e.start(-1), o = i.rectBetween(
      e.pos - s,
      t.pos - s
    ), l = e.node(0), a = i.cellsInRect(o).filter((u) => u != t.pos - s);
    a.unshift(t.pos - s);
    const c = a.map((u) => {
      const h = r.nodeAt(u);
      if (!h)
        throw RangeError(`No cell with offset ${u} found`);
      const f = s + u + 1;
      return new yC(
        l.resolve(f),
        l.resolve(f + h.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = t;
  }
  map(e, t) {
    const r = e.resolve(t.map(this.$anchorCell.pos)), i = e.resolve(t.map(this.$headCell.pos));
    if (m5(r) && m5(i) && vv(r, i)) {
      const s = this.$anchorCell.node(-1) != r.node(-1);
      return s && this.isRowSelection() ? qs.rowSelection(r, i) : s && this.isColSelection() ? qs.colSelection(r, i) : new qs(r, i);
    }
    return Ee.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), t = wt.get(e), r = this.$anchorCell.start(-1), i = t.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), s = {}, o = [];
    for (let a = i.top; a < i.bottom; a++) {
      const c = [];
      for (let u = a * t.width + i.left, h = i.left; h < i.right; h++, u++) {
        const f = t.map[u];
        if (s[f]) continue;
        s[f] = !0;
        const d = t.findCell(f);
        let p = e.nodeAt(f);
        if (!p)
          throw RangeError(`No cell with offset ${f} found`);
        const m = i.left - d.left, g = d.right - i.right;
        if (m > 0 || g > 0) {
          let b = p.attrs;
          if (m > 0 && (b = Ra(b, 0, m)), g > 0 && (b = Ra(
            b,
            b.colspan - g,
            g
          )), d.left < i.left) {
            if (p = p.type.createAndFill(b), !p)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(b)}`
              );
          } else
            p = p.type.create(b, p.content);
        }
        if (d.top < i.top || d.bottom > i.bottom) {
          const b = {
            ...p.attrs,
            rowspan: Math.min(d.bottom, i.bottom) - Math.max(d.top, i.top)
          };
          d.top < i.top ? p = p.type.createAndFill(b) : p = p.type.create(b, p.content);
        }
        c.push(p);
      }
      o.push(e.child(a).copy(ce.from(c)));
    }
    const l = this.isColSelection() && this.isRowSelection() ? e : o;
    return new me(ce.from(l), 1, 1);
  }
  replace(e, t = me.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      const { $from: l, $to: a } = i[o], c = e.mapping.slice(r);
      e.replace(
        c.map(l.pos),
        c.map(a.pos),
        o ? me.empty : t
      );
    }
    const s = Ge.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    s && e.setSelection(s);
  }
  replaceWith(e, t) {
    this.replace(e, new me(ce.from(t), 0, 0));
  }
  forEachCell(e) {
    const t = this.$anchorCell.node(-1), r = wt.get(t), i = this.$anchorCell.start(-1), s = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let o = 0; o < s.length; o++)
      e(t.nodeAt(s[o]), i + s[o]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1);
    if (Math.min(e, t) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = t + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, t = e) {
    const r = e.node(-1), i = wt.get(r), s = e.start(-1), o = i.findCell(e.pos - s), l = i.findCell(t.pos - s), a = e.node(0);
    return o.top <= l.top ? (o.top > 0 && (e = a.resolve(s + i.map[o.left])), l.bottom < i.height && (t = a.resolve(
      s + i.map[i.width * (i.height - 1) + l.right - 1]
    ))) : (l.top > 0 && (t = a.resolve(s + i.map[l.left])), o.bottom < i.height && (e = a.resolve(
      s + i.map[i.width * (i.height - 1) + o.right - 1]
    ))), new qs(e, t);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), t = wt.get(e), r = this.$anchorCell.start(-1), i = t.colCount(this.$anchorCell.pos - r), s = t.colCount(this.$headCell.pos - r);
    if (Math.min(i, s) > 0) return !1;
    const o = i + this.$anchorCell.nodeAfter.attrs.colspan, l = s + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(o, l) == t.width;
  }
  eq(e) {
    return e instanceof qs && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, t = e) {
    const r = e.node(-1), i = wt.get(r), s = e.start(-1), o = i.findCell(e.pos - s), l = i.findCell(t.pos - s), a = e.node(0);
    return o.left <= l.left ? (o.left > 0 && (e = a.resolve(
      s + i.map[o.top * i.width]
    )), l.right < i.width && (t = a.resolve(
      s + i.map[i.width * (l.top + 1) - 1]
    ))) : (l.left > 0 && (t = a.resolve(s + i.map[l.top * i.width])), o.right < i.width && (e = a.resolve(
      s + i.map[i.width * (o.top + 1) - 1]
    ))), new qs(e, t);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, t) {
    return new qs(e.resolve(t.anchor), e.resolve(t.head));
  }
  static create(e, t, r = t) {
    return new qs(e.resolve(t), e.resolve(r));
  }
  getBookmark() {
    return new rQ(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Rt.prototype.visible = !1;
Ge.jsonID("cell", Rt);
var rQ = class VE {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new VE(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const t = e.resolve(this.anchor), r = e.resolve(this.head);
    return t.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && r.index() < r.parent.childCount && vv(t, r) ? new Rt(t, r) : Ge.near(r, 1);
  }
};
function iQ(n) {
  if (!(n.selection instanceof Rt)) return null;
  const e = [];
  return n.selection.forEachCell((t, r) => {
    e.push(
      mr.node(r, r + t.nodeSize, { class: "selectedCell" })
    );
  }), It.create(n.doc, e);
}
function sQ({ $from: n, $to: e }) {
  if (n.pos == e.pos || n.pos < e.pos - 6) return !1;
  let t = n.pos, r = e.pos, i = n.depth;
  for (; i >= 0 && !(n.after(i + 1) < n.end(i)); i--, t++)
    ;
  for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, r--)
    ;
  return t == r && /row|table/.test(n.node(i).type.spec.tableRole);
}
function oQ({ $from: n, $to: e }) {
  let t, r;
  for (let i = n.depth; i > 0; i--) {
    const s = n.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      t = s;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const s = e.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      r = s;
      break;
    }
  }
  return t !== r && e.parentOffset === 0;
}
function lQ(n, e, t) {
  const r = (e || n).selection, i = (e || n).doc;
  let s, o;
  if (r instanceof $e && (o = r.node.type.spec.tableRole)) {
    if (o == "cell" || o == "header_cell")
      s = Rt.create(i, r.from);
    else if (o == "row") {
      const l = i.resolve(r.from + 1);
      s = Rt.rowSelection(l, l);
    } else if (!t) {
      const l = wt.get(r.node), a = r.from + 1, c = a + l.map[l.width * l.height - 1];
      s = Rt.create(i, a + 1, c);
    }
  } else r instanceof Ee && sQ(r) ? s = Ee.create(i, r.from) : r instanceof Ee && oQ(r) && (s = Ee.create(i, r.$from.start(), r.$from.end()));
  return s && (e || (e = n.tr)).setSelection(s), e;
}
var aQ = new en("fix-tables");
function qE(n, e, t, r) {
  const i = n.childCount, s = e.childCount;
  e: for (let o = 0, l = 0; o < s; o++) {
    const a = e.child(o);
    for (let c = l, u = Math.min(i, o + 3); c < u; c++)
      if (n.child(c) == a) {
        l = c + 1, t += a.nodeSize;
        continue e;
      }
    r(a, t), l < i && n.child(l).sameMarkup(a) ? qE(n.child(l), a, t + 1, r) : a.nodesBetween(0, a.content.size, r, t + 1), t += a.nodeSize;
  }
}
function cQ(n, e) {
  let t;
  const r = (i, s) => {
    i.type.spec.tableRole == "table" && (t = uQ(n, i, s, t));
  };
  return e ? e.doc != n.doc && qE(e.doc, n.doc, 0, r) : n.doc.descendants(r), t;
}
function uQ(n, e, t, r) {
  const i = wt.get(e);
  if (!i.problems) return r;
  r || (r = n.tr);
  const s = [];
  for (let a = 0; a < i.height; a++) s.push(0);
  for (let a = 0; a < i.problems.length; a++) {
    const c = i.problems[a];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      const h = u.attrs;
      for (let f = 0; f < h.rowspan; f++) s[c.row + f] += c.n;
      r.setNodeMarkup(
        r.mapping.map(t + 1 + c.pos),
        null,
        Ra(h, h.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      s[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const u = r.mapping.map(t);
      r.delete(u, u + e.nodeSize);
    }
  }
  let o, l;
  for (let a = 0; a < s.length; a++)
    s[a] && (o == null && (o = a), l = a);
  for (let a = 0, c = t + 1; a < i.height; a++) {
    const u = e.child(a), h = c + u.nodeSize, f = s[a];
    if (f > 0) {
      let d = "cell";
      u.firstChild && (d = u.firstChild.type.spec.tableRole);
      const p = [];
      for (let g = 0; g < f; g++) {
        const b = xi(n.schema)[d].createAndFill();
        b && p.push(b);
      }
      const m = (a == 0 || o == a - 1) && l == a ? c + 1 : h - 1;
      r.insert(r.mapping.map(m), p);
    }
    c = h;
  }
  return r.setMeta(aQ, { fixTables: !0 });
}
function Al(n) {
  const e = n.selection, t = J1(n), r = t.node(-1), i = t.start(-1), s = wt.get(r);
  return { ...e instanceof Rt ? s.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : s.findCell(t.pos - i), tableStart: i, map: s, table: r };
}
function WE(n, { map: e, tableStart: t, table: r }, i) {
  let s = i > 0 ? -1 : 0;
  nQ(e, r, i + s) && (s = i == 0 || i == e.width ? null : 0);
  for (let o = 0; o < e.height; o++) {
    const l = o * e.width + i;
    if (i > 0 && i < e.width && e.map[l - 1] == e.map[l]) {
      const a = e.map[l], c = r.nodeAt(a);
      n.setNodeMarkup(
        n.mapping.map(t + a),
        null,
        tQ(c.attrs, i - e.colCount(a))
      ), o += c.attrs.rowspan - 1;
    } else {
      const a = s == null ? xi(r.type.schema).cell : r.nodeAt(e.map[l + s]).type, c = e.positionAt(o, i, r);
      n.insert(n.mapping.map(t + c), a.createAndFill());
    }
  }
  return n;
}
function hQ(n, e) {
  if (!Ci(n)) return !1;
  if (e) {
    const t = Al(n);
    e(WE(n.tr, t, t.left));
  }
  return !0;
}
function fQ(n, e) {
  if (!Ci(n)) return !1;
  if (e) {
    const t = Al(n);
    e(WE(n.tr, t, t.right));
  }
  return !0;
}
function dQ(n, { map: e, table: t, tableStart: r }, i) {
  const s = n.mapping.maps.length;
  for (let o = 0; o < e.height; ) {
    const l = o * e.width + i, a = e.map[l], c = t.nodeAt(a), u = c.attrs;
    if (i > 0 && e.map[l - 1] == a || i < e.width - 1 && e.map[l + 1] == a)
      n.setNodeMarkup(
        n.mapping.slice(s).map(r + a),
        null,
        Ra(u, i - e.colCount(a))
      );
    else {
      const h = n.mapping.slice(s).map(r + a);
      n.delete(h, h + c.nodeSize);
    }
    o += u.rowspan;
  }
}
function pQ(n, e) {
  if (!Ci(n)) return !1;
  if (e) {
    const t = Al(n), r = n.tr;
    if (t.left == 0 && t.right == t.map.width) return !1;
    for (let i = t.right - 1; dQ(r, t, i), i != t.left; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = wt.get(s);
    }
    e(r);
  }
  return !0;
}
function mQ(n, { map: e, table: t, tableStart: r }, i) {
  let s = 0;
  for (let c = 0; c < i; c++) s += t.child(c).nodeSize;
  const o = s + t.child(i).nodeSize, l = n.mapping.maps.length;
  n.delete(s + r, o + r);
  const a = /* @__PURE__ */ new Set();
  for (let c = 0, u = i * e.width; c < e.width; c++, u++) {
    const h = e.map[u];
    if (!a.has(h)) {
      if (a.add(h), i > 0 && h == e.map[u - e.width]) {
        const f = t.nodeAt(h).attrs;
        n.setNodeMarkup(n.mapping.slice(l).map(h + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (i < e.height && h == e.map[u + e.width]) {
        const f = t.nodeAt(h), d = f.attrs, p = f.type.create(
          { ...d, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), m = e.positionAt(i + 1, c, t);
        n.insert(n.mapping.slice(l).map(r + m), p), c += d.colspan - 1;
      }
    }
  }
}
function gQ(n, e) {
  if (!Ci(n)) return !1;
  if (e) {
    const t = Al(n), r = n.tr;
    if (t.top == 0 && t.bottom == t.map.height) return !1;
    for (let i = t.bottom - 1; mQ(r, t, i), i != t.top; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = wt.get(t.table);
    }
    e(r);
  }
  return !0;
}
function yQ(n, e) {
  return function(t, r) {
    if (!Ci(t)) return !1;
    const i = J1(t);
    if (i.nodeAfter.attrs[n] === e) return !1;
    if (r) {
      const s = t.tr;
      t.selection instanceof Rt ? t.selection.forEachCell((o, l) => {
        o.attrs[n] !== e && s.setNodeMarkup(l, null, {
          ...o.attrs,
          [n]: e
        });
      }) : s.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [n]: e
      }), r(s);
    }
    return !0;
  };
}
function bQ(n) {
  return function(e, t) {
    if (!Ci(e)) return !1;
    if (t) {
      const r = xi(e.schema), i = Al(e), s = e.tr, o = i.map.cellsInRect(
        n == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : n == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), l = o.map((a) => i.table.nodeAt(a));
      for (let a = 0; a < o.length; a++)
        l[a].type == r.header_cell && s.setNodeMarkup(
          i.tableStart + o[a],
          r.cell,
          l[a].attrs
        );
      if (s.steps.length == 0)
        for (let a = 0; a < o.length; a++)
          s.setNodeMarkup(
            i.tableStart + o[a],
            r.header_cell,
            l[a].attrs
          );
      t(s);
    }
    return !0;
  };
}
function ak(n, e, t) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: n == "row" ? e.map.width : 1,
    bottom: n == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const s = e.table.nodeAt(r[i]);
    if (s && s.type !== t.header_cell)
      return !1;
  }
  return !0;
}
function wv(n, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? bQ(n) : function(t, r) {
    if (!Ci(t)) return !1;
    if (r) {
      const i = xi(t.schema), s = Al(t), o = t.tr, l = ak("row", s, i), a = ak(
        "column",
        s,
        i
      ), u = (n === "column" ? l : n === "row" ? a : !1) ? 1 : 0, h = n == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: s.map.height
      } : n == "row" ? {
        left: u,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, f = n == "column" ? a ? i.cell : i.header_cell : n == "row" ? l ? i.cell : i.header_cell : i.cell;
      s.map.cellsInRect(h).forEach((d) => {
        const p = d + s.tableStart, m = o.doc.nodeAt(p);
        m && o.setNodeMarkup(p, f, m.attrs);
      }), r(o);
    }
    return !0;
  };
}
wv("row", {
  useDeprecatedLogic: !0
});
wv("column", {
  useDeprecatedLogic: !0
});
wv("cell", {
  useDeprecatedLogic: !0
});
function vQ(n, e) {
  if (e < 0) {
    const t = n.nodeBefore;
    if (t) return n.pos - t.nodeSize;
    for (let r = n.index(-1) - 1, i = n.before(); r >= 0; r--) {
      const s = n.node(-1).child(r), o = s.lastChild;
      if (o)
        return i - 1 - o.nodeSize;
      i -= s.nodeSize;
    }
  } else {
    if (n.index() < n.parent.childCount - 1)
      return n.pos + n.nodeAfter.nodeSize;
    const t = n.node(-1);
    for (let r = n.indexAfter(-1), i = n.after(); r < t.childCount; r++) {
      const s = t.child(r);
      if (s.childCount) return i + 1;
      i += s.nodeSize;
    }
  }
  return null;
}
function jE(n) {
  return function(e, t) {
    if (!Ci(e)) return !1;
    const r = vQ(J1(e), n);
    if (r == null) return !1;
    if (t) {
      const i = e.doc.resolve(r);
      t(
        e.tr.setSelection(Ee.between(i, eQ(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function wQ(n, e) {
  const t = n.selection.$anchor;
  for (let r = t.depth; r > 0; r--)
    if (t.node(r).type.spec.tableRole == "table")
      return e && e(
        n.tr.delete(t.before(r), t.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function v0(n, e) {
  const t = n.selection;
  if (!(t instanceof Rt)) return !1;
  if (e) {
    const r = n.tr, i = xi(n.schema).cell.createAndFill().content;
    t.forEachCell((s, o) => {
      s.content.eq(i) || r.replace(
        r.mapping.map(o + 1),
        r.mapping.map(o + s.nodeSize - 1),
        new me(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function xQ(n) {
  if (!n.size) return null;
  let { content: e, openStart: t, openEnd: r } = n;
  for (; e.childCount == 1 && (t > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    t--, r--, e = e.child(0).content;
  const i = e.child(0), s = i.type.spec.tableRole, o = i.type.schema, l = [];
  if (s == "row")
    for (let a = 0; a < e.childCount; a++) {
      let c = e.child(a).content;
      const u = a ? 0 : Math.max(0, t - 1), h = a < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (u || h) && (c = g5(
        xi(o).row,
        new me(c, u, h)
      ).content), l.push(c);
    }
  else if (s == "cell" || s == "header_cell")
    l.push(
      t || r ? g5(
        xi(o).row,
        new me(e, t, r)
      ).content : e
    );
  else
    return null;
  return kQ(o, l);
}
function kQ(n, e) {
  const t = [];
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    for (let o = s.childCount - 1; o >= 0; o--) {
      const { rowspan: l, colspan: a } = s.child(o).attrs;
      for (let c = i; c < i + l; c++)
        t[c] = (t[c] || 0) + a;
    }
  }
  let r = 0;
  for (let i = 0; i < t.length; i++) r = Math.max(r, t[i]);
  for (let i = 0; i < t.length; i++)
    if (i >= e.length && e.push(ce.empty), t[i] < r) {
      const s = xi(n).cell.createAndFill(), o = [];
      for (let l = t[i]; l < r; l++)
        o.push(s);
      e[i] = e[i].append(ce.from(o));
    }
  return { height: e.length, width: r, rows: e };
}
function g5(n, e) {
  const t = n.createAndFill();
  return new gC(t).replace(0, t.content.size, e).doc;
}
function SQ({ width: n, height: e, rows: t }, r, i) {
  if (n != r) {
    const s = [], o = [];
    for (let l = 0; l < t.length; l++) {
      const a = t[l], c = [];
      for (let u = s[l] || 0, h = 0; u < r; h++) {
        let f = a.child(h % a.childCount);
        u + f.attrs.colspan > r && (f = f.type.createChecked(
          Ra(
            f.attrs,
            f.attrs.colspan,
            u + f.attrs.colspan - r
          ),
          f.content
        )), c.push(f), u += f.attrs.colspan;
        for (let d = 1; d < f.attrs.rowspan; d++)
          s[l + d] = (s[l + d] || 0) + f.attrs.colspan;
      }
      o.push(ce.from(c));
    }
    t = o, n = r;
  }
  if (e != i) {
    const s = [];
    for (let o = 0, l = 0; o < i; o++, l++) {
      const a = [], c = t[l % e];
      for (let u = 0; u < c.childCount; u++) {
        let h = c.child(u);
        o + h.attrs.rowspan > i && (h = h.type.create(
          {
            ...h.attrs,
            rowspan: Math.max(1, i - h.attrs.rowspan)
          },
          h.content
        )), a.push(h);
      }
      s.push(ce.from(a));
    }
    t = s, e = i;
  }
  return { width: n, height: e, rows: t };
}
function CQ(n, e, t, r, i, s, o) {
  const l = n.doc.type.schema, a = xi(l);
  let c, u;
  if (i > e.width)
    for (let h = 0, f = 0; h < e.height; h++) {
      const d = t.child(h);
      f += d.nodeSize;
      const p = [];
      let m;
      d.lastChild == null || d.lastChild.type == a.cell ? m = c || (c = a.cell.createAndFill()) : m = u || (u = a.header_cell.createAndFill());
      for (let g = e.width; g < i; g++) p.push(m);
      n.insert(n.mapping.slice(o).map(f - 1 + r), p);
    }
  if (s > e.height) {
    const h = [];
    for (let p = 0, m = (e.height - 1) * e.width; p < Math.max(e.width, i); p++) {
      const g = p >= e.width ? !1 : t.nodeAt(e.map[m + p]).type == a.header_cell;
      h.push(
        g ? u || (u = a.header_cell.createAndFill()) : c || (c = a.cell.createAndFill())
      );
    }
    const f = a.row.create(null, ce.from(h)), d = [];
    for (let p = e.height; p < s; p++) d.push(f);
    n.insert(n.mapping.slice(o).map(r + t.nodeSize - 2), d);
  }
  return !!(c || u);
}
function ck(n, e, t, r, i, s, o, l) {
  if (o == 0 || o == e.height) return !1;
  let a = !1;
  for (let c = i; c < s; c++) {
    const u = o * e.width + c, h = e.map[u];
    if (e.map[u - e.width] == h) {
      a = !0;
      const f = t.nodeAt(h), { top: d, left: p } = e.findCell(h);
      n.setNodeMarkup(n.mapping.slice(l).map(h + r), null, {
        ...f.attrs,
        rowspan: o - d
      }), n.insert(
        n.mapping.slice(l).map(e.positionAt(o, p, t)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: d + f.attrs.rowspan - o
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return a;
}
function uk(n, e, t, r, i, s, o, l) {
  if (o == 0 || o == e.width) return !1;
  let a = !1;
  for (let c = i; c < s; c++) {
    const u = c * e.width + o, h = e.map[u];
    if (e.map[u - 1] == h) {
      a = !0;
      const f = t.nodeAt(h), d = e.colCount(h), p = n.mapping.slice(l).map(h + r);
      n.setNodeMarkup(
        p,
        null,
        Ra(
          f.attrs,
          o - d,
          f.attrs.colspan - (o - d)
        )
      ), n.insert(
        p + f.nodeSize,
        f.type.createAndFill(
          Ra(f.attrs, 0, o - d)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return a;
}
function hk(n, e, t, r, i) {
  let s = t ? n.doc.nodeAt(t - 1) : n.doc;
  if (!s)
    throw new Error("No table found");
  let o = wt.get(s);
  const { top: l, left: a } = r, c = a + i.width, u = l + i.height, h = n.tr;
  let f = 0;
  function d() {
    if (s = t ? h.doc.nodeAt(t - 1) : h.doc, !s)
      throw new Error("No table found");
    o = wt.get(s), f = h.mapping.maps.length;
  }
  CQ(h, o, s, t, c, u, f) && d(), ck(h, o, s, t, a, c, l, f) && d(), ck(h, o, s, t, a, c, u, f) && d(), uk(h, o, s, t, l, u, a, f) && d(), uk(h, o, s, t, l, u, c, f) && d();
  for (let p = l; p < u; p++) {
    const m = o.positionAt(p, a, s), g = o.positionAt(p, c, s);
    h.replace(
      h.mapping.slice(f).map(m + t),
      h.mapping.slice(f).map(g + t),
      new me(i.rows[p - l], 0, 0)
    );
  }
  d(), h.setSelection(
    new Rt(
      h.doc.resolve(t + o.positionAt(l, a, s)),
      h.doc.resolve(t + o.positionAt(u - 1, c - 1, s))
    )
  ), e(h);
}
var MQ = p3({
  ArrowLeft: w0("horiz", -1),
  ArrowRight: w0("horiz", 1),
  ArrowUp: w0("vert", -1),
  ArrowDown: w0("vert", 1),
  "Shift-ArrowLeft": x0("horiz", -1),
  "Shift-ArrowRight": x0("horiz", 1),
  "Shift-ArrowUp": x0("vert", -1),
  "Shift-ArrowDown": x0("vert", 1),
  Backspace: v0,
  "Mod-Backspace": v0,
  Delete: v0,
  "Mod-Delete": v0
});
function Mp(n, e, t) {
  return t.eq(n.selection) ? !1 : (e && e(n.tr.setSelection(t).scrollIntoView()), !0);
}
function w0(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const s = t.selection;
    if (s instanceof Rt)
      return Mp(
        t,
        r,
        Ge.near(s.$headCell, e)
      );
    if (n != "horiz" && !s.empty) return !1;
    const o = UE(i, n, e);
    if (o == null) return !1;
    if (n == "horiz")
      return Mp(
        t,
        r,
        Ge.near(t.doc.resolve(s.head + e), e)
      );
    {
      const l = t.doc.resolve(o), a = $E(l, n, e);
      let c;
      return a ? c = Ge.near(a, 1) : e < 0 ? c = Ge.near(t.doc.resolve(l.before(-1)), -1) : c = Ge.near(t.doc.resolve(l.after(-1)), 1), Mp(t, r, c);
    }
  };
}
function x0(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const s = t.selection;
    let o;
    if (s instanceof Rt)
      o = s;
    else {
      const a = UE(i, n, e);
      if (a == null) return !1;
      o = new Rt(t.doc.resolve(a));
    }
    const l = $E(o.$headCell, n, e);
    return l ? Mp(
      t,
      r,
      new Rt(o.$anchorCell, l)
    ) : !1;
  };
}
function TQ(n, e) {
  const t = n.state.doc, r = Ad(t.resolve(e));
  return r ? (n.dispatch(n.state.tr.setSelection(new Rt(r))), !0) : !1;
}
function AQ(n, e, t) {
  if (!Ci(n.state)) return !1;
  let r = xQ(t);
  const i = n.state.selection;
  if (i instanceof Rt) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        ce.from(
          g5(xi(n.state.schema).cell, t)
        )
      ]
    });
    const s = i.$anchorCell.node(-1), o = i.$anchorCell.start(-1), l = wt.get(s).rectBetween(
      i.$anchorCell.pos - o,
      i.$headCell.pos - o
    );
    return r = SQ(r, l.right - l.left, l.bottom - l.top), hk(n.state, n.dispatch, o, l, r), !0;
  } else if (r) {
    const s = J1(n.state), o = s.start(-1);
    return hk(
      n.state,
      n.dispatch,
      o,
      wt.get(s.node(-1)).findCell(s.pos - o),
      r
    ), !0;
  } else
    return !1;
}
function OQ(n, e) {
  var t;
  if (e.ctrlKey || e.metaKey) return;
  const r = fk(n, e.target);
  let i;
  if (e.shiftKey && n.state.selection instanceof Rt)
    s(n.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = Ad(n.state.selection.$anchor)) != null && ((t = V2(n, e)) == null ? void 0 : t.pos) != i.pos)
    s(i, e), e.preventDefault();
  else if (!r)
    return;
  function s(a, c) {
    let u = V2(n, c);
    const h = Ko.getState(n.state) == null;
    if (!u || !vv(a, u))
      if (h) u = a;
      else return;
    const f = new Rt(a, u);
    if (h || !n.state.selection.eq(f)) {
      const d = n.state.tr.setSelection(f);
      h && d.setMeta(Ko, a.pos), n.dispatch(d);
    }
  }
  function o() {
    n.root.removeEventListener("mouseup", o), n.root.removeEventListener("dragstart", o), n.root.removeEventListener("mousemove", l), Ko.getState(n.state) != null && n.dispatch(n.state.tr.setMeta(Ko, -1));
  }
  function l(a) {
    const c = a, u = Ko.getState(n.state);
    let h;
    if (u != null)
      h = n.state.doc.resolve(u);
    else if (fk(n, c.target) != r && (h = V2(n, e), !h))
      return o();
    h && s(h, c);
  }
  n.root.addEventListener("mouseup", o), n.root.addEventListener("dragstart", o), n.root.addEventListener("mousemove", l);
}
function UE(n, e, t) {
  if (!(n.state.selection instanceof Ee)) return null;
  const { $head: r } = n.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const s = r.node(i);
    if ((t < 0 ? r.index(i) : r.indexAfter(i)) != (t < 0 ? 0 : s.childCount)) return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const l = r.before(i), a = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
      return n.endOfTextblock(a) ? l : null;
    }
  }
  return null;
}
function fk(n, e) {
  for (; e && e != n.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function V2(n, e) {
  const t = n.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return t && t ? Ad(n.state.doc.resolve(t.pos)) : null;
}
var EQ = class {
  constructor(n, e) {
    this.node = n, this.defaultCellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${e}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), y5(n, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(n) {
    return n.type != this.node.type ? !1 : (this.node = n, y5(
      n,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(n) {
    return n.type == "attributes" && (n.target == this.table || this.colgroup.contains(n.target));
  }
};
function y5(n, e, t, r, i, s) {
  var o;
  let l = 0, a = !0, c = e.firstChild;
  const u = n.firstChild;
  if (u) {
    for (let h = 0, f = 0; h < u.childCount; h++) {
      const { colspan: d, colwidth: p } = u.child(h).attrs;
      for (let m = 0; m < d; m++, f++) {
        const g = i == f ? s : p && p[m], b = g ? g + "px" : "";
        if (l += g || r, g || (a = !1), c)
          c.style.width != b && (c.style.width = b), c = c.nextSibling;
        else {
          const w = document.createElement("col");
          w.style.width = b, e.appendChild(w);
        }
      }
    }
    for (; c; ) {
      const h = c.nextSibling;
      (o = c.parentNode) == null || o.removeChild(c), c = h;
    }
    a ? (t.style.width = l + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = l + "px");
  }
}
var Gr = new en(
  "tableColumnResizing"
);
function IQ({
  handleWidth: n = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: t = 100,
  View: r = EQ,
  lastColumnResizable: i = !0
} = {}) {
  const s = new Ut({
    key: Gr,
    state: {
      init(o, l) {
        var a, c;
        const u = (c = (a = s.spec) == null ? void 0 : a.props) == null ? void 0 : c.nodeViews, h = xi(l.schema).table.name;
        return r && u && (u[h] = (f, d) => new r(f, t, d)), new DQ(-1, !1);
      },
      apply(o, l) {
        return l.apply(o);
      }
    },
    props: {
      attributes: (o) => {
        const l = Gr.getState(o);
        return l && l.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (o, l) => {
          NQ(o, l, n, i);
        },
        mouseleave: (o) => {
          RQ(o);
        },
        mousedown: (o, l) => {
          PQ(o, l, e, t);
        }
      },
      decorations: (o) => {
        const l = Gr.getState(o);
        if (l && l.activeHandle > -1)
          return FQ(o, l.activeHandle);
      },
      nodeViews: {}
    }
  });
  return s;
}
var DQ = class Tp {
  constructor(e, t) {
    this.activeHandle = e, this.dragging = t;
  }
  apply(e) {
    const t = this, r = e.getMeta(Gr);
    if (r && r.setHandle != null)
      return new Tp(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new Tp(t.activeHandle, r.setDragging);
    if (t.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(t.activeHandle, -1);
      return m5(e.doc.resolve(i)) || (i = -1), new Tp(i, t.dragging);
    }
    return t;
  }
};
function NQ(n, e, t, r) {
  if (!n.editable) return;
  const i = Gr.getState(n.state);
  if (i && !i.dragging) {
    const s = LQ(e.target);
    let o = -1;
    if (s) {
      const { left: l, right: a } = s.getBoundingClientRect();
      e.clientX - l <= t ? o = dk(n, e, "left", t) : a - e.clientX <= t && (o = dk(n, e, "right", t));
    }
    if (o != i.activeHandle) {
      if (!r && o !== -1) {
        const l = n.state.doc.resolve(o), a = l.node(-1), c = wt.get(a), u = l.start(-1);
        if (c.colCount(l.pos - u) + l.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      KE(n, o);
    }
  }
}
function RQ(n) {
  if (!n.editable) return;
  const e = Gr.getState(n.state);
  e && e.activeHandle > -1 && !e.dragging && KE(n, -1);
}
function PQ(n, e, t, r) {
  var i;
  if (!n.editable) return !1;
  const s = (i = n.dom.ownerDocument.defaultView) != null ? i : window, o = Gr.getState(n.state);
  if (!o || o.activeHandle == -1 || o.dragging)
    return !1;
  const l = n.state.doc.nodeAt(o.activeHandle), a = _Q(n, o.activeHandle, l.attrs);
  n.dispatch(
    n.state.tr.setMeta(Gr, {
      setDragging: { startX: e.clientX, startWidth: a }
    })
  );
  function c(h) {
    s.removeEventListener("mouseup", c), s.removeEventListener("mousemove", u);
    const f = Gr.getState(n.state);
    f?.dragging && (BQ(
      n,
      f.activeHandle,
      pk(f.dragging, h, t)
    ), n.dispatch(
      n.state.tr.setMeta(Gr, { setDragging: null })
    ));
  }
  function u(h) {
    if (!h.which) return c(h);
    const f = Gr.getState(n.state);
    if (f && f.dragging) {
      const d = pk(f.dragging, h, t);
      mk(
        n,
        f.activeHandle,
        d,
        r
      );
    }
  }
  return mk(
    n,
    o.activeHandle,
    a,
    r
  ), s.addEventListener("mouseup", c), s.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function _Q(n, e, { colspan: t, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i) return i;
  const s = n.domAtPos(e);
  let l = s.node.childNodes[s.offset].offsetWidth, a = t;
  if (r)
    for (let c = 0; c < t; c++)
      r[c] && (l -= r[c], a--);
  return l / a;
}
function LQ(n) {
  for (; n && n.nodeName != "TD" && n.nodeName != "TH"; )
    n = n.classList && n.classList.contains("ProseMirror") ? null : n.parentNode;
  return n;
}
function dk(n, e, t, r) {
  const i = t == "right" ? -r : r, s = n.posAtCoords({
    left: e.clientX + i,
    top: e.clientY
  });
  if (!s) return -1;
  const { pos: o } = s, l = Ad(n.state.doc.resolve(o));
  if (!l) return -1;
  if (t == "right") return l.pos;
  const a = wt.get(l.node(-1)), c = l.start(-1), u = a.map.indexOf(l.pos - c);
  return u % a.width == 0 ? -1 : c + a.map[u - 1];
}
function pk(n, e, t) {
  const r = e.clientX - n.startX;
  return Math.max(t, n.startWidth + r);
}
function KE(n, e) {
  n.dispatch(
    n.state.tr.setMeta(Gr, { setHandle: e })
  );
}
function BQ(n, e, t) {
  const r = n.state.doc.resolve(e), i = r.node(-1), s = wt.get(i), o = r.start(-1), l = s.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1, a = n.state.tr;
  for (let c = 0; c < s.height; c++) {
    const u = c * s.width + l;
    if (c && s.map[u] == s.map[u - s.width]) continue;
    const h = s.map[u], f = i.nodeAt(h).attrs, d = f.colspan == 1 ? 0 : l - s.colCount(h);
    if (f.colwidth && f.colwidth[d] == t) continue;
    const p = f.colwidth ? f.colwidth.slice() : zQ(f.colspan);
    p[d] = t, a.setNodeMarkup(o + h, null, { ...f, colwidth: p });
  }
  a.docChanged && n.dispatch(a);
}
function mk(n, e, t, r) {
  const i = n.state.doc.resolve(e), s = i.node(-1), o = i.start(-1), l = wt.get(s).colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1;
  let a = n.domAtPos(i.start(-1)).node;
  for (; a && a.nodeName != "TABLE"; )
    a = a.parentNode;
  a && y5(
    s,
    a.firstChild,
    a,
    r,
    l,
    t
  );
}
function zQ(n) {
  return Array(n).fill(0);
}
function FQ(n, e) {
  var t;
  const r = [], i = n.doc.resolve(e), s = i.node(-1);
  if (!s)
    return It.empty;
  const o = wt.get(s), l = i.start(-1), a = o.colCount(i.pos - l) + i.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < o.height; c++) {
    const u = a + c * o.width;
    if ((a == o.width - 1 || o.map[u] != o.map[u + 1]) && (c == 0 || o.map[u] != o.map[u - o.width])) {
      const h = o.map[u], f = l + h + s.nodeAt(h).nodeSize - 1, d = document.createElement("div");
      d.className = "column-resize-handle", (t = Gr.getState(n)) != null && t.dragging && r.push(
        mr.node(
          l + h,
          l + h + s.nodeAt(h).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(mr.widget(f, d));
    }
  }
  return It.create(n.doc, r);
}
function HQ({
  allowTableNodeSelection: n = !1
} = {}) {
  return new Ut({
    key: Ko,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, t) {
        const r = e.getMeta(Ko);
        if (r != null) return r == -1 ? null : r;
        if (t == null || !e.docChanged) return t;
        const { deleted: i, pos: s } = e.mapping.mapResult(t);
        return i ? null : s;
      }
    },
    props: {
      decorations: iQ,
      handleDOMEvents: {
        mousedown: OQ
      },
      createSelectionBetween(e) {
        return Ko.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: TQ,
      handleKeyDown: MQ,
      handlePaste: AQ
    },
    appendTransaction(e, t, r) {
      return lQ(
        r,
        cQ(r, t),
        n
      );
    }
  });
}
var Pm = typeof navigator < "u" ? navigator : null, xv = Pm && Pm.userAgent || "", $Q = /Edge\/(\d+)/.exec(xv), VQ = /MSIE \d/.exec(xv), qQ = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(xv), WQ = !!(VQ || qQ || $Q), jQ = !WQ && !!Pm && /Apple Computer/.test(Pm.vendor), GE = new en("safari-ime-span"), b5 = !1, UQ = {
  key: GE,
  props: {
    decorations: KQ,
    handleDOMEvents: {
      compositionstart: () => {
        b5 = !0;
      },
      compositionend: () => {
        b5 = !1;
      }
    }
  }
};
function KQ(n) {
  const { $from: e, $to: t, to: r } = n.selection;
  if (b5 && e.sameParent(t)) {
    const i = mr.widget(r, GQ, {
      ignoreSelection: !0,
      key: "safari-ime-span"
    });
    return It.create(n.doc, [i]);
  }
}
function GQ(n) {
  const e = n.dom.ownerDocument.createElement("span");
  return e.className = "ProseMirror-safari-ime-span", e;
}
var YQ = new Ut(jQ ? UQ : { key: GE });
function gk(n, e) {
  const t = String(n);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, i = t.indexOf(e);
  for (; i !== -1; )
    r++, i = t.indexOf(e, i + e.length);
  return r;
}
function JQ(n) {
  if (typeof n != "string")
    throw new TypeError("Expected a string");
  return n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function XQ(n, e, t) {
  const i = t1((t || {}).ignore || []), s = ZQ(e);
  let o = -1;
  for (; ++o < s.length; )
    X5(n, "text", l);
  function l(c, u) {
    let h = -1, f;
    for (; ++h < u.length; ) {
      const d = u[h], p = f ? f.children : void 0;
      if (i(
        d,
        p ? p.indexOf(d) : void 0,
        f
      ))
        return;
      f = d;
    }
    if (f)
      return a(c, u);
  }
  function a(c, u) {
    const h = u[u.length - 1], f = s[o][0], d = s[o][1];
    let p = 0;
    const g = h.children.indexOf(c);
    let b = !1, w = [];
    f.lastIndex = 0;
    let k = f.exec(c.value);
    for (; k; ) {
      const C = k.index, M = {
        index: k.index,
        input: k.input,
        stack: [...u, c]
      };
      let T = d(...k, M);
      if (typeof T == "string" && (T = T.length > 0 ? { type: "text", value: T } : void 0), T === !1 ? f.lastIndex = C + 1 : (p !== C && w.push({
        type: "text",
        value: c.value.slice(p, C)
      }), Array.isArray(T) ? w.push(...T) : T && w.push(T), p = C + k[0].length, b = !0), !f.global)
        break;
      k = f.exec(c.value);
    }
    return b ? (p < c.value.length && w.push({ type: "text", value: c.value.slice(p) }), h.children.splice(g, 1, ...w)) : w = [c], g + w.length;
  }
}
function ZQ(n) {
  const e = [];
  if (!Array.isArray(n))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const t = !n[0] || Array.isArray(n[0]) ? n : [n];
  let r = -1;
  for (; ++r < t.length; ) {
    const i = t[r];
    e.push([QQ(i[0]), eee(i[1])]);
  }
  return e;
}
function QQ(n) {
  return typeof n == "string" ? new RegExp(JQ(n), "g") : n;
}
function eee(n) {
  return typeof n == "function" ? n : function() {
    return n;
  };
}
const q2 = "phrasing", W2 = ["autolink", "link", "image", "label"];
function tee() {
  return {
    transforms: [aee],
    enter: {
      literalAutolink: ree,
      literalAutolinkEmail: j2,
      literalAutolinkHttp: j2,
      literalAutolinkWww: j2
    },
    exit: {
      literalAutolink: lee,
      literalAutolinkEmail: oee,
      literalAutolinkHttp: iee,
      literalAutolinkWww: see
    }
  };
}
function nee() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: q2,
        notInConstruct: W2
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: q2,
        notInConstruct: W2
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: q2,
        notInConstruct: W2
      }
    ]
  };
}
function ree(n) {
  this.enter({ type: "link", title: null, url: "", children: [] }, n);
}
function j2(n) {
  this.config.enter.autolinkProtocol.call(this, n);
}
function iee(n) {
  this.config.exit.autolinkProtocol.call(this, n);
}
function see(n) {
  this.config.exit.data.call(this, n);
  const e = this.stack[this.stack.length - 1];
  e.type, e.url = "http://" + this.sliceSerialize(n);
}
function oee(n) {
  this.config.exit.autolinkEmail.call(this, n);
}
function lee(n) {
  this.exit(n);
}
function aee(n) {
  XQ(
    n,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, cee],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), uee]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function cee(n, e, t, r, i) {
  let s = "";
  if (!YE(i) || (/^w/i.test(e) && (t = e + t, e = "", s = "http://"), !hee(t)))
    return !1;
  const o = fee(t + r);
  if (!o[0]) return !1;
  const l = {
    type: "link",
    title: null,
    url: s + e + o[0],
    children: [{ type: "text", value: e + o[0] }]
  };
  return o[1] ? [l, { type: "text", value: o[1] }] : l;
}
function uee(n, e, t, r) {
  return (
    // Not an expected previous character.
    !YE(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(t) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + e + "@" + t,
      children: [{ type: "text", value: e + "@" + t }]
    }
  );
}
function hee(n) {
  const e = n.split(".");
  return !(e.length < 2 || e[e.length - 1] && (/_/.test(e[e.length - 1]) || !/[a-zA-Z\d]/.test(e[e.length - 1])) || e[e.length - 2] && (/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2])));
}
function fee(n) {
  const e = /[!"&'),.:;<>?\]}]+$/.exec(n);
  if (!e)
    return [n, void 0];
  n = n.slice(0, e.index);
  let t = e[0], r = t.indexOf(")");
  const i = gk(n, "(");
  let s = gk(n, ")");
  for (; r !== -1 && i > s; )
    n += t.slice(0, r + 1), t = t.slice(r + 1), r = t.indexOf(")"), s++;
  return [n, t];
}
function YE(n, e) {
  const t = n.input.charCodeAt(n.index - 1);
  return (n.index === 0 || ba(t) || Qm(t)) && // If it’s an email, the previous character should not be a slash.
  (!e || t !== 47);
}
JE.peek = xee;
function dee() {
  this.buffer();
}
function pee(n) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, n);
}
function mee() {
  this.buffer();
}
function gee(n) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    n
  );
}
function yee(n) {
  const e = this.resume(), t = this.stack[this.stack.length - 1];
  t.type, t.identifier = Ni(
    this.sliceSerialize(n)
  ).toLowerCase(), t.label = e;
}
function bee(n) {
  this.exit(n);
}
function vee(n) {
  const e = this.resume(), t = this.stack[this.stack.length - 1];
  t.type, t.identifier = Ni(
    this.sliceSerialize(n)
  ).toLowerCase(), t.label = e;
}
function wee(n) {
  this.exit(n);
}
function xee() {
  return "[";
}
function JE(n, e, t, r) {
  const i = t.createTracker(r);
  let s = i.move("[^");
  const o = t.enter("footnoteReference"), l = t.enter("reference");
  return s += i.move(
    t.safe(t.associationId(n), { after: "]", before: s })
  ), l(), o(), s += i.move("]"), s;
}
function kee() {
  return {
    enter: {
      gfmFootnoteCallString: dee,
      gfmFootnoteCall: pee,
      gfmFootnoteDefinitionLabelString: mee,
      gfmFootnoteDefinition: gee
    },
    exit: {
      gfmFootnoteCallString: yee,
      gfmFootnoteCall: bee,
      gfmFootnoteDefinitionLabelString: vee,
      gfmFootnoteDefinition: wee
    }
  };
}
function See(n) {
  let e = !1;
  return n && n.firstLineBlank && (e = !0), {
    handlers: { footnoteDefinition: t, footnoteReference: JE },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function t(r, i, s, o) {
    const l = s.createTracker(o);
    let a = l.move("[^");
    const c = s.enter("footnoteDefinition"), u = s.enter("label");
    return a += l.move(
      s.safe(s.associationId(r), { before: a, after: "]" })
    ), u(), a += l.move("]:"), r.children && r.children.length > 0 && (l.shift(4), a += l.move(
      (e ? `
` : " ") + s.indentLines(
        s.containerFlow(r, l.current()),
        e ? XE : Cee
      )
    )), c(), a;
  }
}
function Cee(n, e, t) {
  return e === 0 ? n : XE(n, e, t);
}
function XE(n, e, t) {
  return (t ? "" : "    ") + n;
}
const Mee = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
ZE.peek = Iee;
function Tee() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Oee },
    exit: { strikethrough: Eee }
  };
}
function Aee() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Mee
      }
    ],
    handlers: { delete: ZE }
  };
}
function Oee(n) {
  this.enter({ type: "delete", children: [] }, n);
}
function Eee(n) {
  this.exit(n);
}
function ZE(n, e, t, r) {
  const i = t.createTracker(r), s = t.enter("strikethrough");
  let o = i.move("~~");
  return o += t.containerPhrasing(n, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), s(), o;
}
function Iee() {
  return "~";
}
function Dee(n) {
  return n.length;
}
function Nee(n, e) {
  const t = e || {}, r = (t.align || []).concat(), i = t.stringLength || Dee, s = [], o = [], l = [], a = [];
  let c = 0, u = -1;
  for (; ++u < n.length; ) {
    const m = [], g = [];
    let b = -1;
    for (n[u].length > c && (c = n[u].length); ++b < n[u].length; ) {
      const w = Ree(n[u][b]);
      if (t.alignDelimiters !== !1) {
        const k = i(w);
        g[b] = k, (a[b] === void 0 || k > a[b]) && (a[b] = k);
      }
      m.push(w);
    }
    o[u] = m, l[u] = g;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < c; )
      s[h] = yk(r[h]);
  else {
    const m = yk(r);
    for (; ++h < c; )
      s[h] = m;
  }
  h = -1;
  const f = [], d = [];
  for (; ++h < c; ) {
    const m = s[h];
    let g = "", b = "";
    m === 99 ? (g = ":", b = ":") : m === 108 ? g = ":" : m === 114 && (b = ":");
    let w = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      a[h] - g.length - b.length
    );
    const k = g + "-".repeat(w) + b;
    t.alignDelimiters !== !1 && (w = g.length + w + b.length, w > a[h] && (a[h] = w), d[h] = w), f[h] = k;
  }
  o.splice(1, 0, f), l.splice(1, 0, d), u = -1;
  const p = [];
  for (; ++u < o.length; ) {
    const m = o[u], g = l[u];
    h = -1;
    const b = [];
    for (; ++h < c; ) {
      const w = m[h] || "";
      let k = "", C = "";
      if (t.alignDelimiters !== !1) {
        const M = a[h] - (g[h] || 0), T = s[h];
        T === 114 ? k = " ".repeat(M) : T === 99 ? M % 2 ? (k = " ".repeat(M / 2 + 0.5), C = " ".repeat(M / 2 - 0.5)) : (k = " ".repeat(M / 2), C = k) : C = " ".repeat(M);
      }
      t.delimiterStart !== !1 && !h && b.push("|"), t.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && w === "") && (t.delimiterStart !== !1 || h) && b.push(" "), t.alignDelimiters !== !1 && b.push(k), b.push(w), t.alignDelimiters !== !1 && b.push(C), t.padding !== !1 && b.push(" "), (t.delimiterEnd !== !1 || h !== c - 1) && b.push("|");
    }
    p.push(
      t.delimiterEnd === !1 ? b.join("").replace(/ +$/, "") : b.join("")
    );
  }
  return p.join(`
`);
}
function Ree(n) {
  return n == null ? "" : String(n);
}
function yk(n) {
  const e = typeof n == "string" ? n.codePointAt(0) : 0;
  return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0;
}
function Pee() {
  return {
    enter: {
      table: _ee,
      tableData: bk,
      tableHeader: bk,
      tableRow: Bee
    },
    exit: {
      codeText: zee,
      table: Lee,
      tableData: U2,
      tableHeader: U2,
      tableRow: U2
    }
  };
}
function _ee(n) {
  const e = n._align;
  this.enter(
    {
      type: "table",
      align: e.map(function(t) {
        return t === "none" ? null : t;
      }),
      children: []
    },
    n
  ), this.data.inTable = !0;
}
function Lee(n) {
  this.exit(n), this.data.inTable = void 0;
}
function Bee(n) {
  this.enter({ type: "tableRow", children: [] }, n);
}
function U2(n) {
  this.exit(n);
}
function bk(n) {
  this.enter({ type: "tableCell", children: [] }, n);
}
function zee(n) {
  let e = this.resume();
  this.data.inTable && (e = e.replace(/\\([\\|])/g, Fee));
  const t = this.stack[this.stack.length - 1];
  t.type, t.value = e, this.exit(n);
}
function Fee(n, e) {
  return e === "|" ? e : n;
}
function Hee(n) {
  const e = n || {}, t = e.tableCellPadding, r = e.tablePipeAlign, i = e.stringLength, s = t ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: f,
      table: o,
      tableCell: a,
      tableRow: l
    }
  };
  function o(d, p, m, g) {
    return c(u(d, m, g), d.align);
  }
  function l(d, p, m, g) {
    const b = h(d, m, g), w = c([b]);
    return w.slice(0, w.indexOf(`
`));
  }
  function a(d, p, m, g) {
    const b = m.enter("tableCell"), w = m.enter("phrasing"), k = m.containerPhrasing(d, {
      ...g,
      before: s,
      after: s
    });
    return w(), b(), k;
  }
  function c(d, p) {
    return Nee(d, {
      align: p,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: t,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(d, p, m) {
    const g = d.children;
    let b = -1;
    const w = [], k = p.enter("table");
    for (; ++b < g.length; )
      w[b] = h(g[b], p, m);
    return k(), w;
  }
  function h(d, p, m) {
    const g = d.children;
    let b = -1;
    const w = [], k = p.enter("tableRow");
    for (; ++b < g.length; )
      w[b] = a(g[b], d, p, m);
    return k(), w;
  }
  function f(d, p, m) {
    let g = Q5.inlineCode(d, p, m);
    return m.stack.includes("tableCell") && (g = g.replace(/\|/g, "\\$&")), g;
  }
}
function $ee() {
  return {
    exit: {
      taskListCheckValueChecked: vk,
      taskListCheckValueUnchecked: vk,
      paragraph: qee
    }
  };
}
function Vee() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: Wee }
  };
}
function vk(n) {
  const e = this.stack[this.stack.length - 2];
  e.type, e.checked = n.type === "taskListCheckValueChecked";
}
function qee(n) {
  const e = this.stack[this.stack.length - 2];
  if (e && e.type === "listItem" && typeof e.checked == "boolean") {
    const t = this.stack[this.stack.length - 1];
    t.type;
    const r = t.children[0];
    if (r && r.type === "text") {
      const i = e.children;
      let s = -1, o;
      for (; ++s < i.length; ) {
        const l = i[s];
        if (l.type === "paragraph") {
          o = l;
          break;
        }
      }
      o === t && (r.value = r.value.slice(1), r.value.length === 0 ? t.children.shift() : t.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, t.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(n);
}
function Wee(n, e, t, r) {
  const i = n.children[0], s = typeof n.checked == "boolean" && i && i.type === "paragraph", o = "[" + (n.checked ? "x" : " ") + "] ", l = t.createTracker(r);
  s && l.move(o);
  let a = Q5.listItem(n, e, t, {
    ...r,
    ...l.current()
  });
  return s && (a = a.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), a;
  function c(u) {
    return u + o;
  }
}
function jee() {
  return [
    tee(),
    kee(),
    Tee(),
    Pee(),
    $ee()
  ];
}
function Uee(n) {
  return {
    extensions: [
      nee(),
      See(n),
      Aee(),
      Hee(n),
      Vee()
    ]
  };
}
const Kee = {
  tokenize: Qee,
  partial: !0
}, QE = {
  tokenize: ete,
  partial: !0
}, eI = {
  tokenize: tte,
  partial: !0
}, tI = {
  tokenize: nte,
  partial: !0
}, Gee = {
  tokenize: rte,
  partial: !0
}, nI = {
  name: "wwwAutolink",
  tokenize: Xee,
  previous: iI
}, rI = {
  name: "protocolAutolink",
  tokenize: Zee,
  previous: sI
}, Co = {
  name: "emailAutolink",
  tokenize: Jee,
  previous: oI
}, Os = {};
function Yee() {
  return {
    text: Os
  };
}
let Ll = 48;
for (; Ll < 123; )
  Os[Ll] = Co, Ll++, Ll === 58 ? Ll = 65 : Ll === 91 && (Ll = 97);
Os[43] = Co;
Os[45] = Co;
Os[46] = Co;
Os[95] = Co;
Os[72] = [Co, rI];
Os[104] = [Co, rI];
Os[87] = [Co, nI];
Os[119] = [Co, nI];
function Jee(n, e, t) {
  const r = this;
  let i, s;
  return o;
  function o(h) {
    return !v5(h) || !oI.call(r, r.previous) || kv(r.events) ? t(h) : (n.enter("literalAutolink"), n.enter("literalAutolinkEmail"), l(h));
  }
  function l(h) {
    return v5(h) ? (n.consume(h), l) : h === 64 ? (n.consume(h), a) : t(h);
  }
  function a(h) {
    return h === 46 ? n.check(Gee, u, c)(h) : h === 45 || h === 95 || Tr(h) ? (s = !0, n.consume(h), a) : u(h);
  }
  function c(h) {
    return n.consume(h), i = !0, a;
  }
  function u(h) {
    return s && i && lr(r.previous) ? (n.exit("literalAutolinkEmail"), n.exit("literalAutolink"), e(h)) : t(h);
  }
}
function Xee(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o !== 87 && o !== 119 || !iI.call(r, r.previous) || kv(r.events) ? t(o) : (n.enter("literalAutolink"), n.enter("literalAutolinkWww"), n.check(Kee, n.attempt(QE, n.attempt(eI, s), t), t)(o));
  }
  function s(o) {
    return n.exit("literalAutolinkWww"), n.exit("literalAutolink"), e(o);
  }
}
function Zee(n, e, t) {
  const r = this;
  let i = "", s = !1;
  return o;
  function o(h) {
    return (h === 72 || h === 104) && sI.call(r, r.previous) && !kv(r.events) ? (n.enter("literalAutolink"), n.enter("literalAutolinkHttp"), i += String.fromCodePoint(h), n.consume(h), l) : t(h);
  }
  function l(h) {
    if (lr(h) && i.length < 5)
      return i += String.fromCodePoint(h), n.consume(h), l;
    if (h === 58) {
      const f = i.toLowerCase();
      if (f === "http" || f === "https")
        return n.consume(h), a;
    }
    return t(h);
  }
  function a(h) {
    return h === 47 ? (n.consume(h), s ? c : (s = !0, a)) : t(h);
  }
  function c(h) {
    return h === null || Qp(h) || Nt(h) || ba(h) || Qm(h) ? t(h) : n.attempt(QE, n.attempt(eI, u), t)(h);
  }
  function u(h) {
    return n.exit("literalAutolinkHttp"), n.exit("literalAutolink"), e(h);
  }
}
function Qee(n, e, t) {
  let r = 0;
  return i;
  function i(o) {
    return (o === 87 || o === 119) && r < 3 ? (r++, n.consume(o), i) : o === 46 && r === 3 ? (n.consume(o), s) : t(o);
  }
  function s(o) {
    return o === null ? t(o) : e(o);
  }
}
function ete(n, e, t) {
  let r, i, s;
  return o;
  function o(c) {
    return c === 46 || c === 95 ? n.check(tI, a, l)(c) : c === null || Nt(c) || ba(c) || c !== 45 && Qm(c) ? a(c) : (s = !0, n.consume(c), o);
  }
  function l(c) {
    return c === 95 ? r = !0 : (i = r, r = void 0), n.consume(c), o;
  }
  function a(c) {
    return i || r || !s ? t(c) : e(c);
  }
}
function tte(n, e) {
  let t = 0, r = 0;
  return i;
  function i(o) {
    return o === 40 ? (t++, n.consume(o), i) : o === 41 && r < t ? s(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? n.check(tI, e, s)(o) : o === null || Nt(o) || ba(o) ? e(o) : (n.consume(o), i);
  }
  function s(o) {
    return o === 41 && r++, n.consume(o), i;
  }
}
function nte(n, e, t) {
  return r;
  function r(l) {
    return l === 33 || l === 34 || l === 39 || l === 41 || l === 42 || l === 44 || l === 46 || l === 58 || l === 59 || l === 63 || l === 95 || l === 126 ? (n.consume(l), r) : l === 38 ? (n.consume(l), s) : l === 93 ? (n.consume(l), i) : (
      // `<` is an end.
      l === 60 || // So is whitespace.
      l === null || Nt(l) || ba(l) ? e(l) : t(l)
    );
  }
  function i(l) {
    return l === null || l === 40 || l === 91 || Nt(l) || ba(l) ? e(l) : r(l);
  }
  function s(l) {
    return lr(l) ? o(l) : t(l);
  }
  function o(l) {
    return l === 59 ? (n.consume(l), r) : lr(l) ? (n.consume(l), o) : t(l);
  }
}
function rte(n, e, t) {
  return r;
  function r(s) {
    return n.consume(s), i;
  }
  function i(s) {
    return Tr(s) ? t(s) : e(s);
  }
}
function iI(n) {
  return n === null || n === 40 || n === 42 || n === 95 || n === 91 || n === 93 || n === 126 || Nt(n);
}
function sI(n) {
  return !lr(n);
}
function oI(n) {
  return !(n === 47 || v5(n));
}
function v5(n) {
  return n === 43 || n === 45 || n === 46 || n === 95 || Tr(n);
}
function kv(n) {
  let e = n.length, t = !1;
  for (; e--; ) {
    const r = n[e][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      t = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      t = !1;
      break;
    }
  }
  return n.length > 0 && !t && (n[n.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), t;
}
const ite = {
  tokenize: fte,
  partial: !0
};
function ste() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: cte,
        continuation: {
          tokenize: ute
        },
        exit: hte
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: ate
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: ote,
        resolveTo: lte
      }
    }
  };
}
function ote(n, e, t) {
  const r = this;
  let i = r.events.length;
  const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o;
  for (; i--; ) {
    const a = r.events[i][1];
    if (a.type === "labelImage") {
      o = a;
      break;
    }
    if (a.type === "gfmFootnoteCall" || a.type === "labelLink" || a.type === "label" || a.type === "image" || a.type === "link")
      break;
  }
  return l;
  function l(a) {
    if (!o || !o._balanced)
      return t(a);
    const c = Ni(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !s.includes(c.slice(1)) ? t(a) : (n.enter("gfmFootnoteCallLabelMarker"), n.consume(a), n.exit("gfmFootnoteCallLabelMarker"), e(a));
  }
}
function lte(n, e) {
  let t = n.length;
  for (; t--; )
    if (n[t][1].type === "labelImage" && n[t][0] === "enter") {
      n[t][1];
      break;
    }
  n[t + 1][1].type = "data", n[t + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, n[t + 3][1].start),
    end: Object.assign({}, n[n.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, n[t + 3][1].end),
    end: Object.assign({}, n[t + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, n[n.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, l = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    n[t + 1],
    n[t + 2],
    ["enter", r, e],
    // The `[`
    n[t + 3],
    n[t + 4],
    // The `^`.
    ["enter", i, e],
    ["exit", i, e],
    // Everything in between.
    ["enter", s, e],
    ["enter", o, e],
    ["exit", o, e],
    ["exit", s, e],
    // The ending (`]`, properly parsed and labelled).
    n[n.length - 2],
    n[n.length - 1],
    ["exit", r, e]
  ];
  return n.splice(t, n.length - t + 1, ...l), n;
}
function ate(n, e, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s = 0, o;
  return l;
  function l(h) {
    return n.enter("gfmFootnoteCall"), n.enter("gfmFootnoteCallLabelMarker"), n.consume(h), n.exit("gfmFootnoteCallLabelMarker"), a;
  }
  function a(h) {
    return h !== 94 ? t(h) : (n.enter("gfmFootnoteCallMarker"), n.consume(h), n.exit("gfmFootnoteCallMarker"), n.enter("gfmFootnoteCallString"), n.enter("chunkString").contentType = "string", c);
  }
  function c(h) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      h === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Nt(h)
    )
      return t(h);
    if (h === 93) {
      n.exit("chunkString");
      const f = n.exit("gfmFootnoteCallString");
      return i.includes(Ni(r.sliceSerialize(f))) ? (n.enter("gfmFootnoteCallLabelMarker"), n.consume(h), n.exit("gfmFootnoteCallLabelMarker"), n.exit("gfmFootnoteCall"), e) : t(h);
    }
    return Nt(h) || (o = !0), s++, n.consume(h), h === 92 ? u : c;
  }
  function u(h) {
    return h === 91 || h === 92 || h === 93 ? (n.consume(h), s++, c) : c(h);
  }
}
function cte(n, e, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s, o = 0, l;
  return a;
  function a(p) {
    return n.enter("gfmFootnoteDefinition")._container = !0, n.enter("gfmFootnoteDefinitionLabel"), n.enter("gfmFootnoteDefinitionLabelMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(p) {
    return p === 94 ? (n.enter("gfmFootnoteDefinitionMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionMarker"), n.enter("gfmFootnoteDefinitionLabelString"), n.enter("chunkString").contentType = "string", u) : t(p);
  }
  function u(p) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      p === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || Nt(p)
    )
      return t(p);
    if (p === 93) {
      n.exit("chunkString");
      const m = n.exit("gfmFootnoteDefinitionLabelString");
      return s = Ni(r.sliceSerialize(m)), n.enter("gfmFootnoteDefinitionLabelMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionLabelMarker"), n.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return Nt(p) || (l = !0), o++, n.consume(p), p === 92 ? h : u;
  }
  function h(p) {
    return p === 91 || p === 92 || p === 93 ? (n.consume(p), o++, u) : u(p);
  }
  function f(p) {
    return p === 58 ? (n.enter("definitionMarker"), n.consume(p), n.exit("definitionMarker"), i.includes(s) || i.push(s), it(n, d, "gfmFootnoteDefinitionWhitespace")) : t(p);
  }
  function d(p) {
    return e(p);
  }
}
function ute(n, e, t) {
  return n.check(sd, e, n.attempt(ite, e, t));
}
function hte(n) {
  n.exit("gfmFootnoteDefinition");
}
function fte(n, e, t) {
  const r = this;
  return it(n, i, "gfmFootnoteDefinitionIndent", 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? e(s) : t(s);
  }
}
function dte(n) {
  let t = (n || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: i
  };
  return t == null && (t = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, l) {
    let a = -1;
    for (; ++a < o.length; )
      if (o[a][0] === "enter" && o[a][1].type === "strikethroughSequenceTemporary" && o[a][1]._close) {
        let c = a;
        for (; c--; )
          if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && // If the sizes are the same:
          o[a][1].end.offset - o[a][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
            o[a][1].type = "strikethroughSequence", o[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, o[c][1].start),
              end: Object.assign({}, o[a][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, o[c][1].end),
              end: Object.assign({}, o[a][1].start)
            }, f = [["enter", u, l], ["enter", o[c][1], l], ["exit", o[c][1], l], ["enter", h, l]], d = l.parser.constructs.insideSpan.null;
            d && Xr(f, f.length, 0, e1(d, o.slice(c + 1, a), l)), Xr(f, f.length, 0, [["exit", h, l], ["enter", o[a][1], l], ["exit", o[a][1], l], ["exit", u, l]]), Xr(o, c - 1, a - c + 3, f), a = c + f.length - 2;
            break;
          }
      }
    for (a = -1; ++a < o.length; )
      o[a][1].type === "strikethroughSequenceTemporary" && (o[a][1].type = "data");
    return o;
  }
  function s(o, l, a) {
    const c = this.previous, u = this.events;
    let h = 0;
    return f;
    function f(p) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? a(p) : (o.enter("strikethroughSequenceTemporary"), d(p));
    }
    function d(p) {
      const m = Ic(c);
      if (p === 126)
        return h > 1 ? a(p) : (o.consume(p), h++, d);
      if (h < 2 && !t) return a(p);
      const g = o.exit("strikethroughSequenceTemporary"), b = Ic(p);
      return g._open = !b || b === 2 && !!m, g._close = !m || m === 2 && !!b, l(p);
    }
  }
}
class pte {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(e, t, r) {
    mte(this, e, t, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(e) {
    if (this.map.sort(function(s, o) {
      return s[0] - o[0];
    }), this.map.length === 0)
      return;
    let t = this.map.length;
    const r = [];
    for (; t > 0; )
      t -= 1, r.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), e.length = this.map[t][0];
    r.push(e.slice()), e.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const s of i)
        e.push(s);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function mte(n, e, t, r) {
  let i = 0;
  if (!(t === 0 && r.length === 0)) {
    for (; i < n.map.length; ) {
      if (n.map[i][0] === e) {
        n.map[i][1] += t, n.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    n.map.push([e, t, r]);
  }
}
function gte(n, e) {
  let t = !1;
  const r = [];
  for (; e < n.length; ) {
    const i = n[e];
    if (t) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(n[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (n[e - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (t = !0);
    e += 1;
  }
  return r;
}
function yte() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: bte,
        resolveAll: vte
      }
    }
  };
}
function bte(n, e, t) {
  const r = this;
  let i = 0, s = 0, o;
  return l;
  function l(R) {
    let V = r.events.length - 1;
    for (; V > -1; ) {
      const ie = r.events[V][1].type;
      if (ie === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      ie === "linePrefix") V--;
      else break;
    }
    const z = V > -1 ? r.events[V][1].type : null, ue = z === "tableHead" || z === "tableRow" ? T : a;
    return ue === T && r.parser.lazy[r.now().line] ? t(R) : ue(R);
  }
  function a(R) {
    return n.enter("tableHead"), n.enter("tableRow"), c(R);
  }
  function c(R) {
    return R === 124 || (o = !0, s += 1), u(R);
  }
  function u(R) {
    return R === null ? t(R) : Ne(R) ? s > 1 ? (s = 0, r.interrupt = !0, n.exit("tableRow"), n.enter("lineEnding"), n.consume(R), n.exit("lineEnding"), d) : t(R) : lt(R) ? it(n, u, "whitespace")(R) : (s += 1, o && (o = !1, i += 1), R === 124 ? (n.enter("tableCellDivider"), n.consume(R), n.exit("tableCellDivider"), o = !0, u) : (n.enter("data"), h(R)));
  }
  function h(R) {
    return R === null || R === 124 || Nt(R) ? (n.exit("data"), u(R)) : (n.consume(R), R === 92 ? f : h);
  }
  function f(R) {
    return R === 92 || R === 124 ? (n.consume(R), h) : h(R);
  }
  function d(R) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? t(R) : (n.enter("tableDelimiterRow"), o = !1, lt(R) ? it(n, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(R) : p(R));
  }
  function p(R) {
    return R === 45 || R === 58 ? g(R) : R === 124 ? (o = !0, n.enter("tableCellDivider"), n.consume(R), n.exit("tableCellDivider"), m) : M(R);
  }
  function m(R) {
    return lt(R) ? it(n, g, "whitespace")(R) : g(R);
  }
  function g(R) {
    return R === 58 ? (s += 1, o = !0, n.enter("tableDelimiterMarker"), n.consume(R), n.exit("tableDelimiterMarker"), b) : R === 45 ? (s += 1, b(R)) : R === null || Ne(R) ? C(R) : M(R);
  }
  function b(R) {
    return R === 45 ? (n.enter("tableDelimiterFiller"), w(R)) : M(R);
  }
  function w(R) {
    return R === 45 ? (n.consume(R), w) : R === 58 ? (o = !0, n.exit("tableDelimiterFiller"), n.enter("tableDelimiterMarker"), n.consume(R), n.exit("tableDelimiterMarker"), k) : (n.exit("tableDelimiterFiller"), k(R));
  }
  function k(R) {
    return lt(R) ? it(n, C, "whitespace")(R) : C(R);
  }
  function C(R) {
    return R === 124 ? p(R) : R === null || Ne(R) ? !o || i !== s ? M(R) : (n.exit("tableDelimiterRow"), n.exit("tableHead"), e(R)) : M(R);
  }
  function M(R) {
    return t(R);
  }
  function T(R) {
    return n.enter("tableRow"), N(R);
  }
  function N(R) {
    return R === 124 ? (n.enter("tableCellDivider"), n.consume(R), n.exit("tableCellDivider"), N) : R === null || Ne(R) ? (n.exit("tableRow"), e(R)) : lt(R) ? it(n, N, "whitespace")(R) : (n.enter("data"), B(R));
  }
  function B(R) {
    return R === null || R === 124 || Nt(R) ? (n.exit("data"), N(R)) : (n.consume(R), R === 92 ? $ : B);
  }
  function $(R) {
    return R === 92 || R === 124 ? (n.consume(R), B) : B(R);
  }
}
function vte(n, e) {
  let t = -1, r = !0, i = 0, s = [0, 0, 0, 0], o = [0, 0, 0, 0], l = !1, a = 0, c, u, h;
  const f = new pte();
  for (; ++t < n.length; ) {
    const d = n[t], p = d[1];
    d[0] === "enter" ? p.type === "tableHead" ? (l = !1, a !== 0 && (wk(f, e, a, c, u), u = void 0, a = 0), c = {
      type: "table",
      start: Object.assign({}, p.start),
      // Note: correct end is set later.
      end: Object.assign({}, p.end)
    }, f.add(t, 0, [["enter", c, e]])) : p.type === "tableRow" || p.type === "tableDelimiterRow" ? (r = !0, h = void 0, s = [0, 0, 0, 0], o = [0, t + 1, 0, 0], l && (l = !1, u = {
      type: "tableBody",
      start: Object.assign({}, p.start),
      // Note: correct end is set later.
      end: Object.assign({}, p.end)
    }, f.add(t, 0, [["enter", u, e]])), i = p.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (s[1] !== 0 && (o[0] = o[1], h = k0(f, e, s, i, void 0, h), s = [0, 0, 0, 0]), o[2] = t)) : p.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (o[0] = o[1], h = k0(f, e, s, i, void 0, h)), s = o, o = [s[1], t, 0, 0])) : p.type === "tableHead" ? (l = !0, a = t) : p.type === "tableRow" || p.type === "tableDelimiterRow" ? (a = t, s[1] !== 0 ? (o[0] = o[1], h = k0(f, e, s, i, t, h)) : o[1] !== 0 && (h = k0(f, e, o, i, t, h)), i = 0) : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") && (o[3] = t);
  }
  for (a !== 0 && wk(f, e, a, c, u), f.consume(e.events), t = -1; ++t < e.events.length; ) {
    const d = e.events[t];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = gte(e.events, t));
  }
  return n;
}
function k0(n, e, t, r, i, s) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", l = "tableContent";
  t[0] !== 0 && (s.end = Object.assign({}, ic(e.events, t[0])), n.add(t[0], 0, [["exit", s, e]]));
  const a = ic(e.events, t[1]);
  if (s = {
    type: o,
    start: Object.assign({}, a),
    // Note: correct end is set later.
    end: Object.assign({}, a)
  }, n.add(t[1], 0, [["enter", s, e]]), t[2] !== 0) {
    const c = ic(e.events, t[2]), u = ic(e.events, t[3]), h = {
      type: l,
      start: Object.assign({}, c),
      end: Object.assign({}, u)
    };
    if (n.add(t[2], 0, [["enter", h, e]]), r !== 2) {
      const f = e.events[t[2]], d = e.events[t[3]];
      if (f[1].end = Object.assign({}, d[1].end), f[1].type = "chunkText", f[1].contentType = "text", t[3] > t[2] + 1) {
        const p = t[2] + 1, m = t[3] - t[2] - 1;
        n.add(p, m, []);
      }
    }
    n.add(t[3] + 1, 0, [["exit", h, e]]);
  }
  return i !== void 0 && (s.end = Object.assign({}, ic(e.events, i)), n.add(i, 0, [["exit", s, e]]), s = void 0), s;
}
function wk(n, e, t, r, i) {
  const s = [], o = ic(e.events, t);
  i && (i.end = Object.assign({}, o), s.push(["exit", i, e])), r.end = Object.assign({}, o), s.push(["exit", r, e]), n.add(t + 1, 0, s);
}
function ic(n, e) {
  const t = n[e], r = t[0] === "enter" ? "start" : "end";
  return t[1][r];
}
const wte = {
  name: "tasklistCheck",
  tokenize: kte
};
function xte() {
  return {
    text: {
      91: wte
    }
  };
}
function kte(n, e, t) {
  const r = this;
  return i;
  function i(a) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? t(a) : (n.enter("taskListCheck"), n.enter("taskListCheckMarker"), n.consume(a), n.exit("taskListCheckMarker"), s)
    );
  }
  function s(a) {
    return Nt(a) ? (n.enter("taskListCheckValueUnchecked"), n.consume(a), n.exit("taskListCheckValueUnchecked"), o) : a === 88 || a === 120 ? (n.enter("taskListCheckValueChecked"), n.consume(a), n.exit("taskListCheckValueChecked"), o) : t(a);
  }
  function o(a) {
    return a === 93 ? (n.enter("taskListCheckMarker"), n.consume(a), n.exit("taskListCheckMarker"), n.exit("taskListCheck"), l) : t(a);
  }
  function l(a) {
    return Ne(a) ? e(a) : lt(a) ? n.check({
      tokenize: Ste
    }, e, t)(a) : t(a);
  }
}
function Ste(n, e, t) {
  return it(n, r, "whitespace");
  function r(i) {
    return i === null ? t(i) : e(i);
  }
}
function Cte(n) {
  return MS([
    Yee(),
    ste(),
    dte(n),
    yte(),
    xte()
  ]);
}
const Mte = {};
function Tte(n) {
  const e = (
    /** @type {Processor<Root>} */
    this
  ), t = n || Mte, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(Cte(t)), s.push(jee()), o.push(Uee(t));
}
function Je(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/preset-gfm",
      ...e
    }
  }), n;
}
const Sv = bd("strike_through");
Je(Sv, {
  displayName: "Attr<strikethrough>",
  group: "Strikethrough"
});
const uu = ru("strike_through", (n) => ({
  parseDOM: [
    { tag: "del" },
    {
      style: "text-decoration",
      getAttrs: (e) => e === "line-through"
    }
  ],
  toDOM: (e) => ["del", n.get(Sv.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "delete",
    runner: (e, t, r) => {
      e.openMark(r), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strike_through",
    runner: (e, t) => {
      e.withMark(t, "delete");
    }
  }
}));
Je(uu.mark, {
  displayName: "MarkSchema<strikethrough>",
  group: "Strikethrough"
});
Je(uu.ctx, {
  displayName: "MarkSchemaCtx<strikethrough>",
  group: "Strikethrough"
});
const X1 = Ye(
  "ToggleStrikeThrough",
  (n) => () => l1(uu.type(n))
);
Je(X1, {
  displayName: "Command<ToggleStrikethrough>",
  group: "Strikethrough"
});
const lI = Qn((n) => ld(
  new RegExp("(?<![\\w:/])(~{1,2})(.+?)\\1(?!\\w|\\/)"),
  uu.type(n)
));
Je(lI, {
  displayName: "InputRule<strikethrough>",
  group: "Strikethrough"
});
const Cv = Pr("strikeThroughKeymap", {
  ToggleStrikethrough: {
    shortcuts: "Mod-Alt-x",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(X1.key);
    }
  }
});
Je(Cv.ctx, {
  displayName: "KeymapCtx<strikethrough>",
  group: "Strikethrough"
});
Je(Cv.shortcuts, {
  displayName: "Keymap<strikethrough>",
  group: "Strikethrough"
});
const Od = ZZ({
  tableGroup: "block",
  cellContent: "paragraph",
  cellAttributes: {
    alignment: {
      default: "left",
      getFromDOM: (n) => n.style.textAlign || "left",
      setDOMAttr: (n, e) => {
        e.style = `text-align: ${n || "left"}`;
      }
    }
  }
}), Ha = hn("table", () => ({
  ...Od.table,
  content: "table_header_row table_row+",
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "table",
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r,
        isHeader: o === 0
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table",
    runner: (n, e) => {
      const t = e.content.firstChild?.content;
      if (!t) return;
      const r = [];
      t.forEach((i) => {
        r.push(i.attrs.alignment);
      }), n.openNode("table", void 0, { align: r }), n.next(e.content), n.closeNode();
    }
  }
}));
Je(Ha.node, {
  displayName: "NodeSchema<table>",
  group: "Table"
});
Je(Ha.ctx, {
  displayName: "NodeSchemaCtx<table>",
  group: "Table"
});
const Z1 = hn("table_header_row", () => ({
  ...Od.table_row,
  disableDropCursor: !0,
  content: "(table_header)*",
  parseDOM: [{ tag: "tr[data-is-header]" }],
  toDOM() {
    return ["tr", { "data-is-header": !0 }, 0];
  },
  parseMarkdown: {
    match: (n) => !!(n.type === "tableRow" && n.isHeader),
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r[o],
        isHeader: e.isHeader
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_header_row",
    runner: (n, e) => {
      n.openNode("tableRow", void 0, { isHeader: !0 }), n.next(e.content), n.closeNode();
    }
  }
}));
Je(Z1.node, {
  displayName: "NodeSchema<tableHeaderRow>",
  group: "Table"
});
Je(Z1.ctx, {
  displayName: "NodeSchemaCtx<tableHeaderRow>",
  group: "Table"
});
const Ed = hn("table_row", () => ({
  ...Od.table_row,
  disableDropCursor: !0,
  content: "(table_cell)*",
  parseMarkdown: {
    match: (n) => n.type === "tableRow",
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r[o]
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_row",
    runner: (n, e) => {
      e.content.size !== 0 && (n.openNode("tableRow"), n.next(e.content), n.closeNode());
    }
  }
}));
Je(Ed.node, {
  displayName: "NodeSchema<tableRow>",
  group: "Table"
});
Je(Ed.ctx, {
  displayName: "NodeSchemaCtx<tableRow>",
  group: "Table"
});
const Id = hn("table_cell", () => ({
  ...Od.table_cell,
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "tableCell" && !n.isHeader,
    runner: (n, e, t) => {
      const r = e.align;
      n.openNode(t, { alignment: r }).openNode(n.schema.nodes.paragraph).next(e.children).closeNode().closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_cell",
    runner: (n, e) => {
      n.openNode("tableCell").next(e.content).closeNode();
    }
  }
}));
Je(Id.node, {
  displayName: "NodeSchema<tableCell>",
  group: "Table"
});
Je(Id.ctx, {
  displayName: "NodeSchemaCtx<tableCell>",
  group: "Table"
});
const Q1 = hn("table_header", () => ({
  ...Od.table_header,
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "tableCell" && !!n.isHeader,
    runner: (n, e, t) => {
      const r = e.align;
      n.openNode(t, { alignment: r }), n.openNode(n.schema.nodes.paragraph), n.next(e.children), n.closeNode(), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_header",
    runner: (n, e) => {
      n.openNode("tableCell"), n.next(e.content), n.closeNode();
    }
  }
}));
Je(Q1.node, {
  displayName: "NodeSchema<tableHeader>",
  group: "Table"
});
Je(Q1.ctx, {
  displayName: "NodeSchemaCtx<tableHeader>",
  group: "Table"
});
function Mv(n, e = 3, t = 3) {
  const r = Array(t).fill(0).map(() => Id.type(n).createAndFill()), i = Array(t).fill(0).map(() => Q1.type(n).createAndFill()), s = Array(e).fill(0).map(
    (o, l) => l === 0 ? Z1.type(n).create(null, i) : Ed.type(n).create(null, r)
  );
  return Ha.type(n).create(null, s);
}
function hu(n) {
  return d3(
    (e) => e.type.spec.tableRole === "table"
  )(n);
}
function sc(n, e) {
  const t = hu(e.$from);
  if (!t) return;
  const r = wt.get(t.node);
  return (Array.isArray(n) ? n : [n]).filter((s) => s >= 0 && s <= r.width - 1).flatMap((s) => r.cellsInRect({
    left: s,
    right: s + 1,
    top: 0,
    bottom: r.height
  }).map((l) => {
    const a = t.node.nodeAt(l), c = l + t.start;
    return { pos: c, start: c + 1, node: a, depth: t.depth + 2 };
  }));
}
function oc(n, e) {
  const t = hu(e.$from);
  if (!t)
    return;
  const r = wt.get(t.node);
  return (Array.isArray(n) ? n : [n]).filter((s) => s >= 0 && s <= r.height - 1).flatMap((s) => r.cellsInRect({
    left: 0,
    right: r.width,
    top: s,
    bottom: s + 1
  }).map((l) => {
    const a = t.node.nodeAt(l), c = l + t.start;
    return { pos: c, start: c + 1, node: a, depth: t.depth + 2 };
  }));
}
function aI(n) {
  return (e, t) => (r) => {
    t = t ?? r.selection.from;
    const i = r.doc.resolve(t), s = d3(
      (a) => a.type.name === "table"
    )(i), o = s ? {
      node: s.node,
      from: s.start
    } : void 0, l = n === "row";
    if (o) {
      const a = wt.get(o.node);
      if (e >= 0 && e < (l ? a.height : a.width)) {
        const c = a.positionAt(
          l ? e : a.height - 1,
          l ? a.width - 1 : e,
          o.node
        ), u = r.doc.resolve(o.from + c), h = l ? Rt.rowSelection : Rt.colSelection, f = a.positionAt(
          l ? e : 0,
          l ? 0 : e,
          o.node
        ), d = r.doc.resolve(o.from + f);
        return RC(
          r.setSelection(
            h(u, d)
          )
        );
      }
    }
    return r;
  };
}
const Ate = aI("row"), Ote = aI("col");
function cI(n, e, { map: t, tableStart: r, table: i }, s) {
  const o = Array(s).fill(0).reduce((a, c, u) => a + i.child(u).nodeSize, r), l = Array(t.width).fill(0).map((a, c) => {
    const u = i.nodeAt(t.map[c]);
    return Id.type(n).createAndFill({ alignment: u?.attrs.alignment });
  });
  return e.insert(o, Ed.type(n).create(null, l)), e;
}
function uI(n, e) {
  const t = [], r = wt.get(n);
  for (let s = 0; s < r.height; s++) {
    const o = n.child(s), l = [];
    for (let a = 0; a < r.width; a++) {
      if (!e[s][a]) continue;
      const c = r.map[s * r.width + a], u = e[s][a], f = n.nodeAt(c).type.createChecked(
        Object.assign({}, u.attrs),
        u.content,
        u.marks
      );
      l.push(f);
    }
    t.push(o.type.createChecked(o.attrs, l, o.marks));
  }
  return n.type.createChecked(
    n.attrs,
    t,
    n.marks
  );
}
function hI(n) {
  const e = wt.get(n), t = [], r = e.height, i = e.width;
  for (let s = 0; s < r; s++) {
    const o = [];
    for (let l = 0; l < i; l++) {
      let a = s * i + l, c = e.map[a];
      if (s > 0) {
        const u = a - i, h = e.map[u];
        if (c === h) {
          o.push(null);
          continue;
        }
      }
      if (l > 0) {
        const u = a - 1, h = e.map[u];
        if (c === h) {
          o.push(null);
          continue;
        }
      }
      c ? o.push(n.nodeAt(c)) : o.push(null);
    }
    t.push(o);
  }
  return t;
}
function xk(n, e, t = e) {
  let r = e, i = t;
  for (let h = e; h >= 0; h--) {
    const f = oc(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.rowspan + h - 1;
      p >= r && (r = h), p > i && (i = p);
    });
  }
  for (let h = e; h <= i; h++) {
    const f = oc(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.rowspan + h - 1;
      d.node.attrs.rowspan > 1 && p > i && (i = p);
    });
  }
  const s = [];
  for (let h = r; h <= i; h++) {
    const f = oc(h, n.selection);
    f && f.length > 0 && s.push(h);
  }
  r = s[0], i = s[s.length - 1];
  const o = oc(r, n.selection), l = sc(0, n.selection);
  if (!o || !l)
    return;
  const a = n.doc.resolve(
    o[o.length - 1].pos
  );
  let c;
  for (let h = i; h >= r; h--) {
    const f = oc(h, n.selection);
    if (f && f.length > 0) {
      for (let d = l.length - 1; d >= 0; d--)
        if (l[d].pos === f[0].pos) {
          c = f[0];
          break;
        }
      if (c)
        break;
    }
  }
  if (!c)
    return;
  const u = n.doc.resolve(c.pos);
  return { $anchor: a, $head: u, indexes: s };
}
function fI(n, e, t, r) {
  const i = e[0] > t[0] ? -1 : 1, s = n.splice(e[0], e.length), o = s.length % 2 === 0 ? 1 : 0;
  let l;
  return l = i === -1 ? t[0] : t[t.length - 1] - o, n.splice(l, 0, ...s), n;
}
function Ete(n) {
  const { tr: e, origin: t, target: r, pos: i } = n, s = e.doc.resolve(i), o = hu(s);
  if (!o) return !1;
  const l = xk(e, t)?.indexes, a = xk(e, r)?.indexes;
  if (!l || !a || l.includes(r)) return !1;
  const c = Ite(
    o.node,
    l,
    a
  );
  e.replaceWith(o.pos, o.pos + o.node.nodeSize, c);
  const u = wt.get(c), h = o.start, f = r, d = u.positionAt(f, u.width - 1, c), p = e.doc.resolve(h + d), m = u.positionAt(f, 0, c), g = e.doc.resolve(h + m);
  return e.setSelection(Rt.rowSelection(p, g)), !0;
}
function Ite(n, e, t, r) {
  let i = hI(n);
  return i = fI(i, e, t), uI(n, i);
}
function kk(n, e, t = e) {
  let r = e, i = t;
  for (let h = e; h >= 0; h--) {
    const f = sc(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.colspan + h - 1;
      p >= r && (r = h), p > i && (i = p);
    });
  }
  for (let h = e; h <= i; h++) {
    const f = sc(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.colspan + h - 1;
      d.node.attrs.colspan > 1 && p > i && (i = p);
    });
  }
  const s = [];
  for (let h = r; h <= i; h++) {
    const f = sc(h, n.selection);
    f && f.length > 0 && s.push(h);
  }
  r = s[0], i = s[s.length - 1];
  const o = sc(r, n.selection), l = oc(0, n.selection);
  if (!o || !l)
    return;
  const a = n.doc.resolve(
    o[o.length - 1].pos
  );
  let c;
  for (let h = i; h >= r; h--) {
    const f = sc(h, n.selection);
    if (f && f.length > 0) {
      for (let d = l.length - 1; d >= 0; d--)
        if (l[d].pos === f[0].pos) {
          c = f[0];
          break;
        }
      if (c)
        break;
    }
  }
  if (!c)
    return;
  const u = n.doc.resolve(c.pos);
  return { $anchor: a, $head: u, indexes: s };
}
function Sk(n) {
  return n[0].map((e, t) => n.map((r) => r[t]));
}
function Dte(n) {
  const { tr: e, origin: t, target: r, pos: i } = n, s = e.doc.resolve(i), o = hu(s);
  if (!o) return !1;
  const l = kk(e, t)?.indexes, a = kk(e, r)?.indexes;
  if (!l || !a || l.includes(r)) return !1;
  const c = Nte(
    o.node,
    l,
    a
  );
  e.replaceWith(o.pos, o.pos + o.node.nodeSize, c);
  const u = wt.get(c), h = o.start, f = r, d = u.positionAt(u.height - 1, f, c), p = e.doc.resolve(h + d), m = u.positionAt(0, f, c), g = e.doc.resolve(h + m);
  return e.setSelection(Rt.colSelection(p, g)), !0;
}
function Nte(n, e, t, r) {
  let i = Sk(hI(n));
  return i = fI(i, e, t), i = Sk(i), uI(n, i);
}
function Rte(n) {
  const e = hu(n.$from);
  if (!e) return;
  const t = wt.get(e.node);
  return t.cellsInRect({
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  }).map((i) => {
    const s = e.node.nodeAt(i), o = i + e.start;
    return { pos: o, start: o + 1, node: s };
  });
}
function Pte(n) {
  const e = Rte(n.selection);
  if (e && e[0]) {
    const t = n.doc.resolve(e[0].pos), r = e[e.length - 1];
    if (r) {
      const i = n.doc.resolve(r.pos);
      return RC(n.setSelection(new Rt(i, t)));
    }
  }
  return n;
}
const Tv = Ye(
  "GoToPrevTableCell",
  () => () => jE(-1)
);
Je(Tv, {
  displayName: "Command<goToPrevTableCellCommand>",
  group: "Table"
});
const Av = Ye(
  "GoToNextTableCell",
  () => () => jE(1)
);
Je(Av, {
  displayName: "Command<goToNextTableCellCommand>",
  group: "Table"
});
const Ov = Ye(
  "ExitTable",
  (n) => () => (e, t) => {
    if (!Ci(e)) return !1;
    const { $head: r } = e.selection, i = Xz(r, Ha.type(n));
    if (!i) return !1;
    const { to: s } = i, o = e.tr.replaceWith(
      s,
      s,
      As.type(n).createAndFill()
    );
    return o.setSelection(Ge.near(o.doc.resolve(s), 1)).scrollIntoView(), t?.(o), !0;
  }
);
Je(Ov, {
  displayName: "Command<breakTableCommand>",
  group: "Table"
});
const dI = Ye(
  "InsertTable",
  (n) => ({ row: e, col: t } = {}) => (r, i) => {
    const { selection: s, tr: o } = r, { from: l } = s, a = Mv(n, e, t), c = o.replaceSelectionWith(a), u = Ge.findFrom(c.doc.resolve(l), 1, !0);
    return u && c.setSelection(u), i?.(c), !0;
  }
);
Je(dI, {
  displayName: "Command<insertTableCommand>",
  group: "Table"
});
const Ev = Ye(
  "MoveRow",
  () => ({ from: n, to: e, pos: t } = {}) => (r, i) => {
    const { tr: s } = r;
    return Ete({
      tr: s,
      origin: n ?? 0,
      target: e ?? 0,
      pos: t ?? r.selection.from
    }) ? (i?.(s), !0) : !1;
  }
);
Je(Ev, {
  displayName: "Command<moveRowCommand>",
  group: "Table"
});
const Iv = Ye(
  "MoveCol",
  () => ({ from: n, to: e, pos: t } = {}) => (r, i) => {
    const { tr: s } = r;
    return Dte({
      tr: s,
      origin: n ?? 0,
      target: e ?? 0,
      pos: t ?? r.selection.from
    }) ? (i?.(s), !0) : !1;
  }
);
Je(Iv, {
  displayName: "Command<moveColCommand>",
  group: "Table"
});
const na = Ye(
  "SelectRow",
  () => (n = { index: 0 }) => (e, t) => {
    const { tr: r } = e;
    return !!t?.(Ate(n.index, n.pos)(r));
  }
);
Je(na, {
  displayName: "Command<selectRowCommand>",
  group: "Table"
});
const ra = Ye(
  "SelectCol",
  () => (n = { index: 0 }) => (e, t) => {
    const { tr: r } = e;
    return !!t?.(Ote(n.index, n.pos)(r));
  }
);
Je(ra, {
  displayName: "Command<selectColCommand>",
  group: "Table"
});
const pI = Ye(
  "SelectTable",
  () => () => (n, e) => {
    const { tr: t } = n;
    return !!e?.(Pte(t));
  }
);
Je(pI, {
  displayName: "Command<selectTableCommand>",
  group: "Table"
});
const Dv = Ye(
  "DeleteSelectedCells",
  () => () => (n, e) => {
    const { selection: t } = n;
    if (!(t instanceof Rt)) return !1;
    const r = t.isRowSelection(), i = t.isColSelection();
    return r && i ? wQ(n, e) : i ? pQ(n, e) : gQ(n, e);
  }
);
Je(Dv, {
  displayName: "Command<deleteSelectedCellsCommand>",
  group: "Table"
});
const Nv = Ye(
  "AddColBefore",
  () => () => hQ
);
Je(Nv, {
  displayName: "Command<addColBeforeCommand>",
  group: "Table"
});
const Rv = Ye(
  "AddColAfter",
  () => () => fQ
);
Je(Rv, {
  displayName: "Command<addColAfterCommand>",
  group: "Table"
});
const Pv = Ye(
  "AddRowBefore",
  (n) => () => (e, t) => {
    if (!Ci(e)) return !1;
    if (t) {
      const r = Al(e);
      t(cI(n, e.tr, r, r.top));
    }
    return !0;
  }
);
Je(Pv, {
  displayName: "Command<addRowBeforeCommand>",
  group: "Table"
});
const _v = Ye(
  "AddRowAfter",
  (n) => () => (e, t) => {
    if (!Ci(e)) return !1;
    if (t) {
      const r = Al(e);
      t(cI(n, e.tr, r, r.bottom));
    }
    return !0;
  }
);
Je(_v, {
  displayName: "Command<addRowAfterCommand>",
  group: "Table"
});
const Lv = Ye(
  "SetAlign",
  () => (n = "left") => yQ("alignment", n)
);
Je(Lv, {
  displayName: "Command<setAlignCommand>",
  group: "Table"
});
const mI = Qn(
  (n) => new Rr(
    /^\|(?<col>\d+)[xX](?<row>\d+)\|\s$/,
    (e, t, r, i) => {
      const s = e.doc.resolve(r);
      if (!s.node(-1).canReplaceWith(
        s.index(-1),
        s.indexAfter(-1),
        Ha.type(n)
      ))
        return null;
      const o = Math.max(Number(t.groups?.row ?? 0), 2), l = Mv(n, o, Number(t.groups?.col)), a = e.tr.replaceRangeWith(r, i, l);
      return a.setSelection(Ee.create(a.doc, r + 3)).scrollIntoView();
    }
  )
);
Je(mI, {
  displayName: "InputRule<insertTableInputRule>",
  group: "Table"
});
const Bv = Pr("tableKeymap", {
  NextCell: {
    priority: 100,
    shortcuts: ["Mod-]", "Tab"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Av.key);
    }
  },
  PrevCell: {
    shortcuts: ["Mod-[", "Shift-Tab"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Tv.key);
    }
  },
  ExitTable: {
    shortcuts: ["Mod-Enter", "Enter"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ov.key);
    }
  }
});
Je(Bv.ctx, {
  displayName: "KeymapCtx<table>",
  group: "Table"
});
Je(Bv.shortcuts, {
  displayName: "Keymap<table>",
  group: "Table"
});
const K2 = "footnote_definition", Ck = "footnoteDefinition", zv = hn(
  "footnote_definition",
  () => ({
    group: "block",
    content: "block+",
    defining: !0,
    attrs: {
      label: {
        default: "",
        validate: "string"
      }
    },
    parseDOM: [
      {
        tag: `dl[data-type="${K2}"]`,
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement)) throw Vi(n);
          return {
            label: n.dataset.label
          };
        },
        contentElement: "dd"
      }
    ],
    toDOM: (n) => {
      const e = n.attrs.label;
      return [
        "dl",
        {
          // TODO: add a prosemirror plugin to sync label on change
          "data-label": e,
          "data-type": K2
        },
        ["dt", e],
        ["dd", 0]
      ];
    },
    parseMarkdown: {
      match: ({ type: n }) => n === Ck,
      runner: (n, e, t) => {
        n.openNode(t, {
          label: e.label
        }).next(e.children).closeNode();
      }
    },
    toMarkdown: {
      match: (n) => n.type.name === K2,
      runner: (n, e) => {
        n.openNode(Ck, void 0, {
          label: e.attrs.label,
          identifier: e.attrs.label
        }).next(e.content).closeNode();
      }
    }
  })
);
Je(zv.ctx, {
  displayName: "NodeSchemaCtx<footnodeDef>",
  group: "footnote"
});
Je(zv.node, {
  displayName: "NodeSchema<footnodeDef>",
  group: "footnote"
});
const G2 = "footnote_reference", Fv = hn(
  "footnote_reference",
  () => ({
    group: "inline",
    inline: !0,
    atom: !0,
    attrs: {
      label: {
        default: "",
        validate: "string"
      }
    },
    parseDOM: [
      {
        tag: `sup[data-type="${G2}"]`,
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement)) throw Vi(n);
          return {
            label: n.dataset.label
          };
        }
      }
    ],
    toDOM: (n) => {
      const e = n.attrs.label;
      return [
        "sup",
        {
          // TODO: add a prosemirror plugin to sync label on change
          "data-label": e,
          "data-type": G2
        },
        e
      ];
    },
    parseMarkdown: {
      match: ({ type: n }) => n === "footnoteReference",
      runner: (n, e, t) => {
        n.addNode(t, {
          label: e.label
        });
      }
    },
    toMarkdown: {
      match: (n) => n.type.name === G2,
      runner: (n, e) => {
        n.addNode("footnoteReference", void 0, void 0, {
          label: e.attrs.label,
          identifier: e.attrs.label
        });
      }
    }
  })
);
Je(Fv.ctx, {
  displayName: "NodeSchemaCtx<footnodeRef>",
  group: "footnote"
});
Je(Fv.node, {
  displayName: "NodeSchema<footnodeRef>",
  group: "footnote"
});
const Hv = Wi.extendSchema(
  (n) => (e) => {
    const t = n(e);
    return {
      ...t,
      attrs: {
        ...t.attrs,
        checked: {
          default: null,
          validate: "boolean|null"
        }
      },
      parseDOM: [
        {
          tag: 'li[data-item-type="task"]',
          getAttrs: (r) => {
            if (!(r instanceof HTMLElement)) throw Vi(r);
            return {
              label: r.dataset.label,
              listType: r.dataset.listType,
              spread: r.dataset.spread,
              checked: r.dataset.checked ? r.dataset.checked === "true" : null
            };
          }
        },
        ...t?.parseDOM || []
      ],
      toDOM: (r) => t.toDOM && r.attrs.checked == null ? t.toDOM(r) : [
        "li",
        {
          "data-item-type": "task",
          "data-label": r.attrs.label,
          "data-list-type": r.attrs.listType,
          "data-spread": r.attrs.spread,
          "data-checked": r.attrs.checked
        },
        0
      ],
      parseMarkdown: {
        match: ({ type: r }) => r === "listItem",
        runner: (r, i, s) => {
          if (i.checked == null) {
            t.parseMarkdown.runner(r, i, s);
            return;
          }
          const o = i.label != null ? `${i.label}.` : "•", l = i.checked != null ? !!i.checked : null, a = i.label != null ? "ordered" : "bullet", c = i.spread != null ? `${i.spread}` : "true";
          r.openNode(s, { label: o, listType: a, spread: c, checked: l }), r.next(i.children), r.closeNode();
        }
      },
      toMarkdown: {
        match: (r) => r.type.name === "list_item",
        runner: (r, i) => {
          if (i.attrs.checked == null) {
            t.toMarkdown.runner(r, i);
            return;
          }
          const s = i.attrs.label, o = i.attrs.listType, l = i.attrs.spread === "true", a = i.attrs.checked;
          r.openNode("listItem", void 0, {
            label: s,
            listType: o,
            spread: l,
            checked: a
          }), r.next(i.content), r.closeNode();
        }
      }
    };
  }
);
Je(Hv.node, {
  displayName: "NodeSchema<taskListItem>",
  group: "ListItem"
});
Je(Hv.ctx, {
  displayName: "NodeSchemaCtx<taskListItem>",
  group: "ListItem"
});
const gI = Qn(() => new Rr(
  /^\[(?<checked>\s|x)\]\s$/,
  (n, e, t, r) => {
    const i = n.doc.resolve(t);
    let s = 0, o = i.node(s);
    for (; o && o.type.name !== "list_item"; )
      s--, o = i.node(s);
    if (!o || o.attrs.checked != null) return null;
    const l = e.groups?.checked === "x", a = i.before(s), c = n.tr;
    return c.deleteRange(t, r).setNodeMarkup(a, void 0, {
      ...o.attrs,
      checked: l
    }), c;
  }
));
Je(gI, {
  displayName: "InputRule<wrapInTaskListInputRule>",
  group: "ListItem"
});
const _te = [
  Cv,
  Bv
].flat(), Lte = [
  mI,
  gI
], Bte = [lI], yI = kn(() => YQ);
Je(yI, {
  displayName: "Prose<autoInsertSpanPlugin>",
  group: "Prose"
});
const zte = kn(() => IQ({}));
Je(zte, {
  displayName: "Prose<columnResizingPlugin>",
  group: "Prose"
});
const bI = kn(
  () => HQ({ allowTableNodeSelection: !0 })
);
Je(bI, {
  displayName: "Prose<tableEditingPlugin>",
  group: "Prose"
});
const $v = Ts("remarkGFM", () => Tte);
Je($v.plugin, {
  displayName: "Remark<remarkGFMPlugin>",
  group: "Remark"
});
Je($v.options, {
  displayName: "RemarkConfig<remarkGFMPlugin>",
  group: "Remark"
});
const Fte = new en("MILKDOWN_KEEP_TABLE_ALIGN_PLUGIN");
function Hte(n, e) {
  let t = 0;
  return e.forEach((r, i, s) => {
    r === n && (t = s);
  }), t;
}
const vI = kn(() => new Ut({
  key: Fte,
  appendTransaction: (n, e, t) => {
    let r;
    const i = (s, o) => {
      if (r || (r = t.tr), s.type.name !== "table_cell") return;
      const l = t.doc.resolve(o), a = l.node(l.depth), u = l.node(l.depth - 1).firstChild;
      if (!u) return;
      const h = Hte(s, a), f = u.maybeChild(h);
      if (!f) return;
      const d = f.attrs.alignment, p = s.attrs.alignment;
      d !== p && r.setNodeMarkup(o, void 0, { ...s.attrs, alignment: d });
    };
    return e.doc !== t.doc && t.doc.descendants(i), r;
  }
}));
Je(vI, {
  displayName: "Prose<keepTableAlignPlugin>",
  group: "Prose"
});
const $te = [
  vI,
  yI,
  $v,
  bI
].flat(), Vte = [
  Hv,
  Ha,
  Z1,
  Ed,
  Q1,
  Id,
  zv,
  Fv,
  Sv,
  uu
].flat(), qte = [
  Av,
  Tv,
  Ov,
  dI,
  Ev,
  Iv,
  na,
  ra,
  pI,
  Dv,
  Pv,
  _v,
  Nv,
  Rv,
  Lv,
  X1
], Wte = [
  Vte,
  Lte,
  Bte,
  _te,
  qte,
  $te
].flat(), jte = (n) => {
  let { state: e } = n, t = e.doc.lineAt(e.selection.main.from), r = qv(n.state, t.from);
  return r.line ? Ute(n) : r.block ? Gte(n) : !1;
};
function Vv(n, e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let i = n(e, t);
    return i ? (r(t.update(i)), !0) : !1;
  };
}
const Ute = /* @__PURE__ */ Vv(
  Xte,
  0
  /* CommentOption.Toggle */
), Kte = /* @__PURE__ */ Vv(
  wI,
  0
  /* CommentOption.Toggle */
), Gte = /* @__PURE__ */ Vv(
  (n, e) => wI(n, e, Jte(e)),
  0
  /* CommentOption.Toggle */
);
function qv(n, e) {
  let t = n.languageDataAt("commentTokens", e, 1);
  return t.length ? t[0] : {};
}
const Ku = 50;
function Yte(n, { open: e, close: t }, r, i) {
  let s = n.sliceDoc(r - Ku, r), o = n.sliceDoc(i, i + Ku), l = /\s*$/.exec(s)[0].length, a = /^\s*/.exec(o)[0].length, c = s.length - l;
  if (s.slice(c - e.length, c) == e && o.slice(a, a + t.length) == t)
    return {
      open: { pos: r - l, margin: l && 1 },
      close: { pos: i + a, margin: a && 1 }
    };
  let u, h;
  i - r <= 2 * Ku ? u = h = n.sliceDoc(r, i) : (u = n.sliceDoc(r, r + Ku), h = n.sliceDoc(i - Ku, i));
  let f = /^\s*/.exec(u)[0].length, d = /\s*$/.exec(h)[0].length, p = h.length - d - t.length;
  return u.slice(f, f + e.length) == e && h.slice(p, p + t.length) == t ? {
    open: {
      pos: r + f + e.length,
      margin: /\s/.test(u.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: i - d - t.length,
      margin: /\s/.test(h.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function Jte(n) {
  let e = [];
  for (let t of n.selection.ranges) {
    let r = n.doc.lineAt(t.from), i = t.to <= r.to ? r : n.doc.lineAt(t.to);
    i.from > r.from && i.from == t.to && (i = t.to == r.to + 1 ? r : n.doc.lineAt(t.to - 1));
    let s = e.length - 1;
    s >= 0 && e[s].to > r.from ? e[s].to = i.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function wI(n, e, t = e.selection.ranges) {
  let r = t.map((s) => qv(e, s.from).block);
  if (!r.every((s) => s))
    return null;
  let i = t.map((s, o) => Yte(e, r[o], s.from, s.to));
  if (n != 2 && !i.every((s) => s))
    return { changes: e.changes(t.map((s, o) => i[o] ? [] : [{ from: s.from, insert: r[o].open + " " }, { from: s.to, insert: " " + r[o].close }])) };
  if (n != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, l; o < i.length; o++)
      if (l = i[o]) {
        let a = r[o], { open: c, close: u } = l;
        s.push({ from: c.pos - a.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + a.close.length });
      }
    return { changes: s };
  }
  return null;
}
function Xte(n, e, t = e.selection.ranges) {
  let r = [], i = -1;
  for (let { from: s, to: o } of t) {
    let l = r.length, a = 1e9, c = qv(e, s).line;
    if (c) {
      for (let u = s; u <= o; ) {
        let h = e.doc.lineAt(u);
        if (h.from > i && (s == o || o > h.from)) {
          i = h.from;
          let f = /^\s*/.exec(h.text)[0].length, d = f == h.length, p = h.text.slice(f, f + c.length) == c ? f : -1;
          f < h.text.length && f < a && (a = f), r.push({ line: h, comment: p, token: c, indent: f, empty: d, single: !1 });
        }
        u = h.to + 1;
      }
      if (a < 1e9)
        for (let u = l; u < r.length; u++)
          r[u].indent < r[u].line.text.length && (r[u].indent = a);
      r.length == l + 1 && (r[l].single = !0);
    }
  }
  if (n != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: a, indent: c, empty: u, single: h } of r)
      (h || !u) && s.push({ from: l.from + c, insert: a + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (n != 1 && r.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: l, token: a } of r)
      if (l >= 0) {
        let c = o.from + l, u = c + a.length;
        o.text[u - o.from] == " " && u++, s.push({ from: c, to: u });
      }
    return { changes: s };
  }
  return null;
}
const w5 = /* @__PURE__ */ wo.define(), Zte = /* @__PURE__ */ wo.define(), Qte = /* @__PURE__ */ ke.define(), xI = /* @__PURE__ */ ke.define({
  combine(n) {
    return Ms(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (r, i) => e(r, i) || t(r, i)
    });
  }
}), kI = /* @__PURE__ */ On.define({
  create() {
    return df.empty;
  },
  update(n, e) {
    let t = e.state.facet(xI), r = e.annotation(w5);
    if (r) {
      let a = Or.fromTransaction(e, r.selection), c = r.side, u = c == 0 ? n.undone : n.done;
      return a ? u = _m(u, u.length, t.minDepth, a) : u = MI(u, e.startState.selection), new df(c == 0 ? r.rest : u, c == 0 ? u : r.rest);
    }
    let i = e.annotation(Zte);
    if ((i == "full" || i == "before") && (n = n.isolate()), e.annotation(mn.addToHistory) === !1)
      return e.changes.empty ? n : n.addMapping(e.changes.desc);
    let s = Or.fromTransaction(e), o = e.annotation(mn.time), l = e.annotation(mn.userEvent);
    return s ? n = n.addChanges(s, o, l, t, e) : e.selection && (n = n.addSelection(e.startState.selection, o, l, t.newGroupDelay)), (i == "full" || i == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((e) => e.toJSON()), undone: n.undone.map((e) => e.toJSON()) };
  },
  fromJSON(n) {
    return new df(n.done.map(Or.fromJSON), n.undone.map(Or.fromJSON));
  }
});
function ene(n = {}) {
  return [
    kI,
    xI.of(n),
    we.domEventHandlers({
      beforeinput(e, t) {
        let r = e.inputType == "historyUndo" ? SI : e.inputType == "historyRedo" ? x5 : null;
        return r ? (e.preventDefault(), r(t)) : !1;
      }
    })
  ];
}
function eg(n, e) {
  return function({ state: t, dispatch: r }) {
    if (!e && t.readOnly)
      return !1;
    let i = t.field(kI, !1);
    if (!i)
      return !1;
    let s = i.pop(n, t, e);
    return s ? (r(s), !0) : !1;
  };
}
const SI = /* @__PURE__ */ eg(0, !1), x5 = /* @__PURE__ */ eg(1, !1), tne = /* @__PURE__ */ eg(0, !0), nne = /* @__PURE__ */ eg(1, !0);
class Or {
  constructor(e, t, r, i, s) {
    this.changes = e, this.effects = t, this.mapped = r, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new Or(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new Or(e.changes && wn.fromJSON(e.changes), [], e.mapped && ys.fromJSON(e.mapped), e.startSelection && G.fromJSON(e.startSelection), e.selectionsAfter.map(G.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let r = ui;
    for (let i of e.startState.facet(Qte)) {
      let s = i(e);
      s.length && (r = r.concat(s));
    }
    return !r.length && e.changes.empty ? null : new Or(e.changes.invert(e.startState.doc), r, void 0, t || e.startState.selection, ui);
  }
  static selection(e) {
    return new Or(void 0, ui, void 0, void 0, e);
  }
}
function _m(n, e, t, r) {
  let i = e + 1 > t + 20 ? e - t - 1 : 0, s = n.slice(i, e);
  return s.push(r), s;
}
function rne(n, e) {
  let t = [], r = !1;
  return n.iterChangedRanges((i, s) => t.push(i, s)), e.iterChangedRanges((i, s, o, l) => {
    for (let a = 0; a < t.length; ) {
      let c = t[a++], u = t[a++];
      l >= c && o <= u && (r = !0);
    }
  }), r;
}
function ine(n, e) {
  return n.ranges.length == e.ranges.length && n.ranges.filter((t, r) => t.empty != e.ranges[r].empty).length === 0;
}
function CI(n, e) {
  return n.length ? e.length ? n.concat(e) : n : e;
}
const ui = [], sne = 200;
function MI(n, e) {
  if (n.length) {
    let t = n[n.length - 1], r = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - sne));
    return r.length && r[r.length - 1].eq(e) ? n : (r.push(e), _m(n, n.length - 1, 1e9, t.setSelAfter(r)));
  } else
    return [Or.selection([e])];
}
function one(n) {
  let e = n[n.length - 1], t = n.slice();
  return t[n.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function Y2(n, e) {
  if (!n.length)
    return n;
  let t = n.length, r = ui;
  for (; t; ) {
    let i = lne(n[t - 1], e, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = n.slice(0, t);
      return s[t - 1] = i, s;
    } else
      e = i.mapped, t--, r = i.selectionsAfter;
  }
  return r.length ? [Or.selection(r)] : ui;
}
function lne(n, e, t) {
  let r = CI(n.selectionsAfter.length ? n.selectionsAfter.map((l) => l.map(e)) : ui, t);
  if (!n.changes)
    return Or.selection(r);
  let i = n.changes.map(e), s = e.mapDesc(n.changes, !0), o = n.mapped ? n.mapped.composeDesc(s) : s;
  return new Or(i, Xe.mapEffects(n.effects, e), o, n.startSelection.map(s), r);
}
const ane = /^(input\.type|delete)($|\.)/;
let df = class bh {
  constructor(e, t, r = 0, i = void 0) {
    this.done = e, this.undone = t, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new bh(this.done, this.undone) : this;
  }
  addChanges(e, t, r, i, s) {
    let o = this.done, l = o[o.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!r || ane.test(r)) && (!l.selectionsAfter.length && t - this.prevTime < i.newGroupDelay && i.joinToEvent(s, rne(l.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? o = _m(o, o.length - 1, i.minDepth, new Or(e.changes.compose(l.changes), CI(Xe.mapEffects(e.effects, l.changes), l.effects), l.mapped, l.startSelection, ui)) : o = _m(o, o.length, i.minDepth, e), new bh(o, ui, t, r);
  }
  addSelection(e, t, r, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : ui;
    return s.length > 0 && t - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && ine(s[s.length - 1], e) ? this : new bh(MI(this.done, e), this.undone, t, r);
  }
  addMapping(e) {
    return new bh(Y2(this.done, e), Y2(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], o = s.selectionsAfter[0] || t.selection;
    if (r && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: w5.of({ side: e, rest: one(i), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let l = i.length == 1 ? ui : i.slice(0, i.length - 1);
      return s.mapped && (l = Y2(l, s.mapped)), t.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: w5.of({ side: e, rest: l, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
};
df.empty = /* @__PURE__ */ new df(ui, ui);
const cne = [
  { key: "Mod-z", run: SI, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: x5, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: x5, preventDefault: !0 },
  { key: "Mod-u", run: tne, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: nne, preventDefault: !0 }
];
function fu(n, e) {
  return G.create(n.ranges.map(e), n.mainIndex);
}
function Es(n, e) {
  return n.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Ki({ state: n, dispatch: e }, t) {
  let r = fu(n.selection, t);
  return r.eq(n.selection, !0) ? !1 : (e(Es(n, r)), !0);
}
function tg(n, e) {
  return G.cursor(e ? n.to : n.from);
}
function TI(n, e) {
  return Ki(n, (t) => t.empty ? n.moveByChar(t, e) : tg(t, e));
}
function er(n) {
  return n.textDirectionAt(n.state.selection.main.head) == Wt.LTR;
}
const AI = (n) => TI(n, !er(n)), OI = (n) => TI(n, er(n));
function EI(n, e) {
  return Ki(n, (t) => t.empty ? n.moveByGroup(t, e) : tg(t, e));
}
const une = (n) => EI(n, !er(n)), hne = (n) => EI(n, er(n));
function fne(n, e, t) {
  if (e.type.prop(t))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(n.sliceDoc(e.from, e.to))) || e.firstChild;
}
function ng(n, e, t) {
  let r = Fn(n).resolveInner(e.head), i = t ? st.closedBy : st.openedBy;
  for (let a = e.head; ; ) {
    let c = t ? r.childAfter(a) : r.childBefore(a);
    if (!c)
      break;
    fne(n, c, i) ? r = c : a = t ? c.to : c.from;
  }
  let s = r.type.prop(i), o, l;
  return s && (o = t ? fs(n, r.from, 1) : fs(n, r.to, -1)) && o.matched ? l = t ? o.end.to : o.end.from : l = t ? r.to : r.from, G.cursor(l, t ? -1 : 1);
}
const dne = (n) => Ki(n, (e) => ng(n.state, e, !er(n))), pne = (n) => Ki(n, (e) => ng(n.state, e, er(n)));
function II(n, e) {
  return Ki(n, (t) => {
    if (!t.empty)
      return tg(t, e);
    let r = n.moveVertically(t, e);
    return r.head != t.head ? r : n.moveToLineBoundary(t, e);
  });
}
const DI = (n) => II(n, !1), NI = (n) => II(n, !0);
function RI(n) {
  let e = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, t = 0, r = 0, i;
  if (e) {
    for (let s of n.state.facet(we.scrollMargins)) {
      let o = s(n);
      o?.top && (t = Math.max(o?.top, t)), o?.bottom && (r = Math.max(o?.bottom, r));
    }
    i = n.scrollDOM.clientHeight - t - r;
  } else
    i = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(n.defaultLineHeight, i - 5)
  };
}
function PI(n, e) {
  let t = RI(n), { state: r } = n, i = fu(r.selection, (o) => o.empty ? n.moveVertically(o, e, t.height) : tg(o, e));
  if (i.eq(r.selection))
    return !1;
  let s;
  if (t.selfScroll) {
    let o = n.coordsAtPos(r.selection.main.head), l = n.scrollDOM.getBoundingClientRect(), a = l.top + t.marginTop, c = l.bottom - t.marginBottom;
    o && o.top > a && o.bottom < c && (s = we.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - a }));
  }
  return n.dispatch(Es(r, i), { effects: s }), !0;
}
const Mk = (n) => PI(n, !1), k5 = (n) => PI(n, !0);
function Ol(n, e, t) {
  let r = n.lineBlockAt(e.head), i = n.moveToLineBoundary(e, t);
  if (i.head == e.head && i.head != (t ? r.to : r.from) && (i = n.moveToLineBoundary(e, t, !1)), !t && i.head == r.from && r.length) {
    let s = /^\s*/.exec(n.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    s && e.head != r.from + s && (i = G.cursor(r.from + s));
  }
  return i;
}
const mne = (n) => Ki(n, (e) => Ol(n, e, !0)), gne = (n) => Ki(n, (e) => Ol(n, e, !1)), yne = (n) => Ki(n, (e) => Ol(n, e, !er(n))), bne = (n) => Ki(n, (e) => Ol(n, e, er(n))), vne = (n) => Ki(n, (e) => G.cursor(n.lineBlockAt(e.head).from, 1)), wne = (n) => Ki(n, (e) => G.cursor(n.lineBlockAt(e.head).to, -1));
function xne(n, e, t) {
  let r = !1, i = fu(n.selection, (s) => {
    let o = fs(n, s.head, -1) || fs(n, s.head, 1) || s.head > 0 && fs(n, s.head - 1, 1) || s.head < n.doc.length && fs(n, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    r = !0;
    let l = o.start.from == s.head ? o.end.to : o.end.from;
    return G.cursor(l);
  });
  return r ? (e(Es(n, i)), !0) : !1;
}
const kne = ({ state: n, dispatch: e }) => xne(n, e);
function Mi(n, e) {
  let t = fu(n.state.selection, (r) => {
    let i = e(r);
    return G.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return t.eq(n.state.selection) ? !1 : (n.dispatch(Es(n.state, t)), !0);
}
function _I(n, e) {
  return Mi(n, (t) => n.moveByChar(t, e));
}
const LI = (n) => _I(n, !er(n)), BI = (n) => _I(n, er(n));
function zI(n, e) {
  return Mi(n, (t) => n.moveByGroup(t, e));
}
const Sne = (n) => zI(n, !er(n)), Cne = (n) => zI(n, er(n)), Mne = (n) => Mi(n, (e) => ng(n.state, e, !er(n))), Tne = (n) => Mi(n, (e) => ng(n.state, e, er(n)));
function FI(n, e) {
  return Mi(n, (t) => n.moveVertically(t, e));
}
const HI = (n) => FI(n, !1), $I = (n) => FI(n, !0);
function VI(n, e) {
  return Mi(n, (t) => n.moveVertically(t, e, RI(n).height));
}
const Tk = (n) => VI(n, !1), Ak = (n) => VI(n, !0), Ane = (n) => Mi(n, (e) => Ol(n, e, !0)), One = (n) => Mi(n, (e) => Ol(n, e, !1)), Ene = (n) => Mi(n, (e) => Ol(n, e, !er(n))), Ine = (n) => Mi(n, (e) => Ol(n, e, er(n))), Dne = (n) => Mi(n, (e) => G.cursor(n.lineBlockAt(e.head).from)), Nne = (n) => Mi(n, (e) => G.cursor(n.lineBlockAt(e.head).to)), Ok = ({ state: n, dispatch: e }) => (e(Es(n, { anchor: 0 })), !0), Ek = ({ state: n, dispatch: e }) => (e(Es(n, { anchor: n.doc.length })), !0), Ik = ({ state: n, dispatch: e }) => (e(Es(n, { anchor: n.selection.main.anchor, head: 0 })), !0), Dk = ({ state: n, dispatch: e }) => (e(Es(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0), Rne = ({ state: n, dispatch: e }) => (e(n.update({ selection: { anchor: 0, head: n.doc.length }, userEvent: "select" })), !0), Pne = ({ state: n, dispatch: e }) => {
  let t = rg(n).map(({ from: r, to: i }) => G.range(r, Math.min(i + 1, n.doc.length)));
  return e(n.update({ selection: G.create(t), userEvent: "select" })), !0;
}, _ne = ({ state: n, dispatch: e }) => {
  let t = fu(n.selection, (r) => {
    let i = Fn(n), s = i.resolveStack(r.from, 1);
    if (r.empty) {
      let o = i.resolveStack(r.from, -1);
      o.node.from >= s.node.from && o.node.to <= s.node.to && (s = o);
    }
    for (let o = s; o; o = o.next) {
      let { node: l } = o;
      if ((l.from < r.from && l.to >= r.to || l.to > r.to && l.from <= r.from) && o.next)
        return G.range(l.to, l.from);
    }
    return r;
  });
  return t.eq(n.selection) ? !1 : (e(Es(n, t)), !0);
}, Lne = ({ state: n, dispatch: e }) => {
  let t = n.selection, r = null;
  return t.ranges.length > 1 ? r = G.create([t.main]) : t.main.empty || (r = G.create([G.cursor(t.main.head)])), r ? (e(Es(n, r)), !0) : !1;
};
function Dd(n, e) {
  if (n.state.readOnly)
    return !1;
  let t = "delete.selection", { state: r } = n, i = r.changeByRange((s) => {
    let { from: o, to: l } = s;
    if (o == l) {
      let a = e(s);
      a < o ? (t = "delete.backward", a = S0(n, a, !1)) : a > o && (t = "delete.forward", a = S0(n, a, !0)), o = Math.min(o, a), l = Math.max(l, a);
    } else
      o = S0(n, o, !1), l = S0(n, l, !0);
    return o == l ? { range: s } : { changes: { from: o, to: l }, range: G.cursor(o, o < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (n.dispatch(r.update(i, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? we.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function S0(n, e, t) {
  if (n instanceof we)
    for (let r of n.state.facet(we.atomicRanges).map((i) => i(n)))
      r.between(e, e, (i, s) => {
        i < e && s > e && (e = t ? s : i);
      });
  return e;
}
const qI = (n, e, t) => Dd(n, (r) => {
  let i = r.from, { state: s } = n, o = s.doc.lineAt(i), l, a;
  if (t && !e && i > o.from && i < o.from + 200 && !/[^ \t]/.test(l = o.text.slice(0, i - o.from))) {
    if (l[l.length - 1] == "	")
      return i - 1;
    let c = tu(l, s.tabSize), u = c % Aa(s) || Aa(s);
    for (let h = 0; h < u && l[l.length - 1 - h] == " "; h++)
      i--;
    a = i;
  } else
    a = zn(o.text, i - o.from, e, e) + o.from, a == i && o.number != (e ? s.doc.lines : 1) ? a += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(a - o.from, i - o.from)) && (a = zn(o.text, a - o.from, !1, !1) + o.from);
  return a;
}), S5 = (n) => qI(n, !1, !0), WI = (n) => qI(n, !0, !1), jI = (n, e) => Dd(n, (t) => {
  let r = t.head, { state: i } = n, s = i.doc.lineAt(r), o = i.charCategorizer(r);
  for (let l = null; ; ) {
    if (r == (e ? s.to : s.from)) {
      r == t.head && s.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let a = zn(s.text, r - s.from, e) + s.from, c = s.text.slice(Math.min(r, a) - s.from, Math.max(r, a) - s.from), u = o(c);
    if (l != null && u != l)
      break;
    (c != " " || r != t.head) && (l = u), r = a;
  }
  return r;
}), UI = (n) => jI(n, !1), Bne = (n) => jI(n, !0), zne = (n) => Dd(n, (e) => {
  let t = n.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), Fne = (n) => Dd(n, (e) => {
  let t = n.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), Hne = (n) => Dd(n, (e) => {
  let t = n.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), $ne = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: dt.of(["", ""]) },
    range: G.cursor(r.from)
  }));
  return e(n.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, Vne = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == n.doc.length)
      return { range: r };
    let i = r.from, s = n.doc.lineAt(i), o = i == s.from ? i - 1 : zn(s.text, i - s.from, !1) + s.from, l = i == s.to ? i + 1 : zn(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: o, to: l, insert: n.doc.slice(i, l).append(n.doc.slice(o, i)) },
      range: G.cursor(l)
    };
  });
  return t.changes.empty ? !1 : (e(n.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function rg(n) {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.from), s = n.doc.lineAt(r.to);
    if (!r.empty && r.to == s.from && (s = n.doc.lineAt(r.to - 1)), t >= i.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(r);
    } else
      e.push({ from: i.from, to: s.to, ranges: [r] });
    t = s.number + 1;
  }
  return e;
}
function KI(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [], i = [];
  for (let s of rg(n)) {
    if (t ? s.to == n.doc.length : s.from == 0)
      continue;
    let o = n.doc.lineAt(t ? s.to + 1 : s.from - 1), l = o.length + 1;
    if (t) {
      r.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + n.lineBreak });
      for (let a of s.ranges)
        i.push(G.range(Math.min(n.doc.length, a.anchor + l), Math.min(n.doc.length, a.head + l)));
    } else {
      r.push({ from: o.from, to: s.from }, { from: s.to, insert: n.lineBreak + o.text });
      for (let a of s.ranges)
        i.push(G.range(a.anchor - l, a.head - l));
    }
  }
  return r.length ? (e(n.update({
    changes: r,
    scrollIntoView: !0,
    selection: G.create(i, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const qne = ({ state: n, dispatch: e }) => KI(n, e, !1), Wne = ({ state: n, dispatch: e }) => KI(n, e, !0);
function GI(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [];
  for (let i of rg(n))
    t ? r.push({ from: i.from, insert: n.doc.slice(i.from, i.to) + n.lineBreak }) : r.push({ from: i.to, insert: n.lineBreak + n.doc.slice(i.from, i.to) });
  return e(n.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const jne = ({ state: n, dispatch: e }) => GI(n, e, !1), Une = ({ state: n, dispatch: e }) => GI(n, e, !0), Kne = (n) => {
  if (n.state.readOnly)
    return !1;
  let { state: e } = n, t = e.changes(rg(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))), r = fu(e.selection, (i) => {
    let s;
    if (n.lineWrapping) {
      let o = n.lineBlockAt(i.head), l = n.coordsAtPos(i.head, i.assoc || 1);
      l && (s = o.bottom + n.documentTop - l.bottom + n.defaultLineHeight / 2);
    }
    return n.moveVertically(i, !0, s);
  }).map(t);
  return n.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function Gne(n, e) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = Fn(n).resolveInner(e), r = t.childBefore(e), i = t.childAfter(e), s;
  return r && i && r.to <= e && i.from >= e && (s = r.type.prop(st.closedBy)) && s.indexOf(i.name) > -1 && n.doc.lineAt(r.to).from == n.doc.lineAt(i.from).from && !/\S/.test(n.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
const Nk = /* @__PURE__ */ YI(!1), Yne = /* @__PURE__ */ YI(!0);
function YI(n) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((i) => {
      let { from: s, to: o } = i, l = e.doc.lineAt(s), a = !n && s == o && Gne(e, s);
      n && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let c = new C1(e, { simulateBreak: s, simulateDoubleBreak: !!a }), u = Y3(c, s);
      for (u == null && (u = tu(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      a ? { from: s, to: o } = a : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let h = ["", Vf(e, u)];
      return a && h.push(Vf(e, c.lineIndent(l.from, -1))), {
        changes: { from: s, to: o, insert: dt.of(h) },
        range: G.cursor(s + 1 + h[1].length)
      };
    });
    return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Wv(n, e) {
  let t = -1;
  return n.changeByRange((r) => {
    let i = [];
    for (let o = r.from; o <= r.to; ) {
      let l = n.doc.lineAt(o);
      l.number > t && (r.empty || r.to > l.from) && (e(l, i, r), t = l.number), o = l.to + 1;
    }
    let s = n.changes(i);
    return {
      changes: i,
      range: G.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
    };
  });
}
const Jne = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), r = new C1(n, { overrideIndentation: (s) => {
    let o = t[s];
    return o ?? -1;
  } }), i = Wv(n, (s, o, l) => {
    let a = Y3(r, s.from);
    if (a == null)
      return;
    /\S/.test(s.text) || (a = 0);
    let c = /^\s*/.exec(s.text)[0], u = Vf(n, a);
    (c != u || l.from < s.from + c.length) && (t[s.from] = a, o.push({ from: s.from, to: s.from + c.length, insert: u }));
  });
  return i.changes.empty || e(n.update(i, { userEvent: "indent" })), !0;
}, JI = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(Wv(n, (t, r) => {
  r.push({ from: t.from, insert: n.facet(S1) });
}), { userEvent: "input.indent" })), !0), XI = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(Wv(n, (t, r) => {
  let i = /^\s*/.exec(t.text)[0];
  if (!i)
    return;
  let s = tu(i, n.tabSize), o = 0, l = Vf(n, Math.max(0, s - Aa(n)));
  for (; o < i.length && o < l.length && i.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  r.push({ from: t.from + o, to: t.from + i.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), Xne = (n) => (n.setTabFocusMode(), !0), Zne = [
  { key: "Ctrl-b", run: AI, shift: LI, preventDefault: !0 },
  { key: "Ctrl-f", run: OI, shift: BI },
  { key: "Ctrl-p", run: DI, shift: HI },
  { key: "Ctrl-n", run: NI, shift: $I },
  { key: "Ctrl-a", run: vne, shift: Dne },
  { key: "Ctrl-e", run: wne, shift: Nne },
  { key: "Ctrl-d", run: WI },
  { key: "Ctrl-h", run: S5 },
  { key: "Ctrl-k", run: zne },
  { key: "Ctrl-Alt-h", run: UI },
  { key: "Ctrl-o", run: $ne },
  { key: "Ctrl-t", run: Vne },
  { key: "Ctrl-v", run: k5 }
], Qne = /* @__PURE__ */ [
  { key: "ArrowLeft", run: AI, shift: LI, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: une, shift: Sne, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: yne, shift: Ene, preventDefault: !0 },
  { key: "ArrowRight", run: OI, shift: BI, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: hne, shift: Cne, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: bne, shift: Ine, preventDefault: !0 },
  { key: "ArrowUp", run: DI, shift: HI, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Ok, shift: Ik },
  { mac: "Ctrl-ArrowUp", run: Mk, shift: Tk },
  { key: "ArrowDown", run: NI, shift: $I, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Ek, shift: Dk },
  { mac: "Ctrl-ArrowDown", run: k5, shift: Ak },
  { key: "PageUp", run: Mk, shift: Tk },
  { key: "PageDown", run: k5, shift: Ak },
  { key: "Home", run: gne, shift: One, preventDefault: !0 },
  { key: "Mod-Home", run: Ok, shift: Ik },
  { key: "End", run: mne, shift: Ane, preventDefault: !0 },
  { key: "Mod-End", run: Ek, shift: Dk },
  { key: "Enter", run: Nk, shift: Nk },
  { key: "Mod-a", run: Rne },
  { key: "Backspace", run: S5, shift: S5 },
  { key: "Delete", run: WI },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: UI },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Bne },
  { mac: "Mod-Backspace", run: Fne },
  { mac: "Mod-Delete", run: Hne }
].concat(/* @__PURE__ */ Zne.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))), ZI = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: dne, shift: Mne },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: pne, shift: Tne },
  { key: "Alt-ArrowUp", run: qne },
  { key: "Shift-Alt-ArrowUp", run: jne },
  { key: "Alt-ArrowDown", run: Wne },
  { key: "Shift-Alt-ArrowDown", run: Une },
  { key: "Escape", run: Lne },
  { key: "Mod-Enter", run: Yne },
  { key: "Alt-l", mac: "Ctrl-l", run: Pne },
  { key: "Mod-i", run: _ne, preventDefault: !0 },
  { key: "Mod-[", run: XI },
  { key: "Mod-]", run: JI },
  { key: "Mod-Alt-\\", run: Jne },
  { key: "Shift-Mod-k", run: Kne },
  { key: "Shift-Mod-\\", run: kne },
  { key: "Mod-/", run: jte },
  { key: "Alt-A", run: Kte },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: Xne }
].concat(Qne), ere = { key: "Tab", run: JI, shift: XI };
var Lm = 200, Tn = function() {
};
Tn.prototype.append = function(e) {
  return e.length ? (e = Tn.from(e), !this.length && e || e.length < Lm && this.leafAppend(e) || this.length < Lm && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Tn.prototype.prepend = function(e) {
  return e.length ? Tn.from(e).append(this) : this;
};
Tn.prototype.appendInner = function(e) {
  return new tre(this, e);
};
Tn.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? Tn.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
Tn.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Tn.prototype.forEach = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
};
Tn.prototype.map = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(s, o) {
    return i.push(e(s, o));
  }, t, r), i;
};
Tn.from = function(e) {
  return e instanceof Tn ? e : e && e.length ? new QI(e) : Tn.empty;
};
var QI = /* @__PURE__ */ (function(n) {
  function e(r) {
    n.call(this), this.values = r;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, s) {
    return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, s, o, l) {
    for (var a = s; a < o; a++)
      if (i(this.values[a], l + a) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, s, o, l) {
    for (var a = s - 1; a >= o; a--)
      if (i(this.values[a], l + a) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Lm)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Lm)
      return new e(i.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
})(Tn);
Tn.empty = new QI([]);
var tre = /* @__PURE__ */ (function(n) {
  function e(t, r) {
    n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, s, o) {
    var l = this.left.length;
    if (i < l && this.left.forEachInner(r, i, Math.min(s, l), o) === !1 || s > l && this.right.forEachInner(r, Math.max(i - l, 0), Math.min(this.length, s) - l, o + l) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, o) {
    var l = this.left.length;
    if (i > l && this.right.forEachInvertedInner(r, i - l, Math.max(s, l) - l, o + l) === !1 || s < l && this.left.forEachInvertedInner(r, Math.min(i, l), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var s = this.left.length;
    return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
})(Tn);
const nre = 500;
class Ii {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, s;
    t && (i = this.remapping(r, this.items.length), s = i.maps.length);
    let o = e.tr, l, a, c = [], u = [];
    return this.items.forEach((h, f) => {
      if (!h.step) {
        i || (i = this.remapping(r, f + 1), s = i.maps.length), s--, u.push(h);
        return;
      }
      if (i) {
        u.push(new rs(h.map));
        let d = h.step.map(i.slice(s)), p;
        d && o.maybeStep(d).doc && (p = o.mapping.maps[o.mapping.maps.length - 1], c.push(new rs(p, void 0, void 0, c.length + u.length))), s--, p && i.appendMap(p, s);
      } else
        o.maybeStep(h.step);
      if (h.selection)
        return l = i ? h.selection.map(i.slice(s)) : h.selection, a = new Ii(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: a, transform: o, selection: l };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, r, i) {
    let s = [], o = this.eventCount, l = this.items, a = !i && l.length ? l.get(l.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let h = e.steps[u].invert(e.docs[u]), f = new rs(e.mapping.maps[u], h, t), d;
      (d = a && a.merge(f)) && (f = d, u ? s.pop() : l = l.slice(0, l.length - 1)), s.push(f), t && (o++, t = void 0), i || (a = f);
    }
    let c = o - r.depth;
    return c > ire && (l = rre(l, c), o -= c), new Ii(l.append(s), o);
  }
  remapping(e, t) {
    let r = new vf();
    return this.items.forEach((i, s) => {
      let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, o);
    }, e, t), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new Ii(this.items.append(e.map((t) => new rs(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - t), s = e.mapping, o = e.steps.length, l = this.eventCount;
    this.items.forEach((f) => {
      f.selection && l--;
    }, i);
    let a = t;
    this.items.forEach((f) => {
      let d = s.getMirror(--a);
      if (d == null)
        return;
      o = Math.min(o, d);
      let p = s.maps[d];
      if (f.step) {
        let m = e.steps[d].invert(e.docs[d]), g = f.selection && f.selection.map(s.slice(a + 1, d));
        g && l++, r.push(new rs(p, m, g));
      } else
        r.push(new rs(p));
    }, i);
    let c = [];
    for (let f = t; f < o; f++)
      c.push(new rs(s.maps[f]));
    let u = this.items.slice(0, i).append(c).append(r), h = new Ii(u, l);
    return h.emptyItemCount() > nre && (h = h.compress(this.items.length - r.length)), h;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), r = t.maps.length, i = [], s = 0;
    return this.items.forEach((o, l) => {
      if (l >= e)
        i.push(o), o.selection && s++;
      else if (o.step) {
        let a = o.step.map(t.slice(r)), c = a && a.getMap();
        if (r--, c && t.appendMap(c, r), a) {
          let u = o.selection && o.selection.map(t.slice(r));
          u && s++;
          let h = new rs(c.invert(), a, u), f, d = i.length - 1;
          (f = i.length && i[d].merge(h)) ? i[d] = f : i.push(h);
        }
      } else o.map && r--;
    }, this.items.length, 0), new Ii(Tn.from(i.reverse()), s);
  }
}
Ii.empty = new Ii(Tn.empty, 0);
function rre(n, e) {
  let t;
  return n.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return t = i, !1;
  }), n.slice(t);
}
class rs {
  constructor(e, t, r, i) {
    this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new rs(t.getMap().invert(), t, this.selection);
    }
  }
}
class qo {
  constructor(e, t, r, i, s) {
    this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i, this.prevComposition = s;
  }
}
const ire = 20;
function sre(n, e, t, r) {
  let i = t.getMeta(ma), s;
  if (i)
    return i.historyState;
  t.getMeta(are) && (n = new qo(n.done, n.undone, null, 0, -1));
  let o = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (o && o.getMeta(ma))
    return o.getMeta(ma).redo ? new qo(n.done.addTransform(t, void 0, r, Ap(e)), n.undone, Rk(t.mapping.maps), n.prevTime, n.prevComposition) : new qo(n.done, n.undone.addTransform(t, void 0, r, Ap(e)), null, n.prevTime, n.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let l = t.getMeta("composition"), a = n.prevTime == 0 || !o && n.prevComposition != l && (n.prevTime < (t.time || 0) - r.newGroupDelay || !ore(t, n.prevRanges)), c = o ? J2(n.prevRanges, t.mapping) : Rk(t.mapping.maps);
    return new qo(n.done.addTransform(t, a ? e.selection.getBookmark() : void 0, r, Ap(e)), Ii.empty, c, t.time, l ?? n.prevComposition);
  } else return (s = t.getMeta("rebased")) ? new qo(n.done.rebased(t, s), n.undone.rebased(t, s), J2(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new qo(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), J2(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
}
function ore(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((r, i) => {
    for (let s = 0; s < e.length; s += 2)
      r <= e[s + 1] && i >= e[s] && (t = !0);
  }), t;
}
function Rk(n) {
  let e = [];
  for (let t = n.length - 1; t >= 0 && e.length == 0; t--)
    n[t].forEach((r, i, s, o) => e.push(s, o));
  return e;
}
function J2(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let r = 0; r < n.length; r += 2) {
    let i = e.map(n[r], 1), s = e.map(n[r + 1], -1);
    i <= s && t.push(i, s);
  }
  return t;
}
function lre(n, e, t) {
  let r = Ap(e), i = ma.get(e).spec.config, s = (t ? n.undone : n.done).popEvent(e, r);
  if (!s)
    return null;
  let o = s.selection.resolve(s.transform.doc), l = (t ? n.done : n.undone).addTransform(s.transform, e.selection.getBookmark(), i, r), a = new qo(t ? l : s.remaining, t ? s.remaining : l, null, 0, -1);
  return s.transform.setSelection(o).setMeta(ma, { redo: t, historyState: a });
}
let X2 = !1, Pk = null;
function Ap(n) {
  let e = n.plugins;
  if (Pk != e) {
    X2 = !1, Pk = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        X2 = !0;
        break;
      }
  }
  return X2;
}
const ma = new en("history"), are = new en("closeHistory");
function cre(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new Ut({
    key: ma,
    state: {
      init() {
        return new qo(Ii.empty, Ii.empty, null, 0, -1);
      },
      apply(e, t, r) {
        return sre(t, r, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let r = t.inputType, i = r == "historyUndo" ? ig : r == "historyRedo" ? jc : null;
          return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function eD(n, e) {
  return (t, r) => {
    let i = ma.getState(t);
    if (!i || (n ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let s = lre(i, t, n);
      s && r(e ? s.scrollIntoView() : s);
    }
    return !0;
  };
}
const ig = eD(!1, !0), jc = eD(!0, !0);
var ure = Object.defineProperty, _k = Object.getOwnPropertySymbols, hre = Object.prototype.hasOwnProperty, fre = Object.prototype.propertyIsEnumerable, Lk = (n, e, t) => e in n ? ure(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, dre = (n, e) => {
  for (var t in e || (e = {}))
    hre.call(e, t) && Lk(n, t, e[t]);
  if (_k)
    for (var t of _k(e))
      fre.call(e, t) && Lk(n, t, e[t]);
  return n;
};
function tD(n, e) {
  return Object.assign(n, {
    meta: dre({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const pre = {
  extensions: [],
  languages: [],
  expandIcon: "⬇",
  searchIcon: "🔍",
  clearSearchIcon: "⌫",
  searchPlaceholder: "Search language",
  noResultText: "No result",
  copyText: "Copy",
  copyIcon: "📋",
  onCopy: () => {
  },
  renderLanguage: (n) => n,
  renderPreview: () => null,
  previewToggleButton: (n) => n ? "Edit" : "Hide",
  previewLabel: "Preview"
}, Nd = Mt(pre, "codeBlockConfigCtx");
tD(Nd, {
  displayName: "Config<code-block>",
  group: "CodeBlock"
});
class mre {
  constructor(e) {
    this.languages = e, this.map = {}, e.forEach((t) => {
      t.alias.forEach((r) => {
        this.map[r] = t;
      });
    });
  }
  getAll() {
    return this.languages.map((e) => ({
      name: e.name,
      alias: e.alias
    }));
  }
  load(e) {
    const r = this.map[e.toLowerCase()];
    return r ? r.support ? Promise.resolve(r.support) : r.load() : Promise.resolve(void 0);
  }
}
function Tc({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
Tc.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
var gre = (n, e, t) => new Promise((r, i) => {
  var s = (a) => {
    try {
      l(t.next(a));
    } catch (c) {
      i(c);
    }
  }, o = (a) => {
    try {
      l(t.throw(a));
    } catch (c) {
      i(c);
    }
  }, l = (a) => a.done ? r(a.value) : Promise.resolve(a.value).then(s, o);
  l((t = t.apply(n, e)).next());
});
function yre(n) {
  return gre(this, null, function* () {
    try {
      return navigator.clipboard.writeText(n);
    } catch {
      const t = document.createElement("textarea"), r = document.activeElement;
      t.value = n, t.setAttribute("readonly", ""), t.style.contain = "strict", t.style.position = "absolute", t.style.left = "-9999px", t.style.fontSize = "12pt";
      const i = document.getSelection(), s = i ? i.rangeCount > 0 && i.getRangeAt(0) : null;
      document.body.appendChild(t), t.select(), t.selectionStart = 0, t.selectionEnd = n.length, document.execCommand("copy"), document.body.removeChild(t), s && (i.removeAllRanges(), i.addRange(s)), r && r.focus();
    }
  });
}
const bre = /* @__PURE__ */ $n({
  props: {
    copyText: {
      type: String,
      required: !0
    },
    copyIcon: {
      type: String,
      required: !0
    },
    onCopy: {
      type: Function,
      required: !0
    },
    text: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = () => {
      yre(n.text).then(() => n.onCopy(n.text)).catch(console.error);
    };
    return () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("button", { type: "button", class: "copy-button", onClick: e }, /* @__PURE__ */ j(Tc, { icon: n.copyIcon }), n.copyText));
  }
}), vre = /* @__PURE__ */ $n({
  props: {
    language: {
      type: Object,
      required: !0
    },
    getReadOnly: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    getAllLanguages: {
      type: Function,
      required: !0
    },
    setLanguage: {
      type: Function,
      required: !0
    }
  },
  setup({ language: n, config: e, setLanguage: t, getAllLanguages: r, getReadOnly: i }) {
    const s = Ae(), o = Ae(!1), l = Ae(), a = Ae(), c = Ae("");
    Mc([o, s, a], () => {
      c.value = "";
      const m = s.value, g = a.value;
      !m || !g || $i(m, g, {
        placement: "bottom-start"
      }).then(({ x: b, y: w }) => {
        Object.assign(g.style, {
          left: `${b}px`,
          top: `${w}px`
        });
      }).catch(console.error);
    });
    const u = (m) => {
      if (m.preventDefault(), m.stopPropagation(), i()) return;
      const g = !o.value;
      o.value = g, g && setTimeout(() => {
        var b;
        return (b = l.value) == null ? void 0 : b.focus();
      }, 0);
    }, h = (m) => {
      const g = m.target;
      c.value = g.value;
    }, f = (m) => {
      m.key === "Escape" && (c.value = "");
    }, d = Na(() => {
      var m;
      if (!o.value) return [];
      const g = (m = r()) != null ? m : [], b = g.find(
        (k) => k.name.toLowerCase() === n.value.toLowerCase()
      ), w = g.filter((k) => {
        const C = c.value.toLowerCase();
        return (k.name.toLowerCase().includes(C) || k.alias.some(
          (M) => M.toLowerCase().includes(C)
        )) && k !== b;
      });
      return w.length === 0 ? [] : b ? [b, ...w] : w;
    }), p = (m) => {
      const g = m.target;
      if (s.value && s.value.contains(g)) return;
      const b = a.value, w = s.value;
      !w || !b || w.dataset.expanded === "true" && (b.contains(g) || (o.value = !1));
    };
    return kd(() => {
      window.addEventListener("click", p);
    }), Sd(() => {
      window.removeEventListener("click", p);
    }), () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j(
      "button",
      {
        type: "button",
        ref: s,
        class: "language-button",
        onClick: u,
        "data-expanded": String(o.value)
      },
      n.value || "Text",
      /* @__PURE__ */ j("div", { class: "expand-icon" }, /* @__PURE__ */ j(Tc, { icon: e.expandIcon }))
    ), /* @__PURE__ */ j("div", { ref: a, class: "language-picker" }, o.value ? /* @__PURE__ */ j("div", { class: "list-wrapper" }, /* @__PURE__ */ j("div", { class: "search-box" }, /* @__PURE__ */ j("div", { class: "search-icon" }, /* @__PURE__ */ j(Tc, { icon: e.searchIcon })), /* @__PURE__ */ j(
      "input",
      {
        ref: l,
        class: "search-input",
        placeholder: e.searchPlaceholder,
        value: c.value,
        onInput: h,
        onKeydown: f
      }
    ), /* @__PURE__ */ j(
      "div",
      {
        class: Hn(
          "clear-icon",
          c.value.length === 0 && "hidden"
        ),
        onMousedown: (m) => {
          m.preventDefault(), c.value = "";
        }
      },
      /* @__PURE__ */ j(Tc, { icon: e.clearSearchIcon })
    )), /* @__PURE__ */ j(
      "ul",
      {
        class: "language-list",
        role: "listbox",
        onKeydown: (m) => {
          if (m.key === "Enter") {
            const g = document.activeElement;
            g instanceof HTMLElement && g.dataset.language && t(g.dataset.language);
          }
        }
      },
      d.value.length ? d.value.map((m) => /* @__PURE__ */ j(
        "li",
        {
          role: "listitem",
          tabindex: "0",
          class: "language-list-item",
          "aria-selected": m.name.toLowerCase() === n.value.toLowerCase(),
          "data-language": m.name,
          onClick: () => {
            t(m.name), o.value = !1;
          }
        },
        e.renderLanguage(
          m.name,
          m.name.toLowerCase() === n.value.toLowerCase()
        )
      )) : /* @__PURE__ */ j("li", { class: "language-list-item no-result" }, e.noResultText)
    )) : null));
  }
}), wre = /* @__PURE__ */ $n({
  props: {
    text: {
      type: Object,
      required: !0
    },
    language: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    previewOnlyMode: {
      type: Object,
      required: !0
    },
    preview: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { previewOnlyMode: e, config: t, preview: r } = n, i = Ae();
    return cu(() => {
      const s = i.value;
      if (!s) return;
      for (; s.firstChild; )
        s.removeChild(s.firstChild);
      const o = r.value;
      (typeof o == "string" || o instanceof Element) && (s.innerHTML = Ui.sanitize(o));
    }), () => r.value ? /* @__PURE__ */ j("div", { class: "preview-panel" }, !e.value && /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("div", { class: "preview-divider" }), /* @__PURE__ */ j("div", { class: Hn("preview-label", e && "hidden") }, t.previewLabel)), /* @__PURE__ */ j("div", { ref: i, class: "preview" })) : null;
  }
}), xre = /* @__PURE__ */ $n({
  props: {
    text: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    getReadOnly: {
      type: Function,
      required: !0
    },
    codemirror: {
      type: Object,
      required: !0
    },
    language: {
      type: Object,
      required: !0
    },
    getAllLanguages: {
      type: Function,
      required: !0
    },
    setLanguage: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = Ae(!1), t = Ae();
    kd(() => {
      for (var s; (s = t.value) != null && s.firstChild; )
        t.value.removeChild(t.value.firstChild);
      t.value && t.value.appendChild(n.codemirror.dom);
    });
    const r = Na(() => {
      const s = n.text.value, o = n.language.value;
      return n.config.renderPreview(o, s);
    }), i = () => {
    };
    return () => {
      var s;
      return /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("div", { class: "tools" }, /* @__PURE__ */ j(
        vre,
        {
          language: n.language,
          config: n.config,
          setLanguage: n.setLanguage,
          getAllLanguages: n.getAllLanguages,
          getReadOnly: n.getReadOnly
        }
      ), /* @__PURE__ */ j("div", { class: "tools-button-group" }, /* @__PURE__ */ j(
        bre,
        {
          copyIcon: n.config.copyIcon,
          copyText: n.config.copyText,
          onCopy: (s = n.config.onCopy) != null ? s : i,
          text: n.text.value
        }
      ), r.value ? /* @__PURE__ */ j(
        "button",
        {
          class: "preview-toggle-button",
          onClick: () => e.value = !e.value
        },
        /* @__PURE__ */ j(
          Tc,
          {
            icon: n.config.previewToggleButton(
              e.value
            )
          }
        )
      ) : null)), /* @__PURE__ */ j(
        "div",
        {
          ref: t,
          class: Hn(
            "codemirror-host",
            r.value && e.value && "hidden"
          )
        }
      ), /* @__PURE__ */ j(
        wre,
        {
          text: n.text,
          language: n.language,
          config: n.config,
          previewOnlyMode: e,
          preview: r
        }
      ));
    };
  }
});
class kre {
  constructor(e, t, r, i, s) {
    this.node = e, this.view = t, this.getPos = r, this.loader = i, this.config = s, this.selected = Ae(!1), this.language = Ae(""), this.text = Ae(""), this.updating = !1, this.languageName = "", this.forwardUpdate = (o) => {
      var l;
      if (this.updating || !this.cm.hasFocus) return;
      let a = ((l = this.getPos()) != null ? l : 0) + 1;
      const { main: c } = o.state.selection, u = a + c.from, h = a + c.to, f = this.view.state.selection;
      if (o.docChanged || f.from !== u || f.to !== h) {
        const d = this.view.state.tr;
        o.changes.iterChanges((p, m, g, b, w) => {
          w.length ? d.replaceWith(
            a + p,
            a + m,
            this.view.state.schema.text(w.toString())
          ) : d.delete(a + p, a + m), a += b - g - (m - p);
        }), d.setSelection(Ee.create(d.doc, u, h)), this.view.dispatch(d);
      }
    }, this.createApp = () => ji(xre, {
      text: this.text,
      selected: this.selected,
      codemirror: this.cm,
      language: this.language,
      getAllLanguages: this.getAllLanguages,
      getReadOnly: () => !this.view.editable,
      setLanguage: this.setLanguage,
      config: this.config
    }), this.codeMirrorKeymap = () => {
      const o = this.view;
      return [
        { key: "ArrowUp", run: () => this.maybeEscape("line", -1) },
        { key: "ArrowLeft", run: () => this.maybeEscape("char", -1) },
        { key: "ArrowDown", run: () => this.maybeEscape("line", 1) },
        { key: "ArrowRight", run: () => this.maybeEscape("char", 1) },
        {
          key: "Mod-Enter",
          run: () => CC(o.state, o.dispatch) ? (o.focus(), !0) : !1
        },
        { key: "Mod-z", run: () => ig(o.state, o.dispatch) },
        { key: "Shift-Mod-z", run: () => jc(o.state, o.dispatch) },
        { key: "Mod-y", run: () => jc(o.state, o.dispatch) },
        {
          key: "Backspace",
          run: () => {
            var l;
            const a = this.cm.state.selection.ranges;
            if (a.length > 1) return !1;
            const c = a[0];
            if (c && (!c.empty || c.anchor > 0) || this.cm.state.doc.lines >= 2) return !1;
            const u = this.view.state, h = (l = this.getPos()) != null ? l : 0, f = u.tr.replaceWith(
              h,
              h + this.node.nodeSize,
              u.schema.nodes.paragraph.createChecked({}, this.node.content)
            );
            return f.setSelection(Ee.near(f.doc.resolve(h))), this.view.dispatch(f), this.view.focus(), !0;
          }
        }
      ];
    }, this.maybeEscape = (o, l) => {
      var a;
      const { state: c } = this.cm;
      let u = c.selection.main;
      if (!u.empty || (o === "line" && (u = c.doc.lineAt(u.head)), l < 0 ? u.from > 0 : u.to < c.doc.length)) return !1;
      const h = ((a = this.getPos()) != null ? a : 0) + (l < 0 ? 0 : this.node.nodeSize), f = Ee.near(
        this.view.state.doc.resolve(h),
        l
      ), d = this.view.state.tr.setSelection(f).scrollIntoView();
      return this.view.dispatch(d), this.view.focus(), !0;
    }, this.setLanguage = (o) => {
      var l;
      this.view.dispatch(
        this.view.state.tr.setNodeAttribute(
          (l = this.getPos()) != null ? l : 0,
          "language",
          o
        )
      );
    }, this.getAllLanguages = () => this.loader.getAll(), this.languageConf = new Lc(), this.readOnlyConf = new Lc(), this.cm = new we({
      doc: this.node.textContent,
      root: this.view.root,
      extensions: [
        this.readOnlyConf.of(ct.readOnly.of(!this.view.editable)),
        vA(),
        nu.of(this.codeMirrorKeymap()),
        this.languageConf.of([]),
        ct.changeFilter.of(() => this.view.editable),
        ...s.extensions,
        we.updateListener.of(this.forwardUpdate)
      ]
    }), this.app = this.createApp(), this.dom = this.createDom(this.app), this.disposeSelectedWatcher = cu(() => {
      this.selected.value ? this.dom.classList.add("selected") : this.dom.classList.remove("selected");
    }), this.updateLanguage();
  }
  createDom(e) {
    const t = document.createElement("div");
    return t.className = "milkdown-code-block", this.text.value = this.node.textContent, e.mount(t), t;
  }
  updateLanguage() {
    const e = this.node.attrs.language;
    if (e === this.languageName) return;
    this.language.value = e, this.loader.load(e ?? "").then((r) => {
      r && (this.cm.dispatch({
        effects: this.languageConf.reconfigure(r)
      }), this.languageName = e);
    }).catch(console.error);
  }
  setSelection(e, t) {
    this.cm.dom.isConnected && (this.cm.focus(), this.updating = !0, this.cm.dispatch({ selection: { anchor: e, head: t } }), this.updating = !1);
  }
  update(e) {
    if (e.type !== this.node.type) return !1;
    if (this.updating) return !0;
    this.node = e, this.text.value = e.textContent, this.updateLanguage(), this.view.editable === this.cm.state.readOnly && this.cm.dispatch({
      effects: this.readOnlyConf.reconfigure(
        ct.readOnly.of(!this.view.editable)
      )
    });
    const t = Sre(this.cm.state.doc.toString(), e.textContent);
    return t && (this.updating = !0, this.cm.dispatch({
      changes: { from: t.from, to: t.to, insert: t.text },
      scrollIntoView: !0
    }), this.updating = !1), !0;
  }
  selectNode() {
    this.selected.value = !0, this.cm.focus();
  }
  deselectNode() {
    this.selected.value = !1;
  }
  stopEvent() {
    return !0;
  }
  destroy() {
    this.app.unmount(), this.cm.destroy(), this.disposeSelectedWatcher();
  }
}
function Sre(n, e) {
  if (n === e) return null;
  let t = 0, r = n.length, i = e.length;
  for (; t < r && n.charCodeAt(t) === e.charCodeAt(t); )
    ++t;
  for (; r > t && i > t && n.charCodeAt(r - 1) === e.charCodeAt(i - 1); )
    r--, i--;
  return { from: t, to: r, text: e.slice(t, i) };
}
const nD = yd(
  Ss.node,
  (n) => {
    const e = n.get(Nd.key), t = new mre(e.languages);
    return (r, i, s) => new kre(r, i, s, t, e);
  }
);
tD(nD, {
  displayName: "NodeView<code-block>",
  group: "CodeBlock"
});
const Cre = [
  nD,
  Nd
], Bk = typeof String.prototype.normalize == "function" ? (n) => n.normalize("NFKD") : (n) => n;
class Uc {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, r = 0, i = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = s ? (l) => s(Bk(l)) : Bk, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Sr(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = P3(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += ls(e);
      let i = this.normalize(t);
      if (i.length)
        for (let s = 0, o = r; ; s++) {
          let l = i.charCodeAt(s), a = this.match(l, o, this.bufferPos + this.bufferStart);
          if (s == i.length - 1) {
            if (a)
              return this.value = a, this;
            break;
          }
          o == r && s < t.length && t.charCodeAt(s) == l && o++;
        }
    }
  }
  match(e, t, r) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], l = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? i = { from: this.matches[s + 1], to: r } : (this.matches[s]++, l = !0)), l || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: r } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (Uc.prototype[Symbol.iterator] = function() {
  return this;
});
const rD = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, jv = "gm" + (/x/.unicode == null ? "" : "u");
class iD {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, r, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = rD, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new sD(e, t, r, i, s);
    this.re = new RegExp(t, jv + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.iter = e.iter();
    let o = e.lineAt(i);
    this.curLineStart = o.from, this.matchPos = Bm(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let r = this.curLineStart + t.index, i = r + t[0].length;
        if (this.matchPos = Bm(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Z2 = /* @__PURE__ */ new WeakMap();
class Ac {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, r) {
    let i = Z2.get(e);
    if (!i || i.from >= r || i.to <= t) {
      let l = new Ac(t, e.sliceString(t, r));
      return Z2.set(e, l), l;
    }
    if (i.from == t && i.to == r)
      return i;
    let { text: s, from: o } = i;
    return o > t && (s = e.sliceString(t, o) + s, o = t), i.to < r && (s += e.sliceString(i.to, r)), Z2.set(e, new Ac(o, s)), new Ac(t, s.slice(t - o, r - o));
  }
}
class sD {
  constructor(e, t, r, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = rD, this.matchPos = Bm(e, i), this.re = new RegExp(t, jv + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.flat = Ac.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let r = this.flat.from + t.index, i = r + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this.matchPos = Bm(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Ac.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (iD.prototype[Symbol.iterator] = sD.prototype[Symbol.iterator] = function() {
  return this;
});
function Mre(n) {
  try {
    return new RegExp(n, jv), !0;
  } catch {
    return !1;
  }
}
function Bm(n, e) {
  if (e >= n.length)
    return e;
  let t = n.lineAt(e), r;
  for (; e < t.to && (r = t.text.charCodeAt(e - t.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function C5(n) {
  let e = String(n.state.doc.lineAt(n.state.selection.main.head).number), t = Ot("input", { class: "cm-textfield", name: "line", value: e }), r = Ot("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), n.dispatch({ effects: pf.of(!1) }), n.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, Ot("label", n.state.phrase("Go to line"), ": ", t), " ", Ot("button", { class: "cm-button", type: "submit" }, n.state.phrase("go")), Ot("button", {
    name: "close",
    onclick: () => {
      n.dispatch({ effects: pf.of(!1) }), n.focus();
    },
    "aria-label": n.state.phrase("close"),
    type: "button"
  }, ["×"]));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!s)
      return;
    let { state: o } = n, l = o.doc.lineAt(o.selection.main.head), [, a, c, u, h] = s, f = u ? +u.slice(1) : 0, d = c ? +c : l.number;
    if (c && h) {
      let g = d / 100;
      a && (g = g * (a == "-" ? -1 : 1) + l.number / o.doc.lines), d = Math.round(o.doc.lines * g);
    } else c && a && (d = d * (a == "-" ? -1 : 1) + l.number);
    let p = o.doc.line(Math.max(1, Math.min(o.doc.lines, d))), m = G.cursor(p.from + Math.max(0, Math.min(f, p.length)));
    n.dispatch({
      effects: [pf.of(!1), we.scrollIntoView(m.from, { y: "center" })],
      selection: m
    }), n.focus();
  }
  return { dom: r };
}
const pf = /* @__PURE__ */ Xe.define(), zk = /* @__PURE__ */ On.define({
  create() {
    return !0;
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(pf) && (n = t.value);
    return n;
  },
  provide: (n) => $f.from(n, (e) => e ? C5 : null)
}), Tre = (n) => {
  let e = Hf(n, C5);
  if (!e) {
    let t = [pf.of(!0)];
    n.state.field(zk, !1) == null && t.push(Xe.appendConfig.of([zk, Are])), n.dispatch({ effects: t }), e = Hf(n, C5);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, Are = /* @__PURE__ */ we.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), Ore = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, Ere = /* @__PURE__ */ ke.define({
  combine(n) {
    return Ms(n, Ore, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Ire(n) {
  return [_re, Pre];
}
const Dre = /* @__PURE__ */ He.mark({ class: "cm-selectionMatch" }), Nre = /* @__PURE__ */ He.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function Fk(n, e, t, r) {
  return (t == 0 || n(e.sliceDoc(t - 1, t)) != jt.Word) && (r == e.doc.length || n(e.sliceDoc(r, r + 1)) != jt.Word);
}
function Rre(n, e, t, r) {
  return n(e.sliceDoc(t, t + 1)) == jt.Word && n(e.sliceDoc(r - 1, r)) == jt.Word;
}
const Pre = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.selectionSet || n.docChanged || n.viewportChanged) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = n.state.facet(Ere), { state: t } = n, r = t.selection;
    if (r.ranges.length > 1)
      return He.none;
    let i = r.main, s, o = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return He.none;
      let a = t.wordAt(i.head);
      if (!a)
        return He.none;
      o = t.charCategorizer(i.head), s = t.sliceDoc(a.from, a.to);
    } else {
      let a = i.to - i.from;
      if (a < e.minSelectionLength || a > 200)
        return He.none;
      if (e.wholeWords) {
        if (s = t.sliceDoc(i.from, i.to), o = t.charCategorizer(i.head), !(Fk(o, t, i.from, i.to) && Rre(o, t, i.from, i.to)))
          return He.none;
      } else if (s = t.sliceDoc(i.from, i.to), !s)
        return He.none;
    }
    let l = [];
    for (let a of n.visibleRanges) {
      let c = new Uc(t.doc, s, a.from, a.to);
      for (; !c.next().done; ) {
        let { from: u, to: h } = c.value;
        if ((!o || Fk(o, t, u, h)) && (i.empty && u <= i.from && h >= i.to ? l.push(Nre.range(u, h)) : (u >= i.to || h <= i.from) && l.push(Dre.range(u, h)), l.length > e.maxMatches))
          return He.none;
      }
    }
    return He.set(l);
  }
}, {
  decorations: (n) => n.decorations
}), _re = /* @__PURE__ */ we.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Lre = ({ state: n, dispatch: e }) => {
  let { selection: t } = n, r = G.create(t.ranges.map((i) => n.wordAt(i.head) || G.cursor(i.head)), t.mainIndex);
  return r.eq(t) ? !1 : (e(n.update({ selection: r })), !0);
};
function Bre(n, e) {
  let { main: t, ranges: r } = n.selection, i = n.wordAt(t.head), s = i && i.from == t.from && i.to == t.to;
  for (let o = !1, l = new Uc(n.doc, e, r[r.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new Uc(n.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((a) => a.from == l.value.from))
        continue;
      if (s) {
        let a = n.wordAt(l.value.from);
        if (!a || a.from != l.value.from || a.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const zre = ({ state: n, dispatch: e }) => {
  let { ranges: t } = n.selection;
  if (t.some((s) => s.from === s.to))
    return Lre({ state: n, dispatch: e });
  let r = n.sliceDoc(t[0].from, t[0].to);
  if (n.selection.ranges.some((s) => n.sliceDoc(s.from, s.to) != r))
    return !1;
  let i = Bre(n, r);
  return i ? (e(n.update({
    selection: n.selection.addRange(G.range(i.from, i.to), !1),
    effects: we.scrollIntoView(i.to)
  })), !0) : !1;
}, du = /* @__PURE__ */ ke.define({
  combine(n) {
    return Ms(n, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new Jre(e),
      scrollToMatch: (e) => we.scrollIntoView(e)
    });
  }
});
class oD {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Mre(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new Vre(this) : new Hre(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, r) {
    let i = e.doc ? e : ct.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? ac(this, i, t, r) : lc(this, i, t, r);
  }
}
class lD {
  constructor(e) {
    this.spec = e;
  }
}
function lc(n, e, t, r) {
  return new Uc(e.doc, n.unquoted, t, r, n.caseSensitive ? void 0 : (i) => i.toLowerCase(), n.wholeWord ? Fre(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function Fre(n, e) {
  return (t, r, i, s) => ((s > t || s + i.length < r) && (s = Math.max(0, t - 2), i = n.sliceString(s, Math.min(n.length, r + 2))), (e(zm(i, t - s)) != jt.Word || e(Fm(i, t - s)) != jt.Word) && (e(Fm(i, r - s)) != jt.Word || e(zm(i, r - s)) != jt.Word));
}
class Hre extends lD {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, r) {
    let i = lc(this.spec, e, r, e.doc.length).nextOverlapping();
    if (i.done) {
      let s = Math.min(e.doc.length, t + this.spec.unquoted.length);
      i = lc(this.spec, e, 0, s).nextOverlapping();
    }
    return i.done || i.value.from == t && i.value.to == r ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, r) {
    for (let i = r; ; ) {
      let s = Math.max(t, i - 1e4 - this.spec.unquoted.length), o = lc(this.spec, e, s, i), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (s == t)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, t, r) {
    let i = this.prevMatchInRange(e, 0, t);
    return i || (i = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), i && (i.from != t || i.to != r) ? i : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let r = lc(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let s = lc(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function ac(n, e, t, r) {
  return new iD(e.doc, n.search, {
    ignoreCase: !n.caseSensitive,
    test: n.wholeWord ? $re(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, r);
}
function zm(n, e) {
  return n.slice(zn(n, e, !1), e);
}
function Fm(n, e) {
  return n.slice(e, zn(n, e));
}
function $re(n) {
  return (e, t, r) => !r[0].length || (n(zm(r.input, r.index)) != jt.Word || n(Fm(r.input, r.index)) != jt.Word) && (n(Fm(r.input, r.index + r[0].length)) != jt.Word || n(zm(r.input, r.index + r[0].length)) != jt.Word);
}
class Vre extends lD {
  nextMatch(e, t, r) {
    let i = ac(this.spec, e, r, e.doc.length).next();
    return i.done && (i = ac(this.spec, e, 0, t).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, t, r) {
    for (let i = 1; ; i++) {
      let s = Math.max(
        t,
        r - i * 1e4
        /* FindPrev.ChunkSize */
      ), o = ac(this.spec, e, s, r), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (s == t || l.from > s + 10))
        return l;
      if (s == t)
        return null;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (t, r) => {
      if (r == "&")
        return e.match[0];
      if (r == "$")
        return "$";
      for (let i = r.length; i > 0; i--) {
        let s = +r.slice(0, i);
        if (s > 0 && s < e.match.length)
          return e.match[s] + r.slice(i);
      }
      return t;
    });
  }
  matchAll(e, t) {
    let r = ac(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let s = ac(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const Jf = /* @__PURE__ */ Xe.define(), Uv = /* @__PURE__ */ Xe.define(), ol = /* @__PURE__ */ On.define({
  create(n) {
    return new Q2(M5(n).create(), null);
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(Jf) ? n = new Q2(t.value.create(), n.panel) : t.is(Uv) && (n = new Q2(n.query, t.value ? Kv : null));
    return n;
  },
  provide: (n) => $f.from(n, (e) => e.panel)
});
class Q2 {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const qre = /* @__PURE__ */ He.mark({ class: "cm-searchMatch" }), Wre = /* @__PURE__ */ He.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), jre = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.decorations = this.highlight(n.state.field(ol));
  }
  update(n) {
    let e = n.state.field(ol);
    (e != n.startState.field(ol) || n.docChanged || n.selectionSet || n.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: n, panel: e }) {
    if (!e || !n.spec.valid)
      return He.none;
    let { view: t } = this, r = new ao();
    for (let i = 0, s = t.visibleRanges, o = s.length; i < o; i++) {
      let { from: l, to: a } = s[i];
      for (; i < o - 1 && a > s[i + 1].from - 500; )
        a = s[++i].to;
      n.highlight(t.state, l, a, (c, u) => {
        let h = t.state.selection.ranges.some((f) => f.from == c && f.to == u);
        r.add(c, u, h ? Wre : qre);
      });
    }
    return r.finish();
  }
}, {
  decorations: (n) => n.decorations
});
function Rd(n) {
  return (e) => {
    let t = e.state.field(ol, !1);
    return t && t.query.spec.valid ? n(e, t) : uD(e);
  };
}
const Hm = /* @__PURE__ */ Rd((n, { query: e }) => {
  let { to: t } = n.state.selection.main, r = e.nextMatch(n.state, t, t);
  if (!r)
    return !1;
  let i = G.single(r.from, r.to), s = n.state.facet(du);
  return n.dispatch({
    selection: i,
    effects: [Gv(n, r), s.scrollToMatch(i.main, n)],
    userEvent: "select.search"
  }), cD(n), !0;
}), $m = /* @__PURE__ */ Rd((n, { query: e }) => {
  let { state: t } = n, { from: r } = t.selection.main, i = e.prevMatch(t, r, r);
  if (!i)
    return !1;
  let s = G.single(i.from, i.to), o = n.state.facet(du);
  return n.dispatch({
    selection: s,
    effects: [Gv(n, i), o.scrollToMatch(s.main, n)],
    userEvent: "select.search"
  }), cD(n), !0;
}), Ure = /* @__PURE__ */ Rd((n, { query: e }) => {
  let t = e.matchAll(n.state, 1e3);
  return !t || !t.length ? !1 : (n.dispatch({
    selection: G.create(t.map((r) => G.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), Kre = ({ state: n, dispatch: e }) => {
  let t = n.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: r, to: i } = t.main, s = [], o = 0;
  for (let l = new Uc(n.doc, n.sliceDoc(r, i)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == r && (o = s.length), s.push(G.range(l.value.from, l.value.to));
  }
  return e(n.update({
    selection: G.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, Hk = /* @__PURE__ */ Rd((n, { query: e }) => {
  let { state: t } = n, { from: r, to: i } = t.selection.main;
  if (t.readOnly)
    return !1;
  let s = e.nextMatch(t, r, r);
  if (!s)
    return !1;
  let o = s, l = [], a, c, u = [];
  o.from == r && o.to == i && (c = t.toText(e.getReplacement(o)), l.push({ from: o.from, to: o.to, insert: c }), o = e.nextMatch(t, o.from, o.to), u.push(we.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(r).number) + ".")));
  let h = n.state.changes(l);
  return o && (a = G.single(o.from, o.to).map(h), u.push(Gv(n, o)), u.push(t.facet(du).scrollToMatch(a.main, n))), n.dispatch({
    changes: h,
    selection: a,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), Gre = /* @__PURE__ */ Rd((n, { query: e }) => {
  if (n.state.readOnly)
    return !1;
  let t = e.matchAll(n.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: e.getReplacement(i) };
  });
  if (!t.length)
    return !1;
  let r = n.state.phrase("replaced $ matches", t.length) + ".";
  return n.dispatch({
    changes: t,
    effects: we.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function Kv(n) {
  return n.state.facet(du).createPanel(n);
}
function M5(n, e) {
  var t, r, i, s, o;
  let l = n.selection.main, a = l.empty || l.to > l.from + 100 ? "" : n.sliceDoc(l.from, l.to);
  if (e && !a)
    return e;
  let c = n.facet(du);
  return new oD({
    search: ((t = e?.literal) !== null && t !== void 0 ? t : c.literal) ? a : a.replace(/\n/g, "\\n"),
    caseSensitive: (r = e?.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (i = e?.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (s = e?.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e?.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function aD(n) {
  let e = Hf(n, Kv);
  return e && e.dom.querySelector("[main-field]");
}
function cD(n) {
  let e = aD(n);
  e && e == n.root.activeElement && e.select();
}
const uD = (n) => {
  let e = n.state.field(ol, !1);
  if (e && e.panel) {
    let t = aD(n);
    if (t && t != n.root.activeElement) {
      let r = M5(n.state, e.query.spec);
      r.valid && n.dispatch({ effects: Jf.of(r) }), t.focus(), t.select();
    }
  } else
    n.dispatch({ effects: [
      Uv.of(!0),
      e ? Jf.of(M5(n.state, e.query.spec)) : Xe.appendConfig.of(Zre)
    ] });
  return !0;
}, hD = (n) => {
  let e = n.state.field(ol, !1);
  if (!e || !e.panel)
    return !1;
  let t = Hf(n, Kv);
  return t && t.dom.contains(n.root.activeElement) && n.focus(), n.dispatch({ effects: Uv.of(!1) }), !0;
}, Yre = [
  { key: "Mod-f", run: uD, scope: "editor search-panel" },
  { key: "F3", run: Hm, shift: $m, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Hm, shift: $m, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: hD, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Kre },
  { key: "Mod-Alt-g", run: Tre },
  { key: "Mod-d", run: zre, preventDefault: !0 }
];
class Jre {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(ol).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Ot("input", {
      value: t.search,
      placeholder: zr(e, "Find"),
      "aria-label": zr(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Ot("input", {
      value: t.replace,
      placeholder: zr(e, "Replace"),
      "aria-label": zr(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Ot("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = Ot("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = Ot("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function r(i, s, o) {
      return Ot("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = Ot("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => Hm(e), [zr(e, "next")]),
      r("prev", () => $m(e), [zr(e, "previous")]),
      r("select", () => Ure(e), [zr(e, "all")]),
      Ot("label", null, [this.caseField, zr(e, "match case")]),
      Ot("label", null, [this.reField, zr(e, "regexp")]),
      Ot("label", null, [this.wordField, zr(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Ot("br"),
        this.replaceField,
        r("replace", () => Hk(e), [zr(e, "replace")]),
        r("replaceAll", () => Gre(e), [zr(e, "replace all")])
      ],
      Ot("button", {
        name: "close",
        onclick: () => hD(e),
        "aria-label": zr(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new oD({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Jf.of(e) }));
  }
  keydown(e) {
    Kj(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? $m : Hm)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Hk(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(Jf) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(du).top;
  }
}
function zr(n, e) {
  return n.state.phrase(e);
}
const C0 = 30, M0 = /[\s\.,:;?!]/;
function Gv(n, { from: e, to: t }) {
  let r = n.state.doc.lineAt(e), i = n.state.doc.lineAt(t).to, s = Math.max(r.from, e - C0), o = Math.min(i, t + C0), l = n.state.sliceDoc(s, o);
  if (s != r.from) {
    for (let a = 0; a < C0; a++)
      if (!M0.test(l[a + 1]) && M0.test(l[a])) {
        l = l.slice(a);
        break;
      }
  }
  if (o != i) {
    for (let a = l.length - 1; a > l.length - C0; a--)
      if (!M0.test(l[a - 1]) && M0.test(l[a])) {
        l = l.slice(0, a);
        break;
      }
  }
  return we.announce.of(`${n.state.phrase("current match")}. ${l} ${n.state.phrase("on line")} ${r.number}.`);
}
const Xre = /* @__PURE__ */ we.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), Zre = [
  ol,
  /* @__PURE__ */ Tl.low(jre),
  Xre
];
class fD {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, r, i) {
    this.state = e, this.pos = t, this.explicit = r, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = Fn(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), r = Math.max(t.from, this.pos - 250), i = t.text.slice(r - t.from, this.pos - t.from), s = i.search(dD(e, !1));
    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, t, r) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(t), r && r.onDocChange && (this.abortOnDocChange = !0));
  }
}
function $k(n) {
  let e = Object.keys(n).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function Qre(n) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of n) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      t[i[s]] = !0;
  }
  let r = $k(e) + $k(t) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function eie(n) {
  let e = n.map((i) => typeof i == "string" ? { label: i } : i), [t, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : Qre(e);
  return (i) => {
    let s = i.matchBefore(r);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: t } : null;
  };
}
function Jue(n, e) {
  return (t) => {
    for (let r = Fn(t.state).resolveInner(t.pos, -1); r; r = r.parent) {
      if (n.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(t);
  };
}
class Vk {
  constructor(e, t, r, i) {
    this.completion = e, this.source = t, this.match = r, this.score = i;
  }
}
function ga(n) {
  return n.selection.main.from;
}
function dD(n, e) {
  var t;
  let { source: r } = n, i = e && r[0] != "^", s = r[r.length - 1] != "$";
  return !i && !s ? n : new RegExp(`${i ? "^" : ""}(?:${r})${s ? "$" : ""}`, (t = n.flags) !== null && t !== void 0 ? t : n.ignoreCase ? "i" : "");
}
const Yv = /* @__PURE__ */ wo.define();
function tie(n, e, t, r) {
  let { main: i } = n.selection, s = t - i.from, o = r - i.from;
  return {
    ...n.changeByRange((l) => {
      if (l != i && t != r && n.sliceDoc(l.from + s, l.from + o) != n.sliceDoc(t, r))
        return { range: l };
      let a = n.toText(e);
      return {
        changes: { from: l.from + s, to: r == i.from ? l.to : l.from + o, insert: a },
        range: G.cursor(l.from + s + a.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
const qk = /* @__PURE__ */ new WeakMap();
function nie(n) {
  if (!Array.isArray(n))
    return n;
  let e = qk.get(n);
  return e || qk.set(n, e = eie(n)), e;
}
const Vm = /* @__PURE__ */ Xe.define(), Xf = /* @__PURE__ */ Xe.define();
class rie {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let r = Sr(e, t), i = ls(r);
      this.chars.push(r);
      let s = e.slice(t, t + i), o = s.toUpperCase();
      this.folded.push(Sr(o == s ? s.toLowerCase() : o, 0)), t += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: r, any: i, precise: s, byWord: o } = this;
    if (t.length == 1) {
      let w = Sr(e, 0), k = ls(w), C = k == e.length ? 0 : -100;
      if (w != t[0]) if (w == r[0])
        C += -200;
      else
        return null;
      return this.ret(C, [0, k]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let a = t.length, c = 0;
    if (l < 0) {
      for (let w = 0, k = Math.min(e.length, 200); w < k && c < a; ) {
        let C = Sr(e, w);
        (C == t[c] || C == r[c]) && (i[c++] = w), w += ls(C);
      }
      if (c < a)
        return null;
    }
    let u = 0, h = 0, f = !1, d = 0, p = -1, m = -1, g = /[a-z]/.test(e), b = !0;
    for (let w = 0, k = Math.min(e.length, 200), C = 0; w < k && h < a; ) {
      let M = Sr(e, w);
      l < 0 && (u < a && M == t[u] && (s[u++] = w), d < a && (M == t[d] || M == r[d] ? (d == 0 && (p = w), m = w + 1, d++) : d = 0));
      let T, N = M < 255 ? M >= 48 && M <= 57 || M >= 97 && M <= 122 ? 2 : M >= 65 && M <= 90 ? 1 : 0 : (T = P3(M)) != T.toLowerCase() ? 1 : T != T.toUpperCase() ? 2 : 0;
      (!w || N == 1 && g || C == 0 && N != 0) && (t[h] == M || r[h] == M && (f = !0) ? o[h++] = w : o.length && (b = !1)), C = N, w += ls(M);
    }
    return h == a && o[0] == 0 && b ? this.result(-100 + (f ? -200 : 0), o, e) : d == a && p == 0 ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : d == a ? this.ret(-900 - e.length, [p, m]) : h == a ? this.result(-100 + (f ? -200 : 0) + -700 + (b ? 0 : -1100), o, e) : t.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, t, r) {
    let i = [], s = 0;
    for (let o of t) {
      let l = o + (this.astral ? ls(Sr(r, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = l : (i[s++] = o, i[s++] = l);
    }
    return this.ret(e - r.length, i);
  }
}
class iie {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let t = e.slice(0, this.pattern.length), r = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, t.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const Mn = /* @__PURE__ */ ke.define({
  combine(n) {
    return Ms(n, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: sie,
      filterStrict: !1,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (r) => Wk(e(r), t(r)),
      optionClass: (e, t) => (r) => Wk(e(r), t(r)),
      addToOptions: (e, t) => e.concat(t),
      filterStrict: (e, t) => e || t
    });
  }
});
function Wk(n, e) {
  return n ? e ? n + " " + e : n : e;
}
function sie(n, e, t, r, i, s) {
  let o = n.textDirection == Wt.RTL, l = o, a = !1, c = "top", u, h, f = e.left - i.left, d = i.right - e.right, p = r.right - r.left, m = r.bottom - r.top;
  if (l && f < Math.min(p, d) ? l = !1 : !l && d < Math.min(p, f) && (l = !0), p <= (l ? f : d))
    u = Math.max(i.top, Math.min(t.top, i.bottom - m)) - e.top, h = Math.min(400, l ? f : d);
  else {
    a = !0, h = Math.min(
      400,
      (o ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let w = i.bottom - e.bottom;
    w >= m || w > e.top ? u = t.bottom - e.top : (c = "bottom", u = e.bottom - t.top);
  }
  let g = (e.bottom - e.top) / s.offsetHeight, b = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${u / g}px; max-width: ${h / b}px`,
    class: "cm-completionInfo-" + (a ? o ? "left-narrow" : "right-narrow" : l ? "left" : "right")
  };
}
function oie(n) {
  let e = n.addToOptions.slice();
  return n.icons && e.push({
    render(t) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), t.type && r.classList.add(...t.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(t, r, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let l = t.displayLabel || t.label, a = 0;
      for (let c = 0; c < s.length; ) {
        let u = s[c++], h = s[c++];
        u > a && o.appendChild(document.createTextNode(l.slice(a, u)));
        let f = o.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(l.slice(u, h))), f.className = "cm-completionMatchedText", a = h;
      }
      return a < l.length && o.appendChild(document.createTextNode(l.slice(a))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = t.detail, r;
    },
    position: 80
  }), e.sort((t, r) => t.position - r.position).map((t) => t.render);
}
function e4(n, e, t) {
  if (n <= t)
    return { from: 0, to: n };
  if (e < 0 && (e = 0), e <= n >> 1) {
    let i = Math.floor(e / t);
    return { from: i * t, to: (i + 1) * t };
  }
  let r = Math.floor((n - e) / t);
  return { from: n - (r + 1) * t, to: n - r * t };
}
class lie {
  constructor(e, t, r) {
    this.view = e, this.stateField = t, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (a) => this.placeInfo(a),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(t), { options: s, selected: o } = i.open, l = e.state.facet(Mn);
    this.optionContent = oie(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = e4(s.length, o, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (a) => {
      let { options: c } = e.state.field(t).open;
      for (let u = a.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
          this.applyCompletion(e, c[+h[1]]), a.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (a) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Mn).closeOnBlur && a.relatedTarget != e.contentDOM && e.dispatch({ effects: Xf.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != i) {
      let { options: s, selected: o, disabled: l } = r.open;
      (!i.open || i.open.options != s) && (this.range = e4(s.length, o, e.state.facet(Mn).maxRenderedOptions), this.showOptions(s, r.id)), this.updateSel(), l != ((t = i.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of t.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = e4(t.options.length, t.selected, this.view.state.facet(Mn).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: r } = t.options[t.selected], { info: i } = r;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);
      }).catch((o) => Ar(this.view.state, o, "completion info")) : this.addInfoPane(s, r);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      r.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), t = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return t && cie(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.documentElement;
      s = { left: 0, top: 0, right: o.clientWidth, bottom: o.clientHeight };
    }
    return i.top > Math.min(s.bottom, t.bottom) - 10 || i.bottom < Math.max(s.top, t.top) + 10 ? null : this.view.state.facet(Mn).positionInfo(this.view, t, i, r, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, r) {
    const i = document.createElement("ul");
    i.id = t, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (o) => {
      o.target == i && o.preventDefault();
    });
    let s = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: l, match: a } = e[o], { section: c } = l;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != s && (o > r.from || r.from == 0))
          if (s = f, typeof c != "string" && c.header)
            i.appendChild(c.header(c));
          else {
            let d = i.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      u.id = t + "-" + o, u.setAttribute("role", "option");
      let h = this.optionClass(l);
      h && (u.className = h);
      for (let f of this.optionContent) {
        let d = f(l, this.view.state, this.view, a);
        d && u.appendChild(d);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function aie(n, e) {
  return (t) => new lie(t, n, e);
}
function cie(n, e) {
  let t = n.getBoundingClientRect(), r = e.getBoundingClientRect(), i = t.height / n.offsetHeight;
  r.top < t.top ? n.scrollTop -= (t.top - r.top) / i : r.bottom > t.bottom && (n.scrollTop += (r.bottom - t.bottom) / i);
}
function jk(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
function uie(n, e) {
  let t = [], r = null, i = (c) => {
    t.push(c);
    let { section: u } = c.completion;
    if (u) {
      r || (r = []);
      let h = typeof u == "string" ? u : u.name;
      r.some((f) => f.name == h) || r.push(typeof u == "string" ? { name: h } : u);
    }
  }, s = e.facet(Mn);
  for (let c of n)
    if (c.hasResult()) {
      let u = c.result.getMatch;
      if (c.result.filter === !1)
        for (let h of c.result.options)
          i(new Vk(h, c.source, u ? u(h) : [], 1e9 - t.length));
      else {
        let h = e.sliceDoc(c.from, c.to), f, d = s.filterStrict ? new iie(h) : new rie(h);
        for (let p of c.result.options)
          if (f = d.match(p.label)) {
            let m = p.displayLabel ? u ? u(p, f.matched) : [] : f.matched;
            i(new Vk(p, c.source, m, f.score + (p.boost || 0)));
          }
      }
    }
  if (r) {
    let c = /* @__PURE__ */ Object.create(null), u = 0, h = (f, d) => {
      var p, m;
      return ((p = f.rank) !== null && p !== void 0 ? p : 1e9) - ((m = d.rank) !== null && m !== void 0 ? m : 1e9) || (f.name < d.name ? -1 : 1);
    };
    for (let f of r.sort(h))
      u -= 1e5, c[f.name] = u;
    for (let f of t) {
      let { section: d } = f.completion;
      d && (f.score += c[typeof d == "string" ? d : d.name]);
    }
  }
  let o = [], l = null, a = s.compareCompletions;
  for (let c of t.sort((u, h) => h.score - u.score || a(u.completion, h.completion))) {
    let u = c.completion;
    !l || l.label != u.label || l.detail != u.detail || l.type != null && u.type != null && l.type != u.type || l.apply != u.apply || l.boost != u.boost ? o.push(c) : jk(c.completion) > jk(l) && (o[o.length - 1] = c), l = c.completion;
  }
  return o;
}
class pc {
  constructor(e, t, r, i, s, o) {
    this.options = e, this.attrs = t, this.tooltip = r, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new pc(this.options, Uk(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, r, i, s, o) {
    if (i && !o && e.some((c) => c.isPending))
      return i.setDisabled();
    let l = uie(e, t);
    if (!l.length)
      return i && e.some((c) => c.isPending) ? i.setDisabled() : null;
    let a = t.facet(Mn).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let c = i.options[i.selected].completion;
      for (let u = 0; u < l.length; u++)
        if (l[u].completion == c) {
          a = u;
          break;
        }
    }
    return new pc(l, Uk(r, a), {
      pos: e.reduce((c, u) => u.hasResult() ? Math.min(c, u.from) : c, 1e8),
      create: gie,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new pc(this.options, this.attrs, { ...this.tooltip, pos: e.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new pc(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class qm {
  constructor(e, t, r) {
    this.active = e, this.id = t, this.open = r;
  }
  static start() {
    return new qm(pie, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, r = t.facet(Mn), s = (r.override || t.languageDataAt("autocomplete", ga(t)).map(nie)).map((a) => (this.active.find((u) => u.source == a) || new hi(
      a,
      this.active.some(
        (u) => u.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    s.length == this.active.length && s.every((a, c) => a == this.active[c]) && (s = this.active);
    let o = this.open, l = e.effects.some((a) => a.is(Jv));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !hie(s, this.active) || l ? o = pc.build(s, t, this.id, o, r, l) : o && o.disabled && !s.some((a) => a.isPending) && (o = null), !o && s.every((a) => !a.isPending) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new hi(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(mD) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new qm(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? fie : die;
  }
}
function hie(n, e) {
  if (n == e)
    return !0;
  for (let t = 0, r = 0; ; ) {
    for (; t < n.length && !n[t].hasResult(); )
      t++;
    for (; r < e.length && !e[r].hasResult(); )
      r++;
    let i = t == n.length, s = r == e.length;
    if (i || s)
      return i == s;
    if (n[t++].result != e[r++].result)
      return !1;
  }
}
const fie = {
  "aria-autocomplete": "list"
}, die = {};
function Uk(n, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return e > -1 && (t["aria-activedescendant"] = n + "-" + e), t;
}
const pie = [];
function pD(n, e) {
  if (n.isUserEvent("input.complete")) {
    let r = n.annotation(Yv);
    if (r && e.activateOnCompletion(r))
      return 12;
  }
  let t = n.isUserEvent("input.type");
  return t && e.activateOnTyping ? 5 : t ? 1 : n.isUserEvent("delete.backward") ? 2 : n.selection ? 8 : n.docChanged ? 16 : 0;
}
class hi {
  constructor(e, t, r = !1) {
    this.source = e, this.state = t, this.explicit = r;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, t) {
    let r = pD(e, t), i = this;
    (r & 8 || r & 16 && this.touches(e)) && (i = new hi(
      i.source,
      0
      /* State.Inactive */
    )), r & 4 && i.state == 0 && (i = new hi(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(e, r);
    for (let s of e.effects)
      if (s.is(Vm))
        i = new hi(i.source, 1, s.value);
      else if (s.is(Xf))
        i = new hi(
          i.source,
          0
          /* State.Inactive */
        );
      else if (s.is(Jv))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  updateFor(e, t) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(ga(e.state));
  }
}
class Oc extends hi {
  constructor(e, t, r, i, s, o) {
    super(e, 3, t), this.limit = r, this.result = i, this.from = s, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, t) {
    var r;
    if (!(t & 3))
      return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), l = ga(e.state);
    if (l > o || !i || t & 2 && (ga(e.startState) == this.from || l < this.limit))
      return new hi(
        this.source,
        t & 4 ? 1 : 0
        /* State.Inactive */
      );
    let a = e.changes.mapPos(this.limit);
    return mie(i.validFor, e.state, s, o) ? new Oc(this.source, this.explicit, a, i, s, o) : i.update && (i = i.update(i, s, o, new fD(e.state, l, !1))) ? new Oc(this.source, this.explicit, a, i, i.from, (r = i.to) !== null && r !== void 0 ? r : ga(e.state)) : new hi(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Oc(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new hi(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function mie(n, e, t, r) {
  if (!n)
    return !1;
  let i = e.sliceDoc(t, r);
  return typeof n == "function" ? n(i, t, r, e) : dD(n, !0).test(i);
}
const Jv = /* @__PURE__ */ Xe.define({
  map(n, e) {
    return n.map((t) => t.map(e));
  }
}), mD = /* @__PURE__ */ Xe.define(), Mr = /* @__PURE__ */ On.define({
  create() {
    return qm.start();
  },
  update(n, e) {
    return n.update(e);
  },
  provide: (n) => [
    G3.from(n, (e) => e.tooltip),
    we.contentAttributes.from(n, (e) => e.attrs)
  ]
});
function Xv(n, e) {
  const t = e.completion.apply || e.completion.label;
  let r = n.state.field(Mr).active.find((i) => i.source == e.source);
  return r instanceof Oc ? (typeof t == "string" ? n.dispatch({
    ...tie(n.state, t, r.from, r.to),
    annotations: Yv.of(e.completion)
  }) : t(n, e.completion, r.from, r.to), !0) : !1;
}
const gie = /* @__PURE__ */ aie(Mr, Xv);
function T0(n, e = "option") {
  return (t) => {
    let r = t.state.field(Mr, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < t.state.facet(Mn).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = SA(t, r.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, l = r.open.selected > -1 ? r.open.selected + i * (n ? 1 : -1) : n ? 0 : o - 1;
    return l < 0 ? l = e == "page" ? 0 : o - 1 : l >= o && (l = e == "page" ? o - 1 : 0), t.dispatch({ effects: mD.of(l) }), !0;
  };
}
const yie = (n) => {
  let e = n.state.field(Mr, !1);
  return n.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < n.state.facet(Mn).interactionDelay ? !1 : Xv(n, e.open.options[e.open.selected]);
}, t4 = (n) => n.state.field(Mr, !1) ? (n.dispatch({ effects: Vm.of(!0) }), !0) : !1, bie = (n) => {
  let e = n.state.field(Mr, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: Xf.of(null) }), !0);
};
class vie {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const wie = 50, xie = 1e3, kie = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of n.state.field(Mr).active)
      e.isPending && this.startQuery(e);
  }
  update(n) {
    let e = n.state.field(Mr), t = n.state.facet(Mn);
    if (!n.selectionSet && !n.docChanged && n.startState.field(Mr) == e)
      return;
    let r = n.transactions.some((s) => {
      let o = pD(s, t);
      return o & 8 || (s.selection || s.docChanged) && !(o & 3);
    });
    for (let s = 0; s < this.running.length; s++) {
      let o = this.running[s];
      if (r || o.context.abortOnDocChange && n.docChanged || o.updates.length + n.transactions.length > wie && Date.now() - o.time > xie) {
        for (let l of o.context.abortListeners)
          try {
            l();
          } catch (a) {
            Ar(this.view.state, a);
          }
        o.context.abortListeners = null, this.running.splice(s--, 1);
      } else
        o.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((s) => s.effects.some((o) => o.is(Vm))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : t.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((s) => s.isPending && !this.running.some((o) => o.active.source == s.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let s of n.transactions)
        s.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && s.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, e = n.field(Mr);
    for (let t of e.active)
      t.isPending && !this.running.some((r) => r.active.source == t.source) && this.startQuery(t);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Mn).updateSyncTime));
  }
  startQuery(n) {
    let { state: e } = this.view, t = ga(e), r = new fD(e, t, n.explicit, this.view), i = new vie(n, r);
    this.running.push(i), Promise.resolve(n.source(r)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: Xf.of(null) }), Ar(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Mn).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Mn), r = this.view.state.field(Mr);
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (s.done === void 0)
        continue;
      if (this.running.splice(i--, 1), s.done) {
        let l = ga(s.updates.length ? s.updates[0].startState : this.view.state), a = Math.min(l, s.done.from + (s.active.explicit ? 0 : 1)), c = new Oc(s.active.source, s.active.explicit, a, s.done, s.done.from, (n = s.done.to) !== null && n !== void 0 ? n : l);
        for (let u of s.updates)
          c = c.update(u, t);
        if (c.hasResult()) {
          e.push(c);
          continue;
        }
      }
      let o = r.active.find((l) => l.source == s.active.source);
      if (o && o.isPending)
        if (s.done == null) {
          let l = new hi(
            s.active.source,
            0
            /* State.Inactive */
          );
          for (let a of s.updates)
            l = l.update(a, t);
          l.isPending || e.push(l);
        } else
          this.startQuery(o);
    }
    (e.length || r.open && r.open.disabled) && this.view.dispatch({ effects: Jv.of(e) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let e = this.view.state.field(Mr, !1);
      if (e && e.tooltip && this.view.state.facet(Mn).closeOnBlur) {
        let t = e.open && SA(this.view, e.open.tooltip);
        (!t || !t.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Xf.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Vm.of(!1) }), 20), this.composing = 0;
    }
  }
}), Sie = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), Cie = /* @__PURE__ */ Tl.highest(/* @__PURE__ */ we.domEventHandlers({
  keydown(n, e) {
    let t = e.state.field(Mr, !1);
    if (!t || !t.open || t.open.disabled || t.open.selected < 0 || n.key.length > 1 || n.ctrlKey && !(Sie && n.altKey) || n.metaKey)
      return !1;
    let r = t.open.options[t.open.selected], i = t.active.find((o) => o.source == r.source), s = r.completion.commitCharacters || i.result.commitCharacters;
    return s && s.indexOf(n.key) > -1 && Xv(e, r), !1;
  }
})), gD = /* @__PURE__ */ we.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class Mie {
  constructor(e, t, r, i) {
    this.field = e, this.line = t, this.from = r, this.to = i;
  }
}
class Zv {
  constructor(e, t, r) {
    this.field = e, this.from = t, this.to = r;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, Bn.TrackDel), r = e.mapPos(this.to, 1, Bn.TrackDel);
    return t == null || r == null ? null : new Zv(this.field, t, r);
  }
}
class Qv {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let r = [], i = [t], s = e.doc.lineAt(t), o = /^\s*/.exec(s.text)[0];
    for (let a of this.lines) {
      if (r.length) {
        let c = o, u = /^\t*/.exec(a)[0].length;
        for (let h = 0; h < u; h++)
          c += e.facet(S1);
        i.push(t + c.length - u), a = c + a.slice(u);
      }
      r.push(a), t += a.length + 1;
    }
    let l = this.fieldPositions.map((a) => new Zv(a.field, i[a.line] + a.from, i[a.line] + a.to));
    return { text: r, ranges: l };
  }
  static parse(e) {
    let t = [], r = [], i = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(o); ) {
        let l = s[1] ? +s[1] : null, a = s[2] || s[3] || "", c = -1, u = a.replace(/\\[{}]/g, (h) => h[1]);
        for (let h = 0; h < t.length; h++)
          (l != null ? t[h].seq == l : u && t[h].name == u) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < t.length && (l == null || t[h].seq != null && t[h].seq < l); )
            h++;
          t.splice(h, 0, { seq: l, name: u }), c = h;
          for (let f of i)
            f.field >= c && f.field++;
        }
        for (let h of i)
          if (h.line == r.length && h.from > s.index) {
            let f = s[2] ? 3 + (s[1] || "").length : 2;
            h.from -= f, h.to -= f;
          }
        i.push(new Mie(c, r.length, s.index, s.index + u.length)), o = o.slice(0, s.index) + a + o.slice(s.index + s[0].length);
      }
      o = o.replace(/\\([{}])/g, (l, a, c) => {
        for (let u of i)
          u.line == r.length && u.from > c && (u.from--, u.to--);
        return a;
      }), r.push(o);
    }
    return new Qv(r, i);
  }
}
let Tie = /* @__PURE__ */ He.widget({ widget: /* @__PURE__ */ new class extends xo {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Aie = /* @__PURE__ */ He.mark({ class: "cm-snippetField" });
class pu {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = He.set(e.map((r) => (r.from == r.to ? Tie : Aie).range(r.from, r.to)), !0);
  }
  map(e) {
    let t = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i)
        return null;
      t.push(i);
    }
    return new pu(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((r) => r.field == this.active && r.from <= t.from && r.to >= t.to));
  }
}
const Pd = /* @__PURE__ */ Xe.define({
  map(n, e) {
    return n && n.map(e);
  }
}), Oie = /* @__PURE__ */ Xe.define(), Zf = /* @__PURE__ */ On.define({
  create() {
    return null;
  },
  update(n, e) {
    for (let t of e.effects) {
      if (t.is(Pd))
        return t.value;
      if (t.is(Oie) && n)
        return new pu(n.ranges, t.value);
    }
    return n && e.docChanged && (n = n.map(e.changes)), n && e.selection && !n.selectionInsideField(e.selection) && (n = null), n;
  },
  provide: (n) => we.decorations.from(n, (e) => e ? e.deco : He.none)
});
function e7(n, e) {
  return G.create(n.filter((t) => t.field == e).map((t) => G.range(t.from, t.to)));
}
function Eie(n) {
  let e = Qv.parse(n);
  return (t, r, i, s) => {
    let { text: o, ranges: l } = e.instantiate(t.state, i), { main: a } = t.state.selection, c = {
      changes: { from: i, to: s == a.from ? a.to : s, insert: dt.of(o) },
      scrollIntoView: !0,
      annotations: r ? [Yv.of(r), mn.userEvent.of("input.complete")] : void 0
    };
    if (l.length && (c.selection = e7(l, 0)), l.some((u) => u.field > 0)) {
      let u = new pu(l, 0), h = c.effects = [Pd.of(u)];
      t.state.field(Zf, !1) === void 0 && h.push(Xe.appendConfig.of([Zf, Pie, _ie, gD]));
    }
    t.dispatch(t.state.update(c));
  };
}
function yD(n) {
  return ({ state: e, dispatch: t }) => {
    let r = e.field(Zf, !1);
    if (!r || n < 0 && r.active == 0)
      return !1;
    let i = r.active + n, s = n > 0 && !r.ranges.some((o) => o.field == i + n);
    return t(e.update({
      selection: e7(r.ranges, i),
      effects: Pd.of(s ? null : new pu(r.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const Iie = ({ state: n, dispatch: e }) => n.field(Zf, !1) ? (e(n.update({ effects: Pd.of(null) })), !0) : !1, Die = /* @__PURE__ */ yD(1), Nie = /* @__PURE__ */ yD(-1), Rie = [
  { key: "Tab", run: Die, shift: Nie },
  { key: "Escape", run: Iie }
], Kk = /* @__PURE__ */ ke.define({
  combine(n) {
    return n.length ? n[0] : Rie;
  }
}), Pie = /* @__PURE__ */ Tl.highest(/* @__PURE__ */ nu.compute([Kk], (n) => n.facet(Kk)));
function Xue(n, e) {
  return { ...e, apply: Eie(n) };
}
const _ie = /* @__PURE__ */ we.domEventHandlers({
  mousedown(n, e) {
    let t = e.state.field(Zf, !1), r;
    if (!t || (r = e.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let i = t.ranges.find((s) => s.from <= r && s.to >= r);
    return !i || i.field == t.active ? !1 : (e.dispatch({
      selection: e7(t.ranges, i.field),
      effects: Pd.of(t.ranges.some((s) => s.field > i.field) ? new pu(t.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), Qf = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, ia = /* @__PURE__ */ Xe.define({
  map(n, e) {
    let t = e.mapPos(n, -1, Bn.TrackAfter);
    return t ?? void 0;
  }
}), t7 = /* @__PURE__ */ new class extends Sa {
}();
t7.startSide = 1;
t7.endSide = -1;
const bD = /* @__PURE__ */ On.define({
  create() {
    return ht.empty;
  },
  update(n, e) {
    if (n = n.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      n = n.update({ filter: (r) => r >= t.from && r <= t.to });
    }
    for (let t of e.effects)
      t.is(ia) && (n = n.update({ add: [t7.range(t.value, t.value + 1)] }));
    return n;
  }
});
function Lie() {
  return [zie, bD];
}
const n4 = "()[]{}<>«»»«［］｛｝";
function vD(n) {
  for (let e = 0; e < n4.length; e += 2)
    if (n4.charCodeAt(e) == n)
      return n4.charAt(e + 1);
  return P3(n < 128 ? n : n + 1);
}
function wD(n, e) {
  return n.languageDataAt("closeBrackets", e)[0] || Qf;
}
const Bie = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), zie = /* @__PURE__ */ we.inputHandler.of((n, e, t, r) => {
  if ((Bie ? n.composing : n.compositionStarted) || n.state.readOnly)
    return !1;
  let i = n.state.selection.main;
  if (r.length > 2 || r.length == 2 && ls(Sr(r, 0)) == 1 || e != i.from || t != i.to)
    return !1;
  let s = $ie(n.state, r);
  return s ? (n.dispatch(s), !0) : !1;
}), Fie = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let r = wD(n, n.selection.main.head).brackets || Qf.brackets, i = null, s = n.changeByRange((o) => {
    if (o.empty) {
      let l = Vie(n.doc, o.head);
      for (let a of r)
        if (a == l && sg(n.doc, o.head) == vD(Sr(a, 0)))
          return {
            changes: { from: o.head - a.length, to: o.head + a.length },
            range: G.cursor(o.head - a.length)
          };
    }
    return { range: i = o };
  });
  return i || e(n.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, Hie = [
  { key: "Backspace", run: Fie }
];
function $ie(n, e) {
  let t = wD(n, n.selection.main.head), r = t.brackets || Qf.brackets;
  for (let i of r) {
    let s = vD(Sr(i, 0));
    if (e == i)
      return s == i ? jie(n, i, r.indexOf(i + i + i) > -1, t) : qie(n, i, s, t.before || Qf.before);
    if (e == s && xD(n, n.selection.main.from))
      return Wie(n, i, s);
  }
  return null;
}
function xD(n, e) {
  let t = !1;
  return n.field(bD).between(0, n.doc.length, (r) => {
    r == e && (t = !0);
  }), t;
}
function sg(n, e) {
  let t = n.sliceString(e, e + 2);
  return t.slice(0, ls(Sr(t, 0)));
}
function Vie(n, e) {
  let t = n.sliceString(e - 2, e);
  return ls(Sr(t, 0)) == t.length ? t : t.slice(1);
}
function qie(n, e, t, r) {
  let i = null, s = n.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: ia.of(o.to + e.length),
        range: G.range(o.anchor + e.length, o.head + e.length)
      };
    let l = sg(n.doc, o.head);
    return !l || /\s/.test(l) || r.indexOf(l) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: ia.of(o.head + e.length),
      range: G.cursor(o.head + e.length)
    } : { range: i = o };
  });
  return i ? null : n.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Wie(n, e, t) {
  let r = null, i = n.changeByRange((s) => s.empty && sg(n.doc, s.head) == t ? {
    changes: { from: s.head, to: s.head + t.length, insert: t },
    range: G.cursor(s.head + t.length)
  } : r = { range: s });
  return r ? null : n.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function jie(n, e, t, r) {
  let i = r.stringPrefixes || Qf.stringPrefixes, s = null, o = n.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: ia.of(l.to + e.length),
        range: G.range(l.anchor + e.length, l.head + e.length)
      };
    let a = l.head, c = sg(n.doc, a), u;
    if (c == e) {
      if (Gk(n, a))
        return {
          changes: { insert: e + e, from: a },
          effects: ia.of(a + e.length),
          range: G.cursor(a + e.length)
        };
      if (xD(n, a)) {
        let f = t && n.sliceDoc(a, a + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: a, to: a + f.length, insert: f },
          range: G.cursor(a + f.length)
        };
      }
    } else {
      if (t && n.sliceDoc(a - 2 * e.length, a) == e + e && (u = Yk(n, a - 2 * e.length, i)) > -1 && Gk(n, u))
        return {
          changes: { insert: e + e + e + e, from: a },
          effects: ia.of(a + e.length),
          range: G.cursor(a + e.length)
        };
      if (n.charCategorizer(a)(c) != jt.Word && Yk(n, a, i) > -1 && !Uie(n, a, e, i))
        return {
          changes: { insert: e + e, from: a },
          effects: ia.of(a + e.length),
          range: G.cursor(a + e.length)
        };
    }
    return { range: s = l };
  });
  return s ? null : n.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Gk(n, e) {
  let t = Fn(n).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function Uie(n, e, t, r) {
  let i = Fn(n).resolveInner(e, -1), s = r.reduce((o, l) => Math.max(o, l.length), 0);
  for (let o = 0; o < 5; o++) {
    let l = n.sliceDoc(i.from, Math.min(i.to, i.from + t.length + s)), a = l.indexOf(t);
    if (!a || a > -1 && r.indexOf(l.slice(0, a)) > -1) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > t.length + a; ) {
        if (n.sliceDoc(u.to - t.length, u.to) == t)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return !1;
}
function Yk(n, e, t) {
  let r = n.charCategorizer(e);
  if (r(n.sliceDoc(e - 1, e)) != jt.Word)
    return e;
  for (let i of t) {
    let s = e - i.length;
    if (n.sliceDoc(s, e) == i && r(n.sliceDoc(s - 1, s)) != jt.Word)
      return s;
  }
  return -1;
}
function Kie(n = {}) {
  return [
    Cie,
    Mr,
    Mn.of(n),
    kie,
    Gie,
    gD
  ];
}
const kD = [
  { key: "Ctrl-Space", run: t4 },
  { mac: "Alt-`", run: t4 },
  { mac: "Alt-i", run: t4 },
  { key: "Escape", run: bie },
  { key: "ArrowDown", run: /* @__PURE__ */ T0(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ T0(!1) },
  { key: "PageDown", run: /* @__PURE__ */ T0(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ T0(!1, "page") },
  { key: "Enter", run: yie }
], Gie = /* @__PURE__ */ Tl.highest(/* @__PURE__ */ nu.computeN([Mn], (n) => n.facet(Mn).defaultKeymap ? [kD] : []));
class Jk {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.diagnostic = r;
  }
}
class Xl {
  constructor(e, t, r) {
    this.diagnostics = e, this.panel = t, this.selected = r;
  }
  static init(e, t, r) {
    let i = r.facet(ed).markerFilter;
    i && (e = i(e, r));
    let s = e.slice().sort((u, h) => u.from - h.from || u.to - h.to), o = new ao(), l = [], a = 0;
    for (let u = 0; ; ) {
      let h = u == s.length ? null : s[u];
      if (!h && !l.length)
        break;
      let f, d;
      for (l.length ? (f = a, d = l.reduce((m, g) => Math.min(m, g.to), h && h.from > f ? h.from : 1e8)) : (f = h.from, d = h.to, l.push(h), u++); u < s.length; ) {
        let m = s[u];
        if (m.from == f && (m.to > m.from || m.to == f))
          l.push(m), u++, d = Math.min(m.to, d);
        else {
          d = Math.min(m.from, d);
          break;
        }
      }
      let p = lse(l);
      if (l.some((m) => m.from == m.to || m.from == m.to - 1 && r.doc.lineAt(m.from).to == m.from))
        o.add(f, f, He.widget({
          widget: new rse(p),
          diagnostics: l.slice()
        }));
      else {
        let m = l.reduce((g, b) => b.markClass ? g + " " + b.markClass : g, "");
        o.add(f, d, He.mark({
          class: "cm-lintRange cm-lintRange-" + p + m,
          diagnostics: l.slice(),
          inclusiveEnd: l.some((g) => g.to > d)
        }));
      }
      a = d;
      for (let m = 0; m < l.length; m++)
        l[m].to <= a && l.splice(m--, 1);
    }
    let c = o.finish();
    return new Xl(c, t, Kc(c));
  }
}
function Kc(n, e = null, t = 0) {
  let r = null;
  return n.between(t, 1e9, (i, s, { spec: o }) => {
    if (!(e && o.diagnostics.indexOf(e) < 0))
      if (!r)
        r = new Jk(i, s, e || o.diagnostics[0]);
      else {
        if (o.diagnostics.indexOf(r.diagnostic) < 0)
          return !1;
        r = new Jk(r.from, s, r.diagnostic);
      }
  }), r;
}
function Yie(n, e) {
  let t = e.pos, r = e.end || t, i = n.state.facet(ed).hideOn(n, t, r);
  if (i != null)
    return i;
  let s = n.startState.doc.lineAt(e.pos);
  return !!(n.effects.some((o) => o.is(SD)) || n.changes.touchesRange(s.from, Math.max(s.to, r)));
}
function Jie(n, e) {
  return n.field(Jr, !1) ? e : e.concat(Xe.appendConfig.of(ase));
}
const SD = /* @__PURE__ */ Xe.define(), n7 = /* @__PURE__ */ Xe.define(), CD = /* @__PURE__ */ Xe.define(), Jr = /* @__PURE__ */ On.define({
  create() {
    return new Xl(He.none, null, null);
  },
  update(n, e) {
    if (e.docChanged && n.diagnostics.size) {
      let t = n.diagnostics.map(e.changes), r = null, i = n.panel;
      if (n.selected) {
        let s = e.changes.mapPos(n.selected.from, 1);
        r = Kc(t, n.selected.diagnostic, s) || Kc(t, null, s);
      }
      !t.size && i && e.state.facet(ed).autoPanel && (i = null), n = new Xl(t, i, r);
    }
    for (let t of e.effects)
      if (t.is(SD)) {
        let r = e.state.facet(ed).autoPanel ? t.value.length ? td.open : null : n.panel;
        n = Xl.init(t.value, r, e.state);
      } else t.is(n7) ? n = new Xl(n.diagnostics, t.value ? td.open : null, n.selected) : t.is(CD) && (n = new Xl(n.diagnostics, n.panel, t.value));
    return n;
  },
  provide: (n) => [
    $f.from(n, (e) => e.panel),
    we.decorations.from(n, (e) => e.diagnostics)
  ]
}), Xie = /* @__PURE__ */ He.mark({ class: "cm-lintRange cm-lintRange-active" });
function Zie(n, e, t) {
  let { diagnostics: r } = n.state.field(Jr), i, s = -1, o = -1;
  r.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (a, c, { spec: u }) => {
    if (e >= a && e <= c && (a == c || (e > a || t > 0) && (e < c || t < 0)))
      return i = u.diagnostics, s = a, o = c, !1;
  });
  let l = n.state.facet(ed).tooltipFilter;
  return i && l && (i = l(i, n.state)), i ? {
    pos: s,
    end: o,
    above: n.state.doc.lineAt(s).to < o,
    create() {
      return { dom: Qie(n, i) };
    }
  } : null;
}
function Qie(n, e) {
  return Ot("ul", { class: "cm-tooltip-lint" }, e.map((t) => TD(n, t, !1)));
}
const ese = (n) => {
  let e = n.state.field(Jr, !1);
  (!e || !e.panel) && n.dispatch({ effects: Jie(n.state, [n7.of(!0)]) });
  let t = Hf(n, td.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, Xk = (n) => {
  let e = n.state.field(Jr, !1);
  return !e || !e.panel ? !1 : (n.dispatch({ effects: n7.of(!1) }), !0);
}, tse = (n) => {
  let e = n.state.field(Jr, !1);
  if (!e)
    return !1;
  let t = n.state.selection.main, r = e.diagnostics.iter(t.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == t.from && r.to == t.to) ? !1 : (n.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, nse = [
  { key: "Mod-Shift-m", run: ese, preventDefault: !0 },
  { key: "F8", run: tse }
], ed = /* @__PURE__ */ ke.define({
  combine(n) {
    return Object.assign({ sources: n.map((e) => e.source).filter((e) => e != null) }, Ms(n.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, t) => e ? t ? (r) => e(r) || t(r) : e : t
    }));
  }
});
function MD(n) {
  let e = [];
  if (n)
    e: for (let { name: t } of n) {
      for (let r = 0; r < t.length; r++) {
        let i = t[r];
        if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function TD(n, e, t) {
  var r;
  let i = t ? MD(e.actions) : [];
  return Ot("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Ot("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(n) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((s, o) => {
    let l = !1, a = (f) => {
      if (f.preventDefault(), l)
        return;
      l = !0;
      let d = Kc(n.state.field(Jr).diagnostics, e);
      d && s.apply(n, d.from, d.to);
    }, { name: c } = s, u = i[o] ? c.indexOf(i[o]) : -1, h = u < 0 ? c : [
      c.slice(0, u),
      Ot("u", c.slice(u, u + 1)),
      c.slice(u + 1)
    ];
    return Ot("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: a,
      onmousedown: a,
      "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[o]})"`}.`
    }, h);
  }), e.source && Ot("div", { class: "cm-diagnosticSource" }, e.source));
}
class rse extends xo {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return Ot("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class Zk {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = TD(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class td {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (i) => {
      if (i.keyCode == 27)
        Xk(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = MD(s.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == i.keyCode) {
            let a = Kc(this.view.state.field(Jr).diagnostics, s);
            a && s.actions[l].apply(e, a.from, a.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = Ot("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: r
    }), this.dom = Ot("div", { class: "cm-panel-lint" }, this.list, Ot("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => Xk(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Jr).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Jr), r = 0, i = !1, s = null, o = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (l, a, { spec: c }) => {
      for (let u of c.diagnostics) {
        if (o.has(u))
          continue;
        o.add(u);
        let h = -1, f;
        for (let d = r; d < this.items.length; d++)
          if (this.items[d].diagnostic == u) {
            h = d;
            break;
          }
        h < 0 ? (f = new Zk(this.view, u), this.items.splice(r, 0, f), i = !0) : (f = this.items[h], h > r && (this.items.splice(r, h - r), i = !0)), t && f.diagnostic == t.diagnostic ? f.dom.hasAttribute("aria-selected") || (f.dom.setAttribute("aria-selected", "true"), s = f) : f.dom.hasAttribute("aria-selected") && f.dom.removeAttribute("aria-selected"), r++;
      }
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new Zk(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: l, panel: a }) => {
        let c = a.height / this.list.offsetHeight;
        l.top < a.top ? this.list.scrollTop -= (a.top - l.top) / c : l.bottom > a.bottom && (this.list.scrollTop += (l.bottom - a.bottom) / c);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          t();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Jr), r = Kc(t.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: CD.of(r)
    });
  }
  static open(e) {
    return new td(e);
  }
}
function ise(n, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(n)}</svg>')`;
}
function A0(n) {
  return ise(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const sse = /* @__PURE__ */ we.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ A0("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ A0("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ A0("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ A0("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function ose(n) {
  return n == "error" ? 4 : n == "warning" ? 3 : n == "info" ? 2 : 1;
}
function lse(n) {
  let e = "hint", t = 1;
  for (let r of n) {
    let i = ose(r.severity);
    i > t && (t = i, e = r.severity);
  }
  return e;
}
const ase = [
  Jr,
  /* @__PURE__ */ we.decorations.compute([Jr], (n) => {
    let { selected: e, panel: t } = n.field(Jr);
    return !e || !t || e.from == e.to ? He.none : He.set([
      Xie.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ NU(Zie, { hideOn: Yie }),
  sse
], cse = [
  qU(),
  UU(),
  cU(),
  ene(),
  OK(),
  vA(),
  rU(),
  ct.allowMultipleSelections.of(!0),
  pK(),
  VA(NK, { fallback: !0 }),
  FK(),
  Lie(),
  Kie(),
  xU(),
  CU(),
  mU(),
  Ire(),
  nu.of([
    ...Hie,
    ...ZI,
    ...Yre,
    ...cne,
    ...CK,
    ...kD,
    ...nse
  ])
];
function use(n = {}) {
  return new Ut({
    view(e) {
      return new hse(e, n);
    }
  });
}
class hse {
  constructor(e, t) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = t.width) !== null && r !== void 0 ? r : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let s = (o) => {
        this[i](o);
      };
      return e.dom.addEventListener(i, s), { name: i, handler: s };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
  }
  update(e, t) {
    this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, r, i = this.editorView.dom, s = i.getBoundingClientRect(), o = s.width / i.offsetWidth, l = s.height / i.offsetHeight;
    if (t) {
      let h = e.nodeBefore, f = e.nodeAfter;
      if (h || f) {
        let d = this.editorView.nodeDOM(this.cursorPos - (h ? h.nodeSize : 0));
        if (d) {
          let p = d.getBoundingClientRect(), m = h ? p.bottom : p.top;
          h && f && (m = (m + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let g = this.width / 2 * l;
          r = { left: p.left, right: p.right, top: m - g, bottom: m + g };
        }
      }
    }
    if (!r) {
      let h = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * o;
      r = { left: h.left - f, right: h.left + f, top: h.top, bottom: h.bottom };
    }
    let a = this.editorView.dom.offsetParent;
    this.element || (this.element = a.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
    let c, u;
    if (!a || a == document.body && getComputedStyle(a).position == "static")
      c = -pageXOffset, u = -pageYOffset;
    else {
      let h = a.getBoundingClientRect(), f = h.width / a.offsetWidth, d = h.height / a.offsetHeight;
      c = h.left - a.scrollLeft * f, u = h.top - a.scrollTop * d;
    }
    this.element.style.left = (r.left - c) / o + "px", this.element.style.top = (r.top - u) / l + "px", this.element.style.width = (r.right - r.left) / o + "px", this.element.style.height = (r.bottom - r.top) / l + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i = r && r.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, t, e) : i;
    if (t && !s) {
      let o = t.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let l = hC(this.editorView.state.doc, o, this.editorView.dragging.slice);
        l != null && (o = l);
      }
      this.setCursor(o), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
  }
}
class rn extends Ge {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    return rn.valid(r) ? new rn(r) : Ge.near(r);
  }
  content() {
    return me.empty;
  }
  eq(e) {
    return e instanceof rn && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new rn(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new r7(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !fse(e) || !dse(e))
      return !1;
    let r = t.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = t.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, r = !1) {
    e: for (; ; ) {
      if (!r && rn.valid(e))
        return e;
      let i = e.pos, s = null;
      for (let o = e.depth; ; o--) {
        let l = e.node(o);
        if (t > 0 ? e.indexAfter(o) < l.childCount : e.index(o) > 0) {
          s = l.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1);
          break;
        } else if (o == 0)
          return null;
        i += t;
        let a = e.doc.resolve(i);
        if (rn.valid(a))
          return a;
      }
      for (; ; ) {
        let o = t > 0 ? s.firstChild : s.lastChild;
        if (!o) {
          if (s.isAtom && !s.isText && !$e.isSelectable(s)) {
            e = e.doc.resolve(i + s.nodeSize * t), r = !1;
            continue e;
          }
          break;
        }
        s = o, i += t;
        let l = e.doc.resolve(i);
        if (rn.valid(l))
          return l;
      }
      return null;
    }
  }
}
rn.prototype.visible = !1;
rn.findFrom = rn.findGapCursorFrom;
Ge.jsonID("gapcursor", rn);
class r7 {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new r7(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return rn.valid(t) ? new rn(t) : Ge.near(t);
  }
}
function fse(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), r = n.node(e);
    if (t == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function dse(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), r = n.node(e);
    if (t == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function pse() {
  return new Ut({
    props: {
      decorations: bse,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && rn.valid(t) ? new rn(t) : null;
      },
      handleClick: gse,
      handleKeyDown: mse,
      handleDOMEvents: { beforeinput: yse }
    }
  });
}
const mse = p3({
  ArrowLeft: O0("horiz", -1),
  ArrowRight: O0("horiz", 1),
  ArrowUp: O0("vert", -1),
  ArrowDown: O0("vert", 1)
});
function O0(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, s) {
    let o = r.selection, l = e > 0 ? o.$to : o.$from, a = o.empty;
    if (o instanceof Ee) {
      if (!s.endOfTextblock(t) || l.depth == 0)
        return !1;
      a = !1, l = r.doc.resolve(e > 0 ? l.after() : l.before());
    }
    let c = rn.findGapCursorFrom(l, e, a);
    return c ? (i && i(r.tr.setSelection(new rn(c))), !0) : !1;
  };
}
function gse(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let r = n.state.doc.resolve(e);
  if (!rn.valid(r))
    return !1;
  let i = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return i && i.inside > -1 && $e.isSelectable(n.state.doc.nodeAt(i.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new rn(r))), !0);
}
function yse(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof rn))
    return !1;
  let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = ce.empty;
  for (let o = r.length - 1; o >= 0; o--)
    i = ce.from(r[o].createAndFill(null, i));
  let s = n.state.tr.replace(t.pos, t.pos, new me(i, 0, 0));
  return s.setSelection(Ee.near(s.doc.resolve(t.pos + 1))), n.dispatch(s), !1;
}
function bse(n) {
  if (!(n.selection instanceof rn))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", It.create(n.doc, [mr.widget(n.selection.head, e, { key: "gapcursor" })]);
}
function i7(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-cursor",
      ...e
    }
  }), n;
}
const og = Mt(
  {},
  "dropCursorConfig"
);
i7(og, {
  displayName: "Ctx<dropCursor>"
});
const AD = kn(
  (n) => use(n.get(og.key))
);
i7(AD, {
  displayName: "Prose<dropCursor>"
});
const OD = kn(() => pse());
i7(OD, {
  displayName: "Prose<gapCursor>"
});
const vse = [
  og,
  AD,
  OD
];
function wse(n) {
  var e;
  const t = (e = void 0) != null ? e : !1;
  let r = typeof document > "u" ? null : document.createElement("div");
  return new Ut({
    key: xse,
    view: (i) => {
      t !== !0 && Mse(i.state.schema, t || []);
      const s = i.dom.ownerDocument;
      r = r || document.createElement("div");
      const o = r, l = () => {
        Sse(i, o);
      };
      let a;
      return window.ResizeObserver && (a = new window.ResizeObserver(() => l()), a.observe(i.dom)), s.addEventListener("selectionchange", l), {
        update: () => {
          l();
        },
        destroy: () => {
          s.removeEventListener("selectionchange", l), a && a.unobserve(i.dom);
        }
      };
    },
    props: {
      handleKeyDown: (i, s) => {
        var o;
        const { selection: l } = i.state;
        if (s.altKey || s.ctrlKey || s.metaKey || s.shiftKey || s.isComposing || !["ArrowLeft", "ArrowRight"].includes(s.key) || !T5(l) || !l.empty)
          return !1;
        const a = l.$head, [c, u] = ED(a), h = i.state.storedMarks || a.marks();
        if (c && u && !nt.sameSet(c, u)) {
          if (s.key === "ArrowLeft" && !nt.sameSet(c, h))
            return i.dispatch(i.state.tr.setStoredMarks(c)), !0;
          if (s.key === "ArrowRight" && !nt.sameSet(u, h))
            return i.dispatch(i.state.tr.setStoredMarks(u)), !0;
        }
        return s.key === "ArrowLeft" && a.textOffset === 1 ? (i.dispatch(
          i.state.tr.setSelection(Ee.create(i.state.doc, a.pos - 1)).setStoredMarks(a.marks())
        ), !0) : s.key === "ArrowRight" && a.textOffset + 1 === ((o = a.parent.maybeChild(a.index())) == null ? void 0 : o.nodeSize) ? (i.dispatch(
          i.state.tr.setSelection(Ee.create(i.state.doc, a.pos + 1)).setStoredMarks(a.marks())
        ), !0) : !1;
      },
      decorations: (i) => {
        if (!(!r || !T5(i.selection) || !i.selection.empty))
          return It.create(i.doc, [
            mr.widget(0, r, {
              key: "prosemirror-virtual-cursor"
            })
          ]);
      },
      attributes: {
        class: "virtual-cursor-enabled"
      }
    }
  });
}
var xse = new en("prosemirror-virtual-cursor");
function kse(n, e) {
  var t;
  const r = window.getSelection();
  if (!r || !r.rangeCount)
    return null;
  const i = (t = r?.getRangeAt(0)) == null ? void 0 : t.cloneRange();
  if (!i)
    return null;
  i.collapse(e);
  const s = i.getClientRects(), o = s?.length ? s[s.length - 1] : null;
  return o?.height ? o : n.coordsAtPos(n.state.selection.head);
}
function ED(n) {
  const e = n.index(), t = n.parent.maybeChild(e);
  let r = n.textOffset ? t : null;
  return !r && e > 0 && (r = n.parent.maybeChild(e - 1)), [r?.marks, t?.marks];
}
function T5(n) {
  return n && typeof n == "object" && "$cursor" in n;
}
function Sse(n, e) {
  if (!n || !n.dom || n.isDestroyed || !e)
    return;
  const { state: t, dom: r } = n, { selection: i } = t;
  if (!T5(i))
    return;
  const s = kse(n, i.$head === i.$from);
  if (!s)
    return e;
  const o = r.getBoundingClientRect();
  let l = "prosemirror-virtual-cursor";
  const a = t.selection.$head, [c, u] = ED(a), h = t.storedMarks || a.marks();
  i.$cursor && c && u && h && !nt.sameSet(c, u) && (nt.sameSet(c, h) ? l += " prosemirror-virtual-cursor-left" : nt.sameSet(u, h) && (l += " prosemirror-virtual-cursor-right")), e.className = l, Cse(e, "prosemirror-virtual-cursor-animation"), e.style.height = `${s.bottom - s.top}px`, e.style.left = `${s.left - o.left}px`, e.style.top = `${s.top - o.top}px`;
}
function Cse(n, e) {
  n.classList.remove(e), n.offsetWidth, n.classList.add(e);
}
function Mse(n, e) {
  for (const [t, r] of Object.entries(n.marks))
    r.spec.inclusive === !1 && !e.includes(t) && console.warn(
      `[prosemirror-virtual-cursor] Virtual cursor does not work well with marks that have inclusive set to false. Please consider removing the inclusive option from the "${t}" mark or adding it to the "skipWarning" option.`
    );
}
var Tse = Object.defineProperty, Qk = Object.getOwnPropertySymbols, Ase = Object.prototype.hasOwnProperty, Ose = Object.prototype.propertyIsEnumerable, e9 = (n, e, t) => e in n ? Tse(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Ese = (n, e) => {
  for (var t in e || (e = {}))
    Ase.call(e, t) && e9(n, t, e[t]);
  if (Qk)
    for (var t of Qk(e))
      Ose.call(e, t) && e9(n, t, e[t]);
  return n;
};
function ID(n, e) {
  return Object.assign(n, {
    meta: Ese({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const Ise = {
  imageIcon: "🌌",
  uploadButton: "Upload",
  confirmButton: "⏎",
  uploadPlaceholderText: "/Paste",
  onUpload: (n) => Promise.resolve(URL.createObjectURL(n))
}, lg = Mt(
  Ise,
  "inlineImageConfigCtx"
);
ID(lg, {
  displayName: "Config<image-inline>",
  group: "ImageInline"
});
function Op({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
Op.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const Dse = FE("abcdefg", 8), Nse = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setLink: {
      type: Function,
      required: !0
    },
    imageIcon: {
      type: String,
      required: !1
    },
    uploadButton: {
      type: String,
      required: !1
    },
    confirmButton: {
      type: String,
      required: !1
    },
    uploadPlaceholderText: {
      type: String,
      required: !1
    },
    onUpload: {
      type: Function,
      required: !0
    }
  },
  setup({
    readonly: n,
    src: e,
    setLink: t,
    onUpload: r,
    imageIcon: i,
    uploadButton: s,
    confirmButton: o,
    uploadPlaceholderText: l,
    className: a
  }) {
    var c, u;
    const h = Ae(!1), f = Ae(), d = Ae((c = e.value) != null ? c : ""), p = Ae(Dse()), m = Ae(((u = e.value) == null ? void 0 : u.length) !== 0), g = (C) => {
      const T = C.target.value;
      m.value = T.length !== 0, d.value = T;
    }, b = (C) => {
      var M, T;
      C.key === "Enter" && t((T = (M = f.value) == null ? void 0 : M.value) != null ? T : "");
    }, w = () => {
      var C, M;
      t((M = (C = f.value) == null ? void 0 : C.value) != null ? M : "");
    }, k = (C) => {
      var M;
      const T = (M = C.target.files) == null ? void 0 : M[0];
      T && r(T).then((N) => {
        N && (t(N), m.value = !0);
      }).catch((N) => {
        console.error("An error occurred while uploading image"), console.error(N);
      });
    };
    return () => /* @__PURE__ */ j("div", { class: Hn("image-edit", a) }, /* @__PURE__ */ j(Op, { icon: i, class: "image-icon" }), /* @__PURE__ */ j("div", { class: Hn("link-importer", h.value && "focus") }, /* @__PURE__ */ j(
      "input",
      {
        ref: f,
        draggable: "true",
        onDragstart: (C) => {
          C.preventDefault(), C.stopPropagation();
        },
        disabled: n.value,
        class: "link-input-area",
        value: d.value,
        onInput: g,
        onKeydown: b,
        onFocus: () => h.value = !0,
        onBlur: () => h.value = !1
      }
    ), !m.value && /* @__PURE__ */ j("div", { class: "placeholder" }, /* @__PURE__ */ j(
      "input",
      {
        disabled: n.value,
        class: "hidden",
        id: p.value,
        type: "file",
        accept: "image/*",
        onChange: k
      }
    ), /* @__PURE__ */ j("label", { class: "uploader", for: p.value }, /* @__PURE__ */ j(Op, { icon: s })), /* @__PURE__ */ j("span", { class: "text", onClick: () => {
      var C;
      return (C = f.value) == null ? void 0 : C.focus();
    } }, l))), d.value && /* @__PURE__ */ j("div", { class: "confirm", onClick: () => w() }, /* @__PURE__ */ j(Op, { icon: o })));
  }
}), Rse = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    alt: {
      type: Object,
      required: !0
    },
    title: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { src: e, alt: t, title: r } = n;
    return () => {
      var i;
      return (i = e.value) != null && i.length ? /* @__PURE__ */ j(
        "img",
        {
          class: "image-inline",
          src: e.value,
          alt: t.value,
          title: r.value
        }
      ) : /* @__PURE__ */ j(
        Nse,
        {
          src: n.src,
          selected: n.selected,
          readonly: n.readonly,
          setLink: (s) => n.setAttr("src", s),
          imageIcon: n.config.imageIcon,
          uploadButton: n.config.uploadButton,
          confirmButton: n.config.confirmButton,
          uploadPlaceholderText: n.config.uploadPlaceholderText,
          onUpload: n.config.onUpload,
          className: "empty-image-inline"
        }
      );
    };
  }
}), DD = yd(
  La.node,
  (n) => (e, t, r) => {
    const i = Ae(e.attrs.src), s = Ae(e.attrs.alt), o = Ae(e.attrs.title), l = Ae(!1), a = Ae(!t.editable), c = (g, b) => {
      if (!t.editable) return;
      const w = r();
      w != null && t.dispatch(
        t.state.tr.setNodeAttribute(
          w,
          g,
          g === "src" ? Ui.sanitize(b) : b
        )
      );
    }, u = n.get(lg.key), h = ji(Rse, {
      src: i,
      alt: s,
      title: o,
      selected: l,
      readonly: a,
      setAttr: c,
      config: u
    }), f = document.createElement("span");
    f.className = "milkdown-image-inline", h.mount(f);
    const d = cu(() => {
      l.value ? f.classList.add("selected") : f.classList.remove("selected");
    }), p = u.proxyDomURL, m = (g) => {
      if (!p)
        i.value = g.attrs.src;
      else {
        const b = p(g.attrs.src);
        typeof b == "string" ? i.value = b : b.then((w) => {
          i.value = w;
        }).catch(console.error);
      }
      s.value = g.attrs.alt, o.value = g.attrs.title;
    };
    return m(e), {
      dom: f,
      update: (g) => g.type !== e.type ? !1 : (m(g), !0),
      stopEvent: (g) => g.target instanceof HTMLInputElement,
      selectNode: () => {
        l.value = !0;
      },
      deselectNode: () => {
        l.value = !1;
      },
      destroy: () => {
        d(), h.unmount(), f.remove();
      }
    };
  }
);
ID(DD, {
  displayName: "NodeView<image-inline>",
  group: "ImageInline"
});
const Pse = [
  lg,
  DD
];
class jr {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(e, t, r) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = t, this.end = r;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, t) {
    return t ? !e || !e.loc || !t.loc || e.loc.lexer !== t.loc.lexer ? null : new jr(e.loc.lexer, e.loc.start, t.loc.end) : e && e.loc;
  }
}
class bi {
  // don't expand the token
  // used in \noexpand
  constructor(e, t) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = t;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, t) {
    return new bi(t, jr.range(this, e));
  }
}
class se {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(e, t) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var r = "KaTeX parse error: " + e, i, s, o = t && t.loc;
    if (o && o.start <= o.end) {
      var l = o.lexer.input;
      i = o.start, s = o.end, i === l.length ? r += " at end of input: " : r += " at position " + (i + 1) + ": ";
      var a = l.slice(i, s).replace(/[^]/g, "$&̲"), c;
      i > 15 ? c = "…" + l.slice(i - 15, i) : c = l.slice(0, i);
      var u;
      s + 15 < l.length ? u = l.slice(s, s + 15) + "…" : u = l.slice(s), r += c + a + u;
    }
    var h = new Error(r);
    return h.name = "ParseError", h.__proto__ = se.prototype, h.position = i, i != null && s != null && (h.length = s - i), h.rawMessage = e, h;
  }
}
se.prototype.__proto__ = Error.prototype;
var _se = function(e, t) {
  return e.indexOf(t) !== -1;
}, Lse = function(e, t) {
  return e === void 0 ? t : e;
}, Bse = /([A-Z])/g, zse = function(e) {
  return e.replace(Bse, "-$1").toLowerCase();
}, Fse = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, Hse = /[&><"']/g;
function $se(n) {
  return String(n).replace(Hse, (e) => Fse[e]);
}
var ND = function n(e) {
  return e.type === "ordgroup" || e.type === "color" ? e.body.length === 1 ? n(e.body[0]) : e : e.type === "font" ? n(e.body) : e;
}, Vse = function(e) {
  var t = ND(e);
  return t.type === "mathord" || t.type === "textord" || t.type === "atom";
}, qse = function(e) {
  if (!e)
    throw new Error("Expected non-null, but got " + String(e));
  return e;
}, Wse = function(e) {
  var t = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
  return t ? t[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(t[1]) ? null : t[1].toLowerCase() : "_relative";
}, Be = {
  contains: _se,
  deflt: Lse,
  escape: $se,
  hyphenate: zse,
  getBaseElem: ND,
  isCharacterBox: Vse,
  protocolFromUrl: Wse
}, Ep = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (n) => "#" + n
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (n, e) => (e.push(n), e)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (n) => Math.max(0, n),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (n) => Math.max(0, n),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n) => Math.max(0, n),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n) => n === "Infinity" ? 1 / 0 : parseInt(n)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function jse(n) {
  if (n.default)
    return n.default;
  var e = n.type, t = Array.isArray(e) ? e[0] : e;
  if (typeof t != "string")
    return t.enum[0];
  switch (t) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class s7 {
  constructor(e) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, e = e || {};
    for (var t in Ep)
      if (Ep.hasOwnProperty(t)) {
        var r = Ep[t];
        this[t] = e[t] !== void 0 ? r.processor ? r.processor(e[t]) : e[t] : jse(r);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(e, t, r) {
    var i = this.strict;
    if (typeof i == "function" && (i = i(e, t, r)), !(!i || i === "ignore")) {
      if (i === !0 || i === "error")
        throw new se("LaTeX-incompatible input and strict mode is set to 'error': " + (t + " [" + e + "]"), r);
      i === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(e, t, r) {
    var i = this.strict;
    if (typeof i == "function")
      try {
        i = i(e, t, r);
      } catch {
        i = "error";
      }
    return !i || i === "ignore" ? !1 : i === !0 || i === "error" ? !0 : i === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(e) {
    if (e.url && !e.protocol) {
      var t = Be.protocolFromUrl(e.url);
      if (t == null)
        return !1;
      e.protocol = t;
    }
    var r = typeof this.trust == "function" ? this.trust(e) : this.trust;
    return !!r;
  }
}
class Io {
  constructor(e, t, r) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = t, this.cramped = r;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return ss[Use[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return ss[Kse[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return ss[Gse[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return ss[Yse[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return ss[Jse[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return ss[Xse[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var o7 = 0, Wm = 1, Ec = 2, io = 3, nd = 4, fi = 5, Gc = 6, cr = 7, ss = [new Io(o7, 0, !1), new Io(Wm, 0, !0), new Io(Ec, 1, !1), new Io(io, 1, !0), new Io(nd, 2, !1), new Io(fi, 2, !0), new Io(Gc, 3, !1), new Io(cr, 3, !0)], Use = [nd, fi, nd, fi, Gc, cr, Gc, cr], Kse = [fi, fi, fi, fi, cr, cr, cr, cr], Gse = [Ec, io, nd, fi, Gc, cr, Gc, cr], Yse = [io, io, fi, fi, cr, cr, cr, cr], Jse = [Wm, Wm, io, io, fi, fi, cr, cr], Xse = [o7, Wm, Ec, io, Ec, io, Ec, io], We = {
  DISPLAY: ss[o7],
  TEXT: ss[Ec],
  SCRIPT: ss[nd],
  SCRIPTSCRIPT: ss[Gc]
}, A5 = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function Zse(n) {
  for (var e = 0; e < A5.length; e++)
    for (var t = A5[e], r = 0; r < t.blocks.length; r++) {
      var i = t.blocks[r];
      if (n >= i[0] && n <= i[1])
        return t.name;
    }
  return null;
}
var Ip = [];
A5.forEach((n) => n.blocks.forEach((e) => Ip.push(...e)));
function RD(n) {
  for (var e = 0; e < Ip.length; e += 2)
    if (n >= Ip[e] && n <= Ip[e + 1])
      return !0;
  return !1;
}
var Xa = 80, Qse = function(e, t) {
  return "M95," + (622 + e + t) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, eoe = function(e, t) {
  return "M263," + (601 + e + t) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, toe = function(e, t) {
  return "M983 " + (10 + e + t) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, noe = function(e, t) {
  return "M424," + (2398 + e + t) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + t + `
h400000v` + (40 + e) + "h-400000z";
}, roe = function(e, t) {
  return "M473," + (2713 + e + t) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "H1017.7z";
}, ioe = function(e) {
  var t = e / 2;
  return "M400000 " + e + " H0 L" + t + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, soe = function(e, t, r) {
  var i = r - 54 - t - e;
  return "M702 " + (e + t) + "H400000" + (40 + e) + `
H742v` + i + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + t + "H400000v" + (40 + e) + "H742z";
}, ooe = function(e, t, r) {
  t = 1e3 * t;
  var i = "";
  switch (e) {
    case "sqrtMain":
      i = Qse(t, Xa);
      break;
    case "sqrtSize1":
      i = eoe(t, Xa);
      break;
    case "sqrtSize2":
      i = toe(t, Xa);
      break;
    case "sqrtSize3":
      i = noe(t, Xa);
      break;
    case "sqrtSize4":
      i = roe(t, Xa);
      break;
    case "sqrtTall":
      i = soe(t, Xa, r);
  }
  return i;
}, loe = function(e, t) {
  switch (e) {
    case "⎜":
      return "M291 0 H417 V" + t + " H291z M291 0 H417 V" + t + " H291z";
    case "∣":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z";
    case "∥":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z" + ("M367 0 H410 V" + t + " H367z M367 0 H410 V" + t + " H367z");
    case "⎟":
      return "M457 0 H583 V" + t + " H457z M457 0 H583 V" + t + " H457z";
    case "⎢":
      return "M319 0 H403 V" + t + " H319z M319 0 H403 V" + t + " H319z";
    case "⎥":
      return "M263 0 H347 V" + t + " H263z M263 0 H347 V" + t + " H263z";
    case "⎪":
      return "M384 0 H504 V" + t + " H384z M384 0 H504 V" + t + " H384z";
    case "⏐":
      return "M312 0 H355 V" + t + " H312z M312 0 H355 V" + t + " H312z";
    case "‖":
      return "M257 0 H300 V" + t + " H257z M257 0 H300 V" + t + " H257z" + ("M478 0 H521 V" + t + " H478z M478 0 H521 V" + t + " H478z");
    default:
      return "";
  }
}, t9 = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, aoe = function(e, t) {
  switch (e) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + t + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + t + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + ` v585 h43z
M367 15 v585 v` + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + t + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v602 h84z
M403 1759 V0 H319 V1759 v` + t + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + t + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (t + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (t + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (t + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (t + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class _d {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(e) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var e = document.createDocumentFragment(), t = 0; t < this.children.length; t++)
      e.appendChild(this.children[t].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var e = "", t = 0; t < this.children.length; t++)
      e += this.children[t].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var e = (t) => t.toText();
    return this.children.map(e).join("");
  }
}
var ps = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, E0 = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, n9 = {
  // Latin-1
  Å: "A",
  Ð: "D",
  Þ: "o",
  å: "a",
  ð: "d",
  þ: "o",
  // Cyrillic
  А: "A",
  Б: "B",
  В: "B",
  Г: "F",
  Д: "A",
  Е: "E",
  Ж: "K",
  З: "3",
  И: "N",
  Й: "N",
  К: "K",
  Л: "N",
  М: "M",
  Н: "H",
  О: "O",
  П: "N",
  Р: "P",
  С: "C",
  Т: "T",
  У: "y",
  Ф: "O",
  Х: "X",
  Ц: "U",
  Ч: "h",
  Ш: "W",
  Щ: "W",
  Ъ: "B",
  Ы: "X",
  Ь: "B",
  Э: "3",
  Ю: "X",
  Я: "R",
  а: "a",
  б: "b",
  в: "a",
  г: "r",
  д: "y",
  е: "e",
  ж: "m",
  з: "e",
  и: "n",
  й: "n",
  к: "n",
  л: "n",
  м: "m",
  н: "n",
  о: "o",
  п: "n",
  р: "p",
  с: "c",
  т: "o",
  у: "y",
  ф: "b",
  х: "x",
  ц: "n",
  ч: "n",
  ш: "w",
  щ: "w",
  ъ: "a",
  ы: "m",
  ь: "a",
  э: "e",
  ю: "m",
  я: "r"
};
function coe(n, e) {
  ps[n] = e;
}
function l7(n, e, t) {
  if (!ps[e])
    throw new Error("Font metrics not found for font: " + e + ".");
  var r = n.charCodeAt(0), i = ps[e][r];
  if (!i && n[0] in n9 && (r = n9[n[0]].charCodeAt(0), i = ps[e][r]), !i && t === "text" && RD(r) && (i = ps[e][77]), i)
    return {
      depth: i[0],
      height: i[1],
      italic: i[2],
      skew: i[3],
      width: i[4]
    };
}
var r4 = {};
function uoe(n) {
  var e;
  if (n >= 5 ? e = 0 : n >= 3 ? e = 1 : e = 2, !r4[e]) {
    var t = r4[e] = {
      cssEmPerMu: E0.quad[e] / 18
    };
    for (var r in E0)
      E0.hasOwnProperty(r) && (t[r] = E0[r][e]);
  }
  return r4[e];
}
var hoe = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], r9 = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], i9 = function(e, t) {
  return t.size < 2 ? e : hoe[e - 1][t.size - 1];
};
class Gs {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(e) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = e.style, this.color = e.color, this.size = e.size || Gs.BASESIZE, this.textSize = e.textSize || this.size, this.phantom = !!e.phantom, this.font = e.font || "", this.fontFamily = e.fontFamily || "", this.fontWeight = e.fontWeight || "", this.fontShape = e.fontShape || "", this.sizeMultiplier = r9[this.size - 1], this.maxSize = e.maxSize, this.minRuleThickness = e.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(e) {
    var t = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var r in e)
      e.hasOwnProperty(r) && (t[r] = e[r]);
    return new Gs(t);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(e) {
    return this.style === e ? this : this.extend({
      style: e,
      size: i9(this.textSize, e)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(e) {
    return this.size === e && this.textSize === e ? this : this.extend({
      style: this.style.text(),
      size: e,
      textSize: e,
      sizeMultiplier: r9[e - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(e) {
    e = e || this.style.text();
    var t = i9(Gs.BASESIZE, e);
    return this.size === t && this.textSize === Gs.BASESIZE && this.style === e ? this : this.extend({
      style: e,
      size: t
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var e;
    switch (this.style.id) {
      case 4:
      case 5:
        e = 3;
        break;
      case 6:
      case 7:
        e = 1;
        break;
      default:
        e = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: e
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(e) {
    return this.extend({
      color: e
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(e) {
    return this.extend({
      font: e
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(e) {
    return this.extend({
      fontFamily: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(e) {
    return this.extend({
      fontWeight: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(e) {
    return this.extend({
      fontShape: e,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(e) {
    return e.size !== this.size ? ["sizing", "reset-size" + e.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Gs.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Gs.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = uoe(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Gs.BASESIZE = 6;
var O5 = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, foe = {
  ex: !0,
  em: !0,
  mu: !0
}, PD = function(e) {
  return typeof e != "string" && (e = e.unit), e in O5 || e in foe || e === "ex";
}, Qt = function(e, t) {
  var r;
  if (e.unit in O5)
    r = O5[e.unit] / t.fontMetrics().ptPerEm / t.sizeMultiplier;
  else if (e.unit === "mu")
    r = t.fontMetrics().cssEmPerMu;
  else {
    var i;
    if (t.style.isTight() ? i = t.havingStyle(t.style.text()) : i = t, e.unit === "ex")
      r = i.fontMetrics().xHeight;
    else if (e.unit === "em")
      r = i.fontMetrics().quad;
    else
      throw new se("Invalid unit: '" + e.unit + "'");
    i !== t && (r *= i.sizeMultiplier / t.sizeMultiplier);
  }
  return Math.min(e.number * r, t.maxSize);
}, fe = function(e) {
  return +e.toFixed(4) + "em";
}, yl = function(e) {
  return e.filter((t) => t).join(" ");
}, _D = function(e, t, r) {
  if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = r || {}, t) {
    t.style.isTight() && this.classes.push("mtight");
    var i = t.getColor();
    i && (this.style.color = i);
  }
}, LD = function(e) {
  var t = document.createElement(e);
  t.className = yl(this.classes);
  for (var r in this.style)
    this.style.hasOwnProperty(r) && (t.style[r] = this.style[r]);
  for (var i in this.attributes)
    this.attributes.hasOwnProperty(i) && t.setAttribute(i, this.attributes[i]);
  for (var s = 0; s < this.children.length; s++)
    t.appendChild(this.children[s].toNode());
  return t;
}, doe = /[\s"'>/=\x00-\x1f]/, BD = function(e) {
  var t = "<" + e;
  this.classes.length && (t += ' class="' + Be.escape(yl(this.classes)) + '"');
  var r = "";
  for (var i in this.style)
    this.style.hasOwnProperty(i) && (r += Be.hyphenate(i) + ":" + this.style[i] + ";");
  r && (t += ' style="' + Be.escape(r) + '"');
  for (var s in this.attributes)
    if (this.attributes.hasOwnProperty(s)) {
      if (doe.test(s))
        throw new se("Invalid attribute name '" + s + "'");
      t += " " + s + '="' + Be.escape(this.attributes[s]) + '"';
    }
  t += ">";
  for (var o = 0; o < this.children.length; o++)
    t += this.children[o].toMarkup();
  return t += "</" + e + ">", t;
};
class Ld {
  constructor(e, t, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, _D.call(this, e, r, i), this.children = t || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  toNode() {
    return LD.call(this, "span");
  }
  toMarkup() {
    return BD.call(this, "span");
  }
}
class a7 {
  constructor(e, t, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, _D.call(this, t, i), this.children = r || [], this.setAttribute("href", e);
  }
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  toNode() {
    return LD.call(this, "a");
  }
  toMarkup() {
    return BD.call(this, "a");
  }
}
class poe {
  constructor(e, t, r) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = t, this.src = e, this.classes = ["mord"], this.style = r;
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  toNode() {
    var e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (var t in this.style)
      this.style.hasOwnProperty(t) && (e.style[t] = this.style[t]);
    return e;
  }
  toMarkup() {
    var e = '<img src="' + Be.escape(this.src) + '"' + (' alt="' + Be.escape(this.alt) + '"'), t = "";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t += Be.hyphenate(r) + ":" + this.style[r] + ";");
    return t && (e += ' style="' + Be.escape(t) + '"'), e += "'/>", e;
  }
}
var moe = {
  î: "ı̂",
  ï: "ı̈",
  í: "ı́",
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  ì: "ı̀"
};
class ki {
  constructor(e, t, r, i, s, o, l, a) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = t || 0, this.depth = r || 0, this.italic = i || 0, this.skew = s || 0, this.width = o || 0, this.classes = l || [], this.style = a || {}, this.maxFontSize = 0;
    var c = Zse(this.text.charCodeAt(0));
    c && this.classes.push(c + "_fallback"), /[îïíì]/.test(this.text) && (this.text = moe[this.text]);
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var e = document.createTextNode(this.text), t = null;
    this.italic > 0 && (t = document.createElement("span"), t.style.marginRight = fe(this.italic)), this.classes.length > 0 && (t = t || document.createElement("span"), t.className = yl(this.classes));
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t = t || document.createElement("span"), t.style[r] = this.style[r]);
    return t ? (t.appendChild(e), t) : e;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var e = !1, t = "<span";
    this.classes.length && (e = !0, t += ' class="', t += Be.escape(yl(this.classes)), t += '"');
    var r = "";
    this.italic > 0 && (r += "margin-right:" + this.italic + "em;");
    for (var i in this.style)
      this.style.hasOwnProperty(i) && (r += Be.hyphenate(i) + ":" + this.style[i] + ";");
    r && (e = !0, t += ' style="' + Be.escape(r) + '"');
    var s = Be.escape(this.text);
    return e ? (t += ">", t += s, t += "</span>", t) : s;
  }
}
class po {
  constructor(e, t) {
    this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = t || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "svg");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    for (var i = 0; i < this.children.length; i++)
      t.appendChild(this.children[i].toNode());
    return t;
  }
  toMarkup() {
    var e = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + Be.escape(this.attributes[t]) + '"');
    e += ">";
    for (var r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</svg>", e;
  }
}
class bl {
  constructor(e, t) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = t;
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "path");
    return this.alternate ? t.setAttribute("d", this.alternate) : t.setAttribute("d", t9[this.pathName]), t;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + Be.escape(this.alternate) + '"/>' : '<path d="' + Be.escape(t9[this.pathName]) + '"/>';
  }
}
class E5 {
  constructor(e) {
    this.attributes = void 0, this.attributes = e || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "line");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    return t;
  }
  toMarkup() {
    var e = "<line";
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + Be.escape(this.attributes[t]) + '"');
    return e += "/>", e;
  }
}
function s9(n) {
  if (n instanceof ki)
    return n;
  throw new Error("Expected symbolNode but got " + String(n) + ".");
}
function goe(n) {
  if (n instanceof Ld)
    return n;
  throw new Error("Expected span<HtmlDomNode> but got " + String(n) + ".");
}
var yoe = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, boe = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, Ft = {
  math: {},
  text: {}
};
function y(n, e, t, r, i, s) {
  Ft[n][i] = {
    font: e,
    group: t,
    replace: r
  }, s && r && (Ft[n][r] = Ft[n][i]);
}
var v = "math", ee = "text", x = "main", A = "ams", Kt = "accent-token", Se = "bin", vr = "close", mu = "inner", qe = "mathord", yn = "op-token", ti = "open", ag = "punct", D = "rel", Mo = "spacing", _ = "textord";
y(v, x, D, "≡", "\\equiv", !0);
y(v, x, D, "≺", "\\prec", !0);
y(v, x, D, "≻", "\\succ", !0);
y(v, x, D, "∼", "\\sim", !0);
y(v, x, D, "⊥", "\\perp");
y(v, x, D, "⪯", "\\preceq", !0);
y(v, x, D, "⪰", "\\succeq", !0);
y(v, x, D, "≃", "\\simeq", !0);
y(v, x, D, "∣", "\\mid", !0);
y(v, x, D, "≪", "\\ll", !0);
y(v, x, D, "≫", "\\gg", !0);
y(v, x, D, "≍", "\\asymp", !0);
y(v, x, D, "∥", "\\parallel");
y(v, x, D, "⋈", "\\bowtie", !0);
y(v, x, D, "⌣", "\\smile", !0);
y(v, x, D, "⊑", "\\sqsubseteq", !0);
y(v, x, D, "⊒", "\\sqsupseteq", !0);
y(v, x, D, "≐", "\\doteq", !0);
y(v, x, D, "⌢", "\\frown", !0);
y(v, x, D, "∋", "\\ni", !0);
y(v, x, D, "∝", "\\propto", !0);
y(v, x, D, "⊢", "\\vdash", !0);
y(v, x, D, "⊣", "\\dashv", !0);
y(v, x, D, "∋", "\\owns");
y(v, x, ag, ".", "\\ldotp");
y(v, x, ag, "⋅", "\\cdotp");
y(v, x, _, "#", "\\#");
y(ee, x, _, "#", "\\#");
y(v, x, _, "&", "\\&");
y(ee, x, _, "&", "\\&");
y(v, x, _, "ℵ", "\\aleph", !0);
y(v, x, _, "∀", "\\forall", !0);
y(v, x, _, "ℏ", "\\hbar", !0);
y(v, x, _, "∃", "\\exists", !0);
y(v, x, _, "∇", "\\nabla", !0);
y(v, x, _, "♭", "\\flat", !0);
y(v, x, _, "ℓ", "\\ell", !0);
y(v, x, _, "♮", "\\natural", !0);
y(v, x, _, "♣", "\\clubsuit", !0);
y(v, x, _, "℘", "\\wp", !0);
y(v, x, _, "♯", "\\sharp", !0);
y(v, x, _, "♢", "\\diamondsuit", !0);
y(v, x, _, "ℜ", "\\Re", !0);
y(v, x, _, "♡", "\\heartsuit", !0);
y(v, x, _, "ℑ", "\\Im", !0);
y(v, x, _, "♠", "\\spadesuit", !0);
y(v, x, _, "§", "\\S", !0);
y(ee, x, _, "§", "\\S");
y(v, x, _, "¶", "\\P", !0);
y(ee, x, _, "¶", "\\P");
y(v, x, _, "†", "\\dag");
y(ee, x, _, "†", "\\dag");
y(ee, x, _, "†", "\\textdagger");
y(v, x, _, "‡", "\\ddag");
y(ee, x, _, "‡", "\\ddag");
y(ee, x, _, "‡", "\\textdaggerdbl");
y(v, x, vr, "⎱", "\\rmoustache", !0);
y(v, x, ti, "⎰", "\\lmoustache", !0);
y(v, x, vr, "⟯", "\\rgroup", !0);
y(v, x, ti, "⟮", "\\lgroup", !0);
y(v, x, Se, "∓", "\\mp", !0);
y(v, x, Se, "⊖", "\\ominus", !0);
y(v, x, Se, "⊎", "\\uplus", !0);
y(v, x, Se, "⊓", "\\sqcap", !0);
y(v, x, Se, "∗", "\\ast");
y(v, x, Se, "⊔", "\\sqcup", !0);
y(v, x, Se, "◯", "\\bigcirc", !0);
y(v, x, Se, "∙", "\\bullet", !0);
y(v, x, Se, "‡", "\\ddagger");
y(v, x, Se, "≀", "\\wr", !0);
y(v, x, Se, "⨿", "\\amalg");
y(v, x, Se, "&", "\\And");
y(v, x, D, "⟵", "\\longleftarrow", !0);
y(v, x, D, "⇐", "\\Leftarrow", !0);
y(v, x, D, "⟸", "\\Longleftarrow", !0);
y(v, x, D, "⟶", "\\longrightarrow", !0);
y(v, x, D, "⇒", "\\Rightarrow", !0);
y(v, x, D, "⟹", "\\Longrightarrow", !0);
y(v, x, D, "↔", "\\leftrightarrow", !0);
y(v, x, D, "⟷", "\\longleftrightarrow", !0);
y(v, x, D, "⇔", "\\Leftrightarrow", !0);
y(v, x, D, "⟺", "\\Longleftrightarrow", !0);
y(v, x, D, "↦", "\\mapsto", !0);
y(v, x, D, "⟼", "\\longmapsto", !0);
y(v, x, D, "↗", "\\nearrow", !0);
y(v, x, D, "↩", "\\hookleftarrow", !0);
y(v, x, D, "↪", "\\hookrightarrow", !0);
y(v, x, D, "↘", "\\searrow", !0);
y(v, x, D, "↼", "\\leftharpoonup", !0);
y(v, x, D, "⇀", "\\rightharpoonup", !0);
y(v, x, D, "↙", "\\swarrow", !0);
y(v, x, D, "↽", "\\leftharpoondown", !0);
y(v, x, D, "⇁", "\\rightharpoondown", !0);
y(v, x, D, "↖", "\\nwarrow", !0);
y(v, x, D, "⇌", "\\rightleftharpoons", !0);
y(v, A, D, "≮", "\\nless", !0);
y(v, A, D, "", "\\@nleqslant");
y(v, A, D, "", "\\@nleqq");
y(v, A, D, "⪇", "\\lneq", !0);
y(v, A, D, "≨", "\\lneqq", !0);
y(v, A, D, "", "\\@lvertneqq");
y(v, A, D, "⋦", "\\lnsim", !0);
y(v, A, D, "⪉", "\\lnapprox", !0);
y(v, A, D, "⊀", "\\nprec", !0);
y(v, A, D, "⋠", "\\npreceq", !0);
y(v, A, D, "⋨", "\\precnsim", !0);
y(v, A, D, "⪹", "\\precnapprox", !0);
y(v, A, D, "≁", "\\nsim", !0);
y(v, A, D, "", "\\@nshortmid");
y(v, A, D, "∤", "\\nmid", !0);
y(v, A, D, "⊬", "\\nvdash", !0);
y(v, A, D, "⊭", "\\nvDash", !0);
y(v, A, D, "⋪", "\\ntriangleleft");
y(v, A, D, "⋬", "\\ntrianglelefteq", !0);
y(v, A, D, "⊊", "\\subsetneq", !0);
y(v, A, D, "", "\\@varsubsetneq");
y(v, A, D, "⫋", "\\subsetneqq", !0);
y(v, A, D, "", "\\@varsubsetneqq");
y(v, A, D, "≯", "\\ngtr", !0);
y(v, A, D, "", "\\@ngeqslant");
y(v, A, D, "", "\\@ngeqq");
y(v, A, D, "⪈", "\\gneq", !0);
y(v, A, D, "≩", "\\gneqq", !0);
y(v, A, D, "", "\\@gvertneqq");
y(v, A, D, "⋧", "\\gnsim", !0);
y(v, A, D, "⪊", "\\gnapprox", !0);
y(v, A, D, "⊁", "\\nsucc", !0);
y(v, A, D, "⋡", "\\nsucceq", !0);
y(v, A, D, "⋩", "\\succnsim", !0);
y(v, A, D, "⪺", "\\succnapprox", !0);
y(v, A, D, "≆", "\\ncong", !0);
y(v, A, D, "", "\\@nshortparallel");
y(v, A, D, "∦", "\\nparallel", !0);
y(v, A, D, "⊯", "\\nVDash", !0);
y(v, A, D, "⋫", "\\ntriangleright");
y(v, A, D, "⋭", "\\ntrianglerighteq", !0);
y(v, A, D, "", "\\@nsupseteqq");
y(v, A, D, "⊋", "\\supsetneq", !0);
y(v, A, D, "", "\\@varsupsetneq");
y(v, A, D, "⫌", "\\supsetneqq", !0);
y(v, A, D, "", "\\@varsupsetneqq");
y(v, A, D, "⊮", "\\nVdash", !0);
y(v, A, D, "⪵", "\\precneqq", !0);
y(v, A, D, "⪶", "\\succneqq", !0);
y(v, A, D, "", "\\@nsubseteqq");
y(v, A, Se, "⊴", "\\unlhd");
y(v, A, Se, "⊵", "\\unrhd");
y(v, A, D, "↚", "\\nleftarrow", !0);
y(v, A, D, "↛", "\\nrightarrow", !0);
y(v, A, D, "⇍", "\\nLeftarrow", !0);
y(v, A, D, "⇏", "\\nRightarrow", !0);
y(v, A, D, "↮", "\\nleftrightarrow", !0);
y(v, A, D, "⇎", "\\nLeftrightarrow", !0);
y(v, A, D, "△", "\\vartriangle");
y(v, A, _, "ℏ", "\\hslash");
y(v, A, _, "▽", "\\triangledown");
y(v, A, _, "◊", "\\lozenge");
y(v, A, _, "Ⓢ", "\\circledS");
y(v, A, _, "®", "\\circledR");
y(ee, A, _, "®", "\\circledR");
y(v, A, _, "∡", "\\measuredangle", !0);
y(v, A, _, "∄", "\\nexists");
y(v, A, _, "℧", "\\mho");
y(v, A, _, "Ⅎ", "\\Finv", !0);
y(v, A, _, "⅁", "\\Game", !0);
y(v, A, _, "‵", "\\backprime");
y(v, A, _, "▲", "\\blacktriangle");
y(v, A, _, "▼", "\\blacktriangledown");
y(v, A, _, "■", "\\blacksquare");
y(v, A, _, "⧫", "\\blacklozenge");
y(v, A, _, "★", "\\bigstar");
y(v, A, _, "∢", "\\sphericalangle", !0);
y(v, A, _, "∁", "\\complement", !0);
y(v, A, _, "ð", "\\eth", !0);
y(ee, x, _, "ð", "ð");
y(v, A, _, "╱", "\\diagup");
y(v, A, _, "╲", "\\diagdown");
y(v, A, _, "□", "\\square");
y(v, A, _, "□", "\\Box");
y(v, A, _, "◊", "\\Diamond");
y(v, A, _, "¥", "\\yen", !0);
y(ee, A, _, "¥", "\\yen", !0);
y(v, A, _, "✓", "\\checkmark", !0);
y(ee, A, _, "✓", "\\checkmark");
y(v, A, _, "ℶ", "\\beth", !0);
y(v, A, _, "ℸ", "\\daleth", !0);
y(v, A, _, "ℷ", "\\gimel", !0);
y(v, A, _, "ϝ", "\\digamma", !0);
y(v, A, _, "ϰ", "\\varkappa");
y(v, A, ti, "┌", "\\@ulcorner", !0);
y(v, A, vr, "┐", "\\@urcorner", !0);
y(v, A, ti, "└", "\\@llcorner", !0);
y(v, A, vr, "┘", "\\@lrcorner", !0);
y(v, A, D, "≦", "\\leqq", !0);
y(v, A, D, "⩽", "\\leqslant", !0);
y(v, A, D, "⪕", "\\eqslantless", !0);
y(v, A, D, "≲", "\\lesssim", !0);
y(v, A, D, "⪅", "\\lessapprox", !0);
y(v, A, D, "≊", "\\approxeq", !0);
y(v, A, Se, "⋖", "\\lessdot");
y(v, A, D, "⋘", "\\lll", !0);
y(v, A, D, "≶", "\\lessgtr", !0);
y(v, A, D, "⋚", "\\lesseqgtr", !0);
y(v, A, D, "⪋", "\\lesseqqgtr", !0);
y(v, A, D, "≑", "\\doteqdot");
y(v, A, D, "≓", "\\risingdotseq", !0);
y(v, A, D, "≒", "\\fallingdotseq", !0);
y(v, A, D, "∽", "\\backsim", !0);
y(v, A, D, "⋍", "\\backsimeq", !0);
y(v, A, D, "⫅", "\\subseteqq", !0);
y(v, A, D, "⋐", "\\Subset", !0);
y(v, A, D, "⊏", "\\sqsubset", !0);
y(v, A, D, "≼", "\\preccurlyeq", !0);
y(v, A, D, "⋞", "\\curlyeqprec", !0);
y(v, A, D, "≾", "\\precsim", !0);
y(v, A, D, "⪷", "\\precapprox", !0);
y(v, A, D, "⊲", "\\vartriangleleft");
y(v, A, D, "⊴", "\\trianglelefteq");
y(v, A, D, "⊨", "\\vDash", !0);
y(v, A, D, "⊪", "\\Vvdash", !0);
y(v, A, D, "⌣", "\\smallsmile");
y(v, A, D, "⌢", "\\smallfrown");
y(v, A, D, "≏", "\\bumpeq", !0);
y(v, A, D, "≎", "\\Bumpeq", !0);
y(v, A, D, "≧", "\\geqq", !0);
y(v, A, D, "⩾", "\\geqslant", !0);
y(v, A, D, "⪖", "\\eqslantgtr", !0);
y(v, A, D, "≳", "\\gtrsim", !0);
y(v, A, D, "⪆", "\\gtrapprox", !0);
y(v, A, Se, "⋗", "\\gtrdot");
y(v, A, D, "⋙", "\\ggg", !0);
y(v, A, D, "≷", "\\gtrless", !0);
y(v, A, D, "⋛", "\\gtreqless", !0);
y(v, A, D, "⪌", "\\gtreqqless", !0);
y(v, A, D, "≖", "\\eqcirc", !0);
y(v, A, D, "≗", "\\circeq", !0);
y(v, A, D, "≜", "\\triangleq", !0);
y(v, A, D, "∼", "\\thicksim");
y(v, A, D, "≈", "\\thickapprox");
y(v, A, D, "⫆", "\\supseteqq", !0);
y(v, A, D, "⋑", "\\Supset", !0);
y(v, A, D, "⊐", "\\sqsupset", !0);
y(v, A, D, "≽", "\\succcurlyeq", !0);
y(v, A, D, "⋟", "\\curlyeqsucc", !0);
y(v, A, D, "≿", "\\succsim", !0);
y(v, A, D, "⪸", "\\succapprox", !0);
y(v, A, D, "⊳", "\\vartriangleright");
y(v, A, D, "⊵", "\\trianglerighteq");
y(v, A, D, "⊩", "\\Vdash", !0);
y(v, A, D, "∣", "\\shortmid");
y(v, A, D, "∥", "\\shortparallel");
y(v, A, D, "≬", "\\between", !0);
y(v, A, D, "⋔", "\\pitchfork", !0);
y(v, A, D, "∝", "\\varpropto");
y(v, A, D, "◀", "\\blacktriangleleft");
y(v, A, D, "∴", "\\therefore", !0);
y(v, A, D, "∍", "\\backepsilon");
y(v, A, D, "▶", "\\blacktriangleright");
y(v, A, D, "∵", "\\because", !0);
y(v, A, D, "⋘", "\\llless");
y(v, A, D, "⋙", "\\gggtr");
y(v, A, Se, "⊲", "\\lhd");
y(v, A, Se, "⊳", "\\rhd");
y(v, A, D, "≂", "\\eqsim", !0);
y(v, x, D, "⋈", "\\Join");
y(v, A, D, "≑", "\\Doteq", !0);
y(v, A, Se, "∔", "\\dotplus", !0);
y(v, A, Se, "∖", "\\smallsetminus");
y(v, A, Se, "⋒", "\\Cap", !0);
y(v, A, Se, "⋓", "\\Cup", !0);
y(v, A, Se, "⩞", "\\doublebarwedge", !0);
y(v, A, Se, "⊟", "\\boxminus", !0);
y(v, A, Se, "⊞", "\\boxplus", !0);
y(v, A, Se, "⋇", "\\divideontimes", !0);
y(v, A, Se, "⋉", "\\ltimes", !0);
y(v, A, Se, "⋊", "\\rtimes", !0);
y(v, A, Se, "⋋", "\\leftthreetimes", !0);
y(v, A, Se, "⋌", "\\rightthreetimes", !0);
y(v, A, Se, "⋏", "\\curlywedge", !0);
y(v, A, Se, "⋎", "\\curlyvee", !0);
y(v, A, Se, "⊝", "\\circleddash", !0);
y(v, A, Se, "⊛", "\\circledast", !0);
y(v, A, Se, "⋅", "\\centerdot");
y(v, A, Se, "⊺", "\\intercal", !0);
y(v, A, Se, "⋒", "\\doublecap");
y(v, A, Se, "⋓", "\\doublecup");
y(v, A, Se, "⊠", "\\boxtimes", !0);
y(v, A, D, "⇢", "\\dashrightarrow", !0);
y(v, A, D, "⇠", "\\dashleftarrow", !0);
y(v, A, D, "⇇", "\\leftleftarrows", !0);
y(v, A, D, "⇆", "\\leftrightarrows", !0);
y(v, A, D, "⇚", "\\Lleftarrow", !0);
y(v, A, D, "↞", "\\twoheadleftarrow", !0);
y(v, A, D, "↢", "\\leftarrowtail", !0);
y(v, A, D, "↫", "\\looparrowleft", !0);
y(v, A, D, "⇋", "\\leftrightharpoons", !0);
y(v, A, D, "↶", "\\curvearrowleft", !0);
y(v, A, D, "↺", "\\circlearrowleft", !0);
y(v, A, D, "↰", "\\Lsh", !0);
y(v, A, D, "⇈", "\\upuparrows", !0);
y(v, A, D, "↿", "\\upharpoonleft", !0);
y(v, A, D, "⇃", "\\downharpoonleft", !0);
y(v, x, D, "⊶", "\\origof", !0);
y(v, x, D, "⊷", "\\imageof", !0);
y(v, A, D, "⊸", "\\multimap", !0);
y(v, A, D, "↭", "\\leftrightsquigarrow", !0);
y(v, A, D, "⇉", "\\rightrightarrows", !0);
y(v, A, D, "⇄", "\\rightleftarrows", !0);
y(v, A, D, "↠", "\\twoheadrightarrow", !0);
y(v, A, D, "↣", "\\rightarrowtail", !0);
y(v, A, D, "↬", "\\looparrowright", !0);
y(v, A, D, "↷", "\\curvearrowright", !0);
y(v, A, D, "↻", "\\circlearrowright", !0);
y(v, A, D, "↱", "\\Rsh", !0);
y(v, A, D, "⇊", "\\downdownarrows", !0);
y(v, A, D, "↾", "\\upharpoonright", !0);
y(v, A, D, "⇂", "\\downharpoonright", !0);
y(v, A, D, "⇝", "\\rightsquigarrow", !0);
y(v, A, D, "⇝", "\\leadsto");
y(v, A, D, "⇛", "\\Rrightarrow", !0);
y(v, A, D, "↾", "\\restriction");
y(v, x, _, "‘", "`");
y(v, x, _, "$", "\\$");
y(ee, x, _, "$", "\\$");
y(ee, x, _, "$", "\\textdollar");
y(v, x, _, "%", "\\%");
y(ee, x, _, "%", "\\%");
y(v, x, _, "_", "\\_");
y(ee, x, _, "_", "\\_");
y(ee, x, _, "_", "\\textunderscore");
y(v, x, _, "∠", "\\angle", !0);
y(v, x, _, "∞", "\\infty", !0);
y(v, x, _, "′", "\\prime");
y(v, x, _, "△", "\\triangle");
y(v, x, _, "Γ", "\\Gamma", !0);
y(v, x, _, "Δ", "\\Delta", !0);
y(v, x, _, "Θ", "\\Theta", !0);
y(v, x, _, "Λ", "\\Lambda", !0);
y(v, x, _, "Ξ", "\\Xi", !0);
y(v, x, _, "Π", "\\Pi", !0);
y(v, x, _, "Σ", "\\Sigma", !0);
y(v, x, _, "Υ", "\\Upsilon", !0);
y(v, x, _, "Φ", "\\Phi", !0);
y(v, x, _, "Ψ", "\\Psi", !0);
y(v, x, _, "Ω", "\\Omega", !0);
y(v, x, _, "A", "Α");
y(v, x, _, "B", "Β");
y(v, x, _, "E", "Ε");
y(v, x, _, "Z", "Ζ");
y(v, x, _, "H", "Η");
y(v, x, _, "I", "Ι");
y(v, x, _, "K", "Κ");
y(v, x, _, "M", "Μ");
y(v, x, _, "N", "Ν");
y(v, x, _, "O", "Ο");
y(v, x, _, "P", "Ρ");
y(v, x, _, "T", "Τ");
y(v, x, _, "X", "Χ");
y(v, x, _, "¬", "\\neg", !0);
y(v, x, _, "¬", "\\lnot");
y(v, x, _, "⊤", "\\top");
y(v, x, _, "⊥", "\\bot");
y(v, x, _, "∅", "\\emptyset");
y(v, A, _, "∅", "\\varnothing");
y(v, x, qe, "α", "\\alpha", !0);
y(v, x, qe, "β", "\\beta", !0);
y(v, x, qe, "γ", "\\gamma", !0);
y(v, x, qe, "δ", "\\delta", !0);
y(v, x, qe, "ϵ", "\\epsilon", !0);
y(v, x, qe, "ζ", "\\zeta", !0);
y(v, x, qe, "η", "\\eta", !0);
y(v, x, qe, "θ", "\\theta", !0);
y(v, x, qe, "ι", "\\iota", !0);
y(v, x, qe, "κ", "\\kappa", !0);
y(v, x, qe, "λ", "\\lambda", !0);
y(v, x, qe, "μ", "\\mu", !0);
y(v, x, qe, "ν", "\\nu", !0);
y(v, x, qe, "ξ", "\\xi", !0);
y(v, x, qe, "ο", "\\omicron", !0);
y(v, x, qe, "π", "\\pi", !0);
y(v, x, qe, "ρ", "\\rho", !0);
y(v, x, qe, "σ", "\\sigma", !0);
y(v, x, qe, "τ", "\\tau", !0);
y(v, x, qe, "υ", "\\upsilon", !0);
y(v, x, qe, "ϕ", "\\phi", !0);
y(v, x, qe, "χ", "\\chi", !0);
y(v, x, qe, "ψ", "\\psi", !0);
y(v, x, qe, "ω", "\\omega", !0);
y(v, x, qe, "ε", "\\varepsilon", !0);
y(v, x, qe, "ϑ", "\\vartheta", !0);
y(v, x, qe, "ϖ", "\\varpi", !0);
y(v, x, qe, "ϱ", "\\varrho", !0);
y(v, x, qe, "ς", "\\varsigma", !0);
y(v, x, qe, "φ", "\\varphi", !0);
y(v, x, Se, "∗", "*", !0);
y(v, x, Se, "+", "+");
y(v, x, Se, "−", "-", !0);
y(v, x, Se, "⋅", "\\cdot", !0);
y(v, x, Se, "∘", "\\circ", !0);
y(v, x, Se, "÷", "\\div", !0);
y(v, x, Se, "±", "\\pm", !0);
y(v, x, Se, "×", "\\times", !0);
y(v, x, Se, "∩", "\\cap", !0);
y(v, x, Se, "∪", "\\cup", !0);
y(v, x, Se, "∖", "\\setminus", !0);
y(v, x, Se, "∧", "\\land");
y(v, x, Se, "∨", "\\lor");
y(v, x, Se, "∧", "\\wedge", !0);
y(v, x, Se, "∨", "\\vee", !0);
y(v, x, _, "√", "\\surd");
y(v, x, ti, "⟨", "\\langle", !0);
y(v, x, ti, "∣", "\\lvert");
y(v, x, ti, "∥", "\\lVert");
y(v, x, vr, "?", "?");
y(v, x, vr, "!", "!");
y(v, x, vr, "⟩", "\\rangle", !0);
y(v, x, vr, "∣", "\\rvert");
y(v, x, vr, "∥", "\\rVert");
y(v, x, D, "=", "=");
y(v, x, D, ":", ":");
y(v, x, D, "≈", "\\approx", !0);
y(v, x, D, "≅", "\\cong", !0);
y(v, x, D, "≥", "\\ge");
y(v, x, D, "≥", "\\geq", !0);
y(v, x, D, "←", "\\gets");
y(v, x, D, ">", "\\gt", !0);
y(v, x, D, "∈", "\\in", !0);
y(v, x, D, "", "\\@not");
y(v, x, D, "⊂", "\\subset", !0);
y(v, x, D, "⊃", "\\supset", !0);
y(v, x, D, "⊆", "\\subseteq", !0);
y(v, x, D, "⊇", "\\supseteq", !0);
y(v, A, D, "⊈", "\\nsubseteq", !0);
y(v, A, D, "⊉", "\\nsupseteq", !0);
y(v, x, D, "⊨", "\\models");
y(v, x, D, "←", "\\leftarrow", !0);
y(v, x, D, "≤", "\\le");
y(v, x, D, "≤", "\\leq", !0);
y(v, x, D, "<", "\\lt", !0);
y(v, x, D, "→", "\\rightarrow", !0);
y(v, x, D, "→", "\\to");
y(v, A, D, "≱", "\\ngeq", !0);
y(v, A, D, "≰", "\\nleq", !0);
y(v, x, Mo, " ", "\\ ");
y(v, x, Mo, " ", "\\space");
y(v, x, Mo, " ", "\\nobreakspace");
y(ee, x, Mo, " ", "\\ ");
y(ee, x, Mo, " ", " ");
y(ee, x, Mo, " ", "\\space");
y(ee, x, Mo, " ", "\\nobreakspace");
y(v, x, Mo, null, "\\nobreak");
y(v, x, Mo, null, "\\allowbreak");
y(v, x, ag, ",", ",");
y(v, x, ag, ";", ";");
y(v, A, Se, "⊼", "\\barwedge", !0);
y(v, A, Se, "⊻", "\\veebar", !0);
y(v, x, Se, "⊙", "\\odot", !0);
y(v, x, Se, "⊕", "\\oplus", !0);
y(v, x, Se, "⊗", "\\otimes", !0);
y(v, x, _, "∂", "\\partial", !0);
y(v, x, Se, "⊘", "\\oslash", !0);
y(v, A, Se, "⊚", "\\circledcirc", !0);
y(v, A, Se, "⊡", "\\boxdot", !0);
y(v, x, Se, "△", "\\bigtriangleup");
y(v, x, Se, "▽", "\\bigtriangledown");
y(v, x, Se, "†", "\\dagger");
y(v, x, Se, "⋄", "\\diamond");
y(v, x, Se, "⋆", "\\star");
y(v, x, Se, "◃", "\\triangleleft");
y(v, x, Se, "▹", "\\triangleright");
y(v, x, ti, "{", "\\{");
y(ee, x, _, "{", "\\{");
y(ee, x, _, "{", "\\textbraceleft");
y(v, x, vr, "}", "\\}");
y(ee, x, _, "}", "\\}");
y(ee, x, _, "}", "\\textbraceright");
y(v, x, ti, "{", "\\lbrace");
y(v, x, vr, "}", "\\rbrace");
y(v, x, ti, "[", "\\lbrack", !0);
y(ee, x, _, "[", "\\lbrack", !0);
y(v, x, vr, "]", "\\rbrack", !0);
y(ee, x, _, "]", "\\rbrack", !0);
y(v, x, ti, "(", "\\lparen", !0);
y(v, x, vr, ")", "\\rparen", !0);
y(ee, x, _, "<", "\\textless", !0);
y(ee, x, _, ">", "\\textgreater", !0);
y(v, x, ti, "⌊", "\\lfloor", !0);
y(v, x, vr, "⌋", "\\rfloor", !0);
y(v, x, ti, "⌈", "\\lceil", !0);
y(v, x, vr, "⌉", "\\rceil", !0);
y(v, x, _, "\\", "\\backslash");
y(v, x, _, "∣", "|");
y(v, x, _, "∣", "\\vert");
y(ee, x, _, "|", "\\textbar", !0);
y(v, x, _, "∥", "\\|");
y(v, x, _, "∥", "\\Vert");
y(ee, x, _, "∥", "\\textbardbl");
y(ee, x, _, "~", "\\textasciitilde");
y(ee, x, _, "\\", "\\textbackslash");
y(ee, x, _, "^", "\\textasciicircum");
y(v, x, D, "↑", "\\uparrow", !0);
y(v, x, D, "⇑", "\\Uparrow", !0);
y(v, x, D, "↓", "\\downarrow", !0);
y(v, x, D, "⇓", "\\Downarrow", !0);
y(v, x, D, "↕", "\\updownarrow", !0);
y(v, x, D, "⇕", "\\Updownarrow", !0);
y(v, x, yn, "∐", "\\coprod");
y(v, x, yn, "⋁", "\\bigvee");
y(v, x, yn, "⋀", "\\bigwedge");
y(v, x, yn, "⨄", "\\biguplus");
y(v, x, yn, "⋂", "\\bigcap");
y(v, x, yn, "⋃", "\\bigcup");
y(v, x, yn, "∫", "\\int");
y(v, x, yn, "∫", "\\intop");
y(v, x, yn, "∬", "\\iint");
y(v, x, yn, "∭", "\\iiint");
y(v, x, yn, "∏", "\\prod");
y(v, x, yn, "∑", "\\sum");
y(v, x, yn, "⨂", "\\bigotimes");
y(v, x, yn, "⨁", "\\bigoplus");
y(v, x, yn, "⨀", "\\bigodot");
y(v, x, yn, "∮", "\\oint");
y(v, x, yn, "∯", "\\oiint");
y(v, x, yn, "∰", "\\oiiint");
y(v, x, yn, "⨆", "\\bigsqcup");
y(v, x, yn, "∫", "\\smallint");
y(ee, x, mu, "…", "\\textellipsis");
y(v, x, mu, "…", "\\mathellipsis");
y(ee, x, mu, "…", "\\ldots", !0);
y(v, x, mu, "…", "\\ldots", !0);
y(v, x, mu, "⋯", "\\@cdots", !0);
y(v, x, mu, "⋱", "\\ddots", !0);
y(v, x, _, "⋮", "\\varvdots");
y(ee, x, _, "⋮", "\\varvdots");
y(v, x, Kt, "ˊ", "\\acute");
y(v, x, Kt, "ˋ", "\\grave");
y(v, x, Kt, "¨", "\\ddot");
y(v, x, Kt, "~", "\\tilde");
y(v, x, Kt, "ˉ", "\\bar");
y(v, x, Kt, "˘", "\\breve");
y(v, x, Kt, "ˇ", "\\check");
y(v, x, Kt, "^", "\\hat");
y(v, x, Kt, "⃗", "\\vec");
y(v, x, Kt, "˙", "\\dot");
y(v, x, Kt, "˚", "\\mathring");
y(v, x, qe, "", "\\@imath");
y(v, x, qe, "", "\\@jmath");
y(v, x, _, "ı", "ı");
y(v, x, _, "ȷ", "ȷ");
y(ee, x, _, "ı", "\\i", !0);
y(ee, x, _, "ȷ", "\\j", !0);
y(ee, x, _, "ß", "\\ss", !0);
y(ee, x, _, "æ", "\\ae", !0);
y(ee, x, _, "œ", "\\oe", !0);
y(ee, x, _, "ø", "\\o", !0);
y(ee, x, _, "Æ", "\\AE", !0);
y(ee, x, _, "Œ", "\\OE", !0);
y(ee, x, _, "Ø", "\\O", !0);
y(ee, x, Kt, "ˊ", "\\'");
y(ee, x, Kt, "ˋ", "\\`");
y(ee, x, Kt, "ˆ", "\\^");
y(ee, x, Kt, "˜", "\\~");
y(ee, x, Kt, "ˉ", "\\=");
y(ee, x, Kt, "˘", "\\u");
y(ee, x, Kt, "˙", "\\.");
y(ee, x, Kt, "¸", "\\c");
y(ee, x, Kt, "˚", "\\r");
y(ee, x, Kt, "ˇ", "\\v");
y(ee, x, Kt, "¨", '\\"');
y(ee, x, Kt, "˝", "\\H");
y(ee, x, Kt, "◯", "\\textcircled");
var zD = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
y(ee, x, _, "–", "--", !0);
y(ee, x, _, "–", "\\textendash");
y(ee, x, _, "—", "---", !0);
y(ee, x, _, "—", "\\textemdash");
y(ee, x, _, "‘", "`", !0);
y(ee, x, _, "‘", "\\textquoteleft");
y(ee, x, _, "’", "'", !0);
y(ee, x, _, "’", "\\textquoteright");
y(ee, x, _, "“", "``", !0);
y(ee, x, _, "“", "\\textquotedblleft");
y(ee, x, _, "”", "''", !0);
y(ee, x, _, "”", "\\textquotedblright");
y(v, x, _, "°", "\\degree", !0);
y(ee, x, _, "°", "\\degree");
y(ee, x, _, "°", "\\textdegree", !0);
y(v, x, _, "£", "\\pounds");
y(v, x, _, "£", "\\mathsterling", !0);
y(ee, x, _, "£", "\\pounds");
y(ee, x, _, "£", "\\textsterling", !0);
y(v, A, _, "✠", "\\maltese");
y(ee, A, _, "✠", "\\maltese");
var o9 = '0123456789/@."';
for (var i4 = 0; i4 < o9.length; i4++) {
  var l9 = o9.charAt(i4);
  y(v, x, _, l9, l9);
}
var a9 = '0123456789!@*()-=+";:?/.,';
for (var s4 = 0; s4 < a9.length; s4++) {
  var c9 = a9.charAt(s4);
  y(ee, x, _, c9, c9);
}
var jm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var o4 = 0; o4 < jm.length; o4++) {
  var I0 = jm.charAt(o4);
  y(v, x, qe, I0, I0), y(ee, x, _, I0, I0);
}
y(v, A, _, "C", "ℂ");
y(ee, A, _, "C", "ℂ");
y(v, A, _, "H", "ℍ");
y(ee, A, _, "H", "ℍ");
y(v, A, _, "N", "ℕ");
y(ee, A, _, "N", "ℕ");
y(v, A, _, "P", "ℙ");
y(ee, A, _, "P", "ℙ");
y(v, A, _, "Q", "ℚ");
y(ee, A, _, "Q", "ℚ");
y(v, A, _, "R", "ℝ");
y(ee, A, _, "R", "ℝ");
y(v, A, _, "Z", "ℤ");
y(ee, A, _, "Z", "ℤ");
y(v, x, qe, "h", "ℎ");
y(ee, x, qe, "h", "ℎ");
var Ke = "";
for (var nr = 0; nr < jm.length; nr++) {
  var nn = jm.charAt(nr);
  Ke = String.fromCharCode(55349, 56320 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56372 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56424 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56580 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56684 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56736 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56788 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56840 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56944 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), nr < 26 && (Ke = String.fromCharCode(55349, 56632 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56476 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke));
}
Ke = "𝕜";
y(v, x, qe, "k", Ke);
y(ee, x, _, "k", Ke);
for (var Bl = 0; Bl < 10; Bl++) {
  var Do = Bl.toString();
  Ke = String.fromCharCode(55349, 57294 + Bl), y(v, x, qe, Do, Ke), y(ee, x, _, Do, Ke), Ke = String.fromCharCode(55349, 57314 + Bl), y(v, x, qe, Do, Ke), y(ee, x, _, Do, Ke), Ke = String.fromCharCode(55349, 57324 + Bl), y(v, x, qe, Do, Ke), y(ee, x, _, Do, Ke), Ke = String.fromCharCode(55349, 57334 + Bl), y(v, x, qe, Do, Ke), y(ee, x, _, Do, Ke);
}
var I5 = "ÐÞþ";
for (var l4 = 0; l4 < I5.length; l4++) {
  var D0 = I5.charAt(l4);
  y(v, x, qe, D0, D0), y(ee, x, _, D0, D0);
}
var N0 = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], u9 = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], voe = function(e, t) {
  var r = e.charCodeAt(0), i = e.charCodeAt(1), s = (r - 55296) * 1024 + (i - 56320) + 65536, o = t === "math" ? 0 : 1;
  if (119808 <= s && s < 120484) {
    var l = Math.floor((s - 119808) / 26);
    return [N0[l][2], N0[l][o]];
  } else if (120782 <= s && s <= 120831) {
    var a = Math.floor((s - 120782) / 10);
    return [u9[a][2], u9[a][o]];
  } else {
    if (s === 120485 || s === 120486)
      return [N0[0][2], N0[0][o]];
    if (120486 < s && s < 120782)
      return ["", ""];
    throw new se("Unsupported character: " + e);
  }
}, cg = function(e, t, r) {
  return Ft[r][e] && Ft[r][e].replace && (e = Ft[r][e].replace), {
    value: e,
    metrics: l7(e, t, r)
  };
}, Ei = function(e, t, r, i, s) {
  var o = cg(e, t, r), l = o.metrics;
  e = o.value;
  var a;
  if (l) {
    var c = l.italic;
    (r === "text" || i && i.font === "mathit") && (c = 0), a = new ki(e, l.height, l.depth, c, l.skew, l.width, s);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + e + "' in style '" + t + "' and mode '" + r + "'")), a = new ki(e, 0, 0, 0, 0, 0, s);
  if (i) {
    a.maxFontSize = i.sizeMultiplier, i.style.isTight() && a.classes.push("mtight");
    var u = i.getColor();
    u && (a.style.color = u);
  }
  return a;
}, woe = function(e, t, r, i) {
  return i === void 0 && (i = []), r.font === "boldsymbol" && cg(e, "Main-Bold", t).metrics ? Ei(e, "Main-Bold", t, r, i.concat(["mathbf"])) : e === "\\" || Ft[t][e].font === "main" ? Ei(e, "Main-Regular", t, r, i) : Ei(e, "AMS-Regular", t, r, i.concat(["amsrm"]));
}, xoe = function(e, t, r, i, s) {
  return s !== "textord" && cg(e, "Math-BoldItalic", t).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, koe = function(e, t, r) {
  var i = e.mode, s = e.text, o = ["mord"], l = i === "math" || i === "text" && t.font, a = l ? t.font : t.fontFamily, c = "", u = "";
  if (s.charCodeAt(0) === 55349 && ([c, u] = voe(s, i)), c.length > 0)
    return Ei(s, c, i, t, o.concat(u));
  if (a) {
    var h, f;
    if (a === "boldsymbol") {
      var d = xoe(s, i, t, o, r);
      h = d.fontName, f = [d.fontClass];
    } else l ? (h = $D[a].fontName, f = [a]) : (h = R0(a, t.fontWeight, t.fontShape), f = [a, t.fontWeight, t.fontShape]);
    if (cg(s, h, i).metrics)
      return Ei(s, h, i, t, o.concat(f));
    if (zD.hasOwnProperty(s) && h.slice(0, 10) === "Typewriter") {
      for (var p = [], m = 0; m < s.length; m++)
        p.push(Ei(s[m], h, i, t, o.concat(f)));
      return HD(p);
    }
  }
  if (r === "mathord")
    return Ei(s, "Math-Italic", i, t, o.concat(["mathnormal"]));
  if (r === "textord") {
    var g = Ft[i][s] && Ft[i][s].font;
    if (g === "ams") {
      var b = R0("amsrm", t.fontWeight, t.fontShape);
      return Ei(s, b, i, t, o.concat("amsrm", t.fontWeight, t.fontShape));
    } else if (g === "main" || !g) {
      var w = R0("textrm", t.fontWeight, t.fontShape);
      return Ei(s, w, i, t, o.concat(t.fontWeight, t.fontShape));
    } else {
      var k = R0(g, t.fontWeight, t.fontShape);
      return Ei(s, k, i, t, o.concat(k, t.fontWeight, t.fontShape));
    }
  } else
    throw new Error("unexpected type: " + r + " in makeOrd");
}, Soe = (n, e) => {
  if (yl(n.classes) !== yl(e.classes) || n.skew !== e.skew || n.maxFontSize !== e.maxFontSize)
    return !1;
  if (n.classes.length === 1) {
    var t = n.classes[0];
    if (t === "mbin" || t === "mord")
      return !1;
  }
  for (var r in n.style)
    if (n.style.hasOwnProperty(r) && n.style[r] !== e.style[r])
      return !1;
  for (var i in e.style)
    if (e.style.hasOwnProperty(i) && n.style[i] !== e.style[i])
      return !1;
  return !0;
}, Coe = (n) => {
  for (var e = 0; e < n.length - 1; e++) {
    var t = n[e], r = n[e + 1];
    t instanceof ki && r instanceof ki && Soe(t, r) && (t.text += r.text, t.height = Math.max(t.height, r.height), t.depth = Math.max(t.depth, r.depth), t.italic = r.italic, n.splice(e + 1, 1), e--);
  }
  return n;
}, c7 = function(e) {
  for (var t = 0, r = 0, i = 0, s = 0; s < e.children.length; s++) {
    var o = e.children[s];
    o.height > t && (t = o.height), o.depth > r && (r = o.depth), o.maxFontSize > i && (i = o.maxFontSize);
  }
  e.height = t, e.depth = r, e.maxFontSize = i;
}, kr = function(e, t, r, i) {
  var s = new Ld(e, t, r, i);
  return c7(s), s;
}, FD = (n, e, t, r) => new Ld(n, e, t, r), Moe = function(e, t, r) {
  var i = kr([e], [], t);
  return i.height = Math.max(r || t.fontMetrics().defaultRuleThickness, t.minRuleThickness), i.style.borderBottomWidth = fe(i.height), i.maxFontSize = 1, i;
}, Toe = function(e, t, r, i) {
  var s = new a7(e, t, r, i);
  return c7(s), s;
}, HD = function(e) {
  var t = new _d(e);
  return c7(t), t;
}, Aoe = function(e, t) {
  return e instanceof _d ? kr([], [e], t) : e;
}, Ooe = function(e) {
  if (e.positionType === "individualShift") {
    for (var t = e.children, r = [t[0]], i = -t[0].shift - t[0].elem.depth, s = i, o = 1; o < t.length; o++) {
      var l = -t[o].shift - s - t[o].elem.depth, a = l - (t[o - 1].elem.height + t[o - 1].elem.depth);
      s = s + l, r.push({
        type: "kern",
        size: a
      }), r.push(t[o]);
    }
    return {
      children: r,
      depth: i
    };
  }
  var c;
  if (e.positionType === "top") {
    for (var u = e.positionData, h = 0; h < e.children.length; h++) {
      var f = e.children[h];
      u -= f.type === "kern" ? f.size : f.elem.height + f.elem.depth;
    }
    c = u;
  } else if (e.positionType === "bottom")
    c = -e.positionData;
  else {
    var d = e.children[0];
    if (d.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (e.positionType === "shift")
      c = -d.elem.depth - e.positionData;
    else if (e.positionType === "firstBaseline")
      c = -d.elem.depth;
    else
      throw new Error("Invalid positionType " + e.positionType + ".");
  }
  return {
    children: e.children,
    depth: c
  };
}, Eoe = function(e, t) {
  for (var {
    children: r,
    depth: i
  } = Ooe(e), s = 0, o = 0; o < r.length; o++) {
    var l = r[o];
    if (l.type === "elem") {
      var a = l.elem;
      s = Math.max(s, a.maxFontSize, a.height);
    }
  }
  s += 2;
  var c = kr(["pstrut"], []);
  c.style.height = fe(s);
  for (var u = [], h = i, f = i, d = i, p = 0; p < r.length; p++) {
    var m = r[p];
    if (m.type === "kern")
      d += m.size;
    else {
      var g = m.elem, b = m.wrapperClasses || [], w = m.wrapperStyle || {}, k = kr(b, [c, g], void 0, w);
      k.style.top = fe(-s - d - g.depth), m.marginLeft && (k.style.marginLeft = m.marginLeft), m.marginRight && (k.style.marginRight = m.marginRight), u.push(k), d += g.height + g.depth;
    }
    h = Math.min(h, d), f = Math.max(f, d);
  }
  var C = kr(["vlist"], u);
  C.style.height = fe(f);
  var M;
  if (h < 0) {
    var T = kr([], []), N = kr(["vlist"], [T]);
    N.style.height = fe(-h);
    var B = kr(["vlist-s"], [new ki("​")]);
    M = [kr(["vlist-r"], [C, B]), kr(["vlist-r"], [N])];
  } else
    M = [kr(["vlist-r"], [C])];
  var $ = kr(["vlist-t"], M);
  return M.length === 2 && $.classes.push("vlist-t2"), $.height = f, $.depth = -h, $;
}, Ioe = (n, e) => {
  var t = kr(["mspace"], [], e), r = Qt(n, e);
  return t.style.marginRight = fe(r), t;
}, R0 = function(e, t, r) {
  var i = "";
  switch (e) {
    case "amsrm":
      i = "AMS";
      break;
    case "textrm":
      i = "Main";
      break;
    case "textsf":
      i = "SansSerif";
      break;
    case "texttt":
      i = "Typewriter";
      break;
    default:
      i = e;
  }
  var s;
  return t === "textbf" && r === "textit" ? s = "BoldItalic" : t === "textbf" ? s = "Bold" : t === "textit" ? s = "Italic" : s = "Regular", i + "-" + s;
}, $D = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  mathsfit: {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, VD = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, Doe = function(e, t) {
  var [r, i, s] = VD[e], o = new bl(r), l = new po([o], {
    width: fe(i),
    height: fe(s),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + fe(i),
    viewBox: "0 0 " + 1e3 * i + " " + 1e3 * s,
    preserveAspectRatio: "xMinYMin"
  }), a = FD(["overlay"], [l], t);
  return a.height = s, a.style.height = fe(s), a.style.width = fe(i), a;
}, H = {
  fontMap: $D,
  makeSymbol: Ei,
  mathsym: woe,
  makeSpan: kr,
  makeSvgSpan: FD,
  makeLineSpan: Moe,
  makeAnchor: Toe,
  makeFragment: HD,
  wrapFragment: Aoe,
  makeVList: Eoe,
  makeOrd: koe,
  makeGlue: Ioe,
  staticSvg: Doe,
  svgData: VD,
  tryCombineChars: Coe
}, Xt = {
  number: 3,
  unit: "mu"
}, zl = {
  number: 4,
  unit: "mu"
}, zs = {
  number: 5,
  unit: "mu"
}, Noe = {
  mord: {
    mop: Xt,
    mbin: zl,
    mrel: zs,
    minner: Xt
  },
  mop: {
    mord: Xt,
    mop: Xt,
    mrel: zs,
    minner: Xt
  },
  mbin: {
    mord: zl,
    mop: zl,
    mopen: zl,
    minner: zl
  },
  mrel: {
    mord: zs,
    mop: zs,
    mopen: zs,
    minner: zs
  },
  mopen: {},
  mclose: {
    mop: Xt,
    mbin: zl,
    mrel: zs,
    minner: Xt
  },
  mpunct: {
    mord: Xt,
    mop: Xt,
    mrel: zs,
    mopen: Xt,
    mclose: Xt,
    mpunct: Xt,
    minner: Xt
  },
  minner: {
    mord: Xt,
    mop: Xt,
    mbin: zl,
    mrel: zs,
    mopen: Xt,
    mpunct: Xt,
    minner: Xt
  }
}, Roe = {
  mord: {
    mop: Xt
  },
  mop: {
    mord: Xt,
    mop: Xt
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: Xt
  },
  mpunct: {},
  minner: {
    mop: Xt
  }
}, qD = {}, Um = {}, Km = {};
function ve(n) {
  for (var {
    type: e,
    names: t,
    props: r,
    handler: i,
    htmlBuilder: s,
    mathmlBuilder: o
  } = n, l = {
    type: e,
    numArgs: r.numArgs,
    argTypes: r.argTypes,
    allowedInArgument: !!r.allowedInArgument,
    allowedInText: !!r.allowedInText,
    allowedInMath: r.allowedInMath === void 0 ? !0 : r.allowedInMath,
    numOptionalArgs: r.numOptionalArgs || 0,
    infix: !!r.infix,
    primitive: !!r.primitive,
    handler: i
  }, a = 0; a < t.length; ++a)
    qD[t[a]] = l;
  e && (s && (Um[e] = s), o && (Km[e] = o));
}
function $a(n) {
  var {
    type: e,
    htmlBuilder: t,
    mathmlBuilder: r
  } = n;
  ve({
    type: e,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: t,
    mathmlBuilder: r
  });
}
var Gm = function(e) {
  return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
}, cn = function(e) {
  return e.type === "ordgroup" ? e.body : [e];
}, mo = H.makeSpan, Poe = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], _oe = ["rightmost", "mrel", "mclose", "mpunct"], Loe = {
  display: We.DISPLAY,
  text: We.TEXT,
  script: We.SCRIPT,
  scriptscript: We.SCRIPTSCRIPT
}, Boe = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, xn = function(e, t, r, i) {
  i === void 0 && (i = [null, null]);
  for (var s = [], o = 0; o < e.length; o++) {
    var l = ft(e[o], t);
    if (l instanceof _d) {
      var a = l.children;
      s.push(...a);
    } else
      s.push(l);
  }
  if (H.tryCombineChars(s), !r)
    return s;
  var c = t;
  if (e.length === 1) {
    var u = e[0];
    u.type === "sizing" ? c = t.havingSize(u.size) : u.type === "styling" && (c = t.havingStyle(Loe[u.style]));
  }
  var h = mo([i[0] || "leftmost"], [], t), f = mo([i[1] || "rightmost"], [], t), d = r === "root";
  return h9(s, (p, m) => {
    var g = m.classes[0], b = p.classes[0];
    g === "mbin" && Be.contains(_oe, b) ? m.classes[0] = "mord" : b === "mbin" && Be.contains(Poe, g) && (p.classes[0] = "mord");
  }, {
    node: h
  }, f, d), h9(s, (p, m) => {
    var g = D5(m), b = D5(p), w = g && b ? p.hasClass("mtight") ? Roe[g][b] : Noe[g][b] : null;
    if (w)
      return H.makeGlue(w, c);
  }, {
    node: h
  }, f, d), s;
}, h9 = function n(e, t, r, i, s) {
  i && e.push(i);
  for (var o = 0; o < e.length; o++) {
    var l = e[o], a = WD(l);
    if (a) {
      n(a.children, t, r, null, s);
      continue;
    }
    var c = !l.hasClass("mspace");
    if (c) {
      var u = t(l, r.node);
      u && (r.insertAfter ? r.insertAfter(u) : (e.unshift(u), o++));
    }
    c ? r.node = l : s && l.hasClass("newline") && (r.node = mo(["leftmost"])), r.insertAfter = /* @__PURE__ */ ((h) => (f) => {
      e.splice(h + 1, 0, f), o++;
    })(o);
  }
  i && e.pop();
}, WD = function(e) {
  return e instanceof _d || e instanceof a7 || e instanceof Ld && e.hasClass("enclosing") ? e : null;
}, zoe = function n(e, t) {
  var r = WD(e);
  if (r) {
    var i = r.children;
    if (i.length) {
      if (t === "right")
        return n(i[i.length - 1], "right");
      if (t === "left")
        return n(i[0], "left");
    }
  }
  return e;
}, D5 = function(e, t) {
  return e ? (t && (e = zoe(e, t)), Boe[e.classes[0]] || null) : null;
}, rd = function(e, t) {
  var r = ["nulldelimiter"].concat(e.baseSizingClasses());
  return mo(t.concat(r));
}, ft = function(e, t, r) {
  if (!e)
    return mo();
  if (Um[e.type]) {
    var i = Um[e.type](e, t);
    if (r && t.size !== r.size) {
      i = mo(t.sizingClasses(r), [i], t);
      var s = t.sizeMultiplier / r.sizeMultiplier;
      i.height *= s, i.depth *= s;
    }
    return i;
  } else
    throw new se("Got group of unknown type: '" + e.type + "'");
};
function P0(n, e) {
  var t = mo(["base"], n, e), r = mo(["strut"]);
  return r.style.height = fe(t.height + t.depth), t.depth && (r.style.verticalAlign = fe(-t.depth)), t.children.unshift(r), t;
}
function N5(n, e) {
  var t = null;
  n.length === 1 && n[0].type === "tag" && (t = n[0].tag, n = n[0].body);
  var r = xn(n, e, "root"), i;
  r.length === 2 && r[1].hasClass("tag") && (i = r.pop());
  for (var s = [], o = [], l = 0; l < r.length; l++)
    if (o.push(r[l]), r[l].hasClass("mbin") || r[l].hasClass("mrel") || r[l].hasClass("allowbreak")) {
      for (var a = !1; l < r.length - 1 && r[l + 1].hasClass("mspace") && !r[l + 1].hasClass("newline"); )
        l++, o.push(r[l]), r[l].hasClass("nobreak") && (a = !0);
      a || (s.push(P0(o, e)), o = []);
    } else r[l].hasClass("newline") && (o.pop(), o.length > 0 && (s.push(P0(o, e)), o = []), s.push(r[l]));
  o.length > 0 && s.push(P0(o, e));
  var c;
  t ? (c = P0(xn(t, e, !0)), c.classes = ["tag"], s.push(c)) : i && s.push(i);
  var u = mo(["katex-html"], s);
  if (u.setAttribute("aria-hidden", "true"), c) {
    var h = c.children[0];
    h.style.height = fe(u.height + u.depth), u.depth && (h.style.verticalAlign = fe(-u.depth));
  }
  return u;
}
function jD(n) {
  return new _d(n);
}
class Yr {
  constructor(e, t, r) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = t || [], this.classes = r || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && e.setAttribute(t, this.attributes[t]);
    this.classes.length > 0 && (e.className = yl(this.classes));
    for (var r = 0; r < this.children.length; r++)
      if (this.children[r] instanceof ms && this.children[r + 1] instanceof ms) {
        for (var i = this.children[r].toText() + this.children[++r].toText(); this.children[r + 1] instanceof ms; )
          i += this.children[++r].toText();
        e.appendChild(new ms(i).toNode());
      } else
        e.appendChild(this.children[r].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var e = "<" + this.type;
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="', e += Be.escape(this.attributes[t]), e += '"');
    this.classes.length > 0 && (e += ' class ="' + Be.escape(yl(this.classes)) + '"'), e += ">";
    for (var r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
}
class ms {
  constructor(e) {
    this.text = void 0, this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return Be.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class Foe {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(e) {
    this.width = void 0, this.character = void 0, this.width = e, e >= 0.05555 && e <= 0.05556 ? this.character = " " : e >= 0.1666 && e <= 0.1667 ? this.character = " " : e >= 0.2222 && e <= 0.2223 ? this.character = " " : e >= 0.2777 && e <= 0.2778 ? this.character = "  " : e >= -0.05556 && e <= -0.05555 ? this.character = " ⁣" : e >= -0.1667 && e <= -0.1666 ? this.character = " ⁣" : e >= -0.2223 && e <= -0.2222 ? this.character = " ⁣" : e >= -0.2778 && e <= -0.2777 ? this.character = " ⁣" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return e.setAttribute("width", fe(this.width)), e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + fe(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var ne = {
  MathNode: Yr,
  TextNode: ms,
  SpaceNode: Foe,
  newDocumentFragment: jD
}, Si = function(e, t, r) {
  return Ft[t][e] && Ft[t][e].replace && e.charCodeAt(0) !== 55349 && !(zD.hasOwnProperty(e) && r && (r.fontFamily && r.fontFamily.slice(4, 6) === "tt" || r.font && r.font.slice(4, 6) === "tt")) && (e = Ft[t][e].replace), new ne.TextNode(e);
}, u7 = function(e) {
  return e.length === 1 ? e[0] : new ne.MathNode("mrow", e);
}, h7 = function(e, t) {
  if (t.fontFamily === "texttt")
    return "monospace";
  if (t.fontFamily === "textsf")
    return t.fontShape === "textit" && t.fontWeight === "textbf" ? "sans-serif-bold-italic" : t.fontShape === "textit" ? "sans-serif-italic" : t.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (t.fontShape === "textit" && t.fontWeight === "textbf")
    return "bold-italic";
  if (t.fontShape === "textit")
    return "italic";
  if (t.fontWeight === "textbf")
    return "bold";
  var r = t.font;
  if (!r || r === "mathnormal")
    return null;
  var i = e.mode;
  if (r === "mathit")
    return "italic";
  if (r === "boldsymbol")
    return e.type === "textord" ? "bold" : "bold-italic";
  if (r === "mathbf")
    return "bold";
  if (r === "mathbb")
    return "double-struck";
  if (r === "mathsfit")
    return "sans-serif-italic";
  if (r === "mathfrak")
    return "fraktur";
  if (r === "mathscr" || r === "mathcal")
    return "script";
  if (r === "mathsf")
    return "sans-serif";
  if (r === "mathtt")
    return "monospace";
  var s = e.text;
  if (Be.contains(["\\imath", "\\jmath"], s))
    return null;
  Ft[i][s] && Ft[i][s].replace && (s = Ft[i][s].replace);
  var o = H.fontMap[r].fontName;
  return l7(s, o, i) ? H.fontMap[r].variant : null;
};
function a4(n) {
  if (!n)
    return !1;
  if (n.type === "mi" && n.children.length === 1) {
    var e = n.children[0];
    return e instanceof ms && e.text === ".";
  } else if (n.type === "mo" && n.children.length === 1 && n.getAttribute("separator") === "true" && n.getAttribute("lspace") === "0em" && n.getAttribute("rspace") === "0em") {
    var t = n.children[0];
    return t instanceof ms && t.text === ",";
  } else
    return !1;
}
var _r = function(e, t, r) {
  if (e.length === 1) {
    var i = Pt(e[0], t);
    return r && i instanceof Yr && i.type === "mo" && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
  }
  for (var s = [], o, l = 0; l < e.length; l++) {
    var a = Pt(e[l], t);
    if (a instanceof Yr && o instanceof Yr) {
      if (a.type === "mtext" && o.type === "mtext" && a.getAttribute("mathvariant") === o.getAttribute("mathvariant")) {
        o.children.push(...a.children);
        continue;
      } else if (a.type === "mn" && o.type === "mn") {
        o.children.push(...a.children);
        continue;
      } else if (a4(a) && o.type === "mn") {
        o.children.push(...a.children);
        continue;
      } else if (a.type === "mn" && a4(o))
        a.children = [...o.children, ...a.children], s.pop();
      else if ((a.type === "msup" || a.type === "msub") && a.children.length >= 1 && (o.type === "mn" || a4(o))) {
        var c = a.children[0];
        c instanceof Yr && c.type === "mn" && (c.children = [...o.children, ...c.children], s.pop());
      } else if (o.type === "mi" && o.children.length === 1) {
        var u = o.children[0];
        if (u instanceof ms && u.text === "̸" && (a.type === "mo" || a.type === "mi" || a.type === "mn")) {
          var h = a.children[0];
          h instanceof ms && h.text.length > 0 && (h.text = h.text.slice(0, 1) + "̸" + h.text.slice(1), s.pop());
        }
      }
    }
    s.push(a), o = a;
  }
  return s;
}, vl = function(e, t, r) {
  return u7(_r(e, t, r));
}, Pt = function(e, t) {
  if (!e)
    return new ne.MathNode("mrow");
  if (Km[e.type]) {
    var r = Km[e.type](e, t);
    return r;
  } else
    throw new se("Got group of unknown type: '" + e.type + "'");
};
function f9(n, e, t, r, i) {
  var s = _r(n, t), o;
  s.length === 1 && s[0] instanceof Yr && Be.contains(["mrow", "mtable"], s[0].type) ? o = s[0] : o = new ne.MathNode("mrow", s);
  var l = new ne.MathNode("annotation", [new ne.TextNode(e)]);
  l.setAttribute("encoding", "application/x-tex");
  var a = new ne.MathNode("semantics", [o, l]), c = new ne.MathNode("math", [a]);
  c.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), r && c.setAttribute("display", "block");
  var u = i ? "katex" : "katex-mathml";
  return H.makeSpan([u], [c]);
}
var UD = function(e) {
  return new Gs({
    style: e.displayMode ? We.DISPLAY : We.TEXT,
    maxSize: e.maxSize,
    minRuleThickness: e.minRuleThickness
  });
}, KD = function(e, t) {
  if (t.displayMode) {
    var r = ["katex-display"];
    t.leqno && r.push("leqno"), t.fleqn && r.push("fleqn"), e = H.makeSpan(r, [e]);
  }
  return e;
}, Hoe = function(e, t, r) {
  var i = UD(r), s;
  if (r.output === "mathml")
    return f9(e, t, i, r.displayMode, !0);
  if (r.output === "html") {
    var o = N5(e, i);
    s = H.makeSpan(["katex"], [o]);
  } else {
    var l = f9(e, t, i, r.displayMode, !1), a = N5(e, i);
    s = H.makeSpan(["katex"], [l, a]);
  }
  return KD(s, r);
}, $oe = function(e, t, r) {
  var i = UD(r), s = N5(e, i), o = H.makeSpan(["katex"], [s]);
  return KD(o, r);
}, Voe = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "←",
  underleftarrow: "←",
  xleftarrow: "←",
  overrightarrow: "→",
  underrightarrow: "→",
  xrightarrow: "→",
  underbrace: "⏟",
  overbrace: "⏞",
  overgroup: "⏠",
  undergroup: "⏡",
  overleftrightarrow: "↔",
  underleftrightarrow: "↔",
  xleftrightarrow: "↔",
  Overrightarrow: "⇒",
  xRightarrow: "⇒",
  overleftharpoon: "↼",
  xleftharpoonup: "↼",
  overrightharpoon: "⇀",
  xrightharpoonup: "⇀",
  xLeftarrow: "⇐",
  xLeftrightarrow: "⇔",
  xhookleftarrow: "↩",
  xhookrightarrow: "↪",
  xmapsto: "↦",
  xrightharpoondown: "⇁",
  xleftharpoondown: "↽",
  xrightleftharpoons: "⇌",
  xleftrightharpoons: "⇋",
  xtwoheadleftarrow: "↞",
  xtwoheadrightarrow: "↠",
  xlongequal: "=",
  xtofrom: "⇄",
  xrightleftarrows: "⇄",
  xrightequilibrium: "⇌",
  // Not a perfect match.
  xleftequilibrium: "⇋",
  // None better available.
  "\\cdrightarrow": "→",
  "\\cdleftarrow": "←",
  "\\cdlongequal": "="
}, qoe = function(e) {
  var t = new ne.MathNode("mo", [new ne.TextNode(Voe[e.replace(/^\\/, "")])]);
  return t.setAttribute("stretchy", "true"), t;
}, Woe = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, joe = function(e) {
  return e.type === "ordgroup" ? e.body.length : 1;
}, Uoe = function(e, t) {
  function r() {
    var l = 4e5, a = e.label.slice(1);
    if (Be.contains(["widehat", "widecheck", "widetilde", "utilde"], a)) {
      var c = e, u = joe(c.base), h, f, d;
      if (u > 5)
        a === "widehat" || a === "widecheck" ? (h = 420, l = 2364, d = 0.42, f = a + "4") : (h = 312, l = 2340, d = 0.34, f = "tilde4");
      else {
        var p = [1, 1, 2, 2, 3, 3][u];
        a === "widehat" || a === "widecheck" ? (l = [0, 1062, 2364, 2364, 2364][p], h = [0, 239, 300, 360, 420][p], d = [0, 0.24, 0.3, 0.3, 0.36, 0.42][p], f = a + p) : (l = [0, 600, 1033, 2339, 2340][p], h = [0, 260, 286, 306, 312][p], d = [0, 0.26, 0.286, 0.3, 0.306, 0.34][p], f = "tilde" + p);
      }
      var m = new bl(f), g = new po([m], {
        width: "100%",
        height: fe(d),
        viewBox: "0 0 " + l + " " + h,
        preserveAspectRatio: "none"
      });
      return {
        span: H.makeSvgSpan([], [g], t),
        minWidth: 0,
        height: d
      };
    } else {
      var b = [], w = Woe[a], [k, C, M] = w, T = M / 1e3, N = k.length, B, $;
      if (N === 1) {
        var R = w[3];
        B = ["hide-tail"], $ = [R];
      } else if (N === 2)
        B = ["halfarrow-left", "halfarrow-right"], $ = ["xMinYMin", "xMaxYMin"];
      else if (N === 3)
        B = ["brace-left", "brace-center", "brace-right"], $ = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + N + " children.");
      for (var V = 0; V < N; V++) {
        var z = new bl(k[V]), ue = new po([z], {
          width: "400em",
          height: fe(T),
          viewBox: "0 0 " + l + " " + M,
          preserveAspectRatio: $[V] + " slice"
        }), ie = H.makeSvgSpan([B[V]], [ue], t);
        if (N === 1)
          return {
            span: ie,
            minWidth: C,
            height: T
          };
        ie.style.height = fe(T), b.push(ie);
      }
      return {
        span: H.makeSpan(["stretchy"], b, t),
        minWidth: C,
        height: T
      };
    }
  }
  var {
    span: i,
    minWidth: s,
    height: o
  } = r();
  return i.height = o, i.style.height = fe(o), s > 0 && (i.style.minWidth = fe(s)), i;
}, Koe = function(e, t, r, i, s) {
  var o, l = e.height + e.depth + r + i;
  if (/fbox|color|angl/.test(t)) {
    if (o = H.makeSpan(["stretchy", t], [], s), t === "fbox") {
      var a = s.color && s.getColor();
      a && (o.style.borderColor = a);
    }
  } else {
    var c = [];
    /^[bx]cancel$/.test(t) && c.push(new E5({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(t) && c.push(new E5({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var u = new po(c, {
      width: "100%",
      height: fe(l)
    });
    o = H.makeSvgSpan([], [u], s);
  }
  return o.height = l, o.style.height = fe(l), o;
}, go = {
  encloseSpan: Koe,
  mathMLnode: qoe,
  svgSpan: Uoe
};
function Qe(n, e) {
  if (!n || n.type !== e)
    throw new Error("Expected node of type " + e + ", but got " + (n ? "node of type " + n.type : String(n)));
  return n;
}
function f7(n) {
  var e = ug(n);
  if (!e)
    throw new Error("Expected node of symbol group type, but got " + (n ? "node of type " + n.type : String(n)));
  return e;
}
function ug(n) {
  return n && (n.type === "atom" || boe.hasOwnProperty(n.type)) ? n : null;
}
var d7 = (n, e) => {
  var t, r, i;
  n && n.type === "supsub" ? (r = Qe(n.base, "accent"), t = r.base, n.base = t, i = goe(ft(n, e)), n.base = r) : (r = Qe(n, "accent"), t = r.base);
  var s = ft(t, e.havingCrampedStyle()), o = r.isShifty && Be.isCharacterBox(t), l = 0;
  if (o) {
    var a = Be.getBaseElem(t), c = ft(a, e.havingCrampedStyle());
    l = s9(c).skew;
  }
  var u = r.label === "\\c", h = u ? s.height + s.depth : Math.min(s.height, e.fontMetrics().xHeight), f;
  if (r.isStretchy)
    f = go.svgSpan(r, e), f = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "elem",
        elem: f,
        wrapperClasses: ["svg-align"],
        wrapperStyle: l > 0 ? {
          width: "calc(100% - " + fe(2 * l) + ")",
          marginLeft: fe(2 * l)
        } : void 0
      }]
    }, e);
  else {
    var d, p;
    r.label === "\\vec" ? (d = H.staticSvg("vec", e), p = H.svgData.vec[1]) : (d = H.makeOrd({
      mode: r.mode,
      text: r.label
    }, e, "textord"), d = s9(d), d.italic = 0, p = d.width, u && (h += d.depth)), f = H.makeSpan(["accent-body"], [d]);
    var m = r.label === "\\textcircled";
    m && (f.classes.push("accent-full"), h = s.height);
    var g = l;
    m || (g -= p / 2), f.style.left = fe(g), r.label === "\\textcircled" && (f.style.top = ".2em"), f = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "kern",
        size: -h
      }, {
        type: "elem",
        elem: f
      }]
    }, e);
  }
  var b = H.makeSpan(["mord", "accent"], [f], e);
  return i ? (i.children[0] = b, i.height = Math.max(b.height, i.height), i.classes[0] = "mord", i) : b;
}, GD = (n, e) => {
  var t = n.isStretchy ? go.mathMLnode(n.label) : new ne.MathNode("mo", [Si(n.label, n.mode)]), r = new ne.MathNode("mover", [Pt(n.base, e), t]);
  return r.setAttribute("accent", "true"), r;
}, Goe = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((n) => "\\" + n).join("|"));
ve({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var t = Gm(e[0]), r = !Goe.test(n.funcName), i = !r || n.funcName === "\\widehat" || n.funcName === "\\widetilde" || n.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: n.parser.mode,
      label: n.funcName,
      isStretchy: r,
      isShifty: i,
      base: t
    };
  },
  htmlBuilder: d7,
  mathmlBuilder: GD
});
ve({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (n, e) => {
    var t = e[0], r = n.parser.mode;
    return r === "math" && (n.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + n.funcName + " works only in text mode"), r = "text"), {
      type: "accent",
      mode: r,
      label: n.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: t
    };
  },
  htmlBuilder: d7,
  mathmlBuilder: GD
});
ve({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "accentUnder",
      mode: t.mode,
      label: r,
      base: i
    };
  },
  htmlBuilder: (n, e) => {
    var t = ft(n.base, e), r = go.svgSpan(n, e), i = n.label === "\\utilde" ? 0.12 : 0, s = H.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return H.makeSpan(["mord", "accentunder"], [s], e);
  },
  mathmlBuilder: (n, e) => {
    var t = go.mathMLnode(n.label), r = new ne.MathNode("munder", [Pt(n.base, e), t]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
var _0 = (n) => {
  var e = new ne.MathNode("mpadded", n ? [n] : []);
  return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
};
ve({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n;
    return {
      type: "xArrow",
      mode: r.mode,
      label: i,
      body: e[0],
      below: t[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(n, e) {
    var t = e.style, r = e.havingStyle(t.sup()), i = H.wrapFragment(ft(n.body, r, e), e), s = n.label.slice(0, 2) === "\\x" ? "x" : "cd";
    i.classes.push(s + "-arrow-pad");
    var o;
    n.below && (r = e.havingStyle(t.sub()), o = H.wrapFragment(ft(n.below, r, e), e), o.classes.push(s + "-arrow-pad"));
    var l = go.svgSpan(n, e), a = -e.fontMetrics().axisHeight + 0.5 * l.height, c = -e.fontMetrics().axisHeight - 0.5 * l.height - 0.111;
    (i.depth > 0.25 || n.label === "\\xleftequilibrium") && (c -= i.depth);
    var u;
    if (o) {
      var h = -e.fontMetrics().axisHeight + o.height + 0.5 * l.height + 0.111;
      u = H.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: c
        }, {
          type: "elem",
          elem: l,
          shift: a
        }, {
          type: "elem",
          elem: o,
          shift: h
        }]
      }, e);
    } else
      u = H.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: c
        }, {
          type: "elem",
          elem: l,
          shift: a
        }]
      }, e);
    return u.children[0].children[0].children[1].classes.push("svg-align"), H.makeSpan(["mrel", "x-arrow"], [u], e);
  },
  mathmlBuilder(n, e) {
    var t = go.mathMLnode(n.label);
    t.setAttribute("minsize", n.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var r;
    if (n.body) {
      var i = _0(Pt(n.body, e));
      if (n.below) {
        var s = _0(Pt(n.below, e));
        r = new ne.MathNode("munderover", [t, s, i]);
      } else
        r = new ne.MathNode("mover", [t, i]);
    } else if (n.below) {
      var o = _0(Pt(n.below, e));
      r = new ne.MathNode("munder", [t, o]);
    } else
      r = _0(), r = new ne.MathNode("mover", [t, r]);
    return r;
  }
});
var Yoe = H.makeSpan;
function YD(n, e) {
  var t = xn(n.body, e, !0);
  return Yoe([n.mclass], t, e);
}
function JD(n, e) {
  var t, r = _r(n.body, e);
  return n.mclass === "minner" ? t = new ne.MathNode("mpadded", r) : n.mclass === "mord" ? n.isCharacterBox ? (t = r[0], t.type = "mi") : t = new ne.MathNode("mi", r) : (n.isCharacterBox ? (t = r[0], t.type = "mo") : t = new ne.MathNode("mo", r), n.mclass === "mbin" ? (t.attributes.lspace = "0.22em", t.attributes.rspace = "0.22em") : n.mclass === "mpunct" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0.17em") : n.mclass === "mopen" || n.mclass === "mclose" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0em") : n.mclass === "minner" && (t.attributes.lspace = "0.0556em", t.attributes.width = "+0.1111em")), t;
}
ve({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "mclass",
      mode: t.mode,
      mclass: "m" + r.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: cn(i),
      isCharacterBox: Be.isCharacterBox(i)
    };
  },
  htmlBuilder: YD,
  mathmlBuilder: JD
});
var hg = (n) => {
  var e = n.type === "ordgroup" && n.body.length ? n.body[0] : n;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
ve({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "mclass",
      mode: t.mode,
      mclass: hg(e[0]),
      body: cn(e[1]),
      isCharacterBox: Be.isCharacterBox(e[1])
    };
  }
});
ve({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[1], s = e[0], o;
    r !== "\\stackrel" ? o = hg(i) : o = "mrel";
    var l = {
      type: "op",
      mode: i.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: r !== "\\stackrel",
      body: cn(i)
    }, a = {
      type: "supsub",
      mode: s.mode,
      base: l,
      sup: r === "\\underset" ? null : s,
      sub: r === "\\underset" ? s : null
    };
    return {
      type: "mclass",
      mode: t.mode,
      mclass: o,
      body: [a],
      isCharacterBox: Be.isCharacterBox(a)
    };
  },
  htmlBuilder: YD,
  mathmlBuilder: JD
});
ve({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "pmb",
      mode: t.mode,
      mclass: hg(e[0]),
      body: cn(e[0])
    };
  },
  htmlBuilder(n, e) {
    var t = xn(n.body, e, !0), r = H.makeSpan([n.mclass], t, e);
    return r.style.textShadow = "0.02em 0.01em 0.04px", r;
  },
  mathmlBuilder(n, e) {
    var t = _r(n.body, e), r = new ne.MathNode("mstyle", t);
    return r.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), r;
  }
});
var Joe = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, d9 = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), p9 = (n) => n.type === "textord" && n.text === "@", Xoe = (n, e) => (n.type === "mathord" || n.type === "atom") && n.text === e;
function Zoe(n, e, t) {
  var r = Joe[n];
  switch (r) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return t.callFunction(r, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var i = t.callFunction("\\\\cdleft", [e[0]], []), s = {
        type: "atom",
        text: r,
        mode: "math",
        family: "rel"
      }, o = t.callFunction("\\Big", [s], []), l = t.callFunction("\\\\cdright", [e[1]], []), a = {
        type: "ordgroup",
        mode: "math",
        body: [i, o, l]
      };
      return t.callFunction("\\\\cdparent", [a], []);
    }
    case "\\\\cdlongequal":
      return t.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var c = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return t.callFunction("\\Big", [c], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function Qoe(n) {
  var e = [];
  for (n.gullet.beginGroup(), n.gullet.macros.set("\\cr", "\\\\\\relax"), n.gullet.beginGroup(); ; ) {
    e.push(n.parseExpression(!1, "\\\\")), n.gullet.endGroup(), n.gullet.beginGroup();
    var t = n.fetch().text;
    if (t === "&" || t === "\\\\")
      n.consume();
    else if (t === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new se("Expected \\\\ or \\cr or \\end", n.nextToken);
  }
  for (var r = [], i = [r], s = 0; s < e.length; s++) {
    for (var o = e[s], l = d9(), a = 0; a < o.length; a++)
      if (!p9(o[a]))
        l.body.push(o[a]);
      else {
        r.push(l), a += 1;
        var c = f7(o[a]).text, u = new Array(2);
        if (u[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, u[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(c) > -1)) if ("<>AV".indexOf(c) > -1)
          for (var h = 0; h < 2; h++) {
            for (var f = !0, d = a + 1; d < o.length; d++) {
              if (Xoe(o[d], c)) {
                f = !1, a = d;
                break;
              }
              if (p9(o[d]))
                throw new se("Missing a " + c + " character to complete a CD arrow.", o[d]);
              u[h].body.push(o[d]);
            }
            if (f)
              throw new se("Missing a " + c + " character to complete a CD arrow.", o[a]);
          }
        else
          throw new se('Expected one of "<>AV=|." after @', o[a]);
        var p = Zoe(c, u, n), m = {
          type: "styling",
          body: [p],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        r.push(m), l = d9();
      }
    s % 2 === 0 ? r.push(l) : r.shift(), r = [], i.push(r);
  }
  n.gullet.endGroup(), n.gullet.endGroup();
  var g = new Array(i[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: i,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: g,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(i.length + 1).fill([])
  };
}
ve({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n;
    return {
      type: "cdlabel",
      mode: t.mode,
      side: r.slice(4),
      label: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = e.havingStyle(e.style.sup()), r = H.wrapFragment(ft(n.label, t, e), e);
    return r.classes.push("cd-label-" + n.side), r.style.bottom = fe(0.8 - r.depth), r.height = 0, r.depth = 0, r;
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mrow", [Pt(n.label, e)]);
    return t = new ne.MathNode("mpadded", [t]), t.setAttribute("width", "0"), n.side === "left" && t.setAttribute("lspace", "-1width"), t.setAttribute("voffset", "0.7em"), t = new ne.MathNode("mstyle", [t]), t.setAttribute("displaystyle", "false"), t.setAttribute("scriptlevel", "1"), t;
  }
});
ve({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "cdlabelparent",
      mode: t.mode,
      fragment: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = H.wrapFragment(ft(n.fragment, e), e);
    return t.classes.push("cd-vert-arrow"), t;
  },
  mathmlBuilder(n, e) {
    return new ne.MathNode("mrow", [Pt(n.fragment, e)]);
  }
});
ve({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    for (var {
      parser: t
    } = n, r = Qe(e[0], "ordgroup"), i = r.body, s = "", o = 0; o < i.length; o++) {
      var l = Qe(i[o], "textord");
      s += l.text;
    }
    var a = parseInt(s), c;
    if (isNaN(a))
      throw new se("\\@char has non-numeric argument " + s);
    if (a < 0 || a >= 1114111)
      throw new se("\\@char with invalid code point " + s);
    return a <= 65535 ? c = String.fromCharCode(a) : (a -= 65536, c = String.fromCharCode((a >> 10) + 55296, (a & 1023) + 56320)), {
      type: "textord",
      mode: t.mode,
      text: c
    };
  }
});
var XD = (n, e) => {
  var t = xn(n.body, e.withColor(n.color), !1);
  return H.makeFragment(t);
}, ZD = (n, e) => {
  var t = _r(n.body, e.withColor(n.color)), r = new ne.MathNode("mstyle", t);
  return r.setAttribute("mathcolor", n.color), r;
};
ve({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = Qe(e[0], "color-token").color, i = e[1];
    return {
      type: "color",
      mode: t.mode,
      color: r,
      body: cn(i)
    };
  },
  htmlBuilder: XD,
  mathmlBuilder: ZD
});
ve({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(n, e) {
    var {
      parser: t,
      breakOnTokenText: r
    } = n, i = Qe(e[0], "color-token").color;
    t.gullet.macros.set("\\current@color", i);
    var s = t.parseExpression(!0, r);
    return {
      type: "color",
      mode: t.mode,
      color: i,
      body: s
    };
  },
  htmlBuilder: XD,
  mathmlBuilder: ZD
});
ve({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = r.gullet.future().text === "[" ? r.parseSizeGroup(!0) : null, s = !r.settings.displayMode || !r.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: r.mode,
      newLine: s,
      size: i && Qe(i, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(n, e) {
    var t = H.makeSpan(["mspace"], [], e);
    return n.newLine && (t.classes.push("newline"), n.size && (t.style.marginTop = fe(Qt(n.size, e)))), t;
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mspace");
    return n.newLine && (t.setAttribute("linebreak", "newline"), n.size && t.setAttribute("height", fe(Qt(n.size, e)))), t;
  }
});
var R5 = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, QD = (n) => {
  var e = n.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new se("Expected a control sequence", n);
  return e;
}, ele = (n) => {
  var e = n.gullet.popToken();
  return e.text === "=" && (e = n.gullet.popToken(), e.text === " " && (e = n.gullet.popToken())), e;
}, eN = (n, e, t, r) => {
  var i = n.gullet.macros.get(t.text);
  i == null && (t.noexpand = !0, i = {
    tokens: [t],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !n.gullet.isExpandable(t.text)
  }), n.gullet.macros.set(e, i, r);
};
ve({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    e.consumeSpaces();
    var r = e.fetch();
    if (R5[r.text])
      return (t === "\\global" || t === "\\\\globallong") && (r.text = R5[r.text]), Qe(e.parseFunction(), "internal");
    throw new se("Invalid token after macro prefix", r);
  }
});
ve({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = e.gullet.popToken(), i = r.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(i))
      throw new se("Expected a control sequence", r);
    for (var s = 0, o, l = [[]]; e.gullet.future().text !== "{"; )
      if (r = e.gullet.popToken(), r.text === "#") {
        if (e.gullet.future().text === "{") {
          o = e.gullet.future(), l[s].push("{");
          break;
        }
        if (r = e.gullet.popToken(), !/^[1-9]$/.test(r.text))
          throw new se('Invalid argument number "' + r.text + '"');
        if (parseInt(r.text) !== s + 1)
          throw new se('Argument number "' + r.text + '" out of order');
        s++, l.push([]);
      } else {
        if (r.text === "EOF")
          throw new se("Expected a macro definition");
        l[s].push(r.text);
      }
    var {
      tokens: a
    } = e.gullet.consumeArg();
    return o && a.unshift(o), (t === "\\edef" || t === "\\xdef") && (a = e.gullet.expandTokens(a), a.reverse()), e.gullet.macros.set(i, {
      tokens: a,
      numArgs: s,
      delimiters: l
    }, t === R5[t]), {
      type: "internal",
      mode: e.mode
    };
  }
});
ve({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = QD(e.gullet.popToken());
    e.gullet.consumeSpaces();
    var i = ele(e);
    return eN(e, r, i, t === "\\\\globallet"), {
      type: "internal",
      mode: e.mode
    };
  }
});
ve({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = QD(e.gullet.popToken()), i = e.gullet.popToken(), s = e.gullet.popToken();
    return eN(e, r, s, t === "\\\\globalfuture"), e.gullet.pushToken(s), e.gullet.pushToken(i), {
      type: "internal",
      mode: e.mode
    };
  }
});
var vh = function(e, t, r) {
  var i = Ft.math[e] && Ft.math[e].replace, s = l7(i || e, t, r);
  if (!s)
    throw new Error("Unsupported symbol " + e + " and font size " + t + ".");
  return s;
}, p7 = function(e, t, r, i) {
  var s = r.havingBaseStyle(t), o = H.makeSpan(i.concat(s.sizingClasses(r)), [e], r), l = s.sizeMultiplier / r.sizeMultiplier;
  return o.height *= l, o.depth *= l, o.maxFontSize = s.sizeMultiplier, o;
}, tN = function(e, t, r) {
  var i = t.havingBaseStyle(r), s = (1 - t.sizeMultiplier / i.sizeMultiplier) * t.fontMetrics().axisHeight;
  e.classes.push("delimcenter"), e.style.top = fe(s), e.height -= s, e.depth += s;
}, tle = function(e, t, r, i, s, o) {
  var l = H.makeSymbol(e, "Main-Regular", s, i), a = p7(l, t, i, o);
  return r && tN(a, i, t), a;
}, nle = function(e, t, r, i) {
  return H.makeSymbol(e, "Size" + t + "-Regular", r, i);
}, nN = function(e, t, r, i, s, o) {
  var l = nle(e, t, s, i), a = p7(H.makeSpan(["delimsizing", "size" + t], [l], i), We.TEXT, i, o);
  return r && tN(a, i, We.TEXT), a;
}, c4 = function(e, t, r) {
  var i;
  t === "Size1-Regular" ? i = "delim-size1" : i = "delim-size4";
  var s = H.makeSpan(["delimsizinginner", i], [H.makeSpan([], [H.makeSymbol(e, t, r)])]);
  return {
    type: "elem",
    elem: s
  };
}, u4 = function(e, t, r) {
  var i = ps["Size4-Regular"][e.charCodeAt(0)] ? ps["Size4-Regular"][e.charCodeAt(0)][4] : ps["Size1-Regular"][e.charCodeAt(0)][4], s = new bl("inner", loe(e, Math.round(1e3 * t))), o = new po([s], {
    width: fe(i),
    height: fe(t),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + fe(i),
    viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * t),
    preserveAspectRatio: "xMinYMin"
  }), l = H.makeSvgSpan([], [o], r);
  return l.height = t, l.style.height = fe(t), l.style.width = fe(i), {
    type: "elem",
    elem: l
  };
}, P5 = 8e-3, L0 = {
  type: "kern",
  size: -1 * P5
}, rle = ["|", "\\lvert", "\\rvert", "\\vert"], ile = ["\\|", "\\lVert", "\\rVert", "\\Vert"], rN = function(e, t, r, i, s, o) {
  var l, a, c, u, h = "", f = 0;
  l = c = u = e, a = null;
  var d = "Size1-Regular";
  e === "\\uparrow" ? c = u = "⏐" : e === "\\Uparrow" ? c = u = "‖" : e === "\\downarrow" ? l = c = "⏐" : e === "\\Downarrow" ? l = c = "‖" : e === "\\updownarrow" ? (l = "\\uparrow", c = "⏐", u = "\\downarrow") : e === "\\Updownarrow" ? (l = "\\Uparrow", c = "‖", u = "\\Downarrow") : Be.contains(rle, e) ? (c = "∣", h = "vert", f = 333) : Be.contains(ile, e) ? (c = "∥", h = "doublevert", f = 556) : e === "[" || e === "\\lbrack" ? (l = "⎡", c = "⎢", u = "⎣", d = "Size4-Regular", h = "lbrack", f = 667) : e === "]" || e === "\\rbrack" ? (l = "⎤", c = "⎥", u = "⎦", d = "Size4-Regular", h = "rbrack", f = 667) : e === "\\lfloor" || e === "⌊" ? (c = l = "⎢", u = "⎣", d = "Size4-Regular", h = "lfloor", f = 667) : e === "\\lceil" || e === "⌈" ? (l = "⎡", c = u = "⎢", d = "Size4-Regular", h = "lceil", f = 667) : e === "\\rfloor" || e === "⌋" ? (c = l = "⎥", u = "⎦", d = "Size4-Regular", h = "rfloor", f = 667) : e === "\\rceil" || e === "⌉" ? (l = "⎤", c = u = "⎥", d = "Size4-Regular", h = "rceil", f = 667) : e === "(" || e === "\\lparen" ? (l = "⎛", c = "⎜", u = "⎝", d = "Size4-Regular", h = "lparen", f = 875) : e === ")" || e === "\\rparen" ? (l = "⎞", c = "⎟", u = "⎠", d = "Size4-Regular", h = "rparen", f = 875) : e === "\\{" || e === "\\lbrace" ? (l = "⎧", a = "⎨", u = "⎩", c = "⎪", d = "Size4-Regular") : e === "\\}" || e === "\\rbrace" ? (l = "⎫", a = "⎬", u = "⎭", c = "⎪", d = "Size4-Regular") : e === "\\lgroup" || e === "⟮" ? (l = "⎧", u = "⎩", c = "⎪", d = "Size4-Regular") : e === "\\rgroup" || e === "⟯" ? (l = "⎫", u = "⎭", c = "⎪", d = "Size4-Regular") : e === "\\lmoustache" || e === "⎰" ? (l = "⎧", u = "⎭", c = "⎪", d = "Size4-Regular") : (e === "\\rmoustache" || e === "⎱") && (l = "⎫", u = "⎩", c = "⎪", d = "Size4-Regular");
  var p = vh(l, d, s), m = p.height + p.depth, g = vh(c, d, s), b = g.height + g.depth, w = vh(u, d, s), k = w.height + w.depth, C = 0, M = 1;
  if (a !== null) {
    var T = vh(a, d, s);
    C = T.height + T.depth, M = 2;
  }
  var N = m + k + C, B = Math.max(0, Math.ceil((t - N) / (M * b))), $ = N + B * M * b, R = i.fontMetrics().axisHeight;
  r && (R *= i.sizeMultiplier);
  var V = $ / 2 - R, z = [];
  if (h.length > 0) {
    var ue = $ - m - k, ie = Math.round($ * 1e3), he = aoe(h, Math.round(ue * 1e3)), Ce = new bl(h, he), ye = (f / 1e3).toFixed(3) + "em", be = (ie / 1e3).toFixed(3) + "em", ze = new po([Ce], {
      width: ye,
      height: be,
      viewBox: "0 0 " + f + " " + ie
    }), I = H.makeSvgSpan([], [ze], i);
    I.height = ie / 1e3, I.style.width = ye, I.style.height = be, z.push({
      type: "elem",
      elem: I
    });
  } else {
    if (z.push(c4(u, d, s)), z.push(L0), a === null) {
      var Ie = $ - m - k + 2 * P5;
      z.push(u4(c, Ie, i));
    } else {
      var Ve = ($ - m - k - C) / 2 + 2 * P5;
      z.push(u4(c, Ve, i)), z.push(L0), z.push(c4(a, d, s)), z.push(L0), z.push(u4(c, Ve, i));
    }
    z.push(L0), z.push(c4(l, d, s));
  }
  var O = i.havingBaseStyle(We.TEXT), pt = H.makeVList({
    positionType: "bottom",
    positionData: V,
    children: z
  }, O);
  return p7(H.makeSpan(["delimsizing", "mult"], [pt], O), We.TEXT, i, o);
}, h4 = 80, f4 = 0.08, d4 = function(e, t, r, i, s) {
  var o = ooe(e, i, r), l = new bl(e, o), a = new po([l], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: fe(t),
    viewBox: "0 0 400000 " + r,
    preserveAspectRatio: "xMinYMin slice"
  });
  return H.makeSvgSpan(["hide-tail"], [a], s);
}, sle = function(e, t) {
  var r = t.havingBaseSizing(), i = lN("\\surd", e * r.sizeMultiplier, oN, r), s = r.sizeMultiplier, o = Math.max(0, t.minRuleThickness - t.fontMetrics().sqrtRuleThickness), l, a = 0, c = 0, u = 0, h;
  return i.type === "small" ? (u = 1e3 + 1e3 * o + h4, e < 1 ? s = 1 : e < 1.4 && (s = 0.7), a = (1 + o + f4) / s, c = (1 + o) / s, l = d4("sqrtMain", a, u, o, t), l.style.minWidth = "0.853em", h = 0.833 / s) : i.type === "large" ? (u = (1e3 + h4) * mf[i.size], c = (mf[i.size] + o) / s, a = (mf[i.size] + o + f4) / s, l = d4("sqrtSize" + i.size, a, u, o, t), l.style.minWidth = "1.02em", h = 1 / s) : (a = e + o + f4, c = e + o, u = Math.floor(1e3 * e + o) + h4, l = d4("sqrtTall", a, u, o, t), l.style.minWidth = "0.742em", h = 1.056), l.height = c, l.style.height = fe(a), {
    span: l,
    advanceWidth: h,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (t.fontMetrics().sqrtRuleThickness + o) * s
  };
}, iN = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"], ole = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"], sN = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], mf = [0, 1.2, 1.8, 2.4, 3], lle = function(e, t, r, i, s) {
  if (e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle"), Be.contains(iN, e) || Be.contains(sN, e))
    return nN(e, t, !1, r, i, s);
  if (Be.contains(ole, e))
    return rN(e, mf[t], !1, r, i, s);
  throw new se("Illegal delimiter: '" + e + "'");
}, ale = [{
  type: "small",
  style: We.SCRIPTSCRIPT
}, {
  type: "small",
  style: We.SCRIPT
}, {
  type: "small",
  style: We.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], cle = [{
  type: "small",
  style: We.SCRIPTSCRIPT
}, {
  type: "small",
  style: We.SCRIPT
}, {
  type: "small",
  style: We.TEXT
}, {
  type: "stack"
}], oN = [{
  type: "small",
  style: We.SCRIPTSCRIPT
}, {
  type: "small",
  style: We.SCRIPT
}, {
  type: "small",
  style: We.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], ule = function(e) {
  if (e.type === "small")
    return "Main-Regular";
  if (e.type === "large")
    return "Size" + e.size + "-Regular";
  if (e.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + e.type + "' here.");
}, lN = function(e, t, r, i) {
  for (var s = Math.min(2, 3 - i.style.size), o = s; o < r.length && r[o].type !== "stack"; o++) {
    var l = vh(e, ule(r[o]), "math"), a = l.height + l.depth;
    if (r[o].type === "small") {
      var c = i.havingBaseStyle(r[o].style);
      a *= c.sizeMultiplier;
    }
    if (a > t)
      return r[o];
  }
  return r[r.length - 1];
}, aN = function(e, t, r, i, s, o) {
  e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle");
  var l;
  Be.contains(sN, e) ? l = ale : Be.contains(iN, e) ? l = oN : l = cle;
  var a = lN(e, t, l, i);
  return a.type === "small" ? tle(e, a.style, r, i, s, o) : a.type === "large" ? nN(e, a.size, r, i, s, o) : rN(e, t, r, i, s, o);
}, hle = function(e, t, r, i, s, o) {
  var l = i.fontMetrics().axisHeight * i.sizeMultiplier, a = 901, c = 5 / i.fontMetrics().ptPerEm, u = Math.max(t - l, r + l), h = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    u / 500 * a,
    2 * u - c
  );
  return aN(e, h, !0, i, s, o);
}, so = {
  sqrtImage: sle,
  sizedDelim: lle,
  sizeToMaxHeight: mf,
  customSizedDelim: aN,
  leftRightDelim: hle
}, m9 = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, fle = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function fg(n, e) {
  var t = ug(n);
  if (t && Be.contains(fle, t.text))
    return t;
  throw t ? new se("Invalid delimiter '" + t.text + "' after '" + e.funcName + "'", n) : new se("Invalid delimiter type '" + n.type + "'", n);
}
ve({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (n, e) => {
    var t = fg(e[0], n);
    return {
      type: "delimsizing",
      mode: n.parser.mode,
      size: m9[n.funcName].size,
      mclass: m9[n.funcName].mclass,
      delim: t.text
    };
  },
  htmlBuilder: (n, e) => n.delim === "." ? H.makeSpan([n.mclass]) : so.sizedDelim(n.delim, n.size, e, n.mode, [n.mclass]),
  mathmlBuilder: (n) => {
    var e = [];
    n.delim !== "." && e.push(Si(n.delim, n.mode));
    var t = new ne.MathNode("mo", e);
    n.mclass === "mopen" || n.mclass === "mclose" ? t.setAttribute("fence", "true") : t.setAttribute("fence", "false"), t.setAttribute("stretchy", "true");
    var r = fe(so.sizeToMaxHeight[n.size]);
    return t.setAttribute("minsize", r), t.setAttribute("maxsize", r), t;
  }
});
function g9(n) {
  if (!n.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
ve({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = n.parser.gullet.macros.get("\\current@color");
    if (t && typeof t != "string")
      throw new se("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: n.parser.mode,
      delim: fg(e[0], n).text,
      color: t
      // undefined if not set via \color
    };
  }
});
ve({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = fg(e[0], n), r = n.parser;
    ++r.leftrightDepth;
    var i = r.parseExpression(!1);
    --r.leftrightDepth, r.expect("\\right", !1);
    var s = Qe(r.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: r.mode,
      body: i,
      left: t.text,
      right: s.delim,
      rightColor: s.color
    };
  },
  htmlBuilder: (n, e) => {
    g9(n);
    for (var t = xn(n.body, e, !0, ["mopen", "mclose"]), r = 0, i = 0, s = !1, o = 0; o < t.length; o++)
      t[o].isMiddle ? s = !0 : (r = Math.max(t[o].height, r), i = Math.max(t[o].depth, i));
    r *= e.sizeMultiplier, i *= e.sizeMultiplier;
    var l;
    if (n.left === "." ? l = rd(e, ["mopen"]) : l = so.leftRightDelim(n.left, r, i, e, n.mode, ["mopen"]), t.unshift(l), s)
      for (var a = 1; a < t.length; a++) {
        var c = t[a], u = c.isMiddle;
        u && (t[a] = so.leftRightDelim(u.delim, r, i, u.options, n.mode, []));
      }
    var h;
    if (n.right === ".")
      h = rd(e, ["mclose"]);
    else {
      var f = n.rightColor ? e.withColor(n.rightColor) : e;
      h = so.leftRightDelim(n.right, r, i, f, n.mode, ["mclose"]);
    }
    return t.push(h), H.makeSpan(["minner"], t, e);
  },
  mathmlBuilder: (n, e) => {
    g9(n);
    var t = _r(n.body, e);
    if (n.left !== ".") {
      var r = new ne.MathNode("mo", [Si(n.left, n.mode)]);
      r.setAttribute("fence", "true"), t.unshift(r);
    }
    if (n.right !== ".") {
      var i = new ne.MathNode("mo", [Si(n.right, n.mode)]);
      i.setAttribute("fence", "true"), n.rightColor && i.setAttribute("mathcolor", n.rightColor), t.push(i);
    }
    return u7(t);
  }
});
ve({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = fg(e[0], n);
    if (!n.parser.leftrightDepth)
      throw new se("\\middle without preceding \\left", t);
    return {
      type: "middle",
      mode: n.parser.mode,
      delim: t.text
    };
  },
  htmlBuilder: (n, e) => {
    var t;
    if (n.delim === ".")
      t = rd(e, []);
    else {
      t = so.sizedDelim(n.delim, 1, e, n.mode, []);
      var r = {
        delim: n.delim,
        options: e
      };
      t.isMiddle = r;
    }
    return t;
  },
  mathmlBuilder: (n, e) => {
    var t = n.delim === "\\vert" || n.delim === "|" ? Si("|", "text") : Si(n.delim, n.mode), r = new ne.MathNode("mo", [t]);
    return r.setAttribute("fence", "true"), r.setAttribute("lspace", "0.05em"), r.setAttribute("rspace", "0.05em"), r;
  }
});
var m7 = (n, e) => {
  var t = H.wrapFragment(ft(n.body, e), e), r = n.label.slice(1), i = e.sizeMultiplier, s, o = 0, l = Be.isCharacterBox(n.body);
  if (r === "sout")
    s = H.makeSpan(["stretchy", "sout"]), s.height = e.fontMetrics().defaultRuleThickness / i, o = -0.5 * e.fontMetrics().xHeight;
  else if (r === "phase") {
    var a = Qt({
      number: 0.6,
      unit: "pt"
    }, e), c = Qt({
      number: 0.35,
      unit: "ex"
    }, e), u = e.havingBaseSizing();
    i = i / u.sizeMultiplier;
    var h = t.height + t.depth + a + c;
    t.style.paddingLeft = fe(h / 2 + a);
    var f = Math.floor(1e3 * h * i), d = ioe(f), p = new po([new bl("phase", d)], {
      width: "400em",
      height: fe(f / 1e3),
      viewBox: "0 0 400000 " + f,
      preserveAspectRatio: "xMinYMin slice"
    });
    s = H.makeSvgSpan(["hide-tail"], [p], e), s.style.height = fe(h), o = t.depth + a + c;
  } else {
    /cancel/.test(r) ? l || t.classes.push("cancel-pad") : r === "angl" ? t.classes.push("anglpad") : t.classes.push("boxpad");
    var m = 0, g = 0, b = 0;
    /box/.test(r) ? (b = Math.max(
      e.fontMetrics().fboxrule,
      // default
      e.minRuleThickness
      // User override.
    ), m = e.fontMetrics().fboxsep + (r === "colorbox" ? 0 : b), g = m) : r === "angl" ? (b = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness), m = 4 * b, g = Math.max(0, 0.25 - t.depth)) : (m = l ? 0.2 : 0, g = m), s = go.encloseSpan(t, r, m, g, e), /fbox|boxed|fcolorbox/.test(r) ? (s.style.borderStyle = "solid", s.style.borderWidth = fe(b)) : r === "angl" && b !== 0.049 && (s.style.borderTopWidth = fe(b), s.style.borderRightWidth = fe(b)), o = t.depth + g, n.backgroundColor && (s.style.backgroundColor = n.backgroundColor, n.borderColor && (s.style.borderColor = n.borderColor));
  }
  var w;
  if (n.backgroundColor)
    w = H.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: s,
          shift: o
        },
        {
          type: "elem",
          elem: t,
          shift: 0
        }
      ]
    }, e);
  else {
    var k = /cancel|phase/.test(r) ? ["svg-align"] : [];
    w = H.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: t,
          shift: 0
        },
        {
          type: "elem",
          elem: s,
          shift: o,
          wrapperClasses: k
        }
      ]
    }, e);
  }
  return /cancel/.test(r) && (w.height = t.height, w.depth = t.depth), /cancel/.test(r) && !l ? H.makeSpan(["mord", "cancel-lap"], [w], e) : H.makeSpan(["mord"], [w], e);
}, g7 = (n, e) => {
  var t = 0, r = new ne.MathNode(n.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [Pt(n.body, e)]);
  switch (n.label) {
    case "\\cancel":
      r.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      r.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      r.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      r.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      r.setAttribute("notation", "box");
      break;
    case "\\angl":
      r.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (t = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm, r.setAttribute("width", "+" + 2 * t + "pt"), r.setAttribute("height", "+" + 2 * t + "pt"), r.setAttribute("lspace", t + "pt"), r.setAttribute("voffset", t + "pt"), n.label === "\\fcolorbox") {
        var i = Math.max(
          e.fontMetrics().fboxrule,
          // default
          e.minRuleThickness
          // user override
        );
        r.setAttribute("style", "border: " + i + "em solid " + String(n.borderColor));
      }
      break;
    case "\\xcancel":
      r.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return n.backgroundColor && r.setAttribute("mathbackground", n.backgroundColor), r;
};
ve({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n, s = Qe(e[0], "color-token").color, o = e[1];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: s,
      body: o
    };
  },
  htmlBuilder: m7,
  mathmlBuilder: g7
});
ve({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n, s = Qe(e[0], "color-token").color, o = Qe(e[1], "color-token").color, l = e[2];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: o,
      borderColor: s,
      body: l
    };
  },
  htmlBuilder: m7,
  mathmlBuilder: g7
});
ve({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
ve({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "enclose",
      mode: t.mode,
      label: r,
      body: i
    };
  },
  htmlBuilder: m7,
  mathmlBuilder: g7
});
ve({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\angl",
      body: e[0]
    };
  }
});
var cN = {};
function Is(n) {
  for (var {
    type: e,
    names: t,
    props: r,
    handler: i,
    htmlBuilder: s,
    mathmlBuilder: o
  } = n, l = {
    type: e,
    numArgs: r.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: i
  }, a = 0; a < t.length; ++a)
    cN[t[a]] = l;
  s && (Um[e] = s), o && (Km[e] = o);
}
var uN = {};
function S(n, e) {
  uN[n] = e;
}
function y9(n) {
  var e = [];
  n.consumeSpaces();
  var t = n.fetch().text;
  for (t === "\\relax" && (n.consume(), n.consumeSpaces(), t = n.fetch().text); t === "\\hline" || t === "\\hdashline"; )
    n.consume(), e.push(t === "\\hdashline"), n.consumeSpaces(), t = n.fetch().text;
  return e;
}
var dg = (n) => {
  var e = n.parser.settings;
  if (!e.displayMode)
    throw new se("{" + n.envName + "} can be used only in display mode.");
};
function y7(n) {
  if (n.indexOf("ed") === -1)
    return n.indexOf("*") === -1;
}
function El(n, e, t) {
  var {
    hskipBeforeAndAfter: r,
    addJot: i,
    cols: s,
    arraystretch: o,
    colSeparationType: l,
    autoTag: a,
    singleRow: c,
    emptySingleRow: u,
    maxNumCols: h,
    leqno: f
  } = e;
  if (n.gullet.beginGroup(), c || n.gullet.macros.set("\\cr", "\\\\\\relax"), !o) {
    var d = n.gullet.expandMacroAsText("\\arraystretch");
    if (d == null)
      o = 1;
    else if (o = parseFloat(d), !o || o < 0)
      throw new se("Invalid \\arraystretch: " + d);
  }
  n.gullet.beginGroup();
  var p = [], m = [p], g = [], b = [], w = a != null ? [] : void 0;
  function k() {
    a && n.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function C() {
    w && (n.gullet.macros.get("\\df@tag") ? (w.push(n.subparse([new bi("\\df@tag")])), n.gullet.macros.set("\\df@tag", void 0, !0)) : w.push(!!a && n.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (k(), b.push(y9(n)); ; ) {
    var M = n.parseExpression(!1, c ? "\\end" : "\\\\");
    n.gullet.endGroup(), n.gullet.beginGroup(), M = {
      type: "ordgroup",
      mode: n.mode,
      body: M
    }, t && (M = {
      type: "styling",
      mode: n.mode,
      style: t,
      body: [M]
    }), p.push(M);
    var T = n.fetch().text;
    if (T === "&") {
      if (h && p.length === h) {
        if (c || l)
          throw new se("Too many tab characters: &", n.nextToken);
        n.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      n.consume();
    } else if (T === "\\end") {
      C(), p.length === 1 && M.type === "styling" && M.body[0].body.length === 0 && (m.length > 1 || !u) && m.pop(), b.length < m.length + 1 && b.push([]);
      break;
    } else if (T === "\\\\") {
      n.consume();
      var N = void 0;
      n.gullet.future().text !== " " && (N = n.parseSizeGroup(!0)), g.push(N ? N.value : null), C(), b.push(y9(n)), p = [], m.push(p), k();
    } else
      throw new se("Expected & or \\\\ or \\cr or \\end", n.nextToken);
  }
  return n.gullet.endGroup(), n.gullet.endGroup(), {
    type: "array",
    mode: n.mode,
    addJot: i,
    arraystretch: o,
    body: m,
    cols: s,
    rowGaps: g,
    hskipBeforeAndAfter: r,
    hLinesBeforeRow: b,
    colSeparationType: l,
    tags: w,
    leqno: f
  };
}
function b7(n) {
  return n.slice(0, 1) === "d" ? "display" : "text";
}
var Ds = function(e, t) {
  var r, i, s = e.body.length, o = e.hLinesBeforeRow, l = 0, a = new Array(s), c = [], u = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    t.fontMetrics().arrayRuleWidth,
    t.minRuleThickness
    // User override.
  ), h = 1 / t.fontMetrics().ptPerEm, f = 5 * h;
  if (e.colSeparationType && e.colSeparationType === "small") {
    var d = t.havingStyle(We.SCRIPT).sizeMultiplier;
    f = 0.2778 * (d / t.sizeMultiplier);
  }
  var p = e.colSeparationType === "CD" ? Qt({
    number: 3,
    unit: "ex"
  }, t) : 12 * h, m = 3 * h, g = e.arraystretch * p, b = 0.7 * g, w = 0.3 * g, k = 0;
  function C(ae) {
    for (var re = 0; re < ae.length; ++re)
      re > 0 && (k += 0.25), c.push({
        pos: k,
        isDashed: ae[re]
      });
  }
  for (C(o[0]), r = 0; r < e.body.length; ++r) {
    var M = e.body[r], T = b, N = w;
    l < M.length && (l = M.length);
    var B = new Array(M.length);
    for (i = 0; i < M.length; ++i) {
      var $ = ft(M[i], t);
      N < $.depth && (N = $.depth), T < $.height && (T = $.height), B[i] = $;
    }
    var R = e.rowGaps[r], V = 0;
    R && (V = Qt(R, t), V > 0 && (V += w, N < V && (N = V), V = 0)), e.addJot && (N += m), B.height = T, B.depth = N, k += T, B.pos = k, k += N + V, a[r] = B, C(o[r + 1]);
  }
  var z = k / 2 + t.fontMetrics().axisHeight, ue = e.cols || [], ie = [], he, Ce, ye = [];
  if (e.tags && e.tags.some((ae) => ae))
    for (r = 0; r < s; ++r) {
      var be = a[r], ze = be.pos - z, I = e.tags[r], Ie = void 0;
      I === !0 ? Ie = H.makeSpan(["eqn-num"], [], t) : I === !1 ? Ie = H.makeSpan([], [], t) : Ie = H.makeSpan([], xn(I, t, !0), t), Ie.depth = be.depth, Ie.height = be.height, ye.push({
        type: "elem",
        elem: Ie,
        shift: ze
      });
    }
  for (
    i = 0, Ce = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    i < l || Ce < ue.length;
    ++i, ++Ce
  ) {
    for (var Ve = ue[Ce] || {}, O = !0; Ve.type === "separator"; ) {
      if (O || (he = H.makeSpan(["arraycolsep"], []), he.style.width = fe(t.fontMetrics().doubleRuleSep), ie.push(he)), Ve.separator === "|" || Ve.separator === ":") {
        var pt = Ve.separator === "|" ? "solid" : "dashed", Ue = H.makeSpan(["vertical-separator"], [], t);
        Ue.style.height = fe(k), Ue.style.borderRightWidth = fe(u), Ue.style.borderRightStyle = pt, Ue.style.margin = "0 " + fe(-u / 2);
        var et = k - z;
        et && (Ue.style.verticalAlign = fe(-et)), ie.push(Ue);
      } else
        throw new se("Invalid separator type: " + Ve.separator);
      Ce++, Ve = ue[Ce] || {}, O = !1;
    }
    if (!(i >= l)) {
      var Tt = void 0;
      (i > 0 || e.hskipBeforeAndAfter) && (Tt = Be.deflt(Ve.pregap, f), Tt !== 0 && (he = H.makeSpan(["arraycolsep"], []), he.style.width = fe(Tt), ie.push(he)));
      var Ht = [];
      for (r = 0; r < s; ++r) {
        var sn = a[r], Gt = sn[i];
        if (Gt) {
          var Lr = sn.pos - z;
          Gt.depth = sn.depth, Gt.height = sn.height, Ht.push({
            type: "elem",
            elem: Gt,
            shift: Lr
          });
        }
      }
      Ht = H.makeVList({
        positionType: "individualShift",
        children: Ht
      }, t), Ht = H.makeSpan(["col-align-" + (Ve.align || "c")], [Ht]), ie.push(Ht), (i < l - 1 || e.hskipBeforeAndAfter) && (Tt = Be.deflt(Ve.postgap, f), Tt !== 0 && (he = H.makeSpan(["arraycolsep"], []), he.style.width = fe(Tt), ie.push(he)));
    }
  }
  if (a = H.makeSpan(["mtable"], ie), c.length > 0) {
    for (var E = H.makeLineSpan("hline", t, u), P = H.makeLineSpan("hdashline", t, u), W = [{
      type: "elem",
      elem: a,
      shift: 0
    }]; c.length > 0; ) {
      var Q = c.pop(), J = Q.pos - z;
      Q.isDashed ? W.push({
        type: "elem",
        elem: P,
        shift: J
      }) : W.push({
        type: "elem",
        elem: E,
        shift: J
      });
    }
    a = H.makeVList({
      positionType: "individualShift",
      children: W
    }, t);
  }
  if (ye.length === 0)
    return H.makeSpan(["mord"], [a], t);
  var Y = H.makeVList({
    positionType: "individualShift",
    children: ye
  }, t);
  return Y = H.makeSpan(["tag"], [Y], t), H.makeFragment([a, Y]);
}, dle = {
  c: "center ",
  l: "left ",
  r: "right "
}, Ns = function(e, t) {
  for (var r = [], i = new ne.MathNode("mtd", [], ["mtr-glue"]), s = new ne.MathNode("mtd", [], ["mml-eqn-num"]), o = 0; o < e.body.length; o++) {
    for (var l = e.body[o], a = [], c = 0; c < l.length; c++)
      a.push(new ne.MathNode("mtd", [Pt(l[c], t)]));
    e.tags && e.tags[o] && (a.unshift(i), a.push(i), e.leqno ? a.unshift(s) : a.push(s)), r.push(new ne.MathNode("mtr", a));
  }
  var u = new ne.MathNode("mtable", r), h = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
  u.setAttribute("rowspacing", fe(h));
  var f = "", d = "";
  if (e.cols && e.cols.length > 0) {
    var p = e.cols, m = "", g = !1, b = 0, w = p.length;
    p[0].type === "separator" && (f += "top ", b = 1), p[p.length - 1].type === "separator" && (f += "bottom ", w -= 1);
    for (var k = b; k < w; k++)
      p[k].type === "align" ? (d += dle[p[k].align], g && (m += "none "), g = !0) : p[k].type === "separator" && g && (m += p[k].separator === "|" ? "solid " : "dashed ", g = !1);
    u.setAttribute("columnalign", d.trim()), /[sd]/.test(m) && u.setAttribute("columnlines", m.trim());
  }
  if (e.colSeparationType === "align") {
    for (var C = e.cols || [], M = "", T = 1; T < C.length; T++)
      M += T % 2 ? "0em " : "1em ";
    u.setAttribute("columnspacing", M.trim());
  } else e.colSeparationType === "alignat" || e.colSeparationType === "gather" ? u.setAttribute("columnspacing", "0em") : e.colSeparationType === "small" ? u.setAttribute("columnspacing", "0.2778em") : e.colSeparationType === "CD" ? u.setAttribute("columnspacing", "0.5em") : u.setAttribute("columnspacing", "1em");
  var N = "", B = e.hLinesBeforeRow;
  f += B[0].length > 0 ? "left " : "", f += B[B.length - 1].length > 0 ? "right " : "";
  for (var $ = 1; $ < B.length - 1; $++)
    N += B[$].length === 0 ? "none " : B[$][0] ? "dashed " : "solid ";
  return /[sd]/.test(N) && u.setAttribute("rowlines", N.trim()), f !== "" && (u = new ne.MathNode("menclose", [u]), u.setAttribute("notation", f.trim())), e.arraystretch && e.arraystretch < 1 && (u = new ne.MathNode("mstyle", [u]), u.setAttribute("scriptlevel", "1")), u;
}, hN = function(e, t) {
  e.envName.indexOf("ed") === -1 && dg(e);
  var r = [], i = e.envName.indexOf("at") > -1 ? "alignat" : "align", s = e.envName === "split", o = El(e.parser, {
    cols: r,
    addJot: !0,
    autoTag: s ? void 0 : y7(e.envName),
    emptySingleRow: !0,
    colSeparationType: i,
    maxNumCols: s ? 2 : void 0,
    leqno: e.parser.settings.leqno
  }, "display"), l, a = 0, c = {
    type: "ordgroup",
    mode: e.mode,
    body: []
  };
  if (t[0] && t[0].type === "ordgroup") {
    for (var u = "", h = 0; h < t[0].body.length; h++) {
      var f = Qe(t[0].body[h], "textord");
      u += f.text;
    }
    l = Number(u), a = l * 2;
  }
  var d = !a;
  o.body.forEach(function(b) {
    for (var w = 1; w < b.length; w += 2) {
      var k = Qe(b[w], "styling"), C = Qe(k.body[0], "ordgroup");
      C.body.unshift(c);
    }
    if (d)
      a < b.length && (a = b.length);
    else {
      var M = b.length / 2;
      if (l < M)
        throw new se("Too many math in a row: " + ("expected " + l + ", but got " + M), b[0]);
    }
  });
  for (var p = 0; p < a; ++p) {
    var m = "r", g = 0;
    p % 2 === 1 ? m = "l" : p > 0 && d && (g = 1), r[p] = {
      type: "align",
      align: m,
      pregap: g,
      postgap: 0
    };
  }
  return o.colSeparationType = d ? "align" : "alignat", o;
};
Is({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var t = ug(e[0]), r = t ? [e[0]] : Qe(e[0], "ordgroup").body, i = r.map(function(o) {
      var l = f7(o), a = l.text;
      if ("lcr".indexOf(a) !== -1)
        return {
          type: "align",
          align: a
        };
      if (a === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (a === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new se("Unknown column alignment: " + a, o);
    }), s = {
      cols: i,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: i.length
    };
    return El(n.parser, s, b7(n.envName));
  },
  htmlBuilder: Ds,
  mathmlBuilder: Ns
});
Is({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[n.envName.replace("*", "")], t = "c", r = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: t
      }]
    };
    if (n.envName.charAt(n.envName.length - 1) === "*") {
      var i = n.parser;
      if (i.consumeSpaces(), i.fetch().text === "[") {
        if (i.consume(), i.consumeSpaces(), t = i.fetch().text, "lcr".indexOf(t) === -1)
          throw new se("Expected l or c or r", i.nextToken);
        i.consume(), i.consumeSpaces(), i.expect("]"), i.consume(), r.cols = [{
          type: "align",
          align: t
        }];
      }
    }
    var s = El(n.parser, r, b7(n.envName)), o = Math.max(0, ...s.body.map((l) => l.length));
    return s.cols = new Array(o).fill({
      type: "align",
      align: t
    }), e ? {
      type: "leftright",
      mode: n.mode,
      body: [s],
      left: e[0],
      right: e[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : s;
  },
  htmlBuilder: Ds,
  mathmlBuilder: Ns
});
Is({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      arraystretch: 0.5
    }, t = El(n.parser, e, "script");
    return t.colSeparationType = "small", t;
  },
  htmlBuilder: Ds,
  mathmlBuilder: Ns
});
Is({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var t = ug(e[0]), r = t ? [e[0]] : Qe(e[0], "ordgroup").body, i = r.map(function(o) {
      var l = f7(o), a = l.text;
      if ("lc".indexOf(a) !== -1)
        return {
          type: "align",
          align: a
        };
      throw new se("Unknown column alignment: " + a, o);
    });
    if (i.length > 1)
      throw new se("{subarray} can contain only one column");
    var s = {
      cols: i,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (s = El(n.parser, s, "script"), s.body.length > 0 && s.body[0].length > 1)
      throw new se("{subarray} can contain only one column");
    return s;
  },
  htmlBuilder: Ds,
  mathmlBuilder: Ns
});
Is({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, t = El(n.parser, e, b7(n.envName));
    return {
      type: "leftright",
      mode: n.mode,
      body: [t],
      left: n.envName.indexOf("r") > -1 ? "." : "\\{",
      right: n.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: Ds,
  mathmlBuilder: Ns
});
Is({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: hN,
  htmlBuilder: Ds,
  mathmlBuilder: Ns
});
Is({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    Be.contains(["gather", "gather*"], n.envName) && dg(n);
    var e = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: y7(n.envName),
      emptySingleRow: !0,
      leqno: n.parser.settings.leqno
    };
    return El(n.parser, e, "display");
  },
  htmlBuilder: Ds,
  mathmlBuilder: Ns
});
Is({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: hN,
  htmlBuilder: Ds,
  mathmlBuilder: Ns
});
Is({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    dg(n);
    var e = {
      autoTag: y7(n.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: n.parser.settings.leqno
    };
    return El(n.parser, e, "display");
  },
  htmlBuilder: Ds,
  mathmlBuilder: Ns
});
Is({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(n) {
    return dg(n), Qoe(n.parser);
  },
  htmlBuilder: Ds,
  mathmlBuilder: Ns
});
S("\\nonumber", "\\gdef\\@eqnsw{0}");
S("\\notag", "\\nonumber");
ve({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(n, e) {
    throw new se(n.funcName + " valid only within array environment");
  }
});
var b9 = cN;
ve({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    if (i.type !== "ordgroup")
      throw new se("Invalid environment name", i);
    for (var s = "", o = 0; o < i.body.length; ++o)
      s += Qe(i.body[o], "textord").text;
    if (r === "\\begin") {
      if (!b9.hasOwnProperty(s))
        throw new se("No such environment: " + s, i);
      var l = b9[s], {
        args: a,
        optArgs: c
      } = t.parseArguments("\\begin{" + s + "}", l), u = {
        mode: t.mode,
        envName: s,
        parser: t
      }, h = l.handler(u, a, c);
      t.expect("\\end", !1);
      var f = t.nextToken, d = Qe(t.parseFunction(), "environment");
      if (d.name !== s)
        throw new se("Mismatch: \\begin{" + s + "} matched by \\end{" + d.name + "}", f);
      return h;
    }
    return {
      type: "environment",
      mode: t.mode,
      name: s,
      nameGroup: i
    };
  }
});
var fN = (n, e) => {
  var t = n.font, r = e.withFont(t);
  return ft(n.body, r);
}, dN = (n, e) => {
  var t = n.font, r = e.withFont(t);
  return Pt(n.body, r);
}, v9 = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
ve({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = Gm(e[0]), s = r;
    return s in v9 && (s = v9[s]), {
      type: "font",
      mode: t.mode,
      font: s.slice(1),
      body: i
    };
  },
  htmlBuilder: fN,
  mathmlBuilder: dN
});
ve({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0], i = Be.isCharacterBox(r);
    return {
      type: "mclass",
      mode: t.mode,
      mclass: hg(r),
      body: [{
        type: "font",
        mode: t.mode,
        font: "boldsymbol",
        body: r
      }],
      isCharacterBox: i
    };
  }
});
ve({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r,
      breakOnTokenText: i
    } = n, {
      mode: s
    } = t, o = t.parseExpression(!0, i), l = "math" + r.slice(1);
    return {
      type: "font",
      mode: s,
      font: l,
      body: {
        type: "ordgroup",
        mode: t.mode,
        body: o
      }
    };
  },
  htmlBuilder: fN,
  mathmlBuilder: dN
});
var pN = (n, e) => {
  var t = e;
  return n === "display" ? t = t.id >= We.SCRIPT.id ? t.text() : We.DISPLAY : n === "text" && t.size === We.DISPLAY.size ? t = We.TEXT : n === "script" ? t = We.SCRIPT : n === "scriptscript" && (t = We.SCRIPTSCRIPT), t;
}, v7 = (n, e) => {
  var t = pN(n.size, e.style), r = t.fracNum(), i = t.fracDen(), s;
  s = e.havingStyle(r);
  var o = ft(n.numer, s, e);
  if (n.continued) {
    var l = 8.5 / e.fontMetrics().ptPerEm, a = 3.5 / e.fontMetrics().ptPerEm;
    o.height = o.height < l ? l : o.height, o.depth = o.depth < a ? a : o.depth;
  }
  s = e.havingStyle(i);
  var c = ft(n.denom, s, e), u, h, f;
  n.hasBarLine ? (n.barSize ? (h = Qt(n.barSize, e), u = H.makeLineSpan("frac-line", e, h)) : u = H.makeLineSpan("frac-line", e), h = u.height, f = u.height) : (u = null, h = 0, f = e.fontMetrics().defaultRuleThickness);
  var d, p, m;
  t.size === We.DISPLAY.size || n.size === "display" ? (d = e.fontMetrics().num1, h > 0 ? p = 3 * f : p = 7 * f, m = e.fontMetrics().denom1) : (h > 0 ? (d = e.fontMetrics().num2, p = f) : (d = e.fontMetrics().num3, p = 3 * f), m = e.fontMetrics().denom2);
  var g;
  if (u) {
    var w = e.fontMetrics().axisHeight;
    d - o.depth - (w + 0.5 * h) < p && (d += p - (d - o.depth - (w + 0.5 * h))), w - 0.5 * h - (c.height - m) < p && (m += p - (w - 0.5 * h - (c.height - m)));
    var k = -(w - 0.5 * h);
    g = H.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: c,
        shift: m
      }, {
        type: "elem",
        elem: u,
        shift: k
      }, {
        type: "elem",
        elem: o,
        shift: -d
      }]
    }, e);
  } else {
    var b = d - o.depth - (c.height - m);
    b < p && (d += 0.5 * (p - b), m += 0.5 * (p - b)), g = H.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: c,
        shift: m
      }, {
        type: "elem",
        elem: o,
        shift: -d
      }]
    }, e);
  }
  s = e.havingStyle(t), g.height *= s.sizeMultiplier / e.sizeMultiplier, g.depth *= s.sizeMultiplier / e.sizeMultiplier;
  var C;
  t.size === We.DISPLAY.size ? C = e.fontMetrics().delim1 : t.size === We.SCRIPTSCRIPT.size ? C = e.havingStyle(We.SCRIPT).fontMetrics().delim2 : C = e.fontMetrics().delim2;
  var M, T;
  return n.leftDelim == null ? M = rd(e, ["mopen"]) : M = so.customSizedDelim(n.leftDelim, C, !0, e.havingStyle(t), n.mode, ["mopen"]), n.continued ? T = H.makeSpan([]) : n.rightDelim == null ? T = rd(e, ["mclose"]) : T = so.customSizedDelim(n.rightDelim, C, !0, e.havingStyle(t), n.mode, ["mclose"]), H.makeSpan(["mord"].concat(s.sizingClasses(e)), [M, H.makeSpan(["mfrac"], [g]), T], e);
}, w7 = (n, e) => {
  var t = new ne.MathNode("mfrac", [Pt(n.numer, e), Pt(n.denom, e)]);
  if (!n.hasBarLine)
    t.setAttribute("linethickness", "0px");
  else if (n.barSize) {
    var r = Qt(n.barSize, e);
    t.setAttribute("linethickness", fe(r));
  }
  var i = pN(n.size, e.style);
  if (i.size !== e.style.size) {
    t = new ne.MathNode("mstyle", [t]);
    var s = i.size === We.DISPLAY.size ? "true" : "false";
    t.setAttribute("displaystyle", s), t.setAttribute("scriptlevel", "0");
  }
  if (n.leftDelim != null || n.rightDelim != null) {
    var o = [];
    if (n.leftDelim != null) {
      var l = new ne.MathNode("mo", [new ne.TextNode(n.leftDelim.replace("\\", ""))]);
      l.setAttribute("fence", "true"), o.push(l);
    }
    if (o.push(t), n.rightDelim != null) {
      var a = new ne.MathNode("mo", [new ne.TextNode(n.rightDelim.replace("\\", ""))]);
      a.setAttribute("fence", "true"), o.push(a);
    }
    return u7(o);
  }
  return t;
};
ve({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = e[1], o, l = null, a = null, c = "auto";
    switch (r) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        o = !0;
        break;
      case "\\\\atopfrac":
        o = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        o = !1, l = "(", a = ")";
        break;
      case "\\\\bracefrac":
        o = !1, l = "\\{", a = "\\}";
        break;
      case "\\\\brackfrac":
        o = !1, l = "[", a = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (r) {
      case "\\dfrac":
      case "\\dbinom":
        c = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        c = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !1,
      numer: i,
      denom: s,
      hasBarLine: o,
      leftDelim: l,
      rightDelim: a,
      size: c,
      barSize: null
    };
  },
  htmlBuilder: v7,
  mathmlBuilder: w7
});
ve({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = e[1];
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !0,
      numer: i,
      denom: s,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
ve({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t,
      token: r
    } = n, i;
    switch (t) {
      case "\\over":
        i = "\\frac";
        break;
      case "\\choose":
        i = "\\binom";
        break;
      case "\\atop":
        i = "\\\\atopfrac";
        break;
      case "\\brace":
        i = "\\\\bracefrac";
        break;
      case "\\brack":
        i = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: e.mode,
      replaceWith: i,
      token: r
    };
  }
});
var w9 = ["display", "text", "script", "scriptscript"], x9 = function(e) {
  var t = null;
  return e.length > 0 && (t = e, t = t === "." ? null : t), t;
};
ve({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = e[4], i = e[5], s = Gm(e[0]), o = s.type === "atom" && s.family === "open" ? x9(s.text) : null, l = Gm(e[1]), a = l.type === "atom" && l.family === "close" ? x9(l.text) : null, c = Qe(e[2], "size"), u, h = null;
    c.isBlank ? u = !0 : (h = c.value, u = h.number > 0);
    var f = "auto", d = e[3];
    if (d.type === "ordgroup") {
      if (d.body.length > 0) {
        var p = Qe(d.body[0], "textord");
        f = w9[Number(p.text)];
      }
    } else
      d = Qe(d, "textord"), f = w9[Number(d.text)];
    return {
      type: "genfrac",
      mode: t.mode,
      numer: r,
      denom: i,
      continued: !1,
      hasBarLine: u,
      barSize: h,
      leftDelim: o,
      rightDelim: a,
      size: f
    };
  },
  htmlBuilder: v7,
  mathmlBuilder: w7
});
ve({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r,
      token: i
    } = n;
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: "\\\\abovefrac",
      size: Qe(e[0], "size").value,
      token: i
    };
  }
});
ve({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = qse(Qe(e[1], "infix").size), o = e[2], l = s.number > 0;
    return {
      type: "genfrac",
      mode: t.mode,
      numer: i,
      denom: o,
      continued: !1,
      hasBarLine: l,
      barSize: s,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: v7,
  mathmlBuilder: w7
});
var mN = (n, e) => {
  var t = e.style, r, i;
  n.type === "supsub" ? (r = n.sup ? ft(n.sup, e.havingStyle(t.sup()), e) : ft(n.sub, e.havingStyle(t.sub()), e), i = Qe(n.base, "horizBrace")) : i = Qe(n, "horizBrace");
  var s = ft(i.base, e.havingBaseStyle(We.DISPLAY)), o = go.svgSpan(i, e), l;
  if (i.isOver ? (l = H.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: s
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: o
    }]
  }, e), l.children[0].children[0].children[1].classes.push("svg-align")) : (l = H.makeVList({
    positionType: "bottom",
    positionData: s.depth + 0.1 + o.height,
    children: [{
      type: "elem",
      elem: o
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: s
    }]
  }, e), l.children[0].children[0].children[0].classes.push("svg-align")), r) {
    var a = H.makeSpan(["mord", i.isOver ? "mover" : "munder"], [l], e);
    i.isOver ? l = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: r
      }]
    }, e) : l = H.makeVList({
      positionType: "bottom",
      positionData: a.depth + 0.2 + r.height + r.depth,
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: a
      }]
    }, e);
  }
  return H.makeSpan(["mord", i.isOver ? "mover" : "munder"], [l], e);
}, ple = (n, e) => {
  var t = go.mathMLnode(n.label);
  return new ne.MathNode(n.isOver ? "mover" : "munder", [Pt(n.base, e), t]);
};
ve({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n;
    return {
      type: "horizBrace",
      mode: t.mode,
      label: r,
      isOver: /^\\over/.test(r),
      base: e[0]
    };
  },
  htmlBuilder: mN,
  mathmlBuilder: ple
});
ve({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[1], i = Qe(e[0], "url").url;
    return t.settings.isTrusted({
      command: "\\href",
      url: i
    }) ? {
      type: "href",
      mode: t.mode,
      href: i,
      body: cn(r)
    } : t.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.body, e, !1);
    return H.makeAnchor(n.href, [], t, e);
  },
  mathmlBuilder: (n, e) => {
    var t = vl(n.body, e);
    return t instanceof Yr || (t = new Yr("mrow", [t])), t.setAttribute("href", n.href), t;
  }
});
ve({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = Qe(e[0], "url").url;
    if (!t.settings.isTrusted({
      command: "\\url",
      url: r
    }))
      return t.formatUnsupportedCmd("\\url");
    for (var i = [], s = 0; s < r.length; s++) {
      var o = r[s];
      o === "~" && (o = "\\textasciitilde"), i.push({
        type: "textord",
        mode: "text",
        text: o
      });
    }
    var l = {
      type: "text",
      mode: t.mode,
      font: "\\texttt",
      body: i
    };
    return {
      type: "href",
      mode: t.mode,
      href: r,
      body: cn(l)
    };
  }
});
ve({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "hbox",
      mode: t.mode,
      body: cn(e[0])
    };
  },
  htmlBuilder(n, e) {
    var t = xn(n.body, e, !1);
    return H.makeFragment(t);
  },
  mathmlBuilder(n, e) {
    return new ne.MathNode("mrow", _r(n.body, e));
  }
});
ve({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r,
      token: i
    } = n, s = Qe(e[0], "raw").string, o = e[1];
    t.settings.strict && t.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var l, a = {};
    switch (r) {
      case "\\htmlClass":
        a.class = s, l = {
          command: "\\htmlClass",
          class: s
        };
        break;
      case "\\htmlId":
        a.id = s, l = {
          command: "\\htmlId",
          id: s
        };
        break;
      case "\\htmlStyle":
        a.style = s, l = {
          command: "\\htmlStyle",
          style: s
        };
        break;
      case "\\htmlData": {
        for (var c = s.split(","), u = 0; u < c.length; u++) {
          var h = c[u].split("=");
          if (h.length !== 2)
            throw new se("Error parsing key-value for \\htmlData");
          a["data-" + h[0].trim()] = h[1].trim();
        }
        l = {
          command: "\\htmlData",
          attributes: a
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return t.settings.isTrusted(l) ? {
      type: "html",
      mode: t.mode,
      attributes: a,
      body: cn(o)
    } : t.formatUnsupportedCmd(r);
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.body, e, !1), r = ["enclosing"];
    n.attributes.class && r.push(...n.attributes.class.trim().split(/\s+/));
    var i = H.makeSpan(r, t, e);
    for (var s in n.attributes)
      s !== "class" && n.attributes.hasOwnProperty(s) && i.setAttribute(s, n.attributes[s]);
    return i;
  },
  mathmlBuilder: (n, e) => vl(n.body, e)
});
ve({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n;
    return {
      type: "htmlmathml",
      mode: t.mode,
      html: cn(e[0]),
      mathml: cn(e[1])
    };
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.html, e, !1);
    return H.makeFragment(t);
  },
  mathmlBuilder: (n, e) => vl(n.mathml, e)
});
var p4 = function(e) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e))
    return {
      number: +e,
      unit: "bp"
    };
  var t = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
  if (!t)
    throw new se("Invalid size: '" + e + "' in \\includegraphics");
  var r = {
    number: +(t[1] + t[2]),
    // sign + magnitude, cast to number
    unit: t[3]
  };
  if (!PD(r))
    throw new se("Invalid unit: '" + r.unit + "' in \\includegraphics.");
  return r;
};
ve({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (n, e, t) => {
    var {
      parser: r
    } = n, i = {
      number: 0,
      unit: "em"
    }, s = {
      number: 0.9,
      unit: "em"
    }, o = {
      number: 0,
      unit: "em"
    }, l = "";
    if (t[0])
      for (var a = Qe(t[0], "raw").string, c = a.split(","), u = 0; u < c.length; u++) {
        var h = c[u].split("=");
        if (h.length === 2) {
          var f = h[1].trim();
          switch (h[0].trim()) {
            case "alt":
              l = f;
              break;
            case "width":
              i = p4(f);
              break;
            case "height":
              s = p4(f);
              break;
            case "totalheight":
              o = p4(f);
              break;
            default:
              throw new se("Invalid key: '" + h[0] + "' in \\includegraphics.");
          }
        }
      }
    var d = Qe(e[0], "url").url;
    return l === "" && (l = d, l = l.replace(/^.*[\\/]/, ""), l = l.substring(0, l.lastIndexOf("."))), r.settings.isTrusted({
      command: "\\includegraphics",
      url: d
    }) ? {
      type: "includegraphics",
      mode: r.mode,
      alt: l,
      width: i,
      height: s,
      totalheight: o,
      src: d
    } : r.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (n, e) => {
    var t = Qt(n.height, e), r = 0;
    n.totalheight.number > 0 && (r = Qt(n.totalheight, e) - t);
    var i = 0;
    n.width.number > 0 && (i = Qt(n.width, e));
    var s = {
      height: fe(t + r)
    };
    i > 0 && (s.width = fe(i)), r > 0 && (s.verticalAlign = fe(-r));
    var o = new poe(n.src, n.alt, s);
    return o.height = t, o.depth = r, o;
  },
  mathmlBuilder: (n, e) => {
    var t = new ne.MathNode("mglyph", []);
    t.setAttribute("alt", n.alt);
    var r = Qt(n.height, e), i = 0;
    if (n.totalheight.number > 0 && (i = Qt(n.totalheight, e) - r, t.setAttribute("valign", fe(-i))), t.setAttribute("height", fe(r + i)), n.width.number > 0) {
      var s = Qt(n.width, e);
      t.setAttribute("width", fe(s));
    }
    return t.setAttribute("src", n.src), t;
  }
});
ve({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = Qe(e[0], "size");
    if (t.settings.strict) {
      var s = r[1] === "m", o = i.value.unit === "mu";
      s ? (o || t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " supports only mu units, " + ("not " + i.value.unit + " units")), t.mode !== "math" && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " works only in math mode")) : o && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: t.mode,
      dimension: i.value
    };
  },
  htmlBuilder(n, e) {
    return H.makeGlue(n.dimension, e);
  },
  mathmlBuilder(n, e) {
    var t = Qt(n.dimension, e);
    return new ne.SpaceNode(t);
  }
});
ve({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "lap",
      mode: t.mode,
      alignment: r.slice(5),
      body: i
    };
  },
  htmlBuilder: (n, e) => {
    var t;
    n.alignment === "clap" ? (t = H.makeSpan([], [ft(n.body, e)]), t = H.makeSpan(["inner"], [t], e)) : t = H.makeSpan(["inner"], [ft(n.body, e)]);
    var r = H.makeSpan(["fix"], []), i = H.makeSpan([n.alignment], [t, r], e), s = H.makeSpan(["strut"]);
    return s.style.height = fe(i.height + i.depth), i.depth && (s.style.verticalAlign = fe(-i.depth)), i.children.unshift(s), i = H.makeSpan(["thinbox"], [i], e), H.makeSpan(["mord", "vbox"], [i], e);
  },
  mathmlBuilder: (n, e) => {
    var t = new ne.MathNode("mpadded", [Pt(n.body, e)]);
    if (n.alignment !== "rlap") {
      var r = n.alignment === "llap" ? "-1" : "-0.5";
      t.setAttribute("lspace", r + "width");
    }
    return t.setAttribute("width", "0px"), t;
  }
});
ve({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(n, e) {
    var {
      funcName: t,
      parser: r
    } = n, i = r.mode;
    r.switchMode("math");
    var s = t === "\\(" ? "\\)" : "$", o = r.parseExpression(!1, s);
    return r.expect(s), r.switchMode(i), {
      type: "styling",
      mode: r.mode,
      style: "text",
      body: o
    };
  }
});
ve({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(n, e) {
    throw new se("Mismatched " + n.funcName);
  }
});
var k9 = (n, e) => {
  switch (e.style.size) {
    case We.DISPLAY.size:
      return n.display;
    case We.TEXT.size:
      return n.text;
    case We.SCRIPT.size:
      return n.script;
    case We.SCRIPTSCRIPT.size:
      return n.scriptscript;
    default:
      return n.text;
  }
};
ve({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n;
    return {
      type: "mathchoice",
      mode: t.mode,
      display: cn(e[0]),
      text: cn(e[1]),
      script: cn(e[2]),
      scriptscript: cn(e[3])
    };
  },
  htmlBuilder: (n, e) => {
    var t = k9(n, e), r = xn(t, e, !1);
    return H.makeFragment(r);
  },
  mathmlBuilder: (n, e) => {
    var t = k9(n, e);
    return vl(t, e);
  }
});
var gN = (n, e, t, r, i, s, o) => {
  n = H.makeSpan([], [n]);
  var l = t && Be.isCharacterBox(t), a, c;
  if (e) {
    var u = ft(e, r.havingStyle(i.sup()), r);
    c = {
      elem: u,
      kern: Math.max(r.fontMetrics().bigOpSpacing1, r.fontMetrics().bigOpSpacing3 - u.depth)
    };
  }
  if (t) {
    var h = ft(t, r.havingStyle(i.sub()), r);
    a = {
      elem: h,
      kern: Math.max(r.fontMetrics().bigOpSpacing2, r.fontMetrics().bigOpSpacing4 - h.height)
    };
  }
  var f;
  if (c && a) {
    var d = r.fontMetrics().bigOpSpacing5 + a.elem.height + a.elem.depth + a.kern + n.depth + o;
    f = H.makeVList({
      positionType: "bottom",
      positionData: d,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: a.elem,
        marginLeft: fe(-s)
      }, {
        type: "kern",
        size: a.kern
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: fe(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else if (a) {
    var p = n.height - o;
    f = H.makeVList({
      positionType: "top",
      positionData: p,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: a.elem,
        marginLeft: fe(-s)
      }, {
        type: "kern",
        size: a.kern
      }, {
        type: "elem",
        elem: n
      }]
    }, r);
  } else if (c) {
    var m = n.depth + o;
    f = H.makeVList({
      positionType: "bottom",
      positionData: m,
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: fe(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else
    return n;
  var g = [f];
  if (a && s !== 0 && !l) {
    var b = H.makeSpan(["mspace"], [], r);
    b.style.marginRight = fe(s), g.unshift(b);
  }
  return H.makeSpan(["mop", "op-limits"], g, r);
}, yN = ["\\smallint"], gu = (n, e) => {
  var t, r, i = !1, s;
  n.type === "supsub" ? (t = n.sup, r = n.sub, s = Qe(n.base, "op"), i = !0) : s = Qe(n, "op");
  var o = e.style, l = !1;
  o.size === We.DISPLAY.size && s.symbol && !Be.contains(yN, s.name) && (l = !0);
  var a;
  if (s.symbol) {
    var c = l ? "Size2-Regular" : "Size1-Regular", u = "";
    if ((s.name === "\\oiint" || s.name === "\\oiiint") && (u = s.name.slice(1), s.name = u === "oiint" ? "\\iint" : "\\iiint"), a = H.makeSymbol(s.name, c, "math", e, ["mop", "op-symbol", l ? "large-op" : "small-op"]), u.length > 0) {
      var h = a.italic, f = H.staticSvg(u + "Size" + (l ? "2" : "1"), e);
      a = H.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: a,
          shift: 0
        }, {
          type: "elem",
          elem: f,
          shift: l ? 0.08 : 0
        }]
      }, e), s.name = "\\" + u, a.classes.unshift("mop"), a.italic = h;
    }
  } else if (s.body) {
    var d = xn(s.body, e, !0);
    d.length === 1 && d[0] instanceof ki ? (a = d[0], a.classes[0] = "mop") : a = H.makeSpan(["mop"], d, e);
  } else {
    for (var p = [], m = 1; m < s.name.length; m++)
      p.push(H.mathsym(s.name[m], s.mode, e));
    a = H.makeSpan(["mop"], p, e);
  }
  var g = 0, b = 0;
  return (a instanceof ki || s.name === "\\oiint" || s.name === "\\oiiint") && !s.suppressBaseShift && (g = (a.height - a.depth) / 2 - e.fontMetrics().axisHeight, b = a.italic), i ? gN(a, t, r, e, o, b, g) : (g && (a.style.position = "relative", a.style.top = fe(g)), a);
}, Bd = (n, e) => {
  var t;
  if (n.symbol)
    t = new Yr("mo", [Si(n.name, n.mode)]), Be.contains(yN, n.name) && t.setAttribute("largeop", "false");
  else if (n.body)
    t = new Yr("mo", _r(n.body, e));
  else {
    t = new Yr("mi", [new ms(n.name.slice(1))]);
    var r = new Yr("mo", [Si("⁡", "text")]);
    n.parentIsSupSub ? t = new Yr("mrow", [t, r]) : t = jD([t, r]);
  }
  return t;
}, mle = {
  "∏": "\\prod",
  "∐": "\\coprod",
  "∑": "\\sum",
  "⋀": "\\bigwedge",
  "⋁": "\\bigvee",
  "⋂": "\\bigcap",
  "⋃": "\\bigcup",
  "⨀": "\\bigodot",
  "⨁": "\\bigoplus",
  "⨂": "\\bigotimes",
  "⨄": "\\biguplus",
  "⨆": "\\bigsqcup"
};
ve({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
  props: {
    numArgs: 0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = r;
    return i.length === 1 && (i = mle[i]), {
      type: "op",
      mode: t.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: i
    };
  },
  htmlBuilder: gu,
  mathmlBuilder: Bd
});
ve({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: cn(r)
    };
  },
  htmlBuilder: gu,
  mathmlBuilder: Bd
});
var gle = {
  "∫": "\\int",
  "∬": "\\iint",
  "∭": "\\iiint",
  "∮": "\\oint",
  "∯": "\\oiint",
  "∰": "\\oiiint"
};
ve({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    return {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: gu,
  mathmlBuilder: Bd
});
ve({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    return {
      type: "op",
      mode: e.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: gu,
  mathmlBuilder: Bd
});
ve({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = t;
    return r.length === 1 && (r = gle[r]), {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: r
    };
  },
  htmlBuilder: gu,
  mathmlBuilder: Bd
});
var bN = (n, e) => {
  var t, r, i = !1, s;
  n.type === "supsub" ? (t = n.sup, r = n.sub, s = Qe(n.base, "operatorname"), i = !0) : s = Qe(n, "operatorname");
  var o;
  if (s.body.length > 0) {
    for (var l = s.body.map((h) => {
      var f = h.text;
      return typeof f == "string" ? {
        type: "textord",
        mode: h.mode,
        text: f
      } : h;
    }), a = xn(l, e.withFont("mathrm"), !0), c = 0; c < a.length; c++) {
      var u = a[c];
      u instanceof ki && (u.text = u.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    o = H.makeSpan(["mop"], a, e);
  } else
    o = H.makeSpan(["mop"], [], e);
  return i ? gN(o, t, r, e, e.style, 0, 0) : o;
}, yle = (n, e) => {
  for (var t = _r(n.body, e.withFont("mathrm")), r = !0, i = 0; i < t.length; i++) {
    var s = t[i];
    if (!(s instanceof ne.SpaceNode)) if (s instanceof ne.MathNode)
      switch (s.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        // Do nothing yet.
        case "mo": {
          var o = s.children[0];
          s.children.length === 1 && o instanceof ne.TextNode ? o.text = o.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : r = !1;
          break;
        }
        default:
          r = !1;
      }
    else
      r = !1;
  }
  if (r) {
    var l = t.map((u) => u.toText()).join("");
    t = [new ne.TextNode(l)];
  }
  var a = new ne.MathNode("mi", t);
  a.setAttribute("mathvariant", "normal");
  var c = new ne.MathNode("mo", [Si("⁡", "text")]);
  return n.parentIsSupSub ? new ne.MathNode("mrow", [a, c]) : ne.newDocumentFragment([a, c]);
};
ve({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "operatorname",
      mode: t.mode,
      body: cn(i),
      alwaysHandleSupSub: r === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: bN,
  mathmlBuilder: yle
});
S("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
$a({
  type: "ordgroup",
  htmlBuilder(n, e) {
    return n.semisimple ? H.makeFragment(xn(n.body, e, !1)) : H.makeSpan(["mord"], xn(n.body, e, !0), e);
  },
  mathmlBuilder(n, e) {
    return vl(n.body, e, !0);
  }
});
ve({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "overline",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder(n, e) {
    var t = ft(n.body, e.havingCrampedStyle()), r = H.makeLineSpan("overline-line", e), i = e.fontMetrics().defaultRuleThickness, s = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: i
      }]
    }, e);
    return H.makeSpan(["mord", "overline"], [s], e);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mo", [new ne.TextNode("‾")]);
    t.setAttribute("stretchy", "true");
    var r = new ne.MathNode("mover", [Pt(n.body, e), t]);
    return r.setAttribute("accent", "true"), r;
  }
});
ve({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "phantom",
      mode: t.mode,
      body: cn(r)
    };
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.body, e.withPhantom(), !1);
    return H.makeFragment(t);
  },
  mathmlBuilder: (n, e) => {
    var t = _r(n.body, e);
    return new ne.MathNode("mphantom", t);
  }
});
ve({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "hphantom",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder: (n, e) => {
    var t = H.makeSpan([], [ft(n.body, e.withPhantom())]);
    if (t.height = 0, t.depth = 0, t.children)
      for (var r = 0; r < t.children.length; r++)
        t.children[r].height = 0, t.children[r].depth = 0;
    return t = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e), H.makeSpan(["mord"], [t], e);
  },
  mathmlBuilder: (n, e) => {
    var t = _r(cn(n.body), e), r = new ne.MathNode("mphantom", t), i = new ne.MathNode("mpadded", [r]);
    return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
  }
});
ve({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "vphantom",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder: (n, e) => {
    var t = H.makeSpan(["inner"], [ft(n.body, e.withPhantom())]), r = H.makeSpan(["fix"], []);
    return H.makeSpan(["mord", "rlap"], [t, r], e);
  },
  mathmlBuilder: (n, e) => {
    var t = _r(cn(n.body), e), r = new ne.MathNode("mphantom", t), i = new ne.MathNode("mpadded", [r]);
    return i.setAttribute("width", "0px"), i;
  }
});
ve({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = Qe(e[0], "size").value, i = e[1];
    return {
      type: "raisebox",
      mode: t.mode,
      dy: r,
      body: i
    };
  },
  htmlBuilder(n, e) {
    var t = ft(n.body, e), r = Qt(n.dy, e);
    return H.makeVList({
      positionType: "shift",
      positionData: -r,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mpadded", [Pt(n.body, e)]), r = n.dy.number + n.dy.unit;
    return t.setAttribute("voffset", r), t;
  }
});
ve({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInArgument: !0
  },
  handler(n) {
    var {
      parser: e
    } = n;
    return {
      type: "internal",
      mode: e.mode
    };
  }
});
ve({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    argTypes: ["size", "size", "size"]
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = t[0], s = Qe(e[0], "size"), o = Qe(e[1], "size");
    return {
      type: "rule",
      mode: r.mode,
      shift: i && Qe(i, "size").value,
      width: s.value,
      height: o.value
    };
  },
  htmlBuilder(n, e) {
    var t = H.makeSpan(["mord", "rule"], [], e), r = Qt(n.width, e), i = Qt(n.height, e), s = n.shift ? Qt(n.shift, e) : 0;
    return t.style.borderRightWidth = fe(r), t.style.borderTopWidth = fe(i), t.style.bottom = fe(s), t.width = r, t.height = i + s, t.depth = -s, t.maxFontSize = i * 1.125 * e.sizeMultiplier, t;
  },
  mathmlBuilder(n, e) {
    var t = Qt(n.width, e), r = Qt(n.height, e), i = n.shift ? Qt(n.shift, e) : 0, s = e.color && e.getColor() || "black", o = new ne.MathNode("mspace");
    o.setAttribute("mathbackground", s), o.setAttribute("width", fe(t)), o.setAttribute("height", fe(r));
    var l = new ne.MathNode("mpadded", [o]);
    return i >= 0 ? l.setAttribute("height", fe(i)) : (l.setAttribute("height", fe(i)), l.setAttribute("depth", fe(-i))), l.setAttribute("voffset", fe(i)), l;
  }
});
function vN(n, e, t) {
  for (var r = xn(n, e, !1), i = e.sizeMultiplier / t.sizeMultiplier, s = 0; s < r.length; s++) {
    var o = r[s].classes.indexOf("sizing");
    o < 0 ? Array.prototype.push.apply(r[s].classes, e.sizingClasses(t)) : r[s].classes[o + 1] === "reset-size" + e.size && (r[s].classes[o + 1] = "reset-size" + t.size), r[s].height *= i, r[s].depth *= i;
  }
  return H.makeFragment(r);
}
var S9 = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], ble = (n, e) => {
  var t = e.havingSize(n.size);
  return vN(n.body, t, e);
};
ve({
  type: "sizing",
  names: S9,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      breakOnTokenText: t,
      funcName: r,
      parser: i
    } = n, s = i.parseExpression(!1, t);
    return {
      type: "sizing",
      mode: i.mode,
      // Figure out what size to use based on the list of functions above
      size: S9.indexOf(r) + 1,
      body: s
    };
  },
  htmlBuilder: ble,
  mathmlBuilder: (n, e) => {
    var t = e.havingSize(n.size), r = _r(n.body, t), i = new ne.MathNode("mstyle", r);
    return i.setAttribute("mathsize", fe(t.sizeMultiplier)), i;
  }
});
ve({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (n, e, t) => {
    var {
      parser: r
    } = n, i = !1, s = !1, o = t[0] && Qe(t[0], "ordgroup");
    if (o)
      for (var l = "", a = 0; a < o.body.length; ++a) {
        var c = o.body[a];
        if (l = c.text, l === "t")
          i = !0;
        else if (l === "b")
          s = !0;
        else {
          i = !1, s = !1;
          break;
        }
      }
    else
      i = !0, s = !0;
    var u = e[0];
    return {
      type: "smash",
      mode: r.mode,
      body: u,
      smashHeight: i,
      smashDepth: s
    };
  },
  htmlBuilder: (n, e) => {
    var t = H.makeSpan([], [ft(n.body, e)]);
    if (!n.smashHeight && !n.smashDepth)
      return t;
    if (n.smashHeight && (t.height = 0, t.children))
      for (var r = 0; r < t.children.length; r++)
        t.children[r].height = 0;
    if (n.smashDepth && (t.depth = 0, t.children))
      for (var i = 0; i < t.children.length; i++)
        t.children[i].depth = 0;
    var s = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
    return H.makeSpan(["mord"], [s], e);
  },
  mathmlBuilder: (n, e) => {
    var t = new ne.MathNode("mpadded", [Pt(n.body, e)]);
    return n.smashHeight && t.setAttribute("height", "0px"), n.smashDepth && t.setAttribute("depth", "0px"), t;
  }
});
ve({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = t[0], s = e[0];
    return {
      type: "sqrt",
      mode: r.mode,
      body: s,
      index: i
    };
  },
  htmlBuilder(n, e) {
    var t = ft(n.body, e.havingCrampedStyle());
    t.height === 0 && (t.height = e.fontMetrics().xHeight), t = H.wrapFragment(t, e);
    var r = e.fontMetrics(), i = r.defaultRuleThickness, s = i;
    e.style.id < We.TEXT.id && (s = e.fontMetrics().xHeight);
    var o = i + s / 4, l = t.height + t.depth + o + i, {
      span: a,
      ruleWidth: c,
      advanceWidth: u
    } = so.sqrtImage(l, e), h = a.height - c;
    h > t.height + t.depth + o && (o = (o + h - t.height - t.depth) / 2);
    var f = a.height - t.height - o - c;
    t.style.paddingLeft = fe(u);
    var d = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(t.height + f)
      }, {
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: c
      }]
    }, e);
    if (n.index) {
      var p = e.havingStyle(We.SCRIPTSCRIPT), m = ft(n.index, p, e), g = 0.6 * (d.height - d.depth), b = H.makeVList({
        positionType: "shift",
        positionData: -g,
        children: [{
          type: "elem",
          elem: m
        }]
      }, e), w = H.makeSpan(["root"], [b]);
      return H.makeSpan(["mord", "sqrt"], [w, d], e);
    } else
      return H.makeSpan(["mord", "sqrt"], [d], e);
  },
  mathmlBuilder(n, e) {
    var {
      body: t,
      index: r
    } = n;
    return r ? new ne.MathNode("mroot", [Pt(t, e), Pt(r, e)]) : new ne.MathNode("msqrt", [Pt(t, e)]);
  }
});
var C9 = {
  display: We.DISPLAY,
  text: We.TEXT,
  script: We.SCRIPT,
  scriptscript: We.SCRIPTSCRIPT
};
ve({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n, e) {
    var {
      breakOnTokenText: t,
      funcName: r,
      parser: i
    } = n, s = i.parseExpression(!0, t), o = r.slice(1, r.length - 5);
    return {
      type: "styling",
      mode: i.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: o,
      body: s
    };
  },
  htmlBuilder(n, e) {
    var t = C9[n.style], r = e.havingStyle(t).withFont("");
    return vN(n.body, r, e);
  },
  mathmlBuilder(n, e) {
    var t = C9[n.style], r = e.havingStyle(t), i = _r(n.body, r), s = new ne.MathNode("mstyle", i), o = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, l = o[n.style];
    return s.setAttribute("scriptlevel", l[0]), s.setAttribute("displaystyle", l[1]), s;
  }
});
var vle = function(e, t) {
  var r = e.base;
  if (r)
    if (r.type === "op") {
      var i = r.limits && (t.style.size === We.DISPLAY.size || r.alwaysHandleSupSub);
      return i ? gu : null;
    } else if (r.type === "operatorname") {
      var s = r.alwaysHandleSupSub && (t.style.size === We.DISPLAY.size || r.limits);
      return s ? bN : null;
    } else {
      if (r.type === "accent")
        return Be.isCharacterBox(r.base) ? d7 : null;
      if (r.type === "horizBrace") {
        var o = !e.sub;
        return o === r.isOver ? mN : null;
      } else
        return null;
    }
  else return null;
};
$a({
  type: "supsub",
  htmlBuilder(n, e) {
    var t = vle(n, e);
    if (t)
      return t(n, e);
    var {
      base: r,
      sup: i,
      sub: s
    } = n, o = ft(r, e), l, a, c = e.fontMetrics(), u = 0, h = 0, f = r && Be.isCharacterBox(r);
    if (i) {
      var d = e.havingStyle(e.style.sup());
      l = ft(i, d, e), f || (u = o.height - d.fontMetrics().supDrop * d.sizeMultiplier / e.sizeMultiplier);
    }
    if (s) {
      var p = e.havingStyle(e.style.sub());
      a = ft(s, p, e), f || (h = o.depth + p.fontMetrics().subDrop * p.sizeMultiplier / e.sizeMultiplier);
    }
    var m;
    e.style === We.DISPLAY ? m = c.sup1 : e.style.cramped ? m = c.sup3 : m = c.sup2;
    var g = e.sizeMultiplier, b = fe(0.5 / c.ptPerEm / g), w = null;
    if (a) {
      var k = n.base && n.base.type === "op" && n.base.name && (n.base.name === "\\oiint" || n.base.name === "\\oiiint");
      (o instanceof ki || k) && (w = fe(-o.italic));
    }
    var C;
    if (l && a) {
      u = Math.max(u, m, l.depth + 0.25 * c.xHeight), h = Math.max(h, c.sub2);
      var M = c.defaultRuleThickness, T = 4 * M;
      if (u - l.depth - (a.height - h) < T) {
        h = T - (u - l.depth) + a.height;
        var N = 0.8 * c.xHeight - (u - l.depth);
        N > 0 && (u += N, h -= N);
      }
      var B = [{
        type: "elem",
        elem: a,
        shift: h,
        marginRight: b,
        marginLeft: w
      }, {
        type: "elem",
        elem: l,
        shift: -u,
        marginRight: b
      }];
      C = H.makeVList({
        positionType: "individualShift",
        children: B
      }, e);
    } else if (a) {
      h = Math.max(h, c.sub1, a.height - 0.8 * c.xHeight);
      var $ = [{
        type: "elem",
        elem: a,
        marginLeft: w,
        marginRight: b
      }];
      C = H.makeVList({
        positionType: "shift",
        positionData: h,
        children: $
      }, e);
    } else if (l)
      u = Math.max(u, m, l.depth + 0.25 * c.xHeight), C = H.makeVList({
        positionType: "shift",
        positionData: -u,
        children: [{
          type: "elem",
          elem: l,
          marginRight: b
        }]
      }, e);
    else
      throw new Error("supsub must have either sup or sub.");
    var R = D5(o, "right") || "mord";
    return H.makeSpan([R], [o, H.makeSpan(["msupsub"], [C])], e);
  },
  mathmlBuilder(n, e) {
    var t = !1, r, i;
    n.base && n.base.type === "horizBrace" && (i = !!n.sup, i === n.base.isOver && (t = !0, r = n.base.isOver)), n.base && (n.base.type === "op" || n.base.type === "operatorname") && (n.base.parentIsSupSub = !0);
    var s = [Pt(n.base, e)];
    n.sub && s.push(Pt(n.sub, e)), n.sup && s.push(Pt(n.sup, e));
    var o;
    if (t)
      o = r ? "mover" : "munder";
    else if (n.sub)
      if (n.sup) {
        var c = n.base;
        c && c.type === "op" && c.limits && e.style === We.DISPLAY || c && c.type === "operatorname" && c.alwaysHandleSupSub && (e.style === We.DISPLAY || c.limits) ? o = "munderover" : o = "msubsup";
      } else {
        var a = n.base;
        a && a.type === "op" && a.limits && (e.style === We.DISPLAY || a.alwaysHandleSupSub) || a && a.type === "operatorname" && a.alwaysHandleSupSub && (a.limits || e.style === We.DISPLAY) ? o = "munder" : o = "msub";
      }
    else {
      var l = n.base;
      l && l.type === "op" && l.limits && (e.style === We.DISPLAY || l.alwaysHandleSupSub) || l && l.type === "operatorname" && l.alwaysHandleSupSub && (l.limits || e.style === We.DISPLAY) ? o = "mover" : o = "msup";
    }
    return new ne.MathNode(o, s);
  }
});
$a({
  type: "atom",
  htmlBuilder(n, e) {
    return H.mathsym(n.text, n.mode, e, ["m" + n.family]);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mo", [Si(n.text, n.mode)]);
    if (n.family === "bin") {
      var r = h7(n, e);
      r === "bold-italic" && t.setAttribute("mathvariant", r);
    } else n.family === "punct" ? t.setAttribute("separator", "true") : (n.family === "open" || n.family === "close") && t.setAttribute("stretchy", "false");
    return t;
  }
});
var wN = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
$a({
  type: "mathord",
  htmlBuilder(n, e) {
    return H.makeOrd(n, e, "mathord");
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mi", [Si(n.text, n.mode, e)]), r = h7(n, e) || "italic";
    return r !== wN[t.type] && t.setAttribute("mathvariant", r), t;
  }
});
$a({
  type: "textord",
  htmlBuilder(n, e) {
    return H.makeOrd(n, e, "textord");
  },
  mathmlBuilder(n, e) {
    var t = Si(n.text, n.mode, e), r = h7(n, e) || "normal", i;
    return n.mode === "text" ? i = new ne.MathNode("mtext", [t]) : /[0-9]/.test(n.text) ? i = new ne.MathNode("mn", [t]) : n.text === "\\prime" ? i = new ne.MathNode("mo", [t]) : i = new ne.MathNode("mi", [t]), r !== wN[i.type] && i.setAttribute("mathvariant", r), i;
  }
});
var m4 = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, g4 = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
$a({
  type: "spacing",
  htmlBuilder(n, e) {
    if (g4.hasOwnProperty(n.text)) {
      var t = g4[n.text].className || "";
      if (n.mode === "text") {
        var r = H.makeOrd(n, e, "textord");
        return r.classes.push(t), r;
      } else
        return H.makeSpan(["mspace", t], [H.mathsym(n.text, n.mode, e)], e);
    } else {
      if (m4.hasOwnProperty(n.text))
        return H.makeSpan(["mspace", m4[n.text]], [], e);
      throw new se('Unknown type of space "' + n.text + '"');
    }
  },
  mathmlBuilder(n, e) {
    var t;
    if (g4.hasOwnProperty(n.text))
      t = new ne.MathNode("mtext", [new ne.TextNode(" ")]);
    else {
      if (m4.hasOwnProperty(n.text))
        return new ne.MathNode("mspace");
      throw new se('Unknown type of space "' + n.text + '"');
    }
    return t;
  }
});
var M9 = () => {
  var n = new ne.MathNode("mtd", []);
  return n.setAttribute("width", "50%"), n;
};
$a({
  type: "tag",
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mtable", [new ne.MathNode("mtr", [M9(), new ne.MathNode("mtd", [vl(n.body, e)]), M9(), new ne.MathNode("mtd", [vl(n.tag, e)])])]);
    return t.setAttribute("width", "100%"), t;
  }
});
var T9 = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, A9 = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, wle = {
  "\\textit": "textit",
  "\\textup": "textup"
}, O9 = (n, e) => {
  var t = n.font;
  if (t) {
    if (T9[t])
      return e.withTextFontFamily(T9[t]);
    if (A9[t])
      return e.withTextFontWeight(A9[t]);
    if (t === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(wle[t]);
};
ve({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "text",
      mode: t.mode,
      body: cn(i),
      font: r
    };
  },
  htmlBuilder(n, e) {
    var t = O9(n, e), r = xn(n.body, t, !0);
    return H.makeSpan(["mord", "text"], r, t);
  },
  mathmlBuilder(n, e) {
    var t = O9(n, e);
    return vl(n.body, t);
  }
});
ve({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "underline",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = ft(n.body, e), r = H.makeLineSpan("underline-line", e), i = e.fontMetrics().defaultRuleThickness, s = H.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return H.makeSpan(["mord", "underline"], [s], e);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mo", [new ne.TextNode("‾")]);
    t.setAttribute("stretchy", "true");
    var r = new ne.MathNode("munder", [Pt(n.body, e), t]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
ve({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "vcenter",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = ft(n.body, e), r = e.fontMetrics().axisHeight, i = 0.5 * (t.height - r - (t.depth + r));
    return H.makeVList({
      positionType: "shift",
      positionData: i,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(n, e) {
    return new ne.MathNode("mpadded", [Pt(n.body, e)], ["vcenter"]);
  }
});
ve({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(n, e, t) {
    throw new se("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(n, e) {
    for (var t = E9(n), r = [], i = e.havingStyle(e.style.text()), s = 0; s < t.length; s++) {
      var o = t[s];
      o === "~" && (o = "\\textasciitilde"), r.push(H.makeSymbol(o, "Typewriter-Regular", n.mode, i, ["mord", "texttt"]));
    }
    return H.makeSpan(["mord", "text"].concat(i.sizingClasses(e)), H.tryCombineChars(r), i);
  },
  mathmlBuilder(n, e) {
    var t = new ne.TextNode(E9(n)), r = new ne.MathNode("mtext", [t]);
    return r.setAttribute("mathvariant", "monospace"), r;
  }
});
var E9 = (n) => n.body.replace(/ /g, n.star ? "␣" : " "), tl = qD, xN = `[ \r
	]`, xle = "\\\\[a-zA-Z@]+", kle = "\\\\[^\uD800-\uDFFF]", Sle = "(" + xle + ")" + xN + "*", Cle = `\\\\(
|[ \r	]+
?)[ \r	]*`, _5 = "[̀-ͯ]", Mle = new RegExp(_5 + "+$"), Tle = "(" + xN + "+)|" + // whitespace
(Cle + "|") + // \whitespace
"([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
(_5 + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(_5 + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + Sle) + // \macroName + spaces
("|" + kle + ")");
class I9 {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(e, t) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = e, this.settings = t, this.tokenRegex = new RegExp(Tle, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(e, t) {
    this.catcodes[e] = t;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var e = this.input, t = this.tokenRegex.lastIndex;
    if (t === e.length)
      return new bi("EOF", new jr(this, t, t));
    var r = this.tokenRegex.exec(e);
    if (r === null || r.index !== t)
      throw new se("Unexpected character: '" + e[t] + "'", new bi(e[t], new jr(this, t, t + 1)));
    var i = r[6] || r[3] || (r[2] ? "\\ " : " ");
    if (this.catcodes[i] === 14) {
      var s = e.indexOf(`
`, this.tokenRegex.lastIndex);
      return s === -1 ? (this.tokenRegex.lastIndex = e.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = s + 1, this.lex();
    }
    return new bi(i, new jr(this, t, this.tokenRegex.lastIndex));
  }
}
class Ale {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(e, t) {
    e === void 0 && (e = {}), t === void 0 && (t = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = t, this.builtins = e, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new se("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var e = this.undefStack.pop();
    for (var t in e)
      e.hasOwnProperty(t) && (e[t] == null ? delete this.current[t] : this.current[t] = e[t]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(e) {
    return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(e) {
    return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(e, t, r) {
    if (r === void 0 && (r = !1), r) {
      for (var i = 0; i < this.undefStack.length; i++)
        delete this.undefStack[i][e];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = t);
    } else {
      var s = this.undefStack[this.undefStack.length - 1];
      s && !s.hasOwnProperty(e) && (s[e] = this.current[e]);
    }
    t == null ? delete this.current[e] : this.current[e] = t;
  }
}
var Ole = uN;
S("\\noexpand", function(n) {
  var e = n.popToken();
  return n.isExpandable(e.text) && (e.noexpand = !0, e.treatAsRelax = !0), {
    tokens: [e],
    numArgs: 0
  };
});
S("\\expandafter", function(n) {
  var e = n.popToken();
  return n.expandOnce(!0), {
    tokens: [e],
    numArgs: 0
  };
});
S("\\@firstoftwo", function(n) {
  var e = n.consumeArgs(2);
  return {
    tokens: e[0],
    numArgs: 0
  };
});
S("\\@secondoftwo", function(n) {
  var e = n.consumeArgs(2);
  return {
    tokens: e[1],
    numArgs: 0
  };
});
S("\\@ifnextchar", function(n) {
  var e = n.consumeArgs(3);
  n.consumeSpaces();
  var t = n.future();
  return e[0].length === 1 && e[0][0].text === t.text ? {
    tokens: e[1],
    numArgs: 0
  } : {
    tokens: e[2],
    numArgs: 0
  };
});
S("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
S("\\TextOrMath", function(n) {
  var e = n.consumeArgs(2);
  return n.mode === "text" ? {
    tokens: e[0],
    numArgs: 0
  } : {
    tokens: e[1],
    numArgs: 0
  };
});
var D9 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
S("\\char", function(n) {
  var e = n.popToken(), t, r = "";
  if (e.text === "'")
    t = 8, e = n.popToken();
  else if (e.text === '"')
    t = 16, e = n.popToken();
  else if (e.text === "`")
    if (e = n.popToken(), e.text[0] === "\\")
      r = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new se("\\char` missing argument");
      r = e.text.charCodeAt(0);
    }
  else
    t = 10;
  if (t) {
    if (r = D9[e.text], r == null || r >= t)
      throw new se("Invalid base-" + t + " digit " + e.text);
    for (var i; (i = D9[n.future().text]) != null && i < t; )
      r *= t, r += i, n.popToken();
  }
  return "\\@char{" + r + "}";
});
var x7 = (n, e, t, r) => {
  var i = n.consumeArg().tokens;
  if (i.length !== 1)
    throw new se("\\newcommand's first argument must be a macro name");
  var s = i[0].text, o = n.isDefined(s);
  if (o && !e)
    throw new se("\\newcommand{" + s + "} attempting to redefine " + (s + "; use \\renewcommand"));
  if (!o && !t)
    throw new se("\\renewcommand{" + s + "} when command " + s + " does not yet exist; use \\newcommand");
  var l = 0;
  if (i = n.consumeArg().tokens, i.length === 1 && i[0].text === "[") {
    for (var a = "", c = n.expandNextToken(); c.text !== "]" && c.text !== "EOF"; )
      a += c.text, c = n.expandNextToken();
    if (!a.match(/^\s*[0-9]+\s*$/))
      throw new se("Invalid number of arguments: " + a);
    l = parseInt(a), i = n.consumeArg().tokens;
  }
  return o && r || n.macros.set(s, {
    tokens: i,
    numArgs: l
  }), "";
};
S("\\newcommand", (n) => x7(n, !1, !0, !1));
S("\\renewcommand", (n) => x7(n, !0, !1, !1));
S("\\providecommand", (n) => x7(n, !0, !0, !0));
S("\\message", (n) => {
  var e = n.consumeArgs(1)[0];
  return console.log(e.reverse().map((t) => t.text).join("")), "";
});
S("\\errmessage", (n) => {
  var e = n.consumeArgs(1)[0];
  return console.error(e.reverse().map((t) => t.text).join("")), "";
});
S("\\show", (n) => {
  var e = n.popToken(), t = e.text;
  return console.log(e, n.macros.get(t), tl[t], Ft.math[t], Ft.text[t]), "";
});
S("\\bgroup", "{");
S("\\egroup", "}");
S("~", "\\nobreakspace");
S("\\lq", "`");
S("\\rq", "'");
S("\\aa", "\\r a");
S("\\AA", "\\r A");
S("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
S("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
S("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
S("ℬ", "\\mathscr{B}");
S("ℰ", "\\mathscr{E}");
S("ℱ", "\\mathscr{F}");
S("ℋ", "\\mathscr{H}");
S("ℐ", "\\mathscr{I}");
S("ℒ", "\\mathscr{L}");
S("ℳ", "\\mathscr{M}");
S("ℛ", "\\mathscr{R}");
S("ℭ", "\\mathfrak{C}");
S("ℌ", "\\mathfrak{H}");
S("ℨ", "\\mathfrak{Z}");
S("\\Bbbk", "\\Bbb{k}");
S("·", "\\cdotp");
S("\\llap", "\\mathllap{\\textrm{#1}}");
S("\\rlap", "\\mathrlap{\\textrm{#1}}");
S("\\clap", "\\mathclap{\\textrm{#1}}");
S("\\mathstrut", "\\vphantom{(}");
S("\\underbar", "\\underline{\\text{#1}}");
S("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
S("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
S("\\ne", "\\neq");
S("≠", "\\neq");
S("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
S("∉", "\\notin");
S("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
S("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
S("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
S("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
S("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
S("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
S("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
S("⟂", "\\perp");
S("‼", "\\mathclose{!\\mkern-0.8mu!}");
S("∌", "\\notni");
S("⌜", "\\ulcorner");
S("⌝", "\\urcorner");
S("⌞", "\\llcorner");
S("⌟", "\\lrcorner");
S("©", "\\copyright");
S("®", "\\textregistered");
S("️", "\\textregistered");
S("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
S("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
S("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
S("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
S("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
S("⋮", "\\vdots");
S("\\varGamma", "\\mathit{\\Gamma}");
S("\\varDelta", "\\mathit{\\Delta}");
S("\\varTheta", "\\mathit{\\Theta}");
S("\\varLambda", "\\mathit{\\Lambda}");
S("\\varXi", "\\mathit{\\Xi}");
S("\\varPi", "\\mathit{\\Pi}");
S("\\varSigma", "\\mathit{\\Sigma}");
S("\\varUpsilon", "\\mathit{\\Upsilon}");
S("\\varPhi", "\\mathit{\\Phi}");
S("\\varPsi", "\\mathit{\\Psi}");
S("\\varOmega", "\\mathit{\\Omega}");
S("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
S("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
S("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
S("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
S("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
S("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
S("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
S("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var N9 = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
S("\\dots", function(n) {
  var e = "\\dotso", t = n.expandAfterFuture().text;
  return t in N9 ? e = N9[t] : (t.slice(0, 4) === "\\not" || t in Ft.math && Be.contains(["bin", "rel"], Ft.math[t].group)) && (e = "\\dotsb"), e;
});
var k7 = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
S("\\dotso", function(n) {
  var e = n.future().text;
  return e in k7 ? "\\ldots\\," : "\\ldots";
});
S("\\dotsc", function(n) {
  var e = n.future().text;
  return e in k7 && e !== "," ? "\\ldots\\," : "\\ldots";
});
S("\\cdots", function(n) {
  var e = n.future().text;
  return e in k7 ? "\\@cdots\\," : "\\@cdots";
});
S("\\dotsb", "\\cdots");
S("\\dotsm", "\\cdots");
S("\\dotsi", "\\!\\cdots");
S("\\dotsx", "\\ldots\\,");
S("\\DOTSI", "\\relax");
S("\\DOTSB", "\\relax");
S("\\DOTSX", "\\relax");
S("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
S("\\,", "\\tmspace+{3mu}{.1667em}");
S("\\thinspace", "\\,");
S("\\>", "\\mskip{4mu}");
S("\\:", "\\tmspace+{4mu}{.2222em}");
S("\\medspace", "\\:");
S("\\;", "\\tmspace+{5mu}{.2777em}");
S("\\thickspace", "\\;");
S("\\!", "\\tmspace-{3mu}{.1667em}");
S("\\negthinspace", "\\!");
S("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
S("\\negthickspace", "\\tmspace-{5mu}{.277em}");
S("\\enspace", "\\kern.5em ");
S("\\enskip", "\\hskip.5em\\relax");
S("\\quad", "\\hskip1em\\relax");
S("\\qquad", "\\hskip2em\\relax");
S("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
S("\\tag@paren", "\\tag@literal{({#1})}");
S("\\tag@literal", (n) => {
  if (n.macros.get("\\df@tag"))
    throw new se("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
S("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
S("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
S("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
S("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
S("\\newline", "\\\\\\relax");
S("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var kN = fe(ps["Main-Regular"][84][1] - 0.7 * ps["Main-Regular"][65][1]);
S("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + kN + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
S("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + kN + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
S("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
S("\\@hspace", "\\hskip #1\\relax");
S("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
S("\\ordinarycolon", ":");
S("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
S("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
S("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
S("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
S("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
S("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
S("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
S("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
S("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
S("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
S("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
S("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
S("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
S("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
S("∷", "\\dblcolon");
S("∹", "\\eqcolon");
S("≔", "\\coloneqq");
S("≕", "\\eqqcolon");
S("⩴", "\\Coloneqq");
S("\\ratio", "\\vcentcolon");
S("\\coloncolon", "\\dblcolon");
S("\\colonequals", "\\coloneqq");
S("\\coloncolonequals", "\\Coloneqq");
S("\\equalscolon", "\\eqqcolon");
S("\\equalscoloncolon", "\\Eqqcolon");
S("\\colonminus", "\\coloneq");
S("\\coloncolonminus", "\\Coloneq");
S("\\minuscolon", "\\eqcolon");
S("\\minuscoloncolon", "\\Eqcolon");
S("\\coloncolonapprox", "\\Colonapprox");
S("\\coloncolonsim", "\\Colonsim");
S("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
S("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
S("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
S("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
S("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
S("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
S("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
S("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
S("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
S("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
S("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
S("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
S("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
S("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
S("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
S("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
S("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
S("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
S("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
S("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
S("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
S("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
S("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
S("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
S("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
S("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
S("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
S("\\imath", "\\html@mathml{\\@imath}{ı}");
S("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
S("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
S("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
S("⟦", "\\llbracket");
S("⟧", "\\rrbracket");
S("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
S("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
S("⦃", "\\lBrace");
S("⦄", "\\rBrace");
S("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
S("⦵", "\\minuso");
S("\\darr", "\\downarrow");
S("\\dArr", "\\Downarrow");
S("\\Darr", "\\Downarrow");
S("\\lang", "\\langle");
S("\\rang", "\\rangle");
S("\\uarr", "\\uparrow");
S("\\uArr", "\\Uparrow");
S("\\Uarr", "\\Uparrow");
S("\\N", "\\mathbb{N}");
S("\\R", "\\mathbb{R}");
S("\\Z", "\\mathbb{Z}");
S("\\alef", "\\aleph");
S("\\alefsym", "\\aleph");
S("\\Alpha", "\\mathrm{A}");
S("\\Beta", "\\mathrm{B}");
S("\\bull", "\\bullet");
S("\\Chi", "\\mathrm{X}");
S("\\clubs", "\\clubsuit");
S("\\cnums", "\\mathbb{C}");
S("\\Complex", "\\mathbb{C}");
S("\\Dagger", "\\ddagger");
S("\\diamonds", "\\diamondsuit");
S("\\empty", "\\emptyset");
S("\\Epsilon", "\\mathrm{E}");
S("\\Eta", "\\mathrm{H}");
S("\\exist", "\\exists");
S("\\harr", "\\leftrightarrow");
S("\\hArr", "\\Leftrightarrow");
S("\\Harr", "\\Leftrightarrow");
S("\\hearts", "\\heartsuit");
S("\\image", "\\Im");
S("\\infin", "\\infty");
S("\\Iota", "\\mathrm{I}");
S("\\isin", "\\in");
S("\\Kappa", "\\mathrm{K}");
S("\\larr", "\\leftarrow");
S("\\lArr", "\\Leftarrow");
S("\\Larr", "\\Leftarrow");
S("\\lrarr", "\\leftrightarrow");
S("\\lrArr", "\\Leftrightarrow");
S("\\Lrarr", "\\Leftrightarrow");
S("\\Mu", "\\mathrm{M}");
S("\\natnums", "\\mathbb{N}");
S("\\Nu", "\\mathrm{N}");
S("\\Omicron", "\\mathrm{O}");
S("\\plusmn", "\\pm");
S("\\rarr", "\\rightarrow");
S("\\rArr", "\\Rightarrow");
S("\\Rarr", "\\Rightarrow");
S("\\real", "\\Re");
S("\\reals", "\\mathbb{R}");
S("\\Reals", "\\mathbb{R}");
S("\\Rho", "\\mathrm{P}");
S("\\sdot", "\\cdot");
S("\\sect", "\\S");
S("\\spades", "\\spadesuit");
S("\\sub", "\\subset");
S("\\sube", "\\subseteq");
S("\\supe", "\\supseteq");
S("\\Tau", "\\mathrm{T}");
S("\\thetasym", "\\vartheta");
S("\\weierp", "\\wp");
S("\\Zeta", "\\mathrm{Z}");
S("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
S("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
S("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
S("\\bra", "\\mathinner{\\langle{#1}|}");
S("\\ket", "\\mathinner{|{#1}\\rangle}");
S("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
S("\\Bra", "\\left\\langle#1\\right|");
S("\\Ket", "\\left|#1\\right\\rangle");
var SN = (n) => (e) => {
  var t = e.consumeArg().tokens, r = e.consumeArg().tokens, i = e.consumeArg().tokens, s = e.consumeArg().tokens, o = e.macros.get("|"), l = e.macros.get("\\|");
  e.macros.beginGroup();
  var a = (h) => (f) => {
    n && (f.macros.set("|", o), i.length && f.macros.set("\\|", l));
    var d = h;
    if (!h && i.length) {
      var p = f.future();
      p.text === "|" && (f.popToken(), d = !0);
    }
    return {
      tokens: d ? i : r,
      numArgs: 0
    };
  };
  e.macros.set("|", a(!1)), i.length && e.macros.set("\\|", a(!0));
  var c = e.consumeArg().tokens, u = e.expandTokens([
    ...s,
    ...c,
    ...t
    // reversed
  ]);
  return e.macros.endGroup(), {
    tokens: u.reverse(),
    numArgs: 0
  };
};
S("\\bra@ket", SN(!1));
S("\\bra@set", SN(!0));
S("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
S("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
S("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
S("\\angln", "{\\angl n}");
S("\\blue", "\\textcolor{##6495ed}{#1}");
S("\\orange", "\\textcolor{##ffa500}{#1}");
S("\\pink", "\\textcolor{##ff00af}{#1}");
S("\\red", "\\textcolor{##df0030}{#1}");
S("\\green", "\\textcolor{##28ae7b}{#1}");
S("\\gray", "\\textcolor{gray}{#1}");
S("\\purple", "\\textcolor{##9d38bd}{#1}");
S("\\blueA", "\\textcolor{##ccfaff}{#1}");
S("\\blueB", "\\textcolor{##80f6ff}{#1}");
S("\\blueC", "\\textcolor{##63d9ea}{#1}");
S("\\blueD", "\\textcolor{##11accd}{#1}");
S("\\blueE", "\\textcolor{##0c7f99}{#1}");
S("\\tealA", "\\textcolor{##94fff5}{#1}");
S("\\tealB", "\\textcolor{##26edd5}{#1}");
S("\\tealC", "\\textcolor{##01d1c1}{#1}");
S("\\tealD", "\\textcolor{##01a995}{#1}");
S("\\tealE", "\\textcolor{##208170}{#1}");
S("\\greenA", "\\textcolor{##b6ffb0}{#1}");
S("\\greenB", "\\textcolor{##8af281}{#1}");
S("\\greenC", "\\textcolor{##74cf70}{#1}");
S("\\greenD", "\\textcolor{##1fab54}{#1}");
S("\\greenE", "\\textcolor{##0d923f}{#1}");
S("\\goldA", "\\textcolor{##ffd0a9}{#1}");
S("\\goldB", "\\textcolor{##ffbb71}{#1}");
S("\\goldC", "\\textcolor{##ff9c39}{#1}");
S("\\goldD", "\\textcolor{##e07d10}{#1}");
S("\\goldE", "\\textcolor{##a75a05}{#1}");
S("\\redA", "\\textcolor{##fca9a9}{#1}");
S("\\redB", "\\textcolor{##ff8482}{#1}");
S("\\redC", "\\textcolor{##f9685d}{#1}");
S("\\redD", "\\textcolor{##e84d39}{#1}");
S("\\redE", "\\textcolor{##bc2612}{#1}");
S("\\maroonA", "\\textcolor{##ffbde0}{#1}");
S("\\maroonB", "\\textcolor{##ff92c6}{#1}");
S("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
S("\\maroonD", "\\textcolor{##ca337c}{#1}");
S("\\maroonE", "\\textcolor{##9e034e}{#1}");
S("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
S("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
S("\\purpleC", "\\textcolor{##aa87ff}{#1}");
S("\\purpleD", "\\textcolor{##7854ab}{#1}");
S("\\purpleE", "\\textcolor{##543b78}{#1}");
S("\\mintA", "\\textcolor{##f5f9e8}{#1}");
S("\\mintB", "\\textcolor{##edf2df}{#1}");
S("\\mintC", "\\textcolor{##e0e5cc}{#1}");
S("\\grayA", "\\textcolor{##f6f7f7}{#1}");
S("\\grayB", "\\textcolor{##f0f1f2}{#1}");
S("\\grayC", "\\textcolor{##e3e5e6}{#1}");
S("\\grayD", "\\textcolor{##d6d8da}{#1}");
S("\\grayE", "\\textcolor{##babec2}{#1}");
S("\\grayF", "\\textcolor{##888d93}{#1}");
S("\\grayG", "\\textcolor{##626569}{#1}");
S("\\grayH", "\\textcolor{##3b3e40}{#1}");
S("\\grayI", "\\textcolor{##21242c}{#1}");
S("\\kaBlue", "\\textcolor{##314453}{#1}");
S("\\kaGreen", "\\textcolor{##71B307}{#1}");
var CN = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class Ele {
  constructor(e, t, r) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = t, this.expansionCount = 0, this.feed(e), this.macros = new Ale(Ole, t.macros), this.mode = r, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(e) {
    this.lexer = new I9(e, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(e) {
    this.stack.push(e);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(e) {
    this.stack.push(...e);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(e) {
    var t, r, i;
    if (e) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      t = this.popToken(), {
        tokens: i,
        end: r
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: i,
        start: t,
        end: r
      } = this.consumeArg());
    return this.pushToken(new bi("EOF", r.loc)), this.pushTokens(i), t.range(r, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var e = this.future();
      if (e.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(e) {
    var t = [], r = e && e.length > 0;
    r || this.consumeSpaces();
    var i = this.future(), s, o = 0, l = 0;
    do {
      if (s = this.popToken(), t.push(s), s.text === "{")
        ++o;
      else if (s.text === "}") {
        if (--o, o === -1)
          throw new se("Extra }", s);
      } else if (s.text === "EOF")
        throw new se("Unexpected end of input in a macro argument, expected '" + (e && r ? e[l] : "}") + "'", s);
      if (e && r)
        if ((o === 0 || o === 1 && e[l] === "{") && s.text === e[l]) {
          if (++l, l === e.length) {
            t.splice(-l, l);
            break;
          }
        } else
          l = 0;
    } while (o !== 0 || r);
    return i.text === "{" && t[t.length - 1].text === "}" && (t.pop(), t.shift()), t.reverse(), {
      tokens: t,
      start: i,
      end: s
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(e, t) {
    if (t) {
      if (t.length !== e + 1)
        throw new se("The length of delimiters doesn't match the number of args!");
      for (var r = t[0], i = 0; i < r.length; i++) {
        var s = this.popToken();
        if (r[i] !== s.text)
          throw new se("Use of the macro doesn't match its definition", s);
      }
    }
    for (var o = [], l = 0; l < e; l++)
      o.push(this.consumeArg(t && t[l + 1]).tokens);
    return o;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(e) {
    if (this.expansionCount += e, this.expansionCount > this.settings.maxExpand)
      throw new se("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(e) {
    var t = this.popToken(), r = t.text, i = t.noexpand ? null : this._getExpansion(r);
    if (i == null || e && i.unexpandable) {
      if (e && i == null && r[0] === "\\" && !this.isDefined(r))
        throw new se("Undefined control sequence: " + r);
      return this.pushToken(t), !1;
    }
    this.countExpansion(1);
    var s = i.tokens, o = this.consumeArgs(i.numArgs, i.delimiters);
    if (i.numArgs) {
      s = s.slice();
      for (var l = s.length - 1; l >= 0; --l) {
        var a = s[l];
        if (a.text === "#") {
          if (l === 0)
            throw new se("Incomplete placeholder at end of macro body", a);
          if (a = s[--l], a.text === "#")
            s.splice(l + 1, 1);
          else if (/^[1-9]$/.test(a.text))
            s.splice(l, 2, ...o[+a.text - 1]);
          else
            throw new se("Not a valid argument number", a);
        }
      }
    }
    return this.pushTokens(s), s.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var e = this.stack.pop();
        return e.treatAsRelax && (e.text = "\\relax"), e;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(e) {
    return this.macros.has(e) ? this.expandTokens([new bi(e)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(e) {
    var t = [], r = this.stack.length;
    for (this.pushTokens(e); this.stack.length > r; )
      if (this.expandOnce(!0) === !1) {
        var i = this.stack.pop();
        i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), t.push(i);
      }
    return this.countExpansion(t.length), t;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(e) {
    var t = this.expandMacro(e);
    return t && t.map((r) => r.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(e) {
    var t = this.macros.get(e);
    if (t == null)
      return t;
    if (e.length === 1) {
      var r = this.lexer.catcodes[e];
      if (r != null && r !== 13)
        return;
    }
    var i = typeof t == "function" ? t(this) : t;
    if (typeof i == "string") {
      var s = 0;
      if (i.indexOf("#") !== -1)
        for (var o = i.replace(/##/g, ""); o.indexOf("#" + (s + 1)) !== -1; )
          ++s;
      for (var l = new I9(i, this.settings), a = [], c = l.lex(); c.text !== "EOF"; )
        a.push(c), c = l.lex();
      a.reverse();
      var u = {
        tokens: a,
        numArgs: s
      };
      return u;
    }
    return i;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(e) {
    return this.macros.has(e) || tl.hasOwnProperty(e) || Ft.math.hasOwnProperty(e) || Ft.text.hasOwnProperty(e) || CN.hasOwnProperty(e);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(e) {
    var t = this.macros.get(e);
    return t != null ? typeof t == "string" || typeof t == "function" || !t.unexpandable : tl.hasOwnProperty(e) && !tl[e].primitive;
  }
}
var R9 = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/, B0 = Object.freeze({
  "₊": "+",
  "₋": "-",
  "₌": "=",
  "₍": "(",
  "₎": ")",
  "₀": "0",
  "₁": "1",
  "₂": "2",
  "₃": "3",
  "₄": "4",
  "₅": "5",
  "₆": "6",
  "₇": "7",
  "₈": "8",
  "₉": "9",
  "ₐ": "a",
  "ₑ": "e",
  "ₕ": "h",
  "ᵢ": "i",
  "ⱼ": "j",
  "ₖ": "k",
  "ₗ": "l",
  "ₘ": "m",
  "ₙ": "n",
  "ₒ": "o",
  "ₚ": "p",
  "ᵣ": "r",
  "ₛ": "s",
  "ₜ": "t",
  "ᵤ": "u",
  "ᵥ": "v",
  "ₓ": "x",
  "ᵦ": "β",
  "ᵧ": "γ",
  "ᵨ": "ρ",
  "ᵩ": "ϕ",
  "ᵪ": "χ",
  "⁺": "+",
  "⁻": "-",
  "⁼": "=",
  "⁽": "(",
  "⁾": ")",
  "⁰": "0",
  "¹": "1",
  "²": "2",
  "³": "3",
  "⁴": "4",
  "⁵": "5",
  "⁶": "6",
  "⁷": "7",
  "⁸": "8",
  "⁹": "9",
  "ᴬ": "A",
  "ᴮ": "B",
  "ᴰ": "D",
  "ᴱ": "E",
  "ᴳ": "G",
  "ᴴ": "H",
  "ᴵ": "I",
  "ᴶ": "J",
  "ᴷ": "K",
  "ᴸ": "L",
  "ᴹ": "M",
  "ᴺ": "N",
  "ᴼ": "O",
  "ᴾ": "P",
  "ᴿ": "R",
  "ᵀ": "T",
  "ᵁ": "U",
  "ⱽ": "V",
  "ᵂ": "W",
  "ᵃ": "a",
  "ᵇ": "b",
  "ᶜ": "c",
  "ᵈ": "d",
  "ᵉ": "e",
  "ᶠ": "f",
  "ᵍ": "g",
  ʰ: "h",
  "ⁱ": "i",
  ʲ: "j",
  "ᵏ": "k",
  ˡ: "l",
  "ᵐ": "m",
  ⁿ: "n",
  "ᵒ": "o",
  "ᵖ": "p",
  ʳ: "r",
  ˢ: "s",
  "ᵗ": "t",
  "ᵘ": "u",
  "ᵛ": "v",
  ʷ: "w",
  ˣ: "x",
  ʸ: "y",
  "ᶻ": "z",
  "ᵝ": "β",
  "ᵞ": "γ",
  "ᵟ": "δ",
  "ᵠ": "ϕ",
  "ᵡ": "χ",
  "ᶿ": "θ"
}), y4 = {
  "́": {
    text: "\\'",
    math: "\\acute"
  },
  "̀": {
    text: "\\`",
    math: "\\grave"
  },
  "̈": {
    text: '\\"',
    math: "\\ddot"
  },
  "̃": {
    text: "\\~",
    math: "\\tilde"
  },
  "̄": {
    text: "\\=",
    math: "\\bar"
  },
  "̆": {
    text: "\\u",
    math: "\\breve"
  },
  "̌": {
    text: "\\v",
    math: "\\check"
  },
  "̂": {
    text: "\\^",
    math: "\\hat"
  },
  "̇": {
    text: "\\.",
    math: "\\dot"
  },
  "̊": {
    text: "\\r",
    math: "\\mathring"
  },
  "̋": {
    text: "\\H"
  },
  "̧": {
    text: "\\c"
  }
}, P9 = {
  á: "á",
  à: "à",
  ä: "ä",
  ǟ: "ǟ",
  ã: "ã",
  ā: "ā",
  ă: "ă",
  ắ: "ắ",
  ằ: "ằ",
  ẵ: "ẵ",
  ǎ: "ǎ",
  â: "â",
  ấ: "ấ",
  ầ: "ầ",
  ẫ: "ẫ",
  ȧ: "ȧ",
  ǡ: "ǡ",
  å: "å",
  ǻ: "ǻ",
  ḃ: "ḃ",
  ć: "ć",
  ḉ: "ḉ",
  č: "č",
  ĉ: "ĉ",
  ċ: "ċ",
  ç: "ç",
  ď: "ď",
  ḋ: "ḋ",
  ḑ: "ḑ",
  é: "é",
  è: "è",
  ë: "ë",
  ẽ: "ẽ",
  ē: "ē",
  ḗ: "ḗ",
  ḕ: "ḕ",
  ĕ: "ĕ",
  ḝ: "ḝ",
  ě: "ě",
  ê: "ê",
  ế: "ế",
  ề: "ề",
  ễ: "ễ",
  ė: "ė",
  ȩ: "ȩ",
  ḟ: "ḟ",
  ǵ: "ǵ",
  ḡ: "ḡ",
  ğ: "ğ",
  ǧ: "ǧ",
  ĝ: "ĝ",
  ġ: "ġ",
  ģ: "ģ",
  ḧ: "ḧ",
  ȟ: "ȟ",
  ĥ: "ĥ",
  ḣ: "ḣ",
  ḩ: "ḩ",
  í: "í",
  ì: "ì",
  ï: "ï",
  ḯ: "ḯ",
  ĩ: "ĩ",
  ī: "ī",
  ĭ: "ĭ",
  ǐ: "ǐ",
  î: "î",
  ǰ: "ǰ",
  ĵ: "ĵ",
  ḱ: "ḱ",
  ǩ: "ǩ",
  ķ: "ķ",
  ĺ: "ĺ",
  ľ: "ľ",
  ļ: "ļ",
  ḿ: "ḿ",
  ṁ: "ṁ",
  ń: "ń",
  ǹ: "ǹ",
  ñ: "ñ",
  ň: "ň",
  ṅ: "ṅ",
  ņ: "ņ",
  ó: "ó",
  ò: "ò",
  ö: "ö",
  ȫ: "ȫ",
  õ: "õ",
  ṍ: "ṍ",
  ṏ: "ṏ",
  ȭ: "ȭ",
  ō: "ō",
  ṓ: "ṓ",
  ṑ: "ṑ",
  ŏ: "ŏ",
  ǒ: "ǒ",
  ô: "ô",
  ố: "ố",
  ồ: "ồ",
  ỗ: "ỗ",
  ȯ: "ȯ",
  ȱ: "ȱ",
  ő: "ő",
  ṕ: "ṕ",
  ṗ: "ṗ",
  ŕ: "ŕ",
  ř: "ř",
  ṙ: "ṙ",
  ŗ: "ŗ",
  ś: "ś",
  ṥ: "ṥ",
  š: "š",
  ṧ: "ṧ",
  ŝ: "ŝ",
  ṡ: "ṡ",
  ş: "ş",
  ẗ: "ẗ",
  ť: "ť",
  ṫ: "ṫ",
  ţ: "ţ",
  ú: "ú",
  ù: "ù",
  ü: "ü",
  ǘ: "ǘ",
  ǜ: "ǜ",
  ǖ: "ǖ",
  ǚ: "ǚ",
  ũ: "ũ",
  ṹ: "ṹ",
  ū: "ū",
  ṻ: "ṻ",
  ŭ: "ŭ",
  ǔ: "ǔ",
  û: "û",
  ů: "ů",
  ű: "ű",
  ṽ: "ṽ",
  ẃ: "ẃ",
  ẁ: "ẁ",
  ẅ: "ẅ",
  ŵ: "ŵ",
  ẇ: "ẇ",
  ẘ: "ẘ",
  ẍ: "ẍ",
  ẋ: "ẋ",
  ý: "ý",
  ỳ: "ỳ",
  ÿ: "ÿ",
  ỹ: "ỹ",
  ȳ: "ȳ",
  ŷ: "ŷ",
  ẏ: "ẏ",
  ẙ: "ẙ",
  ź: "ź",
  ž: "ž",
  ẑ: "ẑ",
  ż: "ż",
  Á: "Á",
  À: "À",
  Ä: "Ä",
  Ǟ: "Ǟ",
  Ã: "Ã",
  Ā: "Ā",
  Ă: "Ă",
  Ắ: "Ắ",
  Ằ: "Ằ",
  Ẵ: "Ẵ",
  Ǎ: "Ǎ",
  Â: "Â",
  Ấ: "Ấ",
  Ầ: "Ầ",
  Ẫ: "Ẫ",
  Ȧ: "Ȧ",
  Ǡ: "Ǡ",
  Å: "Å",
  Ǻ: "Ǻ",
  Ḃ: "Ḃ",
  Ć: "Ć",
  Ḉ: "Ḉ",
  Č: "Č",
  Ĉ: "Ĉ",
  Ċ: "Ċ",
  Ç: "Ç",
  Ď: "Ď",
  Ḋ: "Ḋ",
  Ḑ: "Ḑ",
  É: "É",
  È: "È",
  Ë: "Ë",
  Ẽ: "Ẽ",
  Ē: "Ē",
  Ḗ: "Ḗ",
  Ḕ: "Ḕ",
  Ĕ: "Ĕ",
  Ḝ: "Ḝ",
  Ě: "Ě",
  Ê: "Ê",
  Ế: "Ế",
  Ề: "Ề",
  Ễ: "Ễ",
  Ė: "Ė",
  Ȩ: "Ȩ",
  Ḟ: "Ḟ",
  Ǵ: "Ǵ",
  Ḡ: "Ḡ",
  Ğ: "Ğ",
  Ǧ: "Ǧ",
  Ĝ: "Ĝ",
  Ġ: "Ġ",
  Ģ: "Ģ",
  Ḧ: "Ḧ",
  Ȟ: "Ȟ",
  Ĥ: "Ĥ",
  Ḣ: "Ḣ",
  Ḩ: "Ḩ",
  Í: "Í",
  Ì: "Ì",
  Ï: "Ï",
  Ḯ: "Ḯ",
  Ĩ: "Ĩ",
  Ī: "Ī",
  Ĭ: "Ĭ",
  Ǐ: "Ǐ",
  Î: "Î",
  İ: "İ",
  Ĵ: "Ĵ",
  Ḱ: "Ḱ",
  Ǩ: "Ǩ",
  Ķ: "Ķ",
  Ĺ: "Ĺ",
  Ľ: "Ľ",
  Ļ: "Ļ",
  Ḿ: "Ḿ",
  Ṁ: "Ṁ",
  Ń: "Ń",
  Ǹ: "Ǹ",
  Ñ: "Ñ",
  Ň: "Ň",
  Ṅ: "Ṅ",
  Ņ: "Ņ",
  Ó: "Ó",
  Ò: "Ò",
  Ö: "Ö",
  Ȫ: "Ȫ",
  Õ: "Õ",
  Ṍ: "Ṍ",
  Ṏ: "Ṏ",
  Ȭ: "Ȭ",
  Ō: "Ō",
  Ṓ: "Ṓ",
  Ṑ: "Ṑ",
  Ŏ: "Ŏ",
  Ǒ: "Ǒ",
  Ô: "Ô",
  Ố: "Ố",
  Ồ: "Ồ",
  Ỗ: "Ỗ",
  Ȯ: "Ȯ",
  Ȱ: "Ȱ",
  Ő: "Ő",
  Ṕ: "Ṕ",
  Ṗ: "Ṗ",
  Ŕ: "Ŕ",
  Ř: "Ř",
  Ṙ: "Ṙ",
  Ŗ: "Ŗ",
  Ś: "Ś",
  Ṥ: "Ṥ",
  Š: "Š",
  Ṧ: "Ṧ",
  Ŝ: "Ŝ",
  Ṡ: "Ṡ",
  Ş: "Ş",
  Ť: "Ť",
  Ṫ: "Ṫ",
  Ţ: "Ţ",
  Ú: "Ú",
  Ù: "Ù",
  Ü: "Ü",
  Ǘ: "Ǘ",
  Ǜ: "Ǜ",
  Ǖ: "Ǖ",
  Ǚ: "Ǚ",
  Ũ: "Ũ",
  Ṹ: "Ṹ",
  Ū: "Ū",
  Ṻ: "Ṻ",
  Ŭ: "Ŭ",
  Ǔ: "Ǔ",
  Û: "Û",
  Ů: "Ů",
  Ű: "Ű",
  Ṽ: "Ṽ",
  Ẃ: "Ẃ",
  Ẁ: "Ẁ",
  Ẅ: "Ẅ",
  Ŵ: "Ŵ",
  Ẇ: "Ẇ",
  Ẍ: "Ẍ",
  Ẋ: "Ẋ",
  Ý: "Ý",
  Ỳ: "Ỳ",
  Ÿ: "Ÿ",
  Ỹ: "Ỹ",
  Ȳ: "Ȳ",
  Ŷ: "Ŷ",
  Ẏ: "Ẏ",
  Ź: "Ź",
  Ž: "Ž",
  Ẑ: "Ẑ",
  Ż: "Ż",
  ά: "ά",
  ὰ: "ὰ",
  ᾱ: "ᾱ",
  ᾰ: "ᾰ",
  έ: "έ",
  ὲ: "ὲ",
  ή: "ή",
  ὴ: "ὴ",
  ί: "ί",
  ὶ: "ὶ",
  ϊ: "ϊ",
  ΐ: "ΐ",
  ῒ: "ῒ",
  ῑ: "ῑ",
  ῐ: "ῐ",
  ό: "ό",
  ὸ: "ὸ",
  ύ: "ύ",
  ὺ: "ὺ",
  ϋ: "ϋ",
  ΰ: "ΰ",
  ῢ: "ῢ",
  ῡ: "ῡ",
  ῠ: "ῠ",
  ώ: "ώ",
  ὼ: "ὼ",
  Ύ: "Ύ",
  Ὺ: "Ὺ",
  Ϋ: "Ϋ",
  Ῡ: "Ῡ",
  Ῠ: "Ῠ",
  Ώ: "Ώ",
  Ὼ: "Ὼ"
};
class pg {
  constructor(e, t) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new Ele(e, t, this.mode), this.settings = t, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(e, t) {
    if (t === void 0 && (t = !0), this.fetch().text !== e)
      throw new se("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
    t && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e, this.gullet.switchMode(e);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var e = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(e) {
    var t = this.nextToken;
    this.consume(), this.gullet.pushToken(new bi("}")), this.gullet.pushTokens(e);
    var r = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = t, r;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(e, t) {
    for (var r = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var i = this.fetch();
      if (pg.endOfExpression.indexOf(i.text) !== -1 || t && i.text === t || e && tl[i.text] && tl[i.text].infix)
        break;
      var s = this.parseAtom(t);
      if (s) {
        if (s.type === "internal")
          continue;
      } else break;
      r.push(s);
    }
    return this.mode === "text" && this.formLigatures(r), this.handleInfixNodes(r);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(e) {
    for (var t = -1, r, i = 0; i < e.length; i++)
      if (e[i].type === "infix") {
        if (t !== -1)
          throw new se("only one infix operator per group", e[i].token);
        t = i, r = e[i].replaceWith;
      }
    if (t !== -1 && r) {
      var s, o, l = e.slice(0, t), a = e.slice(t + 1);
      l.length === 1 && l[0].type === "ordgroup" ? s = l[0] : s = {
        type: "ordgroup",
        mode: this.mode,
        body: l
      }, a.length === 1 && a[0].type === "ordgroup" ? o = a[0] : o = {
        type: "ordgroup",
        mode: this.mode,
        body: a
      };
      var c;
      return r === "\\\\abovefrac" ? c = this.callFunction(r, [s, e[t], o], []) : c = this.callFunction(r, [s, o], []), [c];
    } else
      return e;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(e) {
    var t = this.fetch(), r = t.text;
    this.consume(), this.consumeSpaces();
    var i;
    do {
      var s;
      i = this.parseGroup(e);
    } while (((s = i) == null ? void 0 : s.type) === "internal");
    if (!i)
      throw new se("Expected group after '" + r + "'", t);
    return i;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.push({
        type: "textord",
        mode: "text",
        text: e[r]
      });
    var i = {
      type: "text",
      mode: this.mode,
      body: t
    }, s = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [i]
    };
    return s;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(e) {
    var t = this.parseGroup("atom", e);
    if (t?.type === "internal" || this.mode === "text")
      return t;
    for (var r, i; ; ) {
      this.consumeSpaces();
      var s = this.fetch();
      if (s.text === "\\limits" || s.text === "\\nolimits") {
        if (t && t.type === "op") {
          var o = s.text === "\\limits";
          t.limits = o, t.alwaysHandleSupSub = !0;
        } else if (t && t.type === "operatorname")
          t.alwaysHandleSupSub && (t.limits = s.text === "\\limits");
        else
          throw new se("Limit controls must follow a math operator", s);
        this.consume();
      } else if (s.text === "^") {
        if (r)
          throw new se("Double superscript", s);
        r = this.handleSupSubscript("superscript");
      } else if (s.text === "_") {
        if (i)
          throw new se("Double subscript", s);
        i = this.handleSupSubscript("subscript");
      } else if (s.text === "'") {
        if (r)
          throw new se("Double superscript", s);
        var l = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, a = [l];
        for (this.consume(); this.fetch().text === "'"; )
          a.push(l), this.consume();
        this.fetch().text === "^" && a.push(this.handleSupSubscript("superscript")), r = {
          type: "ordgroup",
          mode: this.mode,
          body: a
        };
      } else if (B0[s.text]) {
        var c = R9.test(s.text), u = [];
        for (u.push(new bi(B0[s.text])), this.consume(); ; ) {
          var h = this.fetch().text;
          if (!B0[h] || R9.test(h) !== c)
            break;
          u.unshift(new bi(B0[h])), this.consume();
        }
        var f = this.subparse(u);
        c ? i = {
          type: "ordgroup",
          mode: "math",
          body: f
        } : r = {
          type: "ordgroup",
          mode: "math",
          body: f
        };
      } else
        break;
    }
    return r || i ? {
      type: "supsub",
      mode: this.mode,
      base: t,
      sup: r,
      sub: i
    } : t;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(e, t) {
    var r = this.fetch(), i = r.text, s = tl[i];
    if (!s)
      return null;
    if (this.consume(), t && t !== "atom" && !s.allowedInArgument)
      throw new se("Got function '" + i + "' with no arguments" + (t ? " as " + t : ""), r);
    if (this.mode === "text" && !s.allowedInText)
      throw new se("Can't use function '" + i + "' in text mode", r);
    if (this.mode === "math" && s.allowedInMath === !1)
      throw new se("Can't use function '" + i + "' in math mode", r);
    var {
      args: o,
      optArgs: l
    } = this.parseArguments(i, s);
    return this.callFunction(i, o, l, r, e);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(e, t, r, i, s) {
    var o = {
      funcName: e,
      parser: this,
      token: i,
      breakOnTokenText: s
    }, l = tl[e];
    if (l && l.handler)
      return l.handler(o, t, r);
    throw new se("No function handler for " + e);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(e, t) {
    var r = t.numArgs + t.numOptionalArgs;
    if (r === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var i = [], s = [], o = 0; o < r; o++) {
      var l = t.argTypes && t.argTypes[o], a = o < t.numOptionalArgs;
      (t.primitive && l == null || // \sqrt expands into primitive if optional argument doesn't exist
      t.type === "sqrt" && o === 1 && s[0] == null) && (l = "primitive");
      var c = this.parseGroupOfType("argument to '" + e + "'", l, a);
      if (a)
        s.push(c);
      else if (c != null)
        i.push(c);
      else
        throw new se("Null argument, please report this as a bug");
    }
    return {
      args: i,
      optArgs: s
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(e, t, r) {
    switch (t) {
      case "color":
        return this.parseColorGroup(r);
      case "size":
        return this.parseSizeGroup(r);
      case "url":
        return this.parseUrlGroup(r);
      case "math":
      case "text":
        return this.parseArgumentGroup(r, t);
      case "hbox": {
        var i = this.parseArgumentGroup(r, "text");
        return i != null ? {
          type: "styling",
          mode: i.mode,
          body: [i],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var s = this.parseStringGroup("raw", r);
        return s != null ? {
          type: "raw",
          mode: "text",
          string: s.text
        } : null;
      }
      case "primitive": {
        if (r)
          throw new se("A primitive argument cannot be optional");
        var o = this.parseGroup(e);
        if (o == null)
          throw new se("Expected group as " + e, this.fetch());
        return o;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(r);
      default:
        throw new se("Unknown group type as " + e, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(e, t) {
    var r = this.gullet.scanArgument(t);
    if (r == null)
      return null;
    for (var i = "", s; (s = this.fetch()).text !== "EOF"; )
      i += s.text, this.consume();
    return this.consume(), r.text = i, r;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(e, t) {
    for (var r = this.fetch(), i = r, s = "", o; (o = this.fetch()).text !== "EOF" && e.test(s + o.text); )
      i = o, s += i.text, this.consume();
    if (s === "")
      throw new se("Invalid " + t + ": '" + r.text + "'", r);
    return r.range(i, s);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(e) {
    var t = this.parseStringGroup("color", e);
    if (t == null)
      return null;
    var r = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(t.text);
    if (!r)
      throw new se("Invalid color: '" + t.text + "'", t);
    var i = r[0];
    return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
      type: "color-token",
      mode: this.mode,
      color: i
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(e) {
    var t, r = !1;
    if (this.gullet.consumeSpaces(), !e && this.gullet.future().text !== "{" ? t = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : t = this.parseStringGroup("size", e), !t)
      return null;
    !e && t.text.length === 0 && (t.text = "0pt", r = !0);
    var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t.text);
    if (!i)
      throw new se("Invalid size: '" + t.text + "'", t);
    var s = {
      number: +(i[1] + i[2]),
      // sign + magnitude, cast to number
      unit: i[3]
    };
    if (!PD(s))
      throw new se("Invalid unit: '" + s.unit + "'", t);
    return {
      type: "size",
      mode: this.mode,
      value: s,
      isBlank: r
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(e) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var t = this.parseStringGroup("url", e);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), t == null)
      return null;
    var r = t.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: r
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(e, t) {
    var r = this.gullet.scanArgument(e);
    if (r == null)
      return null;
    var i = this.mode;
    t && this.switchMode(t), this.gullet.beginGroup();
    var s = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var o = {
      type: "ordgroup",
      mode: this.mode,
      loc: r.loc,
      body: s
    };
    return t && this.switchMode(i), o;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(e, t) {
    var r = this.fetch(), i = r.text, s;
    if (i === "{" || i === "\\begingroup") {
      this.consume();
      var o = i === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var l = this.parseExpression(!1, o), a = this.fetch();
      this.expect(o), this.gullet.endGroup(), s = {
        type: "ordgroup",
        mode: this.mode,
        loc: jr.range(r, a),
        body: l,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: i === "\\begingroup" || void 0
      };
    } else if (s = this.parseFunction(t, e) || this.parseSymbol(), s == null && i[0] === "\\" && !CN.hasOwnProperty(i)) {
      if (this.settings.throwOnError)
        throw new se("Undefined control sequence: " + i, r);
      s = this.formatUnsupportedCmd(i), this.consume();
    }
    return s;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(e) {
    for (var t = e.length - 1, r = 0; r < t; ++r) {
      var i = e[r], s = i.text;
      s === "-" && e[r + 1].text === "-" && (r + 1 < t && e[r + 2].text === "-" ? (e.splice(r, 3, {
        type: "textord",
        mode: "text",
        loc: jr.range(i, e[r + 2]),
        text: "---"
      }), t -= 2) : (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: jr.range(i, e[r + 1]),
        text: "--"
      }), t -= 1)), (s === "'" || s === "`") && e[r + 1].text === s && (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: jr.range(i, e[r + 1]),
        text: s + s
      }), t -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var e = this.fetch(), t = e.text;
    if (/^\\verb[^a-zA-Z]/.test(t)) {
      this.consume();
      var r = t.slice(5), i = r.charAt(0) === "*";
      if (i && (r = r.slice(1)), r.length < 2 || r.charAt(0) !== r.slice(-1))
        throw new se(`\\verb assertion failed --
                    please report what input caused this bug`);
      return r = r.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: r,
        star: i
      };
    }
    P9.hasOwnProperty(t[0]) && !Ft[this.mode][t[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + t[0] + '" used in math mode', e), t = P9[t[0]] + t.slice(1));
    var s = Mle.exec(t);
    s && (t = t.substring(0, s.index), t === "i" ? t = "ı" : t === "j" && (t = "ȷ"));
    var o;
    if (Ft[this.mode][t]) {
      this.settings.strict && this.mode === "math" && I5.indexOf(t) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + t[0] + '" used in math mode', e);
      var l = Ft[this.mode][t].group, a = jr.range(e), c;
      if (yoe.hasOwnProperty(l)) {
        var u = l;
        c = {
          type: "atom",
          mode: this.mode,
          family: u,
          loc: a,
          text: t
        };
      } else
        c = {
          type: l,
          mode: this.mode,
          loc: a,
          text: t
        };
      o = c;
    } else if (t.charCodeAt(0) >= 128)
      this.settings.strict && (RD(t.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + t[0] + '" used in math mode', e) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + t[0] + '"' + (" (" + t.charCodeAt(0) + ")"), e)), o = {
        type: "textord",
        mode: "text",
        loc: jr.range(e),
        text: t
      };
    else
      return null;
    if (this.consume(), s)
      for (var h = 0; h < s[0].length; h++) {
        var f = s[0][h];
        if (!y4[f])
          throw new se("Unknown accent ' " + f + "'", e);
        var d = y4[f][this.mode] || y4[f].text;
        if (!d)
          throw new se("Accent " + f + " unsupported in " + this.mode + " mode", e);
        o = {
          type: "accent",
          mode: this.mode,
          loc: jr.range(e),
          label: d,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: o
        };
      }
    return o;
  }
}
pg.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var S7 = function(e, t) {
  if (!(typeof e == "string" || e instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var r = new pg(e, t);
  delete r.gullet.macros.current["\\df@tag"];
  var i = r.parse();
  if (delete r.gullet.macros.current["\\current@color"], delete r.gullet.macros.current["\\color"], r.gullet.macros.get("\\df@tag")) {
    if (!t.displayMode)
      throw new se("\\tag works only in display equations");
    i = [{
      type: "tag",
      mode: "text",
      body: i,
      tag: r.subparse([new bi("\\df@tag")])
    }];
  }
  return i;
}, MN = function(e, t, r) {
  t.textContent = "";
  var i = C7(e, r).toNode();
  t.appendChild(i);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), MN = function() {
  throw new se("KaTeX doesn't work in quirks mode.");
});
var Ile = function(e, t) {
  var r = C7(e, t).toMarkup();
  return r;
}, Dle = function(e, t) {
  var r = new s7(t);
  return S7(e, r);
}, TN = function(e, t, r) {
  if (r.throwOnError || !(e instanceof se))
    throw e;
  var i = H.makeSpan(["katex-error"], [new ki(t)]);
  return i.setAttribute("title", e.toString()), i.setAttribute("style", "color:" + r.errorColor), i;
}, C7 = function(e, t) {
  var r = new s7(t);
  try {
    var i = S7(e, r);
    return Hoe(i, e, r);
  } catch (s) {
    return TN(s, e, r);
  }
}, Nle = function(e, t) {
  var r = new s7(t);
  try {
    var i = S7(e, r);
    return $oe(i, e, r);
  } catch (s) {
    return TN(s, e, r);
  }
}, Rle = "0.16.22", Ple = {
  Span: Ld,
  Anchor: a7,
  SymbolNode: ki,
  SvgNode: po,
  PathNode: bl,
  LineNode: E5
}, AN = {
  /**
   * Current KaTeX version
   */
  version: Rle,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: MN,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: Ile,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: se,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA: Ep,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: Dle,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: C7,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: Nle,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: coe,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: y,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: ve,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: S,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: Ple
};
class mg {
  constructor(e) {
    this.#i = !1, this.onShow = () => {
    }, this.onHide = () => {
    }, this.#c = (t, r) => {
      const { state: i, composing: s } = t, { selection: o, doc: l } = i, { ranges: a } = o, c = Math.min(...a.map((d) => d.$from.pos)), u = Math.max(...a.map((d) => d.$to.pos)), h = r && r.doc.eq(l) && r.selection.eq(o);
      if (this.#i || ((this.#a ?? t.dom.parentElement ?? document.body).appendChild(this.element), this.#i = !0), s || h) return;
      if (!this.#e(t, r)) {
        this.hide();
        return;
      }
      $i({
        getBoundingClientRect: () => c1(t, c, u)
      }, this.element, {
        placement: this.#n.placement ?? "top",
        middleware: [
          Mm(),
          ml(this.#s),
          d8(this.#o),
          ...this.#r
        ]
      }).then(({ x: d, y: p }) => {
        Object.assign(this.element.style, {
          left: `${d}px`,
          top: `${p}px`
        });
      }).catch(console.error), this.show();
    }, this.update = (t, r) => {
      this.#l(t, r);
    }, this.destroy = () => {
      this.#l.cancel();
    }, this.show = (t) => {
      this.element.dataset.show = "true", t && $i(t, this.element, {
        placement: "top",
        middleware: [
          Mm(),
          ml(this.#s),
          d8(this.#o),
          ...this.#r
        ],
        ...this.#n
      }).then(({ x: r, y: i }) => {
        Object.assign(this.element.style, {
          left: `${r}px`,
          top: `${i}px`
        });
      }).catch(console.error), this.onShow();
    }, this.hide = () => {
      this.element.dataset.show !== "false" && (this.element.dataset.show = "false", this.onHide());
    }, this.element = e.content, this.#t = e.debounce ?? 200, this.#e = e.shouldShow ?? this.#u, this.#s = e.offset, this.#o = e.shift, this.#r = e.middleware ?? [], this.#n = e.floatingUIOptions ?? {}, this.#a = e.root, this.element.dataset.show = "false", this.#l = y1(this.#c, this.#t);
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  /// @internal
  #n;
  /// @internal
  #a;
  #i;
  /// @internal
  #s;
  /// @internal
  #o;
  /// @internal
  #l;
  #c;
  /// @internal
  #u(e) {
    const { doc: t, selection: r } = e.state, { empty: i, from: s, to: o } = r, l = !t.textBetween(s, o).length && e.state.selection instanceof Ee, a = this.element.contains(document.activeElement), c = !e.hasFocus() && !a, u = !e.editable;
    return !(c || i || l || u);
  }
}
function gg(n) {
  const e = Mt(
    {},
    `${n}_TOOLTIP_SPEC`
  ), t = kn((i) => {
    const s = i.get(e.key);
    return new Ut({
      key: new en(`${n}_TOOLTIP`),
      ...s
    });
  }), r = [e, t];
  return r.key = e.key, r.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Ctx<tooltipSpec>|${n}`
  }, t.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Prose<tooltip>|${n}`
  }, r;
}
function _le() {
  return {
    enter: {
      mathFlow: n,
      mathFlowFenceMeta: e,
      mathText: s
    },
    exit: {
      mathFlow: i,
      mathFlowFence: r,
      mathFlowFenceMeta: t,
      mathFlowValue: l,
      mathText: o,
      mathTextData: l
    }
  };
  function n(a) {
    const c = {
      type: "element",
      tagName: "code",
      properties: { className: ["language-math", "math-display"] },
      children: []
    };
    this.enter(
      {
        type: "math",
        meta: null,
        value: "",
        data: { hName: "pre", hChildren: [c] }
      },
      a
    );
  }
  function e() {
    this.buffer();
  }
  function t() {
    const a = this.resume(), c = this.stack[this.stack.length - 1];
    c.type, c.meta = a;
  }
  function r() {
    this.data.mathFlowInside || (this.buffer(), this.data.mathFlowInside = !0);
  }
  function i(a) {
    const c = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), u = this.stack[this.stack.length - 1];
    u.type, this.exit(a), u.value = c;
    const h = (
      /** @type {HastElement} */
      u.data.hChildren[0]
    );
    h.type, h.tagName, h.children.push({ type: "text", value: c }), this.data.mathFlowInside = void 0;
  }
  function s(a) {
    this.enter(
      {
        type: "inlineMath",
        value: "",
        data: {
          hName: "code",
          hProperties: { className: ["language-math", "math-inline"] },
          hChildren: []
        }
      },
      a
    ), this.buffer();
  }
  function o(a) {
    const c = this.resume(), u = this.stack[this.stack.length - 1];
    u.type, this.exit(a), u.value = c, /** @type {Array<HastElementContent>} */
    // @ts-expect-error: we defined it in `enterMathFlow`.
    u.data.hChildren.push({ type: "text", value: c });
  }
  function l(a) {
    this.config.enter.data.call(this, a), this.config.exit.data.call(this, a);
  }
}
function Lle(n) {
  let e = (n || {}).singleDollarTextMath;
  return e == null && (e = !0), r.peek = i, {
    unsafe: [
      { character: "\r", inConstruct: "mathFlowMeta" },
      { character: `
`, inConstruct: "mathFlowMeta" },
      {
        character: "$",
        after: e ? void 0 : "\\$",
        inConstruct: "phrasing"
      },
      { character: "$", inConstruct: "mathFlowMeta" },
      { atBreak: !0, character: "$", after: "\\$" }
    ],
    handlers: { math: t, inlineMath: r }
  };
  function t(s, o, l, a) {
    const c = s.value || "", u = l.createTracker(a), h = "$".repeat(Math.max($S(c, "$") + 1, 2)), f = l.enter("mathFlow");
    let d = u.move(h);
    if (s.meta) {
      const p = l.enter("mathFlowMeta");
      d += u.move(
        l.safe(s.meta, {
          after: `
`,
          before: d,
          encode: ["$"],
          ...u.current()
        })
      ), p();
    }
    return d += u.move(`
`), c && (d += u.move(c + `
`)), d += u.move(h), f(), d;
  }
  function r(s, o, l) {
    let a = s.value || "", c = 1;
    for (e || c++; new RegExp("(^|[^$])" + "\\$".repeat(c) + "([^$]|$)").test(a); )
      c++;
    const u = "$".repeat(c);
    // Contains non-space.
    /[^ \r\n]/.test(a) && // Starts with space and ends with space.
    (/^[ \r\n]/.test(a) && /[ \r\n]$/.test(a) || // Starts or ends with dollar.
    /^\$|\$$/.test(a)) && (a = " " + a + " ");
    let h = -1;
    for (; ++h < l.unsafe.length; ) {
      const f = l.unsafe[h];
      if (!f.atBreak) continue;
      const d = l.compilePattern(f);
      let p;
      for (; p = d.exec(a); ) {
        let m = p.index;
        a.codePointAt(m) === 10 && a.codePointAt(m - 1) === 13 && m--, a = a.slice(0, m) + " " + a.slice(p.index + 1);
      }
    }
    return u + a + u;
  }
  function i() {
    return "$";
  }
}
const Ble = {
  tokenize: zle,
  concrete: !0,
  name: "mathFlow"
}, _9 = {
  tokenize: Fle,
  partial: !0
};
function zle(n, e, t) {
  const r = this, i = r.events[r.events.length - 1], s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let o = 0;
  return l;
  function l(w) {
    return n.enter("mathFlow"), n.enter("mathFlowFence"), n.enter("mathFlowFenceSequence"), a(w);
  }
  function a(w) {
    return w === 36 ? (n.consume(w), o++, a) : o < 2 ? t(w) : (n.exit("mathFlowFenceSequence"), it(n, c, "whitespace")(w));
  }
  function c(w) {
    return w === null || Ne(w) ? h(w) : (n.enter("mathFlowFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), u(w));
  }
  function u(w) {
    return w === null || Ne(w) ? (n.exit("chunkString"), n.exit("mathFlowFenceMeta"), h(w)) : w === 36 ? t(w) : (n.consume(w), u);
  }
  function h(w) {
    return n.exit("mathFlowFence"), r.interrupt ? e(w) : n.attempt(_9, f, g)(w);
  }
  function f(w) {
    return n.attempt({
      tokenize: b,
      partial: !0
    }, g, d)(w);
  }
  function d(w) {
    return (s ? it(n, p, "linePrefix", s + 1) : p)(w);
  }
  function p(w) {
    return w === null ? g(w) : Ne(w) ? n.attempt(_9, f, g)(w) : (n.enter("mathFlowValue"), m(w));
  }
  function m(w) {
    return w === null || Ne(w) ? (n.exit("mathFlowValue"), p(w)) : (n.consume(w), m);
  }
  function g(w) {
    return n.exit("mathFlow"), e(w);
  }
  function b(w, k, C) {
    let M = 0;
    return it(w, T, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function T($) {
      return w.enter("mathFlowFence"), w.enter("mathFlowFenceSequence"), N($);
    }
    function N($) {
      return $ === 36 ? (M++, w.consume($), N) : M < o ? C($) : (w.exit("mathFlowFenceSequence"), it(w, B, "whitespace")($));
    }
    function B($) {
      return $ === null || Ne($) ? (w.exit("mathFlowFence"), k($)) : C($);
    }
  }
}
function Fle(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? e(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
function Hle(n) {
  let t = (n || {}).singleDollarTextMath;
  return t == null && (t = !0), {
    tokenize: r,
    resolve: $le,
    previous: Vle,
    name: "mathText"
  };
  function r(i, s, o) {
    let l = 0, a, c;
    return u;
    function u(m) {
      return i.enter("mathText"), i.enter("mathTextSequence"), h(m);
    }
    function h(m) {
      return m === 36 ? (i.consume(m), l++, h) : l < 2 && !t ? o(m) : (i.exit("mathTextSequence"), f(m));
    }
    function f(m) {
      return m === null ? o(m) : m === 36 ? (c = i.enter("mathTextSequence"), a = 0, p(m)) : m === 32 ? (i.enter("space"), i.consume(m), i.exit("space"), f) : Ne(m) ? (i.enter("lineEnding"), i.consume(m), i.exit("lineEnding"), f) : (i.enter("mathTextData"), d(m));
    }
    function d(m) {
      return m === null || m === 32 || m === 36 || Ne(m) ? (i.exit("mathTextData"), f(m)) : (i.consume(m), d);
    }
    function p(m) {
      return m === 36 ? (i.consume(m), a++, p) : a === l ? (i.exit("mathTextSequence"), i.exit("mathText"), s(m)) : (c.type = "mathTextData", d(m));
    }
  }
}
function $le(n) {
  let e = n.length - 4, t = 3, r, i;
  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {
    for (r = t; ++r < e; )
      if (n[r][1].type === "mathTextData") {
        n[e][1].type = "mathTextPadding", n[t][1].type = "mathTextPadding", t += 2, e -= 2;
        break;
      }
  }
  for (r = t - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "mathTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function Vle(n) {
  return n !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function qle(n) {
  return {
    flow: {
      36: Ble
    },
    text: {
      36: Hle(n)
    }
  };
}
const Wle = {};
function jle(n) {
  const e = (
    /** @type {Processor} */
    this
  ), t = n || Wle, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(qle(t)), s.push(_le()), o.push(Lle(t));
}
var Ule = Object.defineProperty, L9 = Object.getOwnPropertySymbols, Kle = Object.prototype.hasOwnProperty, Gle = Object.prototype.propertyIsEnumerable, B9 = (n, e, t) => e in n ? Ule(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Yle = (n, e) => {
  for (var t in e || (e = {}))
    Kle.call(e, t) && B9(n, t, e[t]);
  if (L9)
    for (var t of L9(e))
      Gle.call(e, t) && B9(n, t, e[t]);
  return n;
};
function Va(n, e) {
  return Object.assign(n, {
    meta: Yle({
      package: "@milkdown/components"
    }, e)
  }), n;
}
var Jle = Object.defineProperty, z9 = Object.getOwnPropertySymbols, Xle = Object.prototype.hasOwnProperty, Zle = Object.prototype.propertyIsEnumerable, F9 = (n, e, t) => e in n ? Jle(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, M7 = (n, e) => {
  for (var t in e || (e = {}))
    Xle.call(e, t) && F9(n, t, e[t]);
  if (z9)
    for (var t of z9(e))
      Zle.call(e, t) && F9(n, t, e[t]);
  return n;
};
const Qle = {
  mode: "preview"
}, yo = Mt(M7({}, Qle), "linkTooltipStateCtx");
Va(yo, {
  displayName: "State<link-tooltip>",
  group: "LinkTooltip"
});
const eae = {
  addLink: () => {
  },
  editLink: () => {
  },
  removeLink: () => {
  }
}, Yc = Mt(M7({}, eae), "linkTooltipAPICtx");
Va(yo, {
  displayName: "API<link-tooltip>",
  group: "LinkTooltip"
});
const tae = {
  linkIcon: "🔗",
  editButton: "✎",
  removeButton: "⌫",
  confirmButton: "Confirm ⏎",
  onCopyLink: () => {
  },
  inputPlaceholder: "Paste link..."
}, Jc = Mt(
  M7({}, tae),
  "linkTooltipConfigCtx"
);
Va(yo, {
  displayName: "Config<link-tooltip>",
  group: "LinkTooltip"
});
const ON = Ye("ToggleLink", (n) => () => (e) => {
  const { doc: t, selection: r } = e, i = Ri.type(n);
  return t.rangeHasMark(r.from, r.to, i) ? (n.get(Yc.key).removeLink(r.from, r.to), !0) : (n.get(Yc.key).addLink(r.from, r.to), !0);
}), zd = gg("LINK_PREVIEW");
Va(zd[0], {
  displayName: "PreviewTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
Va(zd[1], {
  displayName: "PreviewTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
const yg = gg("LINK_EDIT");
Va(yg[0], {
  displayName: "EditTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
Va(yg[1], {
  displayName: "EditTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
function gf({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
gf.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const nae = /* @__PURE__ */ $n({
  props: {
    config: {
      type: Object,
      required: !0
    },
    src: {
      type: Object,
      required: !0
    },
    onConfirm: {
      type: Function,
      required: !0
    },
    onCancel: {
      type: Function,
      required: !0
    }
  },
  setup({ config: n, src: e, onConfirm: t, onCancel: r }) {
    const i = Ae(e);
    Mc(e, (l) => {
      i.value = l;
    });
    const s = () => {
      t(i.value);
    }, o = (l) => {
      l.stopPropagation(), l.key === "Enter" && (l.preventDefault(), s()), l.key === "Escape" && (l.preventDefault(), r());
    };
    return () => /* @__PURE__ */ j("div", { class: "link-edit" }, /* @__PURE__ */ j(
      "input",
      {
        class: "input-area",
        placeholder: n.value.inputPlaceholder,
        onKeydown: o,
        onInput: (l) => {
          i.value = l.target.value;
        },
        value: i.value
      }
    ), i.value ? /* @__PURE__ */ j(
      gf,
      {
        class: "button confirm",
        icon: n.value.confirmButton,
        onClick: s
      }
    ) : null);
  }
});
var rae = Object.defineProperty, iae = Object.defineProperties, sae = Object.getOwnPropertyDescriptors, H9 = Object.getOwnPropertySymbols, oae = Object.prototype.hasOwnProperty, lae = Object.prototype.propertyIsEnumerable, EN = (n) => {
  throw TypeError(n);
}, $9 = (n, e, t) => e in n ? rae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, z0 = (n, e) => {
  for (var t in e || (e = {}))
    oae.call(e, t) && $9(n, t, e[t]);
  if (H9)
    for (var t of H9(e))
      lae.call(e, t) && $9(n, t, e[t]);
  return n;
}, V9 = (n, e) => iae(n, sae(e)), IN = (n, e, t) => e.has(n) || EN("Cannot " + t), Jt = (n, e, t) => (IN(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Fs = (n, e, t) => e.has(n) ? EN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Fl = (n, e, t, r) => (IN(n, e, "write to private field"), e.set(n, t), t), wh, Po, _o, Dp, xh, Np, jl, L5, Rp;
const q9 = {
  from: -1,
  to: -1,
  mark: null
};
class aae {
  constructor(e, t) {
    this.ctx = e, Fs(this, wh), Fs(this, Po), Fs(this, _o, z0({}, q9)), Fs(this, Dp), Fs(this, xh), Fs(this, Np, Ae("")), Fs(this, jl, () => {
      Jt(this, Po).hide(), this.ctx.update(yo.key, (s) => V9(z0({}, s), {
        mode: "preview"
      })), Fl(this, _o, z0({}, q9));
    }), Fs(this, L5, (s) => {
      const o = this.ctx.get(Ct), { from: l, to: a, mark: c } = Jt(this, _o), u = Ri.type(this.ctx), h = Ui.sanitize(s);
      if (c && c.attrs.href === h) {
        Jt(this, jl).call(this);
        return;
      }
      const f = o.state.tr;
      c && f.removeMark(l, a, c), f.addMark(l, a, u.create({ href: h })), o.dispatch(f), Jt(this, jl).call(this);
    }), Fs(this, Rp, (s, o, l) => {
      const a = this.ctx.get(Jc.key);
      Jt(this, xh).value = a, Jt(this, Np).value = s, this.ctx.update(yo.key, (u) => V9(z0({}, u), {
        mode: "edit"
      }));
      const c = this.ctx.get(Ct);
      c.dispatch(
        c.state.tr.setSelection(Ee.create(c.state.doc, o, l))
      ), Jt(this, Po).show({
        getBoundingClientRect: () => c1(c, o, l)
      }), requestAnimationFrame(() => {
        var u;
        (u = Jt(this, wh).querySelector("input")) == null || u.focus();
      });
    }), this.update = (s) => {
      const { state: o } = s, { selection: l } = o;
      if (!(l instanceof Ee)) return;
      const { from: a, to: c } = l;
      a === Jt(this, _o).from && c === Jt(this, _o).to || Jt(this, jl).call(this);
    }, this.destroy = () => {
      Jt(this, Dp).unmount(), Jt(this, Po).destroy(), Jt(this, wh).remove();
    }, this.addLink = (s, o) => {
      Fl(this, _o, {
        from: s,
        to: o,
        mark: null
      }), Jt(this, Rp).call(this, "", s, o);
    }, this.editLink = (s, o, l) => {
      Fl(this, _o, {
        from: o,
        to: l,
        mark: s
      }), Jt(this, Rp).call(this, s.attrs.href, o, l);
    }, this.removeLink = (s, o) => {
      const l = this.ctx.get(Ct), a = l.state.tr;
      a.removeMark(s, o, Ri.type(this.ctx)), l.dispatch(a), Jt(this, jl).call(this);
    }, Fl(this, xh, Ae(this.ctx.get(Jc.key)));
    const r = document.createElement("div");
    r.className = "milkdown-link-edit";
    const i = ji(nae, {
      config: Jt(this, xh),
      src: Jt(this, Np),
      onConfirm: Jt(this, L5),
      onCancel: Jt(this, jl)
    });
    i.mount(r), Fl(this, Dp, i), Fl(this, wh, r), Fl(this, Po, new mg({
      content: r,
      debounce: 0,
      shouldShow: () => !1
    })), Jt(this, Po).onHide = () => {
      requestAnimationFrame(() => {
        t.dom.focus({ preventScroll: !0 });
      });
    }, Jt(this, Po).update(t);
  }
}
wh = /* @__PURE__ */ new WeakMap();
Po = /* @__PURE__ */ new WeakMap();
_o = /* @__PURE__ */ new WeakMap();
Dp = /* @__PURE__ */ new WeakMap();
xh = /* @__PURE__ */ new WeakMap();
Np = /* @__PURE__ */ new WeakMap();
jl = /* @__PURE__ */ new WeakMap();
L5 = /* @__PURE__ */ new WeakMap();
Rp = /* @__PURE__ */ new WeakMap();
var cae = Object.defineProperty, uae = Object.defineProperties, hae = Object.getOwnPropertyDescriptors, W9 = Object.getOwnPropertySymbols, fae = Object.prototype.hasOwnProperty, dae = Object.prototype.propertyIsEnumerable, j9 = (n, e, t) => e in n ? cae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, pae = (n, e) => {
  for (var t in e || (e = {}))
    fae.call(e, t) && j9(n, t, e[t]);
  if (W9)
    for (var t of W9(e))
      dae.call(e, t) && j9(n, t, e[t]);
  return n;
}, mae = (n, e) => uae(n, hae(e));
function gae(n) {
  let e;
  n.update(Yc.key, (t) => mae(pae({}, t), {
    addLink: (r, i) => {
      e?.addLink(r, i);
    },
    editLink: (r, i, s) => {
      e?.editLink(r, i, s);
    },
    removeLink: (r, i) => {
      e?.removeLink(r, i);
    }
  })), n.set(yg.key, {
    view: (t) => (e = new aae(n, t), e)
  });
}
function yae(n, e, t, r, i) {
  let s = { start: -1, end: -1 };
  return t.nodesBetween(r, i, (o, l) => {
    if (s.start > -1) return !1;
    s.start === -1 && n.isInSet(o.marks) && e === o && (s = {
      start: l,
      end: l + Math.max(o.textContent.length, 1)
    });
  }), s;
}
function bae(n, e, t) {
  const r = e.posAtCoords({ left: t.clientX, top: t.clientY });
  if (!r) return;
  const { pos: i } = r, s = e.state.doc.nodeAt(i);
  if (!s) return;
  const o = s.marks.find(
    (a) => a.type === Ri.mark.type(n)
  );
  if (!(!o || !zd.pluginKey()))
    return { show: !0, pos: i, node: s, mark: o };
}
const vae = /* @__PURE__ */ $n({
  props: {
    config: {
      type: Object,
      required: !0
    },
    src: {
      type: Object,
      required: !0
    },
    onEdit: {
      type: Object,
      required: !0
    },
    onRemove: {
      type: Object,
      required: !0
    }
  },
  setup({ config: n, src: e, onEdit: t, onRemove: r }) {
    const i = (l) => {
      l.preventDefault(), l.stopPropagation(), t.value();
    }, s = (l) => {
      l.preventDefault(), l.stopPropagation(), r.value();
    }, o = (l) => {
      l.preventDefault();
      const a = e.value;
      navigator.clipboard && a && navigator.clipboard.writeText(a).then(() => {
        n.value.onCopyLink(a);
      }).catch((c) => console.error(c));
    };
    return () => /* @__PURE__ */ j("div", { class: "link-preview" }, /* @__PURE__ */ j(
      gf,
      {
        class: "button link-icon",
        icon: n.value.linkIcon,
        onClick: o
      }
    ), /* @__PURE__ */ j("a", { href: e.value, target: "_blank", class: "link-display" }, e.value), /* @__PURE__ */ j(
      gf,
      {
        class: "button link-edit-button",
        icon: n.value.editButton,
        onClick: i
      }
    ), /* @__PURE__ */ j(
      gf,
      {
        class: "button link-remove-button",
        icon: n.value.removeButton,
        onClick: s
      }
    ));
  }
});
var DN = (n) => {
  throw TypeError(n);
}, NN = (n, e, t) => e.has(n) || DN("Cannot " + t), ut = (n, e, t) => (NN(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Fr = (n, e, t) => e.has(n) ? DN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Hl = (n, e, t, r) => (NN(n, e, "write to private field"), e.set(n, t), t), Ul, Ai, kh, Sh, Pp, _p, Lp, Ch, Mh, Bp, zp, Fp, Th;
class wae {
  constructor(e, t) {
    this.ctx = e, Fr(this, Ul), Fr(this, Ai), Fr(this, kh, this.ctx.use(yo.key)), Fr(this, Sh), Fr(this, Pp, Ae("")), Fr(this, _p, Ae(() => {
    })), Fr(this, Lp, Ae(() => {
    })), Fr(this, Ch), Fr(this, Mh, !1), Fr(this, Bp, ({ mode: r }) => {
      r === "edit" && ut(this, Th).call(this);
    }), Fr(this, zp, () => {
      Hl(this, Mh, !0);
    }), Fr(this, Fp, () => {
      Hl(this, Mh, !1);
    }), Fr(this, Th, () => {
      ut(this, Ai).hide(), ut(this, Ai).element.removeEventListener("mouseenter", ut(this, zp)), ut(this, Ai).element.removeEventListener("mouseleave", ut(this, Fp));
    }), this.show = (r, i, s, o) => {
      ut(this, Sh).value = this.ctx.get(Jc.key), ut(this, Pp).value = r.attrs.href, ut(this, _p).value = () => {
        this.ctx.get(Yc.key).editLink(r, i, s);
      }, ut(this, Lp).value = () => {
        this.ctx.get(Yc.key).removeLink(i, s), ut(this, Th).call(this);
      }, ut(this, Ai).show({
        getBoundingClientRect: () => o
      }), ut(this, Ai).element.addEventListener("mouseenter", ut(this, zp)), ut(this, Ai).element.addEventListener("mouseleave", ut(this, Fp));
    }, this.hide = () => {
      ut(this, Mh) || ut(this, Th).call(this);
    }, this.update = () => {
    }, this.destroy = () => {
      ut(this, Ch).unmount(), ut(this, kh).off(ut(this, Bp)), ut(this, Ai).destroy(), ut(this, Ul).remove();
    }, Hl(this, Sh, Ae(this.ctx.get(Jc.key))), Hl(this, Ch, ji(vae, {
      config: ut(this, Sh),
      src: ut(this, Pp),
      onEdit: ut(this, _p),
      onRemove: ut(this, Lp)
    })), Hl(this, Ul, document.createElement("div")), ut(this, Ul).className = "milkdown-link-preview", ut(this, Ch).mount(ut(this, Ul)), Hl(this, Ai, new mg({
      debounce: 0,
      content: ut(this, Ul),
      shouldShow: () => !1
    })), ut(this, Ai).update(t), Hl(this, kh, e.use(yo.key)), ut(this, kh).on(ut(this, Bp));
  }
}
Ul = /* @__PURE__ */ new WeakMap();
Ai = /* @__PURE__ */ new WeakMap();
kh = /* @__PURE__ */ new WeakMap();
Sh = /* @__PURE__ */ new WeakMap();
Pp = /* @__PURE__ */ new WeakMap();
_p = /* @__PURE__ */ new WeakMap();
Lp = /* @__PURE__ */ new WeakMap();
Ch = /* @__PURE__ */ new WeakMap();
Mh = /* @__PURE__ */ new WeakMap();
Bp = /* @__PURE__ */ new WeakMap();
zp = /* @__PURE__ */ new WeakMap();
Fp = /* @__PURE__ */ new WeakMap();
Th = /* @__PURE__ */ new WeakMap();
function xae(n) {
  let e;
  const r = g1((s, o) => {
    if (!e || !s.hasFocus() || n.get(yo.key).mode === "edit") return;
    const a = bae(n, s, o);
    if (a) {
      const c = s.state.doc.resolve(a.pos), u = yae(
        a.mark,
        a.node,
        s.state.doc,
        c.before(),
        c.after()
      ), h = u.start, f = u.end;
      e.show(
        a.mark,
        h,
        f,
        c1(s, h, f)
      );
      return;
    }
    e.hide();
  }, 50), i = () => {
    setTimeout(() => {
      e?.hide();
    }, 50);
  };
  n.set(zd.key, {
    props: {
      handleDOMEvents: {
        mousemove: r,
        mouseleave: i
      }
    },
    view: (s) => (e = new wae(n, s), e)
  });
}
function kae(n) {
  xae(n), gae(n);
}
const Sae = [
  yo,
  Yc,
  Jc,
  zd,
  yg,
  ON
].flat();
var Cae = Object.defineProperty, U9 = Object.getOwnPropertySymbols, Mae = Object.prototype.hasOwnProperty, Tae = Object.prototype.propertyIsEnumerable, K9 = (n, e, t) => e in n ? Cae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Aae = (n, e) => {
  for (var t in e || (e = {}))
    Mae.call(e, t) && K9(n, t, e[t]);
  if (U9)
    for (var t of U9(e))
      Tae.call(e, t) && K9(n, t, e[t]);
  return n;
};
function RN(n, e) {
  return Object.assign(n, {
    meta: Aae({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const Oae = {
  renderLabel: ({ label: n, listType: e, checked: t }) => t == null ? e === "bullet" ? "⦿" : n : t ? "☑" : "□"
}, bg = Mt(
  Oae,
  "listItemBlockConfigCtx"
);
RN(bg, {
  displayName: "Config<list-item-block>",
  group: "ListItemBlock"
});
function PN({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
PN.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const Eae = /* @__PURE__ */ $n({
  props: {
    label: {
      type: Object,
      required: !0
    },
    checked: {
      type: Object,
      required: !0
    },
    listType: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    onMount: {
      type: Function,
      required: !0
    }
  },
  setup({
    label: n,
    checked: e,
    listType: t,
    config: r,
    readonly: i,
    setAttr: s,
    onMount: o,
    selected: l
  }) {
    const a = (f) => {
      f != null && f instanceof Element && o(f);
    }, c = (f) => {
      f.stopPropagation(), f.preventDefault(), e.value != null && s("checked", !e.value);
    }, u = Na(() => r.renderLabel({
      label: n.value,
      listType: t.value,
      checked: e.value,
      readonly: i.value
    })), h = Na(() => e.value == null ? t.value === "bullet" ? "bullet" : "ordered" : e.value ? "checked" : "unchecked");
    return () => /* @__PURE__ */ j(
      "li",
      {
        class: Hn(
          "list-item",
          l.value && "ProseMirror-selectednode"
        )
      },
      /* @__PURE__ */ j(
        "div",
        {
          class: "label-wrapper",
          onPointerdown: c,
          contenteditable: !1
        },
        /* @__PURE__ */ j(
          PN,
          {
            class: Hn(
              "label",
              i.value && "readonly",
              h.value
            ),
            icon: u.value
          }
        )
      ),
      /* @__PURE__ */ j("div", { class: "children", ref: a })
    );
  }
}), _N = yd(
  Wi.node,
  (n) => (e, t, r) => {
    const i = document.createElement("div");
    i.className = "milkdown-list-item-block";
    const s = document.createElement("div");
    s.setAttribute("data-content-dom", "true"), s.classList.add("content-dom");
    const o = Ae(e.attrs.label), l = Ae(e.attrs.checked), a = Ae(e.attrs.listType), c = Ae(!t.editable), u = n.get(bg.key), h = Ae(!1), f = (k, C) => {
      if (!t.editable) return;
      const M = r();
      M != null && (t.hasFocus() || t.focus(), t.dispatch(t.state.tr.setNodeAttribute(M, k, C)));
    }, d = cu(() => {
      h.value ? i.classList.add("selected") : i.classList.remove("selected");
    });
    let p = 0;
    const g = ji(Eae, {
      label: o,
      checked: l,
      listType: a,
      readonly: c,
      config: u,
      selected: h,
      setAttr: f,
      onMount: (k) => {
        const { anchor: C, head: M } = t.state.selection;
        k.appendChild(s);
        const T = t.state.doc.resolve(C), N = t.state.doc.resolve(M);
        p = requestAnimationFrame(() => {
          if (cancelAnimationFrame(p), !T.doc.eq(t.state.doc)) return;
          const B = new Ee(T, N);
          t.dispatch(t.state.tr.setSelection(B));
        });
      }
    });
    g.mount(i);
    const b = (k) => {
      a.value = k.attrs.listType, o.value = k.attrs.label, l.value = k.attrs.checked, c.value = !t.editable;
    };
    b(e);
    let w = e;
    return {
      dom: i,
      contentDOM: s,
      update: (k) => k.type !== e.type ? !1 : (k.sameMarkup(w) && k.content.eq(w.content) || (w = k, b(k)), !0),
      ignoreMutation: (k) => !i || !s ? !0 : k.type === "selection" ? !1 : s === k.target && k.type === "attributes" ? !0 : !s.contains(k.target),
      selectNode: () => {
        h.value = !0;
      },
      deselectNode: () => {
        h.value = !1;
      },
      destroy: () => {
        d(), g.unmount(), i.remove(), s.remove();
      }
    };
  }
);
RN(_N, {
  displayName: "NodeView<list-item-block>",
  group: "ListItemBlock"
});
const Iae = [
  bg,
  _N
];
var Dae = Object.defineProperty, G9 = Object.getOwnPropertySymbols, Nae = Object.prototype.hasOwnProperty, Rae = Object.prototype.propertyIsEnumerable, Y9 = (n, e, t) => e in n ? Dae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Pae = (n, e) => {
  for (var t in e || (e = {}))
    Nae.call(e, t) && Y9(n, t, e[t]);
  if (G9)
    for (var t of G9(e))
      Rae.call(e, t) && Y9(n, t, e[t]);
  return n;
};
function LN(n, e) {
  return Object.assign(n, {
    meta: Pae({
      package: "@milkdown/components"
    }, e)
  }), n;
}
var _ae = Object.defineProperty, J9 = Object.getOwnPropertySymbols, Lae = Object.prototype.hasOwnProperty, Bae = Object.prototype.propertyIsEnumerable, X9 = (n, e, t) => e in n ? _ae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, zae = (n, e) => {
  for (var t in e || (e = {}))
    Lae.call(e, t) && X9(n, t, e[t]);
  if (J9)
    for (var t of J9(e))
      Bae.call(e, t) && X9(n, t, e[t]);
  return n;
};
const Fae = {
  renderButton: (n) => {
    switch (n) {
      case "add_row":
        return "+";
      case "add_col":
        return "+";
      case "delete_row":
        return "-";
      case "delete_col":
        return "-";
      case "align_col_left":
        return "left";
      case "align_col_center":
        return "center";
      case "align_col_right":
        return "right";
      case "col_drag_handle":
        return "=";
      case "row_drag_handle":
        return "=";
    }
  }
}, vg = Mt(
  zae({}, Fae),
  "tableBlockConfigCtx"
);
LN(vg, {
  displayName: "Config<table-block>",
  group: "TableBlock"
});
function es({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
es.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
function BN(n) {
  const {
    dragPreviewRef: e,
    tableWrapperRef: t,
    contentWrapperRef: r,
    yLineHandleRef: i,
    xLineHandleRef: s,
    colHandleRef: o,
    rowHandleRef: l
  } = n, a = e.value;
  if (!a) return;
  const c = t.value;
  if (!c) return;
  const u = r.value;
  if (!u) return;
  const h = u.querySelector("tbody");
  if (!h) return;
  const f = a.querySelector("tbody");
  if (!f) return;
  const d = i.value;
  if (!d) return;
  const p = s.value;
  if (!p) return;
  const m = o.value;
  if (!m) return;
  const g = l.value;
  return g ? {
    preview: a,
    wrapper: c,
    content: u,
    contentRoot: h,
    previewRoot: f,
    yHandle: d,
    xHandle: p,
    colHandle: m,
    rowHandle: g
  } : void 0;
}
function zN(n) {
  for (; n.firstChild; ) n.removeChild(n.firstChild);
}
function FN(n, e, t, r, i) {
  const { width: s, height: o } = r.querySelector("tbody").getBoundingClientRect();
  if (n === "y") {
    const a = r.querySelectorAll("tr")[i];
    if (!a) return;
    t.appendChild(a.cloneNode(!0));
    const c = a.getBoundingClientRect().height;
    Object.assign(e.style, {
      width: `${s}px`,
      height: `${c}px`
    }), e.dataset.show = "true";
    return;
  }
  if (n === "x") {
    const l = r.querySelectorAll("tr");
    let a;
    Array.from(l).forEach((c) => {
      const u = c.children[i];
      if (!u) return;
      a === void 0 && (a = u.getBoundingClientRect().width);
      const h = u.parentElement.cloneNode(!1), f = u.cloneNode(!0);
      h.appendChild(f), t.appendChild(h);
    }), Object.assign(e.style, {
      width: `${a}px`,
      height: `${o}px`
    }), e.dataset.show = "true";
    return;
  }
}
function Hae(n, e) {
  return (t) => {
    $N(n, t, e, (r) => {
      HN("y", t, r, n);
      const { preview: i, content: s, previewRoot: o } = r;
      zN(o);
      const { hoverIndex: l } = n, [a] = l.value;
      FN("y", i, o, s, a);
    });
  };
}
function $ae(n, e) {
  return (t) => {
    $N(n, t, e, (r) => {
      HN("x", t, r, n);
      const { preview: i, content: s, previewRoot: o } = r, { hoverIndex: l } = n, [a, c] = l.value;
      zN(o), FN("x", i, o, s, c);
    });
  };
}
function HN(n, e, t, r) {
  const { xHandle: i, yHandle: s, colHandle: o, rowHandle: l, preview: a } = t;
  i.dataset.displayType = n === "y" ? "indicator" : "none", s.dataset.displayType = n === "x" ? "indicator" : "none", n === "y" ? (o.dataset.show = "false", Z9(l)) : (l.dataset.show = "false", Z9(o));
  const { hoverIndex: c, dragInfo: u } = r, [h, f] = c.value;
  u.value = {
    startCoords: [e.clientX, e.clientY],
    startIndex: n === "y" ? h : f,
    endIndex: n === "y" ? h : f,
    type: n === "y" ? "row" : "col"
  }, a.dataset.direction = n === "y" ? "vertical" : "horizontal";
}
function $N(n, e, t, r) {
  const i = t?.get(Ct);
  if (!i?.editable) return;
  e.stopPropagation(), e.dataTransfer && (e.dataTransfer.effectAllowed = "move");
  const s = BN(n);
  s && requestAnimationFrame(() => {
    r(s);
  });
}
function Z9(n) {
  var e;
  (e = n.querySelector(".button-group")) == null || e.setAttribute("data-show", "false");
}
function B5(n, e) {
  for (let t = 0; t < n.childCount; t++)
    if (n.child(t) === e) return t;
  return -1;
}
function Vae(n, e) {
  var t, r, i;
  if (e)
    try {
      const s = e.posAtCoords({
        left: n.clientX,
        top: n.clientY
      });
      if (!s) return;
      const o = s?.inside;
      if (o == null || o < 0) return;
      const l = e.state.doc.resolve(o), a = e.state.doc.nodeAt(o);
      if (!a) return;
      const c = ["table_cell", "table_header"], u = ["table_row", "table_header_row"], h = c.includes(a.type.name) ? a : (t = gs((g) => c.includes(g.type.name))(l)) == null ? void 0 : t.node, f = (r = gs((g) => u.includes(g.type.name))(
        l
      )) == null ? void 0 : r.node, d = (i = gs((g) => g.type.name === "table")(l)) == null ? void 0 : i.node;
      if (!h || !f || !d) return;
      const p = B5(f, h);
      return [B5(d, f), p];
    } catch {
      return;
    }
}
function wg(n, [e, t]) {
  const r = n.value;
  if (!r) return;
  const i = r.querySelectorAll("tr"), s = i[e];
  if (!s) return;
  const o = i[0];
  if (!o) return;
  const l = o.children[t];
  if (!l) return;
  const a = s.children[t];
  if (a)
    return {
      row: s,
      col: a,
      headerCol: l
    };
}
function qae(n, e, t) {
  if (!t || !e) return;
  const { selection: r } = e.state;
  if (!(r instanceof Rt)) return;
  const { $from: i } = r, s = hu(i);
  if (!(!s || s.node !== t)) {
    if (r.isColSelection()) {
      const { $head: o } = r, l = o.index(o.depth - 1);
      T7({
        refs: n,
        index: [0, l],
        before: (a) => {
          var c;
          (c = a.querySelector(".button-group")) == null || c.setAttribute("data-show", "true");
        }
      });
      return;
    }
    if (r.isRowSelection()) {
      const { $head: o } = r, l = gs(
        (c) => c.type.name === "table_row" || c.type.name === "table_header_row"
      )(o);
      if (!l) return;
      const a = B5(s.node, l.node);
      A7({
        refs: n,
        index: [a, 0],
        before: (c) => {
          var u;
          a > 0 && ((u = c.querySelector(".button-group")) == null || u.setAttribute("data-show", "true"));
        }
      });
    }
  }
}
function T7({
  refs: n,
  index: e,
  before: t,
  after: r
}) {
  const { contentWrapperRef: i, colHandleRef: s, hoverIndex: o } = n, l = s.value;
  if (!l) return;
  o.value = e;
  const a = wg(i, e);
  if (!a) return;
  const { headerCol: c } = a;
  l.dataset.show = "true", t && t(l), $i(c, l, { placement: "top" }).then(({ x: u, y: h }) => {
    Object.assign(l.style, {
      left: `${u}px`,
      top: `${h}px`
    }), r && r(l);
  }).catch(console.error);
}
function A7({
  refs: n,
  index: e,
  before: t,
  after: r
}) {
  const { contentWrapperRef: i, rowHandleRef: s, hoverIndex: o } = n, l = s.value;
  if (!l) return;
  o.value = e;
  const a = wg(i, e);
  if (!a) return;
  const { row: c } = a;
  l.dataset.show = "true", t && t(l), $i(c, l, { placement: "left" }).then(({ x: u, y: h }) => {
    Object.assign(l.style, {
      left: `${u}px`,
      top: `${h}px`
    }), r && r(l);
  }).catch(console.error);
}
function VN(n, e, t) {
  const r = t === "x" ? "left" : "top", i = t === "x" ? "right" : "bottom", s = n.length - 1, o = n.findIndex((a, c) => {
    const u = a.getBoundingClientRect(), h = u[r], f = u[i];
    return h <= e && e <= f || c === s && e > f || c === 0 && e < h;
  }), l = n[o];
  return l ? [l, o] : void 0;
}
function Wae(n, e) {
  const t = n.querySelector("tr");
  if (!t) return;
  const r = Array.from(t.children);
  return VN(r, e, "x");
}
function jae(n, e) {
  const t = Array.from(n.querySelectorAll("tr"));
  return VN(t, e, "y");
}
function Uae(n) {
  return y1((e) => {
    const t = BN(n);
    if (!t) return;
    const { preview: r, content: i, contentRoot: s, xHandle: o, yHandle: l } = t, { dragInfo: a, hoverIndex: c } = n;
    if (r.dataset.show === "false") return;
    const u = wg(n.contentWrapperRef, c.value);
    if (!u || !s.querySelector("tr")) return;
    const f = a.value;
    if (!f || !s.offsetParent) return;
    const d = s.offsetParent.offsetTop, p = s.offsetParent.offsetLeft;
    if (f.type === "col") {
      const m = u.col.getBoundingClientRect().width, { left: g, width: b } = s.getBoundingClientRect(), w = p - g, k = e.clientX + w - m / 2, [C] = f.startCoords, M = C < e.clientX ? "right" : "left";
      r.style.top = `${d}px`;
      const T = k < g + w - 20 ? g + w - 20 : k > g + b + w - m + 20 ? g + b + w - m + 20 : k;
      r.style.left = `${T}px`;
      const N = Wae(s, e.clientX);
      if (N) {
        const [B, $] = N, R = l.getBoundingClientRect().width, V = i.getBoundingClientRect();
        f.endIndex = $, $i(B, l, {
          placement: M === "left" ? "left" : "right",
          middleware: [ml(M === "left" ? -1 * R : 0)]
        }).then(({ x: z }) => {
          l.dataset.show = "true", Object.assign(l.style, {
            height: `${V.height}px`,
            left: `${z}px`,
            top: `${d}px`
          });
        }).catch(console.error);
      }
    } else if (f.type === "row") {
      const m = u.row.getBoundingClientRect().height, { top: g, height: b } = s.getBoundingClientRect(), w = d - g, k = e.clientY + w - m / 2, [C, M] = f.startCoords, T = M < e.clientY ? "down" : "up", N = k < g + w - 20 ? g + w - 20 : k > g + b + w - m + 20 ? g + b + w - m + 20 : k;
      r.style.top = `${N}px`, r.style.left = `${p}px`;
      const B = jae(s, e.clientY);
      if (B) {
        const [$, R] = B, V = o.getBoundingClientRect().height, z = i.getBoundingClientRect();
        f.endIndex = R, $i($, o, {
          placement: T === "up" ? "top" : "bottom",
          middleware: [ml(T === "up" ? -1 * V : 0)]
        }).then(({ y: ue }) => {
          o.dataset.show = "true", Object.assign(o.style, {
            width: `${z.width}px`,
            top: `${ue}px`
          });
        }).catch(console.error);
      }
    }
  }, 20);
}
function Kae(n, e, t) {
  const { dragPreviewRef: r, yLineHandleRef: i, xLineHandleRef: s, dragInfo: o } = n, l = Hae(n, e), a = $ae(n, e), c = () => {
    const f = r.value;
    if (!f || f.dataset.show === "false") return;
    const d = f?.querySelector("tbody");
    for (; d?.firstChild; )
      d?.removeChild(d.firstChild);
    f && (f.dataset.show = "false");
  }, u = () => {
    var f;
    const d = r.value;
    if (!d) return;
    const p = i.value;
    if (!p) return;
    const m = s.value;
    if (!m) return;
    const g = o.value;
    if (!g || !e || d.dataset.show === "false" || !n.colHandleRef.value || !n.rowHandleRef.value || (p.dataset.show = "false", m.dataset.show = "false", g.startIndex === g.endIndex)) return;
    const k = e.get(Me), C = {
      from: g.startIndex,
      to: g.endIndex,
      pos: ((f = t?.()) != null ? f : 0) + 1
    };
    if (g.type === "col") {
      k.call(ra.key, {
        pos: C.pos,
        index: g.startIndex
      }), k.call(Iv.key, C);
      const M = [0, g.endIndex];
      T7({
        refs: n,
        index: M
      });
    } else {
      k.call(na.key, {
        pos: C.pos,
        index: g.startIndex
      }), k.call(Ev.key, C);
      const M = [g.endIndex, 0];
      A7({
        refs: n,
        index: M
      });
    }
    requestAnimationFrame(() => {
      e.get(Ct).focus();
    });
  }, h = Uae(n);
  return kd(() => {
    window.addEventListener("dragover", h), window.addEventListener("dragend", c), window.addEventListener("drop", u);
  }), Sd(() => {
    window.removeEventListener("dragover", h), window.removeEventListener("dragend", c), window.removeEventListener("drop", u);
  }), {
    dragRow: l,
    dragCol: a
  };
}
function Gae(n, e, t) {
  const {
    xLineHandleRef: r,
    contentWrapperRef: i,
    colHandleRef: s,
    rowHandleRef: o,
    hoverIndex: l,
    lineHoverIndex: a
  } = n;
  return {
    onAddRow: () => {
      var m, g, b;
      if (!e) return;
      const w = r.value;
      if (!w) return;
      const [k] = a.value;
      if (k < 0 || !e.get(Ct).editable) return;
      const C = Array.from(
        (g = (m = i.value) == null ? void 0 : m.querySelectorAll("tr")) != null ? g : []
      ), M = e.get(Me), T = ((b = t?.()) != null ? b : 0) + 1;
      C.length === k ? (M.call(na.key, { pos: T, index: k - 1 }), M.call(_v.key)) : (M.call(na.key, { pos: T, index: k }), M.call(Pv.key)), M.call(na.key, { pos: T, index: k }), w.dataset.show = "false";
    },
    onAddCol: () => {
      var m, g, b, w;
      if (!e || !r.value) return;
      const [C, M] = a.value;
      if (M < 0 || !e.get(Ct).editable) return;
      const T = Array.from(
        (b = (g = (m = i.value) == null ? void 0 : m.querySelector("tr")) == null ? void 0 : g.children) != null ? b : []
      ), N = e.get(Me), B = ((w = t?.()) != null ? w : 0) + 1;
      T.length === M ? (N.call(ra.key, { pos: B, index: M - 1 }), N.call(Rv.key)) : (N.call(ra.key, { pos: B, index: M }), N.call(Nv.key)), N.call(ra.key, { pos: B, index: M });
    },
    selectCol: () => {
      var m, g;
      if (!e) return;
      const [b, w] = l.value, k = e.get(Me), C = ((m = t?.()) != null ? m : 0) + 1;
      k.call(ra.key, { pos: C, index: w });
      const M = (g = s.value) == null ? void 0 : g.querySelector(".button-group");
      M && (M.dataset.show = M.dataset.show === "true" ? "false" : "true");
    },
    selectRow: () => {
      var m, g;
      if (!e) return;
      const [b, w] = l.value, k = e.get(Me), C = ((m = t?.()) != null ? m : 0) + 1;
      k.call(na.key, { pos: C, index: b });
      const M = (g = o.value) == null ? void 0 : g.querySelector(".button-group");
      M && b > 0 && (M.dataset.show = M.dataset.show === "true" ? "false" : "true");
    },
    deleteSelected: (m) => {
      if (!e || !e.get(Ct).editable) return;
      m.preventDefault(), m.stopPropagation(), e.get(Me).call(Dv.key), requestAnimationFrame(() => {
        e.get(Ct).focus();
      });
    },
    onAlign: (m) => (g) => {
      if (!e || !e.get(Ct).editable) return;
      g.preventDefault(), g.stopPropagation(), e.get(Me).call(Lv.key, m), requestAnimationFrame(() => {
        e.get(Ct).focus();
      });
    }
  };
}
function Yae(n, e) {
  return y1((t) => {
    if (!e?.editable) return;
    const {
      contentWrapperRef: r,
      yLineHandleRef: i,
      xLineHandleRef: s,
      colHandleRef: o,
      rowHandleRef: l,
      hoverIndex: a,
      lineHoverIndex: c
    } = n, u = i.value;
    if (!u) return;
    const h = s.value;
    if (!h) return;
    const f = r.value;
    if (!f) return;
    const d = l.value;
    if (!d) return;
    const p = o.value;
    if (!p) return;
    const m = Vae(t, e);
    if (!m) return;
    const g = wg(r, m);
    if (!g) return;
    const [b, w] = m, k = g.col.getBoundingClientRect(), C = Math.abs(t.clientX - k.left) < 8, M = Math.abs(k.right - t.clientX) < 8, T = Math.abs(t.clientY - k.top) < 8, N = Math.abs(k.bottom - t.clientY) < 8, B = C || M || T || N, $ = d.querySelector(".button-group"), R = p.querySelector(".button-group");
    if ($ && ($.dataset.show = "false"), R && (R.dataset.show = "false"), B) {
      const V = f.getBoundingClientRect();
      d.dataset.show = "false", p.dataset.show = "false", h.dataset.displayType = "tool", u.dataset.displayType = "tool";
      const z = u.getBoundingClientRect().width, ue = h.getBoundingClientRect().height;
      C || M ? (c.value[1] = C ? w : w + 1, $i(g.col, u, {
        placement: C ? "left" : "right",
        middleware: [ml(C ? -1 * z : 0)]
      }).then(({ x: ie }) => {
        u.dataset.show = "true", Object.assign(u.style, {
          height: `${V.height}px`,
          left: `${ie}px`
        });
      }).catch(console.error)) : u.dataset.show = "false", m[0] !== 0 && (T || N) ? (c.value[0] = T ? b : b + 1, $i(g.row, h, {
        placement: T ? "top" : "bottom",
        middleware: [ml(T ? -1 * ue : 0)]
      }).then(({ y: ie }) => {
        h.dataset.show = "true", Object.assign(h.style, {
          width: `${V.width}px`,
          top: `${ie}px`
        });
      }).catch(console.error)) : h.dataset.show = "false";
      return;
    }
    c.value = [-1, -1], u.dataset.show = "false", h.dataset.show = "false", d.dataset.show = "true", p.dataset.show = "true", A7({
      refs: n,
      index: m
    }), T7({
      refs: n,
      index: m
    }), a.value = m;
  }, 20);
}
function Jae(n) {
  return () => {
    const { rowHandleRef: e, colHandleRef: t, yLineHandleRef: r, xLineHandleRef: i } = n;
    setTimeout(() => {
      const s = e.value;
      if (!s) return;
      const o = t.value;
      if (!o) return;
      const l = r.value;
      if (!l) return;
      const a = i.value;
      a && (s.dataset.show = "false", o.dataset.show = "false", l.dataset.show = "false", a.dataset.show = "false");
    }, 200);
  };
}
function Xae(n, e) {
  const t = Yae(n, e), r = Jae(n);
  return {
    pointerMove: t,
    pointerLeave: r
  };
}
const Zae = /* @__PURE__ */ $n({
  props: {
    view: {
      type: Object,
      required: !0
    },
    ctx: {
      type: Object,
      required: !0
    },
    getPos: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    onMount: {
      type: Function,
      required: !0
    },
    node: {
      type: Object,
      required: !0
    }
  },
  setup({ view: n, node: e, ctx: t, getPos: r, config: i, onMount: s }) {
    const o = Ae(), l = (z) => {
      z != null && (z instanceof HTMLElement ? (o.value = z, s(z)) : o.value = void 0);
    }, a = Ae(), c = Ae(), u = Ae(), h = Ae(), f = Ae(), d = Ae(), p = Ae([0, 0]), m = Ae([-1, -1]), g = Ae(), b = {
      dragPreviewRef: d,
      tableWrapperRef: f,
      contentWrapperRef: o,
      yLineHandleRef: h,
      xLineHandleRef: u,
      colHandleRef: a,
      rowHandleRef: c,
      hoverIndex: p,
      lineHoverIndex: m,
      dragInfo: g
    }, { pointerLeave: w, pointerMove: k } = Xae(b, n), { dragRow: C, dragCol: M } = Kae(b, t, r), {
      onAddRow: T,
      onAddCol: N,
      selectCol: B,
      selectRow: $,
      deleteSelected: R,
      onAlign: V
    } = Gae(b, t, r);
    return kd(() => {
      requestAnimationFrame(() => {
        n.editable && qae(b, n, e.value);
      });
    }), () => /* @__PURE__ */ j(
      "div",
      {
        onDragstart: (z) => z.preventDefault(),
        onDragover: (z) => z.preventDefault(),
        onDragleave: (z) => z.preventDefault(),
        onPointermove: k,
        onPointerleave: w
      },
      /* @__PURE__ */ j(
        "button",
        {
          type: "button",
          "data-show": "false",
          contenteditable: "false",
          draggable: "true",
          "data-role": "col-drag-handle",
          class: "handle cell-handle",
          onDragstart: M,
          onClick: B,
          onPointerdown: (z) => z.stopPropagation(),
          onPointermove: (z) => z.stopPropagation(),
          ref: a
        },
        /* @__PURE__ */ j(es, { icon: i.renderButton("col_drag_handle") }),
        /* @__PURE__ */ j(
          "div",
          {
            "data-show": "false",
            class: "button-group",
            onPointermove: (z) => z.stopPropagation()
          },
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: V("left") }, /* @__PURE__ */ j(es, { icon: i.renderButton("align_col_left") })),
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: V("center") }, /* @__PURE__ */ j(es, { icon: i.renderButton("align_col_center") })),
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: V("right") }, /* @__PURE__ */ j(es, { icon: i.renderButton("align_col_right") })),
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: R }, /* @__PURE__ */ j(es, { icon: i.renderButton("delete_col") }))
        )
      ),
      /* @__PURE__ */ j(
        "button",
        {
          type: "button",
          "data-show": "false",
          contenteditable: "false",
          draggable: "true",
          "data-role": "row-drag-handle",
          class: "handle cell-handle",
          onDragstart: C,
          onClick: $,
          onPointerdown: (z) => z.stopPropagation(),
          onPointermove: (z) => z.stopPropagation(),
          ref: c
        },
        /* @__PURE__ */ j(es, { icon: i.renderButton("row_drag_handle") }),
        /* @__PURE__ */ j(
          "div",
          {
            "data-show": "false",
            class: "button-group",
            onPointermove: (z) => z.stopPropagation()
          },
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: R }, /* @__PURE__ */ j(es, { icon: i.renderButton("delete_row") }))
        )
      ),
      /* @__PURE__ */ j("div", { class: "table-wrapper", ref: f }, /* @__PURE__ */ j(
        "div",
        {
          "data-show": "false",
          class: "drag-preview",
          "data-direction": "vertical",
          ref: d
        },
        /* @__PURE__ */ j("table", null, /* @__PURE__ */ j("tbody", null))
      ), /* @__PURE__ */ j(
        "div",
        {
          "data-show": "false",
          contenteditable: "false",
          "data-display-type": "tool",
          "data-role": "x-line-drag-handle",
          class: "handle line-handle",
          onPointermove: (z) => z.stopPropagation(),
          ref: u
        },
        /* @__PURE__ */ j("button", { type: "button", onClick: T, class: "add-button" }, /* @__PURE__ */ j(es, { icon: i.renderButton("add_row") }))
      ), /* @__PURE__ */ j(
        "div",
        {
          "data-show": "false",
          contenteditable: "false",
          "data-display-type": "tool",
          "data-role": "y-line-drag-handle",
          class: "handle line-handle",
          onPointermove: (z) => z.stopPropagation(),
          ref: h
        },
        /* @__PURE__ */ j("button", { type: "button", onClick: N, class: "add-button" }, /* @__PURE__ */ j(es, { icon: i.renderButton("add_col") }))
      ), /* @__PURE__ */ j("table", { ref: l, class: "children" }))
    );
  }
});
var qN = (n) => {
  throw TypeError(n);
}, Qae = (n, e, t) => e.has(n) || qN("Cannot " + t), ece = (n, e, t) => e.has(n) ? qN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), tce = (n, e, t) => (Qae(n, e, "access private method"), t), z5, WN;
class nce {
  constructor(e, t, r, i) {
    this.ctx = e, this.node = t, this.view = r, this.getPos = i, ece(this, z5);
    const s = document.createElement("div");
    s.className = "milkdown-table-block";
    const o = document.createElement("tbody");
    this.contentDOM = o, o.setAttribute("data-content-dom", "true"), o.classList.add("content-dom"), this.nodeRef = Am(t);
    const l = ji(Zae, {
      view: r,
      ctx: e,
      getPos: i,
      config: e.get(vg.key),
      onMount: (a) => {
        a.appendChild(o);
      },
      node: this.nodeRef
    });
    l.mount(s), this.app = l, this.dom = s;
  }
  update(e) {
    return e.type !== this.node.type || e.sameMarkup(this.node) && e.content.eq(this.node.content) ? !1 : (this.node = e, this.nodeRef.value = e, !0);
  }
  stopEvent(e) {
    if (e.type === "drop" || e.type.startsWith("drag")) return !0;
    if (e.type === "mousedown" || e.type === "pointerdown") {
      if (e.target instanceof Element && e.target.closest("button")) return !0;
      const t = e.target;
      if (t instanceof HTMLElement && (t.closest("th") || t.closest("td"))) {
        const r = e;
        return tce(this, z5, WN).call(this, r);
      }
    }
    return !1;
  }
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : e.type === "selection" ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  destroy() {
    this.app.unmount(), this.dom.remove(), this.contentDOM.remove();
  }
}
z5 = /* @__PURE__ */ new WeakSet();
WN = function(n) {
  const e = this.view;
  if (!e.editable) return !1;
  const { state: t, dispatch: r } = e, i = e.posAtCoords({ left: n.clientX, top: n.clientY });
  if (!i) return !1;
  const s = t.doc.resolve(i.inside), o = gs(
    (c) => c.type.name === "table_cell" || c.type.name === "table_header"
  )(s);
  if (!o) return !1;
  if (t.selection instanceof Ee) {
    const c = gs(
      (u) => u.type.name === "table_cell" || u.type.name === "table_header"
    )(t.selection.$from);
    if (c?.node === o.node) return !1;
  }
  const { from: l } = o, a = $e.create(t.doc, l + 1);
  return t.selection.eq(a) ? !1 : (t.selection instanceof Rt ? setTimeout(() => {
    r(t.tr.setSelection(a).scrollIntoView());
  }, 20) : requestAnimationFrame(() => {
    r(t.tr.setSelection(a).scrollIntoView());
  }), !0);
};
const jN = yd(
  Ha.node,
  (n) => (e, t, r) => new nce(n, e, t, r)
);
LN(jN, {
  displayName: "NodeView<table-block>",
  group: "TableBlock"
});
const rce = [vg, jN];
function F5(n) {
  if (!n) return !1;
  if (Array.isArray(n))
    return n.length > 1 ? !1 : F5(n[0]);
  const e = n.content;
  return e ? F5(e) : n.type === "text";
}
const UN = kn((n) => {
  const e = n.get(gi);
  n.update(Yh, (i) => ({
    ...i,
    editable: i.editable ?? (() => !0)
  }));
  const t = new en("MILKDOWN_CLIPBOARD");
  return new Ut({
    key: t,
    props: {
      handlePaste: (i, s) => {
        const o = n.get(ha), l = i.props.editable?.(i.state), { clipboardData: a } = s;
        if (!l || !a || i.state.selection.$from.node().type.spec.code) return !1;
        const u = a.getData("text/plain"), h = a.getData("vscode-editor-data");
        if (h) {
          const w = JSON.parse(h)?.mode;
          if (u && w) {
            const { tr: k } = i.state, C = Zz("code_block", e);
            return k.replaceSelectionWith(C.create({ language: w })).setSelection(
              Ee.near(
                k.doc.resolve(Math.max(0, k.selection.from - 2))
              )
            ).insertText(u.replace(/\r\n?/g, `
`)), i.dispatch(k), !0;
          }
        }
        const f = a.getData("text/html");
        if (f.length === 0 && u.length === 0) return !1;
        const d = ll.fromSchema(e);
        let p;
        if (f.length === 0) {
          const b = o(u);
          if (!b || typeof b == "string") return !1;
          p = wl.fromSchema(e).serializeFragment(
            b.content
          );
        } else {
          const b = document.createElement("template");
          b.innerHTML = f, p = b.content.cloneNode(!0), b.remove();
        }
        const m = d.parseSlice(p), g = PC(m);
        return g ? (i.dispatch(i.state.tr.replaceSelectionWith(g, !0)), !0) : (i.dispatch(i.state.tr.replaceSelection(m)), !0);
      },
      clipboardTextSerializer: (i) => {
        const s = n.get(yc);
        if (F5(i.content.toJSON()))
          return i.content.textBetween(
            0,
            i.content.size,
            `

`
          );
        const l = e.topNodeType.createAndFill(void 0, i.content);
        return l ? s(l) : "";
      }
    }
  });
});
UN.meta = {
  displayName: "Prose<clipboard>",
  package: "@milkdown/plugin-clipboard"
};
function yu(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-history",
      ...e
    }
  }), n;
}
const O7 = Ye("Undo", () => () => ig);
yu(O7, {
  displayName: "Command<undo>"
});
const E7 = Ye("Redo", () => () => jc);
yu(E7, {
  displayName: "Command<redo>"
});
const I7 = Mt({}, "historyProviderConfig");
yu(I7, {
  displayName: "Ctx<historyProviderConfig>"
});
const KN = kn(
  (n) => cre(n.get(I7.key))
);
yu(KN, {
  displayName: "Ctx<historyProviderPlugin>"
});
const D7 = Pr("historyKeymap", {
  Undo: {
    shortcuts: "Mod-z",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(O7.key);
    }
  },
  Redo: {
    shortcuts: ["Mod-y", "Shift-Mod-z"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(E7.key);
    }
  }
});
yu(D7.ctx, {
  displayName: "KeymapCtx<history>"
});
yu(D7.shortcuts, {
  displayName: "Keymap<history>"
});
const ice = [
  I7,
  KN,
  D7,
  O7,
  E7
].flat();
function sce(n, e) {
  const { doc: t, selection: r } = n;
  if (!t || !r || !(r instanceof Ee || r instanceof Er))
    return n;
  const { to: i } = r, s = e.type === "space" ? Array(e.size).fill(" ").join("") : "	";
  return n.insertText(s, i);
}
const xg = Mt(
  { type: "space", size: 2 },
  "indentConfig"
);
xg.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Ctx<indentConfig>"
};
const GN = ZA((n) => ({
  Tab: (e, t) => {
    const r = n.get(xg.key), { tr: i } = e, s = sce(i, r);
    return s.docChanged ? (t?.(s), !0) : !1;
  }
}));
GN.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Shortcut<indent>"
};
const oce = [xg, GN];
class YN {
  constructor() {
    this.beforeMountedListeners = [], this.mountedListeners = [], this.updatedListeners = [], this.selectionUpdatedListeners = [], this.markdownUpdatedListeners = [], this.blurListeners = [], this.focusListeners = [], this.destroyListeners = [], this.beforeMount = (e) => (this.beforeMountedListeners.push(e), this), this.mounted = (e) => (this.mountedListeners.push(e), this), this.updated = (e) => (this.updatedListeners.push(e), this);
  }
  /// A getter to get all [subscribers](#interface-subscribers). You should not use this method directly.
  get listeners() {
    return {
      beforeMount: this.beforeMountedListeners,
      mounted: this.mountedListeners,
      updated: this.updatedListeners,
      markdownUpdated: this.markdownUpdatedListeners,
      blur: this.blurListeners,
      focus: this.focusListeners,
      destroy: this.destroyListeners,
      selectionUpdated: this.selectionUpdatedListeners
    };
  }
  /// Subscribe to the markdownUpdated event.
  /// This event will be triggered after the editor state is updated and **the document is changed**.
  /// The second parameter is the current markdown and the third parameter is the previous markdown.
  markdownUpdated(e) {
    return this.markdownUpdatedListeners.push(e), this;
  }
  /// Subscribe to the blur event.
  /// This event will be triggered when the editor is blurred.
  blur(e) {
    return this.blurListeners.push(e), this;
  }
  /// Subscribe to the focus event.
  /// This event will be triggered when the editor is focused.
  focus(e) {
    return this.focusListeners.push(e), this;
  }
  /// Subscribe to the destroy event.
  /// This event will be triggered before the editor is destroyed.
  destroy(e) {
    return this.destroyListeners.push(e), this;
  }
  /// Subscribe to the selectionUpdated event.
  /// This event will be triggered when the editor selection is updated.
  selectionUpdated(e) {
    return this.selectionUpdatedListeners.push(e), this;
  }
}
const Ym = at(
  new YN(),
  "listener"
), lce = new en("MILKDOWN_LISTENER"), JN = (n) => (n.inject(Ym, new YN()), async () => {
  await n.wait(ua);
  const e = n.get(Ym), { listeners: t } = e;
  t.beforeMount.forEach((a) => a(n)), await n.wait(Gh);
  const r = n.get(yc);
  let i = null, s = null, o = null;
  const l = new Ut({
    key: lce,
    view: () => ({
      destroy: () => {
        t.destroy.forEach((a) => a(n));
      }
    }),
    props: {
      handleDOMEvents: {
        focus: () => (t.focus.forEach((a) => a(n)), !1),
        blur: () => (t.blur.forEach((a) => a(n)), !1)
      }
    },
    state: {
      init: (a, c) => {
        i = c.doc, s = r(c.doc);
      },
      apply: (a) => {
        const c = a.selection;
        return (!o && c || o && !c.eq(o)) && (t.selectionUpdated.forEach((h) => {
          h(n, c, o);
        }), o = c), !a.docChanged || a.getMeta("addToHistory") === !1 ? void 0 : g1(() => {
          const { doc: h } = a;
          if (t.updated.length > 0 && i && !i.eq(h) && t.updated.forEach((f) => {
            f(n, h, i);
          }), t.markdownUpdated.length > 0 && i && !i.eq(h)) {
            const f = r(h);
            t.markdownUpdated.forEach((d) => {
              d(n, f, s);
            }), s = f;
          }
          i = h;
        }, 200)();
      }
    }
  });
  n.update(lo, (a) => a.concat(l)), await n.wait(op), t.mounted.forEach((a) => a(n));
});
JN.meta = {
  package: "@milkdown/plugin-listener",
  displayName: "Listener"
};
const N7 = Mt(
  {
    shouldAppend: (n) => !(!n || ["heading", "paragraph"].includes(n.type.name)),
    getNode: (n) => n.schema.nodes.paragraph.create()
  },
  "trailingConfig"
);
N7.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Ctx<trailingConfig>"
};
const XN = kn((n) => {
  const e = new en("MILKDOWN_TRAILING"), { shouldAppend: t, getNode: r } = n.get(N7.key), i = new Ut({
    key: e,
    state: {
      init: (s, o) => {
        const l = o.tr.doc.lastChild;
        return t(l, o);
      },
      apply: (s, o, l, a) => {
        if (!s.docChanged) return o;
        const c = s.doc.lastChild;
        return t(c, a);
      }
    },
    appendTransaction: (s, o, l) => {
      const { doc: a, tr: c } = l, u = r?.(l), h = i.getState(l), f = a.content.size;
      if (!(!h || !u))
        return c.insert(f, u);
    }
  });
  return i;
});
XN.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Prose<trailing>"
};
const ace = [N7, XN];
var St = /* @__PURE__ */ ((n) => (n.CodeMirror = "code-mirror", n.ListItem = "list-item", n.LinkTooltip = "link-tooltip", n.Cursor = "cursor", n.ImageBlock = "image-block", n.BlockEdit = "block-edit", n.Toolbar = "toolbar", n.Placeholder = "placeholder", n.Table = "table", n.Latex = "latex", n))(St || {});
const cce = {
  cursor: !0,
  "list-item": !0,
  "link-tooltip": !0,
  "image-block": !0,
  "block-edit": !0,
  placeholder: !0,
  toolbar: !0,
  "code-mirror": !0,
  table: !0,
  latex: !0
}, uce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25ZM8.25 16.625C8.0375 16.625 7.85942 16.5531 7.71575 16.4093C7.57192 16.2654 7.5 16.0872 7.5 15.8748C7.5 15.6621 7.57192 15.484 7.71575 15.3405C7.85942 15.1968 8.0375 15.125 8.25 15.125H15.75C15.9625 15.125 16.1406 15.1969 16.2843 15.3408C16.4281 15.4846 16.5 15.6628 16.5 15.8753C16.5 16.0879 16.4281 16.266 16.2843 16.4095C16.1406 16.5532 15.9625 16.625 15.75 16.625H8.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM8.25 8.875C8.0375 8.875 7.85942 8.80308 7.71575 8.65925C7.57192 8.51542 7.5 8.33725 7.5 8.12475C7.5 7.91208 7.57192 7.734 7.71575 7.5905C7.85942 7.44683 8.0375 7.375 8.25 7.375H15.75C15.9625 7.375 16.1406 7.44692 16.2843 7.59075C16.4281 7.73458 16.5 7.91275 16.5 8.12525C16.5 8.33792 16.4281 8.516 16.2843 8.6595C16.1406 8.80317 15.9625 8.875 15.75 8.875H8.25ZM4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25Z"
    />
  </svg>
`, hce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25ZM4.25 16.625C4.0375 16.625 3.85942 16.5531 3.71575 16.4093C3.57192 16.2654 3.5 16.0872 3.5 15.8748C3.5 15.6621 3.57192 15.484 3.71575 15.3405C3.85942 15.1968 4.0375 15.125 4.25 15.125H13.75C13.9625 15.125 14.1406 15.1969 14.2843 15.3408C14.4281 15.4846 14.5 15.6628 14.5 15.8753C14.5 16.0879 14.4281 16.266 14.2843 16.4095C14.1406 16.5532 13.9625 16.625 13.75 16.625H4.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM4.25 8.875C4.0375 8.875 3.85942 8.80308 3.71575 8.65925C3.57192 8.51542 3.5 8.33725 3.5 8.12475C3.5 7.91208 3.57192 7.734 3.71575 7.5905C3.85942 7.44683 4.0375 7.375 4.25 7.375H13.75C13.9625 7.375 14.1406 7.44692 14.2843 7.59075C14.4281 7.73458 14.5 7.91275 14.5 8.12525C14.5 8.33792 14.4281 8.516 14.2843 8.6595C14.1406 8.80317 13.9625 8.875 13.75 8.875H4.25ZM4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25Z"
    />
  </svg>
`, fce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25ZM10.25 8.875C10.0375 8.875 9.85942 8.80308 9.71575 8.65925C9.57192 8.51542 9.5 8.33725 9.5 8.12475C9.5 7.91208 9.57192 7.734 9.71575 7.5905C9.85942 7.44683 10.0375 7.375 10.25 7.375H19.75C19.9625 7.375 20.1406 7.44692 20.2843 7.59075C20.4281 7.73458 20.5 7.91275 20.5 8.12525C20.5 8.33792 20.4281 8.516 20.2843 8.6595C20.1406 8.80317 19.9625 8.875 19.75 8.875H10.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM10.25 16.625C10.0375 16.625 9.85942 16.5531 9.71575 16.4093C9.57192 16.2654 9.5 16.0872 9.5 15.8748C9.5 15.6621 9.57192 15.484 9.71575 15.3405C9.85942 15.1968 10.0375 15.125 10.25 15.125H19.75C19.9625 15.125 20.1406 15.1969 20.2843 15.3408C20.4281 15.4846 20.5 15.6628 20.5 15.8753C20.5 16.0879 20.4281 16.266 20.2843 16.4095C20.1406 16.5532 19.9625 16.625 19.75 16.625H10.25ZM4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25Z"
    />
  </svg>
`, dce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M8.85758 18.625C8.4358 18.625 8.07715 18.4772 7.78163 18.1817C7.48613 17.8862 7.33838 17.5275 7.33838 17.1058V6.8942C7.33838 6.47242 7.48613 6.11377 7.78163 5.81825C8.07715 5.52275 8.4358 5.375 8.85758 5.375H12.1999C13.2191 5.375 14.1406 5.69231 14.9643 6.32693C15.788 6.96154 16.1999 7.81603 16.1999 8.89038C16.1999 9.63779 16.0194 10.2471 15.6585 10.7183C15.2976 11.1894 14.9088 11.5314 14.4922 11.7442C15.005 11.9211 15.4947 12.2708 15.9614 12.7933C16.428 13.3157 16.6614 14.0192 16.6614 14.9038C16.6614 16.182 16.1902 17.1217 15.2479 17.723C14.3056 18.3243 13.3563 18.625 12.3999 18.625H8.85758ZM9.4883 16.6327H12.3191C13.1063 16.6327 13.6627 16.4141 13.9884 15.9769C14.314 15.5397 14.4768 15.1205 14.4768 14.7192C14.4768 14.3179 14.314 13.8987 13.9884 13.4615C13.6627 13.0243 13.0909 12.8057 12.273 12.8057H9.4883V16.6327ZM9.4883 10.875H12.0826C12.6903 10.875 13.172 10.7013 13.5278 10.3539C13.8836 10.0064 14.0615 9.59037 14.0615 9.10575C14.0615 8.59035 13.8733 8.16918 13.497 7.84225C13.1207 7.51533 12.6595 7.35188 12.1133 7.35188H9.4883V10.875Z"
    />
  </svg>
`, pce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_952_6527)">
      <circle cx="12" cy="12" r="3" />
    </g>
    <defs>
      <clipPath id="clip0_952_6527">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, mce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8070)">
      <path
        d="M4 10.5C3.17 10.5 2.5 11.17 2.5 12C2.5 12.83 3.17 13.5 4 13.5C4.83 13.5 5.5 12.83 5.5 12C5.5 11.17 4.83 10.5 4 10.5ZM4 4.5C3.17 4.5 2.5 5.17 2.5 6C2.5 6.83 3.17 7.5 4 7.5C4.83 7.5 5.5 6.83 5.5 6C5.5 5.17 4.83 4.5 4 4.5ZM4 16.5C3.17 16.5 2.5 17.18 2.5 18C2.5 18.82 3.18 19.5 4 19.5C4.82 19.5 5.5 18.82 5.5 18C5.5 17.18 4.83 16.5 4 16.5ZM8 19H20C20.55 19 21 18.55 21 18C21 17.45 20.55 17 20 17H8C7.45 17 7 17.45 7 18C7 18.55 7.45 19 8 19ZM8 13H20C20.55 13 21 12.55 21 12C21 11.45 20.55 11 20 11H8C7.45 11 7 11.45 7 12C7 12.55 7.45 13 8 13ZM7 6C7 6.55 7.45 7 8 7H20C20.55 7 21 6.55 21 6C21 5.45 20.55 5 20 5H8C7.45 5 7 5.45 7 6Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8070">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, gce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 24 24"
  >
    <path
      fill="currentColor"
      d="M9 22a1 1 0 0 1-1-1v-3H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6.1l-3.7 3.71c-.2.19-.45.29-.7.29zm1-6v3.08L13.08 16H20V4H4v12z"
    />
  </svg>
`, yce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1803_1151)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM10.71 16.29C10.32 16.68 9.69 16.68 9.3 16.29L5.71 12.7C5.32 12.31 5.32 11.68 5.71 11.29C6.1 10.9 6.73 10.9 7.12 11.29L10 14.17L16.88 7.29C17.27 6.9 17.9 6.9 18.29 7.29C18.68 7.68 18.68 8.31 18.29 8.7L10.71 16.29Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1803_1151">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, bce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1803_535)">
      <path
        d="M18 19H6C5.45 19 5 18.55 5 18V6C5 5.45 5.45 5 6 5H18C18.55 5 19 5.45 19 6V18C19 18.55 18.55 19 18 19ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1803_535">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, ZN = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M19.5 8.25l-7.5 7.5-7.5-7.5"
    />
  </svg>
`, QN = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1098_15553)">
      <path
        d="M18.3007 5.70973C17.9107 5.31973 17.2807 5.31973 16.8907 5.70973L12.0007 10.5897L7.1107 5.69973C6.7207 5.30973 6.0907 5.30973 5.7007 5.69973C5.3107 6.08973 5.3107 6.71973 5.7007 7.10973L10.5907 11.9997L5.7007 16.8897C5.3107 17.2797 5.3107 17.9097 5.7007 18.2997C6.0907 18.6897 6.7207 18.6897 7.1107 18.2997L12.0007 13.4097L16.8907 18.2997C17.2807 18.6897 17.9107 18.6897 18.3007 18.2997C18.6907 17.9097 18.6907 17.2797 18.3007 16.8897L13.4107 11.9997L18.3007 7.10973C18.6807 6.72973 18.6807 6.08973 18.3007 5.70973Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1098_15553">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, eR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8081)">
      <path
        d="M9.4 16.6L4.8 12L9.4 7.4L8 6L2 12L8 18L9.4 16.6ZM14.6 16.6L19.2 12L14.6 7.4L16 6L22 12L16 18L14.6 16.6Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8081">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, R7 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
  >
    <g clip-path="url(#clip0_1013_1606)">
      <path
        d="M9.00012 16.1998L5.50012 12.6998C5.11012 12.3098 4.49012 12.3098 4.10012 12.6998C3.71012 13.0898 3.71012 13.7098 4.10012 14.0998L8.29012 18.2898C8.68012 18.6798 9.31012 18.6798 9.70012 18.2898L20.3001 7.69982C20.6901 7.30982 20.6901 6.68982 20.3001 6.29982C19.9101 5.90982 19.2901 5.90982 18.9001 6.29982L9.00012 16.1998Z"
        fill="#817567"
      />
    </g>
    <defs>
      <clipPath id="clip0_1013_1606">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, tR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    height="24px"
    viewBox="0 -960 960 960"
    width="24px"
    fill="none"
  >
    <path
      d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z"
    />
  </svg>
`, vce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7900)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M19 13H5C4.45 13 4 12.55 4 12C4 11.45 4.45 11 5 11H19C19.55 11 20 11.45 20 12C20 12.55 19.55 13 19 13Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7900">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Q9 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="16"
    height="16"
    viewBox="0 0 16 16"
  >
    <path
      d="M3.5 9.83366C3.35833 9.83366 3.23961 9.78571 3.14383 9.68983C3.04794 9.59394 3 9.47516 3 9.33349C3 9.19171 3.04794 9.07299 3.14383 8.97733C3.23961 8.88155 3.35833 8.83366 3.5 8.83366H12.5C12.6417 8.83366 12.7604 8.8816 12.8562 8.97749C12.9521 9.07338 13 9.19216 13 9.33383C13 9.4756 12.9521 9.59433 12.8562 9.68999C12.7604 9.78577 12.6417 9.83366 12.5 9.83366H3.5ZM3.5 7.16699C3.35833 7.16699 3.23961 7.11905 3.14383 7.02316C3.04794 6.92727 3 6.80849 3 6.66683C3 6.52505 3.04794 6.40633 3.14383 6.31066C3.23961 6.21488 3.35833 6.16699 3.5 6.16699H12.5C12.6417 6.16699 12.7604 6.21494 12.8562 6.31083C12.9521 6.40671 13 6.52549 13 6.66716C13 6.80894 12.9521 6.92766 12.8562 7.02333C12.7604 7.1191 12.6417 7.16699 12.5 7.16699H3.5Z"
    />
  </svg>
`, P7 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1013_1585)">
      <path
        d="M14.06 9.02L14.98 9.94L5.92 19H5V18.08L14.06 9.02ZM17.66 3C17.41 3 17.15 3.1 16.96 3.29L15.13 5.12L18.88 8.87L20.71 7.04C21.1 6.65 21.1 6.02 20.71 5.63L18.37 3.29C18.17 3.09 17.92 3 17.66 3ZM14.06 6.19L3 17.25V21H6.75L17.81 9.94L14.06 6.19Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1013_1585">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, wce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5553)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM12 17H14V7H10V9H12V17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5553">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, xce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5559)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15H11V13H13C14.1 13 15 12.11 15 11V9C15 7.89 14.1 7 13 7H9V9H13V11H11C9.9 11 9 11.89 9 13V17H15V15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5559">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, kce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5565)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15V13.5C15 12.67 14.33 12 13.5 12C14.33 12 15 11.33 15 10.5V9C15 7.89 14.1 7 13 7H9V9H13V11H11V13H13V15H9V17H13C14.1 17 15 16.11 15 15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5565">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Sce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7757)">
      <path
        d="M19.04 3H5.04004C3.94004 3 3.04004 3.9 3.04004 5V19C3.04004 20.1 3.94004 21 5.04004 21H19.04C20.14 21 21.04 20.1 21.04 19V5C21.04 3.9 20.14 3 19.04 3ZM19.04 19H5.04004V5H19.04V19ZM13.04 17H15.04V7H13.04V11H11.04V7H9.04004V13H13.04V17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7757">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Cce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7760)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15V13C15 11.89 14.1 11 13 11H11V9H15V7H9V13H13V15H9V17H13C14.1 17 15 16.11 15 15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7760">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Mce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7763)">
      <path
        d="M11 17H13C14.1 17 15 16.11 15 15V13C15 11.89 14.1 11 13 11H11V9H15V7H11C9.9 7 9 7.89 9 9V15C9 16.11 9.9 17 11 17ZM11 13H13V15H11V13ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7763">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, H5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8075)">
      <path
        d="M19 5V19H5V5H19ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM14.14 11.86L11.14 15.73L9 13.14L6 17H18L14.14 11.86Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8075">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Tce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M6.29811 18.625C6.04505 18.625 5.83115 18.5375 5.65641 18.3626C5.48166 18.1877 5.39429 17.9736 5.39429 17.7203C5.39429 17.467 5.48166 17.2532 5.65641 17.0788C5.83115 16.9045 6.04505 16.8173 6.29811 16.8173H9.21159L12.452 7.18265H9.53851C9.28545 7.18265 9.07155 7.0952 8.89681 6.9203C8.72206 6.7454 8.63469 6.5313 8.63469 6.278C8.63469 6.02472 8.72206 5.81089 8.89681 5.63652C9.07155 5.46217 9.28545 5.375 9.53851 5.375H16.8847C17.1377 5.375 17.3516 5.46245 17.5264 5.63735C17.7011 5.81225 17.7885 6.02634 17.7885 6.27962C17.7885 6.53293 17.7011 6.74676 17.5264 6.92113C17.3516 7.09548 17.1377 7.18265 16.8847 7.18265H14.2789L11.0385 16.8173H13.6443C13.8973 16.8173 14.1112 16.9048 14.286 17.0797C14.4607 17.2546 14.5481 17.4687 14.5481 17.722C14.5481 17.9752 14.4607 18.1891 14.286 18.3634C14.1112 18.5378 13.8973 18.625 13.6443 18.625H6.29811Z"
    />
  </svg>
`, Ace = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M17.0385 19.5003V16.5388H14.0769V15.0388H17.0385V12.0773H18.5384V15.0388H21.5V16.5388H18.5384V19.5003H17.0385ZM10.8077 16.5388H7.03845C5.78282 16.5388 4.7125 16.0963 3.8275 15.2114C2.9425 14.3266 2.5 13.2564 2.5 12.0009C2.5 10.7454 2.9425 9.67504 3.8275 8.78979C4.7125 7.90454 5.78282 7.46191 7.03845 7.46191H10.8077V8.96186H7.03845C6.1987 8.96186 5.48235 9.25834 4.8894 9.85129C4.29645 10.4442 3.99998 11.1606 3.99998 12.0003C3.99998 12.8401 4.29645 13.5564 4.8894 14.1494C5.48235 14.7423 6.1987 15.0388 7.03845 15.0388H10.8077V16.5388ZM8.25 12.7503V11.2504H15.75V12.7503H8.25ZM21.5 12.0003H20C20 11.1606 19.7035 10.4442 19.1106 9.85129C18.5176 9.25834 17.8013 8.96186 16.9615 8.96186H13.1923V7.46191H16.9615C18.2171 7.46191 19.2875 7.90441 20.1725 8.78939C21.0575 9.67439 21.5 10.7447 21.5 12.0003Z"
    />
  </svg>
`, Oce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_971_7680)">
      <path
        d="M11 18C11 19.1 10.1 20 9 20C7.9 20 7 19.1 7 18C7 16.9 7.9 16 9 16C10.1 16 11 16.9 11 18ZM9 10C7.9 10 7 10.9 7 12C7 13.1 7.9 14 9 14C10.1 14 11 13.1 11 12C11 10.9 10.1 10 9 10ZM9 4C7.9 4 7 4.9 7 6C7 7.1 7.9 8 9 8C10.1 8 11 7.1 11 6C11 4.9 10.1 4 9 4ZM15 8C16.1 8 17 7.1 17 6C17 4.9 16.1 4 15 4C13.9 4 13 4.9 13 6C13 7.1 13.9 8 15 8ZM15 10C13.9 10 13 10.9 13 12C13 13.1 13.9 14 15 14C16.1 14 17 13.1 17 12C17 10.9 16.1 10 15 10ZM15 16C13.9 16 13 16.9 13 18C13 19.1 13.9 20 15 20C16.1 20 17 19.1 17 18C17 16.9 16.1 16 15 16Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_971_7680">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ece = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8067)">
      <path
        d="M8 7H20C20.55 7 21 6.55 21 6C21 5.45 20.55 5 20 5H8C7.45 5 7 5.45 7 6C7 6.55 7.45 7 8 7ZM20 17H8C7.45 17 7 17.45 7 18C7 18.55 7.45 19 8 19H20C20.55 19 21 18.55 21 18C21 17.45 20.55 17 20 17ZM20 11H8C7.45 11 7 11.45 7 12C7 12.55 7.45 13 8 13H20C20.55 13 21 12.55 21 12C21 11.45 20.55 11 20 11ZM4.5 16H2.5C2.22 16 2 16.22 2 16.5C2 16.78 2.22 17 2.5 17H4V17.5H3.5C3.22 17.5 3 17.72 3 18C3 18.28 3.22 18.5 3.5 18.5H4V19H2.5C2.22 19 2 19.22 2 19.5C2 19.78 2.22 20 2.5 20H4.5C4.78 20 5 19.78 5 19.5V16.5C5 16.22 4.78 16 4.5 16ZM2.5 5H3V7.5C3 7.78 3.22 8 3.5 8C3.78 8 4 7.78 4 7.5V4.5C4 4.22 3.78 4 3.5 4H2.5C2.22 4 2 4.22 2 4.5C2 4.78 2.22 5 2.5 5ZM4.5 10H2.5C2.22 10 2 10.22 2 10.5C2 10.78 2.22 11 2.5 11H3.8L2.12 12.96C2.04 13.05 2 13.17 2 13.28V13.5C2 13.78 2.22 14 2.5 14H4.5C4.78 14 5 13.78 5 13.5C5 13.22 4.78 13 4.5 13H3.2L4.88 11.04C4.96 10.95 5 10.83 5 10.72V10.5C5 10.22 4.78 10 4.5 10Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8067">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, $5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_971_7676)">
      <path
        d="M18 13H13V18C13 18.55 12.55 19 12 19C11.45 19 11 18.55 11 18V13H6C5.45 13 5 12.55 5 12C5 11.45 5.45 11 6 11H11V6C11 5.45 11.45 5 12 5C12.55 5 13 5.45 13 6V11H18C18.55 11 19 11.45 19 12C19 12.55 18.55 13 18 13Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_971_7676">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ice = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7897)">
      <path
        d="M7.17 17C7.68 17 8.15 16.71 8.37 16.26L9.79 13.42C9.93 13.14 10 12.84 10 12.53V8C10 7.45 9.55 7 9 7H5C4.45 7 4 7.45 4 8V12C4 12.55 4.45 13 5 13H7L5.97 15.06C5.52 15.95 6.17 17 7.17 17ZM17.17 17C17.68 17 18.15 16.71 18.37 16.26L19.79 13.42C19.93 13.14 20 12.84 20 12.53V8C20 7.45 19.55 7 19 7H15C14.45 7 14 7.45 14 8V12C14 12.55 14.45 13 15 13H17L15.97 15.06C15.52 15.95 16.17 17 17.17 17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7897">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, V5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M7.30775 20.4997C6.81058 20.4997 6.385 20.3227 6.031 19.9687C5.677 19.6147 5.5 19.1892 5.5 18.692V5.99973H5.25C5.0375 5.99973 4.85942 5.92782 4.71575 5.78398C4.57192 5.64015 4.5 5.46198 4.5 5.24948C4.5 5.03682 4.57192 4.85873 4.71575 4.71523C4.85942 4.57157 5.0375 4.49973 5.25 4.49973H9C9 4.2549 9.08625 4.04624 9.25875 3.87374C9.43108 3.7014 9.63967 3.61523 9.8845 3.61523H14.1155C14.3603 3.61523 14.5689 3.7014 14.7413 3.87374C14.9138 4.04624 15 4.2549 15 4.49973H18.75C18.9625 4.49973 19.1406 4.57165 19.2843 4.71548C19.4281 4.85932 19.5 5.03748 19.5 5.24998C19.5 5.46265 19.4281 5.64073 19.2843 5.78423C19.1406 5.9279 18.9625 5.99973 18.75 5.99973H18.5V18.692C18.5 19.1892 18.323 19.6147 17.969 19.9687C17.615 20.3227 17.1894 20.4997 16.6923 20.4997H7.30775ZM17 5.99973H7V18.692C7 18.7818 7.02883 18.8556 7.0865 18.9132C7.14417 18.9709 7.21792 18.9997 7.30775 18.9997H16.6923C16.7821 18.9997 16.8558 18.9709 16.9135 18.9132C16.9712 18.8556 17 18.7818 17 18.692V5.99973ZM10.1543 16.9997C10.3668 16.9997 10.5448 16.9279 10.6885 16.7842C10.832 16.6404 10.9037 16.4622 10.9037 16.2497V8.74973C10.9037 8.53723 10.8318 8.35907 10.688 8.21523C10.5443 8.07157 10.3662 7.99973 10.1535 7.99973C9.941 7.99973 9.76292 8.07157 9.61925 8.21523C9.47575 8.35907 9.404 8.53723 9.404 8.74973V16.2497C9.404 16.4622 9.47583 16.6404 9.6195 16.7842C9.76333 16.9279 9.94158 16.9997 10.1543 16.9997ZM13.8465 16.9997C14.059 16.9997 14.2371 16.9279 14.3807 16.7842C14.5243 16.6404 14.596 16.4622 14.596 16.2497V8.74973C14.596 8.53723 14.5242 8.35907 14.3805 8.21523C14.2367 8.07157 14.0584 7.99973 13.8458 7.99973C13.6333 7.99973 13.4552 8.07157 13.3115 8.21523C13.168 8.35907 13.0962 8.53723 13.0962 8.74973V16.2497C13.0962 16.4622 13.1682 16.6404 13.312 16.7842C13.4557 16.9279 13.6338 16.9997 13.8465 16.9997Z"
    />
  </svg>
`, nR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
    />
  </svg>
`, Dce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M3.25 13.7404C3.0375 13.7404 2.85938 13.6684 2.71563 13.5246C2.57188 13.3808 2.5 13.2026 2.5 12.99C2.5 12.7774 2.57188 12.5993 2.71563 12.4558C2.85938 12.3122 3.0375 12.2404 3.25 12.2404H20.75C20.9625 12.2404 21.1406 12.3123 21.2843 12.4561C21.4281 12.5999 21.5 12.7781 21.5 12.9907C21.5 13.2033 21.4281 13.3814 21.2843 13.525C21.1406 13.6686 20.9625 13.7404 20.75 13.7404H3.25ZM10.9423 10.2596V6.62495H6.5673C6.2735 6.62495 6.02377 6.52201 5.8181 6.31613C5.61245 6.11026 5.50963 5.86027 5.50963 5.56615C5.50963 5.27205 5.61245 5.02083 5.8181 4.8125C6.02377 4.60417 6.2735 4.5 6.5673 4.5H17.4423C17.7361 4.5 17.9858 4.60294 18.1915 4.80883C18.3971 5.01471 18.5 5.2647 18.5 5.5588C18.5 5.85292 18.3971 6.10413 18.1915 6.31245C17.9858 6.52078 17.7361 6.62495 17.4423 6.62495H13.0673V10.2596H10.9423ZM10.9423 15.7211H13.0673V18.4423C13.0673 18.7361 12.9643 18.9858 12.7584 19.1915C12.5526 19.3971 12.3026 19.5 12.0085 19.5C11.7144 19.5 11.4631 19.3962 11.2548 19.1887C11.0465 18.9811 10.9423 18.7291 10.9423 18.4327V15.7211Z"
    />
  </svg>
`, Nce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8078)">
      <path
        d="M20 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H20C21.1 21 22 20.1 22 19V5C22 3.9 21.1 3 20 3ZM20 5V8H5V5H20ZM15 19H10V10H15V19ZM5 10H8V19H5V10ZM17 19V10H20V19H17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8078">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Rce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5547)">
      <path
        d="M5 5.5C5 6.33 5.67 7 6.5 7H10.5V17.5C10.5 18.33 11.17 19 12 19C12.83 19 13.5 18.33 13.5 17.5V7H17.5C18.33 7 19 6.33 19 5.5C19 4.67 18.33 4 17.5 4H6.5C5.67 4 5 4.67 5 5.5Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5547">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Pce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M5.66936 16.3389L9.39244 12.6158C9.54115 12.4671 9.71679 12.3937 9.91936 12.3957C10.1219 12.3976 10.2975 12.4761 10.4463 12.6312C10.5847 12.7823 10.654 12.9585 10.654 13.1599C10.654 13.3613 10.5847 13.5363 10.4463 13.6851L6.32704 17.8197C6.14627 18.0004 5.93538 18.0908 5.69436 18.0908C5.45333 18.0908 5.24243 18.0004 5.06166 17.8197L3.01744 15.7754C2.87899 15.637 2.81136 15.4629 2.81456 15.2533C2.81776 15.0437 2.88859 14.8697 3.02706 14.7312C3.16551 14.5928 3.34008 14.5235 3.55076 14.5235C3.76144 14.5235 3.93494 14.5928 4.07126 14.7312L5.66936 16.3389ZM5.66936 8.72359L9.39244 5.00049C9.54115 4.85177 9.71679 4.77838 9.91936 4.78031C10.1219 4.78223 10.2975 4.86075 10.4463 5.01586C10.5847 5.16691 10.654 5.34314 10.654 5.54454C10.654 5.74592 10.5847 5.92097 10.4463 6.06969L6.32704 10.2043C6.14627 10.3851 5.93538 10.4755 5.69436 10.4755C5.45333 10.4755 5.24243 10.3851 5.06166 10.2043L3.01744 8.16009C2.87899 8.02162 2.81136 7.84759 2.81456 7.63799C2.81776 7.42837 2.88859 7.25433 3.02706 7.11586C3.16551 6.97741 3.34008 6.90819 3.55076 6.90819C3.76144 6.90819 3.93494 6.97741 4.07126 7.11586L5.66936 8.72359ZM13.7597 16.5581C13.5472 16.5581 13.3691 16.4862 13.2253 16.3424C13.0816 16.1986 13.0097 16.0204 13.0097 15.8078C13.0097 15.5952 13.0816 15.4171 13.2253 15.2735C13.3691 15.13 13.5472 15.0582 13.7597 15.0582H20.7597C20.9722 15.0582 21.1503 15.1301 21.2941 15.2739C21.4378 15.4177 21.5097 15.5959 21.5097 15.8085C21.5097 16.0211 21.4378 16.1992 21.2941 16.3427C21.1503 16.4863 20.9722 16.5581 20.7597 16.5581H13.7597ZM13.7597 8.94276C13.5472 8.94276 13.3691 8.87085 13.2253 8.72704C13.0816 8.58324 13.0097 8.40504 13.0097 8.19244C13.0097 7.97985 13.0816 7.80177 13.2253 7.65819C13.3691 7.5146 13.5472 7.44281 13.7597 7.44281H20.7597C20.9722 7.44281 21.1503 7.51471 21.2941 7.65851C21.4378 7.80233 21.5097 7.98053 21.5097 8.19311C21.5097 8.40571 21.4378 8.5838 21.2941 8.72739C21.1503 8.87097 20.9722 8.94276 20.7597 8.94276H13.7597Z"
    />
  </svg>
`, rR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 24 24"
  >
    <path
      fill="currentColor"
      d="M7 19v-.808L13.096 12L7 5.808V5h10v1.25H9.102L14.727 12l-5.625 5.77H17V19z"
    />
  </svg>
`, iR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    height="24px"
    viewBox="0 -960 960 960"
    width="24px"
  >
    <path
      d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"
    />
  </svg>
`, _ce = {
  [St.CodeMirror]: {
    theme: lG,
    languages: JK,
    expandIcon: ZN,
    searchIcon: nR,
    clearSearchIcon: QN,
    searchPlaceholder: "Search language",
    noResultText: "No result",
    previewToggleIcon: (n) => n ? P7 : iR
  }
}, Lce = at([], "FeaturesCtx"), Bce = at({}, "CrepeCtx");
function zce(n) {
  return n.get("CrepeCtx");
}
function kg(n) {
  return n.use("FeaturesCtx");
}
function Rs(n) {
  return (e) => {
    kg(e).update((t) => t.includes(n) ? t : [...t, n]);
  };
}
function sR(n) {
  return n.$from.parent.type.name === "code_block";
}
function oR(n) {
  var e;
  const t = (e = n.$from.node(n.$from.depth - 1)) == null ? void 0 : e.type;
  return t?.name === "list_item";
}
var lR = (n) => {
  throw TypeError(n);
}, aR = (n, e, t) => e.has(n) || lR("Cannot " + t), Gu = (n, e, t) => (aR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), eS = (n, e, t) => e.has(n) ? lR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Fce = (n, e, t, r) => (aR(n, e, "write to private field"), e.set(n, t), t), cc, Hp;
class cR {
  constructor() {
    eS(this, cc, []), this.clear = () => (Fce(this, cc, []), this), eS(this, Hp, (e) => {
      const t = {
        group: e,
        addItem: (r, i) => {
          const s = { ...i, key: r };
          return e.items.push(s), t;
        },
        clear: () => (e.items = [], t)
      };
      return t;
    }), this.addGroup = (e, t) => {
      const i = {
        key: e,
        label: t,
        items: []
      };
      return Gu(this, cc).push(i), Gu(this, Hp).call(this, i);
    }, this.getGroup = (e) => {
      const t = Gu(this, cc).find((r) => r.key === e);
      if (!t) throw new Error(`Group with key ${e} not found`);
      return Gu(this, Hp).call(this, t);
    }, this.build = () => Gu(this, cc);
  }
}
cc = /* @__PURE__ */ new WeakMap();
Hp = /* @__PURE__ */ new WeakMap();
function Hce(n, e, t) {
  var r, i, s, o, l, a, c, u, h, f, d, p, m, g, b, w, k, C, M, T, N, B, $, R, V, z, ue, ie, he, Ce, ye, be, ze, I, Ie, Ve, O, pt, Ue, et, Tt, Ht, sn, Gt, Lr, E, P, W, Q, J, Y, ae, re, oe, te, De, de, Te, Pe, F, X, pe, _e, je, kt, _t, Yt, on, xt, mt, Vn, En, Il, Dl, Fd, To, Hd, $d, ln, Ps, Vd, bu, qa, vu, wu, qd, Br, _s, xu, ku, Wa, Su, ni, Cu, Mu, Tu, Au, Wd, Re, L, le, Oe, At, bn, tn, In, ri, Ao, ja, vn, Ou, Eu, L7, B7, z7, F7, H7, $7, V7;
  const Ua = t && kg(t).get(), SR = Ua?.includes(St.Latex), CR = Ua?.includes(St.ImageBlock), MR = Ua?.includes(St.Table), Iu = new cR();
  if (e?.textGroup !== null) {
    const yt = Iu.addGroup(
      "text",
      (i = (r = e?.textGroup) == null ? void 0 : r.label) != null ? i : "Text"
    );
    ((s = e?.textGroup) == null ? void 0 : s.text) !== null && yt.addItem("text", {
      label: (a = (l = (o = e?.textGroup) == null ? void 0 : o.text) == null ? void 0 : l.label) != null ? a : "Text",
      icon: (h = (u = (c = e?.textGroup) == null ? void 0 : c.text) == null ? void 0 : u.icon) != null ? h : Rce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = As.type(Le);
        Fe.call(Dn.key), Fe.call($s.key, {
          nodeType: gt
        });
      }
    }), ((f = e?.textGroup) == null ? void 0 : f.h1) !== null && yt.addItem("h1", {
      label: (m = (p = (d = e?.textGroup) == null ? void 0 : d.h1) == null ? void 0 : p.label) != null ? m : "Heading 1",
      icon: (w = (b = (g = e?.textGroup) == null ? void 0 : g.h1) == null ? void 0 : b.icon) != null ? w : wce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Ur.type(Le);
        Fe.call(Dn.key), Fe.call($s.key, {
          nodeType: gt,
          attrs: {
            level: 1
          }
        });
      }
    }), ((k = e?.textGroup) == null ? void 0 : k.h2) !== null && yt.addItem("h2", {
      label: (T = (M = (C = e?.textGroup) == null ? void 0 : C.h2) == null ? void 0 : M.label) != null ? T : "Heading 2",
      icon: ($ = (B = (N = e?.textGroup) == null ? void 0 : N.h2) == null ? void 0 : B.icon) != null ? $ : xce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Ur.type(Le);
        Fe.call(Dn.key), Fe.call($s.key, {
          nodeType: gt,
          attrs: {
            level: 2
          }
        });
      }
    }), ((R = e?.textGroup) == null ? void 0 : R.h3) !== null && yt.addItem("h3", {
      label: (ue = (z = (V = e?.textGroup) == null ? void 0 : V.h3) == null ? void 0 : z.label) != null ? ue : "Heading 3",
      icon: (Ce = (he = (ie = e?.textGroup) == null ? void 0 : ie.h3) == null ? void 0 : he.icon) != null ? Ce : kce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Ur.type(Le);
        Fe.call(Dn.key), Fe.call($s.key, {
          nodeType: gt,
          attrs: {
            level: 3
          }
        });
      }
    }), ((ye = e?.textGroup) == null ? void 0 : ye.h4) !== null && yt.addItem("h4", {
      label: (I = (ze = (be = e?.textGroup) == null ? void 0 : be.h4) == null ? void 0 : ze.label) != null ? I : "Heading 4",
      icon: (O = (Ve = (Ie = e?.textGroup) == null ? void 0 : Ie.h4) == null ? void 0 : Ve.icon) != null ? O : Sce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Ur.type(Le);
        Fe.call(Dn.key), Fe.call($s.key, {
          nodeType: gt,
          attrs: {
            level: 4
          }
        });
      }
    }), ((pt = e?.textGroup) == null ? void 0 : pt.h5) !== null && yt.addItem("h5", {
      label: (Tt = (et = (Ue = e?.textGroup) == null ? void 0 : Ue.h5) == null ? void 0 : et.label) != null ? Tt : "Heading 5",
      icon: (Gt = (sn = (Ht = e?.textGroup) == null ? void 0 : Ht.h5) == null ? void 0 : sn.icon) != null ? Gt : Cce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Ur.type(Le);
        Fe.call(Dn.key), Fe.call($s.key, {
          nodeType: gt,
          attrs: {
            level: 5
          }
        });
      }
    }), ((Lr = e?.textGroup) == null ? void 0 : Lr.h6) !== null && yt.addItem("h6", {
      label: (W = (P = (E = e?.textGroup) == null ? void 0 : E.h6) == null ? void 0 : P.label) != null ? W : "Heading 6",
      icon: (Y = (J = (Q = e?.textGroup) == null ? void 0 : Q.h6) == null ? void 0 : J.icon) != null ? Y : Mce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Ur.type(Le);
        Fe.call(Dn.key), Fe.call($s.key, {
          nodeType: gt,
          attrs: {
            level: 6
          }
        });
      }
    }), ((ae = e?.textGroup) == null ? void 0 : ae.quote) !== null && yt.addItem("quote", {
      label: (te = (oe = (re = e?.textGroup) == null ? void 0 : re.quote) == null ? void 0 : oe.label) != null ? te : "Quote",
      icon: (Te = (de = (De = e?.textGroup) == null ? void 0 : De.quote) == null ? void 0 : de.icon) != null ? Te : Ice,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = ou.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: gt
        });
      }
    }), ((Pe = e?.textGroup) == null ? void 0 : Pe.divider) !== null && yt.addItem("divider", {
      label: (pe = (X = (F = e?.textGroup) == null ? void 0 : F.divider) == null ? void 0 : X.label) != null ? pe : "Divider",
      icon: (kt = (je = (_e = e?.textGroup) == null ? void 0 : _e.divider) == null ? void 0 : je.icon) != null ? kt : vce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = lu.type(Le);
        Fe.call(Dn.key), Fe.call(mh.key, {
          nodeType: gt
        });
      }
    });
  }
  if (e?.listGroup !== null) {
    const yt = Iu.addGroup(
      "list",
      (Yt = (_t = e?.listGroup) == null ? void 0 : _t.label) != null ? Yt : "List"
    );
    ((on = e?.listGroup) == null ? void 0 : on.bulletList) !== null && yt.addItem("bullet-list", {
      label: (Vn = (mt = (xt = e?.listGroup) == null ? void 0 : xt.bulletList) == null ? void 0 : mt.label) != null ? Vn : "Bullet List",
      icon: (Dl = (Il = (En = e?.listGroup) == null ? void 0 : En.bulletList) == null ? void 0 : Il.icon) != null ? Dl : mce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Ba.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: gt
        });
      }
    }), ((Fd = e?.listGroup) == null ? void 0 : Fd.orderedList) !== null && yt.addItem("ordered-list", {
      label: ($d = (Hd = (To = e?.listGroup) == null ? void 0 : To.orderedList) == null ? void 0 : Hd.label) != null ? $d : "Ordered List",
      icon: (Vd = (Ps = (ln = e?.listGroup) == null ? void 0 : ln.orderedList) == null ? void 0 : Ps.icon) != null ? Vd : Ece,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = za.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: gt
        });
      }
    }), ((bu = e?.listGroup) == null ? void 0 : bu.taskList) !== null && yt.addItem("task-list", {
      label: (wu = (vu = (qa = e?.listGroup) == null ? void 0 : qa.taskList) == null ? void 0 : vu.label) != null ? wu : "Task List",
      icon: (_s = (Br = (qd = e?.listGroup) == null ? void 0 : qd.taskList) == null ? void 0 : Br.icon) != null ? _s : Pce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Wi.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: gt,
          attrs: { checked: !1 }
        });
      }
    });
  }
  if (e?.advancedGroup !== null) {
    const yt = Iu.addGroup(
      "advanced",
      (ku = (xu = e?.advancedGroup) == null ? void 0 : xu.label) != null ? ku : "Advanced"
    );
    ((Wa = e?.advancedGroup) == null ? void 0 : Wa.image) !== null && CR && yt.addItem("image", {
      label: (Cu = (ni = (Su = e?.advancedGroup) == null ? void 0 : Su.image) == null ? void 0 : ni.label) != null ? Cu : "Image",
      icon: (Au = (Tu = (Mu = e?.advancedGroup) == null ? void 0 : Mu.image) == null ? void 0 : Tu.icon) != null ? Au : H5,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Y1.type(Le);
        Fe.call(Dn.key), Fe.call(mh.key, {
          nodeType: gt
        });
      }
    }), ((Wd = e?.advancedGroup) == null ? void 0 : Wd.codeBlock) !== null && yt.addItem("code", {
      label: (le = (L = (Re = e?.advancedGroup) == null ? void 0 : Re.codeBlock) == null ? void 0 : L.label) != null ? le : "Code",
      icon: (bn = (At = (Oe = e?.advancedGroup) == null ? void 0 : Oe.codeBlock) == null ? void 0 : At.icon) != null ? bn : eR,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Ss.type(Le);
        Fe.call(Dn.key), Fe.call($s.key, {
          nodeType: gt
        });
      }
    }), ((tn = e?.advancedGroup) == null ? void 0 : tn.table) !== null && MR && yt.addItem("table", {
      label: (Ao = (ri = (In = e?.advancedGroup) == null ? void 0 : In.table) == null ? void 0 : ri.label) != null ? Ao : "Table",
      icon: (Ou = (vn = (ja = e?.advancedGroup) == null ? void 0 : ja.table) == null ? void 0 : vn.icon) != null ? Ou : Nce,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Le.get(Ct);
        Fe.call(Dn.key);
        const { from: TR } = gt.state.selection;
        Fe.call(mh.key, {
          nodeType: Mv(Le, 3, 3)
        }), Fe.call(DO.key, {
          pos: TR
        });
      }
    }), ((Eu = e?.advancedGroup) == null ? void 0 : Eu.math) !== null && SR && yt.addItem("math", {
      label: (z7 = (B7 = (L7 = e?.advancedGroup) == null ? void 0 : L7.math) == null ? void 0 : B7.label) != null ? z7 : "Math",
      icon: ($7 = (H7 = (F7 = e?.advancedGroup) == null ? void 0 : F7.math) == null ? void 0 : H7.icon) != null ? $7 : rR,
      onRun: (Le) => {
        const Fe = Le.get(Me), gt = Ss.type(Le);
        Fe.call(Dn.key), Fe.call(mh.key, {
          nodeType: gt,
          attrs: { language: "LaTex" }
        });
      }
    });
  }
  (V7 = e?.buildMenu) == null || V7.call(e, Iu);
  let Du = Iu.build();
  n && (Du = Du.map((yt) => {
    const Le = yt.items.filter(
      (Fe) => Fe.label.toLowerCase().includes(n.toLowerCase())
    );
    return {
      ...yt,
      items: Le
    };
  }).filter((yt) => yt.items.length > 0));
  const q7 = Du.flatMap((yt) => yt.items);
  return q7.forEach((yt, Le) => {
    Object.assign(yt, { index: Le });
  }), Du.reduce((yt, Le) => {
    const Fe = yt + Le.items.length;
    return Object.assign(Le, {
      range: [yt, Fe]
    }), Fe;
  }, 0), {
    groups: Du,
    size: q7.length
  };
}
const $ce = /* @__PURE__ */ $n({
  props: {
    ctx: {
      type: Object,
      required: !0
    },
    show: {
      type: Object,
      required: !0
    },
    filter: {
      type: Object,
      required: !0
    },
    hide: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !1
    }
  },
  setup({ ctx: n, show: e, filter: t, hide: r, config: i }) {
    const s = Ae(), o = Na(() => Hce(t.value, i, n)), l = Ae(0), a = Ae({ x: -999, y: -999 }), c = (m) => {
      const { x: g, y: b } = m;
      a.value = { x: g, y: b };
    };
    Mc([o, e], () => {
      const { size: m } = o.value;
      m === 0 && e.value ? r() : l.value >= m && (l.value = 0);
    });
    const u = (m, g) => {
      const b = l.value, w = typeof m == "function" ? m(b) : m;
      g?.(w), l.value = w;
    }, h = (m) => {
      var g, b;
      const w = (g = s.value) == null ? void 0 : g.querySelector(
        `[data-index="${m}"]`
      ), k = (b = s.value) == null ? void 0 : b.querySelector(".menu-groups");
      !w || !k || (k.scrollTop = w.offsetTop - k.offsetTop);
    }, f = (m) => {
      const g = o.value.groups.flatMap((b) => b.items).at(m);
      g && n && g.onRun(n), r();
    }, d = (m) => {
      const { size: g, groups: b } = o.value;
      if (m.key === "Escape") {
        m.preventDefault(), r?.();
        return;
      }
      if (m.key === "ArrowDown")
        return m.preventDefault(), u(
          (w) => w < g - 1 ? w + 1 : w,
          h
        );
      if (m.key === "ArrowUp")
        return m.preventDefault(), u(
          (w) => w <= 0 ? w : w - 1,
          h
        );
      if (m.key === "ArrowLeft")
        return m.preventDefault(), u((w) => {
          const k = b.find(
            (M) => M.range[0] <= w && M.range[1] > w
          );
          if (!k) return w;
          const C = b[b.indexOf(k) - 1];
          return C ? C.range[1] - 1 : w;
        }, h);
      if (m.key === "ArrowRight")
        return m.preventDefault(), u((w) => {
          const k = b.find(
            (M) => M.range[0] <= w && M.range[1] > w
          );
          if (!k) return w;
          const C = b[b.indexOf(k) + 1];
          return C ? C.range[0] : w;
        }, h);
      m.key === "Enter" && (m.preventDefault(), f(l.value));
    }, p = (m) => (g) => {
      const b = a.value;
      if (!b) return;
      const { x: w, y: k } = g;
      w === b.x && k === b.y || u(m);
    };
    return cu(() => {
      e.value ? window.addEventListener("keydown", d, { capture: !0 }) : window.removeEventListener("keydown", d, { capture: !0 });
    }), Sd(() => {
      window.removeEventListener("keydown", d, { capture: !0 });
    }), () => /* @__PURE__ */ j("div", { ref: s, onPointerdown: (m) => m.preventDefault() }, /* @__PURE__ */ j("nav", { class: "tab-group" }, /* @__PURE__ */ j("ul", null, o.value.groups.map((m) => /* @__PURE__ */ j(
      "li",
      {
        key: m.key,
        onPointerdown: () => u(m.range[0], h),
        class: l.value >= m.range[0] && l.value < m.range[1] ? "selected" : ""
      },
      m.label
    )))), /* @__PURE__ */ j("div", { class: "menu-groups", onPointermove: c }, o.value.groups.map((m) => /* @__PURE__ */ j("div", { key: m.key, class: "menu-group" }, /* @__PURE__ */ j("h6", null, m.label), /* @__PURE__ */ j("ul", null, m.items.map((g) => /* @__PURE__ */ j(
      "li",
      {
        key: g.key,
        "data-index": g.index,
        class: l.value === g.index ? "hover" : "",
        onPointerenter: p(g.index),
        onPointerdown: () => {
          var b, w;
          (w = (b = s.value) == null ? void 0 : b.querySelector(`[data-index="${g.index}"]`)) == null || w.classList.add("active");
        },
        onPointerup: () => {
          var b, w;
          (w = (b = s.value) == null ? void 0 : b.querySelector(`[data-index="${g.index}"]`)) == null || w.classList.remove("active"), f(g.index);
        }
      },
      /* @__PURE__ */ j(Wc, { icon: g.icon }),
      /* @__PURE__ */ j("span", null, g.label)
    )))))));
  }
});
var uR = (n) => {
  throw TypeError(n);
}, hR = (n, e, t) => e.has(n) || uR("Cannot " + t), Ti = (n, e, t) => (hR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Yu = (n, e, t) => e.has(n) ? uR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), $l = (n, e, t, r) => (hR(n, e, "write to private field"), e.set(n, t), t), Ah, $p, Vp, Ws, uc;
const fR = rZ("CREPE_MENU"), _7 = Mt(
  {
    show: () => {
    },
    hide: () => {
    }
  },
  "menuAPICtx"
);
function Vce(n, e) {
  n.set(fR.key, {
    view: (t) => new qce(n, t, e)
  });
}
class qce {
  constructor(e, t, r) {
    Yu(this, Ah), Yu(this, $p), Yu(this, Vp), Yu(this, Ws), Yu(this, uc, null), this.update = (u) => {
      Ti(this, Ws).update(u);
    }, this.show = (u) => {
      $l(this, uc, u), Ti(this, Vp).value = "", Ti(this, Ws).show();
    }, this.hide = () => {
      $l(this, uc, null), Ti(this, Ws).hide();
    }, this.destroy = () => {
      Ti(this, Ws).destroy(), Ti(this, $p).unmount(), Ti(this, Ah).remove();
    };
    const i = document.createElement("div");
    i.classList.add("milkdown-slash-menu");
    const s = Ae(!1), o = Ae("");
    $l(this, Vp, o);
    const l = this.hide, a = ji($ce, {
      ctx: e,
      config: r,
      show: s,
      filter: o,
      hide: l
    });
    $l(this, $p, a), a.mount(i), $l(this, Ah, i);
    const c = this;
    $l(this, Ws, new iZ({
      content: Ti(this, Ah),
      debounce: 20,
      shouldShow(u) {
        if (sR(u.state.selection) || oR(u.state.selection))
          return !1;
        const h = this.getContent(
          u,
          (d) => ["paragraph", "heading"].includes(d.type.name)
        );
        if (h == null || !Wce(u.state.selection))
          return !1;
        const f = Ti(c, uc);
        if (o.value = h.startsWith("/") ? h.slice(1) : h, typeof f == "number") {
          const d = u.state.doc.nodeSize - 2, p = Math.min(f, d);
          return u.state.doc.resolve(p).node() !== u.state.doc.resolve(u.state.selection.from).node() ? ($l(c, uc, null), !1) : !0;
        }
        return !!h.startsWith("/");
      },
      offset: 10
    })), Ti(this, Ws).onShow = () => {
      s.value = !0;
    }, Ti(this, Ws).onHide = () => {
      s.value = !1;
    }, this.update(t), e.set(_7.key, {
      show: (u) => this.show(u),
      hide: () => this.hide()
    });
  }
}
Ah = /* @__PURE__ */ new WeakMap();
$p = /* @__PURE__ */ new WeakMap();
Vp = /* @__PURE__ */ new WeakMap();
Ws = /* @__PURE__ */ new WeakMap();
uc = /* @__PURE__ */ new WeakMap();
function Wce(n) {
  if (!(n instanceof Ee)) return !1;
  const { $head: e } = n, t = e.parent;
  return e.parentOffset === t.content.size;
}
const jce = /* @__PURE__ */ $n({
  props: {
    onAdd: {
      type: Function,
      required: !0
    },
    addIcon: {
      type: String,
      required: !0
    },
    handleIcon: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = Ae();
    return () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j(
      "div",
      {
        ref: e,
        class: "operation-item",
        onPointerdown: (t) => {
          var r;
          t.preventDefault(), t.stopPropagation(), (r = e.value) == null || r.classList.add("active");
        },
        onPointerup: (t) => {
          var r;
          t.preventDefault(), t.stopPropagation(), (r = e.value) == null || r.classList.remove("active"), n.onAdd();
        }
      },
      /* @__PURE__ */ j(Wc, { icon: n.addIcon })
    ), /* @__PURE__ */ j("div", { class: "operation-item" }, /* @__PURE__ */ j(Wc, { icon: n.handleIcon })));
  }
});
var dR = (n) => {
  throw TypeError(n);
}, pR = (n, e, t) => e.has(n) || dR("Cannot " + t), Vl = (n, e, t) => (pR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), F0 = (n, e, t) => e.has(n) ? dR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), H0 = (n, e, t, r) => (pR(n, e, "write to private field"), e.set(n, t), t), qp, Kl, Wp, jp;
class Uce {
  constructor(e, t) {
    F0(this, qp), F0(this, Kl), F0(this, Wp), F0(this, jp), this.update = () => {
      Vl(this, Kl).update();
    }, this.destroy = () => {
      Vl(this, Kl).destroy(), Vl(this, qp).remove(), Vl(this, Wp).unmount();
    }, this.onAdd = () => {
      const c = Vl(this, jp), u = c.get(Ct);
      u.hasFocus() || u.focus();
      const { state: h, dispatch: f } = u, d = Vl(this, Kl).active;
      if (!d) return;
      const m = d.$pos.pos + d.node.nodeSize;
      let g = h.tr.insert(m, As.type(c).create());
      g = g.setSelection(Ee.near(g.doc.resolve(m))), f(g.scrollIntoView()), Vl(this, Kl).hide(), c.get(_7.key).show(g.selection.from);
    };
    var r, i, s;
    H0(this, jp, e);
    const o = document.createElement("div");
    o.classList.add("milkdown-block-handle");
    const l = ji(jce, {
      onAdd: this.onAdd,
      addIcon: (r = t?.handleAddIcon) != null ? r : $5,
      handleIcon: (i = t?.handleDragIcon) != null ? i : Oce
    });
    l.mount(o), H0(this, Wp, l), H0(this, qp, o);
    const a = (s = t?.blockHandle) != null ? s : {};
    H0(this, Kl, new nY({
      ctx: e,
      content: o,
      getOffset: () => 16,
      getPlacement: ({ active: c, blockDom: u }) => {
        if (c.node.type.name === "heading") return "left";
        let h = 0;
        c.node.descendants((C) => {
          h += C.childCount;
        });
        const f = c.el, d = f.getBoundingClientRect(), p = u.getBoundingClientRect(), m = window.getComputedStyle(f), g = Number.parseInt(m.paddingTop, 10) || 0, b = Number.parseInt(m.paddingBottom, 10) || 0, w = d.height - g - b, k = p.height;
        return h > 2 || k < w ? "left-start" : "left";
      },
      ...a
    })), this.update();
  }
}
qp = /* @__PURE__ */ new WeakMap();
Kl = /* @__PURE__ */ new WeakMap();
Wp = /* @__PURE__ */ new WeakMap();
jp = /* @__PURE__ */ new WeakMap();
function Kce(n, e) {
  n.set(N1.key, {
    filterNodes: (t) => !gs(
      (i) => ["table", "blockquote", "math_inline"].includes(i.type.name)
    )(t)
  }), n.set(_1.key, {
    view: () => new Uce(n, e)
  });
}
const Gce = (n, e) => {
  n.config(Rs(St.BlockEdit)).config((t) => Kce(t, e)).config((t) => Vce(t, e)).use(_7).use(_1).use(fR);
}, Yce = (n, e = {}) => {
  n.config(Rs(St.CodeMirror)).config((t) => {
    const { languages: r = [], theme: i } = e, s = [
      nu.of(ZI.concat(ere)),
      cse
    ];
    i && s.push(i), e.extensions && s.push(...e.extensions), t.update(Nd.key, (o) => ({
      extensions: s,
      languages: r,
      expandIcon: e.expandIcon || ZN,
      searchIcon: e.searchIcon || nR,
      clearSearchIcon: e.clearSearchIcon || QN,
      searchPlaceholder: e.searchPlaceholder || "Search language",
      copyText: e.copyText || "Copy",
      copyIcon: e.copyIcon || tR,
      onCopy: e.onCopy || (() => {
      }),
      noResultText: e.noResultText || "No result",
      renderLanguage: e.renderLanguage || o.renderLanguage,
      renderPreview: e.renderPreview || o.renderPreview,
      previewToggleButton: (l) => {
        var a, c;
        const u = ((a = e.previewToggleIcon) == null ? void 0 : a.call(e, l)) || (l ? P7 : iR), h = ((c = e.previewToggleText) == null ? void 0 : c.call(e, l)) || (l ? "Edit" : "Hide");
        return [u, h].map((f) => f.trim()).join(" ");
      },
      previewLabel: e.previewLabel || o.previewLabel
    }));
  }).use(Cre);
}, Jce = (n, e) => {
  if (n.config(Rs(St.Cursor)).config((r) => {
    r.update(og.key, () => {
      var i, s;
      return {
        class: "crepe-drop-cursor",
        width: (i = e?.width) != null ? i : 4,
        color: (s = e?.color) != null ? s : !1
      };
    });
  }).use(vse), e?.virtual === !1)
    return;
  const t = wse();
  n.use(kn(() => t));
}, Xce = (n, e) => {
  n.config(Rs(St.ImageBlock)).config((t) => {
    t.update(lg.key, (r) => {
      var i, s, o, l, a, c;
      return {
        uploadButton: (i = e?.inlineUploadButton) != null ? i : "Upload",
        imageIcon: (s = e?.inlineImageIcon) != null ? s : H5,
        confirmButton: (o = e?.inlineConfirmButton) != null ? o : R7,
        uploadPlaceholderText: (l = e?.inlineUploadPlaceholderText) != null ? l : "or paste link",
        onUpload: (c = (a = e?.inlineOnUpload) != null ? a : e?.onUpload) != null ? c : r.onUpload,
        proxyDomURL: e?.proxyDomURL
      };
    }), t.update(G1.key, (r) => {
      var i, s, o, l, a, c, u, h;
      return {
        uploadButton: (i = e?.blockUploadButton) != null ? i : "Upload file",
        imageIcon: (s = e?.blockImageIcon) != null ? s : H5,
        captionIcon: (o = e?.blockCaptionIcon) != null ? o : gce,
        confirmButton: (l = e?.blockConfirmButton) != null ? l : "Confirm",
        captionPlaceholderText: (a = e?.blockCaptionPlaceholderText) != null ? a : "Write Image Caption",
        uploadPlaceholderText: (c = e?.blockUploadPlaceholderText) != null ? c : "or paste link",
        onUpload: (h = (u = e?.blockOnUpload) != null ? u : e?.onUpload) != null ? h : r.onUpload,
        proxyDomURL: e?.proxyDomURL
      };
    });
  }).use(UZ).use(Pse);
}, Zce = Ss.extendSchema((n) => (e) => {
  const t = n(e);
  return {
    ...t,
    toMarkdown: {
      match: t.toMarkdown.match,
      runner: (r, i) => {
        var s, o;
        if (((s = i.attrs.language) != null ? s : "").toLowerCase() === "latex")
          r.addNode(
            "math",
            void 0,
            ((o = i.content.firstChild) == null ? void 0 : o.text) || ""
          );
        else
          return t.toMarkdown.runner(r, i);
      }
    }
  };
}), Oh = "math_inline", id = hn(Oh, () => ({
  group: "inline",
  inline: !0,
  draggable: !0,
  atom: !0,
  attrs: {
    value: {
      default: ""
    }
  },
  parseDOM: [
    {
      tag: `span[data-type="${Oh}"]`,
      getAttrs: (n) => {
        var e;
        return {
          value: (e = n.dataset.value) != null ? e : ""
        };
      }
    }
  ],
  toDOM: (n) => {
    const e = n.attrs.value, t = document.createElement("span");
    return t.dataset.type = Oh, t.dataset.value = e, AN.render(e, t, {
      throwOnError: !1
    }), t;
  },
  parseMarkdown: {
    match: (n) => n.type === "inlineMath",
    runner: (n, e, t) => {
      n.addNode(t, { value: e.value });
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === Oh,
    runner: (n, e) => {
      n.addNode("inlineMath", void 0, e.attrs.value);
    }
  }
})), mR = Ye("ToggleLatex", (n) => () => (e, t) => {
  const {
    hasNode: r,
    pos: i,
    target: s
  } = _C(e, id.type(n)), { selection: o, doc: l, tr: a } = e;
  if (!r) {
    const d = l.textBetween(o.from, o.to);
    let p = a.replaceSelectionWith(
      id.type(n).create({
        value: d
      })
    );
    return t && t(
      p.setSelection($e.create(p.doc, o.from))
    ), !0;
  }
  const { from: c, to: u } = o;
  if (!s || i < 0) return !1;
  let h = a.delete(i, i + 1);
  const f = s.attrs.value;
  return h = h.insertText(f, i), t && t(
    h.setSelection(
      Ee.create(h.doc, c, u + f.length - 1)
    )
  ), !0;
}), tS = gg("INLINE_LATEX"), Qce = /* @__PURE__ */ $n({
  props: {
    config: {
      type: Object,
      required: !0
    },
    innerView: {
      type: Object,
      required: !0
    },
    updateValue: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = (r) => {
      if (!(!r || !(r instanceof HTMLElement))) {
        for (; r.firstChild; )
          r.removeChild(r.firstChild);
        n.innerView.value && r.appendChild(n.innerView.value.dom);
      }
    }, t = (r) => {
      r.preventDefault(), n.updateValue.value();
    };
    return () => /* @__PURE__ */ j("div", { class: "container" }, n.innerView && /* @__PURE__ */ j("div", { ref: e }), /* @__PURE__ */ j("button", { onPointerdown: t }, /* @__PURE__ */ j(Wc, { icon: n.config.inlineEditConfirm })));
  }
});
var gR = (n) => {
  throw TypeError(n);
}, yR = (n, e, t) => e.has(n) || gR("Cannot " + t), Sn = (n, e, t) => (yR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), No = (n, e, t) => e.has(n) ? gR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), $0 = (n, e, t, r) => (yR(n, e, "write to private field"), e.set(n, t), t), Eh, hc, Up, Gl, Ih, Dh, q5, W5;
class eue {
  constructor(e, t, r) {
    this.ctx = e, No(this, Eh), No(this, hc), No(this, Up), No(this, Gl, Am(null)), No(this, Ih, Am(() => {
    })), No(this, Dh), No(this, q5, () => {
      Sn(this, Gl).value && (Sn(this, Gl).value.destroy(), Sn(this, Gl).value = null);
    }), No(this, W5, (s) => {
      const l = (() => {
        const { selection: a, schema: c } = s.state;
        if (a.empty || !(a instanceof $e)) return !1;
        const u = a.node;
        if (u.type.name !== Oh) return !1;
        const h = a.from, f = c.nodes.paragraph.create(
          null,
          c.text(u.attrs.value)
        ), d = new S3(Sn(this, Up), {
          state: o3.create({
            doc: f,
            schema: new xS({
              nodes: {
                doc: {
                  content: "block+"
                },
                paragraph: {
                  content: "inline*",
                  group: "block",
                  parseDOM: [{ tag: "p" }],
                  toDOM() {
                    return ["p", 0];
                  }
                },
                text: {
                  group: "inline"
                }
              }
            }),
            plugins: [
              BC({
                "Mod-z": ig,
                "Mod-Z": jc,
                "Mod-y": jc,
                Enter: () => (Sn(this, Ih).value(), !0)
              })
            ]
          })
        });
        return Sn(this, Gl).value = d, Sn(this, Ih).value = () => {
          const { tr: p } = s.state;
          p.setNodeAttribute(h, "value", d.state.doc.textContent), s.dispatch(p), requestAnimationFrame(() => {
            s.focus();
          });
        }, !0;
      })();
      return l || Sn(this, q5).call(this), l;
    }), this.update = (s, o) => {
      Sn(this, hc).update(s, o);
    }, this.destroy = () => {
      Sn(this, Dh).unmount(), Sn(this, hc).destroy(), Sn(this, Eh).remove();
    };
    const i = document.createElement("div");
    i.className = "milkdown-latex-inline-edit", $0(this, Eh, i), $0(this, Dh, ji(Qce, {
      config: r,
      innerView: Sn(this, Gl),
      updateValue: Sn(this, Ih)
    })), Sn(this, Dh).mount(i), $0(this, hc, new mg({
      debounce: 0,
      content: Sn(this, Eh),
      shouldShow: Sn(this, W5),
      offset: 10,
      floatingUIOptions: {
        placement: "bottom"
      }
    })), Sn(this, hc).update(t), $0(this, Up, document.createElement("div"));
  }
}
Eh = /* @__PURE__ */ new WeakMap();
hc = /* @__PURE__ */ new WeakMap();
Up = /* @__PURE__ */ new WeakMap();
Gl = /* @__PURE__ */ new WeakMap();
Ih = /* @__PURE__ */ new WeakMap();
Dh = /* @__PURE__ */ new WeakMap();
q5 = /* @__PURE__ */ new WeakMap();
W5 = /* @__PURE__ */ new WeakMap();
const tue = Qn(
  (n) => Vz(/(?:\$)([^$]+)(?:\$)$/, id.type(n), {
    getAttr: (e) => {
      var t;
      return {
        value: (t = e[1]) != null ? t : ""
      };
    }
  })
), nue = Qn(
  (n) => f3(/^\$\$[\s\n]$/, Ss.type(n), () => ({
    language: "LaTeX"
  }))
), rue = Ts(
  "remarkMath",
  () => jle
);
function iue(n) {
  return kl(
    n,
    "math",
    (e, t, r) => {
      const { value: i } = e, s = {
        type: "code",
        lang: "LaTeX",
        value: i
      };
      r.children.splice(t, 1, s);
    }
  );
}
const sue = Ts(
  "remarkMathBlock",
  () => () => iue
), oue = (n, e) => {
  n.config(Rs(St.Latex)).config((t) => {
    if (!kg(t).get().includes(St.CodeMirror))
      throw new Error("You need to enable CodeMirror to use LaTeX feature");
    t.update(Nd.key, (s) => ({
      ...s,
      renderPreview: (o, l) => {
        if (o.toLowerCase() === "latex" && l.length > 0)
          return lue(l, e?.katexOptions);
        const a = s.renderPreview;
        return a(o, l);
      }
    })), t.set(tS.key, {
      view: (s) => {
        var o;
        return new eue(t, s, {
          inlineEditConfirm: (o = e?.inlineEditConfirm) != null ? o : R7,
          ...e
        });
      }
    });
  }).use(rue).use(sue).use(id).use(tS).use(tue).use(nue).use(Zce).use(mR);
};
function lue(n, e) {
  return AN.renderToString(n, {
    ...e,
    throwOnError: !1,
    displayMode: !0
  });
}
const aue = (n, e) => {
  n.config(Rs(St.LinkTooltip)).config(kae).config((t) => {
    t.update(Jc.key, (r) => {
      var i, s, o, l, a, c;
      return {
        ...r,
        linkIcon: (i = e?.linkIcon) != null ? i : tR,
        editButton: (s = e?.editButton) != null ? s : P7,
        removeButton: (o = e?.removeButton) != null ? o : V5,
        confirmButton: (l = e?.confirmButton) != null ? l : R7,
        inputPlaceholder: (a = e?.inputPlaceholder) != null ? a : "Paste link...",
        onCopyLink: (c = e?.onCopyLink) != null ? c : (() => {
        })
      };
    });
  }).use(Sae);
};
function cue(n, e) {
  n.set(bg.key, {
    renderLabel: ({ label: t, listType: r, checked: i }) => {
      var s, o, l;
      return i == null ? r === "bullet" ? (s = e?.bulletIcon) != null ? s : pce : t : i ? (o = e?.checkBoxCheckedIcon) != null ? o : yce : (l = e?.checkBoxUncheckedIcon) != null ? l : bce;
    }
  });
}
const uue = (n, e) => {
  n.config(Rs(St.ListItem)).config((t) => cue(t, e)).use(Iae);
};
function hue(n) {
  var e;
  return n.childCount <= 1 && !((e = n.firstChild) != null && e.content.size);
}
function fue(n, e) {
  const { selection: t } = n;
  if (!t.empty) return null;
  const r = t.$anchor, i = r.parent;
  if (i.content.size > 0 || gs((l) => l.type.name === "table")(r)) return null;
  const o = r.before();
  return mr.node(o, o + i.nodeSize, {
    class: "crepe-placeholder",
    "data-placeholder": e
  });
}
const j5 = Mt(
  {
    text: "Please enter...",
    mode: "block"
  },
  "placeholderConfigCtx"
), due = kn((n) => new Ut({
  key: new en("CREPE_PLACEHOLDER"),
  props: {
    decorations: (e) => {
      var t;
      if (zce(n).readonly) return null;
      const i = n.get(j5.key);
      if (i.mode === "doc" && !hue(e.doc) || sR(e.selection) || oR(e.selection))
        return null;
      const s = (t = i.text) != null ? t : "Please enter...", o = fue(e, s);
      return o ? It.create(e.doc, [o]) : null;
    }
  }
})), pue = (n, e) => {
  n.config(Rs(St.Placeholder)).config((t) => {
    e && t.update(j5.key, (r) => ({
      ...r,
      ...e
    }));
  }).use(due).use(j5);
}, mue = (n, e) => {
  n.config(Rs(St.Table)).config((t) => {
    t.update(vg.key, (r) => ({
      ...r,
      renderButton: (i) => {
        var s, o, l, a, c, u, h, f, d;
        switch (i) {
          case "add_row":
            return (s = e?.addRowIcon) != null ? s : $5;
          case "add_col":
            return (o = e?.addColIcon) != null ? o : $5;
          case "delete_row":
            return (l = e?.deleteRowIcon) != null ? l : V5;
          case "delete_col":
            return (a = e?.deleteColIcon) != null ? a : V5;
          case "align_col_left":
            return (c = e?.alignLeftIcon) != null ? c : hce;
          case "align_col_center":
            return (u = e?.alignCenterIcon) != null ? u : uce;
          case "align_col_right":
            return (h = e?.alignRightIcon) != null ? h : fce;
          case "col_drag_handle":
            return (f = e?.colDragHandleIcon) != null ? f : Q9;
          case "row_drag_handle":
            return (d = e?.rowDragHandleIcon) != null ? d : Q9;
        }
      }
    }));
  }).use(rce);
};
function gue(n, e) {
  var t, r, i, s, o, l, a;
  const c = new cR();
  c.addGroup("formatting", "Formatting").addItem("bold", {
    icon: (t = n?.boldIcon) != null ? t : dce,
    active: (d) => d.get(Me).call(nc.key, su.type(d)),
    onRun: (d) => {
      d.get(Me).call(B1.key);
    }
  }).addItem("italic", {
    icon: (r = n?.italicIcon) != null ? r : Tce,
    active: (d) => d.get(Me).call(
      nc.key,
      _a.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(L1.key);
    }
  }).addItem("strikethrough", {
    icon: (i = n?.strikethroughIcon) != null ? i : Dce,
    active: (d) => d.get(Me).call(
      nc.key,
      uu.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(X1.key);
    }
  });
  const u = c.addGroup("function", "Function");
  u.addItem("code", {
    icon: (s = n?.codeIcon) != null ? s : eR,
    active: (d) => d.get(Me).call(
      nc.key,
      Qs.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(z1.key);
    }
  });
  const h = e && kg(e).get();
  return h?.includes(St.Latex) && u.addItem("latex", {
    icon: (o = n?.latexIcon) != null ? o : rR,
    active: (d) => d.get(Me).call(
      IO.key,
      id.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(mR.key);
    }
  }), u.addItem("link", {
    icon: (l = n?.linkIcon) != null ? l : Ace,
    active: (d) => d.get(Me).call(nc.key, Ri.type(d)),
    onRun: (d) => {
      d.get(Me).call(ON.key);
    }
  }), (a = n?.buildToolbar) == null || a.call(n, c), c.build();
}
const yue = /* @__PURE__ */ $n({
  props: {
    ctx: {
      type: Object,
      required: !0
    },
    hide: {
      type: Function,
      required: !0
    },
    show: {
      type: Object,
      required: !0
    },
    selection: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !1
    }
  },
  setup(n) {
    const { ctx: e, config: t } = n, r = (o) => (l) => {
      l.preventDefault(), e && o(e);
    };
    function i(o) {
      return n.selection.value, e.get(Q4).status !== om.Created ? !1 : o(e);
    }
    const s = Na(() => gue(t, e));
    return () => /* @__PURE__ */ j(Ln, null, s.value.map((o) => o.items.map((l) => /* @__PURE__ */ j(
      "button",
      {
        type: "button",
        class: Hn(
          "toolbar-item",
          e && i(l.active) && "active"
        ),
        onPointerdown: r(l.onRun)
      },
      /* @__PURE__ */ j(Wc, { icon: l.icon })
    ))).reduce((o, l, a) => (a === 0 ? o.push(...l) : o.push(/* @__PURE__ */ j("div", { class: "divider" }), ...l), o), []));
  }
});
var bR = (n) => {
  throw TypeError(n);
}, vR = (n, e, t) => e.has(n) || bR("Cannot " + t), Hr = (n, e, t) => (vR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Ju = (n, e, t) => e.has(n) ? bR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), V0 = (n, e, t, r) => (vR(n, e, "write to private field"), e.set(n, t), t), Lo, Nh, Kp, Rh, Ph;
const nS = gg("CREPE_TOOLBAR");
class bue {
  constructor(e, t, r) {
    Ju(this, Lo), Ju(this, Nh), Ju(this, Kp), Ju(this, Rh), Ju(this, Ph, Ae(!1)), this.update = (o, l) => {
      Hr(this, Lo).update(o, l), Hr(this, Rh).value = o.state.selection;
    }, this.destroy = () => {
      Hr(this, Lo).destroy(), Hr(this, Kp).unmount(), Hr(this, Nh).remove();
    }, this.hide = () => {
      Hr(this, Lo).hide();
    };
    const i = document.createElement("div");
    i.className = "milkdown-toolbar", V0(this, Rh, Am(t.state.selection));
    const s = ji(yue, {
      ctx: e,
      hide: this.hide,
      config: r,
      selection: Hr(this, Rh),
      show: Hr(this, Ph)
    });
    s.mount(i), V0(this, Nh, i), V0(this, Kp, s), V0(this, Lo, new mg({
      content: Hr(this, Nh),
      debounce: 20,
      offset: 10,
      shouldShow(o) {
        const { doc: l, selection: a } = o.state, { empty: c, from: u, to: h } = a, f = !l.textBetween(u, h).length && a instanceof Ee, d = !(a instanceof Ee), p = o.dom.getRootNode().activeElement, m = i.contains(p), g = !o.hasFocus() && !m, b = !o.editable;
        return !(g || d || c || f || b);
      }
    })), Hr(this, Lo).onShow = () => {
      Hr(this, Ph).value = !0;
    }, Hr(this, Lo).onHide = () => {
      Hr(this, Ph).value = !1;
    }, this.update(t);
  }
}
Lo = /* @__PURE__ */ new WeakMap();
Nh = /* @__PURE__ */ new WeakMap();
Kp = /* @__PURE__ */ new WeakMap();
Rh = /* @__PURE__ */ new WeakMap();
Ph = /* @__PURE__ */ new WeakMap();
const vue = (n, e) => {
  n.config(Rs(St.Toolbar)).config((t) => {
    t.set(nS.key, {
      view: (r) => new bue(t, r, e)
    });
  }).use(nS);
};
function wue(n, e, t) {
  switch (n) {
    case St.CodeMirror:
      return Yce(e, t);
    case St.ListItem:
      return uue(e, t);
    case St.LinkTooltip:
      return aue(e, t);
    case St.ImageBlock:
      return Xce(e, t);
    case St.Cursor:
      return Jce(e, t);
    case St.BlockEdit:
      return Gce(e, t);
    case St.Placeholder:
      return pue(e, t);
    case St.Toolbar:
      return vue(e, t);
    case St.Table:
      return mue(e, t);
    case St.Latex:
      return oue(e, t);
  }
}
var wR = (n) => {
  throw TypeError(n);
}, xR = (n, e, t) => e.has(n) || wR("Cannot " + t), $r = (n, e, t) => (xR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), b4 = (n, e, t) => e.has(n) ? wR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), v4 = (n, e, t, r) => (xR(n, e, "write to private field"), e.set(n, t), t), Vr, Gp, _h;
class xue {
  /// The constructor of the crepe builder.
  /// You can pass configs to the builder to configure the editor.
  constructor({ root: e, defaultValue: t = "" } = {}) {
    b4(this, Vr), b4(this, Gp), b4(this, _h, !0), this.addFeature = (i, s) => (i($r(this, Vr), s), this), this.create = () => $r(this, Vr).create(), this.destroy = () => $r(this, Vr).destroy(), this.setReadonly = (i) => (v4(this, _h, !i), $r(this, Vr).action((s) => {
      $r(this, Vr).status === om.Created && s.get(Ct).setProps({
        editable: () => !i
      });
    }), this), this.getMarkdown = () => $r(this, Vr).action(cG()), this.on = (i) => $r(this, Vr).status !== om.Created ? ($r(this, Vr).config((s) => {
      const o = s.get(Ym);
      i(o);
    }), this) : ($r(this, Vr).action((s) => {
      const o = s.get(Ym);
      i(o);
    }), this);
    var r;
    v4(this, Gp, (r = typeof e == "string" ? document.querySelector(e) : e) != null ? r : document.body), v4(this, Vr, C3.make().config((i) => {
      i.inject(Bce, this), i.inject(Lce, []);
    }).config((i) => {
      i.set(lp, $r(this, Gp)), i.set(rp, t), i.set(Yh, {
        editable: () => $r(this, _h)
      }), i.update(xg.key, (s) => ({
        ...s,
        size: 4
      }));
    }).use(AY).use(JN).use(ice).use(oce).use(ace).use(UN).use(Wte));
  }
  /// Get the milkdown editor instance.
  get editor() {
    return $r(this, Vr);
  }
  /// Get the readonly state of the editor.
  get readonly() {
    return !$r(this, _h);
  }
}
Vr = /* @__PURE__ */ new WeakMap();
Gp = /* @__PURE__ */ new WeakMap();
_h = /* @__PURE__ */ new WeakMap();
class kR extends xue {
  /// The constructor of the crepe editor.
  /// You can pass configs to the editor to configure the editor.
  /// Calling the constructor will not create the editor, you need to call `create` to create the editor.
  constructor({
    features: e = {},
    featureConfigs: t = {},
    ...r
  } = {}) {
    super(r);
    const i = Lq(t, _ce);
    Object.entries({
      ...cce,
      ...e
    }).filter(([, o]) => o).map(([o]) => o).forEach((o) => {
      const l = i[o];
      wue(o, this.editor, l);
    });
  }
}
kR.Feature = St;
const kue = (n, e, t = null) => new kR({
  root: n,
  defaultValue: e
}), Sue = async (n, e = () => {
}) => {
  await n.create(), n.on((t) => {
    t.updated(e);
  });
}, Cue = async (n) => {
  await n.destroy();
}, Mue = (n) => n.getMarkdown(), Tue = (n, e) => {
  n.editor.action(uG(e));
}, Aue = (n, e) => {
  n.editor.action(hG(e));
}, Zue = {
  createEditor: kue,
  create: Sue,
  destroy: Cue,
  getMarkdown: Mue,
  insertMarkdown: Tue,
  replaceMarkdown: Aue
};
export {
  ta as A,
  ct as B,
  fD as C,
  q as D,
  we as E,
  Hc as F,
  HK as G,
  zq as H,
  Zt as I,
  nK as J,
  Zue as K,
  sK as L,
  $ue as N,
  ZM as P,
  oi as T,
  Wy as a,
  Jue as b,
  Gue as c,
  eie as d,
  Fn as e,
  gK as f,
  Uue as g,
  Kue as h,
  DA as i,
  Yue as j,
  Xue as k,
  G as l,
  gr as m,
  st as n,
  I3 as o,
  que as p,
  zt as q,
  mK as r,
  XU as s,
  U as t,
  Tl as u,
  nu as v,
  ci as w,
  EA as x,
  tu as y,
  S1 as z
};
