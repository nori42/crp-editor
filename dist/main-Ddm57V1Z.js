var cS = typeof global == "object" && global && global.Object === Object && global, NR = typeof self == "object" && self && self.Object === Object && self, _a = cS || NR || Function("return this")(), Jp = _a.Symbol, uS = Object.prototype, RR = uS.hasOwnProperty, PR = uS.toString, Ru = Jp ? Jp.toStringTag : void 0;
function _R(n) {
  var e = RR.call(n, Ru), t = n[Ru];
  try {
    n[Ru] = void 0;
    var r = !0;
  } catch {
  }
  var i = PR.call(n);
  return r && (e ? n[Ru] = t : delete n[Ru]), i;
}
var LR = Object.prototype, BR = LR.toString;
function zR(n) {
  return BR.call(n);
}
var FR = "[object Null]", HR = "[object Undefined]", J7 = Jp ? Jp.toStringTag : void 0;
function sd(n) {
  return n == null ? n === void 0 ? HR : FR : J7 && J7 in Object(n) ? _R(n) : zR(n);
}
function Zc(n) {
  return n != null && typeof n == "object";
}
var $R = "[object Symbol]";
function VR(n) {
  return typeof n == "symbol" || Zc(n) && sd(n) == $R;
}
var x4 = Array.isArray, qR = /\s/;
function WR(n) {
  for (var e = n.length; e-- && qR.test(n.charAt(e)); )
    ;
  return e;
}
var jR = /^\s+/;
function UR(n) {
  return n && n.slice(0, WR(n) + 1).replace(jR, "");
}
function Zr(n) {
  var e = typeof n;
  return n != null && (e == "object" || e == "function");
}
var X7 = NaN, KR = /^[-+]0x[0-9a-f]+$/i, GR = /^0b[01]+$/i, YR = /^0o[0-7]+$/i, JR = parseInt;
function Z7(n) {
  if (typeof n == "number")
    return n;
  if (VR(n))
    return X7;
  if (Zr(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = Zr(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = UR(n);
  var t = GR.test(n);
  return t || YR.test(n) ? JR(n.slice(2), t ? 2 : 8) : KR.test(n) ? X7 : +n;
}
function hS(n) {
  return n;
}
var XR = "[object AsyncFunction]", ZR = "[object Function]", QR = "[object GeneratorFunction]", eP = "[object Proxy]";
function Z5(n) {
  if (!Zr(n))
    return !1;
  var e = sd(n);
  return e == ZR || e == QR || e == XR || e == eP;
}
var Cg = _a["__core-js_shared__"], Q7 = (function() {
  var n = /[^.]+$/.exec(Cg && Cg.keys && Cg.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
})();
function tP(n) {
  return !!Q7 && Q7 in n;
}
var nP = Function.prototype, rP = nP.toString;
function iP(n) {
  if (n != null) {
    try {
      return rP.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var sP = /[\\^$.*+?()[\]{}|]/g, oP = /^\[object .+?Constructor\]$/, lP = Function.prototype, aP = Object.prototype, cP = lP.toString, uP = aP.hasOwnProperty, hP = RegExp(
  "^" + cP.call(uP).replace(sP, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function fP(n) {
  if (!Zr(n) || tP(n))
    return !1;
  var e = Z5(n) ? hP : oP;
  return e.test(iP(n));
}
function dP(n, e) {
  return n?.[e];
}
function Q5(n, e) {
  var t = dP(n, e);
  return fP(t) ? t : void 0;
}
var e6 = Object.create, pP = /* @__PURE__ */ (function() {
  function n() {
  }
  return function(e) {
    if (!Zr(e))
      return {};
    if (e6)
      return e6(e);
    n.prototype = e;
    var t = new n();
    return n.prototype = void 0, t;
  };
})();
function fS(n, e, t) {
  switch (t.length) {
    case 0:
      return n.call(e);
    case 1:
      return n.call(e, t[0]);
    case 2:
      return n.call(e, t[0], t[1]);
    case 3:
      return n.call(e, t[0], t[1], t[2]);
  }
  return n.apply(e, t);
}
function mP(n, e) {
  var t = -1, r = n.length;
  for (e || (e = Array(r)); ++t < r; )
    e[t] = n[t];
  return e;
}
var gP = 800, yP = 16, bP = Date.now;
function vP(n) {
  var e = 0, t = 0;
  return function() {
    var r = bP(), i = yP - (r - t);
    if (t = r, i > 0) {
      if (++e >= gP)
        return arguments[0];
    } else
      e = 0;
    return n.apply(void 0, arguments);
  };
}
function wP(n) {
  return function() {
    return n;
  };
}
var Xp = (function() {
  try {
    var n = Q5(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
})(), xP = Xp ? function(n, e) {
  return Xp(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: wP(e),
    writable: !0
  });
} : hS, kP = vP(xP), SP = 9007199254740991, CP = /^(?:0|[1-9]\d*)$/;
function dS(n, e) {
  var t = typeof n;
  return e = e ?? SP, !!e && (t == "number" || t != "symbol" && CP.test(n)) && n > -1 && n % 1 == 0 && n < e;
}
function e3(n, e, t) {
  e == "__proto__" && Xp ? Xp(n, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : n[e] = t;
}
function Xm(n, e) {
  return n === e || n !== n && e !== e;
}
var MP = Object.prototype, TP = MP.hasOwnProperty;
function AP(n, e, t) {
  var r = n[e];
  (!(TP.call(n, e) && Xm(r, t)) || t === void 0 && !(e in n)) && e3(n, e, t);
}
function OP(n, e, t, r) {
  var i = !t;
  t || (t = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var l = e[s], a = void 0;
    a === void 0 && (a = n[l]), i ? e3(t, l, a) : AP(t, l, a);
  }
  return t;
}
var t6 = Math.max;
function EP(n, e, t) {
  return e = t6(e === void 0 ? n.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, s = t6(r.length - e, 0), o = Array(s); ++i < s; )
      o[i] = r[e + i];
    i = -1;
    for (var l = Array(e + 1); ++i < e; )
      l[i] = r[i];
    return l[e] = t(o), fS(n, this, l);
  };
}
function pS(n, e) {
  return kP(EP(n, e, hS), n + "");
}
var IP = 9007199254740991;
function mS(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= IP;
}
function t3(n) {
  return n != null && mS(n.length) && !Z5(n);
}
function DP(n, e, t) {
  if (!Zr(t))
    return !1;
  var r = typeof e;
  return (r == "number" ? t3(t) && dS(e, t.length) : r == "string" && e in t) ? Xm(t[e], n) : !1;
}
function NP(n) {
  return pS(function(e, t) {
    var r = -1, i = t.length, s = i > 1 ? t[i - 1] : void 0, o = i > 2 ? t[2] : void 0;
    for (s = n.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && DP(t[0], t[1], o) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i; ) {
      var l = t[r];
      l && n(e, l, r, s);
    }
    return e;
  });
}
var RP = Object.prototype;
function gS(n) {
  var e = n && n.constructor, t = typeof e == "function" && e.prototype || RP;
  return n === t;
}
function PP(n, e) {
  for (var t = -1, r = Array(n); ++t < n; )
    r[t] = e(t);
  return r;
}
var _P = "[object Arguments]";
function n6(n) {
  return Zc(n) && sd(n) == _P;
}
var yS = Object.prototype, LP = yS.hasOwnProperty, BP = yS.propertyIsEnumerable, k4 = n6(/* @__PURE__ */ (function() {
  return arguments;
})()) ? n6 : function(n) {
  return Zc(n) && LP.call(n, "callee") && !BP.call(n, "callee");
};
function zP() {
  return !1;
}
var bS = typeof exports == "object" && exports && !exports.nodeType && exports, r6 = bS && typeof module == "object" && module && !module.nodeType && module, FP = r6 && r6.exports === bS, i6 = FP ? _a.Buffer : void 0, HP = i6 ? i6.isBuffer : void 0, vS = HP || zP, $P = "[object Arguments]", VP = "[object Array]", qP = "[object Boolean]", WP = "[object Date]", jP = "[object Error]", UP = "[object Function]", KP = "[object Map]", GP = "[object Number]", YP = "[object Object]", JP = "[object RegExp]", XP = "[object Set]", ZP = "[object String]", QP = "[object WeakMap]", e_ = "[object ArrayBuffer]", t_ = "[object DataView]", n_ = "[object Float32Array]", r_ = "[object Float64Array]", i_ = "[object Int8Array]", s_ = "[object Int16Array]", o_ = "[object Int32Array]", l_ = "[object Uint8Array]", a_ = "[object Uint8ClampedArray]", c_ = "[object Uint16Array]", u_ = "[object Uint32Array]", Ht = {};
Ht[n_] = Ht[r_] = Ht[i_] = Ht[s_] = Ht[o_] = Ht[l_] = Ht[a_] = Ht[c_] = Ht[u_] = !0;
Ht[$P] = Ht[VP] = Ht[e_] = Ht[qP] = Ht[t_] = Ht[WP] = Ht[jP] = Ht[UP] = Ht[KP] = Ht[GP] = Ht[YP] = Ht[JP] = Ht[XP] = Ht[ZP] = Ht[QP] = !1;
function h_(n) {
  return Zc(n) && mS(n.length) && !!Ht[sd(n)];
}
function f_(n) {
  return function(e) {
    return n(e);
  };
}
var wS = typeof exports == "object" && exports && !exports.nodeType && exports, Lh = wS && typeof module == "object" && module && !module.nodeType && module, d_ = Lh && Lh.exports === wS, Mg = d_ && cS.process, s6 = (function() {
  try {
    var n = Lh && Lh.require && Lh.require("util").types;
    return n || Mg && Mg.binding && Mg.binding("util");
  } catch {
  }
})(), o6 = s6 && s6.isTypedArray, xS = o6 ? f_(o6) : h_;
function p_(n, e) {
  var t = x4(n), r = !t && k4(n), i = !t && !r && vS(n), s = !t && !r && !i && xS(n), o = t || r || i || s, l = o ? PP(n.length, String) : [], a = l.length;
  for (var c in n)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    dS(c, a)) || l.push(c);
  return l;
}
function m_(n, e) {
  return function(t) {
    return n(e(t));
  };
}
function g_(n) {
  var e = [];
  if (n != null)
    for (var t in Object(n))
      e.push(t);
  return e;
}
var y_ = Object.prototype, b_ = y_.hasOwnProperty;
function v_(n) {
  if (!Zr(n))
    return g_(n);
  var e = gS(n), t = [];
  for (var r in n)
    r == "constructor" && (e || !b_.call(n, r)) || t.push(r);
  return t;
}
function kS(n) {
  return t3(n) ? p_(n) : v_(n);
}
var yf = Q5(Object, "create");
function w_() {
  this.__data__ = yf ? yf(null) : {}, this.size = 0;
}
function x_(n) {
  var e = this.has(n) && delete this.__data__[n];
  return this.size -= e ? 1 : 0, e;
}
var k_ = "__lodash_hash_undefined__", S_ = Object.prototype, C_ = S_.hasOwnProperty;
function M_(n) {
  var e = this.__data__;
  if (yf) {
    var t = e[n];
    return t === k_ ? void 0 : t;
  }
  return C_.call(e, n) ? e[n] : void 0;
}
var T_ = Object.prototype, A_ = T_.hasOwnProperty;
function O_(n) {
  var e = this.__data__;
  return yf ? e[n] !== void 0 : A_.call(e, n);
}
var E_ = "__lodash_hash_undefined__";
function I_(n, e) {
  var t = this.__data__;
  return this.size += this.has(n) ? 0 : 1, t[n] = yf && e === void 0 ? E_ : e, this;
}
function ba(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
ba.prototype.clear = w_;
ba.prototype.delete = x_;
ba.prototype.get = M_;
ba.prototype.has = O_;
ba.prototype.set = I_;
function D_() {
  this.__data__ = [], this.size = 0;
}
function Zm(n, e) {
  for (var t = n.length; t--; )
    if (Xm(n[t][0], e))
      return t;
  return -1;
}
var N_ = Array.prototype, R_ = N_.splice;
function P_(n) {
  var e = this.__data__, t = Zm(e, n);
  if (t < 0)
    return !1;
  var r = e.length - 1;
  return t == r ? e.pop() : R_.call(e, t, 1), --this.size, !0;
}
function __(n) {
  var e = this.__data__, t = Zm(e, n);
  return t < 0 ? void 0 : e[t][1];
}
function L_(n) {
  return Zm(this.__data__, n) > -1;
}
function B_(n, e) {
  var t = this.__data__, r = Zm(t, n);
  return r < 0 ? (++this.size, t.push([n, e])) : t[r][1] = e, this;
}
function vo(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
vo.prototype.clear = D_;
vo.prototype.delete = P_;
vo.prototype.get = __;
vo.prototype.has = L_;
vo.prototype.set = B_;
var SS = Q5(_a, "Map");
function z_() {
  this.size = 0, this.__data__ = {
    hash: new ba(),
    map: new (SS || vo)(),
    string: new ba()
  };
}
function F_(n) {
  var e = typeof n;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null;
}
function Qm(n, e) {
  var t = n.__data__;
  return F_(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function H_(n) {
  var e = Qm(this, n).delete(n);
  return this.size -= e ? 1 : 0, e;
}
function $_(n) {
  return Qm(this, n).get(n);
}
function V_(n) {
  return Qm(this, n).has(n);
}
function q_(n, e) {
  var t = Qm(this, n), r = t.size;
  return t.set(n, e), this.size += t.size == r ? 0 : 1, this;
}
function Qc(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
Qc.prototype.clear = z_;
Qc.prototype.delete = H_;
Qc.prototype.get = $_;
Qc.prototype.has = V_;
Qc.prototype.set = q_;
var CS = m_(Object.getPrototypeOf, Object), W_ = "[object Object]", j_ = Function.prototype, U_ = Object.prototype, MS = j_.toString, K_ = U_.hasOwnProperty, G_ = MS.call(Object);
function Y_(n) {
  if (!Zc(n) || sd(n) != W_)
    return !1;
  var e = CS(n);
  if (e === null)
    return !0;
  var t = K_.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && MS.call(t) == G_;
}
function J_() {
  this.__data__ = new vo(), this.size = 0;
}
function X_(n) {
  var e = this.__data__, t = e.delete(n);
  return this.size = e.size, t;
}
function Z_(n) {
  return this.__data__.get(n);
}
function Q_(n) {
  return this.__data__.has(n);
}
var eL = 200;
function tL(n, e) {
  var t = this.__data__;
  if (t instanceof vo) {
    var r = t.__data__;
    if (!SS || r.length < eL - 1)
      return r.push([n, e]), this.size = ++t.size, this;
    t = this.__data__ = new Qc(r);
  }
  return t.set(n, e), this.size = t.size, this;
}
function eu(n) {
  var e = this.__data__ = new vo(n);
  this.size = e.size;
}
eu.prototype.clear = J_;
eu.prototype.delete = X_;
eu.prototype.get = Z_;
eu.prototype.has = Q_;
eu.prototype.set = tL;
var TS = typeof exports == "object" && exports && !exports.nodeType && exports, l6 = TS && typeof module == "object" && module && !module.nodeType && module, nL = l6 && l6.exports === TS, a6 = nL ? _a.Buffer : void 0;
a6 && a6.allocUnsafe;
function rL(n, e) {
  return n.slice();
}
var c6 = _a.Uint8Array;
function iL(n) {
  var e = new n.constructor(n.byteLength);
  return new c6(e).set(new c6(n)), e;
}
function sL(n, e) {
  var t = iL(n.buffer);
  return new n.constructor(t, n.byteOffset, n.length);
}
function oL(n) {
  return typeof n.constructor == "function" && !gS(n) ? pP(CS(n)) : {};
}
function lL(n) {
  return function(e, t, r) {
    for (var i = -1, s = Object(e), o = r(e), l = o.length; l--; ) {
      var a = o[++i];
      if (t(s[a], a, s) === !1)
        break;
    }
    return e;
  };
}
var aL = lL(), Tg = function() {
  return _a.Date.now();
}, cL = "Expected a function", uL = Math.max, hL = Math.min;
function e1(n, e, t) {
  var r, i, s, o, l, a, c = 0, u = !1, h = !1, f = !0;
  if (typeof n != "function")
    throw new TypeError(cL);
  e = Z7(e) || 0, Zr(t) && (u = !!t.leading, h = "maxWait" in t, s = h ? uL(Z7(t.maxWait) || 0, e) : s, f = "trailing" in t ? !!t.trailing : f);
  function d(T) {
    var N = r, B = i;
    return r = i = void 0, c = T, o = n.apply(B, N), o;
  }
  function p(T) {
    return c = T, l = setTimeout(b, e), u ? d(T) : o;
  }
  function m(T) {
    var N = T - a, B = T - c, $ = e - N;
    return h ? hL($, s - B) : $;
  }
  function g(T) {
    var N = T - a, B = T - c;
    return a === void 0 || N >= e || N < 0 || h && B >= s;
  }
  function b() {
    var T = Tg();
    if (g(T))
      return w(T);
    l = setTimeout(b, m(T));
  }
  function w(T) {
    return l = void 0, f && r ? d(T) : (r = i = void 0, o);
  }
  function k() {
    l !== void 0 && clearTimeout(l), c = 0, r = a = i = l = void 0;
  }
  function C() {
    return l === void 0 ? o : w(Tg());
  }
  function M() {
    var T = Tg(), N = g(T);
    if (r = arguments, i = this, a = T, N) {
      if (l === void 0)
        return p(a);
      if (h)
        return clearTimeout(l), l = setTimeout(b, e), d(a);
    }
    return l === void 0 && (l = setTimeout(b, e)), o;
  }
  return M.cancel = k, M.flush = C, M;
}
function S4(n, e, t) {
  (t !== void 0 && !Xm(n[e], t) || t === void 0 && !(e in n)) && e3(n, e, t);
}
function fL(n) {
  return Zc(n) && t3(n);
}
function C4(n, e) {
  if (!(e === "constructor" && typeof n[e] == "function") && e != "__proto__")
    return n[e];
}
function dL(n) {
  return OP(n, kS(n));
}
function pL(n, e, t, r, i, s, o) {
  var l = C4(n, t), a = C4(e, t), c = o.get(a);
  if (c) {
    S4(n, t, c);
    return;
  }
  var u = s ? s(l, a, t + "", n, e, o) : void 0, h = u === void 0;
  if (h) {
    var f = x4(a), d = !f && vS(a), p = !f && !d && xS(a);
    u = a, f || d || p ? x4(l) ? u = l : fL(l) ? u = mP(l) : d ? (h = !1, u = rL(a)) : p ? (h = !1, u = sL(a)) : u = [] : Y_(a) || k4(a) ? (u = l, k4(l) ? u = dL(l) : (!Zr(l) || Z5(l)) && (u = oL(a))) : h = !1;
  }
  h && (o.set(a, u), i(u, a, r, s, o), o.delete(a)), S4(n, t, u);
}
function n3(n, e, t, r, i) {
  n !== e && aL(e, function(s, o) {
    if (i || (i = new eu()), Zr(s))
      pL(n, e, o, t, n3, r, i);
    else {
      var l = r ? r(C4(n, o), s, o + "", n, e, i) : void 0;
      l === void 0 && (l = s), S4(n, o, l);
    }
  }, kS);
}
function AS(n, e, t, r, i, s) {
  return Zr(n) && Zr(e) && (s.set(e, n), n3(n, e, void 0, AS, s), s.delete(e)), n;
}
var mL = NP(function(n, e, t, r) {
  n3(n, e, t, r);
}), gL = pS(function(n) {
  return n.push(void 0, AS), fS(mL, void 0, n);
}), yL = "Expected a function";
function t1(n, e, t) {
  var r = !0, i = !0;
  if (typeof n != "function")
    throw new TypeError(yL);
  return Zr(t) && (r = "leading" in t ? !!t.leading : r, i = "trailing" in t ? !!t.trailing : i), e1(n, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
const bL = 1024;
let vL = 0, ai = class {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
};
class st {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = vL++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Qr.match(e)), (t) => {
      let r = e(t);
      return r === void 0 ? null : [this, r];
    };
  }
}
st.closedBy = new st({ deserialize: (n) => n.split(" ") });
st.openedBy = new st({ deserialize: (n) => n.split(" ") });
st.group = new st({ deserialize: (n) => n.split(" ") });
st.isolate = new st({ deserialize: (n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
} });
st.contextHash = new st({ perNode: !0 });
st.lookAhead = new st({ perNode: !0 });
st.mounted = new st({ perNode: !0 });
class bf {
  constructor(e, t, r) {
    this.tree = e, this.overlay = t, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[st.mounted.id];
  }
}
const wL = /* @__PURE__ */ Object.create(null);
let Qr = class OS {
  /**
  @internal
  */
  constructor(e, t, r, i = 0) {
    this.name = e, this.props = t, this.id = r, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : wL, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new OS(e.name || "", t, e.id, r);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[s[0].id] = s[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(st.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let i of r.split(" "))
        t[i] = e[r];
    return (r) => {
      for (let i = r.prop(st.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = t[s < 0 ? r.name : i[s]];
        if (o)
          return o;
      }
    };
  }
};
Qr.none = new Qr(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class r3 {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let r of this.types) {
      let i = null;
      for (let s of e) {
        let o = s(r);
        o && (i || (i = Object.assign({}, r.props)), i[o[0].id] = o[1]);
      }
      t.push(i ? new Qr(r.name, i, r.id, r.flags) : r);
    }
    return new r3(t);
  }
}
const jd = /* @__PURE__ */ new WeakMap(), u6 = /* @__PURE__ */ new WeakMap();
var Zt;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Zt || (Zt = {}));
class Bt {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, r, i, s) {
    if (this.type = e, this.children = t, this.positions = r, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of s)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = bf.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (t && (t += ","), t += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Zp(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, r = 0) {
    let i = jd.get(this) || this.topNode, s = new Zp(i);
    return s.moveTo(e, t), jd.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Gn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let r = vf(jd.get(this) || this.topNode, e, t, !1);
    return jd.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let r = vf(u6.get(this) || this.topNode, e, t, !0);
    return u6.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return SL(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: r, from: i = 0, to: s = this.length } = e, o = e.mode || 0, l = (o & Zt.IncludeAnonymous) > 0;
    for (let a = this.cursor(o | Zt.IncludeAnonymous); ; ) {
      let c = !1;
      if (a.from <= s && a.to >= i && (!l && a.type.isAnonymous || t(a) !== !1)) {
        if (a.firstChild())
          continue;
        c = !0;
      }
      for (; c && r && (l || !a.type.isAnonymous) && r(a), !a.nextSibling(); ) {
        if (!a.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : o3(Qr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, r, i) => new Bt(this.type, t, r, i, this.propValues), e.makeTree || ((t, r, i) => new Bt(Qr.none, t, r, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return CL(e);
  }
}
Bt.empty = new Bt(Qr.none, [], [], 0);
class i3 {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new i3(this.buffer, this.index);
  }
}
class cl {
  /**
  Create a tree buffer.
  */
  constructor(e, t, r) {
    this.buffer = e, this.length = t, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return Qr.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[t], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, r == e)
      return s;
    let o = [];
    for (; e < r; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, r, i, s) {
    let { buffer: o } = this, l = -1;
    for (let a = e; a != t && !(ES(s, i, o[a + 1], o[a + 2]) && (l = a, r > 0)); a = o[a + 3])
      ;
    return l;
  }
  /**
  @internal
  */
  slice(e, t, r) {
    let i = this.buffer, s = new Uint16Array(t - e), o = 0;
    for (let l = e, a = 0; l < t; ) {
      s[a++] = i[l++], s[a++] = i[l++] - r;
      let c = s[a++] = i[l++] - r;
      s[a++] = i[l++] - e, o = Math.max(o, c);
    }
    return new cl(s, o, this.set);
  }
}
function ES(n, e, t, r) {
  switch (n) {
    case -2:
      return t < e;
    case -1:
      return r >= e && t < e;
    case 0:
      return t < e && r > e;
    case 1:
      return t <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function vf(n, e, t, r) {
  for (var i; n.from == n.to || (t < 1 ? n.from >= e : n.from > e) || (t > -1 ? n.to <= e : n.to < e); ) {
    let o = !r && n instanceof Gn && n.index < 0 ? null : n.parent;
    if (!o)
      return n;
    n = o;
  }
  let s = r ? 0 : Zt.IgnoreOverlays;
  if (r)
    for (let o = n, l = o.parent; l; o = l, l = o.parent)
      o instanceof Gn && o.index < 0 && ((i = l.enter(e, t, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (n = l);
  for (; ; ) {
    let o = n.enter(e, t, s);
    if (!o)
      return n;
    n = o;
  }
}
class IS {
  cursor(e = 0) {
    return new Zp(this, e);
  }
  getChild(e, t = null, r = null) {
    let i = h6(this, e, t, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, t = null, r = null) {
    return h6(this, e, t, r);
  }
  resolve(e, t = 0) {
    return vf(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return vf(this, e, t, !0);
  }
  matchContext(e) {
    return M4(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), r = this;
    for (; t; ) {
      let i = t.lastChild;
      if (!i || i.to != t.to)
        break;
      i.type.isError && i.from == i.to ? (r = t, t = i.prevSibling) : t = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Gn extends IS {
  constructor(e, t, r, i) {
    super(), this._tree = e, this.from = t, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, r, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: a } = o._tree, c = t > 0 ? l.length : -1; e != c; e += t) {
        let u = l[e], h = a[e] + o.from;
        if (ES(i, r, h, h + u.length)) {
          if (u instanceof cl) {
            if (s & Zt.ExcludeBuffers)
              continue;
            let f = u.findChild(0, u.buffer.length, t, r - h, i);
            if (f > -1)
              return new hs(new xL(o, u, e, h), null, f);
          } else if (s & Zt.IncludeAnonymous || !u.type.isAnonymous || s3(u)) {
            let f;
            if (!(s & Zt.IgnoreMounts) && (f = bf.get(u)) && !f.overlay)
              return new Gn(f.tree, h, e, o);
            let d = new Gn(u, h, e, o);
            return s & Zt.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(t < 0 ? u.children.length - 1 : 0, t, r, i);
          }
        }
      }
      if (s & Zt.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    let i;
    if (!(r & Zt.IgnoreOverlays) && (i = bf.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: l } of i.overlay)
        if ((t > 0 ? o <= s : o < s) && (t < 0 ? l >= s : l > s))
          return new Gn(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function h6(n, e, t, r) {
  let i = n.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (t != null) {
    for (let o = !1; !o; )
      if (o = i.type.is(t), !i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return r == null ? s : [];
  }
}
function M4(n, e, t = e.length - 1) {
  for (let r = n; t >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[t] && e[t] != r.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class xL {
  constructor(e, t, r, i) {
    this.parent = e, this.buffer = t, this.index = r, this.start = i;
  }
}
class hs extends IS {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, r) {
    super(), this.context = e, this._parent = t, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, t, r) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.context.start, r);
    return s < 0 ? null : new hs(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    if (r & Zt.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return s < 0 ? null : new hs(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new hs(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new hs(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: r } = this.context, i = this.index + 4, s = r.buffer[this.index + 3];
    if (s > i) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(i, s, o)), t.push(0);
    }
    return new Bt(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function DS(n) {
  if (!n.length)
    return null;
  let e = 0, t = n[0];
  for (let s = 1; s < n.length; s++) {
    let o = n[s];
    (o.from > t.from || o.to < t.to) && (t = o, e = s);
  }
  let r = t instanceof Gn && t.index < 0 ? null : t.parent, i = n.slice();
  return r ? i[e] = r : i.splice(e, 1), new kL(i, t);
}
class kL {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return DS(this.heads);
  }
}
function SL(n, e, t) {
  let r = n.resolveInner(e, t), i = null;
  for (let s = r instanceof Gn ? r : r.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [r])).push(o.resolve(e, t)), s = o;
    } else {
      let o = bf.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let l = new Gn(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [r])).push(vf(l, e, t, !1));
      }
    }
  return i ? DS(i) : r;
}
class Zp {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Gn)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return this.type = t || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Gn ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, r, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.buffer.start, r);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, r = this.mode) {
    return this.buffer ? r & Zt.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Zt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Zt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(t.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = t.buffer[this.index + 3];
      if (i < (r < 0 ? t.buffer.length : t.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, r, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: t, parent: r } = i);
    } else
      ({ index: t, _parent: r } = this._tree);
    for (; r; { index: t, _parent: r } = r)
      if (t > -1)
        for (let s = t + e, o = e < 0 ? -1 : r._tree.children.length; s != o; s += e) {
          let l = r._tree.children[s];
          if (this.mode & Zt.IncludeAnonymous || l instanceof cl || !l.type.isAnonymous || s3(l))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, r = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == i) {
            if (i == this.index)
              return o;
            t = o, r = s + 1;
            break e;
          }
        i = this.stack[--s];
      }
    for (let i = r; i < this.stack.length; i++)
      t = new hs(this.buffer, t, this.stack[i]);
    return this.bufferNode = new hs(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && t && t(this), i = this.type.isAnonymous, !r)
          return;
        if (this.nextSibling())
          break;
        this.parent(), r--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return M4(this.node.parent, e);
    let { buffer: t } = this.buffer, { types: r } = t.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return M4(this._tree, e, i);
      let o = r[t.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function s3(n) {
  return n.children.some((e) => e instanceof cl || !e.type.isAnonymous || s3(e));
}
function CL(n) {
  var e;
  let { buffer: t, nodeSet: r, maxBufferLength: i = bL, reused: s = [], minRepeatType: o = r.types.length } = n, l = Array.isArray(t) ? new i3(t, t.length) : t, a = r.types, c = 0, u = 0;
  function h(M, T, N, B, $, R) {
    let { id: V, start: z, end: ue, size: ie } = l, he = u, Se = c;
    for (; ie < 0; )
      if (l.next(), ie == -1) {
        let Ie = s[V];
        N.push(Ie), B.push(z - M);
        return;
      } else if (ie == -3) {
        c = V;
        return;
      } else if (ie == -4) {
        u = V;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${ie}`);
    let ge = a[V], ye, ze, I = z - M;
    if (ue - z <= i && (ze = g(l.pos - T, $))) {
      let Ie = new Uint16Array(ze.size - ze.skip), Ve = l.pos - ze.size, O = Ie.length;
      for (; l.pos > Ve; )
        O = b(ze.start, Ie, O);
      ye = new cl(Ie, ue - ze.start, r), I = ze.start - M;
    } else {
      let Ie = l.pos - ie;
      l.next();
      let Ve = [], O = [], dt = V >= o ? V : -1, Ue = 0, et = ue;
      for (; l.pos > Ie; )
        dt >= 0 && l.id == dt && l.size >= 0 ? (l.end <= et - i && (p(Ve, O, z, Ue, l.end, et, dt, he, Se), Ue = Ve.length, et = l.end), l.next()) : R > 2500 ? f(z, Ie, Ve, O) : h(z, Ie, Ve, O, dt, R + 1);
      if (dt >= 0 && Ue > 0 && Ue < Ve.length && p(Ve, O, z, Ue, z, et, dt, he, Se), Ve.reverse(), O.reverse(), dt > -1 && Ue > 0) {
        let Mt = d(ge, Se);
        ye = o3(ge, Ve, O, 0, Ve.length, 0, ue - z, Mt, Mt);
      } else
        ye = m(ge, Ve, O, ue - z, he - ue, Se);
    }
    N.push(ye), B.push(I);
  }
  function f(M, T, N, B) {
    let $ = [], R = 0, V = -1;
    for (; l.pos > T; ) {
      let { id: z, start: ue, end: ie, size: he } = l;
      if (he > 4)
        l.next();
      else {
        if (V > -1 && ue < V)
          break;
        V < 0 && (V = ie - i), $.push(z, ue, ie), R++, l.next();
      }
    }
    if (R) {
      let z = new Uint16Array(R * 4), ue = $[$.length - 2];
      for (let ie = $.length - 3, he = 0; ie >= 0; ie -= 3)
        z[he++] = $[ie], z[he++] = $[ie + 1] - ue, z[he++] = $[ie + 2] - ue, z[he++] = he;
      N.push(new cl(z, $[2] - ue, r)), B.push(ue - M);
    }
  }
  function d(M, T) {
    return (N, B, $) => {
      let R = 0, V = N.length - 1, z, ue;
      if (V >= 0 && (z = N[V]) instanceof Bt) {
        if (!V && z.type == M && z.length == $)
          return z;
        (ue = z.prop(st.lookAhead)) && (R = B[V] + z.length + ue);
      }
      return m(M, N, B, $, R, T);
    };
  }
  function p(M, T, N, B, $, R, V, z, ue) {
    let ie = [], he = [];
    for (; M.length > B; )
      ie.push(M.pop()), he.push(T.pop() + N - $);
    M.push(m(r.types[V], ie, he, R - $, z - R, ue)), T.push($ - N);
  }
  function m(M, T, N, B, $, R, V) {
    if (R) {
      let z = [st.contextHash, R];
      V = V ? [z].concat(V) : [z];
    }
    if ($ > 25) {
      let z = [st.lookAhead, $];
      V = V ? [z].concat(V) : [z];
    }
    return new Bt(M, T, N, B, V);
  }
  function g(M, T) {
    let N = l.fork(), B = 0, $ = 0, R = 0, V = N.end - i, z = { size: 0, start: 0, skip: 0 };
    e: for (let ue = N.pos - M; N.pos > ue; ) {
      let ie = N.size;
      if (N.id == T && ie >= 0) {
        z.size = B, z.start = $, z.skip = R, R += 4, B += 4, N.next();
        continue;
      }
      let he = N.pos - ie;
      if (ie < 0 || he < ue || N.start < V)
        break;
      let Se = N.id >= o ? 4 : 0, ge = N.start;
      for (N.next(); N.pos > he; ) {
        if (N.size < 0)
          if (N.size == -3)
            Se += 4;
          else
            break e;
        else N.id >= o && (Se += 4);
        N.next();
      }
      $ = ge, B += ie, R += Se;
    }
    return (T < 0 || B == M) && (z.size = B, z.start = $, z.skip = R), z.size > 4 ? z : void 0;
  }
  function b(M, T, N) {
    let { id: B, start: $, end: R, size: V } = l;
    if (l.next(), V >= 0 && B < o) {
      let z = N;
      if (V > 4) {
        let ue = l.pos - (V - 4);
        for (; l.pos > ue; )
          N = b(M, T, N);
      }
      T[--N] = z, T[--N] = R - M, T[--N] = $ - M, T[--N] = B;
    } else V == -3 ? c = B : V == -4 && (u = B);
    return N;
  }
  let w = [], k = [];
  for (; l.pos > 0; )
    h(n.start || 0, n.bufferStart || 0, w, k, -1, 0);
  let C = (e = n.length) !== null && e !== void 0 ? e : w.length ? k[0] + w[0].length : 0;
  return new Bt(a[n.topID], w.reverse(), k.reverse(), C);
}
const f6 = /* @__PURE__ */ new WeakMap();
function W0(n, e) {
  if (!n.isAnonymous || e instanceof cl || e.type != n)
    return 1;
  let t = f6.get(e);
  if (t == null) {
    t = 1;
    for (let r of e.children) {
      if (r.type != n || !(r instanceof Bt)) {
        t = 1;
        break;
      }
      t += W0(n, r);
    }
    f6.set(e, t);
  }
  return t;
}
function o3(n, e, t, r, i, s, o, l, a) {
  let c = 0;
  for (let p = r; p < i; p++)
    c += W0(n, e[p]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], f = [];
  function d(p, m, g, b, w) {
    for (let k = g; k < b; ) {
      let C = k, M = m[k], T = W0(n, p[k]);
      for (k++; k < b; k++) {
        let N = W0(n, p[k]);
        if (T + N >= u)
          break;
        T += N;
      }
      if (k == C + 1) {
        if (T > u) {
          let N = p[C];
          d(N.children, N.positions, 0, N.children.length, m[C] + w);
          continue;
        }
        h.push(p[C]);
      } else {
        let N = m[k - 1] + p[k - 1].length - M;
        h.push(o3(n, p, m, C, k, M, N, null, a));
      }
      f.push(M + w - s);
    }
  }
  return d(e, t, r, i, 0), (l || a)(h, f, o);
}
class Rue {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, r) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(t, r);
  }
  getBuffer(e, t) {
    let r = this.map.get(e);
    return r && r.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof hs ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof Gn && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof hs ? this.getBuffer(e.context.buffer, e.index) : e instanceof Gn ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class to {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, r, i, s = !1, o = !1) {
    this.from = e, this.to = t, this.tree = r, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], r = !1) {
    let i = [new to(0, e.length, e, 0, !1, r)];
    for (let s of t)
      s.to > e.length && i.push(s);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, r = 128) {
    if (!t.length)
      return e;
    let i = [], s = 1, o = e.length ? e[0] : null;
    for (let l = 0, a = 0, c = 0; ; l++) {
      let u = l < t.length ? t[l] : null, h = u ? u.fromA : 1e9;
      if (h - a >= r)
        for (; o && o.from < h; ) {
          let f = o;
          if (a >= f.from || h <= f.to || c) {
            let d = Math.max(f.from, a) - c, p = Math.min(f.to, h) - c;
            f = d >= p ? null : new to(d, p, f.tree, f.offset + c, l > 0, !!u);
          }
          if (f && i.push(f), o.to > h)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!u)
        break;
      a = u.toA, c = u.toA - u.toB;
    }
    return i;
  }
}
let NS = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, r) {
    return typeof e == "string" && (e = new ML(e)), r = r ? r.length ? r.map((i) => new ai(i.from, i.to)) : [new ai(0, 0)] : [new ai(0, e.length)], this.createParse(e, t || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, r) {
    let i = this.startParse(e, t, r);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
};
class ML {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function _ue(n) {
  return (e, t, r, i) => new AL(e, n, t, r, i);
}
class d6 {
  constructor(e, t, r, i, s) {
    this.parser = e, this.parse = t, this.overlay = r, this.target = i, this.from = s;
  }
}
function p6(n) {
  if (!n.length || n.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(n));
}
class TL {
  constructor(e, t, r, i, s, o, l) {
    this.parser = e, this.predicate = t, this.mounts = r, this.index = i, this.start = s, this.target = o, this.prev = l, this.depth = 0, this.ranges = [];
  }
}
const T4 = new st({ perNode: !0 });
class AL {
  constructor(e, t, r, i, s) {
    this.nest = t, this.input = r, this.fragments = i, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new Bt(r.type, r.children, r.positions, r.length, r.propValues.concat([[T4, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[st.mounted.id] = new bf(t, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new IL(this.fragments), t = null, r = null, i = new Zp(new Gn(this.baseTree, this.ranges[0].from, 0, null), Zt.IncludeAnonymous | Zt.IgnoreMounts);
    e: for (let s, o; ; ) {
      let l = !0, a;
      if (this.stoppedAt != null && i.from >= this.stoppedAt)
        l = !1;
      else if (e.hasNode(i)) {
        if (t) {
          let c = t.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
          if (c)
            for (let u of c.mount.overlay) {
              let h = u.from + c.pos, f = u.to + c.pos;
              h >= i.from && f <= i.to && !t.ranges.some((d) => d.from < f && d.to > h) && t.ranges.push({ from: h, to: f });
            }
        }
        l = !1;
      } else if (r && (o = OL(r.ranges, i.from, i.to)))
        l = o != 2;
      else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
        i.tree || EL(i);
        let c = e.findMounts(i.from, s.parser);
        if (typeof s.overlay == "function")
          t = new TL(s.parser, s.overlay, c, this.inner.length, i.from, i.tree, t);
        else {
          let u = y6(this.ranges, s.overlay || (i.from < i.to ? [new ai(i.from, i.to)] : []));
          u.length && p6(u), (u.length || !s.overlay) && this.inner.push(new d6(s.parser, u.length ? s.parser.startParse(this.input, b6(c, u), u) : s.parser.startParse(""), s.overlay ? s.overlay.map((h) => new ai(h.from - i.from, h.to - i.from)) : null, i.tree, u.length ? u[0].from : i.from)), s.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : l = !1;
        }
      } else if (t && (a = t.predicate(i)) && (a === !0 && (a = new ai(i.from, i.to)), a.from < a.to)) {
        let c = t.ranges.length - 1;
        c >= 0 && t.ranges[c].to == a.from ? t.ranges[c] = { from: t.ranges[c].from, to: a.to } : t.ranges.push(a);
      }
      if (l && i.firstChild())
        t && t.depth++, r && r.depth++;
      else
        for (; !i.nextSibling(); ) {
          if (!i.parent())
            break e;
          if (t && !--t.depth) {
            let c = y6(this.ranges, t.ranges);
            c.length && (p6(c), this.inner.splice(t.index, 0, new d6(t.parser, t.parser.startParse(this.input, b6(t.mounts, c), c), t.ranges.map((u) => new ai(u.from - t.start, u.to - t.start)), t.target, c[0].from))), t = t.prev;
          }
          r && !--r.depth && (r = r.prev);
        }
    }
  }
}
function OL(n, e, t) {
  for (let r of n) {
    if (r.from >= t)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= t ? 2 : 1;
  }
  return 0;
}
function m6(n, e, t, r, i, s) {
  if (e < t) {
    let o = n.buffer[e + 1];
    r.push(n.slice(e, t, o)), i.push(o - s);
  }
}
function EL(n) {
  let { node: e } = n, t = [], r = e.context.buffer;
  do
    t.push(n.index), n.parent();
  while (!n.tree);
  let i = n.tree, s = i.children.indexOf(r), o = i.children[s], l = o.buffer, a = [s];
  function c(u, h, f, d, p, m) {
    let g = t[m], b = [], w = [];
    m6(o, u, g, b, w, d);
    let k = l[g + 1], C = l[g + 2];
    a.push(b.length);
    let M = m ? c(g + 4, l[g + 3], o.set.types[l[g]], k, C - k, m - 1) : e.toTree();
    return b.push(M), w.push(k - d), m6(o, l[g + 3], h, b, w, d), new Bt(f, b, w, p);
  }
  i.children[s] = c(0, l.length, Qr.none, 0, o.length, t.length - 1);
  for (let u of a) {
    let h = n.tree.children[u], f = n.tree.positions[u];
    n.yield(new Gn(h, f + n.from, u, n._tree));
  }
}
class g6 {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Zt.IncludeAnonymous | Zt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, r = e - this.offset;
    for (; !this.done && t.from < r; )
      t.to >= e && t.enter(r, 1, Zt.IgnoreOverlays | Zt.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof Bt)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
class IL {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (t = r.tree.prop(T4)) !== null && t !== void 0 ? t : r.to, this.inner = new g6(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(T4)) !== null && e !== void 0 ? e : t.to, this.inner = new g6(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(st.mounted);
        if (o && o.parser == t)
          for (let l = this.fragI; l < this.fragments.length; l++) {
            let a = this.fragments[l];
            if (a.from >= s.to)
              break;
            a.tree == this.curFrag.tree && i.push({
              frag: a,
              pos: s.from - a.offset,
              mount: o
            });
          }
      }
    }
    return i;
  }
}
function y6(n, e) {
  let t = null, r = e;
  for (let i = 1, s = 0; i < n.length; i++) {
    let o = n[i - 1].to, l = n[i].from;
    for (; s < r.length; s++) {
      let a = r[s];
      if (a.from >= l)
        break;
      a.to <= o || (t || (r = t = e.slice()), a.from < o ? (t[s] = new ai(a.from, o), a.to > l && t.splice(s + 1, 0, new ai(l, a.to))) : a.to > l ? t[s--] = new ai(l, a.to) : t.splice(s--, 1));
    }
  }
  return r;
}
function DL(n, e, t, r) {
  let i = 0, s = 0, o = !1, l = !1, a = -1e9, c = [];
  for (; ; ) {
    let u = i == n.length ? 1e9 : o ? n[i].to : n[i].from, h = s == e.length ? 1e9 : l ? e[s].to : e[s].from;
    if (o != l) {
      let f = Math.max(a, t), d = Math.min(u, h, r);
      f < d && c.push(new ai(f, d));
    }
    if (a = Math.min(u, h), a == 1e9)
      break;
    u == a && (o ? (o = !1, i++) : o = !0), h == a && (l ? (l = !1, s++) : l = !0);
  }
  return c;
}
function b6(n, e) {
  let t = [];
  for (let { pos: r, mount: i, frag: s } of n) {
    let o = r + (i.overlay ? i.overlay[0].from : 0), l = o + i.tree.length, a = Math.max(s.from, o), c = Math.min(s.to, l);
    if (i.overlay) {
      let u = i.overlay.map((f) => new ai(f.from + r, f.to + r)), h = DL(e, u, a, c);
      for (let f = 0, d = a; ; f++) {
        let p = f == h.length, m = p ? c : h[f].from;
        if (m > d && t.push(new to(d, m, i.tree, -o, s.from >= d || s.openStart, s.to <= m || s.openEnd)), p)
          break;
        d = h[f].to;
      }
    } else
      t.push(new to(a, c, i.tree, -o, s.from >= o || s.openStart, s.to <= l || s.openEnd));
  }
  return t;
}
let A4 = [], RS = [];
(() => {
  let n = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, t = 0; e < n.length; e++)
    (e % 2 ? RS : A4).push(t = t + n[e]);
})();
function NL(n) {
  if (n < 768) return !1;
  for (let e = 0, t = A4.length; ; ) {
    let r = e + t >> 1;
    if (n < A4[r]) t = r;
    else if (n >= RS[r]) e = r + 1;
    else return !0;
    if (e == t) return !1;
  }
}
function v6(n) {
  return n >= 127462 && n <= 127487;
}
const w6 = 8205;
function RL(n, e, t = !0, r = !0) {
  return (t ? PS : PL)(n, e, r);
}
function PS(n, e, t) {
  if (e == n.length) return e;
  e && _S(n.charCodeAt(e)) && LS(n.charCodeAt(e - 1)) && e--;
  let r = Ag(n, e);
  for (e += x6(r); e < n.length; ) {
    let i = Ag(n, e);
    if (r == w6 || i == w6 || t && NL(i))
      e += x6(i), r = i;
    else if (v6(i)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && v6(Ag(n, o)); )
        s++, o -= 2;
      if (s % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function PL(n, e, t) {
  for (; e > 0; ) {
    let r = PS(n, e - 2, t);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function Ag(n, e) {
  let t = n.charCodeAt(e);
  if (!LS(t) || e + 1 == n.length) return t;
  let r = n.charCodeAt(e + 1);
  return _S(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function _S(n) {
  return n >= 56320 && n < 57344;
}
function LS(n) {
  return n >= 55296 && n < 56320;
}
function x6(n) {
  return n < 65536 ? 1 : 2;
}
let ft = class BS {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, r) {
    [e, t] = Nc(this, e, t);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      i,
      1
      /* Open.From */
    ), j0.from(i, this.length - (t - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = Nc(this, e, t);
    let r = [];
    return this.decompose(e, t, r, 0), j0.from(r, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Bh(this), s = new Bh(e);
    for (let o = t, l = t; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (l += i.value.length, i.done || l >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Bh(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new zS(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new FS(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? BS.empty : e.length <= 32 ? new an(e) : j0.from(an.split(e, []));
  }
};
class an extends ft {
  constructor(e, t = _L(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], l = i + o.length;
      if ((t ? r : l) >= e)
        return new LL(i, l, r, o);
      i = l + 1, r++;
    }
  }
  decompose(e, t, r, i) {
    let s = e <= 0 && t >= this.length ? this : new an(k6(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = r.pop(), l = U0(s.text, o.text.slice(), 0, s.length);
      if (l.length <= 32)
        r.push(new an(l, o.length + s.length));
      else {
        let a = l.length >> 1;
        r.push(new an(l.slice(0, a)), new an(l.slice(a)));
      }
    } else
      r.push(s);
  }
  replace(e, t, r) {
    if (!(r instanceof an))
      return super.replace(e, t, r);
    [e, t] = Nc(this, e, t);
    let i = U0(this.text, U0(r.text, k6(this.text, 0, e)), t), s = this.length + r.length - (t - e);
    return i.length <= 32 ? new an(i, s) : j0.from(an.split(i, []), s);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = Nc(this, e, t);
    let i = "";
    for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
      let l = this.text[o], a = s + l.length;
      s > e && o && (i += r), e < a && t > s && (i += l.slice(Math.max(0, e - s), t - s)), s = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let r = [], i = -1;
    for (let s of e)
      r.push(s), i += s.length + 1, r.length == 32 && (t.push(new an(r, i)), r = [], i = -1);
    return i > -1 && t.push(new an(r, i)), t;
  }
}
let j0 = class Qa extends ft {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], l = i + o.length, a = r + o.lines - 1;
      if ((t ? a : l) >= e)
        return o.lineInner(e, t, r, i);
      i = l + 1, r = a + 1;
    }
  }
  decompose(e, t, r, i) {
    for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
      let l = this.children[s], a = o + l.length;
      if (e <= a && t >= o) {
        let c = i & ((o <= e ? 1 : 0) | (a >= t ? 2 : 0));
        o >= e && a <= t && !c ? r.push(l) : l.decompose(e - o, t - o, r, c);
      }
      o = a + 1;
    }
  }
  replace(e, t, r) {
    if ([e, t] = Nc(this, e, t), r.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], l = s + o.length;
        if (e >= s && t <= l) {
          let a = o.replace(e - s, t - s, r), c = this.lines - o.lines + a.lines;
          if (a.lines < c >> 4 && a.lines > c >> 6) {
            let u = this.children.slice();
            return u[i] = a, new Qa(u, this.length - (t - e) + r.length);
          }
          return super.replace(s, l, a);
        }
        s = l + 1;
      }
    return super.replace(e, t, r);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = Nc(this, e, t);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
      let l = this.children[s], a = o + l.length;
      o > e && s && (i += r), e < a && t > o && (i += l.sliceString(e - o, t - o, r)), o = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Qa))
      return 0;
    let r = 0, [i, s, o, l] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += t, s += t) {
      if (i == o || s == l)
        return r;
      let a = this.children[i], c = e.children[s];
      if (a != c)
        return r + a.scanIdentical(c, t);
      r += a.length + 1;
    }
  }
  static from(e, t = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let d of e)
      r += d.lines;
    if (r < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new an(d, t);
    }
    let i = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), s = i << 1, o = i >> 1, l = [], a = 0, c = -1, u = [];
    function h(d) {
      let p;
      if (d.lines > s && d instanceof Qa)
        for (let m of d.children)
          h(m);
      else d.lines > o && (a > o || !a) ? (f(), l.push(d)) : d instanceof an && a && (p = u[u.length - 1]) instanceof an && d.lines + p.lines <= 32 ? (a += d.lines, c += d.length + 1, u[u.length - 1] = new an(p.text.concat(d.text), p.length + 1 + d.length)) : (a + d.lines > i && f(), a += d.lines, c += d.length + 1, u.push(d));
    }
    function f() {
      a != 0 && (l.push(u.length == 1 ? u[0] : Qa.from(u, c)), c = -1, a = u.length = 0);
    }
    for (let d of e)
      h(d);
    return f(), l.length == 1 ? l[0] : new Qa(l, t);
  }
};
ft.empty = /* @__PURE__ */ new an([""], 0);
function _L(n) {
  let e = -1;
  for (let t of n)
    e += t.length + 1;
  return e;
}
function U0(n, e, t = 0, r = 1e9) {
  for (let i = 0, s = 0, o = !0; s < n.length && i <= r; s++) {
    let l = n[s], a = i + l.length;
    a >= t && (a > r && (l = l.slice(0, r - i)), i < t && (l = l.slice(t - i)), o ? (e[e.length - 1] += l, o = !1) : e.push(l)), i = a + 1;
  }
  return e;
}
function k6(n, e, t) {
  return U0(n, [""], e, t);
}
class Bh {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof an ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], s = this.offsets[r], o = s >> 1, l = i instanceof an ? i.text.length : i.children.length;
      if (o == (t > 0 ? l : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[r] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof an) {
        let a = i.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[r] += t, a.length > Math.max(0, e))
          return this.value = e == 0 ? a : t > 0 ? a.slice(e) : a.slice(0, a.length - e), this;
        e -= a.length;
      } else {
        let a = i.children[o + (t < 0 ? -1 : 0)];
        e > a.length ? (e -= a.length, this.offsets[r] += t) : (t < 0 && this.offsets[r]--, this.nodes.push(a), this.offsets.push(t > 0 ? 1 : (a instanceof an ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class zS {
  constructor(e, t, r) {
    this.value = "", this.done = !1, this.cursor = new Bh(e, t > r ? -1 : 1), this.pos = t > r ? e.length : 0, this.from = Math.min(t, r), this.to = Math.max(t, r);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let r = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * t, this.value = i.length <= r ? i : t < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class FS {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: r, value: i } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (ft.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Bh.prototype[Symbol.iterator] = zS.prototype[Symbol.iterator] = FS.prototype[Symbol.iterator] = function() {
  return this;
});
class LL {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.number = r, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Nc(n, e, t) {
  return e = Math.max(0, Math.min(n.length, e)), [e, Math.max(e, Math.min(n.length, t))];
}
function zn(n, e, t = !0, r = !0) {
  return RL(n, e, t, r);
}
function BL(n) {
  return n >= 56320 && n < 57344;
}
function zL(n) {
  return n >= 55296 && n < 56320;
}
function kr(n, e) {
  let t = n.charCodeAt(e);
  if (!zL(t) || e + 1 == n.length)
    return t;
  let r = n.charCodeAt(e + 1);
  return BL(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function l3(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
function as(n) {
  return n < 65536 ? 1 : 2;
}
const O4 = /\r\n?|\n/;
var Bn = /* @__PURE__ */ (function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
})(Bn || (Bn = {}));
class ys {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t + 1];
      e += r < 0 ? this.sections[t] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, r = 0, i = 0; t < this.sections.length; ) {
      let s = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(r, i, s), i += s) : i += o, r += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    E4(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new ys(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : HS(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : I4(this, e, t);
  }
  mapPos(e, t = -1, r = Bn.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], a = this.sections[o++], c = i + l;
      if (a < 0) {
        if (c > e)
          return s + (e - i);
        s += l;
      } else {
        if (r != Bn.Simple && c >= e && (r == Bn.TrackDel && i < e && c > e || r == Bn.TrackBefore && i < e || r == Bn.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !l)
          return e == i || t < 0 ? s : s + a;
        s += a;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= t; ) {
      let s = this.sections[r++], o = this.sections[r++], l = i + s;
      if (o >= 0 && i <= t && l >= e)
        return i < e && l > t ? "cover" : !0;
      i = l;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ys(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new ys(e);
  }
}
class wn extends ys {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return E4(this, (t, r, i, s, o) => e = e.replace(i, i + (r - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return I4(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), r = [];
    for (let i = 0, s = 0; i < t.length; i += 2) {
      let o = t[i], l = t[i + 1];
      if (l >= 0) {
        t[i] = l, t[i + 1] = o;
        let a = i >> 1;
        for (; r.length < a; )
          r.push(ft.empty);
        r.push(o ? e.slice(s, s + o) : ft.empty);
      }
      s += o;
    }
    return new wn(t, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : HS(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : I4(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    E4(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ys.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], r = [], i = [], s = new wf(this);
    e: for (let o = 0, l = 0; ; ) {
      let a = o == e.length ? 1e9 : e[o++];
      for (; l < a || l == a && s.len == 0; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, a - l);
        Wn(i, u, -1);
        let h = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        Wn(t, u, h), h > 0 && Yo(r, t, s.text), s.forward(u), l += u;
      }
      let c = e[o++];
      for (; l < c; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, c - l);
        Wn(t, u, -1), Wn(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), l += u;
      }
    }
    return {
      changes: new wn(t, r),
      filtered: ys.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t], i = this.sections[t + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, r) {
    let i = [], s = [], o = 0, l = null;
    function a(u = !1) {
      if (!u && !i.length)
        return;
      o < t && Wn(i, t - o, -1);
      let h = new wn(i, s);
      l = l ? l.compose(h.map(l)) : h, i = [], s = [], o = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let h of u)
          c(h);
      else if (u instanceof wn) {
        if (u.length != t)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${t})`);
        a(), l = l ? l.compose(u.map(l)) : u;
      } else {
        let { from: h, to: f = h, insert: d } = u;
        if (h > f || h < 0 || f > t)
          throw new RangeError(`Invalid change range ${h} to ${f} (in doc of length ${t})`);
        let p = d ? typeof d == "string" ? ft.of(d.split(r || O4)) : d : ft.empty, m = p.length;
        if (h == f && m == 0)
          return;
        h < o && a(), h > o && Wn(i, h - o, -1), Wn(i, f - h, m), Yo(s, i, p), o = f;
      }
    }
    return c(e), a(!l), l;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new wn(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], r = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        t.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          t.push(s[0], 0);
        else {
          for (; r.length < i; )
            r.push(ft.empty);
          r[i] = ft.of(s.slice(1)), t.push(s[0], r[i].length);
        }
      }
    }
    return new wn(t, r);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new wn(e, t);
  }
}
function Wn(n, e, t, r = !1) {
  if (e == 0 && t <= 0)
    return;
  let i = n.length - 2;
  i >= 0 && t <= 0 && t == n[i + 1] ? n[i] += e : i >= 0 && e == 0 && n[i] == 0 ? n[i + 1] += t : r ? (n[i] += e, n[i + 1] += t) : n.push(e, t);
}
function Yo(n, e, t) {
  if (t.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < n.length)
    n[n.length - 1] = n[n.length - 1].append(t);
  else {
    for (; n.length < r; )
      n.push(ft.empty);
    n.push(t);
  }
}
function E4(n, e, t) {
  let r = n.inserted;
  for (let i = 0, s = 0, o = 0; o < n.sections.length; ) {
    let l = n.sections[o++], a = n.sections[o++];
    if (a < 0)
      i += l, s += l;
    else {
      let c = i, u = s, h = ft.empty;
      for (; c += l, u += a, a && r && (h = h.append(r[o - 2 >> 1])), !(t || o == n.sections.length || n.sections[o + 1] < 0); )
        l = n.sections[o++], a = n.sections[o++];
      e(i, c, s, u, h), i = c, s = u;
    }
  }
}
function I4(n, e, t, r = !1) {
  let i = [], s = r ? [] : null, o = new wf(n), l = new wf(e);
  for (let a = -1; ; ) {
    if (o.done && l.len || l.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && l.ins == -1) {
      let c = Math.min(o.len, l.len);
      Wn(i, c, -1), o.forward(c), l.forward(c);
    } else if (l.ins >= 0 && (o.ins < 0 || a == o.i || o.off == 0 && (l.len < o.len || l.len == o.len && !t))) {
      let c = l.len;
      for (Wn(i, l.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && a < o.i && o.len <= u && (Wn(i, 0, o.ins), s && Yo(s, i, o.text), a = o.i), o.forward(u), c -= u;
      }
      l.next();
    } else if (o.ins >= 0) {
      let c = 0, u = o.len;
      for (; u; )
        if (l.ins == -1) {
          let h = Math.min(u, l.len);
          c += h, u -= h, l.forward(h);
        } else if (l.ins == 0 && l.len < u)
          u -= l.len, l.next();
        else
          break;
      Wn(i, c, a < o.i ? o.ins : 0), s && a < o.i && Yo(s, i, o.text), a = o.i, o.forward(o.len - u);
    } else {
      if (o.done && l.done)
        return s ? wn.createSet(i, s) : ys.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function HS(n, e, t = !1) {
  let r = [], i = t ? [] : null, s = new wf(n), o = new wf(e);
  for (let l = !1; ; ) {
    if (s.done && o.done)
      return i ? wn.createSet(r, i) : ys.create(r);
    if (s.ins == 0)
      Wn(r, s.len, 0, l), s.next();
    else if (o.len == 0 && !o.done)
      Wn(r, 0, o.ins, l), i && Yo(i, r, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(s.len2, o.len), c = r.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          Wn(r, a, u, l), i && u && Yo(i, r, o.text);
        } else o.ins == -1 ? (Wn(r, s.off ? 0 : s.len, a, l), i && Yo(i, r, s.textBit(a))) : (Wn(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, l), i && !o.off && Yo(i, r, o.text));
        l = (s.ins > a || o.ins >= 0 && o.len > a) && (l || r.length > c), s.forward2(a), o.forward(a);
      }
    }
  }
}
class wf {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? ft.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, r = this.i - 2 >> 1;
    return r >= t.length && !e ? ft.empty : t[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
let Ud = class D4 {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.flags = r;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let r, i;
    return this.empty ? r = i = e.mapPos(this.from, t) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new D4(r, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return G.range(e, t);
    let r = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return G.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return G.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new D4(e, t, r);
  }
};
class G {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : G.create(this.ranges.map((r) => r.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new G([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return G.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let r = this.ranges.slice();
    return r[t] = e, G.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new G(e.ranges.map((t) => Ud.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new G([G.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= r : s.from < r)
        return G.normalized(e.slice(), t);
      r = s.to;
    }
    return new G(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, r, i) {
    return Ud.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, r, i) {
    let s = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return t < e ? Ud.create(t, e, 48 | s) : Ud.create(e, t, (t > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let r = e[t];
    e.sort((i, s) => i.from - s.from), t = e.indexOf(r);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let l = o.from, a = Math.max(s.to, o.to);
        i <= t && t--, e.splice(--i, 2, s.anchor > s.head ? G.range(a, l) : G.range(l, a));
      }
    }
    return new G(e, t);
  }
}
function $S(n, e) {
  for (let t of n.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let a3 = 0;
class xe {
  constructor(e, t, r, i, s) {
    this.combine = e, this.compareInput = t, this.compare = r, this.isStatic = i, this.id = a3++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new xe(e.combine || ((t) => t), e.compareInput || ((t, r) => t === r), e.compare || (e.combine ? (t, r) => t === r : c3), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new K0([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new K0(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new K0(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (r) => r), this.compute([e], (r) => t(r.field(e)));
  }
}
function c3(n, e) {
  return n == e || n.length == e.length && n.every((t, r) => t === e[r]);
}
class K0 {
  constructor(e, t, r, i) {
    this.dependencies = e, this.facet = t, this.type = r, this.value = i, this.id = a3++;
  }
  dynamicSlot(e) {
    var t;
    let r = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, l = this.type == 2, a = !1, c = !1, u = [];
    for (let h of this.dependencies)
      h == "doc" ? a = !0 : h == "selection" ? c = !0 : (((t = e[h.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 && u.push(e[h.id]);
    return {
      create(h) {
        return h.values[o] = r(h), 1;
      },
      update(h, f) {
        if (a && f.docChanged || c && (f.docChanged || f.selection) || N4(h, u)) {
          let d = r(h);
          if (l ? !S6(d, h.values[o], i) : !i(d, h.values[o]))
            return h.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (h, f) => {
        let d, p = f.config.address[s];
        if (p != null) {
          let m = Qp(f, p);
          if (this.dependencies.every((g) => g instanceof xe ? f.facet(g) === h.facet(g) : g instanceof On ? f.field(g, !1) == h.field(g, !1) : !0) || (l ? S6(d = r(h), m, i) : i(d = r(h), m)))
            return h.values[o] = m, 0;
        } else
          d = r(h);
        return h.values[o] = d, 1;
      }
    };
  }
}
function S6(n, e, t) {
  if (n.length != e.length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (!t(n[r], e[r]))
      return !1;
  return !0;
}
function N4(n, e) {
  let t = !1;
  for (let r of e)
    zh(n, r) & 1 && (t = !0);
  return t;
}
function FL(n, e, t) {
  let r = t.map((a) => n[a.id]), i = t.map((a) => a.type), s = r.filter((a) => !(a & 1)), o = n[e.id] >> 1;
  function l(a) {
    let c = [];
    for (let u = 0; u < r.length; u++) {
      let h = Qp(a, r[u]);
      if (i[u] == 2)
        for (let f of h)
          c.push(f);
      else
        c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(a) {
      for (let c of r)
        zh(a, c);
      return a.values[o] = l(a), 1;
    },
    update(a, c) {
      if (!N4(a, s))
        return 0;
      let u = l(a);
      return e.compare(u, a.values[o]) ? 0 : (a.values[o] = u, 1);
    },
    reconfigure(a, c) {
      let u = N4(a, r), h = c.config.facets[e.id], f = c.facet(e);
      if (h && !u && c3(t, h))
        return a.values[o] = f, 0;
      let d = l(a);
      return e.compare(d, f) ? (a.values[o] = f, 0) : (a.values[o] = d, 1);
    }
  };
}
const Kd = /* @__PURE__ */ xe.define({ static: !0 });
class On {
  constructor(e, t, r, i, s) {
    this.id = e, this.createF = t, this.updateF = r, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new On(a3++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(Kd).find((r) => r.field == this);
    return (t?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (r) => (r.values[t] = this.create(r), 1),
      update: (r, i) => {
        let s = r.values[t], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (r.values[t] = o, 1);
      },
      reconfigure: (r, i) => {
        let s = r.facet(Kd), o = i.facet(Kd), l;
        return (l = s.find((a) => a.field == this)) && l != o.find((a) => a.field == this) ? (r.values[t] = l.create(r), 1) : i.config.address[this.id] != null ? (r.values[t] = i.field(this), 0) : (r.values[t] = this.create(r), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Kd.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Xl = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Pu(n) {
  return (e) => new VS(e, n);
}
const kl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Pu(Xl.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Pu(Xl.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Pu(Xl.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Pu(Xl.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Pu(Xl.lowest)
};
class VS {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class Rc {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new R4(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Rc.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class R4 {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
let C6 = class qS {
  constructor(e, t, r, i, s, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = r, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, r) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of HL(e, t, o))
      f instanceof On ? i.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let l = /* @__PURE__ */ Object.create(null), a = [], c = [];
    for (let f of i)
      l[f.id] = c.length << 1, c.push((d) => f.slot(d));
    let u = r?.config.facets;
    for (let f in s) {
      let d = s[f], p = d[0].facet, m = u && u[f] || [];
      if (d.every(
        (g) => g.type == 0
        /* Provider.Static */
      ))
        if (l[p.id] = a.length << 1 | 1, c3(m, d))
          a.push(r.facet(p));
        else {
          let g = p.combine(d.map((b) => b.value));
          a.push(r && p.compare(g, r.facet(p)) ? r.facet(p) : g);
        }
      else {
        for (let g of d)
          g.type == 0 ? (l[g.id] = a.length << 1 | 1, a.push(g.value)) : (l[g.id] = c.length << 1, c.push((b) => g.dynamicSlot(b)));
        l[p.id] = c.length << 1, c.push((g) => FL(g, p, d));
      }
    }
    let h = c.map((f) => f(l));
    return new qS(e, o, h, l, a, s);
  }
};
function HL(n, e, t) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, l) {
    let a = i.get(o);
    if (a != null) {
      if (a <= l)
        return;
      let c = r[a].indexOf(o);
      c > -1 && r[a].splice(c, 1), o instanceof R4 && t.delete(o.compartment);
    }
    if (i.set(o, l), Array.isArray(o))
      for (let c of o)
        s(c, l);
    else if (o instanceof R4) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      t.set(o.compartment, c), s(c, l);
    } else if (o instanceof VS)
      s(o.inner, o.prec);
    else if (o instanceof On)
      r[l].push(o), o.provides && s(o.provides, l);
    else if (o instanceof K0)
      r[l].push(o), o.facet.extensions && s(o.facet.extensions, Xl.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, l);
    }
  }
  return s(n, Xl.default), r.reduce((o, l) => o.concat(l));
}
function zh(n, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, r = n.status[t];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  n.status[t] = 4;
  let i = n.computeSlot(n, n.config.dynamicSlots[t]);
  return n.status[t] = 2 | i;
}
function Qp(n, e) {
  return e & 1 ? n.config.staticValues[e >> 1] : n.values[e >> 1];
}
const WS = /* @__PURE__ */ xe.define(), P4 = /* @__PURE__ */ xe.define({
  combine: (n) => n.some((e) => e),
  static: !0
}), jS = /* @__PURE__ */ xe.define({
  combine: (n) => n.length ? n[0] : void 0,
  static: !0
}), US = /* @__PURE__ */ xe.define(), KS = /* @__PURE__ */ xe.define(), GS = /* @__PURE__ */ xe.define(), YS = /* @__PURE__ */ xe.define({
  combine: (n) => n.length ? n[0] : !1
});
class wo {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new $L();
  }
}
class $L {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new wo(this, e);
  }
}
class VL {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new Xe(this, e);
  }
}
class Xe {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new Xe(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new VL(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let r = [];
    for (let i of e) {
      let s = i.map(t);
      s && r.push(s);
    }
    return r;
  }
}
Xe.reconfigure = /* @__PURE__ */ Xe.define();
Xe.appendConfig = /* @__PURE__ */ Xe.define();
let ur = class Zu {
  constructor(e, t, r, i, s, o) {
    this.startState = e, this.changes = t, this.selection = r, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, r && $S(r, t.newLength), s.some((l) => l.type == Zu.time) || (this.annotations = s.concat(Zu.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, r, i, s, o) {
    return new Zu(e, t, r, i, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(Zu.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
};
ur.time = /* @__PURE__ */ wo.define();
ur.userEvent = /* @__PURE__ */ wo.define();
ur.addToHistory = /* @__PURE__ */ wo.define();
ur.remote = /* @__PURE__ */ wo.define();
function qL(n, e) {
  let t = [];
  for (let r = 0, i = 0; ; ) {
    let s, o;
    if (r < n.length && (i == e.length || e[i] >= n[r]))
      s = n[r++], o = n[r++];
    else if (i < e.length)
      s = e[i++], o = e[i++];
    else
      return t;
    !t.length || t[t.length - 1] < s ? t.push(s, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function JS(n, e, t) {
  var r;
  let i, s, o;
  return t ? (i = e.changes, s = wn.empty(e.changes.length), o = n.changes.compose(e.changes)) : (i = e.changes.map(n.changes), s = n.changes.mapDesc(e.changes, !0), o = n.changes.compose(i)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (r = n.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: Xe.mapEffects(n.effects, i).concat(Xe.mapEffects(e.effects, s)),
    annotations: n.annotations.length ? n.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: n.scrollIntoView || e.scrollIntoView
  };
}
function _4(n, e, t) {
  let r = e.selection, i = yc(e.annotations);
  return e.userEvent && (i = i.concat(ur.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof wn ? e.changes : wn.of(e.changes || [], t, n.facet(jS)),
    selection: r && (r instanceof G ? r : G.single(r.anchor, r.head)),
    effects: yc(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function XS(n, e, t) {
  let r = _4(n, e.length ? e[0] : {}, n.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1);
    let o = !!e[s].sequential;
    r = JS(r, _4(n, e[s], o ? r.changes.newLength : n.doc.length), o);
  }
  let i = ur.create(n, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return jL(t ? WL(i) : i);
}
function WL(n) {
  let e = n.startState, t = !0;
  for (let i of e.facet(US)) {
    let s = i(n);
    if (s === !1) {
      t = !1;
      break;
    }
    Array.isArray(s) && (t = t === !0 ? s : qL(t, s));
  }
  if (t !== !0) {
    let i, s;
    if (t === !1)
      s = n.changes.invertedDesc, i = wn.empty(e.doc.length);
    else {
      let o = n.changes.filter(t);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    n = ur.create(e, i, n.selection && n.selection.map(s), Xe.mapEffects(n.effects, s), n.annotations, n.scrollIntoView);
  }
  let r = e.facet(KS);
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](n);
    s instanceof ur ? n = s : Array.isArray(s) && s.length == 1 && s[0] instanceof ur ? n = s[0] : n = XS(e, yc(s), !1);
  }
  return n;
}
function jL(n) {
  let e = n.startState, t = e.facet(GS), r = n;
  for (let i = t.length - 1; i >= 0; i--) {
    let s = t[i](n);
    s && Object.keys(s).length && (r = JS(r, _4(e, s, n.changes.newLength), !0));
  }
  return r == n ? n : ur.create(e, n.changes, n.selection, r.effects, r.annotations, r.scrollIntoView);
}
const UL = [];
function yc(n) {
  return n == null ? UL : Array.isArray(n) ? n : [n];
}
var Wt = /* @__PURE__ */ (function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
})(Wt || (Wt = {}));
const KL = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let L4;
try {
  L4 = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function GL(n) {
  if (L4)
    return L4.test(n);
  for (let e = 0; e < n.length; e++) {
    let t = n[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || KL.test(t)))
      return !0;
  }
  return !1;
}
function YL(n) {
  return (e) => {
    if (!/\S/.test(e))
      return Wt.Space;
    if (GL(e))
      return Wt.Word;
    for (let t = 0; t < n.length; t++)
      if (e.indexOf(n[t]) > -1)
        return Wt.Word;
    return Wt.Other;
  };
}
let jt = class Ai {
  constructor(e, t, r, i, s, o) {
    this.config = e, this.doc = t, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      zh(this, l << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return zh(this, r), Qp(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return XS(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: r, compartments: i } = t;
    for (let l of e.effects)
      l.is(Rc.reconfigure) ? (t && (i = /* @__PURE__ */ new Map(), t.compartments.forEach((a, c) => i.set(c, a)), t = null), i.set(l.value.compartment, l.value.extension)) : l.is(Xe.reconfigure) ? (t = null, r = l.value) : l.is(Xe.appendConfig) && (t = null, r = yc(r).concat(l.value));
    let s;
    t ? s = e.startState.values.slice() : (t = C6.resolve(r, i, this), s = new Ai(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (a, c) => c.reconfigure(a, this), null).values);
    let o = e.startState.facet(P4) ? e.newSelection : e.newSelection.asSingle();
    new Ai(t, e.newDoc, o, s, (l, a) => a.update(l, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: G.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, r = e(t.ranges[0]), i = this.changes(r.changes), s = [r.range], o = yc(r.effects);
    for (let l = 1; l < t.ranges.length; l++) {
      let a = e(t.ranges[l]), c = this.changes(a.changes), u = c.map(i);
      for (let f = 0; f < l; f++)
        s[f] = s[f].map(u);
      let h = i.mapDesc(c, !0);
      s.push(a.range.map(h)), i = i.compose(u), o = Xe.mapEffects(o, u).concat(Xe.mapEffects(yc(a.effects), h));
    }
    return {
      changes: i,
      selection: G.create(s, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof wn ? e : wn.of(e, this.doc.length, this.facet(Ai.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return ft.of(e.split(this.facet(Ai.lineSeparator) || O4));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (zh(this, t), Qp(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof On && this.config.address[i.id] != null && (t[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = r[s], l = e[s];
          i.push(o.init((a) => o.spec.fromJSON(l, a)));
        }
    }
    return Ai.create({
      doc: e.doc,
      selection: G.fromJSON(e.selection),
      extensions: t.extensions ? i.concat([t.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = C6.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof ft ? e.doc : ft.of((e.doc || "").split(t.staticFacet(Ai.lineSeparator) || O4)), i = e.selection ? e.selection instanceof G ? e.selection : G.single(e.selection.anchor, e.selection.head) : G.single(0);
    return $S(i, r.length), t.staticFacet(P4) || (i = i.asSingle()), new Ai(t, r, i, t.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Ai.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Ai.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(YS);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let r of this.facet(Ai.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > t.length ? r : t[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, r = -1) {
    let i = [];
    for (let s of this.facet(WS))
      for (let o of s(this, t, r))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return YL(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: r, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - r, l = e - r;
    for (; o > 0; ) {
      let a = zn(t, o, !1);
      if (s(t.slice(a, o)) != Wt.Word)
        break;
      o = a;
    }
    for (; l < i; ) {
      let a = zn(t, l);
      if (s(t.slice(l, a)) != Wt.Word)
        break;
      l = a;
    }
    return o == l ? null : G.range(o + r, l + r);
  }
};
jt.allowMultipleSelections = P4;
jt.tabSize = /* @__PURE__ */ xe.define({
  combine: (n) => n.length ? n[0] : 4
});
jt.lineSeparator = jS;
jt.readOnly = YS;
jt.phrases = /* @__PURE__ */ xe.define({
  compare(n, e) {
    let t = Object.keys(n), r = Object.keys(e);
    return t.length == r.length && t.every((i) => n[i] == e[i]);
  }
});
jt.languageData = WS;
jt.changeFilter = US;
jt.transactionFilter = KS;
jt.transactionExtender = GS;
Rc.reconfigure = /* @__PURE__ */ Xe.define();
function Ts(n, e, t = {}) {
  let r = {};
  for (let i of n)
    for (let s of Object.keys(i)) {
      let o = i[s], l = r[s];
      if (l === void 0)
        r[s] = o;
      else if (!(l === o || o === void 0)) if (Object.hasOwnProperty.call(t, s))
        r[s] = t[s](l, o);
      else
        throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class va {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return xf.create(e, t, this);
  }
}
va.prototype.startSide = va.prototype.endSide = 0;
va.prototype.point = !1;
va.prototype.mapMode = Bn.TrackDel;
class xf {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.value = r;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new xf(e, t, r);
  }
}
function B4(n, e) {
  return n.from - e.from || n.value.startSide - e.value.startSide;
}
class u3 {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, r, i = 0) {
    let s = r ? this.to : this.from;
    for (let o = i, l = s.length; ; ) {
      if (o == l)
        return o;
      let a = o + l >> 1, c = s[a] - e || (r ? this.value[a].endSide : this.value[a].startSide) - t;
      if (a == o)
        return c >= 0 ? o : l;
      c >= 0 ? l = a : o = a + 1;
    }
  }
  between(e, t, r, i) {
    for (let s = this.findIndex(t, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, t) {
    let r = [], i = [], s = [], o = -1, l = -1;
    for (let a = 0; a < this.value.length; a++) {
      let c = this.value[a], u = this.from[a] + e, h = this.to[a] + e, f, d;
      if (u == h) {
        let p = t.mapPos(u, c.startSide, c.mapMode);
        if (p == null || (f = d = p, c.startSide != c.endSide && (d = t.mapPos(u, c.endSide), d < f)))
          continue;
      } else if (f = t.mapPos(u, c.startSide), d = t.mapPos(h, c.endSide), f > d || f == d && c.startSide > 0 && c.endSide <= 0)
        continue;
      (d - f || c.endSide - c.startSide) < 0 || (o < 0 && (o = f), c.point && (l = Math.max(l, d - f)), r.push(c), i.push(f - o), s.push(d - o));
    }
    return { mapped: r.length ? new u3(i, s, r, l) : null, pos: o };
  }
}
class ut {
  constructor(e, t, r, i) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = r, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, t, r, i) {
    return new ut(e, t, r, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: r = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (r && (t = t.slice().sort(B4)), this.isEmpty)
      return t.length ? ut.of(t) : this;
    let l = new ZS(this, null, -1).goto(0), a = 0, c = [], u = new lo();
    for (; l.value || a < t.length; )
      if (a < t.length && (l.from - t[a].from || l.startSide - t[a].value.startSide) >= 0) {
        let h = t[a++];
        u.addInner(h.from, h.to, h.value) || c.push(h);
      } else l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (a == t.length || this.chunkEnd(l.chunkIndex) < t[a].from) && (!o || i > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) && u.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || i > l.to || s < l.from || o(l.from, l.to, l.value)) && (u.addInner(l.from, l.to, l.value) || c.push(xf.create(l.from, l.to, l.value))), l.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? ut.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: i, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], r = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], a = this.chunk[o], c = e.touchesRange(l, l + a.length);
      if (c === !1)
        i = Math.max(i, a.maxPoint), t.push(a), r.push(e.mapPos(l));
      else if (c === !0) {
        let { mapped: u, pos: h } = a.map(l, e);
        u && (i = Math.max(i, u.maxPoint), t.push(u), r.push(h));
      }
    }
    let s = this.nextLayer.map(e);
    return t.length == 0 ? s : new ut(r, t, s || ut.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (t >= s && e <= s + o.length && o.between(s, e - s, t - s, r) === !1)
          return;
      }
      this.nextLayer.between(e, t, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return kf.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return kf.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, r, i, s = -1) {
    let o = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), l = t.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), a = M6(o, l, r), c = new _u(o, a, s), u = new _u(l, a, s);
    r.iterGaps((h, f, d) => T6(c, h, u, f, d, i)), r.empty && r.length == 0 && T6(c, 0, u, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, r = 0, i) {
    i == null && (i = 999999999);
    let s = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0), o = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let l = M6(s, o), a = new _u(s, l, 0).goto(r), c = new _u(o, l, 0).goto(r);
    for (; ; ) {
      if (a.to != c.to || !z4(a.active, c.active) || a.point && (!c.point || !a.point.eq(c.point)))
        return !1;
      if (a.to > i)
        return !0;
      a.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, r, i, s = -1) {
    let o = new _u(e, null, s).goto(t), l = t, a = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, r);
      if (o.point) {
        let u = o.activeForPoint(o.to), h = o.pointFrom < t ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, a);
        i.point(l, c, o.point, u, h, o.pointRank), a = Math.min(o.openEnd(c), u.length);
      } else c > l && (i.span(l, c, o.active, a), a = o.openEnd(c));
      if (o.to > r)
        return a + (o.point && o.to > r ? 1 : 0);
      l = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let r = new lo();
    for (let i of e instanceof xf ? [e] : t ? JL(e) : e)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return ut.empty;
    let t = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != ut.empty; i = i.nextLayer)
        t = new ut(i.chunkPos, i.chunk, t, Math.max(i.maxPoint, t.maxPoint));
    return t;
  }
}
ut.empty = /* @__PURE__ */ new ut([], [], null, -1);
function JL(n) {
  if (n.length > 1)
    for (let e = n[0], t = 1; t < n.length; t++) {
      let r = n[t];
      if (B4(e, r) > 0)
        return n.slice().sort(B4);
      e = r;
    }
  return n;
}
ut.empty.nextLayer = ut.empty;
class lo {
  finishChunk(e) {
    this.chunks.push(new u3(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, r) {
    this.addInner(e, t, r) || (this.nextLayer || (this.nextLayer = new lo())).add(e, t, r);
  }
  /**
  @internal
  */
  addInner(e, t, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = t, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let r = t.value.length - 1;
    return this.last = t.value[r], this.lastFrom = t.from[r] + e, this.lastTo = t.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(ut.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = ut.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function M6(n, e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let s of n)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let l = r.get(s.chunk[o]);
      l != null && (t ? t.mapPos(l) : l) == s.chunkPos[o] && !t?.touchesRange(l, l + s.chunk[o].length) && i.add(s.chunk[o]);
    }
  return i;
}
class ZS {
  constructor(e, t, r, i = 0) {
    this.layer = e, this.skip = t, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], r = e + t.from[this.rangeIndex];
        if (this.from = r, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class kf {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, r = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && i.push(new ZS(o, t, r, s));
    return i.length == 1 ? i[0] : new kf(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let r of this.heap)
      r.goto(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Og(this.heap, r);
    return this.next(), this;
  }
  forward(e, t) {
    for (let r of this.heap)
      r.forward(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Og(this.heap, r);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Og(this.heap, 0);
    }
  }
}
function Og(n, e) {
  for (let t = n[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= n.length)
      break;
    let i = n[r];
    if (r + 1 < n.length && i.compare(n[r + 1]) >= 0 && (i = n[r + 1], r++), t.compare(i) < 0)
      break;
    n[r] = t, n[e] = i, e = r;
  }
}
class _u {
  constructor(e, t, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = kf.from(e, t, r);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Gd(this.active, e), Gd(this.activeTo, e), Gd(this.activeRank, e), this.minActive = A6(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: r, to: i, rank: s } = this.cursor;
    for (; t < this.activeRank.length && (s - this.activeRank[t] || i - this.activeTo[t]) > 0; )
      t++;
    Yd(this.active, t, r), Yd(this.activeTo, t, i), Yd(this.activeRank, t, s), e && Yd(e, t, this.cursor.from), this.minActive = A6(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && Gd(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(r), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && t.push(this.active[r]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      t++;
    return t;
  }
}
function T6(n, e, t, r, i, s) {
  n.goto(e), t.goto(r);
  let o = r + i, l = r, a = r - e;
  for (; ; ) {
    let c = n.to + a - t.to, u = c || n.endSide - t.endSide, h = u < 0 ? n.to + a : t.to, f = Math.min(h, o);
    if (n.point || t.point ? n.point && t.point && (n.point == t.point || n.point.eq(t.point)) && z4(n.activeForPoint(n.to), t.activeForPoint(t.to)) || s.comparePoint(l, f, n.point, t.point) : f > l && !z4(n.active, t.active) && s.compareRange(l, f, n.active, t.active), h > o)
      break;
    (c || n.openEnd != t.openEnd) && s.boundChange && s.boundChange(h), l = h, u <= 0 && n.next(), u >= 0 && t.next();
  }
}
function z4(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] != e[t] && !n[t].eq(e[t]))
      return !1;
  return !0;
}
function Gd(n, e) {
  for (let t = e, r = n.length - 1; t < r; t++)
    n[t] = n[t + 1];
  n.pop();
}
function Yd(n, e, t) {
  for (let r = n.length - 1; r >= e; r--)
    n[r + 1] = n[r];
  n[e] = t;
}
function A6(n, e) {
  let t = -1, r = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - r || n[i].endSide - n[t].endSide) < 0 && (t = i, r = e[i]);
  return t;
}
function tu(n, e, t = n.length) {
  let r = 0;
  for (let i = 0; i < t && i < n.length; )
    n.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = zn(n, i));
  return r;
}
function F4(n, e, t, r) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == n.length)
      break;
    s += n.charCodeAt(i) == 9 ? t - s % t : 1, i = zn(n, i);
  }
  return r === !0 ? -1 : n.length;
}
const H4 = "ͼ", O6 = typeof Symbol > "u" ? "__" + H4 : Symbol.for(H4), $4 = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), E6 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class ul {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: r } = t || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, l, a, c) {
      let u = [], h = /^@(\w+)\b/.exec(o[0]), f = h && h[1] == "keyframes";
      if (h && l == null) return a.push(o[0] + ";");
      for (let d in l) {
        let p = l[d];
        if (/&/.test(d))
          s(
            d.split(/,\s*/).map((m) => o.map((g) => m.replace(/&/, g))).reduce((m, g) => m.concat(g)),
            p,
            a
          );
        else if (p && typeof p == "object") {
          if (!h) throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          s(i(d), p, u, f);
        } else p != null && u.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + p + ";");
      }
      (u.length || f) && a.push((r && !h && !c ? o.map(r) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e) s(i(o), e[o], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = E6[O6] || 1;
    return E6[O6] = e + 1, H4 + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, r) {
    let i = e[$4], s = r && r.nonce;
    i ? s && i.setNonce(s) : i = new XL(e, s), i.mount(Array.isArray(t) ? t : [t], e);
  }
}
let I6 = /* @__PURE__ */ new Map();
class XL {
  constructor(e, t) {
    let r = e.ownerDocument || e, i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = I6.get(r);
      if (s) return e[$4] = s;
      this.sheet = new i.CSSStyleSheet(), I6.set(r, this);
    } else
      this.styleTag = r.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[$4] = this;
  }
  mount(e, t) {
    let r = this.sheet, i = 0, s = 0;
    for (let o = 0; o < e.length; o++) {
      let l = e[o], a = this.modules.indexOf(l);
      if (a < s && a > -1 && (this.modules.splice(a, 1), s--, a = -1), a == -1) {
        if (this.modules.splice(s++, 0, l), r) for (let c = 0; c < l.rules.length; c++)
          r.insertRule(l.rules[c], i++);
      } else {
        for (; s < a; ) i += this.modules[s++].rules.length;
        i += l.rules.length, s++;
      }
    }
    if (r)
      t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
    else {
      let o = "";
      for (let a = 0; a < this.modules.length; a++)
        o += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = o;
      let l = t.head || t;
      this.styleTag.parentNode != l && l.insertBefore(this.styleTag, l.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var ao = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Sf = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, ZL = typeof navigator < "u" && /Mac/.test(navigator.platform), QL = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Pn = 0; Pn < 10; Pn++) ao[48 + Pn] = ao[96 + Pn] = String(Pn);
for (var Pn = 1; Pn <= 24; Pn++) ao[Pn + 111] = "F" + Pn;
for (var Pn = 65; Pn <= 90; Pn++)
  ao[Pn] = String.fromCharCode(Pn + 32), Sf[Pn] = String.fromCharCode(Pn);
for (var Eg in ao) Sf.hasOwnProperty(Eg) || (Sf[Eg] = ao[Eg]);
function QS(n) {
  var e = ZL && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || QL && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? Sf : ao)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function At() {
  var n = arguments[0];
  typeof n == "string" && (n = document.createElement(n));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) {
      var i = t[r];
      typeof i == "string" ? n.setAttribute(r, i) : i != null && (n[r] = i);
    }
    e++;
  }
  for (; e < arguments.length; e++) eC(n, arguments[e]);
  return n;
}
function eC(n, e) {
  if (typeof e == "string")
    n.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    n.appendChild(e);
  else if (Array.isArray(e))
    for (var t = 0; t < e.length; t++) eC(n, e[t]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
function Cf(n) {
  let e;
  return n.nodeType == 11 ? e = n.getSelection ? n : n.ownerDocument : e = n, e.getSelection();
}
function V4(n, e) {
  return e ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function G0(n, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return V4(n, e.anchorNode);
  } catch {
    return !1;
  }
}
function Mf(n) {
  return n.nodeType == 3 ? xa(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function Fh(n, e, t, r) {
  return t ? D6(n, e, t, r, -1) || D6(n, e, t, r, 1) : !1;
}
function wa(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}
function em(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
function D6(n, e, t, r, i) {
  for (; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : ws(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let s = n.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = wa(n) + (i < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (i < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      e = i < 0 ? ws(n) : 0;
    } else
      return !1;
  }
}
function ws(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function n1(n, e) {
  let t = e ? n.left : n.right;
  return { left: t, right: t, top: n.top, bottom: n.bottom };
}
function eB(n) {
  let e = n.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function tC(n, e) {
  let t = e.width / n.offsetWidth, r = e.height / n.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - n.offsetWidth) < 1) && (t = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - n.offsetHeight) < 1) && (r = 1), { scaleX: t, scaleY: r };
}
function tB(n, e, t, r, i, s, o, l) {
  let a = n.ownerDocument, c = a.defaultView || window;
  for (let u = n, h = !1; u && !h; )
    if (u.nodeType == 1) {
      let f, d = u == a.body, p = 1, m = 1;
      if (d)
        f = eB(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let w = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: m } = tC(u, w)), f = {
          left: w.left,
          right: w.left + u.clientWidth * p,
          top: w.top,
          bottom: w.top + u.clientHeight * m
        };
      }
      let g = 0, b = 0;
      if (i == "nearest")
        e.top < f.top ? (b = e.top - (f.top + o), t > 0 && e.bottom > f.bottom + b && (b = e.bottom - f.bottom + o)) : e.bottom > f.bottom && (b = e.bottom - f.bottom + o, t < 0 && e.top - b < f.top && (b = e.top - (f.top + o)));
      else {
        let w = e.bottom - e.top, k = f.bottom - f.top;
        b = (i == "center" && w <= k ? e.top + w / 2 - k / 2 : i == "start" || i == "center" && t < 0 ? e.top - o : e.bottom - k + o) - f.top;
      }
      if (r == "nearest" ? e.left < f.left ? (g = e.left - (f.left + s), t > 0 && e.right > f.right + g && (g = e.right - f.right + s)) : e.right > f.right && (g = e.right - f.right + s, t < 0 && e.left < f.left + g && (g = e.left - (f.left + s))) : g = (r == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : r == "start" == l ? e.left - s : e.right - (f.right - f.left) + s) - f.left, g || b)
        if (d)
          c.scrollBy(g, b);
        else {
          let w = 0, k = 0;
          if (b) {
            let C = u.scrollTop;
            u.scrollTop += b / m, k = (u.scrollTop - C) * m;
          }
          if (g) {
            let C = u.scrollLeft;
            u.scrollLeft += g / p, w = (u.scrollLeft - C) * p;
          }
          e = {
            left: e.left - w,
            top: e.top - k,
            right: e.right - w,
            bottom: e.bottom - k
          }, w && Math.abs(w - g) < 1 && (r = "nearest"), k && Math.abs(k - b) < 1 && (i = "nearest");
        }
      if (d)
        break;
      (e.top < f.top || e.bottom > f.bottom || e.left < f.left || e.right > f.right) && (e = {
        left: Math.max(e.left, f.left),
        right: Math.min(e.right, f.right),
        top: Math.max(e.top, f.top),
        bottom: Math.min(e.bottom, f.bottom)
      }), u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function nB(n) {
  let e = n.ownerDocument, t, r;
  for (let i = n.parentNode; i && !(i == e.body || t && r); )
    if (i.nodeType == 1)
      !r && i.scrollHeight > i.clientHeight && (r = i), !t && i.scrollWidth > i.clientWidth && (t = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: t, y: r };
}
class rB {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: r } = e;
    this.set(t, Math.min(e.anchorOffset, t ? ws(t) : 0), r, Math.min(e.focusOffset, r ? ws(r) : 0));
  }
  set(e, t, r, i) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = r, this.focusOffset = i;
  }
}
let Ga = null;
function nC(n) {
  if (n.setActive)
    return n.setActive();
  if (Ga)
    return n.focus(Ga);
  let e = [];
  for (let t = n; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (n.focus(Ga == null ? {
    get preventScroll() {
      return Ga = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ga) {
    Ga = !1;
    for (let t = 0; t < e.length; ) {
      let r = e[t++], i = e[t++], s = e[t++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
}
let N6;
function xa(n, e, t = e) {
  let r = N6 || (N6 = document.createRange());
  return r.setEnd(n, t), r.setStart(n, e), r;
}
function bc(n, e, t, r) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let s = new KeyboardEvent("keydown", i);
  s.synthetic = !0, n.dispatchEvent(s);
  let o = new KeyboardEvent("keyup", i);
  return o.synthetic = !0, n.dispatchEvent(o), s.defaultPrevented || o.defaultPrevented;
}
function iB(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function rC(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function sB(n, e) {
  let t = e.focusNode, r = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, ws(t)); ; )
    if (r) {
      if (t.nodeType != 1)
        return !1;
      let i = t.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (t = i, r = ws(t));
    } else {
      if (t == n)
        return !0;
      r = wa(t), t = t.parentNode;
    }
}
function iC(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
function sC(n, e) {
  for (let t = n, r = e; ; ) {
    if (t.nodeType == 3 && r > 0)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r - 1], r = ws(t);
    } else if (t.parentNode && !em(t))
      r = wa(t), t = t.parentNode;
    else
      return null;
  }
}
function oC(n, e) {
  for (let t = n, r = e; ; ) {
    if (t.nodeType == 3 && r < t.nodeValue.length)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r], r = 0;
    } else if (t.parentNode && !em(t))
      r = wa(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
class Un {
  constructor(e, t, r = !0) {
    this.node = e, this.offset = t, this.precise = r;
  }
  static before(e, t) {
    return new Un(e.parentNode, wa(e), t);
  }
  static after(e, t) {
    return new Un(e.parentNode, wa(e) + 1, t);
  }
}
const h3 = [];
class It {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return t;
      t += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let r = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
            let l = It.get(s);
            (!l || !l.parent && l.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : r.firstChild, t && !t.written && t.node == r && s != o.dom && (t.written = !0), o.dom.parentNode == r)
          for (; s && s != o.dom; )
            s = R6(s);
        else
          r.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : r.firstChild, s && t && t.node == r && (t.written = !0); s; )
        s = R6(s);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, t), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[t];
    else {
      let i = ws(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !It.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == r)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, r = 0) {
    let i = -1, s = -1, o = -1, l = -1;
    for (let a = 0, c = r, u = r; a < this.children.length; a++) {
      let h = this.children[a], f = c + h.length;
      if (c < e && f > t)
        return h.domBoundsAround(e, t, c);
      if (f >= e && i == -1 && (i = a, s = c), c > t && h.dom.parentNode == this.dom) {
        o = a, l = u;
        break;
      }
      u = f, c = f + h.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? r + this.length : l,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, r = h3) {
    this.markDirty();
    for (let i = e; i < t; i++) {
      let s = this.children[i];
      s.parent == this && r.indexOf(s) < 0 && s.destroy();
    }
    r.length < 250 ? this.children.splice(e, t - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(t));
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new lC(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, r, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
It.prototype.breakAfter = 0;
function R6(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class lC {
  constructor(e, t, r) {
    this.children = e, this.pos = t, this.i = r, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function aC(n, e, t, r, i, s, o, l, a) {
  let { children: c } = n, u = c.length ? c[e] : null, h = s.length ? s[s.length - 1] : null, f = h ? h.breakAfter : o;
  if (!(e == r && u && !o && !f && s.length < 2 && u.merge(t, i, s.length ? h : null, t == 0, l, a))) {
    if (r < c.length) {
      let d = c[r];
      d && (i < d.length || d.breakAfter && h?.breakAfter) ? (e == r && (d = d.split(i), i = 0), !f && h && d.merge(0, i, h, !0, 0, a) ? s[s.length - 1] = d : ((i || d.children.length && !d.children[0].length) && d.merge(0, i, null, !1, 0, a), s.push(d))) : d?.breakAfter && (h ? h.breakAfter = 1 : o = 1), r++;
    }
    for (u && (u.breakAfter = o, t > 0 && (!o && s.length && u.merge(t, u.length, s[0], !1, l, 0) ? u.breakAfter = s.shift().breakAfter : (t < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(t, u.length, null, !1, l, 0), e++)); e < r && s.length; )
      if (c[r - 1].become(s[s.length - 1]))
        r--, s.pop(), a = s.length ? 0 : l;
      else if (c[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : a;
      else
        break;
    !s.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, l, a) && e--, (e < r || s.length) && n.replaceChildren(e, r, s);
  }
}
function cC(n, e, t, r, i, s) {
  let o = n.childCursor(), { i: l, off: a } = o.findPos(t, 1), { i: c, off: u } = o.findPos(e, -1), h = e - t;
  for (let f of r)
    h += f.length;
  n.length += h, aC(n, c, u, l, a, r, 0, i, s);
}
let Sr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, q4 = typeof document < "u" ? document : { documentElement: { style: {} } };
const W4 = /* @__PURE__ */ /Edge\/(\d+)/.exec(Sr.userAgent), uC = /* @__PURE__ */ /MSIE \d/.test(Sr.userAgent), j4 = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Sr.userAgent), r1 = !!(uC || j4 || W4), P6 = !r1 && /* @__PURE__ */ /gecko\/(\d+)/i.test(Sr.userAgent), Ig = !r1 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Sr.userAgent), oB = "webkitFontSmoothing" in q4.documentElement.style, hC = !r1 && /* @__PURE__ */ /Apple Computer/.test(Sr.vendor), _6 = hC && (/* @__PURE__ */ /Mobile\/\w+/.test(Sr.userAgent) || Sr.maxTouchPoints > 2);
var we = {
  mac: _6 || /* @__PURE__ */ /Mac/.test(Sr.platform),
  windows: /* @__PURE__ */ /Win/.test(Sr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Sr.platform),
  ie: r1,
  ie_version: uC ? q4.documentMode || 6 : j4 ? +j4[1] : W4 ? +W4[1] : 0,
  gecko: P6,
  gecko_version: P6 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Sr.userAgent) || [0, 0])[1] : 0,
  chrome: !!Ig,
  chrome_version: Ig ? +Ig[1] : 0,
  ios: _6,
  android: /* @__PURE__ */ /Android\b/.test(Sr.userAgent),
  safari: hC,
  webkit_version: oB ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Sr.userAgent) || [0, 0])[1] : 0,
  tabSize: q4.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const lB = 256;
class zi extends It {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, r) {
    return this.flags & 8 || r && (!(r instanceof zi) || this.length - (t - e) + r.length > lB || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new zi(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Un(this.dom, e);
  }
  domBoundsAround(e, t, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return aB(this.dom, e, t);
  }
}
class co extends It {
  constructor(e, t = [], r = 0) {
    super(), this.mark = e, this.children = t, this.length = r;
    for (let i of t)
      i.setParent(this);
  }
  setAttrs(e) {
    if (rC(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof co && r.mark.eq(this.mark)) || e && s <= 0 || t < this.length && o <= 0) ? !1 : (cC(this, e, t, r ? r.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], r = 0, i = -1, s = 0;
    for (let l of this.children) {
      let a = r + l.length;
      a > e && t.push(r < e ? l.split(e - r) : l), i < 0 && r >= e && (i = s), r = a, s++;
    }
    let o = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new co(this.mark, t, o);
  }
  domAtPos(e) {
    return fC(this, e);
  }
  coordsAt(e, t) {
    return pC(this, e, t);
  }
}
function aB(n, e, t) {
  let r = n.nodeValue.length;
  e > r && (e = r);
  let i = e, s = e, o = 0;
  e == 0 && t < 0 || e == r && t >= 0 ? we.chrome || we.gecko || (e ? (i--, o = 1) : s < r && (s++, o = -1)) : t < 0 ? i-- : s < r && s++;
  let l = xa(n, i, s).getClientRects();
  if (!l.length)
    return null;
  let a = l[(o ? o < 0 : t >= 0) ? 0 : l.length - 1];
  return we.safari && !o && a.width == 0 && (a = Array.prototype.find.call(l, (c) => c.width) || a), o ? n1(a, o < 0) : a || null;
}
class Jo extends It {
  static create(e, t, r) {
    return new Jo(e, t, r);
  }
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let t = Jo.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof Jo) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof Jo && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return ft.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, r = t && t.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : ft.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Un.before(this.dom) : Un.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    if (r)
      return r;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let l = o ? i.length - 1 : 0; s = i[l], !(e > 0 ? l == 0 : l == i.length - 1 || s.top < s.bottom); l += o ? -1 : 1)
      ;
    return n1(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Pc extends It {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Pc && e.side == this.side;
  }
  split() {
    return new Pc(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Un.before(this.dom) : Un.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return ft.empty;
  }
  get isHidden() {
    return !0;
  }
}
zi.prototype.children = Jo.prototype.children = Pc.prototype.children = h3;
function fC(n, e) {
  let t = n.dom, { children: r } = n, i = 0;
  for (let s = 0; i < r.length; i++) {
    let o = r[i], l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == t)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = r[s - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < r.length; s++) {
    let o = r[s];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new Un(t, 0);
}
function dC(n, e, t) {
  let r, { children: i } = n;
  t > 0 && e instanceof co && i.length && (r = i[i.length - 1]) instanceof co && r.mark.eq(e.mark) ? dC(r, e.children[0], t - 1) : (i.push(e), e.setParent(n)), n.length += e.length;
}
function pC(n, e, t) {
  let r = null, i = -1, s = null, o = -1;
  function l(c, u) {
    for (let h = 0, f = 0; h < c.children.length && f <= u; h++) {
      let d = c.children[h], p = f + d.length;
      p >= u && (d.children.length ? l(d, u - f) : (!s || s.isHidden && (t > 0 || uB(s, d))) && (p > u || f == p && d.getSide() > 0) ? (s = d, o = u - f) : (f < u || f == p && d.getSide() < 0 && !d.isHidden) && (r = d, i = u - f)), f = p;
    }
  }
  l(n, e);
  let a = (t < 0 ? r : s) || r || s;
  return a ? a.coordsAt(Math.max(0, a == r ? i : o), t) : cB(n);
}
function cB(n) {
  let e = n.dom.lastChild;
  if (!e)
    return n.dom.getBoundingClientRect();
  let t = Mf(e);
  return t[t.length - 1] || null;
}
function uB(n, e) {
  let t = n.coordsAt(0, 1), r = e.coordsAt(0, 1);
  return t && r && r.top < t.bottom;
}
function U4(n, e) {
  for (let t in n)
    t == "class" && e.class ? e.class += " " + n.class : t == "style" && e.style ? e.style += ";" + n.style : e[t] = n[t];
  return e;
}
const L6 = /* @__PURE__ */ Object.create(null);
function tm(n, e, t) {
  if (n == e)
    return !0;
  n || (n = L6), e || (e = L6);
  let r = Object.keys(n), i = Object.keys(e);
  if (r.length - (t && r.indexOf(t) > -1 ? 1 : 0) != i.length - (t && i.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let s of r)
    if (s != t && (i.indexOf(s) == -1 || n[s] !== e[s]))
      return !1;
  return !0;
}
function K4(n, e, t) {
  let r = !1;
  if (e)
    for (let i in e)
      t && i in t || (r = !0, i == "style" ? n.style.cssText = "" : n.removeAttribute(i));
  if (t)
    for (let i in t)
      e && e[i] == t[i] || (r = !0, i == "style" ? n.style.cssText = t[i] : n.setAttribute(i, t[i]));
  return r;
}
function hB(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < n.attributes.length; t++) {
    let r = n.attributes[t];
    e[r.name] = r.value;
  }
  return e;
}
let xo = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
};
var hr = /* @__PURE__ */ (function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
})(hr || (hr = {}));
let He = class extends va {
  constructor(e, t, r, i) {
    super(), this.startSide = e, this.endSide = t, this.widget = r, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new od(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return t += r && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new hl(e, t, t, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, r, i;
    if (e.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = mC(e, t);
      r = (s ? t ? -3e8 : -1 : 5e8) - 1, i = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new hl(e, r, i, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new ld(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return ut.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
};
He.none = ut.empty;
class od extends He {
  constructor(e) {
    let { start: t, end: r } = mC(e);
    super(t ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, r;
    return this == e || e instanceof od && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && tm(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
od.prototype.point = !1;
class ld extends He {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof ld && this.spec.class == e.spec.class && tm(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
ld.prototype.mapMode = Bn.TrackBefore;
ld.prototype.point = !0;
class hl extends He {
  constructor(e, t, r, i, s, o) {
    super(t, r, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? t <= 0 ? Bn.TrackBefore : Bn.TrackAfter : Bn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? hr.WidgetRange : this.startSide <= 0 ? hr.WidgetBefore : hr.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof hl && fB(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
hl.prototype.point = !0;
function mC(n, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: r } = n;
  return t == null && (t = n.inclusive), r == null && (r = n.inclusive), { start: t ?? e, end: r ?? e };
}
function fB(n, e) {
  return n == e || !!(n && e && n.compare(e));
}
function Y0(n, e, t, r = 0) {
  let i = t.length - 1;
  i >= 0 && t[i] + r >= n ? t[i] = Math.max(t[i], e) : t.push(n, e);
}
class dn extends It {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, r, i, s, o) {
    if (r) {
      if (!(r instanceof dn))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), cC(this, e, t, r ? r.children.slice() : [], s, o), !0;
  }
  split(e) {
    let t = new dn();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: r, off: i } = this.childPos(e);
    i && (t.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let s = r; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    tm(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    dC(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, r = e.spec.class;
    t && (this.attrs = U4(t, this.attrs || {})), r && (this.attrs = U4({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return fC(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var r;
    this.dom ? this.flags & 4 && (rC(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (K4(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let i = this.dom.lastChild;
    for (; i && It.get(i) instanceof co; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = It.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!we.ios || !this.children.some((s) => s instanceof zi))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let r of this.children) {
      if (!(r instanceof zi) || /[^ -~]/.test(r.text))
        return null;
      let i = Mf(r.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, t = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let r = pC(this, e, t);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = r.bottom - r.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return e instanceof dn && this.children.length == 0 && e.children.length == 0 && tm(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let s = e.children[r], o = i + s.length;
      if (o >= t) {
        if (s instanceof dn)
          return s;
        if (o > t)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class no extends It {
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof no) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Un.before(this.dom) : Un.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let r = new no(this.widget, t, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return h3;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : ft.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof no && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    return r || (this.widget instanceof G4 ? null : n1(this.dom.getBoundingClientRect(), this.length ? e == 0 : t <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: r } = this.deco;
    return t == r ? !1 : e < 0 ? t < 0 : r > 0;
  }
}
class G4 extends xo {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Hh {
  constructor(e, t, r, i) {
    this.doc = e, this.pos = t, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof no && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new dn()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Jd(new Pc(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof no) && this.getLine();
  }
  buildText(e, t, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - r)), this.getLine().append(Jd(new zi(this.text.slice(this.textOff, this.textOff + i)), t), r), this.atCursorPos = !0, this.textOff += i, e -= i, r = 0;
    }
  }
  span(e, t, r, i) {
    this.buildText(t - e, r, i), this.pos = t, this.openStart < 0 && (this.openStart = i);
  }
  point(e, t, r, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof hl) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = t - e;
    if (r instanceof hl)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new no(r.widget || _c.block, l, r));
      else {
        let a = Jo.create(r.widget || _c.inline, l, l ? 0 : r.startSide), c = this.atCursorPos && !a.isEditable && s <= i.length && (e < t || r.startSide > 0), u = !a.isEditable && (e < t || s > i.length || r.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !c && !a.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (h.append(Jd(new Pc(1), i), s), s = i.length + Math.max(0, s - i.length)), h.append(Jd(a, i), s), this.atCursorPos = u, this.pendingBuffer = u ? e < t || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, r, i, s) {
    let o = new Hh(e, t, r, s);
    return o.openEnd = ut.spans(i, t, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Jd(n, e) {
  for (let t of e)
    n = new co(t, [n], n.length);
  return n;
}
class _c extends xo {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
_c.inline = /* @__PURE__ */ new _c("span");
_c.block = /* @__PURE__ */ new _c("div");
var qt = /* @__PURE__ */ (function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
})(qt || (qt = {}));
const ka = qt.LTR, f3 = qt.RTL;
function gC(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    e.push(1 << +n[t]);
  return e;
}
const dB = /* @__PURE__ */ gC("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), pB = /* @__PURE__ */ gC("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Y4 = /* @__PURE__ */ Object.create(null), Yi = [];
for (let n of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ n.charCodeAt(0), t = /* @__PURE__ */ n.charCodeAt(1);
  Y4[e] = t, Y4[t] = -e;
}
function yC(n) {
  return n <= 247 ? dB[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? pB[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
const mB = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Xo {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? f3 : ka;
  }
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.level = r;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, r, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= t && l.to >= t) {
        if (l.level == r)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? l.from < t : l.to > t : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function bC(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++) {
    let r = n[t], i = e[t];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !bC(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const Ot = [];
function gB(n, e, t, r, i) {
  for (let s = 0; s <= r.length; s++) {
    let o = s ? r[s - 1].to : e, l = s < r.length ? r[s].from : t, a = s ? 256 : i;
    for (let c = o, u = a, h = a; c < l; c++) {
      let f = yC(n.charCodeAt(c));
      f == 512 ? f = u : f == 8 && h == 4 && (f = 16), Ot[c] = f == 4 ? 2 : f, f & 7 && (h = f), u = f;
    }
    for (let c = o, u = a, h = a; c < l; c++) {
      let f = Ot[c];
      if (f == 128)
        c < l - 1 && u == Ot[c + 1] && u & 24 ? f = Ot[c] = u : Ot[c] = 256;
      else if (f == 64) {
        let d = c + 1;
        for (; d < l && Ot[d] == 64; )
          d++;
        let p = c && u == 8 || d < t && Ot[d] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let m = c; m < d; m++)
          Ot[m] = p;
        c = d - 1;
      } else f == 8 && h == 1 && (Ot[c] = 1);
      u = f, f & 7 && (h = f);
    }
  }
}
function yB(n, e, t, r, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, l = 0, a = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e, u = o < r.length ? r[o].from : t;
    for (let h = c, f, d, p; h < u; h++)
      if (d = Y4[f = n.charCodeAt(h)])
        if (d < 0) {
          for (let m = l - 3; m >= 0; m -= 3)
            if (Yi[m + 1] == -d) {
              let g = Yi[m + 2], b = g & 2 ? i : g & 4 ? g & 1 ? s : i : 0;
              b && (Ot[h] = Ot[Yi[m]] = b), l = m;
              break;
            }
        } else {
          if (Yi.length == 189)
            break;
          Yi[l++] = h, Yi[l++] = f, Yi[l++] = a;
        }
      else if ((p = Ot[h]) == 2 || p == 1) {
        let m = p == i;
        a = m ? 0 : 1;
        for (let g = l - 3; g >= 0; g -= 3) {
          let b = Yi[g + 2];
          if (b & 2)
            break;
          if (m)
            Yi[g + 2] |= 2;
          else {
            if (b & 4)
              break;
            Yi[g + 2] |= 4;
          }
        }
      }
  }
}
function bB(n, e, t, r) {
  for (let i = 0, s = r; i <= t.length; i++) {
    let o = i ? t[i - 1].to : n, l = i < t.length ? t[i].from : e;
    for (let a = o; a < l; ) {
      let c = Ot[a];
      if (c == 256) {
        let u = a + 1;
        for (; ; )
          if (u == l) {
            if (i == t.length)
              break;
            u = t[i++].to, l = i < t.length ? t[i].from : e;
          } else if (Ot[u] == 256)
            u++;
          else
            break;
        let h = s == 1, f = (u < e ? Ot[u] : r) == 1, d = h == f ? h ? 1 : 2 : r;
        for (let p = u, m = i, g = m ? t[m - 1].to : n; p > a; )
          p == g && (p = t[--m].from, g = m ? t[m - 1].to : n), Ot[--p] = d;
        a = u;
      } else
        s = c, a++;
    }
  }
}
function J4(n, e, t, r, i, s, o) {
  let l = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let a = e, c = 0; a < t; ) {
      let u = !0, h = !1;
      if (c == s.length || a < s[c].from) {
        let m = Ot[a];
        m != l && (u = !1, h = m == 16);
      }
      let f = !u && l == 1 ? [] : null, d = u ? r : r + 1, p = a;
      e: for (; ; )
        if (c < s.length && p == s[c].from) {
          if (h)
            break e;
          let m = s[c];
          if (!u)
            for (let g = m.to, b = c + 1; ; ) {
              if (g == t)
                break e;
              if (b < s.length && s[b].from == g)
                g = s[b++].to;
              else {
                if (Ot[g] == l)
                  break e;
                break;
              }
            }
          if (c++, f)
            f.push(m);
          else {
            m.from > a && o.push(new Xo(a, m.from, d));
            let g = m.direction == ka != !(d % 2);
            X4(n, g ? r + 1 : r, i, m.inner, m.from, m.to, o), a = m.to;
          }
          p = m.to;
        } else {
          if (p == t || (u ? Ot[p] != l : Ot[p] == l))
            break;
          p++;
        }
      f ? J4(n, a, p, r + 1, i, f, o) : a < p && o.push(new Xo(a, p, d)), a = p;
    }
  else
    for (let a = t, c = s.length; a > e; ) {
      let u = !0, h = !1;
      if (!c || a > s[c - 1].to) {
        let m = Ot[a - 1];
        m != l && (u = !1, h = m == 16);
      }
      let f = !u && l == 1 ? [] : null, d = u ? r : r + 1, p = a;
      e: for (; ; )
        if (c && p == s[c - 1].to) {
          if (h)
            break e;
          let m = s[--c];
          if (!u)
            for (let g = m.from, b = c; ; ) {
              if (g == e)
                break e;
              if (b && s[b - 1].to == g)
                g = s[--b].from;
              else {
                if (Ot[g - 1] == l)
                  break e;
                break;
              }
            }
          if (f)
            f.push(m);
          else {
            m.to < a && o.push(new Xo(m.to, a, d));
            let g = m.direction == ka != !(d % 2);
            X4(n, g ? r + 1 : r, i, m.inner, m.from, m.to, o), a = m.from;
          }
          p = m.from;
        } else {
          if (p == e || (u ? Ot[p - 1] != l : Ot[p - 1] == l))
            break;
          p--;
        }
      f ? J4(n, p, a, r + 1, i, f, o) : p < a && o.push(new Xo(p, a, d)), a = p;
    }
}
function X4(n, e, t, r, i, s, o) {
  let l = e % 2 ? 2 : 1;
  gB(n, i, s, r, l), yB(n, i, s, r, l), bB(i, s, r, l), J4(n, i, s, e, t, r, o);
}
function vB(n, e, t) {
  if (!n)
    return [new Xo(0, 0, e == f3 ? 1 : 0)];
  if (e == ka && !t.length && !mB.test(n))
    return vC(n.length);
  if (t.length)
    for (; n.length > Ot.length; )
      Ot[Ot.length] = 256;
  let r = [], i = e == ka ? 0 : 1;
  return X4(n, i, i, t, 0, n.length, r), r;
}
function vC(n) {
  return [new Xo(0, n, 0)];
}
let wC = "";
function wB(n, e, t, r, i) {
  var s;
  let o = r.head - n.from, l = Xo.find(e, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc), a = e[l], c = a.side(i, t);
  if (o == c) {
    let f = l += i ? 1 : -1;
    if (f < 0 || f >= e.length)
      return null;
    a = e[l = f], o = a.side(!i, t), c = a.side(i, t);
  }
  let u = zn(n.text, o, a.forward(i, t));
  (u < a.from || u > a.to) && (u = c), wC = n.text.slice(Math.min(o, u), Math.max(o, u));
  let h = l == (i ? e.length - 1 : 0) ? null : e[l + (i ? 1 : -1)];
  return h && u == c && h.level + (i ? 0 : 1) < a.level ? G.cursor(h.side(!i, t) + n.from, h.forward(i, t) ? 1 : -1, h.level) : G.cursor(u + n.from, a.forward(i, t) ? -1 : 1, a.level);
}
function xB(n, e, t) {
  for (let r = e; r < t; r++) {
    let i = yC(n.charCodeAt(r));
    if (i == 1)
      return ka;
    if (i == 2 || i == 4)
      return f3;
  }
  return ka;
}
const xC = /* @__PURE__ */ xe.define(), kC = /* @__PURE__ */ xe.define(), SC = /* @__PURE__ */ xe.define(), CC = /* @__PURE__ */ xe.define(), Z4 = /* @__PURE__ */ xe.define(), MC = /* @__PURE__ */ xe.define(), TC = /* @__PURE__ */ xe.define(), d3 = /* @__PURE__ */ xe.define(), p3 = /* @__PURE__ */ xe.define(), AC = /* @__PURE__ */ xe.define({
  combine: (n) => n.some((e) => e)
}), OC = /* @__PURE__ */ xe.define({
  combine: (n) => n.some((e) => e)
}), EC = /* @__PURE__ */ xe.define();
class vc {
  constructor(e, t = "nearest", r = "nearest", i = 5, s = 5, o = !1) {
    this.range = e, this.y = t, this.x = r, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new vc(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new vc(G.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Xd = /* @__PURE__ */ Xe.define({ map: (n, e) => n.map(e) }), IC = /* @__PURE__ */ Xe.define();
function Mr(n, e, t) {
  let r = n.facet(CC);
  r.length ? r[0](e) : window.onerror && window.onerror(String(e), t, void 0, void 0, e) || (t ? console.error(t + ":", e) : console.error(e));
}
const Js = /* @__PURE__ */ xe.define({ combine: (n) => n.length ? n[0] : !0 });
let kB = 0;
const pc = /* @__PURE__ */ xe.define({
  combine(n) {
    return n.filter((e, t) => {
      for (let r = 0; r < t; r++)
        if (n[r].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class gn {
  constructor(e, t, r, i, s) {
    this.id = e, this.create = t, this.domEventHandlers = r, this.domEventObservers = i, this.baseExtensions = s(this), this.extension = this.baseExtensions.concat(pc.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(pc.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: r, eventObservers: i, provide: s, decorations: o } = t || {};
    return new gn(kB++, e, r, i, (l) => {
      let a = [];
      return o && a.push(Tf.of((c) => {
        let u = c.plugin(l);
        return u ? o(u) : He.none;
      })), s && a.push(s(l)), a;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return gn.define((r, i) => new e(r, i), t);
  }
}
class Dg {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (r) {
            if (Mr(t.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (t) {
        Mr(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Mr(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const DC = /* @__PURE__ */ xe.define(), m3 = /* @__PURE__ */ xe.define(), Tf = /* @__PURE__ */ xe.define(), NC = /* @__PURE__ */ xe.define(), i1 = /* @__PURE__ */ xe.define(), RC = /* @__PURE__ */ xe.define();
function B6(n, e) {
  let t = n.state.facet(RC);
  if (!t.length)
    return t;
  let r = t.map((s) => s instanceof Function ? s(n) : s), i = [];
  return ut.spans(r, e.from, e.to, {
    point() {
    },
    span(s, o, l, a) {
      let c = s - e.from, u = o - e.from, h = i;
      for (let f = l.length - 1; f >= 0; f--, a--) {
        let d = l[f].spec.bidiIsolate, p;
        if (d == null && (d = xB(e.text, c, u)), a > 0 && h.length && (p = h[h.length - 1]).to == c && p.direction == d)
          p.to = u, h = p.inner;
        else {
          let m = { from: c, to: u, direction: d, inner: [] };
          h.push(m), h = m.inner;
        }
      }
    }
  }), i;
}
const PC = /* @__PURE__ */ xe.define();
function g3(n) {
  let e = 0, t = 0, r = 0, i = 0;
  for (let s of n.state.facet(PC)) {
    let o = s(n);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: t, top: r, bottom: i };
}
const Qu = /* @__PURE__ */ xe.define();
class di {
  constructor(e, t, r, i) {
    this.fromA = e, this.toA = t, this.fromB = r, this.toB = i;
  }
  join(e) {
    return new di(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, r = this;
    for (; t > 0; t--) {
      let i = e[t - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, r), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let r = [];
    for (let i = 0, s = 0, o = 0, l = 0; ; i++) {
      let a = i == e.length ? null : e[i], c = o - l, u = a ? a.fromB : 1e9;
      for (; s < t.length && t[s] < u; ) {
        let h = t[s], f = t[s + 1], d = Math.max(l, h), p = Math.min(u, f);
        if (d <= p && new di(d + c, p + c, d, p).addToSet(r), f > u)
          break;
        s += 2;
      }
      if (!a)
        return r;
      new di(a.fromA, a.toA, a.fromB, a.toB).addToSet(r), o = a.toA, l = a.toB;
    }
  }
}
class nm {
  constructor(e, t, r) {
    this.view = e, this.state = t, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = wn.empty(this.startState.doc.length);
    for (let s of r)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, l, a) => i.push(new di(s, o, l, a))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new nm(e, t, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class z6 extends It {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = He.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new dn()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new di(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? i = this.domChanged.newSel.head : !EB(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? CB(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      r = new di(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (we.ie || we.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, l = this.updateDeco(), a = AB(o, l, e.changes);
    return r = di.extendWithRanges(r, a), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = we.chrome || we.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof no && o.widget instanceof G4 && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, t, r) {
    let i = r ? r.range.addToSet(e.slice()) : e, s = this.childCursor(t);
    for (let o = i.length - 1; ; o--) {
      let l = o >= 0 ? i[o] : null;
      if (!l)
        break;
      let { fromA: a, toA: c, fromB: u, toB: h } = l, f, d, p, m;
      if (r && r.range.fromB < h && r.range.toB > u) {
        let C = Hh.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), M = Hh.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
        d = C.breakAtStart, p = C.openStart, m = M.openEnd;
        let T = this.compositionView(r);
        M.breakAtStart ? T.breakAfter = 1 : M.content.length && T.merge(T.length, T.length, M.content[0], !1, M.openStart, 0) && (T.breakAfter = M.content[0].breakAfter, M.content.shift()), C.content.length && T.merge(0, 0, C.content[C.content.length - 1], !0, 0, C.openEnd) && C.content.pop(), f = C.content.concat(T).concat(M.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: m } = Hh.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
      let { i: g, off: b } = s.findPos(c, 1), { i: w, off: k } = s.findPos(a, -1);
      aC(this, w, k, g, b, f, d, p, m);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(IC) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let t = new zi(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: i } of e.marks)
      t = new co(i, [t], t.length);
    let r = new dn();
    return r.append(t, 0), r;
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (a) => a.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let l = It.get(s);
      l && l != o && (l.dom = null), o.setDOM(s);
    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
    t(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      r = i.childPos(r.off, 1), i = i.children[r.i], t(s >= 0 ? e.marks[s].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, s = !i && !(this.view.state.facet(Js) || this.dom.tabIndex > -1) && G0(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || t || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, a = this.moveToLine(this.domAtPos(l.anchor)), c = l.empty ? a : this.moveToLine(this.domAtPos(l.head));
    if (we.gecko && l.empty && !this.hasComposition && SB(a)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => a.node.insertBefore(h, a.node.childNodes[a.offset] || null)), a = c = new Un(h, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || (!Fh(a.node, a.offset, u.anchorNode, u.anchorOffset) || !Fh(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, l)) && (this.view.observer.ignore(() => {
      we.android && we.chrome && this.dom.contains(u.focusNode) && OB(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Cf(this.view.root);
      if (h) if (l.empty) {
        if (we.gecko) {
          let f = MB(a.node, a.offset);
          if (f && f != 3) {
            let d = (f == 1 ? sC : oC)(a.node, a.offset);
            d && (a = new Un(d.node, d.offset));
          }
        }
        h.collapse(a.node, a.offset), l.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = l.bidiLevel);
      } else if (h.extend) {
        h.collapse(a.node, a.offset);
        try {
          h.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let f = document.createRange();
        l.anchor > l.head && ([a, c] = [c, a]), f.setEnd(c.node, c.offset), f.setStart(a.node, a.offset), h.removeAllRanges(), h.addRange(f);
      }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(a, c)), this.impreciseAnchor = a.precise ? null : new Un(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new Un(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && Fh(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, r = Cf(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!r || !t.empty || !t.assoc || !r.modify)
      return;
    let o = dn.find(this, t.head);
    if (!o)
      return;
    let l = o.posAtStart;
    if (t.head == l || t.head == l + o.length)
      return;
    let a = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!a || !c || a.bottom > c.top)
      return;
    let u = this.domAtPos(t.head + t.assoc);
    r.collapse(u.node, u.offset), r.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != t.from && r.collapse(i, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, r;
    if (e.node != t)
      return e;
    for (let i = e.offset; !r && i < t.childNodes.length; i++) {
      let s = It.get(t.childNodes[i]);
      s instanceof dn && (r = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let s = It.get(t.childNodes[i]);
      s instanceof dn && (r = s.domAtPos(s.length));
    }
    return r ? new Un(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let r = It.get(t);
      if (r && r.rootView == this)
        return r;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, t) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: r } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let i = this.children[t];
      if (r < i.length || i instanceof dn)
        break;
      t++, r = 0;
    }
    return this.children[t].domAtPos(r);
  }
  coordsAt(e, t) {
    let r = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let l = this.children[o], a = s - l.breakAfter, c = a - l.length;
      if (a < e)
        break;
      if (c <= e && (c < e || l.covers(-1)) && (a > e || l.covers(1)) && (!r || l instanceof dn && !(r instanceof dn && t >= 0)))
        r = l, i = c;
      else if (r && c == e && a == e && l instanceof no && Math.abs(t) < 2) {
        if (l.deco.startSide < 0)
          break;
        o && (r = null);
      }
      s = c;
    }
    return r ? r.coordsAt(e - i, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: r } = this.childPos(e, 1), i = this.children[t];
    if (!(i instanceof dn))
      return null;
    for (; i.children.length; ) {
      let { i: l, off: a } = i.childPos(r, 1);
      for (; ; l++) {
        if (l == i.children.length)
          return null;
        if ((i = i.children[l]).length)
          break;
      }
      r = a;
    }
    if (!(i instanceof zi))
      return null;
    let s = zn(i.text, r);
    if (s == r)
      return null;
    let o = xa(i.dom, r, s).getClientRects();
    for (let l = 0; l < o.length; l++) {
      let a = o[l];
      if (l == o.length - 1 || a.top < a.bottom && a.left < a.right)
        return a;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: r, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, a = this.view.textDirection == qt.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let h = this.children[u], f = c + h.length;
      if (f > i)
        break;
      if (c >= r) {
        let d = h.dom.getBoundingClientRect();
        if (t.push(d.height), o) {
          let p = h.dom.lastChild, m = p ? Mf(p) : [];
          if (m.length) {
            let g = m[m.length - 1], b = a ? g.right - d.left : d.right - g.left;
            b > l && (l = b, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + h.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? qt.RTL : qt.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof dn) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, r, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Mf(e.firstChild)[0];
      t = e.getBoundingClientRect().height, r = s ? s.width / 27 : 7, i = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: r, textHeight: i };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new lC(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let s = i == t.viewports.length ? null : t.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > r) {
        let l = (t.lineBlockAt(o).bottom - t.lineBlockAt(r).top) / this.view.scaleY;
        e.push(He.replace({
          widget: new G4(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!s)
        break;
      r = s.to + 1;
    }
    return He.set(e);
  }
  updateDeco() {
    let e = 1, t = this.view.state.facet(Tf).map((s) => (this.dynamicDecorationMap[e++] = typeof s == "function") ? s(this.view) : s), r = !1, i = this.view.state.facet(NC).map((s, o) => {
      let l = typeof s == "function";
      return l && (r = !0), l ? s(this.view) : s;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = r, t.push(ut.join(i))), this.decorations = [
      this.editContextFormatting,
      ...t,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(EC))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (u) {
        Mr(this.view.state, u, "scroll handler");
      }
    let { range: t } = e, r = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), i;
    if (!r)
      return;
    !t.empty && (i = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let s = g3(this.view), o = {
      left: r.left - s.left,
      top: r.top - s.top,
      right: r.right + s.right,
      bottom: r.bottom + s.bottom
    }, { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM;
    tB(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, a), -a), this.view.textDirection == qt.LTR);
  }
}
function SB(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
function _C(n, e) {
  let t = n.observer.selectionRange;
  if (!t.focusNode)
    return null;
  let r = sC(t.focusNode, t.focusOffset), i = oC(t.focusNode, t.focusOffset), s = r || i;
  if (i && r && i.node != r.node) {
    let l = It.get(i.node);
    if (!l || l instanceof zi && l.text != i.node.nodeValue)
      s = i;
    else if (n.docView.lastCompositionAfterCursor) {
      let a = It.get(r.node);
      !a || a instanceof zi && a.text != r.node.nodeValue || (s = i);
    }
  }
  if (n.docView.lastCompositionAfterCursor = s != r, !s)
    return null;
  let o = e - s.offset;
  return { from: o, to: o + s.node.nodeValue.length, node: s.node };
}
function CB(n, e, t) {
  let r = _C(n, t);
  if (!r)
    return null;
  let { node: i, from: s, to: o } = r, l = i.nodeValue;
  if (/[\n\r]/.test(l) || n.state.doc.sliceString(r.from, r.to) != l)
    return null;
  let a = e.invertedDesc, c = new di(a.mapPos(s), a.mapPos(o), s, o), u = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let f = It.get(h);
    if (f instanceof co)
      u.push({ node: h, deco: f.mark });
    else {
      if (f instanceof dn || h.nodeName == "DIV" && h.parentNode == n.contentDOM)
        return { range: c, text: i, marks: u, line: h };
      if (h != n.contentDOM)
        u.push({ node: h, deco: new od({
          inclusive: !0,
          attributes: hB(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function MB(n, e) {
  return n.nodeType != 1 ? 0 : (e && n.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < n.childNodes.length && n.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let TB = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    Y0(e, t, this.changes);
  }
  comparePoint(e, t) {
    Y0(e, t, this.changes);
  }
  boundChange(e) {
    Y0(e, e, this.changes);
  }
};
function AB(n, e, t) {
  let r = new TB();
  return ut.compare(n, e, t, r), r.changes;
}
function OB(n, e) {
  for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function EB(n, e) {
  let t = !1;
  return e && n.iterChangedRanges((r, i) => {
    r < e.to && i > e.from && (t = !0);
  }), t;
}
function IB(n, e, t = 1) {
  let r = n.charCategorizer(e), i = n.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return G.cursor(e);
  s == 0 ? t = 1 : s == i.length && (t = -1);
  let o = s, l = s;
  t < 0 ? o = zn(i.text, s, !1) : l = zn(i.text, s);
  let a = r(i.text.slice(o, l));
  for (; o > 0; ) {
    let c = zn(i.text, o, !1);
    if (r(i.text.slice(c, o)) != a)
      break;
    o = c;
  }
  for (; l < i.length; ) {
    let c = zn(i.text, l);
    if (r(i.text.slice(l, c)) != a)
      break;
    l = c;
  }
  return G.range(o + i.from, l + i.from);
}
function DB(n, e) {
  return e.left > n ? e.left - n : Math.max(0, n - e.right);
}
function NB(n, e) {
  return e.top > n ? e.top - n : Math.max(0, n - e.bottom);
}
function Ng(n, e) {
  return n.top < e.bottom - 1 && n.bottom > e.top + 1;
}
function F6(n, e) {
  return e < n.top ? { top: e, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function H6(n, e) {
  return e > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: e } : n;
}
function Q4(n, e, t) {
  let r, i, s, o, l = !1, a, c, u, h;
  for (let p = n.firstChild; p; p = p.nextSibling) {
    let m = Mf(p);
    for (let g = 0; g < m.length; g++) {
      let b = m[g];
      i && Ng(i, b) && (b = F6(H6(b, i.bottom), i.top));
      let w = DB(e, b), k = NB(t, b);
      if (w == 0 && k == 0)
        return p.nodeType == 3 ? $6(p, e, t) : Q4(p, e, t);
      (!r || o > k || o == k && s > w) && (r = p, i = b, s = w, o = k, l = w ? e < b.left ? g > 0 : g < m.length - 1 : !0), w == 0 ? t > b.bottom && (!u || u.bottom < b.bottom) ? (a = p, u = b) : t < b.top && (!h || h.top > b.top) && (c = p, h = b) : u && Ng(u, b) ? u = H6(u, b.bottom) : h && Ng(h, b) && (h = F6(h, b.top));
    }
  }
  if (u && u.bottom >= t ? (r = a, i = u) : h && h.top <= t && (r = c, i = h), !r)
    return { node: n, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3)
    return $6(r, f, t);
  if (l && r.contentEditable != "false")
    return Q4(r, f, t);
  let d = Array.prototype.indexOf.call(n.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: n, offset: d };
}
function $6(n, e, t) {
  let r = n.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let l = 0; l < r; l++) {
    let a = xa(n, l, l + 1).getClientRects();
    for (let c = 0; c < a.length; c++) {
      let u = a[c];
      if (u.top == u.bottom)
        continue;
      o || (o = e - u.left);
      let h = (u.top > t ? u.top - t : t - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && h < s) {
        let f = e >= (u.left + u.right) / 2, d = f;
        if ((we.chrome || we.gecko) && xa(n, l).getBoundingClientRect().left == u.right && (d = !f), h <= 0)
          return { node: n, offset: l + (d ? 1 : 0) };
        i = l + (d ? 1 : 0), s = h;
      }
    }
  }
  return { node: n, offset: i > -1 ? i : o > 0 ? n.nodeValue.length : 0 };
}
function LC(n, e, t, r = -1) {
  var i, s;
  let o = n.contentDOM.getBoundingClientRect(), l = o.top + n.viewState.paddingTop, a, { docHeight: c } = n.viewState, { x: u, y: h } = e, f = h - l;
  if (f < 0)
    return 0;
  if (f > c)
    return n.state.doc.length;
  for (let C = n.viewState.heightOracle.textHeight / 2, M = !1; a = n.elementAtHeight(f), a.type != hr.Text; )
    for (; f = r > 0 ? a.bottom + C : a.top - C, !(f >= 0 && f <= c); ) {
      if (M)
        return t ? null : 0;
      M = !0, r = -r;
    }
  h = l + f;
  let d = a.from;
  if (d < n.viewport.from)
    return n.viewport.from == 0 ? 0 : t ? null : V6(n, o, a, u, h);
  if (d > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : t ? null : V6(n, o, a, u, h);
  let p = n.dom.ownerDocument, m = n.root.elementFromPoint ? n.root : p, g = m.elementFromPoint(u, h);
  g && !n.contentDOM.contains(g) && (g = null), g || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), g = m.elementFromPoint(u, h), g && !n.contentDOM.contains(g) && (g = null));
  let b, w = -1;
  if (g && ((i = n.docView.nearest(g)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let C = p.caretPositionFromPoint(u, h);
      C && ({ offsetNode: b, offset: w } = C);
    } else if (p.caretRangeFromPoint) {
      let C = p.caretRangeFromPoint(u, h);
      C && ({ startContainer: b, startOffset: w } = C, (!n.contentDOM.contains(b) || we.safari && RB(b, w, u) || we.chrome && PB(b, w, u)) && (b = void 0));
    }
    b && (w = Math.min(ws(b), w));
  }
  if (!b || !n.docView.dom.contains(b)) {
    let C = dn.find(n.docView, d);
    if (!C)
      return f > a.top + a.height / 2 ? a.to : a.from;
    ({ node: b, offset: w } = Q4(C.dom, u, h));
  }
  let k = n.docView.nearest(b);
  if (!k)
    return null;
  if (k.isWidget && ((s = k.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let C = k.dom.getBoundingClientRect();
    return e.y < C.top || e.y <= C.bottom && e.x <= (C.left + C.right) / 2 ? k.posAtStart : k.posAtEnd;
  } else
    return k.localPosFromDOM(b, w) + k.posAtStart;
}
function V6(n, e, t, r, i) {
  let s = Math.round((r - e.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
    let l = n.viewState.heightOracle.textHeight, a = Math.floor((i - t.top - (n.defaultLineHeight - l) * 0.5) / l);
    s += a * n.viewState.heightOracle.lineLength;
  }
  let o = n.state.sliceDoc(t.from, t.to);
  return t.from + F4(o, s, n.state.tabSize);
}
function RB(n, e, t) {
  let r, i = n;
  if (n.nodeType != 3 || e != (r = n.nodeValue.length))
    return !1;
  for (; ; ) {
    let s = i.nextSibling;
    if (s) {
      if (s.nodeName == "BR")
        break;
      return !1;
    } else {
      let o = i.parentNode;
      if (!o || o.nodeName == "DIV")
        break;
      i = o;
    }
  }
  return xa(n, r - 1, r).getBoundingClientRect().right > t;
}
function PB(n, e, t) {
  if (e != 0)
    return !1;
  for (let i = n; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let r = n.nodeType == 1 ? n.getBoundingClientRect() : xa(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return t - r.left > 5;
}
function ey(n, e, t) {
  let r = n.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    let i;
    for (let s of r.type) {
      if (s.from > e)
        break;
      if (!(s.to < e)) {
        if (s.from < e && s.to > e)
          return s;
        (!i || s.type == hr.Text && (i.type != s.type || (t < 0 ? s.from < e : s.to > e))) && (i = s);
      }
    }
    return i || r;
  }
  return r;
}
function _B(n, e, t, r) {
  let i = ey(n, e.head, e.assoc || -1), s = !r || i.type != hr.Text || !(n.lineWrapping || i.widgetLineBreaks) ? null : n.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = n.dom.getBoundingClientRect(), l = n.textDirectionAt(i.from), a = n.posAtCoords({
      x: t == (l == qt.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (a != null)
      return G.cursor(a, t ? -1 : 1);
  }
  return G.cursor(t ? i.to : i.from, t ? -1 : 1);
}
function q6(n, e, t, r) {
  let i = n.state.doc.lineAt(e.head), s = n.bidiSpans(i), o = n.textDirectionAt(i.from);
  for (let l = e, a = null; ; ) {
    let c = wB(i, s, o, l, t), u = wC;
    if (!c) {
      if (i.number == (t ? n.state.doc.lines : 1))
        return l;
      u = `
`, i = n.state.doc.line(i.number + (t ? 1 : -1)), s = n.bidiSpans(i), c = n.visualLineSide(i, !t);
    }
    if (a) {
      if (!a(u))
        return l;
    } else {
      if (!r)
        return c;
      a = r(u);
    }
    l = c;
  }
}
function LB(n, e, t) {
  let r = n.state.charCategorizer(e), i = r(t);
  return (s) => {
    let o = r(s);
    return i == Wt.Space && (i = o), i == o;
  };
}
function BB(n, e, t, r) {
  let i = e.head, s = t ? 1 : -1;
  if (i == (t ? n.state.doc.length : 0))
    return G.cursor(i, e.assoc);
  let o = e.goalColumn, l, a = n.contentDOM.getBoundingClientRect(), c = n.coordsAtPos(i, e.assoc || -1), u = n.documentTop;
  if (c)
    o == null && (o = c.left - a.left), l = s < 0 ? c.top : c.bottom;
  else {
    let d = n.viewState.lineBlockAt(i);
    o == null && (o = Math.min(a.right - a.left, n.defaultCharacterWidth * (i - d.from))), l = (s < 0 ? d.top : d.bottom) + u;
  }
  let h = a.left + o, f = r ?? n.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = l + (f + d) * s, m = LC(n, { x: h, y: p }, !1, s);
    if (p < a.top || p > a.bottom || (s < 0 ? m < i : m > i)) {
      let g = n.docView.coordsForChar(m), b = !g || p < g.top ? -1 : 1;
      return G.cursor(m, b, void 0, o);
    }
  }
}
function J0(n, e, t) {
  for (; ; ) {
    let r = 0;
    for (let i of n)
      i.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let a = r || t || (e - s < o - e ? -1 : 1);
          e = a < 0 ? s : o, r = a;
        }
      });
    if (!r)
      return e;
  }
}
function BC(n, e) {
  let t = null;
  for (let r = 0; r < e.ranges.length; r++) {
    let i = e.ranges[r], s = null;
    if (i.empty) {
      let o = J0(n, i.from, 0);
      o != i.from && (s = G.cursor(o, -1));
    } else {
      let o = J0(n, i.from, -1), l = J0(n, i.to, 1);
      (o != i.from || l != i.to) && (s = G.range(i.from == i.anchor ? o : l, i.from == i.head ? o : l));
    }
    s && (t || (t = e.ranges.slice()), t[r] = s);
  }
  return t ? G.create(t, e.mainIndex) : e;
}
function Rg(n, e, t) {
  let r = J0(n.state.facet(i1).map((i) => i(n)), t.from, e.head > t.from ? -1 : 1);
  return r == t.from ? t : G.cursor(r, r < t.from ? 1 : -1);
}
const eh = "￿";
class zB {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(jt.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += eh;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == t)
        break;
      let l = It.get(i), a = It.get(o);
      (l && a ? l.breakAfter : (l ? l.breakAfter : em(i)) || em(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(r, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, t.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, l;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (l = i.exec(t)) && (s = l.index, o = l[0].length), this.append(t.slice(r, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= o - 1);
      r = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = It.get(e), r = t && t.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == t && (r.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (FB(e, r.node, r.offset) ? t : 0));
  }
}
function FB(n, e, t) {
  for (; ; ) {
    if (!e || t < ws(e))
      return !1;
    if (e == n)
      return !0;
    t = wa(e) + 1, e = e.parentNode;
  }
}
class W6 {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class HB {
  constructor(e, t, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = t > -1;
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, r, 0))) {
      let l = s || o ? [] : qB(e), a = new zB(l, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = WB(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, a = s && s.node == l.focusNode && s.offset == l.focusOffset || !V4(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), c = o && o.node == l.anchorNode && o.offset == l.anchorOffset || !V4(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset), u = e.viewport;
      if ((we.ios || we.chrome) && e.state.selection.main.empty && a != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let h = Math.min(a, c), f = Math.max(a, c), d = u.from - h, p = u.to - f;
        (d == 0 || d == 1 || h == 0) && (p == 0 || p == -1 || f == e.state.doc.length) && (a = 0, c = e.state.doc.length);
      }
      this.newSel = G.single(c, a);
    }
  }
}
function zC(n, e) {
  let t, { newSel: r } = e, i = n.state.selection.main, s = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds, a = i.from, c = null;
    (s === 8 || we.android && e.text.length < l - o) && (a = i.to, c = "end");
    let u = VB(n.state.doc.sliceString(o, l, eh), e.text, a - o, c);
    u && (we.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == eh + eh && u.toB--, t = {
      from: o + u.from,
      to: o + u.toA,
      insert: ft.of(e.text.slice(u.from, u.toB).split(eh))
    });
  } else r && (!n.hasFocus && n.state.facet(Js) || r.main.eq(i)) && (r = null);
  if (!t && !r)
    return !1;
  if (!t && e.typeOver && !i.empty && r && r.main.empty ? t = { from: i.from, to: i.to, insert: n.state.doc.slice(i.from, i.to) } : (we.mac || we.android) && t && t.from == t.to && t.from == i.head - 1 && /^\. ?$/.test(t.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (r && t.insert.length == 2 && (r = G.single(r.main.anchor - 1, r.main.head - 1)), t = { from: t.from, to: t.to, insert: ft.of([t.insert.toString().replace(".", " ")]) }) : t && t.from >= i.from && t.to <= i.to && (t.from != i.from || t.to != i.to) && i.to - i.from - (t.to - t.from) <= 4 ? t = {
    from: i.from,
    to: i.to,
    insert: n.state.doc.slice(i.from, t.from).append(t.insert).append(n.state.doc.slice(t.to, i.to))
  } : we.chrome && t && t.from == t.to && t.from == i.head && t.insert.toString() == `
 ` && n.lineWrapping && (r && (r = G.single(r.main.anchor - 1, r.main.head - 1)), t = { from: i.from, to: i.to, insert: ft.of([" "]) }), t)
    return y3(n, t, r, s);
  if (r && !r.main.eq(i)) {
    let o = !1, l = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (o = !0), l = n.inputState.lastSelectionOrigin, l == "select.pointer" && (r = BC(n.state.facet(i1).map((a) => a(n)), r))), n.dispatch({ selection: r, scrollIntoView: o, userEvent: l }), !0;
  } else
    return !1;
}
function y3(n, e, t, r = -1) {
  if (we.ios && n.inputState.flushIOSKey(e))
    return !0;
  let i = n.state.selection.main;
  if (we.android && (e.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == i.from || e.from == i.from - 1 && n.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && bc(n.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && bc(n.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && bc(n.contentDOM, "Delete", 46)))
    return !0;
  let s = e.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let o, l = () => o || (o = $B(n, e, t));
  return n.state.facet(MC).some((a) => a(n, e.from, e.to, s, l)) || n.dispatch(l()), !0;
}
function $B(n, e, t) {
  let r, i = n.state, s = i.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && n.inputState.composing < 0) {
    let l = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", a = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    r = i.replaceSelection(n.state.toText(l + e.insert.sliceString(0, void 0, n.state.lineBreak) + a));
  } else {
    let l = i.changes(e), a = t && t.main.to <= l.newLength ? t.main : void 0;
    if (i.selection.ranges.length > 1 && n.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = n.state.sliceDoc(e.from, e.to), u, h = t && _C(n, t.main.head);
      if (h) {
        let p = e.insert.length - (e.to - e.from);
        u = { from: h.from, to: h.to - p };
      } else
        u = n.state.doc.lineAt(s.head);
      let f = s.to - e.to, d = s.to - s.from;
      r = i.changeByRange((p) => {
        if (p.from == s.from && p.to == s.to)
          return { changes: l, range: a || p.map(l) };
        let m = p.to - f, g = m - c.length;
        if (p.to - p.from != d || n.state.sliceDoc(g, m) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= u.from && p.from <= u.to)
          return { range: p };
        let b = i.changes({ from: g, to: m, insert: e.insert }), w = p.to - s.to;
        return {
          changes: b,
          range: a ? G.range(Math.max(0, a.anchor + w), Math.max(0, a.head + w)) : p.map(b)
        };
      });
    } else
      r = {
        changes: l,
        selection: a && i.selection.replaceRange(a)
      };
  }
  let o = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, o += ".compose", n.inputState.compositionFirstChange && (o += ".start", n.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: o, scrollIntoView: !0 });
}
function VB(n, e, t, r) {
  let i = Math.min(n.length, e.length), s = 0;
  for (; s < i && n.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && n.length == e.length)
    return null;
  let o = n.length, l = e.length;
  for (; o > 0 && l > 0 && n.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (r == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    t -= o + a - s;
  }
  if (o < s && n.length < e.length) {
    let a = t <= s && t >= o ? s - t : 0;
    s -= a, l = s + (l - o), o = s;
  } else if (l < s) {
    let a = t <= s && t >= l ? s - t : 0;
    s -= a, o = s + (o - l), l = s;
  }
  return { from: s, toA: o, toB: l };
}
function qB(n) {
  let e = [];
  if (n.root.activeElement != n.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s } = n.observer.selectionRange;
  return t && (e.push(new W6(t, r)), (i != t || s != r) && e.push(new W6(i, s))), e;
}
function WB(n, e) {
  if (n.length == 0)
    return null;
  let t = n[0].pos, r = n.length == 2 ? n[1].pos : t;
  return t > -1 && r > -1 ? G.single(t + e, r + e) : null;
}
let jB = class {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, we.safari && e.contentDOM.addEventListener("input", () => null), we.gecko && lz(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !QB(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, t) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers)
        i(this.view, t);
      for (let i of r.handlers) {
        if (t.defaultPrevented)
          break;
        if (i(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = UB(e), r = this.handlers, i = this.view.contentDOM;
    for (let s in t)
      if (s != "scroll") {
        let o = !t[s].handlers.length, l = r[s];
        l && o != !l.handlers.length && (i.removeEventListener(s, this.handleEvent), l = null), l || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in r)
      s != "scroll" && !t[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && HC.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), we.android && we.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return we.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = FC.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || KB.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return !t || t.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, bc(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : we.safari && !we.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
function j6(n, e) {
  return (t, r) => {
    try {
      return e.call(n, r, t);
    } catch (i) {
      Mr(t.state, i);
    }
  };
}
function UB(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of n) {
    let i = r.spec, s = i && i.plugin.domEventHandlers, o = i && i.plugin.domEventObservers;
    if (s)
      for (let l in s) {
        let a = s[l];
        a && t(l).handlers.push(j6(r.value, a));
      }
    if (o)
      for (let l in o) {
        let a = o[l];
        a && t(l).observers.push(j6(r.value, a));
      }
  }
  for (let r in Fi)
    t(r).handlers.push(Fi[r]);
  for (let r in vi)
    t(r).observers.push(vi[r]);
  return e;
}
const FC = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], KB = "dthko", HC = [16, 17, 18, 20, 91, 92, 224, 225], Zd = 6;
function Qd(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function GB(n, e) {
  return Math.max(Math.abs(n.clientX - e.clientX), Math.abs(n.clientY - e.clientY));
}
class YB {
  constructor(e, t, r, i) {
    this.view = e, this.startEvent = t, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParents = nB(e.contentDOM), this.atoms = e.state.facet(i1).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(jt.allowMultipleSelections) && JB(e, t), this.dragging = ZB(e, t) && qC(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && GB(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let t = 0, r = 0, i = 0, s = 0, o = this.view.win.innerWidth, l = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: s, bottom: l } = this.scrollParents.y.getBoundingClientRect());
    let a = g3(this.view);
    e.clientX - a.left <= i + Zd ? t = -Qd(i - e.clientX) : e.clientX + a.right >= o - Zd && (t = Qd(e.clientX - o)), e.clientY - a.top <= s + Zd ? r = -Qd(s - e.clientY) : e.clientY + a.bottom >= l - Zd && (r = Qd(e.clientY - l)), this.setScrollSpeed(t, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: t } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), t && this.scrollParents.y && (this.scrollParents.y.scrollTop += t, t = 0), (e || t) && this.view.win.scrollBy(e, t), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(e) {
    let { view: t } = this, r = BC(this.atoms, this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((t) => t.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function JB(n, e) {
  let t = n.state.facet(xC);
  return t.length ? t[0](e) : we.mac ? e.metaKey : e.ctrlKey;
}
function XB(n, e) {
  let t = n.state.facet(kC);
  return t.length ? t[0](e) : we.mac ? !e.altKey : !e.ctrlKey;
}
function ZB(n, e) {
  let { main: t } = n.state.selection;
  if (t.empty)
    return !1;
  let r = Cf(n.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function QB(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, r; t != n.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (r = It.get(t)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const Fi = /* @__PURE__ */ Object.create(null), vi = /* @__PURE__ */ Object.create(null), $C = we.ie && we.ie_version < 15 || we.ios && we.webkit_version < 604;
function ez(n) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    n.focus(), t.remove(), VC(n, t.value);
  }, 50);
}
function s1(n, e, t) {
  for (let r of n.facet(e))
    t = r(t, n);
  return t;
}
function VC(n, e) {
  e = s1(n.state, d3, e);
  let { state: t } = n, r, i = 1, s = t.toText(e), o = s.lines == t.selection.ranges.length;
  if (ty != null && t.selection.ranges.every((a) => a.empty) && ty == s.toString()) {
    let a = -1;
    r = t.changeByRange((c) => {
      let u = t.doc.lineAt(c.from);
      if (u.from == a)
        return { range: c };
      a = u.from;
      let h = t.toText((o ? s.line(i++).text : e) + t.lineBreak);
      return {
        changes: { from: u.from, insert: h },
        range: G.cursor(c.from + h.length)
      };
    });
  } else o ? r = t.changeByRange((a) => {
    let c = s.line(i++);
    return {
      changes: { from: a.from, to: a.to, insert: c.text },
      range: G.cursor(a.from + c.length)
    };
  }) : r = t.replaceSelection(s);
  n.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
vi.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
Fi.keydown = (n, e) => (n.inputState.setSelectionOrigin("select"), e.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
vi.touchstart = (n, e) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
vi.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
Fi.mousedown = (n, e) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let r of n.state.facet(SC))
    if (t = r(n, e), t)
      break;
  if (!t && e.button == 0 && (t = rz(n, e)), t) {
    let r = !n.hasFocus;
    n.inputState.startMouseSelection(new YB(n, e, t, r)), r && n.observer.ignore(() => {
      nC(n.contentDOM);
      let s = n.root.activeElement;
      s && !s.contains(n.contentDOM) && s.blur();
    });
    let i = n.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  } else
    n.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function U6(n, e, t, r) {
  if (r == 1)
    return G.cursor(e, t);
  if (r == 2)
    return IB(n.state, e, t);
  {
    let i = dn.find(n.docView, e), s = n.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, l = i ? i.posAtEnd : s.to;
    return l < n.state.doc.length && l == s.to && l++, G.range(o, l);
  }
}
let K6 = (n, e, t) => e >= t.top && e <= t.bottom && n >= t.left && n <= t.right;
function tz(n, e, t, r) {
  let i = dn.find(n.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && K6(t, r, o))
    return -1;
  let l = i.coordsAt(s, 1);
  return l && K6(t, r, l) ? 1 : o && o.bottom >= r ? -1 : 1;
}
function G6(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: tz(n, t, e.clientX, e.clientY) };
}
const nz = we.ie && we.ie_version <= 11;
let Y6 = null, J6 = 0, X6 = 0;
function qC(n) {
  if (!nz)
    return n.detail;
  let e = Y6, t = X6;
  return Y6 = n, X6 = Date.now(), J6 = !e || t > Date.now() - 400 && Math.abs(e.clientX - n.clientX) < 2 && Math.abs(e.clientY - n.clientY) < 2 ? (J6 + 1) % 3 : 1;
}
function rz(n, e) {
  let t = G6(n, e), r = qC(e), i = n.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), i = i.map(s.changes));
    },
    get(s, o, l) {
      let a = G6(n, s), c, u = U6(n, a.pos, a.bias, r);
      if (t.pos != a.pos && !o) {
        let h = U6(n, t.pos, t.bias, r), f = Math.min(h.from, u.from), d = Math.max(h.to, u.to);
        u = f < u.from ? G.range(f, d) : G.range(d, f);
      }
      return o ? i.replaceRange(i.main.extend(u.from, u.to)) : l && r == 1 && i.ranges.length > 1 && (c = iz(i, a.pos)) ? c : l ? i.addRange(u) : G.create([u]);
    }
  };
}
function iz(n, e) {
  for (let t = 0; t < n.ranges.length; t++) {
    let { from: r, to: i } = n.ranges[t];
    if (r <= e && i >= e)
      return G.create(n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)), n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0));
  }
  return null;
}
Fi.dragstart = (n, e) => {
  let { selection: { main: t } } = n.state;
  if (e.target.draggable) {
    let i = n.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= t.to || o <= t.from) && (t = G.range(s, o));
    }
  }
  let { inputState: r } = n;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", s1(n.state, p3, n.state.sliceDoc(t.from, t.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Fi.dragend = (n) => (n.inputState.draggedContent = null, !1);
function Z6(n, e, t, r) {
  if (t = s1(n.state, d3, t), !t)
    return;
  let i = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = n.inputState, o = r && s && XB(n, e) ? { from: s.from, to: s.to } : null, l = { from: i, insert: t }, a = n.state.changes(o ? [o, l] : l);
  n.focus(), n.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(i, -1), head: a.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
Fi.drop = (n, e) => {
  if (!e.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let r = Array(t.length), i = 0, s = () => {
      ++i == t.length && Z6(n, e, r.filter((o) => o != null).join(n.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (r[o] = l.result), s();
      }, l.readAsText(t[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return Z6(n, e, r, !0), !0;
  }
  return !1;
};
Fi.paste = (n, e) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let t = $C ? null : e.clipboardData;
  return t ? (VC(n, t.getData("text/plain") || t.getData("text/uri-list")), !0) : (ez(n), !1);
};
function sz(n, e) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let r = t.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), n.focus();
  }, 50);
}
function oz(n) {
  let e = [], t = [], r = !1;
  for (let i of n.selection.ranges)
    i.empty || (e.push(n.sliceDoc(i.from, i.to)), t.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of n.selection.ranges) {
      let o = n.doc.lineAt(s);
      o.number > i && (e.push(o.text), t.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })), i = o.number;
    }
    r = !0;
  }
  return { text: s1(n, p3, e.join(n.lineBreak)), ranges: t, linewise: r };
}
let ty = null;
Fi.copy = Fi.cut = (n, e) => {
  let { text: t, ranges: r, linewise: i } = oz(n.state);
  if (!t && !i)
    return !1;
  ty = i ? t : null, e.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = $C ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", t), !0) : (sz(n, t), !1);
};
const WC = /* @__PURE__ */ wo.define();
function jC(n, e) {
  let t = [];
  for (let r of n.facet(TC)) {
    let i = r(n, e);
    i && t.push(i);
  }
  return t.length ? n.update({ effects: t, annotations: WC.of(!0) }) : null;
}
function UC(n) {
  setTimeout(() => {
    let e = n.hasFocus;
    if (e != n.inputState.notifiedFocused) {
      let t = jC(n.state, e);
      t ? n.dispatch(t) : n.update([]);
    }
  }, 10);
}
vi.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), UC(n);
};
vi.blur = (n) => {
  n.observer.clearSelectionRange(), UC(n);
};
vi.compositionstart = vi.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
vi.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, we.chrome && we.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
vi.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
Fi.beforeinput = (n, e) => {
  var t, r;
  if (e.inputType == "insertReplacementText" && n.observer.editContext) {
    let s = (t = e.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain"), o = e.getTargetRanges();
    if (s && o.length) {
      let l = o[0], a = n.posAtDOM(l.startContainer, l.startOffset), c = n.posAtDOM(l.endContainer, l.endOffset);
      return y3(n, { from: a, to: c, insert: n.state.toText(s) }, null), !0;
    }
  }
  let i;
  if (we.chrome && we.android && (i = FC.find((s) => s.inputType == e.inputType)) && (n.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let s = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > s + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return we.ios && e.inputType == "deleteContentForward" && n.observer.flushSoon(), we.safari && e.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => vi.compositionend(n, e), 20), !1;
};
const Q6 = /* @__PURE__ */ new Set();
function lz(n) {
  Q6.has(n) || (Q6.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
const ew = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Lc = !1;
function tw() {
  Lc = !1;
}
class az {
  constructor(e) {
    this.lineWrapping = e, this.doc = ft.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, t) {
    let r = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((t - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return ew.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (t = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, r, i, s, o) {
    let l = ew.indexOf(e) > -1, a = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = t, this.charWidth = r, this.textHeight = i, this.lineLength = s, a) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return a;
  }
}
class cz {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class cs {
  /**
  @internal
  */
  constructor(e, t, r, i, s) {
    this.from = e, this.length = t, this.top = r, this.height = i, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? hr.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof hl ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new cs(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Vt = /* @__PURE__ */ (function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
})(Vt || (Vt = {}));
const X0 = 1e-3;
class fr {
  constructor(e, t, r = 2) {
    this.length = e, this.height = t, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > X0 && (Lc = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, r) {
    return fr.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, r, i) {
    let s = this, o = r.doc;
    for (let l = i.length - 1; l >= 0; l--) {
      let { fromA: a, toA: c, fromB: u, toB: h } = i[l], f = s.lineAt(a, Vt.ByPosNoHeight, r.setDoc(t), 0, 0), d = f.to >= c ? f : s.lineAt(c, Vt.ByPosNoHeight, r, 0, 0);
      for (h += d.to - c, c = d.to; l > 0 && f.from <= i[l - 1].toA; )
        a = i[l - 1].fromA, u = i[l - 1].fromB, l--, a < f.from && (f = s.lineAt(a, Vt.ByPosNoHeight, r, 0, 0));
      u += f.from - a, a = f.from;
      let p = b3.build(r.setDoc(o), e, u, h);
      s = rm(s, s.replace(a, c, p));
    }
    return s.updateHeight(r, 0);
  }
  static empty() {
    return new qr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, r = e.length, i = 0, s = 0;
    for (; ; )
      if (t == r)
        if (i > s * 2) {
          let l = e[t - 1];
          l.break ? e.splice(--t, 1, l.left, null, l.right) : e.splice(--t, 1, l.left, l.right), r += 1 + l.break, i -= l.size;
        } else if (s > i * 2) {
          let l = e[r];
          l.break ? e.splice(r, 1, l.left, null, l.right) : e.splice(r, 1, l.left, l.right), r += 2 + l.break, s -= l.size;
        } else
          break;
      else if (i < s) {
        let l = e[t++];
        l && (i += l.size);
      } else {
        let l = e[--r];
        l && (s += l.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, r++), new uz(fr.of(e.slice(0, t)), o, fr.of(e.slice(r)));
  }
}
function rm(n, e) {
  return n == e ? n : (n.constructor != e.constructor && (Lc = !0), e);
}
fr.prototype.size = 1;
class KC extends fr {
  constructor(e, t, r) {
    super(e, t), this.deco = r;
  }
  blockAt(e, t, r, i) {
    return new cs(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, t, r, i, s) {
    return this.blockAt(0, r, i, s);
  }
  forEachLine(e, t, r, i, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, r, i, s));
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class qr extends KC {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, r, i) {
    return new cs(i, this.length, r, this.height, this.breaks);
  }
  replace(e, t, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof qr || i instanceof Rn && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Rn ? i = new qr(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : fr.of(r);
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more ? this.setHeight(i.heights[i.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Rn extends fr {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let r = e.doc.lineAt(t).number, i = e.doc.lineAt(t + this.length).number, s = i - r + 1, o, l = 0;
    if (e.lineWrapping) {
      let a = Math.min(this.height, e.lineHeight * s);
      o = a / s, this.length > s + 1 && (l = (this.height - a) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: r, lastLine: i, perLine: o, perChar: l };
  }
  blockAt(e, t, r, i) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: a } = this.heightMetrics(t, i);
    if (t.lineWrapping) {
      let c = i + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), u = t.doc.lineAt(c), h = l + u.length * a, f = Math.max(r, e - h / 2);
      return new cs(u.from, u.length, f, h, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - r) / l))), { from: u, length: h } = t.doc.line(s + c);
      return new cs(u, h, r + l * c, l, 0);
    }
  }
  lineAt(e, t, r, i, s) {
    if (t == Vt.ByHeight)
      return this.blockAt(e, r, i, s);
    if (t == Vt.ByPosNoHeight) {
      let { from: d, to: p } = r.doc.lineAt(e);
      return new cs(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: a } = this.heightMetrics(r, s), c = r.doc.lineAt(e), u = l + c.length * a, h = c.number - o, f = i + l * h + a * (c.from - s - h);
    return new cs(c.from, c.length, Math.max(i, Math.min(f, i + this.height - u)), u, 0);
  }
  forEachLine(e, t, r, i, s, o) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: l, perLine: a, perChar: c } = this.heightMetrics(r, s);
    for (let u = e, h = i; u <= t; ) {
      let f = r.doc.lineAt(u);
      if (u == e) {
        let p = f.number - l;
        h += a * p + c * (e - s - p);
      }
      let d = a + c * f.length;
      o(new cs(f.from, f.length, h, d, 0)), h += d, u = f.to + 1;
    }
  }
  replace(e, t, r) {
    let i = this.length - t;
    if (i > 0) {
      let s = r[r.length - 1];
      s instanceof Rn ? r[r.length - 1] = new Rn(s.length + i) : r.push(null, new Rn(i - 1));
    }
    if (e > 0) {
      let s = r[0];
      s instanceof Rn ? r[0] = new Rn(e + s.length) : r.unshift(new Rn(e - 1), null);
    }
    return fr.of(r);
  }
  decomposeLeft(e, t) {
    t.push(new Rn(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new Rn(this.length - e - 1));
  }
  updateHeight(e, t = 0, r = !1, i) {
    let s = t + this.length;
    if (i && i.from <= t + this.length && i.more) {
      let o = [], l = Math.max(t, i.from), a = -1;
      for (i.from > t && o.push(new Rn(i.from - t - 1).updateHeight(e, t)); l <= s && i.more; ) {
        let u = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let h = i.heights[i.index++];
        a == -1 ? a = h : Math.abs(h - a) >= X0 && (a = -2);
        let f = new qr(u, h);
        f.outdated = !1, o.push(f), l += u + 1;
      }
      l <= s && o.push(null, new Rn(s - l).updateHeight(e, l));
      let c = fr.of(o);
      return (a < 0 || Math.abs(c.height - this.height) >= X0 || Math.abs(a - this.heightMetrics(e, t).perLine) >= X0) && (Lc = !0), rm(this, c);
    } else (r || this.outdated) && (this.setHeight(e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class uz extends fr {
  constructor(e, t, r) {
    super(e.length + t + r.length, e.height + r.height, t | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, r, i) {
    let s = r + this.left.height;
    return e < s ? this.left.blockAt(e, t, r, i) : this.right.blockAt(e, t, s, i + this.left.length + this.break);
  }
  lineAt(e, t, r, i, s) {
    let o = i + this.left.height, l = s + this.left.length + this.break, a = t == Vt.ByHeight ? e < o : e < l, c = a ? this.left.lineAt(e, t, r, i, s) : this.right.lineAt(e, t, r, o, l);
    if (this.break || (a ? c.to < l : c.from > l))
      return c;
    let u = t == Vt.ByPosNoHeight ? Vt.ByPosNoHeight : Vt.ByPos;
    return a ? c.join(this.right.lineAt(l, u, r, o, l)) : this.left.lineAt(l, u, r, i, s).join(c);
  }
  forEachLine(e, t, r, i, s, o) {
    let l = i + this.left.height, a = s + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, t, r, i, s, o), t >= a && this.right.forEachLine(e, t, r, l, a, o);
    else {
      let c = this.lineAt(a, Vt.ByPos, r, i, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, s, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, r, l, a, o);
    }
  }
  replace(e, t, r) {
    let i = this.left.length + this.break;
    if (t < i)
      return this.balanced(this.left.replace(e, t, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, t - i, r));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of r)
      s.push(l);
    if (e > 0 && nw(s, o - 1), t < this.length) {
      let l = s.length;
      this.decomposeRight(t, s), nw(s, l);
    }
    return fr.of(s);
  }
  decomposeLeft(e, t) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (r++, e >= r && t.push(null)), e > r && this.right.decomposeLeft(e - r, t);
  }
  decomposeRight(e, t) {
    let r = this.left.length, i = r + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, t);
    e < r && this.left.decomposeRight(e, t), this.break && e < i && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? fr.of(this.break ? [e, null, t] : [e, t]) : (this.left = rm(this.left, e), this.right = rm(this.right, t), this.setHeight(e.height + t.height), this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, r = !1, i) {
    let { left: s, right: o } = this, l = t + s.length + this.break, a = null;
    return i && i.from <= t + s.length && i.more ? a = s = s.updateHeight(e, t, r, i) : s.updateHeight(e, t, r), i && i.from <= l + o.length && i.more ? a = o = o.updateHeight(e, l, r, i) : o.updateHeight(e, l, r), a ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function nw(n, e) {
  let t, r;
  n[e] == null && (t = n[e - 1]) instanceof Rn && (r = n[e + 1]) instanceof Rn && n.splice(e - 1, 3, new Rn(t.length + 1 + r.length));
}
const hz = 5;
class b3 {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let r = Math.min(t, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof qr ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new qr(r - this.pos, -1)), this.writtenTo = r, t > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, r) {
    if (e < t || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, s = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = t - e;
      r.block ? this.addBlock(new KC(o, i, r)) : (o || s || i >= hz) && this.addLineDeco(i, s, o);
    } else t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new qr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let r = new Rn(t - e);
    return this.oracle.doc.lineAt(e).to == t && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof qr)
      return e;
    let t = new qr(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += t, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof qr) && !this.isCovered ? this.nodes.push(new qr(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes)
      i instanceof qr && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, r, i) {
    let s = new b3(r, e);
    return ut.spans(t, r, i, s, 0), s.finish(r);
  }
}
function fz(n, e, t) {
  let r = new dz();
  return ut.compare(n, e, t, r, 0), r.changes;
}
class dz {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, r, i) {
    (e < t || r && r.heightRelevant || i && i.heightRelevant) && Y0(e, t, this.changes, 5);
  }
}
function pz(n, e) {
  let t = n.getBoundingClientRect(), r = n.ownerDocument, i = r.defaultView || window, s = Math.max(0, t.left), o = Math.min(i.innerWidth, t.right), l = Math.max(0, t.top), a = Math.min(i.innerHeight, t.bottom);
  for (let c = n.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let u = c, h = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
        let f = u.getBoundingClientRect();
        s = Math.max(s, f.left), o = Math.min(o, f.right), l = Math.max(l, f.top), a = Math.min(c == n.parentNode ? i.innerHeight : a, f.bottom);
      }
      c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: l - (t.top + e),
    bottom: Math.max(l, a) - (t.top + e)
  };
}
function mz(n) {
  let e = n.getBoundingClientRect(), t = n.ownerDocument.defaultView || window;
  return e.left < t.innerWidth && e.right > 0 && e.top < t.innerHeight && e.bottom > 0;
}
function gz(n, e) {
  let t = n.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class Pg {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.size = r, this.displaySize = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r], s = t[r];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return He.replace({
      widget: new yz(this.displaySize * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class yz extends xo {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class rw {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = iw, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = qt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(m3).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new az(t), this.stateDeco = e.facet(Tf).filter((r) => typeof r != "function"), this.heightMap = fr.empty().applyChanges(this.stateDeco, ft.empty, this.heightOracle.setDoc(e.doc), [new di(0, 0, 0, e.doc.length)]);
    for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = He.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? t.head : t.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new e0(s, o));
      }
    }
    return this.viewports = e.sort((r, i) => r.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? iw : new v3(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(th(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(Tf).filter((u) => typeof u != "function");
    let i = e.changedRanges, s = di.extendWithRanges(i, fz(r, this.stateDeco, e ? e.changes : wn.empty(this.state.doc.length))), o = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    tw(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), (this.heightMap.height != o || Lc) && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = o);
    let a = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < a.from || t.range.head > a.to) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, t));
    let c = a.from != this.viewport.from || a.to != this.viewport.to;
    this.viewport = a, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(OC) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, r = window.getComputedStyle(t), i = this.heightOracle, s = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? qt.RTL : qt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), l = t.getBoundingClientRect(), a = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (l.width && l.height) {
      let { scaleX: C, scaleY: M } = tC(t, l);
      (C > 5e-3 && Math.abs(this.scaleX - C) > 5e-3 || M > 5e-3 && Math.abs(this.scaleY - M) > 5e-3) && (this.scaleX = C, this.scaleY = M, c |= 16, o = a = !0);
    }
    let h = (parseInt(r.paddingTop) || 0) * this.scaleY, f = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != f) && (this.paddingTop = h, this.paddingBottom = f, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (a = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
    let d = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != d && (this.scrollAnchorHeight = -1, this.scrollTop = d), this.scrolledToBottom = iC(e.scrollDOM);
    let p = (this.printing ? gz : pz)(t, this.paddingTop), m = p.top - this.pixelViewport.top, g = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let b = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (b != this.inView && (this.inView = b, b && (a = !0)), !this.inView && !this.scrollTarget && !mz(e.dom))
      return 0;
    let w = l.width;
    if ((this.contentDOMWidth != w || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), a) {
      let C = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(C) && (o = !0), o || i.lineWrapping && Math.abs(w - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: M, charWidth: T, textHeight: N } = e.docView.measureTextSize();
        o = M > 0 && i.refresh(s, M, T, N, Math.max(5, w / T), C), o && (e.docView.minWidth = 0, c |= 16);
      }
      m > 0 && g > 0 ? u = Math.max(m, g) : m < 0 && g < 0 && (u = Math.min(m, g)), tw();
      for (let M of this.viewports) {
        let T = M.from == this.viewport.from ? C : e.docView.measureVisibleLineHeights(M);
        this.heightMap = (o ? fr.empty().applyChanges(this.stateDeco, ft.empty, this.heightOracle, [new di(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new cz(M.from, T));
      }
      Lc && (c |= 2);
    }
    let k = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return k && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || k) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: l } = this, a = new e0(i.lineAt(o - r * 1e3, Vt.ByHeight, s, 0, 0).from, i.lineAt(l + (1 - r) * 1e3, Vt.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < a.from || c > a.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, Vt.ByPos, s, 0, 0), f;
        t.y == "center" ? f = (h.top + h.bottom) / 2 - u / 2 : t.y == "start" || t.y == "nearest" && c < a.from ? f = h.top : f = h.bottom - u, a = new e0(i.lineAt(f - 1e3 / 2, Vt.ByHeight, s, 0, 0).from, i.lineAt(f + u + 1e3 / 2, Vt.ByHeight, s, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, t) {
    let r = t.mapPos(e.from, -1), i = t.mapPos(e.to, 1);
    return new e0(this.heightMap.lineAt(r, Vt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Vt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, Vt.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, Vt.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || i <= o - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || s >= l + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && i > o - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let r = [];
    for (let i of e)
      t.touchesRange(i.from, i.to) || r.push(new Pg(t.mapPos(i.from), t.mapPos(i.to), i.size, i.displaySize));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != qt.LTR && !r)
      return [];
    let l = [], a = (u, h, f, d) => {
      if (h - u < s)
        return;
      let p = this.state.selection.main, m = [p.from];
      p.empty || m.push(p.to);
      for (let b of m)
        if (b > u && b < h) {
          a(u, b - 10, f, d), a(b + 10, h, f, d);
          return;
        }
      let g = vz(e, (b) => b.from >= f.from && b.to <= f.to && Math.abs(b.from - u) < s && Math.abs(b.to - h) < s && !m.some((w) => b.from < w && b.to > w));
      if (!g) {
        if (h < f.to && t && r && t.visibleRanges.some((k) => k.from <= h && k.to >= h)) {
          let k = t.moveToLineBoundary(G.cursor(h), !1, !0).head;
          k > u && (h = k);
        }
        let b = this.gapSize(f, u, h, d), w = r || b < 2e6 ? b : 2e6;
        g = new Pg(u, h, b, w);
      }
      l.push(g);
    }, c = (u) => {
      if (u.length < o || u.type != hr.Text)
        return;
      let h = bz(u.from, u.to, this.stateDeco);
      if (h.total < o)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, d, p;
      if (r) {
        let m = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, b;
        if (f != null) {
          let w = n0(h, f), k = ((this.visibleBottom - this.visibleTop) / 2 + m) / u.height;
          g = w - k, b = w + k;
        } else
          g = (this.visibleTop - u.top - m) / u.height, b = (this.visibleBottom - u.top + m) / u.height;
        d = t0(h, g), p = t0(h, b);
      } else {
        let m = h.total * this.heightOracle.charWidth, g = i * this.heightOracle.charWidth, b = 0;
        if (m > 2e6)
          for (let T of e)
            T.from >= u.from && T.from < u.to && T.size != T.displaySize && T.from * this.heightOracle.charWidth + b < this.pixelViewport.left && (b = T.size - T.displaySize);
        let w = this.pixelViewport.left + b, k = this.pixelViewport.right + b, C, M;
        if (f != null) {
          let T = n0(h, f), N = ((k - w) / 2 + g) / m;
          C = T - N, M = T + N;
        } else
          C = (w - g) / m, M = (k + g) / m;
        d = t0(h, C), p = t0(h, M);
      }
      d > u.from && a(u.from, d, u, h), p < u.to && a(p, u.to, u, h);
    };
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(c) : c(u);
    return l;
  }
  gapSize(e, t, r, i) {
    let s = n0(i, r) - n0(i, t);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Pg.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = He.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let r = [];
    ut.spans(t, this.viewport.from, this.viewport.to, {
      span(s, o) {
        r.push({ from: s, to: o });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (r.length != this.visibleRanges.length)
      i = 12;
    else
      for (let s = 0; s < r.length && !(i & 8); s++) {
        let o = this.visibleRanges[s], l = r[s];
        (o.from != l.from || o.to != l.to) && (i |= 4, e && e.mapPos(o.from, -1) == l.from && e.mapPos(o.to, 1) == l.to || (i |= 8));
      }
    return this.visibleRanges = r, i;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || th(this.heightMap.lineAt(e, Vt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t) => t.top <= e && t.bottom >= e) || th(this.heightMap.lineAt(this.scaler.fromDOM(e), Vt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return th(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class e0 {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function bz(n, e, t) {
  let r = [], i = n, s = 0;
  return ut.spans(t, n, e, {
    span() {
    },
    point(o, l) {
      o > i && (r.push({ from: i, to: o }), s += o - i), i = l;
    }
  }, 20), i < e && (r.push({ from: i, to: e }), s += e - i), { total: s, ranges: r };
}
function t0({ total: n, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(n * t);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i], l = o - s;
    if (r <= l)
      return s + r;
    r -= l;
  }
}
function n0(n, e) {
  let t = 0;
  for (let { from: r, to: i } of n.ranges) {
    if (e <= i) {
      t += e - r;
      break;
    }
    t += i - r;
  }
  return t / n.total;
}
function vz(n, e) {
  for (let t of n)
    if (e(t))
      return t;
}
const iw = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
class v3 {
  constructor(e, t, r) {
    let i = 0, s = 0, o = 0;
    this.viewports = r.map(({ from: l, to: a }) => {
      let c = t.lineAt(l, Vt.ByPos, e, 0, 0).top, u = t.lineAt(a, Vt.ByPos, e, 0, 0).bottom;
      return i += u - c, { from: l, to: a, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (t.height - i);
    for (let l of this.viewports)
      l.domTop = o + (l.top - s) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return i + (e - r) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      r = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return r + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      r = s.bottom, i = s.domBottom;
    }
  }
  eq(e) {
    return e instanceof v3 ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((t, r) => t.from == e.viewports[r].from && t.to == e.viewports[r].to) : !1;
  }
}
function th(n, e) {
  if (e.scale == 1)
    return n;
  let t = e.toDOM(n.top), r = e.toDOM(n.bottom);
  return new cs(n.from, n.length, t, r - t, Array.isArray(n._content) ? n._content.map((i) => th(i, e)) : n._content);
}
const r0 = /* @__PURE__ */ xe.define({ combine: (n) => n.join(" ") }), ny = /* @__PURE__ */ xe.define({ combine: (n) => n.indexOf(!0) > -1 }), ry = /* @__PURE__ */ ul.newName(), GC = /* @__PURE__ */ ul.newName(), YC = /* @__PURE__ */ ul.newName(), JC = { "&light": "." + GC, "&dark": "." + YC };
function iy(n, e, t) {
  return new ul(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return n;
        if (!t || !t[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return t[i];
      }) : n + " " + r;
    }
  });
}
const wz = /* @__PURE__ */ iy("." + ry, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, JC), xz = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, _g = we.ie && we.ie_version <= 11;
let kz = class {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new rB(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let r of t)
        this.queue.push(r);
      (we.ie && we.ie_version <= 11 || we.ios && e.composing) && t.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && we.android && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(we.chrome && we.chrome_version < 126) && (this.editContext = new Cz(e), e.state.facet(Js) && (e.contentDOM.editContext = this.editContext.editContext)), _g && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, r) => t != e[r]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(Js) ? r.root.activeElement != this.dom : !G0(this.dom, i))
      return;
    let s = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (we.ie && we.ie_version <= 11 || we.android && we.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Fh(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = Cf(e.root);
    if (!t)
      return !1;
    let r = we.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && Sz(this.view, t) || t;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let i = G0(this.dom, r);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && sB(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = t)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, xz), _g && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), _g && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && bc(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, r = -1, i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (i = !0), t == -1 ? { from: t, to: r } = o : (t = Math.min(o.from, t), r = Math.max(o.to, r)));
    }
    return { from: t, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: t, typeOver: r } = this.processRecords(), i = this.selectionChanged && G0(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new HB(this.view, e, t, r);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = zC(this.view, t);
    return this.view.state == r && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let r = sw(t, e.previousSibling || e.target.previousSibling, -1), i = sw(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? t.posAfter(r) : t.posAtStart,
        to: i ? t.posBefore(i) : t.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Js) != e.state.facet(Js) && (e.view.contentDOM.editContext = e.state.facet(Js) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, t, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
};
function sw(n, e, t) {
  for (; e; ) {
    let r = It.get(e);
    if (r && r.parent == n)
      return r;
    let i = e.parentNode;
    e = i != n.dom ? i : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function ow(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.docView.domAtPos(n.state.selection.main.anchor);
  return Fh(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s };
}
function Sz(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return ow(n, i);
  }
  let t = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.contentDOM.addEventListener("beforeinput", r, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", r, !0), t ? ow(n, t) : null;
}
class Cz {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let t = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (r) => {
      let i = e.state.selection.main, { anchor: s, head: o } = i, l = this.toEditorPos(r.updateRangeStart), a = this.toEditorPos(r.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: r.updateRangeStart, editorBase: l, drifted: !1 });
      let c = { from: l, to: a, insert: ft.of(r.text.split(`
`)) };
      if (c.from == this.from && s < this.from ? c.from = s : c.to == this.to && s > this.to && (c.to = s), c.from == c.to && !c.insert.length) {
        let u = G.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
        u.main.eq(i) || e.dispatch({ selection: u, userEvent: "select" });
        return;
      }
      if ((we.mac || we.android) && c.from == o - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (c = { from: l, to: a, insert: ft.of([r.text.replace(".", " ")]) }), this.pendingContextChange = c, !e.state.readOnly) {
        let u = this.to - this.from + (c.to - c.from + c.insert.length);
        y3(e, c, G.single(this.toEditorPos(r.selectionStart, u), this.toEditorPos(r.selectionEnd, u)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
    }, this.handlers.characterboundsupdate = (r) => {
      let i = [], s = null;
      for (let o = this.toEditorPos(r.rangeStart), l = this.toEditorPos(r.rangeEnd); o < l; o++) {
        let a = e.coordsForChar(o);
        s = a && new DOMRect(a.left, a.top, a.right - a.left, a.bottom - a.top) || s || new DOMRect(), i.push(s);
      }
      t.updateCharacterBounds(r.rangeStart, i);
    }, this.handlers.textformatupdate = (r) => {
      let i = [];
      for (let s of r.getTextFormats()) {
        let o = s.underlineStyle, l = s.underlineThickness;
        if (o != "None" && l != "None") {
          let a = this.toEditorPos(s.rangeStart), c = this.toEditorPos(s.rangeEnd);
          if (a < c) {
            let u = `text-decoration: underline ${o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${l == "Thin" ? 1 : 2}px`;
            i.push(He.mark({ attributes: { style: u } }).range(a, c));
          }
        }
      }
      e.dispatch({ effects: IC.of(He.set(i)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: r } = this.composing;
        this.composing = null, r && this.reset(e.state);
      }
    };
    for (let r in this.handlers)
      t.addEventListener(r, this.handlers[r]);
    this.measureReq = { read: (r) => {
      this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
      let i = Cf(r.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let t = 0, r = !1, i = this.pendingContextChange;
    return e.changes.iterChanges((s, o, l, a, c) => {
      if (r)
        return;
      let u = c.length - (o - s);
      if (i && o >= i.to)
        if (i.from == s && i.to == o && i.insert.eq(c)) {
          i = this.pendingContextChange = null, t += u, this.to += u;
          return;
        } else
          i = null, this.revertPending(e.state);
      if (s += t, o += t, o <= this.from)
        this.from += u, this.to += u;
      else if (s < this.to) {
        if (s < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
          r = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(s), this.toContextPos(o), c.toString()), this.to += u;
      }
      t += u;
    }), i && !r && this.revertPending(e.state), !r;
  }
  update(e) {
    let t = this.pendingContextChange, r = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || t) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: t } = e.selection.main;
    this.from = Math.max(
      0,
      t - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      t + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let t = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.from + t.insert.length), e.doc.sliceString(t.from, t.to));
  }
  setSelection(e) {
    let { main: t } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))), i = this.toContextPos(t.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
  }
  rangeIsValid(e) {
    let { head: t } = e.selection.main;
    return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, t = this.to - this.from) {
    e = Math.min(e, t);
    let r = this.composing;
    return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let t = this.composing;
    return t && t.drifted ? t.contextBase + (e - t.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
let Ce = class sy {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var t;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((s) => r(s, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || iB(e.parent) || document, this.viewState = new rw(e.state || jt.create(e)), e.scrollTo && e.scrollTo.is(Xd) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(pc).map((i) => new Dg(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new kz(this), this.inputState = new jB(this), this.inputState.ensureHandlers(this.plugins), this.docView = new z6(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((t = document.fonts) === null || t === void 0) && t.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof ur ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, r = !1, i, s = this.state;
    for (let f of e) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, l = 0, a = null;
    e.some((f) => f.annotation(WC)) ? (this.inputState.notifiedFocused = o, l = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, a = jC(s, o), a || (l = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(jt.phrases) != this.state.facet(jt.phrases))
      return this.setState(s);
    i = nm.create(this, s, e), i.flags |= l;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (h && (h = h.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          h = new vc(d.empty ? d : G.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(Xd) && (h = d.value.clip(this.state));
      }
      this.viewState.update(i, h), this.bidiCache = im.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), t = this.docView.update(i), this.state.facet(Qu) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(r0) != i.state.facet(r0) && (this.viewState.mustMeasureContent = !0), (t || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), t && this.docViewUpdate(), !i.empty)
      for (let f of this.state.facet(Z4))
        try {
          f(i);
        } catch (d) {
          Mr(this.state, d, "update listener");
        }
    (a || u) && Promise.resolve().then(() => {
      a && this.state == a.startState && this.dispatch(a), u && !zC(this, u) && c.force && bc(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new rw(e), this.plugins = e.facet(pc).map((r) => new Dg(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new z6(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(pc), r = e.state.facet(pc);
    if (t != r) {
      let i = [];
      for (let s of r) {
        let o = t.indexOf(s);
        if (o < 0)
          i.push(new Dg(s));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, i.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    t != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let t = e.value;
      if (t && t.docViewUpdate)
        try {
          t.docViewUpdate(this);
        } catch (r) {
          Mr(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (iC(r))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(i);
            s = d.from, o = d.top;
          }
        this.updateState = 1;
        let a = this.viewState.measure(this);
        if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        a & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return Mr(this.state, p), lw;
          }
        }), h = nm.create(this, this.state, []), f = !1;
        h.flags |= a, t ? t.flags |= a : t = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), f = this.docView.update(h), f && this.docViewUpdate());
        for (let d = 0; d < c.length; d++)
          if (u[d] != lw)
            try {
              let p = c[d];
              p.write && p.write(u[d], this);
            } catch (p) {
              Mr(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                i = i + p, r.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let l of this.state.facet(Z4))
        l(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return ry + " " + (this.state.facet(ny) ? YC : GC) + " " + this.state.facet(r0);
  }
  updateAttrs() {
    let e = aw(this, DC, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Js) ? "true" : "false",
      class: "cm-content",
      style: `${we.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), aw(this, m3, t);
    let r = this.observer.ignore(() => {
      let i = K4(this.contentDOM, this.contentAttrs, t), s = K4(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, r;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(sy.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Qu);
    let e = this.state.facet(sy.cspNonce);
    ul.mount(this.root, this.styleModules.concat(wz).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.plugin != e) && this.pluginMap.set(e, t = this.plugins.find((r) => r.plugin == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, r) {
    return Rg(this, e, q6(this, e, t, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return Rg(this, e, q6(this, e, t, (r) => LB(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = r[t ? r.length - 1 : 0];
    return G.cursor(s.side(t, i) + e.from, s.forward(!t, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, r = !0) {
    return _B(this, e, t, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, r) {
    return Rg(this, e, BB(this, e, t, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), LC(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, t);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[Xo.find(s, e - i.from, -1, t)];
    return n1(r, o.dir == qt.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(AC) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > Mz)
      return vC(e.length);
    let t = this.textDirectionAt(e.from), r;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t && (s.fresh || bC(s.isolates, r = B6(this, e))))
        return s.order;
    r || (r = B6(this, e));
    let i = vB(e.text, t, r);
    return this.bidiCache.push(new im(e.from, e.to, t, r, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || we.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      nC(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return Xd.of(new vc(typeof e == "number" ? G.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return Xd.of(new vc(G.cursor(r.from), "start", "start", r.top - e, t, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return gn.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return gn.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let r = ul.newName(), i = [r0.of(r), Qu.of(iy(`.${r}`, e))];
    return t && t.dark && i.push(ny.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return kl.lowest(Qu.of(iy("." + ry, e, JC)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let r = e.querySelector(".cm-content"), i = r && It.get(r) || It.get(e);
    return ((t = i?.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
};
Ce.styleModule = Qu;
Ce.inputHandler = MC;
Ce.clipboardInputFilter = d3;
Ce.clipboardOutputFilter = p3;
Ce.scrollHandler = EC;
Ce.focusChangeEffect = TC;
Ce.perLineTextDirection = AC;
Ce.exceptionSink = CC;
Ce.updateListener = Z4;
Ce.editable = Js;
Ce.mouseSelectionStyle = SC;
Ce.dragMovesSelection = kC;
Ce.clickAddsSelectionRange = xC;
Ce.decorations = Tf;
Ce.outerDecorations = NC;
Ce.atomicRanges = i1;
Ce.bidiIsolatedRanges = RC;
Ce.scrollMargins = PC;
Ce.darkTheme = ny;
Ce.cspNonce = /* @__PURE__ */ xe.define({ combine: (n) => n.length ? n[0] : "" });
Ce.contentAttributes = m3;
Ce.editorAttributes = DC;
Ce.lineWrapping = /* @__PURE__ */ Ce.contentAttributes.of({ class: "cm-lineWrapping" });
Ce.announce = /* @__PURE__ */ Xe.define();
const Mz = 4096, lw = {};
class im {
  constructor(e, t, r, i, s, o) {
    this.from = e, this.to = t, this.dir = r, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh))
      return e;
    let r = [], i = e.length ? e[e.length - 1].dir : qt.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i && !t.touchesRange(o.from, o.to) && r.push(new im(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function aw(n, e, t) {
  for (let r = n.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let s = r[i], o = typeof s == "function" ? s(n) : s;
    o && U4(o, t);
  }
  return t;
}
const Tz = we.mac ? "mac" : we.windows ? "win" : we.linux ? "linux" : "key";
function Az(n, e) {
  const t = n.split(/-(?!$)/);
  let r = t[t.length - 1];
  r == "Space" && (r = " ");
  let i, s, o, l;
  for (let a = 0; a < t.length - 1; ++a) {
    const c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      l = !0;
    else if (/^a(lt)?$/i.test(c))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? l = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (r = "Alt-" + r), s && (r = "Ctrl-" + r), l && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function i0(n, e, t) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t !== !1 && e.shiftKey && (n = "Shift-" + n), n;
}
const Oz = /* @__PURE__ */ kl.default(/* @__PURE__ */ Ce.domEventHandlers({
  keydown(n, e) {
    return ZC(XC(e.state), n, e, "editor");
  }
})), nu = /* @__PURE__ */ xe.define({ enables: Oz }), cw = /* @__PURE__ */ new WeakMap();
function XC(n) {
  let e = n.facet(nu), t = cw.get(e);
  return t || cw.set(e, t = Dz(e.reduce((r, i) => r.concat(i), []))), t;
}
function Ez(n, e, t) {
  return ZC(XC(n.state), e, n, t);
}
let jo = null;
const Iz = 4e3;
function Dz(n, e = Tz) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (o, l) => {
    let a = r[o];
    if (a == null)
      r[o] = l;
    else if (a != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, l, a, c, u) => {
    var h, f;
    let d = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), p = l.split(/ (?!$)/).map((b) => Az(b, e));
    for (let b = 1; b < p.length; b++) {
      let w = p.slice(0, b).join(" ");
      i(w, !0), d[w] || (d[w] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(k) => {
          let C = jo = { view: k, prefix: w, scope: o };
          return setTimeout(() => {
            jo == C && (jo = null);
          }, Iz), !0;
        }]
      });
    }
    let m = p.join(" ");
    i(m, !1);
    let g = d[m] || (d[m] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (h = d._any) === null || h === void 0 ? void 0 : h.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    a && g.run.push(a), c && (g.preventDefault = !0), u && (g.stopPropagation = !0);
  };
  for (let o of n) {
    let l = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of l) {
        let u = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: h } = o;
        for (let f in u)
          u[f].run.push((d) => h(d, oy));
      }
    let a = o[e] || o.key;
    if (a)
      for (let c of l)
        s(c, a, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + a, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
let oy = null;
function ZC(n, e, t, r) {
  oy = e;
  let i = QS(e), s = kr(i, 0), o = as(s) == i.length && i != " ", l = "", a = !1, c = !1, u = !1;
  jo && jo.view == t && jo.scope == r && (l = jo.prefix + " ", HC.indexOf(e.keyCode) < 0 && (c = !0, jo = null));
  let h = /* @__PURE__ */ new Set(), f = (g) => {
    if (g) {
      for (let b of g.run)
        if (!h.has(b) && (h.add(b), b(t)))
          return g.stopPropagation && (u = !0), !0;
      g.preventDefault && (g.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, d = n[r], p, m;
  return d && (f(d[l + i0(i, e, !o)]) ? a = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(we.windows && e.ctrlKey && e.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(we.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (p = ao[e.keyCode]) && p != i ? (f(d[l + i0(p, e, !0)]) || e.shiftKey && (m = Sf[e.keyCode]) != i && m != p && f(d[l + i0(m, e, !1)])) && (a = !0) : o && e.shiftKey && f(d[l + i0(i, e, !0)]) && (a = !0), !a && f(d._any) && (a = !0)), c && (a = !0), a && u && e.stopPropagation(), oy = null, a;
}
class ad {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, r, i, s) {
    this.className = e, this.left = t, this.top = r, this.width = i, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let s = QC(e);
      return [new ad(t, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return Nz(e, t, r);
  }
}
function QC(n) {
  let e = n.scrollDOM.getBoundingClientRect();
  return { left: (n.textDirection == qt.LTR ? e.left : e.right - n.scrollDOM.clientWidth * n.scaleX) - n.scrollDOM.scrollLeft * n.scaleX, top: e.top - n.scrollDOM.scrollTop * n.scaleY };
}
function uw(n, e, t, r) {
  let i = n.coordsAtPos(e, t * 2);
  if (!i)
    return r;
  let s = n.dom.getBoundingClientRect(), o = (i.top + i.bottom) / 2, l = n.posAtCoords({ x: s.left + 1, y: o }), a = n.posAtCoords({ x: s.right - 1, y: o });
  return l == null || a == null ? r : { from: Math.max(r.from, Math.min(l, a)), to: Math.min(r.to, Math.max(l, a)) };
}
function Nz(n, e, t) {
  if (t.to <= n.viewport.from || t.from >= n.viewport.to)
    return [];
  let r = Math.max(t.from, n.viewport.from), i = Math.min(t.to, n.viewport.to), s = n.textDirection == qt.LTR, o = n.contentDOM, l = o.getBoundingClientRect(), a = QC(n), c = o.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = l.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), f = l.right - (u ? parseInt(u.paddingRight) : 0), d = ey(n, r, 1), p = ey(n, i, -1), m = d.type == hr.Text ? d : null, g = p.type == hr.Text ? p : null;
  if (m && (n.lineWrapping || d.widgetLineBreaks) && (m = uw(n, r, 1, m)), g && (n.lineWrapping || p.widgetLineBreaks) && (g = uw(n, i, -1, g)), m && g && m.from == g.from && m.to == g.to)
    return w(k(t.from, t.to, m));
  {
    let M = m ? k(t.from, null, m) : C(d, !1), T = g ? k(null, t.to, g) : C(p, !0), N = [];
    return (m || d).to < (g || p).from - (m && g ? 1 : 0) || d.widgetLineBreaks > 1 && M.bottom + n.defaultLineHeight / 2 < T.top ? N.push(b(h, M.bottom, f, T.top)) : M.bottom < T.top && n.elementAtHeight((M.bottom + T.top) / 2).type == hr.Text && (M.bottom = T.top = (M.bottom + T.top) / 2), w(M).concat(N).concat(w(T));
  }
  function b(M, T, N, B) {
    return new ad(e, M - a.left, T - a.top, N - M, B - T);
  }
  function w({ top: M, bottom: T, horizontal: N }) {
    let B = [];
    for (let $ = 0; $ < N.length; $ += 2)
      B.push(b(N[$], M, N[$ + 1], T));
    return B;
  }
  function k(M, T, N) {
    let B = 1e9, $ = -1e9, R = [];
    function V(ie, he, Se, ge, ye) {
      let ze = n.coordsAtPos(ie, ie == N.to ? -2 : 2), I = n.coordsAtPos(Se, Se == N.from ? 2 : -2);
      !ze || !I || (B = Math.min(ze.top, I.top, B), $ = Math.max(ze.bottom, I.bottom, $), ye == qt.LTR ? R.push(s && he ? h : ze.left, s && ge ? f : I.right) : R.push(!s && ge ? h : I.left, !s && he ? f : ze.right));
    }
    let z = M ?? N.from, ue = T ?? N.to;
    for (let ie of n.visibleRanges)
      if (ie.to > z && ie.from < ue)
        for (let he = Math.max(ie.from, z), Se = Math.min(ie.to, ue); ; ) {
          let ge = n.state.doc.lineAt(he);
          for (let ye of n.bidiSpans(ge)) {
            let ze = ye.from + ge.from, I = ye.to + ge.from;
            if (ze >= Se)
              break;
            I > he && V(Math.max(ze, he), M == null && ze <= z, Math.min(I, Se), T == null && I >= ue, ye.dir);
          }
          if (he = ge.to + 1, he >= Se)
            break;
        }
    return R.length == 0 && V(z, M == null, ue, T == null, n.textDirection), { top: B, bottom: $, horizontal: R };
  }
  function C(M, T) {
    let N = l.top + (T ? M.top : M.bottom);
    return { top: N, bottom: N, horizontal: [] };
  }
}
function Rz(n, e) {
  return n.constructor == e.constructor && n.eq(e);
}
class Pz {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Z0) != e.state.facet(Z0) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, r = e.facet(Z0);
    for (; t < r.length && r[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, r) => !Rz(t, this.drawn[r]))) {
      let t = this.dom.firstChild, r = 0;
      for (let i of e)
        i.update && t && i.constructor && this.drawn[r].constructor && i.update(t, this.drawn[r]) ? (t = t.nextSibling, r++) : this.dom.insertBefore(i.draw(), t);
      for (; t; ) {
        let i = t.nextSibling;
        t.remove(), t = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Z0 = /* @__PURE__ */ xe.define();
function eM(n) {
  return [
    gn.define((e) => new Pz(e, n)),
    Z0.of(n)
  ];
}
const Af = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function tM(n = {}) {
  return [
    Af.of(n),
    _z,
    Lz,
    Bz,
    OC.of(!0)
  ];
}
function nM(n) {
  return n.startState.facet(Af) != n.state.facet(Af);
}
const _z = /* @__PURE__ */ eM({
  above: !0,
  markers(n) {
    let { state: e } = n, t = e.facet(Af), r = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty || t.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = i.empty ? i : G.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let a of ad.forRange(n, o, l))
          r.push(a);
      }
    }
    return r;
  },
  update(n, e) {
    n.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = nM(n);
    return t && hw(n.state, e), n.docChanged || n.selectionSet || t;
  },
  mount(n, e) {
    hw(e.state, n);
  },
  class: "cm-cursorLayer"
});
function hw(n, e) {
  e.style.animationDuration = n.facet(Af).cursorBlinkRate + "ms";
}
const Lz = /* @__PURE__ */ eM({
  above: !1,
  markers(n) {
    return n.state.selection.ranges.map((e) => e.empty ? [] : ad.forRange(n, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(n, e) {
    return n.docChanged || n.selectionSet || n.viewportChanged || nM(n);
  },
  class: "cm-selectionLayer"
}), Bz = /* @__PURE__ */ kl.highest(/* @__PURE__ */ Ce.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), rM = /* @__PURE__ */ Xe.define({
  map(n, e) {
    return n == null ? null : e.mapPos(n);
  }
}), nh = /* @__PURE__ */ On.define({
  create() {
    return null;
  },
  update(n, e) {
    return n != null && (n = e.changes.mapPos(n)), e.effects.reduce((t, r) => r.is(rM) ? r.value : t, n);
  }
}), zz = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var e;
    let t = n.state.field(nh);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(nh) != t || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, e = n.state.field(nh), t = e != null && n.coordsAtPos(e);
    if (!t)
      return null;
    let r = n.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - r.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: t.top - r.top + n.scrollDOM.scrollTop * n.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      n ? (this.cursor.style.left = n.left / e + "px", this.cursor.style.top = n.top / t + "px", this.cursor.style.height = n.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(nh) != n && this.view.dispatch({ effects: rM.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function Fz() {
  return [nh, zz];
}
function fw(n, e, t, r, i) {
  e.lastIndex = 0;
  for (let s = n.iterRange(t, r), o = t, l; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; l = e.exec(s.value); )
        i(o + l.index, l);
}
function Hz(n, e) {
  let t = n.visibleRanges;
  if (t.length == 1 && t[0].from == n.viewport.from && t[0].to == n.viewport.to)
    return t;
  let r = [];
  for (let { from: i, to: s } of t)
    i = Math.max(n.state.doc.lineAt(i).from, i - e), s = Math.min(n.state.doc.lineAt(s).to, s + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = s : r.push({ from: i, to: s });
  return r;
}
class $z {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: r, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, i)
      this.addMatch = (l, a, c, u) => i(u, c, c + l[0].length, l, a);
    else if (typeof r == "function")
      this.addMatch = (l, a, c, u) => {
        let h = r(l, a, c);
        h && u(c, c + l[0].length, h);
      };
    else if (r)
      this.addMatch = (l, a, c, u) => u(c, c + l[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new lo(), r = t.add.bind(t);
    for (let { from: i, to: s } of Hz(e, this.maxLength))
      fw(e.state.doc, this.regexp, i, s, (o, l) => this.addMatch(l, e, o, r));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let r = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, o, l, a) => {
      a >= e.view.viewport.from && l <= e.view.viewport.to && (r = Math.min(l, r), i = Math.max(a, i));
    }), e.viewportMoved || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, t.map(e.changes), r, i) : t;
  }
  updateRange(e, t, r, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, r), l = Math.min(s.to, i);
      if (l >= o) {
        let a = e.state.doc.lineAt(o), c = a.to < l ? e.state.doc.lineAt(l) : a, u = Math.max(s.from, a.from), h = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > a.from; o--)
            if (this.boundary.test(a.text[o - 1 - a.from])) {
              u = o;
              break;
            }
          for (; l < c.to; l++)
            if (this.boundary.test(c.text[l - c.from])) {
              h = l;
              break;
            }
        }
        let f = [], d, p = (m, g, b) => f.push(b.range(m, g));
        if (a == c)
          for (this.regexp.lastIndex = u - a.from; (d = this.regexp.exec(a.text)) && d.index < h - a.from; )
            this.addMatch(d, e, d.index + a.from, p);
        else
          fw(e.state.doc, this.regexp, u, h, (m, g) => this.addMatch(g, e, m, p));
        t = t.update({ filterFrom: u, filterTo: h, filter: (m, g) => m < u || g > h, add: f });
      }
    }
    return t;
  }
}
const ly = /x/.unicode != null ? "gu" : "g", Vz = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, ly), qz = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Lg = null;
function Wz() {
  var n;
  if (Lg == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Lg = ((n = e.tabSize) !== null && n !== void 0 ? n : e.MozTabSize) != null;
  }
  return Lg || !1;
}
const Q0 = /* @__PURE__ */ xe.define({
  combine(n) {
    let e = Ts(n, {
      render: null,
      specialChars: Vz,
      addSpecialChars: null
    });
    return (e.replaceTabs = !Wz()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, ly)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, ly)), e;
  }
});
function jz(n = {}) {
  return [Q0.of(n), Uz()];
}
let dw = null;
function Uz() {
  return dw || (dw = gn.fromClass(class {
    constructor(n) {
      this.view = n, this.decorations = He.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(n.state.facet(Q0)), this.decorations = this.decorator.createDeco(n);
    }
    makeDecorator(n) {
      return new $z({
        regexp: n.specialChars,
        decoration: (e, t, r) => {
          let { doc: i } = t.state, s = kr(e[0], 0);
          if (s == 9) {
            let o = i.lineAt(r), l = t.state.tabSize, a = tu(o.text, l, r - o.from);
            return He.replace({
              widget: new Jz((l - a % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = He.replace({ widget: new Yz(n, s) }));
        },
        boundary: n.replaceTabs ? void 0 : /[^]/
      });
    }
    update(n) {
      let e = n.state.facet(Q0);
      n.startState.facet(Q0) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(n.view)) : this.decorations = this.decorator.updateDeco(n, this.decorations);
    }
  }, {
    decorations: (n) => n.decorations
  }));
}
const Kz = "•";
function Gz(n) {
  return n >= 32 ? Kz : n == 10 ? "␤" : String.fromCharCode(9216 + n);
}
class Yz extends xo {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = Gz(this.code), r = e.state.phrase("Control character") + " " + (qz[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, t);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = t, s.title = r, s.setAttribute("aria-label", r), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class Jz extends xo {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function Xz() {
  return Qz;
}
const Zz = /* @__PURE__ */ He.line({ class: "cm-activeLine" }), Qz = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.docChanged || n.selectionSet) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = -1, t = [];
    for (let r of n.state.selection.ranges) {
      let i = n.lineBlockAt(r.head);
      i.from > e && (t.push(Zz.range(i.from)), e = i.from);
    }
    return He.set(t);
  }
}, {
  decorations: (n) => n.decorations
}), ay = 2e3;
function eF(n, e, t) {
  let r = Math.min(e.line, t.line), i = Math.max(e.line, t.line), s = [];
  if (e.off > ay || t.off > ay || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), l = Math.max(e.off, t.off);
    for (let a = r; a <= i; a++) {
      let c = n.doc.line(a);
      c.length <= l && s.push(G.range(c.from + o, c.to + l));
    }
  } else {
    let o = Math.min(e.col, t.col), l = Math.max(e.col, t.col);
    for (let a = r; a <= i; a++) {
      let c = n.doc.line(a), u = F4(c.text, o, n.tabSize, !0);
      if (u < 0)
        s.push(G.cursor(c.to));
      else {
        let h = F4(c.text, l, n.tabSize);
        s.push(G.range(c.from + u, c.from + h));
      }
    }
  }
  return s;
}
function tF(n, e) {
  let t = n.coordsAtPos(n.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / n.defaultCharacterWidth)) : -1;
}
function pw(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = n.state.doc.lineAt(t), i = t - r.from, s = i > ay ? -1 : i == r.length ? tF(n, e.clientX) : tu(r.text, n.state.tabSize, t - r.from);
  return { line: r.number, col: s, off: i };
}
function nF(n, e) {
  let t = pw(n, e), r = n.state.selection;
  return t ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(t.line).from), o = i.state.doc.lineAt(s);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, r = r.map(i.changes);
      }
    },
    get(i, s, o) {
      let l = pw(n, i);
      if (!l)
        return r;
      let a = eF(n.state, t, l);
      return a.length ? o ? G.create(a.concat(r.ranges)) : G.create(a) : r;
    }
  } : null;
}
function rF(n) {
  let e = ((t) => t.altKey && t.button == 0);
  return Ce.mouseSelectionStyle.of((t, r) => e(r) ? nF(t, r) : null);
}
const iF = {
  Alt: [18, (n) => !!n.altKey],
  Control: [17, (n) => !!n.ctrlKey],
  Shift: [16, (n) => !!n.shiftKey],
  Meta: [91, (n) => !!n.metaKey]
}, sF = { style: "cursor: crosshair" };
function oF(n = {}) {
  let [e, t] = iF[n.key || "Alt"], r = gn.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || t(i));
      },
      keyup(i) {
        (i.keyCode == e || !t(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(t(i));
      }
    }
  });
  return [
    r,
    Ce.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(r)) === null || s === void 0) && s.isDown ? sF : null;
    })
  ];
}
const Lu = "-10000px";
class iM {
  constructor(e, t, r, i) {
    this.facet = t, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = r(o, s));
  }
  update(e, t) {
    var r;
    let i = e.state.facet(this.facet), s = i.filter((a) => a);
    if (i === this.input) {
      for (let a of this.tooltipViews)
        a.update && a.update(e);
      return !1;
    }
    let o = [], l = t ? [] : null;
    for (let a = 0; a < s.length; a++) {
      let c = s[a], u = -1;
      if (c) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let f = this.tooltips[h];
          f && f.create == c.create && (u = h);
        }
        if (u < 0)
          o[a] = this.createTooltipView(c, a ? o[a - 1] : null), l && (l[a] = !!c.above);
        else {
          let h = o[a] = this.tooltipViews[u];
          l && (l[a] = t[u]), h.update && h.update(e);
        }
      }
    }
    for (let a of this.tooltipViews)
      o.indexOf(a) < 0 && (this.removeTooltipView(a), (r = a.destroy) === null || r === void 0 || r.call(a));
    return t && (l.forEach((a, c) => t[c] = a), t.length = l.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function lF(n) {
  let e = n.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const Bg = /* @__PURE__ */ xe.define({
  combine: (n) => {
    var e, t, r;
    return {
      position: we.ios ? "absolute" : ((e = n.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = n.find((i) => i.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((r = n.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || lF
    };
  }
}), mw = /* @__PURE__ */ new WeakMap(), w3 = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = n.state.facet(Bg);
    this.position = e.position, this.parent = e.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new iM(n, x3, (t, r) => this.createTooltip(t, r), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(n, this.above);
    e && this.observeIntersection();
    let t = e || n.geometryChanged, r = n.state.facet(Bg);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      t = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      t = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(n, e) {
    let t = n.create(this.view), r = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), n.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", t.dom.appendChild(i);
    }
    return t.dom.style.position = this.position, t.dom.style.top = Lu, t.dom.style.left = "0px", this.container.insertBefore(t.dom, r), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var n, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (n = r.destroy) === null || n === void 0 || n.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = 1, e = 1, t = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: s } = this.manager.tooltipViews[0];
      if (we.gecko)
        t = s.offsetParent != this.container.ownerDocument.body;
      else if (s.style.top == Lu && s.style.left == "0px") {
        let o = s.getBoundingClientRect();
        t = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (t || this.position == "absolute")
      if (this.parent) {
        let s = this.parent.getBoundingClientRect();
        s.width && s.height && (n = s.width / this.parent.offsetWidth, e = s.height / this.parent.offsetHeight);
      } else
        ({ scaleX: n, scaleY: e } = this.view.viewState);
    let r = this.view.scrollDOM.getBoundingClientRect(), i = g3(this.view);
    return {
      visible: {
        left: r.left + i.left,
        top: r.top + i.top,
        right: r.right - i.right,
        bottom: r.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((s, o) => {
        let l = this.manager.tooltipViews[o];
        return l.getCoords ? l.getCoords(s.pos) : this.view.coordsAtPos(s.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: s }) => s.getBoundingClientRect()),
      space: this.view.state.facet(Bg).tooltipSpace(this.view),
      scaleX: n,
      scaleY: e,
      makeAbsolute: t
    };
  }
  writeMeasure(n) {
    var e;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { visible: t, space: r, scaleX: i, scaleY: s } = n, o = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let a = this.manager.tooltips[l], c = this.manager.tooltipViews[l], { dom: u } = c, h = n.pos[l], f = n.size[l];
      if (!h || a.clip !== !1 && (h.bottom <= Math.max(t.top, r.top) || h.top >= Math.min(t.bottom, r.bottom) || h.right < Math.max(t.left, r.left) - 0.1 || h.left > Math.min(t.right, r.right) + 0.1)) {
        u.style.top = Lu;
        continue;
      }
      let d = a.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = d ? 7 : 0, m = f.right - f.left, g = (e = mw.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top, b = c.offset || cF, w = this.view.textDirection == qt.LTR, k = f.width > r.right - r.left ? w ? r.left : r.right - f.width : w ? Math.max(r.left, Math.min(h.left - (d ? 14 : 0) + b.x, r.right - m)) : Math.min(Math.max(r.left, h.left - m + (d ? 14 : 0) - b.x), r.right - m), C = this.above[l];
      !a.strictSide && (C ? h.top - g - p - b.y < r.top : h.bottom + g + p + b.y > r.bottom) && C == r.bottom - h.bottom > h.top - r.top && (C = this.above[l] = !C);
      let M = (C ? h.top - r.top : r.bottom - h.bottom) - p;
      if (M < g && c.resize !== !1) {
        if (M < this.view.defaultLineHeight) {
          u.style.top = Lu;
          continue;
        }
        mw.set(c, g), u.style.height = (g = M) / s + "px";
      } else u.style.height && (u.style.height = "");
      let T = C ? h.top - g - p - b.y : h.bottom + p + b.y, N = k + m;
      if (c.overlap !== !0)
        for (let B of o)
          B.left < N && B.right > k && B.top < T + g && B.bottom > T && (T = C ? B.top - g - 2 - p : B.bottom + p + 2);
      if (this.position == "absolute" ? (u.style.top = (T - n.parent.top) / s + "px", gw(u, (k - n.parent.left) / i)) : (u.style.top = T / s + "px", gw(u, k / i)), d) {
        let B = h.left + (w ? b.x : -b.x) - (k + 14 - 7);
        d.style.left = B / i + "px";
      }
      c.overlap !== !0 && o.push({ left: k, top: T, right: N, bottom: T + g }), u.classList.toggle("cm-tooltip-above", C), u.classList.toggle("cm-tooltip-below", !C), c.positioned && c.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = Lu;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function gw(n, e) {
  let t = parseInt(n.style.left, 10);
  (isNaN(t) || Math.abs(e - t) > 1) && (n.style.left = e + "px");
}
const aF = /* @__PURE__ */ Ce.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), cF = { x: 0, y: 0 }, x3 = /* @__PURE__ */ xe.define({
  enables: [w3, aF]
}), sm = /* @__PURE__ */ xe.define({
  combine: (n) => n.reduce((e, t) => e.concat(t), [])
});
class o1 {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new o1(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new iM(e, sm, (t, r) => this.createHostedView(t, r), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (t === void 0)
          t = i;
        else if (t !== i)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const uF = /* @__PURE__ */ x3.compute([sm], (n) => {
  let e = n.facet(sm);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var r;
      return (r = t.end) !== null && r !== void 0 ? r : t.pos;
    })),
    create: o1.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class hF {
  constructor(e, t, r, i, s) {
    this.view = e, this.source = t, this.field = r, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, r = e.docView.nearest(t.target);
    if (!r)
      return;
    let i, s = 1;
    if (r instanceof Jo)
      i = r.posAtStart;
    else {
      if (i = e.posAtCoords(t), i == null)
        return;
      let l = e.coordsAtPos(i);
      if (!l || t.y < l.top || t.y > l.bottom || t.x < l.left - e.defaultCharacterWidth || t.x > l.right + e.defaultCharacterWidth)
        return;
      let a = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), c = a && a.dir == qt.RTL ? -1 : 1;
      s = t.x < l.left ? -c : c;
    }
    let o = this.source(e, i, s);
    if (o?.then) {
      let l = this.pending = { pos: i };
      o.then((a) => {
        this.pending == l && (this.pending = null, a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) }));
      }, (a) => Mr(e.state, a, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(w3), t = e ? e.manager.tooltips.findIndex((r) => r.create == o1.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: s } = this;
    if (i.length && s && !fF(s.dom, e) || this.pending) {
      let { pos: o } = i[0] || this.pending, l = (r = (t = i[0]) === null || t === void 0 ? void 0 : t.end) !== null && r !== void 0 ? r : o;
      (o == l ? this.view.posAtCoords(this.lastMove) != o : !dF(this.view, o, l, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (r) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const s0 = 4;
function fF(n, e) {
  let { left: t, right: r, top: i, bottom: s } = n.getBoundingClientRect(), o;
  if (o = n.querySelector(".cm-tooltip-arrow")) {
    let l = o.getBoundingClientRect();
    i = Math.min(l.top, i), s = Math.max(l.bottom, s);
  }
  return e.clientX >= t - s0 && e.clientX <= r + s0 && e.clientY >= i - s0 && e.clientY <= s + s0;
}
function dF(n, e, t, r, i, s) {
  let o = n.scrollDOM.getBoundingClientRect(), l = n.documentTop + n.documentPadding.top + n.contentHeight;
  if (o.left > r || o.right < r || o.top > i || Math.min(o.bottom, l) < i)
    return !1;
  let a = n.posAtCoords({ x: r, y: i }, !1);
  return a >= e && a <= t;
}
function pF(n, e = {}) {
  let t = Xe.define(), r = On.define({
    create() {
      return [];
    },
    update(i, s) {
      if (i.length && (e.hideOnChange && (s.docChanged || s.selection) ? i = [] : e.hideOn && (i = i.filter((o) => !e.hideOn(s, o))), s.docChanged)) {
        let o = [];
        for (let l of i) {
          let a = s.changes.mapPos(l.pos, -1, Bn.TrackDel);
          if (a != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), l);
            c.pos = a, c.end != null && (c.end = s.changes.mapPos(c.end)), o.push(c);
          }
        }
        i = o;
      }
      for (let o of s.effects)
        o.is(t) && (i = o.value), o.is(mF) && (i = []);
      return i;
    },
    provide: (i) => sm.from(i)
  });
  return {
    active: r,
    extension: [
      r,
      gn.define((i) => new hF(
        i,
        n,
        r,
        t,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      uF
    ]
  };
}
function sM(n, e) {
  let t = n.plugin(w3);
  if (!t)
    return null;
  let r = t.manager.tooltips.indexOf(e);
  return r < 0 ? null : t.manager.tooltipViews[r];
}
const mF = /* @__PURE__ */ Xe.define(), yw = /* @__PURE__ */ xe.define({
  combine(n) {
    let e, t;
    for (let r of n)
      e = e || r.topContainer, t = t || r.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Of(n, e) {
  let t = n.plugin(oM), r = t ? t.specs.indexOf(e) : -1;
  return r > -1 ? t.panels[r] : null;
}
const oM = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.input = n.state.facet(Ef), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(n));
    let e = n.state.facet(yw);
    this.top = new o0(n, !0, e.topContainer), this.bottom = new o0(n, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(n) {
    let e = n.state.facet(yw);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new o0(n.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new o0(n.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = n.state.facet(Ef);
    if (t != this.input) {
      let r = t.filter((a) => a), i = [], s = [], o = [], l = [];
      for (let a of r) {
        let c = this.specs.indexOf(a), u;
        c < 0 ? (u = a(n.view), l.push(u)) : (u = this.panels[c], u.update && u.update(n)), i.push(u), (u.top ? s : o).push(u);
      }
      this.specs = r, this.panels = i, this.top.sync(s), this.bottom.sync(o);
      for (let a of l)
        a.dom.classList.add("cm-panel"), a.mount && a.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(n);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (n) => Ce.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class o0 {
  constructor(e, t, r) {
    this.view = e, this.top = t, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = bw(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = bw(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function bw(n) {
  let e = n.nextSibling;
  return n.remove(), e;
}
const Ef = /* @__PURE__ */ xe.define({
  enables: oM
});
class uo extends va {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
uo.prototype.elementClass = "";
uo.prototype.toDOM = void 0;
uo.prototype.mapMode = Bn.TrackBefore;
uo.prototype.startSide = uo.prototype.endSide = -1;
uo.prototype.point = !0;
const ep = /* @__PURE__ */ xe.define(), gF = /* @__PURE__ */ xe.define(), yF = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => ut.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {},
  side: "before"
}, $h = /* @__PURE__ */ xe.define();
function bF(n) {
  return [lM(), $h.of({ ...yF, ...n })];
}
const vw = /* @__PURE__ */ xe.define({
  combine: (n) => n.some((e) => e)
});
function lM(n) {
  return [
    vF
  ];
}
const vF = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.domAfter = null, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = n.state.facet($h).map((e) => new xw(n, e)), this.fixed = !n.state.facet(vw);
    for (let e of this.gutters)
      e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
    this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  getDOMAfter() {
    return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
  }
  update(n) {
    if (this.updateGutters(n)) {
      let e = this.prevViewport, t = n.view.viewport, r = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(r < (t.to - t.from) * 0.8);
    }
    if (n.geometryChanged) {
      let e = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
    }
    this.view.state.facet(vw) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let e = this.dom.nextSibling;
    n && (this.dom.remove(), this.domAfter && this.domAfter.remove());
    let t = ut.iter(this.view.state.facet(ep), this.view.viewport.from), r = [], i = this.gutters.map((s) => new wF(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(s.type)) {
        let o = !0;
        for (let l of s.type)
          if (l.type == hr.Text && o) {
            cy(t, r, l.from);
            for (let a of i)
              a.line(this.view, l, r);
            o = !1;
          } else if (l.widget)
            for (let a of i)
              a.widget(this.view, l);
      } else if (s.type == hr.Text) {
        cy(t, r, s.from);
        for (let o of i)
          o.line(this.view, s, r);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    n && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
  }
  updateGutters(n) {
    let e = n.startState.facet($h), t = n.state.facet($h), r = n.docChanged || n.heightChanged || n.viewportChanged || !ut.eq(n.startState.facet(ep), n.state.facet(ep), n.view.viewport.from, n.view.viewport.to);
    if (e == t)
      for (let i of this.gutters)
        i.update(n) && (r = !0);
    else {
      r = !0;
      let i = [];
      for (let s of t) {
        let o = e.indexOf(s);
        o < 0 ? i.push(new xw(this.view, s)) : (this.gutters[o].update(n), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        s.config.side == "after" ? this.getDOMAfter().appendChild(s.dom) : this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove(), this.domAfter && this.domAfter.remove();
  }
}, {
  provide: (n) => Ce.scrollMargins.of((e) => {
    let t = e.plugin(n);
    if (!t || t.gutters.length == 0 || !t.fixed)
      return null;
    let r = t.dom.offsetWidth * e.scaleX, i = t.domAfter ? t.domAfter.offsetWidth * e.scaleX : 0;
    return e.textDirection == qt.LTR ? { left: r, right: i } : { right: r, left: i };
  })
});
function ww(n) {
  return Array.isArray(n) ? n : [n];
}
function cy(n, e, t) {
  for (; n.value && n.from <= t; )
    n.from == t && e.push(n.value), n.next();
}
class wF {
  constructor(e, t, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = ut.iter(e.markers, t.from);
  }
  addElement(e, t, r) {
    let { gutter: i } = this, s = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == i.elements.length) {
      let l = new aM(e, o, s, r);
      i.elements.push(l), i.dom.appendChild(l.dom);
    } else
      i.elements[this.i].update(e, o, s, r);
    this.height = t.bottom, this.i++;
  }
  line(e, t, r) {
    let i = [];
    cy(this.cursor, i, t.from), r.length && (i = i.concat(r));
    let s = this.gutter.config.lineMarker(e, t, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, i);
  }
  widget(e, t) {
    let r = this.gutter.config.widgetMarker(e, t.widget, t), i = r ? [r] : null;
    for (let s of e.state.facet(gF)) {
      let o = s(e, t.widget, t);
      o && (i || (i = [])).push(o);
    }
    i && this.addElement(e, t, i);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class xw {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in t.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let a = s.getBoundingClientRect();
          o = (a.top + a.bottom) / 2;
        } else
          o = i.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[r](e, l, i) && i.preventDefault();
      });
    this.markers = ww(t.markers(e)), t.initialSpacer && (this.spacer = new aM(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = ww(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !ut.eq(this.markers, t, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class aM {
  constructor(e, t, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, r, i);
  }
  update(e, t, r, i) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), xF(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, t) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o, a = s < t.length ? t[s++] : null, c = !1;
      if (a) {
        let u = a.elementClass;
        u && (r += " " + u);
        for (let h = o; h < this.markers.length; h++)
          if (this.markers[h].compare(a)) {
            l = h, c = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(i);
          let h = i.nextSibling;
          i.remove(), i = h;
        }
      }
      if (!a)
        break;
      a.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(a.toDOM(e), i)), c && o++;
    }
    this.dom.className = r, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function xF(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].compare(e[t]))
      return !1;
  return !0;
}
const kF = /* @__PURE__ */ xe.define(), SF = /* @__PURE__ */ xe.define(), mc = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let r = Object.assign({}, e);
        for (let i in t) {
          let s = r[i], o = t[i];
          r[i] = s ? (l, a, c) => s(l, a, c) || o(l, a, c) : o;
        }
        return r;
      }
    });
  }
});
class zg extends uo {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Fg(n, e) {
  return n.state.facet(mc).formatNumber(e, n.state);
}
const CF = /* @__PURE__ */ $h.compute([mc], (n) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(kF);
  },
  lineMarker(e, t, r) {
    return r.some((i) => i.toDOM) ? null : new zg(Fg(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: (e, t, r) => {
    for (let i of e.state.facet(SF)) {
      let s = i(e, t, r);
      if (s)
        return s;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(mc) != e.state.facet(mc),
  initialSpacer(e) {
    return new zg(Fg(e, kw(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let r = Fg(t.view, kw(t.view.state.doc.lines));
    return r == e.number ? e : new zg(r);
  },
  domEventHandlers: n.facet(mc).domEventHandlers,
  side: "before"
}));
function MF(n = {}) {
  return [
    mc.of(n),
    lM(),
    CF
  ];
}
function kw(n) {
  let e = 9;
  for (; e < n; )
    e = e * 10 + 9;
  return e;
}
const TF = /* @__PURE__ */ new class extends uo {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), AF = /* @__PURE__ */ ep.compute(["selection"], (n) => {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.head).from;
    i > t && (t = i, e.push(TF.range(i)));
  }
  return ut.of(e);
});
function OF() {
  return AF;
}
let EF = 0;
class si {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.set = t, this.base = r, this.modified = i, this.id = EF++;
  }
  toString() {
    let { name: e } = this;
    for (let t of this.modified)
      t.name && (e = `${t.name}(${e})`);
    return e;
  }
  static define(e, t) {
    let r = typeof e == "string" ? e : "?";
    if (e instanceof si && (t = e), t?.base)
      throw new Error("Can not derive from a modified tag");
    let i = new si(r, [], null, []);
    if (i.set.push(i), t)
      for (let s of t.set)
        i.set.push(s);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let t = new om(e);
    return (r) => r.modified.indexOf(t) > -1 ? r : om.get(r.base || r, r.modified.concat(t).sort((i, s) => i.id - s.id));
  }
}
let IF = 0;
class om {
  constructor(e) {
    this.name = e, this.instances = [], this.id = IF++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let r = t[0].instances.find((l) => l.base == e && DF(t, l.modified));
    if (r)
      return r;
    let i = [], s = new si(e.name, i, e, t);
    for (let l of t)
      l.instances.push(s);
    let o = NF(t);
    for (let l of e.set)
      if (!l.modified.length)
        for (let a of o)
          i.push(om.get(l, a));
    return s;
  }
}
function DF(n, e) {
  return n.length == e.length && n.every((t, r) => t == e[r]);
}
function NF(n) {
  let e = [[]];
  for (let t = 0; t < n.length; t++)
    for (let r = 0, i = e.length; r < i; r++)
      e.push(e[r].concat(n[t]));
  return e.sort((t, r) => r.length - t.length);
}
function RF(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    Array.isArray(r) || (r = [r]);
    for (let i of t.split(" "))
      if (i) {
        let s = [], o = 2, l = i;
        for (let h = 0; ; ) {
          if (l == "..." && h > 0 && h + 3 == i.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), h += f[0].length, h == i.length)
            break;
          let d = i[h++];
          if (h == i.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + i);
          l = i.slice(h);
        }
        let a = s.length - 1, c = s[a];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let u = new lm(r, o, a > 0 ? s.slice(0, a) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return cM.add(e);
}
const cM = new st();
class lm {
  constructor(e, t, r, i) {
    this.tags = e, this.mode = t, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
lm.empty = new lm([], 2, null);
function uM(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let s of n)
    if (!Array.isArray(s.tag))
      t[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        t[o.id] = s.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let l of s)
        for (let a of l.set) {
          let c = t[a.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function PF(n, e) {
  let t = null;
  for (let r of n) {
    let i = r.style(e);
    i && (t = t ? t + " " + i : i);
  }
  return t;
}
function _F(n, e, t, r = 0, i = n.length) {
  let s = new LF(r, Array.isArray(e) ? e : [e], t);
  s.highlightRange(n.cursor(), r, i, "", s.highlighters), s.flush(i);
}
class LF {
  constructor(e, t, r) {
    this.at = e, this.highlighters = t, this.span = r, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, r, i, s) {
    let { type: o, from: l, to: a } = e;
    if (l >= r || a <= t)
      return;
    o.isTop && (s = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let c = i, u = BF(e) || lm.empty, h = PF(s, u.tags);
    if (h && (c && (c += " "), c += h, u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(t, l), c), u.opaque)
      return;
    let f = e.tree && e.tree.prop(st.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + l, 1), p = this.highlighters.filter((g) => !g.scope || g.scope(f.tree.type)), m = e.firstChild();
      for (let g = 0, b = l; ; g++) {
        let w = g < f.overlay.length ? f.overlay[g] : null, k = w ? w.from + l : a, C = Math.max(t, b), M = Math.min(r, k);
        if (C < M && m)
          for (; e.from < M && (this.highlightRange(e, C, M, i, s), this.startSpan(Math.min(M, e.to), c), !(e.to >= k || !e.nextSibling())); )
            ;
        if (!w || k > r)
          break;
        b = w.to + l, b > t && (this.highlightRange(d.cursor(), Math.max(t, w.from + l), Math.min(r, b), "", p), this.startSpan(Math.min(r, b), c));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      f && (i = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, t, r, i, s), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function BF(n) {
  let e = n.type.prop(cM);
  for (; e && e.context && !n.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const me = si.define, l0 = me(), zo = me(), Sw = me(zo), Cw = me(zo), Fo = me(), a0 = me(Fo), Hg = me(Fo), Qi = me(), Pl = me(Qi), Ji = me(), Xi = me(), uy = me(), Bu = me(uy), c0 = me(), U = {
  /**
  A comment.
  */
  comment: l0,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: me(l0),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: me(l0),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: me(l0),
  /**
  Any kind of identifier.
  */
  name: zo,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: me(zo),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: Sw,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: me(Sw),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Cw,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: me(Cw),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: me(zo),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: me(zo),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: me(zo),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: me(zo),
  /**
  A literal value.
  */
  literal: Fo,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: a0,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: me(a0),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: me(a0),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: me(a0),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Hg,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: me(Hg),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: me(Hg),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: me(Fo),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: me(Fo),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: me(Fo),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: me(Fo),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: me(Fo),
  /**
  A language keyword.
  */
  keyword: Ji,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: me(Ji),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: me(Ji),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: me(Ji),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: me(Ji),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: me(Ji),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: me(Ji),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: me(Ji),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: me(Ji),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: me(Ji),
  /**
  An operator.
  */
  operator: Xi,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: me(Xi),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: me(Xi),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: me(Xi),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: me(Xi),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: me(Xi),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: me(Xi),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: me(Xi),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: me(Xi),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: me(Xi),
  /**
  Program or markup punctuation.
  */
  punctuation: uy,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: me(uy),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Bu,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: me(Bu),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: me(Bu),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: me(Bu),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: me(Bu),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Qi,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Pl,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: me(Pl),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: me(Pl),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: me(Pl),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: me(Pl),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: me(Pl),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: me(Pl),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: me(Qi),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: me(Qi),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: me(Qi),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: me(Qi),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: me(Qi),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: me(Qi),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: me(Qi),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: me(Qi),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: me(),
  /**
  Deleted text.
  */
  deleted: me(),
  /**
  Changed text.
  */
  changed: me(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: me(),
  /**
  Metadata or meta-instruction.
  */
  meta: c0,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: me(c0),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: me(c0),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: me(c0),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: si.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: si.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: si.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: si.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: si.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: si.defineModifier("special")
};
for (let n in U) {
  let e = U[n];
  e instanceof si && (e.name = n);
}
uM([
  { tag: U.link, class: "tok-link" },
  { tag: U.heading, class: "tok-heading" },
  { tag: U.emphasis, class: "tok-emphasis" },
  { tag: U.strong, class: "tok-strong" },
  { tag: U.keyword, class: "tok-keyword" },
  { tag: U.atom, class: "tok-atom" },
  { tag: U.bool, class: "tok-bool" },
  { tag: U.url, class: "tok-url" },
  { tag: U.labelName, class: "tok-labelName" },
  { tag: U.inserted, class: "tok-inserted" },
  { tag: U.deleted, class: "tok-deleted" },
  { tag: U.literal, class: "tok-literal" },
  { tag: U.string, class: "tok-string" },
  { tag: U.number, class: "tok-number" },
  { tag: [U.regexp, U.escape, U.special(U.string)], class: "tok-string2" },
  { tag: U.variableName, class: "tok-variableName" },
  { tag: U.local(U.variableName), class: "tok-variableName tok-local" },
  { tag: U.definition(U.variableName), class: "tok-variableName tok-definition" },
  { tag: U.special(U.variableName), class: "tok-variableName2" },
  { tag: U.definition(U.propertyName), class: "tok-propertyName tok-definition" },
  { tag: U.typeName, class: "tok-typeName" },
  { tag: U.namespace, class: "tok-namespace" },
  { tag: U.className, class: "tok-className" },
  { tag: U.macroName, class: "tok-macroName" },
  { tag: U.propertyName, class: "tok-propertyName" },
  { tag: U.operator, class: "tok-operator" },
  { tag: U.comment, class: "tok-comment" },
  { tag: U.meta, class: "tok-meta" },
  { tag: U.invalid, class: "tok-invalid" },
  { tag: U.punctuation, class: "tok-punctuation" }
]);
var $g;
const ea = /* @__PURE__ */ new st();
function hM(n) {
  return xe.define({
    combine: n ? (e) => e.concat(n) : void 0
  });
}
const zF = /* @__PURE__ */ new st();
class ci {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], i = "") {
    this.data = e, this.name = i, jt.prototype.hasOwnProperty("tree") || Object.defineProperty(jt.prototype, "tree", { get() {
      return Fn(this);
    } }), this.parser = t, this.extension = [
      fl.of(this),
      jt.languageData.of((s, o, l) => {
        let a = Mw(s, o, l), c = a.type.prop(ea);
        if (!c)
          return [];
        let u = s.facet(c), h = a.type.prop(zF);
        if (h) {
          let f = a.resolve(o - a.from, l);
          for (let d of h)
            if (d.test(f, s)) {
              let p = s.facet(d.facet);
              return d.type == "replace" ? p : p.concat(u);
            }
        }
        return u;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return Mw(e, t, r).type.prop(ea) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(fl);
    if (t?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], i = (s, o) => {
      if (s.prop(ea) == this.data) {
        r.push({ from: o, to: o + s.length });
        return;
      }
      let l = s.prop(st.mounted);
      if (l) {
        if (l.tree.prop(ea) == this.data) {
          if (l.overlay)
            for (let a of l.overlay)
              r.push({ from: a.from + o, to: a.to + o });
          else
            r.push({ from: o, to: o + s.length });
          return;
        } else if (l.overlay) {
          let a = r.length;
          if (i(l.tree, l.overlay[0].from + o), r.length > a)
            return;
        }
      }
      for (let a = 0; a < s.children.length; a++) {
        let c = s.children[a];
        c instanceof Bt && i(c, s.positions[a] + o);
      }
    };
    return i(Fn(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
ci.setState = /* @__PURE__ */ Xe.define();
function Mw(n, e, t) {
  let r = n.facet(fl), i = Fn(n).topNode;
  if (!r || r.allowsNesting)
    for (let s = i; s; s = s.enter(e, t, Zt.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
class hy extends ci {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = hM(e.languageData);
    return new hy(t, e.parser.configure({
      props: [ea.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new hy(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Fn(n) {
  let e = n.field(ci.state, !1);
  return e ? e.tree : Bt.empty;
}
class FF {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let zu = null, fy = class dy {
  constructor(e, t, r = [], i, s, o, l, a) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = l, this.scheduleOn = a, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new dy(e, t, [], Bt.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new FF(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != Bt.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(to.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(to.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = zu;
    zu = this;
    try {
      return e();
    } finally {
      zu = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = Tw(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let a = [];
      if (e.iterChangedRanges((c, u, h, f) => a.push({ fromA: c, toA: u, fromB: h, toB: f })), r = to.applyChanges(r, a), i = Bt.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
          u < h && l.push({ from: u, to: h });
        }
      }
    }
    return new dy(this.parser, t, r, i, s, o, l, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: s } = this.skipped[r];
      i < e.to && s > e.from && (this.fragments = Tw(this.fragments, i, s), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends NS {
      createParse(t, r, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let a = zu;
            if (a) {
              for (let c of i)
                a.tempSkipped.push(c);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new Bt(Qr.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return zu;
  }
};
function Tw(n, e, t) {
  return to.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class Bc {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new Bc(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = fy.create(e.facet(fl).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new Bc(r);
  }
}
ci.state = /* @__PURE__ */ On.define({
  create: Bc.init,
  update(n, e) {
    for (let t of e.effects)
      if (t.is(ci.setState))
        return t.value;
    return e.startState.facet(fl) != e.state.facet(fl) ? Bc.init(e.state) : n.apply(e);
  }
});
let fM = (n) => {
  let e = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (fM = (n) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const Vg = typeof navigator < "u" && (!(($g = navigator.scheduling) === null || $g === void 0) && $g.isInputPending) ? () => navigator.scheduling.isInputPending() : null, HF = /* @__PURE__ */ gn.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(ci.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(ci.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = fM(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, s = r.field(ci.state);
    if (s.tree == s.context.tree && s.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !Vg ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = s.context.treeLen < i && r.doc.length > i + 1e3, a = s.context.work(() => Vg && Vg() || Date.now() > o, i + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (a || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: ci.setState.of(new Bc(s.context)) })), this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Mr(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), fl = /* @__PURE__ */ xe.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    ci.state,
    HF,
    Ce.contentAttributes.compute([n], (e) => {
      let t = e.facet(n);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class $F {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
class q {
  constructor(e, t, r, i, s, o = void 0) {
    this.name = e, this.alias = t, this.extensions = r, this.filename = i, this.loadFunc = s, this.support = o, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: t, support: r } = e;
    if (!t) {
      if (!r)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      t = () => Promise.resolve(r);
    }
    return new q(e.name, (e.alias || []).concat(e.name).map((i) => i.toLowerCase()), e.extensions || [], e.filename, t, r);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, t) {
    for (let i of e)
      if (i.filename && i.filename.test(t))
        return i;
    let r = /\.([^.]+)$/.exec(t);
    if (r) {
      for (let i of e)
        if (i.extensions.indexOf(r[1]) > -1)
          return i;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, t, r = !0) {
    t = t.toLowerCase();
    for (let i of e)
      if (i.alias.some((s) => s == t))
        return i;
    if (r)
      for (let i of e)
        for (let s of i.alias) {
          let o = t.indexOf(s);
          if (o > -1 && (s.length > 2 || !/\w/.test(t[o - 1]) && !/\w/.test(t[o + s.length])))
            return i;
        }
    return null;
  }
}
const VF = /* @__PURE__ */ xe.define(), l1 = /* @__PURE__ */ xe.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let e = n[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return e;
  }
});
function Sa(n) {
  let e = n.facet(l1);
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
}
function If(n, e) {
  let t = "", r = n.tabSize, i = n.facet(l1)[0];
  if (i == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    t += i;
  return t;
}
function k3(n, e) {
  n instanceof jt && (n = new a1(n));
  for (let r of n.state.facet(VF)) {
    let i = r(n, e);
    if (i !== void 0)
      return i;
  }
  let t = Fn(n.state);
  return t.length >= e ? qF(n, t, e) : null;
}
class a1 {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Sa(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= r.from && i <= r.to ? s && i == e ? { text: "", from: e } : (t < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, t);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), s = this.countColumn(r, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return tu(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const dM = /* @__PURE__ */ new st();
function qF(n, e, t) {
  let r = e.resolveStack(t), i = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
  if (i != r.node) {
    let s = [];
    for (let o = i; o && !(o.from < r.node.from || o.to > r.node.to || o.from == r.node.from && o.type == r.node.type); o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      r = { node: s[o], next: r };
  }
  return pM(r, n, t);
}
function pM(n, e, t) {
  for (let r = n; r; r = r.next) {
    let i = jF(r.node);
    if (i)
      return i(S3.create(e, t, r));
  }
  return 0;
}
function WF(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function jF(n) {
  let e = n.type.prop(dM);
  if (e)
    return e;
  let t = n.firstChild, r;
  if (t && (r = t.type.prop(st.closedBy))) {
    let i = n.lastChild, s = i && r.indexOf(i.name) > -1;
    return (o) => mM(o, !0, 1, void 0, s && !WF(o) ? i.from : void 0);
  }
  return n.parent == null ? UF : null;
}
function UF() {
  return 0;
}
class S3 extends a1 {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new S3(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (KF(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return pM(this.context.next, this.base, this.pos);
  }
}
function KF(n, e) {
  for (let t = e; t; t = t.parent)
    if (n == t)
      return !0;
  return !1;
}
function GF(n) {
  let e = n.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let i = n.options.simulateBreak, s = n.state.doc.lineAt(t.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let l = t.to; ; ) {
    let a = e.childAfter(l);
    if (!a || a == r)
      return null;
    if (!a.type.isSkipped) {
      if (a.from >= o)
        return null;
      let c = /^ */.exec(s.text.slice(t.to - s.from))[0].length;
      return { from: t.from, to: t.to + c };
    }
    l = a.to;
  }
}
function Vue({ closing: n, align: e = !0, units: t = 1 }) {
  return (r) => mM(r, e, t, n);
}
function mM(n, e, t, r, i) {
  let s = n.textAfter, o = s.match(/^\s*/)[0].length, l = r && s.slice(o, o + r.length) == r || i == n.pos + o, a = e ? GF(n) : null;
  return a ? l ? n.column(a.from) : n.column(a.to) : n.baseIndent + (l ? 0 : n.unit * t);
}
const que = (n) => n.baseIndent;
function Wue({ except: n, units: e = 1 } = {}) {
  return (t) => {
    let r = n && n.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const YF = 200;
function JF() {
  return jt.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let e = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!e.length)
      return n;
    let t = n.newDoc, { head: r } = n.newSelection.main, i = t.lineAt(r);
    if (r > i.from + YF)
      return n;
    let s = t.sliceString(i.from, r);
    if (!e.some((c) => c.test(s)))
      return n;
    let { state: o } = n, l = -1, a = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == l)
        continue;
      l = u.from;
      let h = k3(o, u.from);
      if (h == null)
        continue;
      let f = /^\s*/.exec(u.text)[0], d = If(o, h);
      f != d && a.push({ from: u.from, to: u.from + f.length, insert: d });
    }
    return a.length ? [n, { changes: a, sequential: !0 }] : n;
  });
}
const XF = /* @__PURE__ */ xe.define(), ZF = /* @__PURE__ */ new st();
function jue(n) {
  let e = n.firstChild, t = n.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? n.to : t.from } : null;
}
function QF(n, e, t) {
  let r = Fn(n);
  if (r.length < t)
    return null;
  let i = r.resolveStack(t, 1), s = null;
  for (let o = i; o; o = o.next) {
    let l = o.node;
    if (l.to <= t || l.from > t)
      continue;
    if (s && l.from < e)
      break;
    let a = l.type.prop(ZF);
    if (a && (l.to < r.length - 50 || r.length == n.doc.length || !eH(l))) {
      let c = a(l, n);
      c && c.from <= t && c.from >= e && c.to > t && (s = c);
    }
  }
  return s;
}
function eH(n) {
  let e = n.lastChild;
  return e && e.to == n.to && e.type.isError;
}
function am(n, e, t) {
  for (let r of n.facet(XF)) {
    let i = r(n, e, t);
    if (i)
      return i;
  }
  return QF(n, e, t);
}
function gM(n, e) {
  let t = e.mapPos(n.from, 1), r = e.mapPos(n.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const c1 = /* @__PURE__ */ Xe.define({ map: gM }), cd = /* @__PURE__ */ Xe.define({ map: gM });
function yM(n) {
  let e = [];
  for (let { head: t } of n.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(n.lineBlockAt(t));
  return e;
}
const Ca = /* @__PURE__ */ On.define({
  create() {
    return He.none;
  },
  update(n, e) {
    e.isUserEvent("delete") && e.changes.iterChangedRanges((t, r) => n = Aw(n, t, r)), n = n.map(e.changes);
    for (let t of e.effects)
      if (t.is(c1) && !tH(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(wM), i = r ? He.replace({ widget: new aH(r(e.state, t.value)) }) : Ow;
        n = n.update({ add: [i.range(t.value.from, t.value.to)] });
      } else t.is(cd) && (n = n.update({
        filter: (r, i) => t.value.from != r || t.value.to != i,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    return e.selection && (n = Aw(n, e.selection.main.head)), n;
  },
  provide: (n) => Ce.decorations.from(n),
  toJSON(n, e) {
    let t = [];
    return n.between(0, e.doc.length, (r, i) => {
      t.push(r, i);
    }), t;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < n.length; ) {
      let r = n[t++], i = n[t++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Ow.range(r, i));
    }
    return He.set(e, !0);
  }
});
function Aw(n, e, t = e) {
  let r = !1;
  return n.between(e, t, (i, s) => {
    i < t && s > e && (r = !0);
  }), r ? n.update({
    filterFrom: e,
    filterTo: t,
    filter: (i, s) => i >= t || s <= e
  }) : n;
}
function cm(n, e, t) {
  var r;
  let i = null;
  return (r = n.field(Ca, !1)) === null || r === void 0 || r.between(e, t, (s, o) => {
    (!i || i.from > s) && (i = { from: s, to: o });
  }), i;
}
function tH(n, e, t) {
  let r = !1;
  return n.between(e, e, (i, s) => {
    i == e && s == t && (r = !0);
  }), r;
}
function bM(n, e) {
  return n.field(Ca, !1) ? e : e.concat(Xe.appendConfig.of(xM()));
}
const nH = (n) => {
  for (let e of yM(n)) {
    let t = am(n.state, e.from, e.to);
    if (t)
      return n.dispatch({ effects: bM(n.state, [c1.of(t), vM(n, t)]) }), !0;
  }
  return !1;
}, rH = (n) => {
  if (!n.state.field(Ca, !1))
    return !1;
  let e = [];
  for (let t of yM(n)) {
    let r = cm(n.state, t.from, t.to);
    r && e.push(cd.of(r), vM(n, r, !1));
  }
  return e.length && n.dispatch({ effects: e }), e.length > 0;
};
function vM(n, e, t = !0) {
  let r = n.state.doc.lineAt(e.from).number, i = n.state.doc.lineAt(e.to).number;
  return Ce.announce.of(`${n.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${n.state.phrase("to")} ${i}.`);
}
const iH = (n) => {
  let { state: e } = n, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = n.lineBlockAt(r), s = am(e, i.from, i.to);
    s && t.push(c1.of(s)), r = (s ? n.lineBlockAt(s.to) : i).to + 1;
  }
  return t.length && n.dispatch({ effects: bM(n.state, t) }), !!t.length;
}, sH = (n) => {
  let e = n.state.field(Ca, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, n.state.doc.length, (r, i) => {
    t.push(cd.of({ from: r, to: i }));
  }), n.dispatch({ effects: t }), !0;
}, oH = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: nH },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: rH },
  { key: "Ctrl-Alt-[", run: iH },
  { key: "Ctrl-Alt-]", run: sH }
], lH = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, wM = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, lH);
  }
});
function xM(n) {
  return [Ca, hH];
}
function kM(n, e) {
  let { state: t } = n, r = t.facet(wM), i = (o) => {
    let l = n.lineBlockAt(n.posAtDOM(o.target)), a = cm(n.state, l.from, l.to);
    a && n.dispatch({ effects: cd.of(a) }), o.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(n, i, e);
  let s = document.createElement("span");
  return s.textContent = r.placeholderText, s.setAttribute("aria-label", t.phrase("folded code")), s.title = t.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
}
const Ow = /* @__PURE__ */ He.replace({ widget: /* @__PURE__ */ new class extends xo {
  toDOM(n) {
    return kM(n, null);
  }
}() });
class aH extends xo {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return kM(e, this.value);
  }
}
const cH = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class qg extends uo {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function uH(n = {}) {
  let e = { ...cH, ...n }, t = new qg(e, !0), r = new qg(e, !1), i = gn.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(fl) != o.state.facet(fl) || o.startState.field(Ca, !1) != o.state.field(Ca, !1) || Fn(o.startState) != Fn(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let l = new lo();
      for (let a of o.viewportLineBlocks) {
        let c = cm(o.state, a.from, a.to) ? r : am(o.state, a.from, a.to) ? t : null;
        c && l.add(a.from, a.from, c);
      }
      return l.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    i,
    bF({
      class: "cm-foldGutter",
      markers(o) {
        var l;
        return ((l = o.plugin(i)) === null || l === void 0 ? void 0 : l.markers) || ut.empty;
      },
      initialSpacer() {
        return new qg(e, !1);
      },
      domEventHandlers: {
        ...s,
        click: (o, l, a) => {
          if (s.click && s.click(o, l, a))
            return !0;
          let c = cm(o.state, l.from, l.to);
          if (c)
            return o.dispatch({ effects: cd.of(c) }), !0;
          let u = am(o.state, l.from, l.to);
          return u ? (o.dispatch({ effects: c1.of(u) }), !0) : !1;
        }
      }
    }),
    xM()
  ];
}
const hH = /* @__PURE__ */ Ce.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class ud {
  constructor(e, t) {
    this.specs = e;
    let r;
    function i(l) {
      let a = ul.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + a] = l, a;
    }
    const s = typeof t.all == "string" ? t.all : t.all ? i(t.all) : void 0, o = t.scope;
    this.scope = o instanceof ci ? (l) => l.prop(ea) == o.data : o ? (l) => l == o : void 0, this.style = uM(e.map((l) => ({
      tag: l.tag,
      class: l.class || i(Object.assign({}, l, { tag: null }))
    })), {
      all: s
    }).style, this.module = r ? new ul(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new ud(e, t || {});
  }
}
const py = /* @__PURE__ */ xe.define(), SM = /* @__PURE__ */ xe.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function Wg(n) {
  let e = n.facet(py);
  return e.length ? e : n.facet(SM);
}
function CM(n, e) {
  let t = [dH], r;
  return n instanceof ud && (n.module && t.push(Ce.styleModule.of(n.module)), r = n.themeType), e?.fallback ? t.push(SM.of(n)) : r ? t.push(py.computeN([Ce.darkTheme], (i) => i.facet(Ce.darkTheme) == (r == "dark") ? [n] : [])) : t.push(py.of(n)), t;
}
class fH {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Fn(e.state), this.decorations = this.buildDeco(e, Wg(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = Fn(e.state), r = Wg(e.state), i = r != Wg(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    t.length < s.to && !i && t.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (t != this.tree || e.viewportChanged || i) && (this.tree = t, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = s.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return He.none;
    let r = new lo();
    for (let { from: i, to: s } of e.visibleRanges)
      _F(this.tree, t, (o, l, a) => {
        r.add(o, l, this.markCache[a] || (this.markCache[a] = He.mark({ class: a })));
      }, i, s);
    return r.finish();
  }
}
const dH = /* @__PURE__ */ kl.high(/* @__PURE__ */ gn.fromClass(fH, {
  decorations: (n) => n.decorations
})), pH = /* @__PURE__ */ ud.define([
  {
    tag: U.meta,
    color: "#404740"
  },
  {
    tag: U.link,
    textDecoration: "underline"
  },
  {
    tag: U.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: U.emphasis,
    fontStyle: "italic"
  },
  {
    tag: U.strong,
    fontWeight: "bold"
  },
  {
    tag: U.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: U.keyword,
    color: "#708"
  },
  {
    tag: [U.atom, U.bool, U.url, U.contentSeparator, U.labelName],
    color: "#219"
  },
  {
    tag: [U.literal, U.inserted],
    color: "#164"
  },
  {
    tag: [U.string, U.deleted],
    color: "#a11"
  },
  {
    tag: [U.regexp, U.escape, /* @__PURE__ */ U.special(U.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ U.definition(U.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ U.local(U.variableName),
    color: "#30a"
  },
  {
    tag: [U.typeName, U.namespace],
    color: "#085"
  },
  {
    tag: U.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ U.special(U.variableName), U.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ U.definition(U.propertyName),
    color: "#00c"
  },
  {
    tag: U.comment,
    color: "#940"
  },
  {
    tag: U.invalid,
    color: "#f00"
  }
]), mH = /* @__PURE__ */ Ce.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), MM = 1e4, TM = "()[]{}", AM = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, {
      afterCursor: !0,
      brackets: TM,
      maxScanDistance: MM,
      renderMatch: bH
    });
  }
}), gH = /* @__PURE__ */ He.mark({ class: "cm-matchingBracket" }), yH = /* @__PURE__ */ He.mark({ class: "cm-nonmatchingBracket" });
function bH(n) {
  let e = [], t = n.matched ? gH : yH;
  return e.push(t.range(n.start.from, n.start.to)), n.end && e.push(t.range(n.end.from, n.end.to)), e;
}
const vH = /* @__PURE__ */ On.define({
  create() {
    return He.none;
  },
  update(n, e) {
    if (!e.docChanged && !e.selection)
      return n;
    let t = [], r = e.state.facet(AM);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = fs(e.state, i.head, -1, r) || i.head > 0 && fs(e.state, i.head - 1, 1, r) || r.afterCursor && (fs(e.state, i.head, 1, r) || i.head < e.state.doc.length && fs(e.state, i.head + 1, -1, r));
      s && (t = t.concat(r.renderMatch(s, e.state)));
    }
    return He.set(t, !0);
  },
  provide: (n) => Ce.decorations.from(n)
}), wH = [
  vH,
  mH
];
function xH(n = {}) {
  return [AM.of(n), wH];
}
const kH = /* @__PURE__ */ new st();
function my(n, e, t) {
  let r = n.prop(e < 0 ? st.openedBy : st.closedBy);
  if (r)
    return r;
  if (n.name.length == 1) {
    let i = t.indexOf(n.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [t[i + e]];
  }
  return null;
}
function gy(n) {
  let e = n.type.prop(kH);
  return e ? e(n.node) : n;
}
function fs(n, e, t, r = {}) {
  let i = r.maxScanDistance || MM, s = r.brackets || TM, o = Fn(n), l = o.resolveInner(e, t);
  for (let a = l; a; a = a.parent) {
    let c = my(a.type, t, s);
    if (c && a.from < a.to) {
      let u = gy(a);
      if (u && (t > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return SH(n, e, t, a, u, c, s);
    }
  }
  return CH(n, e, t, o, l.type, i, s);
}
function SH(n, e, t, r, i, s, o) {
  let l = r.parent, a = { from: i.from, to: i.to }, c = 0, u = l?.cursor();
  if (u && (t < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (t < 0 ? u.to <= r.from : u.from >= r.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let h = gy(u);
          return { start: a, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (my(u.type, t, o))
          c++;
        else if (my(u.type, -t, o)) {
          if (c == 0) {
            let h = gy(u);
            return {
              start: a,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? u.prevSibling() : u.nextSibling());
  return { start: a, matched: !1 };
}
function CH(n, e, t, r, i, s, o) {
  let l = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1), a = o.indexOf(l);
  if (a < 0 || a % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, u = n.doc.iterRange(e, t > 0 ? n.doc.length : 0), h = 0;
  for (let f = 0; !u.next().done && f <= s; ) {
    let d = u.value;
    t < 0 && (f += d.length);
    let p = e + f * t;
    for (let m = t > 0 ? 0 : d.length - 1, g = t > 0 ? d.length : -1; m != g; m += t) {
      let b = o.indexOf(d[m]);
      if (!(b < 0 || r.resolveInner(p + m, 1).type != i))
        if (b % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: c, end: { from: p + m, to: p + m + 1 }, matched: b >> 1 == a >> 1 };
          h--;
        }
    }
    t > 0 && (f += d.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
function Ew(n, e, t, r = 0, i = 0) {
  e == null && (e = n.search(/[^\s\u00a0]/), e == -1 && (e = n.length));
  let s = i;
  for (let o = r; o < e; o++)
    n.charCodeAt(o) == 9 ? s += t - s % t : s++;
  return s;
}
class OM {
  /**
  Create a stream.
  */
  constructor(e, t, r, i) {
    this.string = e, this.tabSize = t, this.indentUnit = r, this.overrideIndent = i, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(e) {
    let t = this.string.charAt(this.pos), r;
    if (typeof e == "string" ? r = t == e : r = t && (e instanceof RegExp ? e.test(t) : e(t)), r)
      return ++this.pos, t;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(e) {
    let t = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > t;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(e) {
    let t = this.string.indexOf(e, this.pos);
    if (t > -1)
      return this.pos = t, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(e) {
    this.pos -= e;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = Ew(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : Ew(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(e, t, r) {
    if (typeof e == "string") {
      let i = (o) => r ? o.toLowerCase() : o, s = this.string.substr(this.pos, e.length);
      return i(s) == i(e) ? (t !== !1 && (this.pos += e.length), !0) : null;
    } else {
      let i = this.string.slice(this.pos).match(e);
      return i && i.index > 0 ? null : (i && t !== !1 && (this.pos += i[0].length), i);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function MH(n) {
  return {
    name: n.name || "",
    token: n.token,
    blankLine: n.blankLine || (() => {
    }),
    startState: n.startState || (() => !0),
    copyState: n.copyState || TH,
    indent: n.indent || (() => null),
    languageData: n.languageData || {},
    tokenTable: n.tokenTable || T3,
    mergeTokens: n.mergeTokens !== !1
  };
}
function TH(n) {
  if (typeof n != "object")
    return n;
  let e = {};
  for (let t in n) {
    let r = n[t];
    e[t] = r instanceof Array ? r.slice() : r;
  }
  return e;
}
const Iw = /* @__PURE__ */ new WeakMap();
class C3 extends ci {
  constructor(e) {
    let t = hM(e.languageData), r = MH(e), i, s = new class extends NS {
      createParse(o, l, a) {
        return new OH(i, o, l, a);
      }
    }();
    super(t, s, [], e.name), this.topNode = DH(t, this), i = this, this.streamParser = r, this.stateAfter = new st({ perNode: !0 }), this.tokenTable = e.tokenTable ? new NM(r.tokenTable) : IH;
  }
  /**
  Define a stream language.
  */
  static define(e) {
    return new C3(e);
  }
  /**
  @internal
  */
  getIndent(e) {
    let t, { overrideIndentation: r } = e.options;
    r && (t = Iw.get(e.state), t != null && t < e.pos - 1e4 && (t = void 0));
    let i = M3(this, e.node.tree, e.node.from, e.node.from, t ?? e.pos), s, o;
    if (i ? (o = i.state, s = i.pos + 1) : (o = this.streamParser.startState(e.unit), s = e.node.from), e.pos - s > 1e4)
      return null;
    for (; s < e.pos; ) {
      let a = e.state.doc.lineAt(s), c = Math.min(e.pos, a.to);
      if (a.length) {
        let u = r ? r(a.from) : -1, h = new OM(a.text, e.state.tabSize, e.unit, u < 0 ? void 0 : u);
        for (; h.pos < c - a.from; )
          IM(this.streamParser.token, h, o);
      } else
        this.streamParser.blankLine(o, e.unit);
      if (c == e.pos)
        break;
      s = a.to + 1;
    }
    let l = e.lineAt(e.pos);
    return r && t == null && Iw.set(e.state, l.from), this.streamParser.indent(o, /^\s*(.*)/.exec(l.text)[1], e);
  }
  get allowsNesting() {
    return !1;
  }
}
function M3(n, e, t, r, i) {
  let s = t >= r && t + e.length <= i && e.prop(n.stateAfter);
  if (s)
    return { state: n.streamParser.copyState(s), pos: t + e.length };
  for (let o = e.children.length - 1; o >= 0; o--) {
    let l = e.children[o], a = t + e.positions[o], c = l instanceof Bt && a < i && M3(n, l, a, r, i);
    if (c)
      return c;
  }
  return null;
}
function EM(n, e, t, r, i) {
  if (i && t <= 0 && r >= e.length)
    return e;
  !i && t == 0 && e.type == n.topNode && (i = !0);
  for (let s = e.children.length - 1; s >= 0; s--) {
    let o = e.positions[s], l = e.children[s], a;
    if (o < r && l instanceof Bt) {
      if (!(a = EM(n, l, t - o, r - o, i)))
        break;
      return i ? new Bt(e.type, e.children.slice(0, s).concat(a), e.positions.slice(0, s + 1), o + a.length) : a;
    }
  }
  return null;
}
function AH(n, e, t, r, i) {
  for (let s of e) {
    let o = s.from + (s.openStart ? 25 : 0), l = s.to - (s.openEnd ? 25 : 0), a = o <= t && l > t && M3(n, s.tree, 0 - s.offset, t, l), c;
    if (a && a.pos <= r && (c = EM(n, s.tree, t + s.offset, a.pos + s.offset, !1)))
      return { state: a.state, tree: c };
  }
  return { state: n.streamParser.startState(i ? Sa(i) : 4), tree: Bt.empty };
}
class OH {
  constructor(e, t, r, i) {
    this.lang = e, this.input = t, this.fragments = r, this.ranges = i, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = i[i.length - 1].to;
    let s = fy.get(), o = i[0].from, { state: l, tree: a } = AH(e, r, o, this.to, s?.state);
    this.state = l, this.parsedPos = this.chunkStart = o + a.length;
    for (let c = 0; c < a.children.length; c++)
      this.chunks.push(a.children[c]), this.chunkPos.push(a.positions[c]);
    s && this.parsedPos < s.viewport.from - 1e5 && i.some((c) => c.from <= s.viewport.from && c.to >= s.viewport.from) && (this.state = this.lang.streamParser.startState(Sa(s.state)), s.skipUntilInView(this.parsedPos, s.viewport.from), this.parsedPos = s.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let e = fy.get(), t = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), r = Math.min(
      t,
      this.chunkStart + 512
      /* C.ChunkSize */
    );
    for (e && (r = Math.min(r, e.viewport.to)); this.parsedPos < r; )
      this.parseLine(e);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= t ? this.finish() : e && this.parsedPos >= e.viewport.to ? (e.skipUntilInView(this.parsedPos, t), this.finish()) : null;
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let t = this.input.chunk(e);
    if (this.input.lineChunks)
      t == `
` && (t = "");
    else {
      let r = t.indexOf(`
`);
      r > -1 && (t = t.slice(0, r));
    }
    return e + t.length <= this.to ? t : t.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos, t = this.lineAfter(e), r = e + t.length;
    for (let i = this.rangeIndex; ; ) {
      let s = this.ranges[i].to;
      if (s >= r || (t = t.slice(0, s - (r - t.length)), i++, i == this.ranges.length))
        break;
      let o = this.ranges[i].from, l = this.lineAfter(o);
      t += l, r = o + l.length;
    }
    return { line: t, end: r };
  }
  skipGapsTo(e, t, r) {
    for (; ; ) {
      let i = this.ranges[this.rangeIndex].to, s = e + t;
      if (r > 0 ? i > s : i >= s)
        break;
      let o = this.ranges[++this.rangeIndex].from;
      t += o - i;
    }
    return t;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(e, t, r, i) {
    let s = 4;
    if (this.ranges.length > 1) {
      i = this.skipGapsTo(t, i, 1), t += i;
      let l = this.chunk.length;
      i = this.skipGapsTo(r, i, -1), r += i, s += this.chunk.length - l;
    }
    let o = this.chunk.length - 4;
    return this.lang.streamParser.mergeTokens && s == 4 && o >= 0 && this.chunk[o] == e && this.chunk[o + 2] == t ? this.chunk[o + 2] = r : this.chunk.push(e, t, r, s), i;
  }
  parseLine(e) {
    let { line: t, end: r } = this.nextLine(), i = 0, { streamParser: s } = this.lang, o = new OM(t, e ? e.state.tabSize : 4, e ? Sa(e.state) : 2);
    if (o.eol())
      s.blankLine(this.state, o.indentUnit);
    else
      for (; !o.eol(); ) {
        let l = IM(s.token, o, this.state);
        if (l && (i = this.emitToken(this.lang.tokenTable.resolve(l), this.parsedPos + o.start, this.parsedPos + o.pos, i)), o.start > 1e4)
          break;
      }
    this.parsedPos = r, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = Bt.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: EH,
      topID: 0,
      maxBufferLength: 512,
      reused: this.chunkReused
    });
    e = new Bt(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(e), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new Bt(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}
function IM(n, e, t) {
  e.start = e.pos;
  for (let r = 0; r < 10; r++) {
    let i = n(e, t);
    if (e.pos > e.start)
      return i;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const T3 = /* @__PURE__ */ Object.create(null), Df = [Qr.none], EH = /* @__PURE__ */ new r3(Df), Dw = [], Nw = /* @__PURE__ */ Object.create(null), DM = /* @__PURE__ */ Object.create(null);
for (let [n, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  DM[n] = /* @__PURE__ */ RM(T3, e);
class NM {
  constructor(e) {
    this.extra = e, this.table = Object.assign(/* @__PURE__ */ Object.create(null), DM);
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = RM(this.extra, e)) : 0;
  }
}
const IH = /* @__PURE__ */ new NM(T3);
function jg(n, e) {
  Dw.indexOf(n) > -1 || (Dw.push(n), console.warn(e));
}
function RM(n, e) {
  let t = [];
  for (let l of e.split(" ")) {
    let a = [];
    for (let c of l.split(".")) {
      let u = n[c] || U[c];
      u ? typeof u == "function" ? a.length ? a = a.map(u) : jg(c, `Modifier ${c} used at start of tag`) : a.length ? jg(c, `Tag ${c} used as modifier`) : a = Array.isArray(u) ? u : [u] : jg(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of a)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + t.map((l) => l.id), s = Nw[i];
  if (s)
    return s.id;
  let o = Nw[i] = Qr.define({
    id: Df.length,
    name: r,
    props: [RF({ [r]: t })]
  });
  return Df.push(o), o.id;
}
function DH(n, e) {
  let t = Qr.define({ id: Df.length, name: "Document", props: [
    ea.add(() => n),
    dM.add(() => (r) => e.getIndent(r))
  ], top: !0 });
  return Df.push(t), t;
}
qt.RTL, qt.LTR;
function Z(n) {
  return new $F(C3.define(n));
}
function Eo(n) {
  return import("./index-BNOs9yxi.js").then((e) => e.sql({ dialect: e[n] }));
}
const NH = [
  // New-style language modes
  /* @__PURE__ */ q.of({
    name: "C",
    extensions: ["c", "h", "ino"],
    load() {
      return import("./index-BYAKAtss.js").then((n) => n.cpp());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "C++",
    alias: ["cpp"],
    extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
    load() {
      return import("./index-BYAKAtss.js").then((n) => n.cpp());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CQL",
    alias: ["cassandra"],
    extensions: ["cql"],
    load() {
      return Eo("Cassandra");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CSS",
    extensions: ["css"],
    load() {
      return import("./index-CJbA1RwZ.js").then((n) => n.css());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Go",
    extensions: ["go"],
    load() {
      return import("./index-BFU2qa2J.js").then((n) => n.go());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "HTML",
    alias: ["xhtml"],
    extensions: ["html", "htm", "handlebars", "hbs"],
    load() {
      return import("./index-BHH_j45W.js").then((n) => n.html());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Java",
    extensions: ["java"],
    load() {
      return import("./index-CHCzEACO.js").then((n) => n.java());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JavaScript",
    alias: ["ecmascript", "js", "node"],
    extensions: ["js", "mjs", "cjs"],
    load() {
      return import("./index-CeW_LBF4.js").then((n) => n.javascript());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JSON",
    alias: ["json5"],
    extensions: ["json", "map"],
    load() {
      return import("./index-2pAQnQCc.js").then((n) => n.json());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JSX",
    extensions: ["jsx"],
    load() {
      return import("./index-CeW_LBF4.js").then((n) => n.javascript({ jsx: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "LESS",
    extensions: ["less"],
    load() {
      return import("./index-aFC-o3EP.js").then((n) => n.less());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Liquid",
    extensions: ["liquid"],
    load() {
      return import("./index-BQjabgfk.js").then((n) => n.liquid());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MariaDB SQL",
    load() {
      return Eo("MariaSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Markdown",
    extensions: ["md", "markdown", "mkd"],
    load() {
      return import("./index-D1ZBqb5K.js").then((n) => n.markdown());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MS SQL",
    load() {
      return Eo("MSSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MySQL",
    load() {
      return Eo("MySQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PHP",
    extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
    load() {
      return import("./index-Bd3BEyW3.js").then((n) => n.php());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PLSQL",
    extensions: ["pls"],
    load() {
      return Eo("PLSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PostgreSQL",
    load() {
      return Eo("PostgreSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Python",
    extensions: ["BUILD", "bzl", "py", "pyw"],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return import("./index-CBJPbwZL.js").then((n) => n.python());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Rust",
    extensions: ["rs"],
    load() {
      return import("./index-DWzI_wQw.js").then((n) => n.rust());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Sass",
    extensions: ["sass"],
    load() {
      return import("./index-EIRdS8Y6.js").then((n) => n.sass({ indented: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SCSS",
    extensions: ["scss"],
    load() {
      return import("./index-EIRdS8Y6.js").then((n) => n.sass());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SQL",
    extensions: ["sql"],
    load() {
      return Eo("StandardSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SQLite",
    load() {
      return Eo("SQLite");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TSX",
    extensions: ["tsx"],
    load() {
      return import("./index-CeW_LBF4.js").then((n) => n.javascript({ jsx: !0, typescript: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TypeScript",
    alias: ["ts"],
    extensions: ["ts", "mts", "cts"],
    load() {
      return import("./index-CeW_LBF4.js").then((n) => n.javascript({ typescript: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "WebAssembly",
    extensions: ["wat", "wast"],
    load() {
      return import("./index-DNaomUNK.js").then((n) => n.wast());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "XML",
    alias: ["rss", "wsdl", "xsd"],
    extensions: ["xml", "xsl", "xsd", "svg"],
    load() {
      return import("./index-BBcPDlzF.js").then((n) => n.xml());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "YAML",
    alias: ["yml"],
    extensions: ["yaml", "yml"],
    load() {
      return import("./index-Dfxq3vs4.js").then((n) => n.yaml());
    }
  }),
  // Legacy modes ported from CodeMirror 5
  /* @__PURE__ */ q.of({
    name: "APL",
    extensions: ["dyalog", "apl"],
    load() {
      return import("./apl-B2DGVGxc.js").then((n) => Z(n.apl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PGP",
    alias: ["asciiarmor"],
    extensions: ["asc", "pgp", "sig"],
    load() {
      return import("./asciiarmor-2LVJmxlE.js").then((n) => Z(n.asciiArmor));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ASN.1",
    extensions: ["asn", "asn1"],
    load() {
      return import("./asn1-jKiBa2Ya.js").then((n) => Z(n.asn1({})));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Asterisk",
    filename: /^extensions\.conf$/i,
    load() {
      return import("./asterisk-DS281yxp.js").then((n) => Z(n.asterisk));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Brainfuck",
    extensions: ["b", "bf"],
    load() {
      return import("./brainfuck-C_p9pTT8.js").then((n) => Z(n.brainfuck));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Cobol",
    extensions: ["cob", "cpy"],
    load() {
      return import("./cobol-BlTKFDRj.js").then((n) => Z(n.cobol));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "C#",
    alias: ["csharp", "cs"],
    extensions: ["cs"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.csharp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Clojure",
    extensions: ["clj", "cljc", "cljx"],
    load() {
      return import("./clojure-CCKyeQKf.js").then((n) => Z(n.clojure));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ClojureScript",
    extensions: ["cljs"],
    load() {
      return import("./clojure-CCKyeQKf.js").then((n) => Z(n.clojure));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Closure Stylesheets (GSS)",
    extensions: ["gss"],
    load() {
      return import("./css-BkF-NPzE.js").then((n) => Z(n.gss));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CMake",
    extensions: ["cmake", "cmake.in"],
    filename: /^CMakeLists\.txt$/,
    load() {
      return import("./cmake-CuaCgAKt.js").then((n) => Z(n.cmake));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CoffeeScript",
    alias: ["coffee", "coffee-script"],
    extensions: ["coffee"],
    load() {
      return import("./coffeescript-BVCvwO8I.js").then((n) => Z(n.coffeeScript));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Common Lisp",
    alias: ["lisp"],
    extensions: ["cl", "lisp", "el"],
    load() {
      return import("./commonlisp-D_kxz07b.js").then((n) => Z(n.commonLisp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Cypher",
    extensions: ["cyp", "cypher"],
    load() {
      return import("./cypher-BMq4Fwjl.js").then((n) => Z(n.cypher));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Cython",
    extensions: ["pyx", "pxd", "pxi"],
    load() {
      return import("./python-BkR3uSy8.js").then((n) => Z(n.cython));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Crystal",
    extensions: ["cr"],
    load() {
      return import("./crystal-D309uH6_.js").then((n) => Z(n.crystal));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "D",
    extensions: ["d"],
    load() {
      return import("./d-BZcgY6La.js").then((n) => Z(n.d));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Dart",
    extensions: ["dart"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.dart));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "diff",
    extensions: ["diff", "patch"],
    load() {
      return import("./diff-Cg9d_RX2.js").then((n) => Z(n.diff));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Dockerfile",
    filename: /^Dockerfile$/,
    load() {
      return import("./dockerfile-DIy8NleC.js").then((n) => Z(n.dockerFile));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "DTD",
    extensions: ["dtd"],
    load() {
      return import("./dtd-CtLokQ-U.js").then((n) => Z(n.dtd));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Dylan",
    extensions: ["dylan", "dyl", "intr"],
    load() {
      return import("./dylan-QYeExnWK.js").then((n) => Z(n.dylan));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "EBNF",
    load() {
      return import("./ebnf-DUPDuY4r.js").then((n) => Z(n.ebnf));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ECL",
    extensions: ["ecl"],
    load() {
      return import("./ecl-CiXN-g_D.js").then((n) => Z(n.ecl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "edn",
    extensions: ["edn"],
    load() {
      return import("./clojure-CCKyeQKf.js").then((n) => Z(n.clojure));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Eiffel",
    extensions: ["e"],
    load() {
      return import("./eiffel-yQhjl4T1.js").then((n) => Z(n.eiffel));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Elm",
    extensions: ["elm"],
    load() {
      return import("./elm-CNT9vbN0.js").then((n) => Z(n.elm));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Erlang",
    extensions: ["erl"],
    load() {
      return import("./erlang-CFOYdy9e.js").then((n) => Z(n.erlang));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Esper",
    load() {
      return import("./sql-CfG5lQ3l.js").then((n) => Z(n.esper));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Factor",
    extensions: ["factor"],
    load() {
      return import("./factor-DDOC7X6P.js").then((n) => Z(n.factor));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "FCL",
    load() {
      return import("./fcl-CPC2WYrI.js").then((n) => Z(n.fcl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Forth",
    extensions: ["forth", "fth", "4th"],
    load() {
      return import("./forth-BmxRyE9S.js").then((n) => Z(n.forth));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Fortran",
    extensions: ["f", "for", "f77", "f90", "f95"],
    load() {
      return import("./fortran-9bvPyrOW.js").then((n) => Z(n.fortran));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "F#",
    alias: ["fsharp"],
    extensions: ["fs"],
    load() {
      return import("./mllike-BSnXJBGA.js").then((n) => Z(n.fSharp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Gas",
    extensions: ["s"],
    load() {
      return import("./gas-cpmYfFX2.js").then((n) => Z(n.gas));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Gherkin",
    extensions: ["feature"],
    load() {
      return import("./gherkin-CJuwpceU.js").then((n) => Z(n.gherkin));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Groovy",
    extensions: ["groovy", "gradle"],
    filename: /^Jenkinsfile$/,
    load() {
      return import("./groovy-DZeT_VM-.js").then((n) => Z(n.groovy));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Haskell",
    extensions: ["hs"],
    load() {
      return import("./haskell-CxiO_7JL.js").then((n) => Z(n.haskell));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Haxe",
    extensions: ["hx"],
    load() {
      return import("./haxe-70NVW1pR.js").then((n) => Z(n.haxe));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "HXML",
    extensions: ["hxml"],
    load() {
      return import("./haxe-70NVW1pR.js").then((n) => Z(n.hxml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "HTTP",
    load() {
      return import("./http-D9LttvKF.js").then((n) => Z(n.http));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "IDL",
    extensions: ["pro"],
    load() {
      return import("./idl-B6TRFYjl.js").then((n) => Z(n.idl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JSON-LD",
    alias: ["jsonld"],
    extensions: ["jsonld"],
    load() {
      return import("./javascript-DOuB9oqA.js").then((n) => Z(n.jsonld));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Jinja2",
    extensions: ["j2", "jinja", "jinja2"],
    load() {
      return import("./jinja2-DnB6dQmV.js").then((n) => Z(n.jinja2));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Julia",
    extensions: ["jl"],
    load() {
      return import("./julia-DpvXAuO6.js").then((n) => Z(n.julia));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Kotlin",
    extensions: ["kt", "kts"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.kotlin));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "LiveScript",
    alias: ["ls"],
    extensions: ["ls"],
    load() {
      return import("./livescript-CanGTf8u.js").then((n) => Z(n.liveScript));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Lua",
    extensions: ["lua"],
    load() {
      return import("./lua-XplVlWi_.js").then((n) => Z(n.lua));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "mIRC",
    extensions: ["mrc"],
    load() {
      return import("./mirc-CFBPAOaF.js").then((n) => Z(n.mirc));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Mathematica",
    extensions: ["m", "nb", "wl", "wls"],
    load() {
      return import("./mathematica-jaRHnSxC.js").then((n) => Z(n.mathematica));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Modelica",
    extensions: ["mo"],
    load() {
      return import("./modelica-vUgVs--1.js").then((n) => Z(n.modelica));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MUMPS",
    extensions: ["mps"],
    load() {
      return import("./mumps-CQoS1kWX.js").then((n) => Z(n.mumps));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Mbox",
    extensions: ["mbox"],
    load() {
      return import("./mbox-BctzC1hL.js").then((n) => Z(n.mbox));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Nginx",
    filename: /nginx.*\.conf$/i,
    load() {
      return import("./nginx-zDPm3Z74.js").then((n) => Z(n.nginx));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "NSIS",
    extensions: ["nsh", "nsi"],
    load() {
      return import("./nsis-fePjrhq7.js").then((n) => Z(n.nsis));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "NTriples",
    extensions: ["nt", "nq"],
    load() {
      return import("./ntriples-CsNjv2QF.js").then((n) => Z(n.ntriples));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Objective-C",
    alias: ["objective-c", "objc"],
    extensions: ["m"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.objectiveC));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Objective-C++",
    alias: ["objective-c++", "objc++"],
    extensions: ["mm"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.objectiveCpp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "OCaml",
    extensions: ["ml", "mli", "mll", "mly"],
    load() {
      return import("./mllike-BSnXJBGA.js").then((n) => Z(n.oCaml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Octave",
    extensions: ["m"],
    load() {
      return import("./octave-C8PmmSRH.js").then((n) => Z(n.octave));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Oz",
    extensions: ["oz"],
    load() {
      return import("./oz-Ce8aN8oE.js").then((n) => Z(n.oz));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Pascal",
    extensions: ["p", "pas"],
    load() {
      return import("./pascal-De0D6mP7.js").then((n) => Z(n.pascal));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Perl",
    extensions: ["pl", "pm"],
    load() {
      return import("./perl-B4bSCe1C.js").then((n) => Z(n.perl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Pig",
    extensions: ["pig"],
    load() {
      return import("./pig-D24Z8EXi.js").then((n) => Z(n.pig));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PowerShell",
    extensions: ["ps1", "psd1", "psm1"],
    load() {
      return import("./powershell-DkYVfTzP.js").then((n) => Z(n.powerShell));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Properties files",
    alias: ["ini", "properties"],
    extensions: ["properties", "ini", "in"],
    load() {
      return import("./properties-Dn9wna3M.js").then((n) => Z(n.properties));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ProtoBuf",
    extensions: ["proto"],
    load() {
      return import("./protobuf-BPIjwpzm.js").then((n) => Z(n.protobuf));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Pug",
    alias: ["jade"],
    extensions: ["pug", "jade"],
    load() {
      return import("./pug-TGXr6c5j.js").then((n) => Z(n.pug));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Puppet",
    extensions: ["pp"],
    load() {
      return import("./puppet-nyd4dhjf.js").then((n) => Z(n.puppet));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Q",
    extensions: ["q"],
    load() {
      return import("./q-DXjKs-tC.js").then((n) => Z(n.q));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "R",
    alias: ["rscript"],
    extensions: ["r", "R"],
    load() {
      return import("./r-LKEuhEGI.js").then((n) => Z(n.r));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "RPM Changes",
    load() {
      return import("./rpm-IznJm2Xc.js").then((n) => Z(n.rpmChanges));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "RPM Spec",
    extensions: ["spec"],
    load() {
      return import("./rpm-IznJm2Xc.js").then((n) => Z(n.rpmSpec));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Ruby",
    alias: ["jruby", "macruby", "rake", "rb", "rbx"],
    extensions: ["rb"],
    filename: /^(Gemfile|Rakefile)$/,
    load() {
      return import("./ruby-CcYfvIk6.js").then((n) => Z(n.ruby));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SAS",
    extensions: ["sas"],
    load() {
      return import("./sas-7E8yHoCW.js").then((n) => Z(n.sas));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Scala",
    extensions: ["scala"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.scala));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Scheme",
    extensions: ["scm", "ss"],
    load() {
      return import("./scheme-DjibxsNh.js").then((n) => Z(n.scheme));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Shell",
    alias: ["bash", "sh", "zsh"],
    extensions: ["sh", "ksh", "bash"],
    filename: /^PKGBUILD$/,
    load() {
      return import("./shell-C0C2sNA_.js").then((n) => Z(n.shell));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Sieve",
    extensions: ["siv", "sieve"],
    load() {
      return import("./sieve-Bwz7vjP5.js").then((n) => Z(n.sieve));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Smalltalk",
    extensions: ["st"],
    load() {
      return import("./smalltalk-Bhddl2pB.js").then((n) => Z(n.smalltalk));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Solr",
    load() {
      return import("./solr-BNlsLglM.js").then((n) => Z(n.solr));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SML",
    extensions: ["sml", "sig", "fun", "smackspec"],
    load() {
      return import("./mllike-BSnXJBGA.js").then((n) => Z(n.sml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SPARQL",
    alias: ["sparul"],
    extensions: ["rq", "sparql"],
    load() {
      return import("./sparql-FarWu_Gb.js").then((n) => Z(n.sparql));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Spreadsheet",
    alias: ["excel", "formula"],
    load() {
      return import("./spreadsheet-C-cy4P5N.js").then((n) => Z(n.spreadsheet));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Squirrel",
    extensions: ["nut"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.squirrel));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Stylus",
    extensions: ["styl"],
    load() {
      return import("./stylus-CAdqWld3.js").then((n) => Z(n.stylus));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Swift",
    extensions: ["swift"],
    load() {
      return import("./swift-DSxqR9R6.js").then((n) => Z(n.swift));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "sTeX",
    load() {
      return import("./stex-Du4h4KAU.js").then((n) => Z(n.stex));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "LaTeX",
    alias: ["tex"],
    extensions: ["text", "ltx", "tex"],
    load() {
      return import("./stex-Du4h4KAU.js").then((n) => Z(n.stex));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SystemVerilog",
    extensions: ["v", "sv", "svh"],
    load() {
      return import("./verilog-CiS1jyi5.js").then((n) => Z(n.verilog));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Tcl",
    extensions: ["tcl"],
    load() {
      return import("./tcl-xfoLljhY.js").then((n) => Z(n.tcl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Textile",
    extensions: ["textile"],
    load() {
      return import("./textile-D1AWE-pc.js").then((n) => Z(n.textile));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TiddlyWiki",
    load() {
      return import("./tiddlywiki-5wqsXtSk.js").then((n) => Z(n.tiddlyWiki));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Tiki wiki",
    load() {
      return import("./tiki-__Kn3CeS.js").then((n) => Z(n.tiki));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TOML",
    extensions: ["toml"],
    load() {
      return import("./toml-BHiuTcfn.js").then((n) => Z(n.toml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Troff",
    extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    load() {
      return import("./troff-D2UO-fKf.js").then((n) => Z(n.troff));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TTCN",
    extensions: ["ttcn", "ttcn3", "ttcnpp"],
    load() {
      return import("./ttcn-Bsa4sfRm.js").then((n) => Z(n.ttcn));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TTCN_CFG",
    extensions: ["cfg"],
    load() {
      return import("./ttcn-cfg-Bac_acMi.js").then((n) => Z(n.ttcnCfg));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Turtle",
    extensions: ["ttl"],
    load() {
      return import("./turtle-xwJUxoPV.js").then((n) => Z(n.turtle));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Web IDL",
    extensions: ["webidl"],
    load() {
      return import("./webidl-CjfDENEo.js").then((n) => Z(n.webIDL));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "VB.NET",
    extensions: ["vb"],
    load() {
      return import("./vb-c2kQGd6-.js").then((n) => Z(n.vb));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "VBScript",
    extensions: ["vbs"],
    load() {
      return import("./vbscript-1f_Dhg5H.js").then((n) => Z(n.vbScript));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Velocity",
    extensions: ["vtl"],
    load() {
      return import("./velocity-DJd0pTTC.js").then((n) => Z(n.velocity));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Verilog",
    extensions: ["v"],
    load() {
      return import("./verilog-CiS1jyi5.js").then((n) => Z(n.verilog));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "VHDL",
    extensions: ["vhd", "vhdl"],
    load() {
      return import("./vhdl-T9HkrbI2.js").then((n) => Z(n.vhdl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "XQuery",
    extensions: ["xy", "xquery"],
    load() {
      return import("./xquery-Ct6lEb4B.js").then((n) => Z(n.xQuery));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Yacas",
    extensions: ["ys"],
    load() {
      return import("./yacas-C0absKBh.js").then((n) => Z(n.yacas));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Z80",
    extensions: ["z80"],
    load() {
      return import("./z80-Pki2zAjW.js").then((n) => Z(n.z80));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MscGen",
    extensions: ["mscgen", "mscin", "msc"],
    load() {
      return import("./mscgen-Cpl0NYLN.js").then((n) => Z(n.mscgen));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Xù",
    extensions: ["xu"],
    load() {
      return import("./mscgen-Cpl0NYLN.js").then((n) => Z(n.xu));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MsGenny",
    extensions: ["msgenny"],
    load() {
      return import("./mscgen-Cpl0NYLN.js").then((n) => Z(n.msgenny));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Vue",
    extensions: ["vue"],
    load() {
      return import("./index-Pp-0rdir.js").then((n) => n.vue());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Angular Template",
    load() {
      return import("./index-hw0oYJvg.js").then((n) => n.angular());
    }
  })
], RH = "#e5c07b", Rw = "#e06c75", PH = "#56b6c2", _H = "#ffffff", tp = "#abb2bf", yy = "#7d8799", LH = "#61afef", BH = "#98c379", Pw = "#d19a66", zH = "#c678dd", FH = "#21252b", _w = "#2c313a", Lw = "#282c34", Ug = "#353a42", HH = "#3E4451", Bw = "#528bff", $H = /* @__PURE__ */ Ce.theme({
  "&": {
    color: tp,
    backgroundColor: Lw
  },
  ".cm-content": {
    caretColor: Bw
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: Bw },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: HH },
  ".cm-panels": { backgroundColor: FH, color: tp },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: Lw,
    color: yy,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: _w
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: Ug
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Ug,
    borderBottomColor: Ug
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: _w,
      color: tp
    }
  }
}, { dark: !0 }), VH = /* @__PURE__ */ ud.define([
  {
    tag: U.keyword,
    color: zH
  },
  {
    tag: [U.name, U.deleted, U.character, U.propertyName, U.macroName],
    color: Rw
  },
  {
    tag: [/* @__PURE__ */ U.function(U.variableName), U.labelName],
    color: LH
  },
  {
    tag: [U.color, /* @__PURE__ */ U.constant(U.name), /* @__PURE__ */ U.standard(U.name)],
    color: Pw
  },
  {
    tag: [/* @__PURE__ */ U.definition(U.name), U.separator],
    color: tp
  },
  {
    tag: [U.typeName, U.className, U.number, U.changed, U.annotation, U.modifier, U.self, U.namespace],
    color: RH
  },
  {
    tag: [U.operator, U.operatorKeyword, U.url, U.escape, U.regexp, U.link, /* @__PURE__ */ U.special(U.string)],
    color: PH
  },
  {
    tag: [U.meta, U.comment],
    color: yy
  },
  {
    tag: U.strong,
    fontWeight: "bold"
  },
  {
    tag: U.emphasis,
    fontStyle: "italic"
  },
  {
    tag: U.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: U.link,
    color: yy,
    textDecoration: "underline"
  },
  {
    tag: U.heading,
    fontWeight: "bold",
    color: Rw
  },
  {
    tag: [U.atom, U.bool, /* @__PURE__ */ U.special(U.variableName)],
    color: Pw
  },
  {
    tag: [U.processingInstruction, U.string, U.inserted],
    color: BH
  },
  {
    tag: U.invalid,
    color: _H
  }
]), qH = [$H, /* @__PURE__ */ CM(VH)];
function Nn(n) {
  this.content = n;
}
Nn.prototype = {
  constructor: Nn,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(n, e, t) {
    var r = t && t != n ? this.remove(t) : this, i = r.find(n), s = r.content.slice();
    return i == -1 ? s.push(t || n, e) : (s[i + 1] = e, t && (s[i] = t)), new Nn(s);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(n) {
    var e = this.find(n);
    if (e == -1) return this;
    var t = this.content.slice();
    return t.splice(e, 2), new Nn(t);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(n, e) {
    return new Nn([n, e].concat(this.remove(n).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new Nn(t);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(n, e, t) {
    var r = this.remove(e), i = r.content.slice(), s = r.find(n);
    return i.splice(s == -1 ? i.length : s, 0, e, t), new Nn(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(n) {
    return n = Nn.from(n), n.size ? new Nn(n.content.concat(this.subtract(n).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(n) {
    return n = Nn.from(n), n.size ? new Nn(this.subtract(n).content.concat(n.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(n) {
    var e = this;
    n = Nn.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Nn.from = function(n) {
  if (n instanceof Nn) return n;
  var e = [];
  if (n) for (var t in n) e.push(t, n[t]);
  return new Nn(e);
};
function PM(n, e, t) {
  for (let r = 0; ; r++) {
    if (r == n.childCount || r == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let i = n.child(r), s = e.child(r);
    if (i == s) {
      t += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return t;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        t++;
      return t;
    }
    if (i.content.size || s.content.size) {
      let o = PM(i.content, s.content, t + 1);
      if (o != null)
        return o;
    }
    t += i.nodeSize;
  }
}
function _M(n, e, t, r) {
  for (let i = n.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: t, b: r };
    let o = n.child(--i), l = e.child(--s), a = o.nodeSize;
    if (o == l) {
      t -= a, r -= a;
      continue;
    }
    if (!o.sameMarkup(l))
      return { a: t, b: r };
    if (o.isText && o.text != l.text) {
      let c = 0, u = Math.min(o.text.length, l.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == l.text[l.text.length - c - 1]; )
        c++, t--, r--;
      return { a: t, b: r };
    }
    if (o.content.size || l.content.size) {
      let c = _M(o.content, l.content, t - 1, r - 1);
      if (c)
        return c;
    }
    t -= a, r -= a;
  }
}
let ce = class rr {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, r, i = 0, s) {
    for (let o = 0, l = 0; l < t; o++) {
      let a = this.content[o], c = l + a.nodeSize;
      if (c > e && r(a, i + l, s || null, o) !== !1 && a.content.size) {
        let u = l + 1;
        a.nodesBetween(Math.max(0, e - u), Math.min(a.content.size, t - u), r, i + u);
      }
      l = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, t, (l, a) => {
      let c = l.isText ? l.text.slice(Math.max(e, a) - a, t - a) : l.isLeaf ? i ? typeof i == "function" ? i(l) : i : l.type.spec.leafText ? l.type.spec.leafText(l) : "" : "";
      l.isBlock && (l.isLeaf && c || l.isTextblock) && r && (o ? o = !1 : s += r), s += c;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new rr(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let r = [], i = 0;
    if (t > e)
      for (let s = 0, o = 0; o < t; s++) {
        let l = this.content[s], a = o + l.nodeSize;
        a > e && ((o < e || a > t) && (l.isText ? l = l.cut(Math.max(0, e - o), Math.min(l.text.length, t - o)) : l = l.cut(Math.max(0, e - o - 1), Math.min(l.content.size, t - o - 1))), r.push(l), i += l.nodeSize), o = a;
      }
    return new rr(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? rr.empty : e == 0 && t == this.content.length ? this : new rr(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let r = this.content[e];
    if (r == t)
      return this;
    let i = this.content.slice(), s = this.size + t.nodeSize - r.nodeSize;
    return i[e] = t, new rr(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new rr([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new rr(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, r = 0; t < this.content.length; t++) {
      let i = this.content[t];
      e(i, r, t), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return PM(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, r = e.size) {
    return _M(this, e, t, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return u0(0, e);
    if (e == this.size)
      return u0(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let t = 0, r = 0; ; t++) {
      let i = this.child(t), s = r + i.nodeSize;
      if (s >= e)
        return s == e ? u0(t + 1, s) : u0(t, r);
      r = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return rr.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new rr(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return rr.empty;
    let t, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (t || (t = e.slice(0, i)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
    }
    return new rr(t || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return rr.empty;
    if (e instanceof rr)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new rr([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
ce.empty = new ce([], 0);
const Kg = { index: 0, offset: 0 };
function u0(n, e) {
  return Kg.index = n, Kg.offset = e, Kg;
}
function um(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let r = 0; r < n.length; r++)
      if (!um(n[r], e[r]))
        return !1;
  } else {
    for (let r in n)
      if (!(r in e) || !um(n[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in n))
        return !1;
  }
  return !0;
}
class nt {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        t || (t = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !r && s.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(s);
      }
    }
    return t || (t = e.slice()), r || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && um(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[t.type];
    if (!r)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    let i = r.create(t.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(t[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return nt.none;
    if (e instanceof nt)
      return [e];
    let t = e.slice();
    return t.sort((r, i) => r.type.rank - i.type.rank), t;
  }
}
nt.none = [];
class hm extends Error {
}
let be = class ec {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, r) {
    this.content = e, this.openStart = t, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let r = BM(this.content, e + this.openStart, t);
    return r && new ec(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new ec(LM(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return ec.empty;
    let r = t.openStart || 0, i = t.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new ec(ce.fromJSON(e, t.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new ec(e, r, i);
  }
};
be.empty = new be(ce.empty, 0, 0);
function LM(n, e, t) {
  let { index: r, offset: i } = n.findIndex(e), s = n.maybeChild(r), { index: o, offset: l } = n.findIndex(t);
  if (i == e || s.isText) {
    if (l != t && !n.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(r, s.copy(LM(s.content, e - i - 1, t - i - 1)));
}
function BM(n, e, t, r) {
  let { index: i, offset: s } = n.findIndex(e), o = n.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, t) ? null : n.cut(0, e).append(t).append(n.cut(e));
  let l = BM(o.content, e - s - 1, t, o);
  return l && n.replaceChild(i, o.copy(l));
}
function WH(n, e, t) {
  if (t.openStart > n.depth)
    throw new hm("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new hm("Inconsistent open depths");
  return zM(n, e, t, 0);
}
function zM(n, e, t, r) {
  let i = n.index(r), s = n.node(r);
  if (i == e.index(r) && r < n.depth - t.openStart) {
    let o = zM(n, e, t, r + 1);
    return s.copy(s.content.replaceChild(i, o));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) {
      let o = n.parent, l = o.content;
      return la(o, l.cut(0, n.parentOffset).append(t.content).append(l.cut(e.parentOffset)));
    } else {
      let { start: o, end: l } = jH(t, n);
      return la(s, HM(n, o, l, e, r));
    }
  else return la(s, fm(n, e, r));
}
function FM(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new hm("Cannot join " + e.type.name + " onto " + n.type.name);
}
function by(n, e, t) {
  let r = n.node(t);
  return FM(r, e.node(t)), r;
}
function oa(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function Vh(n, e, t, r) {
  let i = (e || n).node(t), s = 0, o = e ? e.index(t) : i.childCount;
  n && (s = n.index(t), n.depth > t ? s++ : n.textOffset && (oa(n.nodeAfter, r), s++));
  for (let l = s; l < o; l++)
    oa(i.child(l), r);
  e && e.depth == t && e.textOffset && oa(e.nodeBefore, r);
}
function la(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function HM(n, e, t, r, i) {
  let s = n.depth > i && by(n, e, i + 1), o = r.depth > i && by(t, r, i + 1), l = [];
  return Vh(null, n, i, l), s && o && e.index(i) == t.index(i) ? (FM(s, o), oa(la(s, HM(n, e, t, r, i + 1)), l)) : (s && oa(la(s, fm(n, e, i + 1)), l), Vh(e, t, i, l), o && oa(la(o, fm(t, r, i + 1)), l)), Vh(r, null, i, l), new ce(l);
}
function fm(n, e, t) {
  let r = [];
  if (Vh(null, n, t, r), n.depth > t) {
    let i = by(n, e, t + 1);
    oa(la(i, fm(n, e, t + 1)), r);
  }
  return Vh(e, null, t, r), new ce(r);
}
function jH(n, e) {
  let t = e.depth - n.openStart, i = e.node(t).copy(n.content);
  for (let s = t - 1; s >= 0; s--)
    i = e.node(s).copy(ce.from(i));
  return {
    start: i.resolveNoCache(n.openStart + t),
    end: i.resolveNoCache(i.content.size - n.openEnd - t)
  };
}
class Nf {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(t);
    return r ? e.child(t).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += r.child(s).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return nt.none;
    if (this.textOffset)
      return e.child(t).marks;
    let r = e.maybeChild(t - 1), i = e.maybeChild(t);
    if (!r) {
      let l = r;
      r = i, i = l;
    }
    let s = r.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let r = t.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!t || t(this.node(r))))
        return new $M(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let r = [], i = 0, s = t;
    for (let o = e; ; ) {
      let { index: l, offset: a } = o.content.findIndex(s), c = s - a;
      if (r.push(o, l, i + a), !c || (o = o.child(l), o.isText))
        break;
      s = c - 1, i += a + 1;
    }
    return new Nf(t, r, s);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    let r = zw.get(e);
    if (r)
      for (let s = 0; s < r.elts.length; s++) {
        let o = r.elts[s];
        if (o.pos == t)
          return o;
      }
    else
      zw.set(e, r = new UH());
    let i = r.elts[r.i] = Nf.resolve(e, t);
    return r.i = (r.i + 1) % KH, i;
  }
}
class UH {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const KH = 12, zw = /* @__PURE__ */ new WeakMap();
class $M {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const GH = /* @__PURE__ */ Object.create(null);
let ro = class vy {
  /**
  @internal
  */
  constructor(e, t, r, i = nt.none) {
    this.type = e, this.attrs = t, this.marks = i, this.content = r || ce.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, r, i = 0) {
    this.content.nodesBetween(e, t, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, t, r, i) {
    return this.content.textBetween(e, t, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, r) {
    return this.type == e && um(this.attrs, t || e.defaultAttrs || GH) && nt.sameSet(this.marks, r || nt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new vy(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new vy(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, r = !1) {
    if (e == t)
      return be.empty;
    let i = this.resolve(e), s = this.resolve(t), o = r ? 0 : i.sharedDepth(t), l = i.start(o), c = i.node(o).content.cut(i.pos - l, s.pos - l);
    return new be(c, i.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, r) {
    return WH(this.resolve(e), this.resolve(t), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: r, offset: i } = t.content.findIndex(e);
      if (t = t.maybeChild(r), !t)
        return null;
      if (i == e || t.isText)
        return t;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(t), index: t, offset: r };
    let i = this.content.child(t - 1);
    return { node: i, index: t - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Nf.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Nf.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, r) {
    let i = !1;
    return t > e && this.nodesBetween(e, t, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), VM(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, r = ce.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s), l = o && o.matchFragment(this.content, t);
    if (!l || !l.validEnd)
      return !1;
    for (let a = i; a < s; a++)
      if (!this.type.allowsMarks(r.child(a).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, t);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = nt.none;
    for (let t = 0; t < this.marks.length; t++) {
      let r = this.marks[t];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!nt.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, r);
    }
    let i = ce.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, i, r);
    return s.type.checkAttrs(s.attrs), s;
  }
};
ro.prototype.text = void 0;
let YH = class wy extends ro {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    if (super(e, t, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : VM(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new wy(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new wy(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
};
function VM(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class Ma {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let r = new JH(e, t);
    if (r.next == null)
      return Ma.empty;
    let i = qM(r);
    r.next && r.err("Unexpected trailing text");
    let s = r$(n$(i));
    return i$(s, r), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, r = e.childCount) {
    let i = this;
    for (let s = t; i && s < r; s++)
      i = i.matchType(e.child(s).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[t].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, r = 0) {
    let i = [this];
    function s(o, l) {
      let a = o.matchFragment(e, r);
      if (a && (!t || a.validEnd))
        return ce.from(l.map((c) => c.createAndFill()));
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: h } = o.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h);
          let f = s(h, l.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), s = i.match;
      if (s.matchType(e)) {
        let o = [];
        for (let l = i; l.type; l = l.via)
          o.push(l.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: l, next: a } = s.next[o];
        !l.isLeaf && !l.hasRequiredAttrs() && !(l.name in t) && (!i.type || a.validEnd) && (r.push({ match: l.contentMatch, type: l, via: i }), t[l.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && t(r.next[i].next);
    }
    return t(this), e.map((r, i) => {
      let s = i + (r.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < r.next.length; o++)
        s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
      return s;
    }).join(`
`);
  }
}
Ma.empty = new Ma(!0);
class JH {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function qM(n) {
  let e = [];
  do
    e.push(XH(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function XH(n) {
  let e = [];
  do
    e.push(ZH(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function ZH(n) {
  let e = t$(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = QH(n, e);
    else
      break;
  return e;
}
function Fw(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function QH(n, e) {
  let t = Fw(n), r = t;
  return n.eat(",") && (n.next != "}" ? r = Fw(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e };
}
function e$(n, e) {
  let t = n.nodeTypes, r = t[e];
  if (r)
    return [r];
  let i = [];
  for (let s in t) {
    let o = t[s];
    o.isInGroup(e) && i.push(o);
  }
  return i.length == 0 && n.err("No node type or group '" + e + "' found"), i;
}
function t$(n) {
  if (n.eat("(")) {
    let e = qM(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = e$(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function n$(n) {
  let e = [[]];
  return i(s(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function r(o, l, a) {
    let c = { term: a, to: l };
    return e[o].push(c), c;
  }
  function i(o, l) {
    o.forEach((a) => a.to = l);
  }
  function s(o, l) {
    if (o.type == "choice")
      return o.exprs.reduce((a, c) => a.concat(s(c, l)), []);
    if (o.type == "seq")
      for (let a = 0; ; a++) {
        let c = s(o.exprs[a], l);
        if (a == o.exprs.length - 1)
          return c;
        i(c, l = t());
      }
    else if (o.type == "star") {
      let a = t();
      return r(l, a), i(s(o.expr, a), a), [r(a)];
    } else if (o.type == "plus") {
      let a = t();
      return i(s(o.expr, l), a), i(s(o.expr, a), a), [r(a)];
    } else {
      if (o.type == "opt")
        return [r(l)].concat(s(o.expr, l));
      if (o.type == "range") {
        let a = l;
        for (let c = 0; c < o.min; c++) {
          let u = t();
          i(s(o.expr, a), u), a = u;
        }
        if (o.max == -1)
          i(s(o.expr, a), a);
        else
          for (let c = o.min; c < o.max; c++) {
            let u = t();
            r(a, u), i(s(o.expr, a), u), a = u;
          }
        return [r(a)];
      } else {
        if (o.type == "name")
          return [r(l, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function WM(n, e) {
  return e - n;
}
function Hw(n, e) {
  let t = [];
  return r(e), t.sort(WM);
  function r(i) {
    let s = n[i];
    if (s.length == 1 && !s[0].term)
      return r(s[0].to);
    t.push(i);
    for (let o = 0; o < s.length; o++) {
      let { term: l, to: a } = s[o];
      !l && t.indexOf(a) == -1 && r(a);
    }
  }
}
function r$(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(Hw(n, 0));
  function t(r) {
    let i = [];
    r.forEach((o) => {
      n[o].forEach(({ term: l, to: a }) => {
        if (!l)
          return;
        let c;
        for (let u = 0; u < i.length; u++)
          i[u][0] == l && (c = i[u][1]);
        Hw(n, a).forEach((u) => {
          c || i.push([l, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let s = e[r.join(",")] = new Ma(r.indexOf(n.length - 1) > -1);
    for (let o = 0; o < i.length; o++) {
      let l = i[o][1].sort(WM);
      s.next.push({ type: i[o][0], next: e[l.join(",")] || t(l) });
    }
    return s;
  }
}
function i$(n, e) {
  for (let t = 0, r = [n]; t < r.length; t++) {
    let i = r[t], s = !i.validEnd, o = [];
    for (let l = 0; l < i.next.length; l++) {
      let { type: a, next: c } = i.next[l];
      o.push(a.name), s && !(a.isText || a.hasRequiredAttrs()) && (s = !1), r.indexOf(c) == -1 && r.push(c);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function jM(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    if (!r.hasDefault)
      return null;
    e[t] = r.default;
  }
  return e;
}
function UM(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in n) {
    let i = e && e[r];
    if (i === void 0) {
      let s = n[r];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    t[r] = i;
  }
  return t;
}
function KM(n, e, t, r) {
  for (let i in e)
    if (!(i in n))
      throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`);
  for (let i in n) {
    let s = n[i];
    s.validate && s.validate(e[i]);
  }
}
function GM(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      t[r] = new o$(n, r, e[r]);
  return t;
}
let dm = class YM {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = GM(e, r.attrs), this.defaultAttrs = jM(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Ma.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : UM(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new ro(this, this.computeAttrs(e), ce.from(t), nt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, r) {
    return t = ce.from(t), this.checkContent(t), new ro(this, this.computeAttrs(e), t, nt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, r) {
    if (e = this.computeAttrs(e), t = ce.from(t), t.size) {
      let o = this.contentMatch.fillBefore(t);
      if (!o)
        return null;
      t = o.append(t);
    }
    let i = this.contentMatch.matchFragment(t), s = i && i.fillBefore(ce.empty, !0);
    return s ? new ro(this, e, t.append(s), nt.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    KM(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
    return t ? t.length ? t : nt.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => r[s] = new YM(s, t, o));
    let i = t.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function s$(n, e, t) {
  let r = t.split("|");
  return (i) => {
    let s = i === null ? "null" : typeof i;
    if (r.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n}, got ${s}`);
  };
}
class o$ {
  constructor(e, t, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? s$(e, t, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class u1 {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = GM(e, i.attrs), this.excluded = null;
    let s = jM(this.attrs);
    this.instance = s ? new nt(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new nt(this, UM(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, o) => r[s] = new u1(s, i++, t, o)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    KM(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class JM {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let i in e)
      t[i] = e[i];
    t.nodes = Nn.from(e.nodes), t.marks = Nn.from(e.marks || {}), this.nodes = dm.compile(this.spec.nodes, this), this.marks = u1.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let s = this.nodes[i], o = s.spec.content || "", l = s.spec.marks;
      if (s.contentMatch = r[o] || (r[o] = Ma.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!s.isInline || !s.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = s;
      }
      s.markSet = l == "_" ? null : l ? $w(this, l.split(" ")) : l == "" || !s.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let s = this.marks[i], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : $w(this, o.split(" "));
    }
    this.nodeFromJSON = (i) => ro.fromJSON(this, i), this.markFromJSON = (i) => nt.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof dm) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let r = this.nodes.text;
    return new YH(r, r.defaultAttrs, e, nt.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function $w(n, e) {
  let t = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], s = n.marks[i], o = s;
    if (s)
      t.push(s);
    else
      for (let l in n.marks) {
        let a = n.marks[l];
        (i == "_" || a.spec.group && a.spec.group.split(" ").indexOf(i) > -1) && t.push(o = a);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return t;
}
function l$(n) {
  return n.tag != null;
}
function a$(n) {
  return n.style != null;
}
class dl {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    t.forEach((i) => {
      if (l$(i))
        this.tags.push(i);
      else if (a$(i)) {
        let s = /[^=]*/.exec(i.style)[0];
        r.indexOf(s) < 0 && r.push(s), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let s = e.nodes[i.node];
      return s.contentMatch.matchType(s);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let r = new qw(this, t, !1);
    return r.addAll(e, nt.none, t.from, t.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let r = new qw(this, t, !0);
    return r.addAll(e, nt.none, t.from, t.to), be.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (h$(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], l = o.style;
      if (!(l.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      l.length > e.length && (l.charCodeAt(e.length) != 61 || l.slice(e.length + 1) != t))) {
        if (o.getAttrs) {
          let a = o.getAttrs(t);
          if (a === !1)
            continue;
          o.attrs = a || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function r(i) {
      let s = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < t.length; o++) {
        let l = t[o];
        if ((l.priority == null ? 50 : l.priority) < s)
          break;
      }
      t.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = Ww(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = Ww(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new dl(e, dl.schemaRules(e)));
  }
}
const XM = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, c$ = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, ZM = { ol: !0, ul: !0 }, Rf = 1, xy = 2, qh = 4;
function Vw(n, e, t) {
  return e != null ? (e ? Rf : 0) | (e === "full" ? xy : 0) : n && n.whitespace == "pre" ? Rf | xy : t & ~qh;
}
class h0 {
  constructor(e, t, r, i, s, o) {
    this.type = e, this.attrs = t, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = nt.none, this.match = s || (o & qh ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore(ce.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Rf)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let t = ce.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore(ce.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !XM.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class qw {
  constructor(e, t, r) {
    this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = t.topNode, s, o = Vw(null, t.preserveWhitespace, 0) | (r ? qh : 0);
    i ? s = new h0(i.type, i.attrs, nt.none, !0, t.topMatch || i.type.contentMatch, o) : r ? s = new h0(null, null, nt.none, !0, null, o) : s = new h0(e.schema.topNodeType, null, nt.none, !0, null, o), this.nodes = [s], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, t) {
    e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
  }
  addTextNode(e, t) {
    let r = e.nodeValue, i = this.top, s = i.options & xy ? "full" : this.localPreserveWS || (i.options & Rf) > 0;
    if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (s)
        s !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let o = i.content[i.content.length - 1], l = e.previousSibling;
        (!o || l && l.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), t, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t, r) {
    let i = this.localPreserveWS, s = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let o = e.nodeName.toLowerCase(), l;
    ZM.hasOwnProperty(o) && this.parser.normalizeLists && u$(e);
    let a = this.options.ruleFromNode && this.options.ruleFromNode(e) || (l = this.parser.matchTag(e, this, r));
    e: if (a ? a.ignore : c$.hasOwnProperty(o))
      this.findInside(e), this.ignoreFallback(e, t);
    else if (!a || a.skip || a.closeParent) {
      a && a.closeParent ? this.open = Math.max(0, this.open - 1) : a && a.skip.nodeType && (e = a.skip);
      let c, u = this.needsBlock;
      if (XM.hasOwnProperty(o))
        s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), c = !0, s.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, t);
        break e;
      }
      let h = a && a.skip ? t : this.readStyles(e, t);
      h && this.addAll(e, h), c && this.sync(s), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, t);
      c && this.addElementByRule(e, a, c, a.consuming === !1 ? l : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
  }
  // Called for ignored nodes
  ignoreFallback(e, t) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, t) {
    let r = e.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let s = this.parser.matchedStyles[i], o = r.getPropertyValue(s);
        if (o)
          for (let l = void 0; ; ) {
            let a = this.parser.matchStyle(s, o, this, l);
            if (!a)
              break;
            if (a.ignore)
              return null;
            if (a.clearMark ? t = t.filter((c) => !a.clearMark(c)) : t = t.concat(this.parser.schema.marks[a.mark].create(a.attrs)), a.consuming === !1)
              l = a;
            else
              break;
          }
      }
    return t;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, r, i) {
    let s, o;
    if (t.node)
      if (o = this.parser.schema.nodes[t.node], o.isLeaf)
        this.insertNode(o.create(t.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let a = this.enter(o, t.attrs || null, r, t.preserveWhitespace);
        a && (s = !0, r = a);
      }
    else {
      let a = this.parser.schema.marks[t.mark];
      r = r.concat(a.create(t.attrs));
    }
    let l = this.top;
    if (o && o.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, r, i);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((a) => this.insertNode(a, r, !1));
    else {
      let a = e;
      typeof t.contentElement == "string" ? a = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? a = t.contentElement(e) : t.contentElement && (a = t.contentElement), this.findAround(e, a, !0), this.addAll(a, r), this.findAround(e, a, !1);
    }
    s && this.sync(l) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, r, i) {
    let s = r || 0;
    for (let o = r ? e.childNodes[r] : e.firstChild, l = i == null ? null : e.childNodes[i]; o != l; o = o.nextSibling, ++s)
      this.findAtPoint(e, s), this.addDOM(o, t);
    this.findAtPoint(e, s);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, t, r) {
    let i, s;
    for (let o = this.open, l = 0; o >= 0; o--) {
      let a = this.nodes[o], c = a.findWrapping(e);
      if (c && (!i || i.length > c.length + l) && (i = c, s = a, !c.length))
        break;
      if (a.solid) {
        if (r)
          break;
        l += 2;
      }
    }
    if (!i)
      return null;
    this.sync(s);
    for (let o = 0; o < i.length; o++)
      t = this.enterInner(i[o], null, t, !1);
    return t;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, t, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let s = this.textblockFromContext();
      s && (t = this.enterInner(s, null, t));
    }
    let i = this.findPlace(e, t, r);
    if (i) {
      this.closeExtra();
      let s = this.top;
      s.match && (s.match = s.match.matchType(e.type));
      let o = nt.none;
      for (let l of i.concat(e.marks))
        (s.type ? s.type.allowsMarkType(l.type) : jw(l.type, e.type)) && (o = l.addToSet(o));
      return s.content.push(e.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, r, i) {
    let s = this.findPlace(e.create(t), r, !1);
    return s && (s = this.enterInner(e, t, r, !0, i)), s;
  }
  // Open a node of the given type
  enterInner(e, t, r, i = !1, s) {
    this.closeExtra();
    let o = this.top;
    o.match = o.match && o.match.matchType(e);
    let l = Vw(e, s, o.options);
    o.options & qh && o.content.length == 0 && (l |= qh);
    let a = nt.none;
    return r = r.filter((c) => (o.type ? o.type.allowsMarkType(c.type) : jw(c.type, e)) ? (a = c.addToSet(a), !1) : !0), this.nodes.push(new h0(e, t, a, i, null, l)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--) {
      if (this.nodes[t] == e)
        return this.open = t, !0;
      this.localPreserveWS && (this.nodes[t].options |= Rf);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let r = this.nodes[t].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, r) {
    if (e != t && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (l, a) => {
      for (; l >= 0; l--) {
        let c = t[l];
        if (c == "") {
          if (l == t.length - 1 || l == 0)
            continue;
          for (; a >= s; a--)
            if (o(l - 1, a))
              return !0;
          return !1;
        } else {
          let u = a > 0 || a == 0 && i ? this.nodes[a].type : r && a >= s ? r.node(a - s).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          a--;
        }
      }
      return !0;
    };
    return o(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let t in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[t];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function u$(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && ZM.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
  }
}
function h$(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function Ww(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function jw(n, e) {
  let t = e.schema.nodes;
  for (let r in t) {
    let i = t[r];
    if (!i.allowsMarkType(n))
      continue;
    let s = [], o = (l) => {
      s.push(l);
      for (let a = 0; a < l.edgeCount; a++) {
        let { type: c, next: u } = l.edge(a);
        if (c == e || s.indexOf(u) < 0 && o(u))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
class Sl {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, r) {
    r || (r = Gg(t).createDocumentFragment());
    let i = r, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let l = 0, a = 0;
        for (; l < s.length && a < o.marks.length; ) {
          let c = o.marks[a];
          if (!this.marks[c.type.name]) {
            a++;
            continue;
          }
          if (!c.eq(s[l][0]) || c.type.spec.spanning === !1)
            break;
          l++, a++;
        }
        for (; l < s.length; )
          i = s.pop()[1];
        for (; a < o.marks.length; ) {
          let c = o.marks[a++], u = this.serializeMark(c, o.isInline, t);
          u && (s.push([c, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, t));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: r, contentDOM: i } = np(Gg(t), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let r = this.serializeNodeInner(e, t);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, t);
      s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, t, r = {}) {
    let i = this.marks[e.type.name];
    return i && np(Gg(r), i(e, t), null, e.attrs);
  }
  static renderSpec(e, t, r = null, i) {
    return np(e, t, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Sl(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = Uw(e.nodes);
    return t.text || (t.text = (r) => r.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Uw(e.marks);
  }
}
function Uw(n) {
  let e = {};
  for (let t in n) {
    let r = n[t].spec.toDOM;
    r && (e[t] = r);
  }
  return e;
}
function Gg(n) {
  return n.document || window.document;
}
const Kw = /* @__PURE__ */ new WeakMap();
function f$(n) {
  let e = Kw.get(n);
  return e === void 0 && Kw.set(n, e = d$(n)), e;
}
function d$(n) {
  let e = null;
  function t(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let i = 0; i < r.length; i++)
            t(r[i]);
      else
        for (let i in r)
          t(r[i]);
  }
  return t(n), e;
}
function np(n, e, t, r) {
  if (typeof e == "string")
    return { dom: n.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], s;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (s = f$(r)) && s.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let o = i.indexOf(" ");
  o > 0 && (t = i.slice(0, o), i = i.slice(o + 1));
  let l, a = t ? n.createElementNS(t, i) : n.createElement(i), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let h in c)
      if (c[h] != null) {
        let f = h.indexOf(" ");
        f > 0 ? a.setAttributeNS(h.slice(0, f), h.slice(f + 1), c[h]) : h == "style" && a.style ? a.style.cssText = c[h] : a.setAttribute(h, c[h]);
      }
  }
  for (let h = u; h < e.length; h++) {
    let f = e[h];
    if (f === 0) {
      if (h < e.length - 1 || h > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: a, contentDOM: a };
    } else {
      let { dom: d, contentDOM: p } = np(n, f, t, r);
      if (a.appendChild(d), p) {
        if (l)
          throw new RangeError("Multiple content holes");
        l = p;
      }
    }
  }
  return { dom: a, contentDOM: l };
}
const QM = 65535, eT = Math.pow(2, 16);
function p$(n, e) {
  return n + e * eT;
}
function Gw(n) {
  return n & QM;
}
function m$(n) {
  return (n - (n & QM)) / eT;
}
const tT = 1, nT = 2, rp = 4, rT = 8;
class ky {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.delInfo = t, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & rT) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (tT | rp)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (nT | rp)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & rp) > 0;
  }
}
class Ur {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && Ur.empty)
      return Ur.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, r = Gw(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + t + m$(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let a = this.ranges[l] - (this.inverted ? i : 0);
      if (a > e)
        break;
      let c = this.ranges[l + s], u = this.ranges[l + o], h = a + c;
      if (e <= h) {
        let f = c ? e == a ? -1 : e == h ? 1 : t : t, d = a + i + (f < 0 ? 0 : u);
        if (r)
          return d;
        let p = e == (t < 0 ? a : h) ? null : p$(l / 3, e - a), m = e == a ? nT : e == h ? tT : rp;
        return (t < 0 ? e != a : e != h) && (m |= rT), new ky(d, m, p);
      }
      i += u - c;
    }
    return r ? e + i : new ky(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let r = 0, i = Gw(t), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let a = this.ranges[l] - (this.inverted ? r : 0);
      if (a > e)
        break;
      let c = this.ranges[l + s], u = a + c;
      if (e <= u && l == i * 3)
        return !0;
      r += this.ranges[l + o] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], l = o - (this.inverted ? s : 0), a = o + (this.inverted ? 0 : s), c = this.ranges[i + t], u = this.ranges[i + r];
      e(l, l + c, a, a + u), s += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Ur(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Ur.empty : new Ur(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Ur.empty = new Ur([]);
class Pf {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, t, r = 0, i = e ? e.length : 0) {
    this.mirror = t, this.from = r, this.to = i, this._maps = e || [], this.ownData = !(e || t);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new Pf(this._maps, this.mirror, e, t);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, r = this._maps.length; t < e._maps.length; t++) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t], i != null && i < t ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, r = this._maps.length + e._maps.length; t >= 0; t--) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t].invert(), i != null && i > t ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new Pf();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this._maps[s], l = o.mapResult(e, t);
      if (l.recover != null) {
        let a = this.getMirror(s);
        if (a != null && a > s && a < this.to) {
          s = a, e = this._maps[a].recover(l.recover);
          continue;
        }
      }
      i |= l.delInfo, e = l.pos;
    }
    return r ? e : new ky(e, i, null);
  }
}
const Yg = /* @__PURE__ */ Object.create(null);
class Zn {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Ur.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = Yg[t.stepType];
    if (!r)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in Yg)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Yg[e] = t, t.prototype.jsonID = e, t;
  }
}
class pn {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new pn(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new pn(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, r, i) {
    try {
      return pn.ok(e.replace(t, r, i));
    } catch (s) {
      if (s instanceof hm)
        return pn.fail(s.message);
      throw s;
    }
  }
}
function A3(n, e, t) {
  let r = [];
  for (let i = 0; i < n.childCount; i++) {
    let s = n.child(i);
    s.content.size && (s = s.copy(A3(s.content, e, s))), s.isInline && (s = e(s, t, i)), r.push(s);
  }
  return ce.fromArray(r);
}
class Zs extends Zn {
  /**
  Create a mark step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new be(A3(t.content, (o, l) => !o.isAtom || !l.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), t.openStart, t.openEnd);
    return pn.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new ds(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Zs(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Zs && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Zs(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Zs(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("addMark", Zs);
class ds extends Zn {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = new be(A3(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd);
    return pn.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Zs(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new ds(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof ds && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ds(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new ds(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("removeMark", ds);
class Zo extends Zn {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return pn.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return pn.fromReplace(e, this.pos, this.pos + 1, new be(ce.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let r = this.mark.addToSet(t.marks);
      if (r.length == t.marks.length) {
        for (let i = 0; i < t.marks.length; i++)
          if (!t.marks[i].isInSet(r))
            return new Zo(this.pos, t.marks[i]);
        return new Zo(this.pos, this.mark);
      }
    }
    return new Ta(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Zo(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Zo(t.pos, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("addNodeMark", Zo);
class Ta extends Zn {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return pn.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return pn.fromReplace(e, this.pos, this.pos + 1, new be(ce.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new Zo(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Ta(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Ta(t.pos, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("removeNodeMark", Ta);
class Cn extends Zn {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, r, i = !1) {
    super(), this.from = e, this.to = t, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && Sy(e, this.from, this.to) ? pn.fail("Structure replace would overwrite content") : pn.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Ur([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new Cn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deletedAcross && r.deletedAcross ? null : new Cn(t.pos, Math.max(t.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof Cn) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? be.empty : new be(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new Cn(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? be.empty : new be(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new Cn(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Cn(t.from, t.to, be.fromJSON(e, t.slice), !!t.structure);
  }
}
Zn.jsonID("replace", Cn);
class Yn extends Zn {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, r, i, s, o, l = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = l;
  }
  apply(e) {
    if (this.structure && (Sy(e, this.from, this.gapFrom) || Sy(e, this.gapTo, this.to)))
      return pn.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return pn.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, t.content);
    return r ? pn.fromReplace(e, this.from, this.to, r) : pn.fail("Content does not fit in gap");
  }
  getMap() {
    return new Ur([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new Yn(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return t.deletedAcross && r.deletedAcross || i < t.pos || s > r.pos ? null : new Yn(t.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Yn(t.from, t.to, t.gapFrom, t.gapTo, be.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
Zn.jsonID("replaceAround", Yn);
function Sy(n, e, t) {
  let r = n.resolve(e), i = t - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function g$(n, e, t, r) {
  let i = [], s = [], o, l;
  n.doc.nodesBetween(e, t, (a, c, u) => {
    if (!a.isInline)
      return;
    let h = a.marks;
    if (!r.isInSet(h) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), d = Math.min(c + a.nodeSize, t), p = r.addToSet(h);
      for (let m = 0; m < h.length; m++)
        h[m].isInSet(p) || (o && o.to == f && o.mark.eq(h[m]) ? o.to = d : i.push(o = new ds(f, d, h[m])));
      l && l.to == f ? l.to = d : s.push(l = new Zs(f, d, r));
    }
  }), i.forEach((a) => n.step(a)), s.forEach((a) => n.step(a));
}
function y$(n, e, t, r) {
  let i = [], s = 0;
  n.doc.nodesBetween(e, t, (o, l) => {
    if (!o.isInline)
      return;
    s++;
    let a = null;
    if (r instanceof u1) {
      let c = o.marks, u;
      for (; u = r.isInSet(c); )
        (a || (a = [])).push(u), c = u.removeFromSet(c);
    } else r ? r.isInSet(o.marks) && (a = [r]) : a = o.marks;
    if (a && a.length) {
      let c = Math.min(l + o.nodeSize, t);
      for (let u = 0; u < a.length; u++) {
        let h = a[u], f;
        for (let d = 0; d < i.length; d++) {
          let p = i[d];
          p.step == s - 1 && h.eq(i[d].style) && (f = p);
        }
        f ? (f.to = c, f.step = s) : i.push({ style: h, from: Math.max(l, e), to: c, step: s });
      }
    }
  }), i.forEach((o) => n.step(new ds(o.from, o.to, o.style)));
}
function O3(n, e, t, r = t.contentMatch, i = !0) {
  let s = n.doc.nodeAt(e), o = [], l = e + 1;
  for (let a = 0; a < s.childCount; a++) {
    let c = s.child(a), u = l + c.nodeSize, h = r.matchType(c.type);
    if (!h)
      o.push(new Cn(l, u, be.empty));
    else {
      r = h;
      for (let f = 0; f < c.marks.length; f++)
        t.allowsMarkType(c.marks[f].type) || n.step(new ds(l, u, c.marks[f]));
      if (i && c.isText && t.whitespace != "pre") {
        let f, d = /\r?\n|\r/g, p;
        for (; f = d.exec(c.text); )
          p || (p = new be(ce.from(t.schema.text(" ", t.allowedMarks(c.marks))), 0, 0)), o.push(new Cn(l + f.index, l + f.index + f[0].length, p));
      }
    }
    l = u;
  }
  if (!r.validEnd) {
    let a = r.fillBefore(ce.empty, !0);
    n.replace(l, l, new be(a, 0, 0));
  }
  for (let a = o.length - 1; a >= 0; a--)
    n.step(o[a]);
}
function b$(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function h1(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let r = n.depth; ; --r) {
    let i = n.$from.node(r), s = n.$from.index(r), o = n.$to.indexAfter(r);
    if (r < n.depth && i.canReplace(s, o, t))
      return r;
    if (r == 0 || i.type.spec.isolating || !b$(i, s, o))
      break;
  }
  return null;
}
function v$(n, e, t) {
  let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), l = i.after(s + 1), a = o, c = l, u = ce.empty, h = 0;
  for (let p = s, m = !1; p > t; p--)
    m || r.index(p) > 0 ? (m = !0, u = ce.from(r.node(p).copy(u)), h++) : a--;
  let f = ce.empty, d = 0;
  for (let p = s, m = !1; p > t; p--)
    m || i.after(p + 1) < i.end(p) ? (m = !0, f = ce.from(i.node(p).copy(f)), d++) : c++;
  n.step(new Yn(a, c, o, l, new be(u.append(f), h, d), u.size - h, !0));
}
function E3(n, e, t = null, r = n) {
  let i = w$(n, e), s = i && x$(r, e);
  return s ? i.map(Yw).concat({ type: e, attrs: t }).concat(s.map(Yw)) : null;
}
function Yw(n) {
  return { type: n, attrs: null };
}
function w$(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.contentMatchAt(r).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return t.canReplaceWith(r, i, o) ? s : null;
}
function x$(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.child(r), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let a = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let c = r; a && c < i; c++)
    a = a.matchType(t.child(c).type);
  return !a || !a.validEnd ? null : o;
}
function k$(n, e, t) {
  let r = ce.empty;
  for (let o = t.length - 1; o >= 0; o--) {
    if (r.size) {
      let l = t[o].type.contentMatch.matchFragment(r);
      if (!l || !l.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = ce.from(t[o].type.create(t[o].attrs, r));
  }
  let i = e.start, s = e.end;
  n.step(new Yn(i, s, i, s, new be(r, 0, 0), t.length, !0));
}
function S$(n, e, t, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = n.steps.length;
  n.doc.nodesBetween(e, t, (o, l) => {
    let a = typeof i == "function" ? i(o) : i;
    if (o.isTextblock && !o.hasMarkup(r, a) && C$(n.doc, n.mapping.slice(s).map(l), r)) {
      let c = null;
      if (r.schema.linebreakReplacement) {
        let d = r.whitespace == "pre", p = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        d && !p ? c = !1 : !d && p && (c = !0);
      }
      c === !1 && sT(n, o, l, s), O3(n, n.mapping.slice(s).map(l, 1), r, void 0, c === null);
      let u = n.mapping.slice(s), h = u.map(l, 1), f = u.map(l + o.nodeSize, 1);
      return n.step(new Yn(h, f, h + 1, f - 1, new be(ce.from(r.create(a, null, o.marks)), 0, 0), 1, !0)), c === !0 && iT(n, o, l, s), !1;
    }
  });
}
function iT(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.isText) {
      let o, l = /\r?\n|\r/g;
      for (; o = l.exec(i.text); ) {
        let a = n.mapping.slice(r).map(t + 1 + s + o.index);
        n.replaceWith(a, a + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function sT(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = n.mapping.slice(r).map(t + 1 + s);
      n.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function C$(n, e, t) {
  let r = n.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, t);
}
function M$(n, e, t, r, i) {
  let s = n.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  t || (t = s.type);
  let o = t.create(r, null, i || s.marks);
  if (s.isLeaf)
    return n.replaceWith(e, e + s.nodeSize, o);
  if (!t.validContent(s.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new Yn(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new be(ce.from(o), 0, 0), 1, !0));
}
function Wh(n, e, t = 1, r) {
  let i = n.resolve(e), s = i.depth - t, o = r && r[r.length - 1] || i.parent;
  if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let c = i.depth - 1, u = t - 2; c > s; c--, u--) {
    let h = i.node(c), f = i.index(c);
    if (h.type.spec.isolating)
      return !1;
    let d = h.content.cutByIndex(f, h.childCount), p = r && r[u + 1];
    p && (d = d.replaceChild(0, p.type.create(p.attrs)));
    let m = r && r[u] || h;
    if (!h.canReplace(f + 1, h.childCount) || !m.type.validContent(d))
      return !1;
  }
  let l = i.indexAfter(s), a = r && r[0];
  return i.node(s).canReplaceWith(l, l, a ? a.type : i.node(s + 1).type);
}
function T$(n, e, t = 1, r) {
  let i = n.doc.resolve(e), s = ce.empty, o = ce.empty;
  for (let l = i.depth, a = i.depth - t, c = t - 1; l > a; l--, c--) {
    s = ce.from(i.node(l).copy(s));
    let u = r && r[c];
    o = ce.from(u ? u.type.create(u.attrs, o) : i.node(l).copy(o));
  }
  n.step(new Cn(e, e, new be(s.append(o), t, t), !0));
}
function f1(n, e) {
  let t = n.resolve(e), r = t.index();
  return O$(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
}
function A$(n, e) {
  e.content.size || n.type.compatibleContent(e.type);
  let t = n.contentMatchAt(n.childCount), { linebreakReplacement: r } = n.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let s = e.child(i), o = s.type == r ? n.type.schema.nodes.text : s.type;
    if (t = t.matchType(o), !t || !n.type.allowsMarks(s.marks))
      return !1;
  }
  return t.validEnd;
}
function O$(n, e) {
  return !!(n && e && !n.isLeaf && A$(n, e));
}
function E$(n, e, t) {
  let r = null, { linebreakReplacement: i } = n.doc.type.schema, s = n.doc.resolve(e - t), o = s.node().type;
  if (i && o.inlineContent) {
    let u = o.whitespace == "pre", h = !!o.contentMatch.matchType(i);
    u && !h ? r = !1 : !u && h && (r = !0);
  }
  let l = n.steps.length;
  if (r === !1) {
    let u = n.doc.resolve(e + t);
    sT(n, u.node(), u.before(), l);
  }
  o.inlineContent && O3(n, e + t - 1, o, s.node().contentMatchAt(s.index()), r == null);
  let a = n.mapping.slice(l), c = a.map(e - t);
  if (n.step(new Cn(c, a.map(e + t, -1), be.empty, !0)), r === !0) {
    let u = n.doc.resolve(c);
    iT(n, u.node(), u.before(), n.steps.length);
  }
  return n;
}
function I$(n, e, t) {
  let r = n.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), t))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.before(i + 1);
      if (s > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.after(i + 1);
      if (s < r.node(i).childCount)
        return null;
    }
  return null;
}
function oT(n, e, t) {
  let r = n.resolve(e);
  if (!t.content.size)
    return e;
  let i = t.content;
  for (let s = 0; s < t.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let l = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, a = r.index(o) + (l > 0 ? 1 : 0), c = r.node(o), u = !1;
      if (s == 1)
        u = c.canReplace(a, a, i);
      else {
        let h = c.contentMatchAt(a).findWrapping(i.firstChild.type);
        u = h && c.canReplaceWith(a, a, h[0]);
      }
      if (u)
        return l == 0 ? r.pos : l < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function d1(n, e, t = e, r = be.empty) {
  if (e == t && !r.size)
    return null;
  let i = n.resolve(e), s = n.resolve(t);
  return lT(i, s, r) ? new Cn(e, t, r) : new D$(i, s, r).fit();
}
function lT(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class D$ {
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = ce.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = ce.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, o = r.depth, l = i.depth;
    for (; o && l && s.childCount == 1; )
      s = s.firstChild.content, o--, l--;
    let a = new be(s, o, l);
    return e > -1 ? new Yn(r.pos, e, this.$to.pos, this.$to.end(), a, t) : a.size || r.pos != this.$to.pos ? new Cn(r.pos, i.pos, a) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = t.firstChild;
      if (t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      t = s.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = Jg(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let l = this.depth; l >= 0; l--) {
          let { type: a, match: c } = this.frontier[l], u, h = null;
          if (t == 1 && (o ? c.matchType(o.type) || (h = c.fillBefore(ce.from(o), !1)) : s && a.compatibleContent(s.type)))
            return { sliceDepth: r, frontierDepth: l, parent: s, inject: h };
          if (t == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: l, parent: s, wrap: u };
          if (s && c.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = Jg(e, t);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new be(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = Jg(e, t);
    if (i.childCount <= 1 && t > 0) {
      let s = e.size - t <= t + i.size;
      this.unplaced = new be(rh(e, t - 1, 1), t - 1, s ? t - 1 : r);
    } else
      this.unplaced = new be(rh(e, t, 1), t, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: s }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (s)
      for (let m = 0; m < s.length; m++)
        this.openFrontierNode(s[m]);
    let o = this.unplaced, l = r ? r.content : o.content, a = o.openStart - e, c = 0, u = [], { match: h, type: f } = this.frontier[t];
    if (i) {
      for (let m = 0; m < i.childCount; m++)
        u.push(i.child(m));
      h = h.matchFragment(i);
    }
    let d = l.size + e - (o.content.size - o.openEnd);
    for (; c < l.childCount; ) {
      let m = l.child(c), g = h.matchType(m.type);
      if (!g)
        break;
      c++, (c > 1 || a == 0 || m.content.size) && (h = g, u.push(aT(m.mark(f.allowedMarks(m.marks)), c == 1 ? a : 0, c == l.childCount ? d : -1)));
    }
    let p = c == l.childCount;
    p || (d = -1), this.placed = ih(this.placed, t, ce.from(u)), this.frontier[t].match = h, p && d < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let m = 0, g = l; m < d; m++) {
      let b = g.lastChild;
      this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), g = b.content;
    }
    this.unplaced = p ? e == 0 ? be.empty : new be(rh(o.content, e - 1, 1), e - 1, d < 0 ? o.openEnd : e - 1) : new be(rh(o.content, e, c), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !Xg(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
      let { match: r, type: i } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = Xg(e, t, i, r, s);
      if (o) {
        for (let l = t - 1; l >= 0; l--) {
          let { match: a, type: c } = this.frontier[l], u = Xg(e, l, c, a, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: t, fit: o, move: s ? e.doc.resolve(e.after(t + 1)) : e };
      }
    }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = ih(this.placed, t.depth, t.fit)), e = t.move;
    for (let r = t.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, t = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = ih(this.placed, this.depth, ce.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(ce.empty, !0);
    t.childCount && (this.placed = ih(this.placed, this.frontier.length, t));
  }
}
function rh(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(rh(n.firstChild.content, e - 1, t)));
}
function ih(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(ih(n.lastChild.content, e - 1, t)));
}
function Jg(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function aT(n, e, t) {
  if (e <= 0)
    return n;
  let r = n.content;
  return e > 1 && (r = r.replaceChild(0, aT(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(ce.empty, !0)))), n.copy(r);
}
function Xg(n, e, t, r, i) {
  let s = n.node(e), o = i ? n.indexAfter(e) : n.index(e);
  if (o == s.childCount && !t.compatibleContent(s.type))
    return null;
  let l = r.fillBefore(s.content, !0, o);
  return l && !N$(t, s.content, o) ? l : null;
}
function N$(n, e, t) {
  for (let r = t; r < e.childCount; r++)
    if (!n.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function R$(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function P$(n, e, t, r) {
  if (!r.size)
    return n.deleteRange(e, t);
  let i = n.doc.resolve(e), s = n.doc.resolve(t);
  if (lT(i, s, r))
    return n.step(new Cn(e, t, r));
  let o = uT(i, n.doc.resolve(t));
  o[o.length - 1] == 0 && o.pop();
  let l = -(i.depth + 1);
  o.unshift(l);
  for (let f = i.depth, d = i.pos - 1; f > 0; f--, d--) {
    let p = i.node(f).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    o.indexOf(f) > -1 ? l = f : i.before(f) == d && o.splice(1, 0, -f);
  }
  let a = o.indexOf(l), c = [], u = r.openStart;
  for (let f = r.content, d = 0; ; d++) {
    let p = f.firstChild;
    if (c.push(p), d == r.openStart)
      break;
    f = p.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let d = c[f], p = R$(d.type);
    if (p && !d.sameMarkup(i.node(Math.abs(l) - 1)))
      u = f;
    else if (p || !d.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let d = (f + u + 1) % (r.openStart + 1), p = c[d];
    if (p)
      for (let m = 0; m < o.length; m++) {
        let g = o[(m + a) % o.length], b = !0;
        g < 0 && (b = !1, g = -g);
        let w = i.node(g - 1), k = i.index(g - 1);
        if (w.canReplaceWith(k, k, p.type, p.marks))
          return n.replace(i.before(g), b ? s.after(g) : t, new be(cT(r.content, 0, r.openStart, d), d, r.openEnd));
      }
  }
  let h = n.steps.length;
  for (let f = o.length - 1; f >= 0 && (n.replace(e, t, r), !(n.steps.length > h)); f--) {
    let d = o[f];
    d < 0 || (e = i.before(d), t = s.after(d));
  }
}
function cT(n, e, t, r, i) {
  if (e < t) {
    let s = n.firstChild;
    n = n.replaceChild(0, s.copy(cT(s.content, e + 1, t, r, s)));
  }
  if (e > r) {
    let s = i.contentMatchAt(0), o = s.fillBefore(n).append(n);
    n = o.append(s.matchFragment(o).fillBefore(ce.empty, !0));
  }
  return n;
}
function _$(n, e, t, r) {
  if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let i = I$(n.doc, e, r.type);
    i != null && (e = t = i);
  }
  n.replaceRange(e, t, new be(ce.from(r), 0, 0));
}
function L$(n, e, t) {
  let r = n.doc.resolve(e), i = n.doc.resolve(t), s = uT(r, i);
  for (let o = 0; o < s.length; o++) {
    let l = s[o], a = o == s.length - 1;
    if (a && l == 0 || r.node(l).type.contentMatch.validEnd)
      return n.delete(r.start(l), i.end(l));
    if (l > 0 && (a || r.node(l - 1).canReplace(r.index(l - 1), i.indexAfter(l - 1))))
      return n.delete(r.before(l), i.after(l));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && t > r.end(o) && i.end(o) - t != i.depth - o && r.start(o - 1) == i.start(o - 1) && r.node(o - 1).canReplace(r.index(o - 1), i.index(o - 1)))
      return n.delete(r.before(o), t);
  n.delete(e, t);
}
function uT(n, e) {
  let t = [], r = Math.min(n.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let s = n.start(i);
    if (s < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && t.push(i);
  }
  return t;
}
class wc extends Zn {
  /**
  Construct an attribute step.
  */
  constructor(e, t, r) {
    super(), this.pos = e, this.attr = t, this.value = r;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return pn.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in t.attrs)
      r[s] = t.attrs[s];
    r[this.attr] = this.value;
    let i = t.type.create(r, null, t.marks);
    return pn.fromReplace(e, this.pos, this.pos + 1, new be(ce.from(i), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return Ur.empty;
  }
  invert(e) {
    return new wc(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new wc(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new wc(t.pos, t.attr, t.value);
  }
}
Zn.jsonID("attr", wc);
class _f extends Zn {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      t[i] = e.attrs[i];
    t[this.attr] = this.value;
    let r = e.type.create(t, e.content, e.marks);
    return pn.ok(r);
  }
  getMap() {
    return Ur.empty;
  }
  invert(e) {
    return new _f(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _f(t.attr, t.value);
  }
}
Zn.jsonID("docAttr", _f);
let zc = class extends Error {
};
zc = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
zc.prototype = Object.create(Error.prototype);
zc.prototype.constructor = zc;
zc.prototype.name = "TransformError";
class hT {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Pf();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new zc(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, r = be.empty) {
    let i = d1(this.doc, e, t, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, r) {
    return this.replace(e, t, new be(ce.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, be.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, r) {
    return P$(this, e, t, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, r) {
    return _$(this, e, t, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return L$(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return v$(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return E$(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return k$(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, r, i = null) {
    return S$(this, e, t, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, r = null, i) {
    return M$(this, e, t, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, r) {
    return this.step(new wc(e, t, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new _f(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new Zo(e, t)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (t instanceof nt)
      t.isInSet(r.marks) && this.step(new Ta(e, t));
    else {
      let i = r.marks, s, o = [];
      for (; s = t.isInSet(i); )
        o.push(new Ta(e, s)), i = s.removeFromSet(i);
      for (let l = o.length - 1; l >= 0; l--)
        this.step(o[l]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, t = 1, r) {
    return T$(this, e, t, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, r) {
    return g$(this, e, t, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, r) {
    return y$(this, e, t, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, r) {
    return O3(this, e, t, r), this;
  }
}
const Zg = /* @__PURE__ */ Object.create(null);
class Ge {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, r) {
    this.$anchor = e, this.$head = t, this.ranges = r || [new fT(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = be.empty) {
    let r = t.content.lastChild, i = null;
    for (let l = 0; l < t.openEnd; l++)
      i = r, r = r.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let l = 0; l < o.length; l++) {
      let { $from: a, $to: c } = o[l], u = e.mapping.slice(s);
      e.replaceRange(u.map(a.pos), u.map(c.pos), l ? be.empty : t), l == 0 && Zw(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let r = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: l } = i[s], a = e.mapping.slice(r), c = a.map(o.pos), u = a.map(l.pos);
      s ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, t), Zw(e, r, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, r = !1) {
    let i = e.parent.inlineContent ? new Ee(e) : tc(e.node(0), e.parent, e.pos, e.index(), t, r);
    if (i)
      return i;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = t < 0 ? tc(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, r) : tc(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, r);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new Or(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return tc(e, e, 0, 0, 1) || new Or(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return tc(e, e, e.content.size, e.childCount, -1) || new Or(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = Zg[t.type];
    if (!r)
      throw new RangeError(`No selection type ${t.type} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in Zg)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Zg[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Ee.between(this.$anchor, this.$head).getBookmark();
  }
}
Ge.prototype.visible = !0;
class fT {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let Jw = !1;
function Xw(n) {
  !Jw && !n.parent.inlineContent && (Jw = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class Ee extends Ge {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    Xw(e), Xw(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    if (!r.parent.inlineContent)
      return Ge.near(r);
    let i = e.resolve(t.map(this.anchor));
    return new Ee(i.parent.inlineContent ? i : r, r);
  }
  replace(e, t = be.empty) {
    if (super.replace(e, t), t == be.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof Ee && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new p1(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Ee(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, r = t) {
    let i = e.resolve(t);
    return new this(i, r == t ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, r) {
    let i = e.pos - t.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let s = Ge.findFrom(t, r, !0) || Ge.findFrom(t, -r, !0);
      if (s)
        t = s.$head;
      else
        return Ge.near(t, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = t : (e = (Ge.findFrom(e, -r, !0) || Ge.findFrom(e, r, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new Ee(e, t);
  }
}
Ge.jsonID("text", Ee);
class p1 {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new p1(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Ee.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class $e extends Ge {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, r), this.node = t;
  }
  map(e, t) {
    let { deleted: r, pos: i } = t.mapResult(this.anchor), s = e.resolve(i);
    return r ? Ge.near(s) : new $e(s);
  }
  content() {
    return new be(ce.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof $e && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new I3(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new $e(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new $e(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
$e.prototype.visible = !1;
Ge.jsonID("node", $e);
class I3 {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: r } = e.mapResult(this.anchor);
    return t ? new p1(r, r) : new I3(r);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), r = t.nodeAfter;
    return r && $e.isSelectable(r) ? new $e(t) : Ge.near(t);
  }
}
class Or extends Ge {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = be.empty) {
    if (t == be.empty) {
      e.delete(0, e.doc.content.size);
      let r = Ge.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Or(e);
  }
  map(e) {
    return new Or(e);
  }
  eq(e) {
    return e instanceof Or;
  }
  getBookmark() {
    return B$;
  }
}
Ge.jsonID("all", Or);
const B$ = {
  map() {
    return this;
  },
  resolve(n) {
    return new Or(n);
  }
};
function tc(n, e, t, r, i, s = !1) {
  if (e.inlineContent)
    return Ee.create(n, t);
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let l = e.child(o);
    if (l.isAtom) {
      if (!s && $e.isSelectable(l))
        return $e.create(n, t - (i < 0 ? l.nodeSize : 0));
    } else {
      let a = tc(n, l, t + i, i < 0 ? l.childCount : 0, i, s);
      if (a)
        return a;
    }
    t += l.nodeSize * i;
  }
  return null;
}
function Zw(n, e, t) {
  let r = n.steps.length - 1;
  if (r < e)
    return;
  let i = n.steps[r];
  if (!(i instanceof Cn || i instanceof Yn))
    return;
  let s = n.mapping.maps[r], o;
  s.forEach((l, a, c, u) => {
    o == null && (o = u);
  }), n.setSelection(Ge.near(n.doc.resolve(o), t));
}
const Qw = 1, f0 = 2, ex = 4;
class z$ extends hT {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Qw) & ~f0, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & Qw) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= f0, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return nt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & f0) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~f0, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let r = this.selection;
    return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || nt.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, r) {
    let i = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = t), r = r ?? t, !e)
        return this.deleteRange(t, r);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(t);
        s = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(t, r, i.text(e, s)), this.selection.empty || this.setSelection(Ge.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= ex, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & ex) > 0;
  }
}
function tx(n, e) {
  return !e || !n ? n : n.bind(e);
}
class sh {
  constructor(e, t, r) {
    this.name = e, this.init = tx(t.init, r), this.apply = tx(t.apply, r);
  }
}
const F$ = [
  new sh("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new sh("selection", {
    init(n, e) {
      return n.selection || Ge.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new sh("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, r) {
      return r.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new sh("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
class Qg {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = F$.slice(), t && t.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new sh(r.key, r.spec.state, r));
    });
  }
}
class Qo {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != t) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let l = this.config.plugins[o];
        if (l.spec.appendTransaction) {
          let a = i ? i[o].n : 0, c = i ? i[o].state : this, u = a < t.length && l.spec.appendTransaction.call(l, a ? t.slice(a) : t, c, r);
          if (u && r.filterTransaction(u, o)) {
            if (u.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < o ? { state: r, n: t.length } : { state: this, n: 0 });
            }
            t.push(u), r = r.applyInner(u), s = !0;
          }
          i && (i[o] = { state: r, n: t.length });
        }
      }
      if (!s)
        return { state: r, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new Qo(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let s = r[i];
      t[s.name] = s.apply(e, this[s.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new z$(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new Qg(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Qo(t);
    for (let i = 0; i < t.fields.length; i++)
      r[t.fields[i].name] = t.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new Qg(this.schema, e.plugins), r = t.fields, i = new Qo(t);
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name;
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], s = i.spec.state;
        s && s.toJSON && (t[r] = s.toJSON.call(i, this[i.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, r) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new Qg(e.schema, e.plugins), s = new Qo(i);
    return i.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = ro.fromJSON(e.schema, t.doc);
      else if (o.name == "selection")
        s.selection = Ge.fromJSON(s.doc, t.selection);
      else if (o.name == "storedMarks")
        t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let l in r) {
            let a = r[l], c = a.spec.state;
            if (a.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(t, l)) {
              s[o.name] = c.fromJSON.call(a, e, t[l], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
}
function dT(n, e, t) {
  for (let r in n) {
    let i = n[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = dT(i, e, {})), t[r] = i;
  }
  return t;
}
class Ut {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && dT(e.props, this, this.props), this.key = e.key ? e.key.key : pT("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const e2 = /* @__PURE__ */ Object.create(null);
function pT(n) {
  return n in e2 ? n + "$" + ++e2[n] : (e2[n] = 0, n + "$");
}
class en {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = pT(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
class Ir {
  /**
  Create an input rule. The rule applies when the user typed
  something and the text directly in front of the cursor matches
  `match`, which should end with `$`.
  
  The `handler` can be a string, in which case the matched text, or
  the first matched group in the regexp, is replaced by that
  string.
  
  Or a it can be a function, which will be called with the match
  array produced by
  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  as well as the start and end of the matched range, and which can
  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
  rule's effect, or null to indicate the input was not handled.
  */
  constructor(e, t, r = {}) {
    this.match = e, this.match = e, this.handler = typeof t == "string" ? H$(t) : t, this.undoable = r.undoable !== !1, this.inCode = r.inCode || !1, this.inCodeMark = r.inCodeMark !== !1;
  }
}
function H$(n) {
  return function(e, t, r, i) {
    let s = n;
    if (t[1]) {
      let o = t[0].lastIndexOf(t[1]);
      s += t[0].slice(o + t[1].length), r += o;
      let l = r - i;
      l > 0 && (s = t[0].slice(o - l, o) + s, r = i);
    }
    return e.tr.insertText(s, r, i);
  };
}
const $$ = (n, e) => {
  let t = n.plugins;
  for (let r = 0; r < t.length; r++) {
    let i = t[r], s;
    if (i.spec.isInputRules && (s = i.getState(n))) {
      if (e) {
        let o = n.tr, l = s.transform;
        for (let a = l.steps.length - 1; a >= 0; a--)
          o.step(l.steps[a].invert(l.docs[a]));
        if (s.text) {
          let a = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, n.schema.text(s.text, a));
        } else
          o.delete(s.from, s.to);
        e(o);
      }
      return !0;
    }
  }
  return !1;
};
new Ir(/--$/, "—", { inCodeMark: !1 });
new Ir(/\.\.\.$/, "…", { inCodeMark: !1 });
new Ir(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“", { inCodeMark: !1 });
new Ir(/"$/, "”", { inCodeMark: !1 });
new Ir(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘", { inCodeMark: !1 });
new Ir(/'$/, "’", { inCodeMark: !1 });
function D3(n, e, t = null, r) {
  return new Ir(n, (i, s, o, l) => {
    let a = t instanceof Function ? t(s) : t, c = i.tr.delete(o, l), u = c.doc.resolve(o), h = u.blockRange(), f = h && E3(h, e, a);
    if (!f)
      return null;
    c.wrap(h, f);
    let d = c.doc.resolve(o - 1).nodeBefore;
    return d && d.type == e && f1(c.doc, o - 1) && (!r || r(s, d)) && c.join(o - 1), c;
  });
}
function N3(n, e, t = null) {
  return new Ir(n, (r, i, s, o) => {
    let l = r.doc.resolve(s), a = t instanceof Function ? t(i) : t;
    return l.node(-1).canReplaceWith(l.index(-1), l.indexAfter(-1), e) ? r.tr.delete(s, o).setBlockType(s, s, e, a) : null;
  });
}
var Dr = /* @__PURE__ */ ((n) => (n.docTypeError = "docTypeError", n.contextNotFound = "contextNotFound", n.timerNotFound = "timerNotFound", n.ctxCallOutOfScope = "ctxCallOutOfScope", n.createNodeInParserFail = "createNodeInParserFail", n.stackOverFlow = "stackOverFlow", n.parserMatchError = "parserMatchError", n.serializerMatchError = "serializerMatchError", n.getAtomFromSchemaFail = "getAtomFromSchemaFail", n.expectDomTypeError = "expectDomTypeError", n.callCommandBeforeEditorView = "callCommandBeforeEditorView", n.missingRootElement = "missingRootElement", n.missingNodeInSchema = "missingNodeInSchema", n.missingMarkInSchema = "missingMarkInSchema", n.ctxNotBind = "ctxNotBind", n.missingYjsDoc = "missingYjsDoc", n))(Dr || {});
class ei extends Error {
  constructor(e, t) {
    super(t), this.name = "MilkdownError", this.code = e;
  }
}
const V$ = (n, e) => typeof e == "function" ? "[Function]" : e, m1 = (n) => JSON.stringify(n, V$);
function q$(n) {
  return new ei(
    Dr.docTypeError,
    `Doc type error, unsupported type: ${m1(n)}`
  );
}
function W$(n) {
  return new ei(
    Dr.contextNotFound,
    `Context "${n}" not found, do you forget to inject it?`
  );
}
function j$(n) {
  return new ei(
    Dr.timerNotFound,
    `Timer "${n}" not found, do you forget to record it?`
  );
}
function g1() {
  return new ei(
    Dr.ctxCallOutOfScope,
    "Should not call a context out of the plugin."
  );
}
function U$(n, e, t) {
  const i = `Cannot create node for ${"name" in n ? n.name : n}`, s = (u) => {
    if (u == null) return "null";
    if (Array.isArray(u))
      return `[${u.map(s).join(", ")}]`;
    if (typeof u == "object")
      return "toJSON" in u && typeof u.toJSON == "function" ? JSON.stringify(u.toJSON()) : "spec" in u ? JSON.stringify(u.spec) : JSON.stringify(u);
    if (typeof u == "string" || typeof u == "number" || typeof u == "boolean")
      return JSON.stringify(u);
    if (typeof u == "function")
      return `[Function: ${u.name || "anonymous"}]`;
    try {
      return String(u);
    } catch {
      return "[Unserializable]";
    }
  }, o = ["[Description]", i], l = ["[Attributes]", e], a = [
    "[Content]",
    (t ?? []).map((u) => u ? typeof u == "object" && "type" in u ? `${u}` : s(u) : "null")
  ], c = [o, l, a].reduce(
    (u, [h, f]) => {
      const d = `${h}: ${s(f)}.`;
      return u.concat(d);
    },
    []
  );
  return new ei(
    Dr.createNodeInParserFail,
    c.join(`
`)
  );
}
function mT() {
  return new ei(
    Dr.stackOverFlow,
    "Stack over flow, cannot pop on an empty stack."
  );
}
function K$(n) {
  return new ei(
    Dr.parserMatchError,
    `Cannot match target parser for node: ${m1(n)}.`
  );
}
function G$(n) {
  return new ei(
    Dr.serializerMatchError,
    `Cannot match target serializer for node: ${m1(n)}.`
  );
}
function Y$(n, e) {
  return new ei(
    Dr.getAtomFromSchemaFail,
    `Cannot get ${n}: ${e} from schema.`
  );
}
function qi(n) {
  return new ei(
    Dr.expectDomTypeError,
    `Expect to be a dom, but get: ${m1(n)}.`
  );
}
function t2() {
  return new ei(
    Dr.callCommandBeforeEditorView,
    "You're trying to call a command before editor view initialized, make sure to get commandManager from ctx after editor view has been initialized"
  );
}
function J$(n) {
  return new ei(
    Dr.missingNodeInSchema,
    `Missing node in schema, milkdown cannot find "${n}" in schema.`
  );
}
function X$(n) {
  return new ei(
    Dr.missingMarkInSchema,
    `Missing mark in schema, milkdown cannot find "${n}" in schema.`
  );
}
const pl = typeof navigator < "u" ? navigator : null, nx = typeof document < "u" ? document : null, Cl = pl && pl.userAgent || "", Cy = /Edge\/(\d+)/.exec(Cl), gT = /MSIE \d/.exec(Cl), My = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Cl), y1 = !!(gT || My || Cy), Z$ = gT ? document.documentMode : My ? +My[1] : Cy ? +Cy[1] : 0, yT = !y1 && /gecko\/(\d+)/i.test(Cl), Q$ = yT && +(/Firefox\/(\d+)/.exec(Cl) || [0, 0])[1], Ty = !y1 && /Chrome\/(\d+)/.exec(Cl), eV = !!Ty, tV = Ty ? +Ty[1] : 0, bT = !y1 && !!pl && /Apple Computer/.test(pl.vendor), vT = bT && (/Mobile\/\w+/.test(Cl) || !!pl && pl.maxTouchPoints > 2), nV = vT || (pl ? /Mac/.test(pl.platform) : !1), rV = /Android \d/.test(Cl), wT = !!nx && "webkitFontSmoothing" in nx.documentElement.style, iV = wT ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
var d0 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  android: rV,
  chrome: eV,
  chrome_version: tV,
  gecko: yT,
  gecko_version: Q$,
  ie: y1,
  ie_version: Z$,
  ios: vT,
  mac: nV,
  safari: bT,
  webkit: wT,
  webkit_version: iV
});
function n2(n, e, t, r, i, s) {
  if (n.composing) return !1;
  const o = n.state, l = o.doc.resolve(e);
  if (l.parent.type.spec.code) return !1;
  const a = l.parent.textBetween(
    Math.max(0, l.parentOffset - 500),
    l.parentOffset,
    void 0,
    "￼"
  ) + r;
  for (let c of i) {
    const u = c, h = u.match.exec(a), f = h && h[0] && u.handler(o, h, e - (h[0].length - r.length), t);
    if (f)
      return u.undoable !== !1 && f.setMeta(s, { transform: f, from: e, to: t, text: r }), n.dispatch(f), !0;
  }
  return !1;
}
const sV = new en("MILKDOWN_CUSTOM_INPUTRULES");
function oV({ rules: n }) {
  const e = new Ut({
    key: sV,
    isInputRules: !0,
    state: {
      init() {
        return null;
      },
      apply(t, r) {
        const i = t.getMeta(this);
        return i || (t.selectionSet || t.docChanged ? null : r);
      }
    },
    props: {
      handleTextInput(t, r, i, s) {
        return n2(t, r, i, s, n, e);
      },
      handleDOMEvents: {
        compositionend: (t) => (setTimeout(() => {
          const { $cursor: r } = t.state.selection;
          r && n2(t, r.pos, r.pos, "", n, e);
        }), !1)
      },
      handleKeyDown(t, r) {
        if (r.key !== "Enter") return !1;
        const { $cursor: i } = t.state.selection;
        return i ? n2(t, i.pos, i.pos, `
`, n, e) : !1;
      }
    }
  });
  return e;
}
function hd(n, e, t = {}) {
  return new Ir(n, (r, i, s, o) => {
    var l, a, c, u;
    const { tr: h } = r, f = i.length;
    let d = i[f - 1], p = i[0], m = [], g = o;
    const b = {
      group: d,
      fullMatch: p,
      start: s,
      end: o
    }, w = (l = t.updateCaptured) == null ? void 0 : l.call(t, b);
    if (Object.assign(b, w), { group: d, fullMatch: p, start: s, end: o } = b, p === null || d?.trim() === "") return null;
    if (d) {
      const k = p.search(/\S/), C = s + p.indexOf(d), M = C + d.length;
      m = (a = h.storedMarks) != null ? a : [], M < o && h.delete(M, o), C > s && h.delete(s + k, C), g = s + k + d.length;
      const T = (c = t.getAttr) == null ? void 0 : c.call(t, i);
      h.addMark(s, g, e.create(T)), h.setStoredMarks(m), (u = t.beforeDispatch) == null || u.call(t, { match: i, start: s, end: o, tr: h });
    }
    return h;
  });
}
function lV(n, e, t = {}) {
  return new Ir(n, (r, i, s, o) => {
    var l, a, c;
    const { tr: u } = r;
    let h = i[1], f = i[0];
    const d = {
      group: h,
      fullMatch: f,
      start: s,
      end: o
    }, p = (l = t.updateCaptured) == null ? void 0 : l.call(t, d);
    if (Object.assign(d, p), { group: h, fullMatch: f, start: s, end: o } = d, f === null || !h || h.trim() === "") return null;
    const m = (a = t.getAttr) == null ? void 0 : a.call(t, i), g = e.createAndFill(m);
    return g && (u.replaceRangeWith(
      e.isBlock ? u.doc.resolve(s).before() : s,
      o,
      g
    ), (c = t.beforeDispatch) == null || c.call(t, {
      match: [f, h ?? ""],
      start: s,
      end: o,
      tr: u
    })), u;
  });
}
var aV = Object.defineProperty, cV = Object.defineProperties, uV = Object.getOwnPropertyDescriptors, rx = Object.getOwnPropertySymbols, hV = Object.prototype.hasOwnProperty, fV = Object.prototype.propertyIsEnumerable, ix = (n, e, t) => e in n ? aV(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, dV = (n, e) => {
  for (var t in e || (e = {}))
    hV.call(e, t) && ix(n, t, e[t]);
  if (rx)
    for (var t of rx(e))
      fV.call(e, t) && ix(n, t, e[t]);
  return n;
}, pV = (n, e) => cV(n, uV(e));
function sx(n = 0, e = 0, t = 0) {
  return Math.min(Math.max(n, e), t);
}
function b1(n, e, t) {
  const i = n.state.doc.content.size, s = sx(e, 0, i), o = sx(t, 0, i), l = n.coordsAtPos(s), a = n.coordsAtPos(o, -1), c = Math.min(l.top, a.top), u = Math.max(l.bottom, a.bottom), h = Math.min(l.left, a.left), f = Math.max(l.right, a.right), d = f - h, p = u - c, b = {
    top: c,
    bottom: u,
    left: h,
    right: f,
    width: d,
    height: p,
    x: h,
    y: c
  };
  return pV(dV({}, b), {
    toJSON: () => b
  });
}
function xT(n) {
  return Object.assign(Object.create(n), n).setTime(Date.now());
}
function mV(n, e) {
  return Array.isArray(n) && n.includes(e.type) || e.type === n;
}
function kT(n) {
  if (n.content.childCount === 1) {
    const e = n.content.firstChild;
    if (e?.type.name === "text" && e.marks.length === 0) return e;
    if (e?.type.name === "paragraph" && e.childCount === 1) {
      const t = e.firstChild;
      if (t?.type.name === "text" && t.marks.length === 0) return t;
    }
  }
  return !1;
}
function bs(n) {
  return (e) => {
    for (let t = e.depth; t > 0; t -= 1) {
      const r = e.node(t);
      if (n(r)) {
        const i = e.before(t), s = e.after(t);
        return {
          from: i,
          to: s,
          node: r
        };
      }
    }
  };
}
function gV(n, e) {
  return bs((t) => t.type === e)(n);
}
function yV(n, e) {
  const t = e.nodes[n];
  if (!t) throw Y$("node", n);
  return t;
}
function R3(n) {
  return (e) => {
    for (let t = e.depth; t > 0; t--) {
      const r = e.node(t);
      if (n(r))
        return {
          pos: t > 0 ? e.before(t) : 0,
          start: e.start(t),
          depth: t,
          node: r
        };
    }
  };
}
function bV(n) {
  return (e) => R3(n)(e.$from);
}
function vV(n, e) {
  if (!(n instanceof $e)) return;
  const { node: t, $from: r } = n;
  if (mV(e, t))
    return {
      node: t,
      pos: r.pos,
      start: r.start(r.depth),
      depth: r.depth
    };
}
const ST = (n, e) => {
  const { selection: t, doc: r } = n;
  if (t instanceof $e)
    return {
      hasNode: t.node.type === e,
      pos: t.from,
      target: t.node
    };
  const { from: i, to: s } = t;
  let o = !1, l = -1, a = null;
  return r.nodesBetween(i, s, (c, u) => a ? !1 : c.type === e ? (o = !0, l = u, a = c, !1) : !0), {
    hasNode: o,
    pos: l,
    target: a
  };
};
class CT {
  constructor() {
    this.sliceMap = /* @__PURE__ */ new Map(), this.get = (e) => {
      const t = typeof e == "string" ? [...this.sliceMap.values()].find((r) => r.type.name === e) : this.sliceMap.get(e.id);
      if (!t) {
        const r = typeof e == "string" ? e : e.name;
        throw W$(r);
      }
      return t;
    }, this.remove = (e) => {
      const t = typeof e == "string" ? [...this.sliceMap.values()].find((r) => r.type.name === e) : this.sliceMap.get(e.id);
      t && this.sliceMap.delete(t.type.id);
    }, this.has = (e) => typeof e == "string" ? [...this.sliceMap.values()].some((t) => t.type.name === e) : this.sliceMap.has(e.id);
  }
}
class wV {
  /// @internal
  constructor(e, t, r) {
    this.#t = [], this.#r = () => {
      this.#t.forEach((i) => i(this.#e));
    }, this.set = (i) => {
      this.#e = i, this.#r();
    }, this.get = () => this.#e, this.update = (i) => {
      this.#e = i(this.#e), this.#r();
    }, this.type = r, this.#e = t, e.set(r.id, this);
  }
  #t;
  /// @internal
  #e;
  #r;
  /// Add a watcher for changes in the slice.
  /// Returns a function to remove the watcher.
  on(e) {
    return this.#t.push(e), () => {
      this.#t = this.#t.filter((t) => t !== e);
    };
  }
  /// Add a one-time watcher for changes in the slice.
  /// The watcher will be removed after it is called.
  /// Returns a function to remove the watcher.
  once(e) {
    const t = this.on((r) => {
      e(r), t();
    });
    return t;
  }
  /// Remove a watcher.
  off(e) {
    this.#t = this.#t.filter((t) => t !== e);
  }
  /// Remove all watchers.
  offAll() {
    this.#t = [];
  }
}
class xV {
  /// Create a slice type with a default value and a name.
  /// The name should be unique in the container.
  constructor(e, t) {
    this.id = Symbol(`Context-${t}`), this.name = t, this._defaultValue = e, this._typeInfo = () => {
      throw g1();
    };
  }
  /// Create a slice with a container.
  /// You can also pass a value to override the default value.
  create(e, t = this._defaultValue) {
    return new wV(e, t, this);
  }
}
const at = (n, e) => new xV(n, e);
class kV {
  /// Create an inspector with container, clock and metadata.
  constructor(e, t, r) {
    this.#n = /* @__PURE__ */ new Set(), this.#a = /* @__PURE__ */ new Set(), this.#i = /* @__PURE__ */ new Map(), this.#s = /* @__PURE__ */ new Map(), this.read = () => ({
      metadata: this.#t,
      injectedSlices: [...this.#n].map((i) => ({
        name: typeof i == "string" ? i : i.name,
        value: this.#o(i)
      })),
      consumedSlices: [...this.#a].map((i) => ({
        name: typeof i == "string" ? i : i.name,
        value: this.#o(i)
      })),
      recordedTimers: [...this.#i].map(
        ([i, { duration: s }]) => ({
          name: i.name,
          duration: s,
          status: this.#l(i)
        })
      ),
      waitTimers: [...this.#s].map(([i, { duration: s }]) => ({
        name: i.name,
        duration: s,
        status: this.#l(i)
      }))
    }), this.onRecord = (i) => {
      this.#i.set(i, { start: Date.now(), duration: 0 });
    }, this.onClear = (i) => {
      this.#i.delete(i);
    }, this.onDone = (i) => {
      const s = this.#i.get(i);
      s && (s.duration = Date.now() - s.start);
    }, this.onWait = (i, s) => {
      const o = Date.now();
      s.finally(() => {
        this.#s.set(i, { duration: Date.now() - o });
      }).catch(console.error);
    }, this.onInject = (i) => {
      this.#n.add(i);
    }, this.onRemove = (i) => {
      this.#n.delete(i);
    }, this.onUse = (i) => {
      this.#a.add(i);
    }, this.#o = (i) => this.#e.get(i).get(), this.#l = (i) => this.#r.get(i).status, this.#e = e, this.#r = t, this.#t = r;
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  #n;
  #a;
  #i;
  #s;
  #o;
  #l;
}
class P3 {
  /// Create a ctx object with container and clock.
  constructor(e, t, r) {
    this.produce = (i) => i && Object.keys(i).length ? new P3(this.#t, this.#e, { ...i }) : this, this.inject = (i, s) => {
      const o = i.create(this.#t.sliceMap);
      return s != null && o.set(s), this.#n?.onInject(i), this;
    }, this.remove = (i) => (this.#t.remove(i), this.#n?.onRemove(i), this), this.record = (i) => (i.create(this.#e.store), this.#n?.onRecord(i), this), this.clearTimer = (i) => (this.#e.remove(i), this.#n?.onClear(i), this), this.isInjected = (i) => this.#t.has(i), this.isRecorded = (i) => this.#e.has(i), this.use = (i) => (this.#n?.onUse(i), this.#t.get(i)), this.get = (i) => this.use(i).get(), this.set = (i, s) => this.use(i).set(s), this.update = (i, s) => this.use(i).update(s), this.timer = (i) => this.#e.get(i), this.done = (i) => {
      this.timer(i).done(), this.#n?.onDone(i);
    }, this.wait = (i) => {
      const s = this.timer(i).start();
      return this.#n?.onWait(i, s), s;
    }, this.waitTimers = async (i) => {
      await Promise.all(this.get(i).map((s) => this.wait(s)));
    }, this.#t = e, this.#e = t, this.#r = r, r && (this.#n = new kV(e, t, r));
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  /// @internal
  #n;
  /// Get metadata of the ctx.
  get meta() {
    return this.#r;
  }
  /// Get the inspector of the ctx.
  get inspector() {
    return this.#n;
  }
}
class SV {
  constructor() {
    this.store = /* @__PURE__ */ new Map(), this.get = (e) => {
      const t = this.store.get(e.id);
      if (!t) throw j$(e.name);
      return t;
    }, this.remove = (e) => {
      this.store.delete(e.id);
    }, this.has = (e) => this.store.has(e.id);
  }
}
class CV {
  /// @internal
  constructor(e, t) {
    this.#t = null, this.#e = null, this.#n = "pending", this.start = () => (this.#t ??= new Promise((r, i) => {
      this.#e = (s) => {
        s instanceof CustomEvent && s.detail.id === this.#r && (this.#n = "resolved", this.#a(), s.stopImmediatePropagation(), r());
      }, this.#i(() => {
        this.#n === "pending" && (this.#n = "rejected"), this.#a(), i(new Error(`Timing ${this.type.name} timeout.`));
      }), this.#n = "pending", addEventListener(this.type.name, this.#e);
    }), this.#t), this.done = () => {
      const r = new CustomEvent(this.type.name, {
        detail: { id: this.#r }
      });
      dispatchEvent(r);
    }, this.#a = () => {
      this.#e && removeEventListener(this.type.name, this.#e);
    }, this.#i = (r) => {
      setTimeout(() => {
        r();
      }, this.type.timeout);
    }, this.#r = Symbol(t.name), this.type = t, e.set(t.id, this);
  }
  #t;
  #e;
  /// @internal
  #r;
  #n;
  /// The status of the timer.
  /// Can be `pending`, `resolved` or `rejected`.
  get status() {
    return this.#n;
  }
  #a;
  #i;
}
class MV {
  /// Create a timer type with a name and a timeout.
  /// The name should be unique in the clock.
  constructor(e, t = 3e3) {
    this.create = (r) => new CV(r, this), this.id = Symbol(`Timer-${e}`), this.name = e, this.timeout = t;
  }
}
const ko = (n, e = 3e3) => new MV(n, e), TV = {};
function _3(n, e) {
  const t = TV, r = typeof t.includeImageAlt == "boolean" ? t.includeImageAlt : !0, i = typeof t.includeHtml == "boolean" ? t.includeHtml : !0;
  return MT(n, r, i);
}
function MT(n, e, t) {
  if (AV(n)) {
    if ("value" in n)
      return n.type === "html" && !t ? "" : n.value;
    if (e && "alt" in n && n.alt)
      return n.alt;
    if ("children" in n)
      return ox(n.children, e, t);
  }
  return Array.isArray(n) ? ox(n, e, t) : "";
}
function ox(n, e, t) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; )
    r[i] = MT(n[i], e, t);
  return r.join("");
}
function AV(n) {
  return !!(n && typeof n == "object");
}
const lx = document.createElement("i");
function L3(n) {
  const e = "&" + n + ";";
  lx.innerHTML = e;
  const t = lx.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    t.charCodeAt(t.length - 1) === 59 && n !== "semi" || t === e ? !1 : t
  );
}
function Jr(n, e, t, r) {
  const i = n.length;
  let s = 0, o;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, t = t > 0 ? t : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(e, t), n.splice(...o);
  else
    for (t && n.splice(e, t); s < r.length; )
      o = r.slice(s, s + 1e4), o.unshift(e, 0), n.splice(...o), s += 1e4, e += 1e4;
}
function oi(n, e) {
  return n.length > 0 ? (Jr(n, n.length, 0, e), n) : e;
}
const ax = {}.hasOwnProperty;
function TT(n) {
  const e = {};
  let t = -1;
  for (; ++t < n.length; )
    OV(e, n[t]);
  return e;
}
function OV(n, e) {
  let t;
  for (t in e) {
    const i = (ax.call(n, t) ? n[t] : void 0) || (n[t] = {}), s = e[t];
    let o;
    if (s)
      for (o in s) {
        ax.call(i, o) || (i[o] = []);
        const l = s[o];
        EV(
          // @ts-expect-error Looks like a list.
          i[o],
          Array.isArray(l) ? l : l ? [l] : []
        );
      }
  }
}
function EV(n, e) {
  let t = -1;
  const r = [];
  for (; ++t < e.length; )
    (e[t].add === "after" ? n : r).push(e[t]);
  Jr(n, 0, 0, r);
}
function AT(n, e) {
  const t = Number.parseInt(n, e);
  return (
    // C0 except for HT, LF, FF, CR, space.
    t < 9 || t === 11 || t > 13 && t < 32 || // Control character (DEL) of C0, and C1 controls.
    t > 126 && t < 160 || // Lone high surrogates and low surrogates.
    t > 55295 && t < 57344 || // Noncharacters.
    t > 64975 && t < 65008 || /* eslint-disable no-bitwise */
    (t & 65535) === 65535 || (t & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    t > 1114111 ? "�" : String.fromCodePoint(t)
  );
}
function Ri(n) {
  return n.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const lr = Ml(/[A-Za-z]/), Tr = Ml(/[\dA-Za-z]/), IV = Ml(/[#-'*+\--9=?A-Z^-~]/);
function pm(n) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    n !== null && (n < 32 || n === 127)
  );
}
const Ay = Ml(/\d/), DV = Ml(/[\dA-Fa-f]/), NV = Ml(/[!-/:-@[-`{-~]/);
function Ne(n) {
  return n !== null && n < -2;
}
function Dt(n) {
  return n !== null && (n < 0 || n === 32);
}
function lt(n) {
  return n === -2 || n === -1 || n === 32;
}
const v1 = Ml(new RegExp("\\p{P}|\\p{S}", "u")), Aa = Ml(/\s/);
function Ml(n) {
  return e;
  function e(t) {
    return t !== null && t > -1 && n.test(String.fromCharCode(t));
  }
}
function it(n, e, t, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return o;
  function o(a) {
    return lt(a) ? (n.enter(t), l(a)) : e(a);
  }
  function l(a) {
    return lt(a) && s++ < i ? (n.consume(a), l) : (n.exit(t), e(a));
  }
}
const RV = {
  tokenize: PV
};
function PV(n) {
  const e = n.attempt(this.parser.constructs.contentInitial, r, i);
  let t;
  return e;
  function r(l) {
    if (l === null) {
      n.consume(l);
      return;
    }
    return n.enter("lineEnding"), n.consume(l), n.exit("lineEnding"), it(n, e, "linePrefix");
  }
  function i(l) {
    return n.enter("paragraph"), s(l);
  }
  function s(l) {
    const a = n.enter("chunkText", {
      contentType: "text",
      previous: t
    });
    return t && (t.next = a), t = a, o(l);
  }
  function o(l) {
    if (l === null) {
      n.exit("chunkText"), n.exit("paragraph"), n.consume(l);
      return;
    }
    return Ne(l) ? (n.consume(l), n.exit("chunkText"), s) : (n.consume(l), o);
  }
}
const _V = {
  tokenize: LV
}, cx = {
  tokenize: BV
};
function LV(n) {
  const e = this, t = [];
  let r = 0, i, s, o;
  return l;
  function l(k) {
    if (r < t.length) {
      const C = t[r];
      return e.containerState = C[1], n.attempt(C[0].continuation, a, c)(k);
    }
    return c(k);
  }
  function a(k) {
    if (r++, e.containerState._closeFlow) {
      e.containerState._closeFlow = void 0, i && w();
      const C = e.events.length;
      let M = C, T;
      for (; M--; )
        if (e.events[M][0] === "exit" && e.events[M][1].type === "chunkFlow") {
          T = e.events[M][1].end;
          break;
        }
      b(r);
      let N = C;
      for (; N < e.events.length; )
        e.events[N][1].end = {
          ...T
        }, N++;
      return Jr(e.events, M + 1, 0, e.events.slice(C)), e.events.length = N, c(k);
    }
    return l(k);
  }
  function c(k) {
    if (r === t.length) {
      if (!i)
        return f(k);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return p(k);
      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return e.containerState = {}, n.check(cx, u, h)(k);
  }
  function u(k) {
    return i && w(), b(r), f(k);
  }
  function h(k) {
    return e.parser.lazy[e.now().line] = r !== t.length, o = e.now().offset, p(k);
  }
  function f(k) {
    return e.containerState = {}, n.attempt(cx, d, p)(k);
  }
  function d(k) {
    return r++, t.push([e.currentConstruct, e.containerState]), f(k);
  }
  function p(k) {
    if (k === null) {
      i && w(), b(0), n.consume(k);
      return;
    }
    return i = i || e.parser.flow(e.now()), n.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: s
    }), m(k);
  }
  function m(k) {
    if (k === null) {
      g(n.exit("chunkFlow"), !0), b(0), n.consume(k);
      return;
    }
    return Ne(k) ? (n.consume(k), g(n.exit("chunkFlow")), r = 0, e.interrupt = void 0, l) : (n.consume(k), m);
  }
  function g(k, C) {
    const M = e.sliceStream(k);
    if (C && M.push(null), k.previous = s, s && (s.next = k), s = k, i.defineSkip(k.start), i.write(M), e.parser.lazy[k.start.line]) {
      let T = i.events.length;
      for (; T--; )
        if (
          // The token starts before the line ending…
          i.events[T][1].start.offset < o && // …and either is not ended yet…
          (!i.events[T][1].end || // …or ends after it.
          i.events[T][1].end.offset > o)
        )
          return;
      const N = e.events.length;
      let B = N, $, R;
      for (; B--; )
        if (e.events[B][0] === "exit" && e.events[B][1].type === "chunkFlow") {
          if ($) {
            R = e.events[B][1].end;
            break;
          }
          $ = !0;
        }
      for (b(r), T = N; T < e.events.length; )
        e.events[T][1].end = {
          ...R
        }, T++;
      Jr(e.events, B + 1, 0, e.events.slice(N)), e.events.length = T;
    }
  }
  function b(k) {
    let C = t.length;
    for (; C-- > k; ) {
      const M = t[C];
      e.containerState = M[1], M[0].exit.call(e, n);
    }
    t.length = k;
  }
  function w() {
    i.write([null]), s = void 0, i = void 0, e.containerState._closeFlow = void 0;
  }
}
function BV(n, e, t) {
  return it(n, n.attempt(this.parser.constructs.document, e, t), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function Fc(n) {
  if (n === null || Dt(n) || Aa(n))
    return 1;
  if (v1(n))
    return 2;
}
function w1(n, e, t) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; ) {
    const s = n[i].resolveAll;
    s && !r.includes(s) && (e = s(e, t), r.push(s));
  }
  return e;
}
const Oy = {
  name: "attention",
  resolveAll: zV,
  tokenize: FV
};
function zV(n, e) {
  let t = -1, r, i, s, o, l, a, c, u;
  for (; ++t < n.length; )
    if (n[t][0] === "enter" && n[t][1].type === "attentionSequence" && n[t][1]._close) {
      for (r = t; r--; )
        if (n[r][0] === "exit" && n[r][1].type === "attentionSequence" && n[r][1]._open && // If the markers are the same:
        e.sliceSerialize(n[r][1]).charCodeAt(0) === e.sliceSerialize(n[t][1]).charCodeAt(0)) {
          if ((n[r][1]._close || n[t][1]._open) && (n[t][1].end.offset - n[t][1].start.offset) % 3 && !((n[r][1].end.offset - n[r][1].start.offset + n[t][1].end.offset - n[t][1].start.offset) % 3))
            continue;
          a = n[r][1].end.offset - n[r][1].start.offset > 1 && n[t][1].end.offset - n[t][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...n[r][1].end
          }, f = {
            ...n[t][1].start
          };
          ux(h, -a), ux(f, a), o = {
            type: a > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...n[r][1].end
            }
          }, l = {
            type: a > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...n[t][1].start
            },
            end: f
          }, s = {
            type: a > 1 ? "strongText" : "emphasisText",
            start: {
              ...n[r][1].end
            },
            end: {
              ...n[t][1].start
            }
          }, i = {
            type: a > 1 ? "strong" : "emphasis",
            start: {
              ...o.start
            },
            end: {
              ...l.end
            }
          }, n[r][1].end = {
            ...o.start
          }, n[t][1].start = {
            ...l.end
          }, c = [], n[r][1].end.offset - n[r][1].start.offset && (c = oi(c, [["enter", n[r][1], e], ["exit", n[r][1], e]])), c = oi(c, [["enter", i, e], ["enter", o, e], ["exit", o, e], ["enter", s, e]]), c = oi(c, w1(e.parser.constructs.insideSpan.null, n.slice(r + 1, t), e)), c = oi(c, [["exit", s, e], ["enter", l, e], ["exit", l, e], ["exit", i, e]]), n[t][1].end.offset - n[t][1].start.offset ? (u = 2, c = oi(c, [["enter", n[t][1], e], ["exit", n[t][1], e]])) : u = 0, Jr(n, r - 1, t - r + 3, c), t = r + c.length - u - 2;
          break;
        }
    }
  for (t = -1; ++t < n.length; )
    n[t][1].type === "attentionSequence" && (n[t][1].type = "data");
  return n;
}
function FV(n, e) {
  const t = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Fc(r);
  let s;
  return o;
  function o(a) {
    return s = a, n.enter("attentionSequence"), l(a);
  }
  function l(a) {
    if (a === s)
      return n.consume(a), l;
    const c = n.exit("attentionSequence"), u = Fc(a), h = !u || u === 2 && i || t.includes(a), f = !i || i === 2 && u || t.includes(r);
    return c._open = !!(s === 42 ? h : h && (i || !f)), c._close = !!(s === 42 ? f : f && (u || !h)), e(a);
  }
}
function ux(n, e) {
  n.column += e, n.offset += e, n._bufferIndex += e;
}
const HV = {
  name: "autolink",
  tokenize: $V
};
function $V(n, e, t) {
  let r = 0;
  return i;
  function i(d) {
    return n.enter("autolink"), n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.enter("autolinkProtocol"), s;
  }
  function s(d) {
    return lr(d) ? (n.consume(d), o) : d === 64 ? t(d) : c(d);
  }
  function o(d) {
    return d === 43 || d === 45 || d === 46 || Tr(d) ? (r = 1, l(d)) : c(d);
  }
  function l(d) {
    return d === 58 ? (n.consume(d), r = 0, a) : (d === 43 || d === 45 || d === 46 || Tr(d)) && r++ < 32 ? (n.consume(d), l) : (r = 0, c(d));
  }
  function a(d) {
    return d === 62 ? (n.exit("autolinkProtocol"), n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.exit("autolink"), e) : d === null || d === 32 || d === 60 || pm(d) ? t(d) : (n.consume(d), a);
  }
  function c(d) {
    return d === 64 ? (n.consume(d), u) : IV(d) ? (n.consume(d), c) : t(d);
  }
  function u(d) {
    return Tr(d) ? h(d) : t(d);
  }
  function h(d) {
    return d === 46 ? (n.consume(d), r = 0, u) : d === 62 ? (n.exit("autolinkProtocol").type = "autolinkEmail", n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.exit("autolink"), e) : f(d);
  }
  function f(d) {
    if ((d === 45 || Tr(d)) && r++ < 63) {
      const p = d === 45 ? f : h;
      return n.consume(d), p;
    }
    return t(d);
  }
}
const fd = {
  partial: !0,
  tokenize: VV
};
function VV(n, e, t) {
  return r;
  function r(s) {
    return lt(s) ? it(n, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || Ne(s) ? e(s) : t(s);
  }
}
const OT = {
  continuation: {
    tokenize: WV
  },
  exit: jV,
  name: "blockQuote",
  tokenize: qV
};
function qV(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const l = r.containerState;
      return l.open || (n.enter("blockQuote", {
        _container: !0
      }), l.open = !0), n.enter("blockQuotePrefix"), n.enter("blockQuoteMarker"), n.consume(o), n.exit("blockQuoteMarker"), s;
    }
    return t(o);
  }
  function s(o) {
    return lt(o) ? (n.enter("blockQuotePrefixWhitespace"), n.consume(o), n.exit("blockQuotePrefixWhitespace"), n.exit("blockQuotePrefix"), e) : (n.exit("blockQuotePrefix"), e(o));
  }
}
function WV(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return lt(o) ? it(n, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : s(o);
  }
  function s(o) {
    return n.attempt(OT, e, t)(o);
  }
}
function jV(n) {
  n.exit("blockQuote");
}
const ET = {
  name: "characterEscape",
  tokenize: UV
};
function UV(n, e, t) {
  return r;
  function r(s) {
    return n.enter("characterEscape"), n.enter("escapeMarker"), n.consume(s), n.exit("escapeMarker"), i;
  }
  function i(s) {
    return NV(s) ? (n.enter("characterEscapeValue"), n.consume(s), n.exit("characterEscapeValue"), n.exit("characterEscape"), e) : t(s);
  }
}
const IT = {
  name: "characterReference",
  tokenize: KV
};
function KV(n, e, t) {
  const r = this;
  let i = 0, s, o;
  return l;
  function l(h) {
    return n.enter("characterReference"), n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), a;
  }
  function a(h) {
    return h === 35 ? (n.enter("characterReferenceMarkerNumeric"), n.consume(h), n.exit("characterReferenceMarkerNumeric"), c) : (n.enter("characterReferenceValue"), s = 31, o = Tr, u(h));
  }
  function c(h) {
    return h === 88 || h === 120 ? (n.enter("characterReferenceMarkerHexadecimal"), n.consume(h), n.exit("characterReferenceMarkerHexadecimal"), n.enter("characterReferenceValue"), s = 6, o = DV, u) : (n.enter("characterReferenceValue"), s = 7, o = Ay, u(h));
  }
  function u(h) {
    if (h === 59 && i) {
      const f = n.exit("characterReferenceValue");
      return o === Tr && !L3(r.sliceSerialize(f)) ? t(h) : (n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), n.exit("characterReference"), e);
    }
    return o(h) && i++ < s ? (n.consume(h), u) : t(h);
  }
}
const hx = {
  partial: !0,
  tokenize: YV
}, fx = {
  concrete: !0,
  name: "codeFenced",
  tokenize: GV
};
function GV(n, e, t) {
  const r = this, i = {
    partial: !0,
    tokenize: M
  };
  let s = 0, o = 0, l;
  return a;
  function a(T) {
    return c(T);
  }
  function c(T) {
    const N = r.events[r.events.length - 1];
    return s = N && N[1].type === "linePrefix" ? N[2].sliceSerialize(N[1], !0).length : 0, l = T, n.enter("codeFenced"), n.enter("codeFencedFence"), n.enter("codeFencedFenceSequence"), u(T);
  }
  function u(T) {
    return T === l ? (o++, n.consume(T), u) : o < 3 ? t(T) : (n.exit("codeFencedFenceSequence"), lt(T) ? it(n, h, "whitespace")(T) : h(T));
  }
  function h(T) {
    return T === null || Ne(T) ? (n.exit("codeFencedFence"), r.interrupt ? e(T) : n.check(hx, m, C)(T)) : (n.enter("codeFencedFenceInfo"), n.enter("chunkString", {
      contentType: "string"
    }), f(T));
  }
  function f(T) {
    return T === null || Ne(T) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), h(T)) : lt(T) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), it(n, d, "whitespace")(T)) : T === 96 && T === l ? t(T) : (n.consume(T), f);
  }
  function d(T) {
    return T === null || Ne(T) ? h(T) : (n.enter("codeFencedFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), p(T));
  }
  function p(T) {
    return T === null || Ne(T) ? (n.exit("chunkString"), n.exit("codeFencedFenceMeta"), h(T)) : T === 96 && T === l ? t(T) : (n.consume(T), p);
  }
  function m(T) {
    return n.attempt(i, C, g)(T);
  }
  function g(T) {
    return n.enter("lineEnding"), n.consume(T), n.exit("lineEnding"), b;
  }
  function b(T) {
    return s > 0 && lt(T) ? it(n, w, "linePrefix", s + 1)(T) : w(T);
  }
  function w(T) {
    return T === null || Ne(T) ? n.check(hx, m, C)(T) : (n.enter("codeFlowValue"), k(T));
  }
  function k(T) {
    return T === null || Ne(T) ? (n.exit("codeFlowValue"), w(T)) : (n.consume(T), k);
  }
  function C(T) {
    return n.exit("codeFenced"), e(T);
  }
  function M(T, N, B) {
    let $ = 0;
    return R;
    function R(he) {
      return T.enter("lineEnding"), T.consume(he), T.exit("lineEnding"), V;
    }
    function V(he) {
      return T.enter("codeFencedFence"), lt(he) ? it(T, z, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(he) : z(he);
    }
    function z(he) {
      return he === l ? (T.enter("codeFencedFenceSequence"), ue(he)) : B(he);
    }
    function ue(he) {
      return he === l ? ($++, T.consume(he), ue) : $ >= o ? (T.exit("codeFencedFenceSequence"), lt(he) ? it(T, ie, "whitespace")(he) : ie(he)) : B(he);
    }
    function ie(he) {
      return he === null || Ne(he) ? (T.exit("codeFencedFence"), N(he)) : B(he);
    }
  }
}
function YV(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? t(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
const r2 = {
  name: "codeIndented",
  tokenize: XV
}, JV = {
  partial: !0,
  tokenize: ZV
};
function XV(n, e, t) {
  const r = this;
  return i;
  function i(c) {
    return n.enter("codeIndented"), it(n, s, "linePrefix", 5)(c);
  }
  function s(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : t(c);
  }
  function o(c) {
    return c === null ? a(c) : Ne(c) ? n.attempt(JV, o, a)(c) : (n.enter("codeFlowValue"), l(c));
  }
  function l(c) {
    return c === null || Ne(c) ? (n.exit("codeFlowValue"), o(c)) : (n.consume(c), l);
  }
  function a(c) {
    return n.exit("codeIndented"), e(c);
  }
}
function ZV(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? t(o) : Ne(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), i) : it(n, s, "linePrefix", 5)(o);
  }
  function s(o) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? e(o) : Ne(o) ? i(o) : t(o);
  }
}
const QV = {
  name: "codeText",
  previous: tq,
  resolve: eq,
  tokenize: nq
};
function eq(n) {
  let e = n.length - 4, t = 3, r, i;
  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {
    for (r = t; ++r < e; )
      if (n[r][1].type === "codeTextData") {
        n[t][1].type = "codeTextPadding", n[e][1].type = "codeTextPadding", t += 2, e -= 2;
        break;
      }
  }
  for (r = t - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "codeTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function tq(n) {
  return n !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function nq(n, e, t) {
  let r = 0, i, s;
  return o;
  function o(h) {
    return n.enter("codeText"), n.enter("codeTextSequence"), l(h);
  }
  function l(h) {
    return h === 96 ? (n.consume(h), r++, l) : (n.exit("codeTextSequence"), a(h));
  }
  function a(h) {
    return h === null ? t(h) : h === 32 ? (n.enter("space"), n.consume(h), n.exit("space"), a) : h === 96 ? (s = n.enter("codeTextSequence"), i = 0, u(h)) : Ne(h) ? (n.enter("lineEnding"), n.consume(h), n.exit("lineEnding"), a) : (n.enter("codeTextData"), c(h));
  }
  function c(h) {
    return h === null || h === 32 || h === 96 || Ne(h) ? (n.exit("codeTextData"), a(h)) : (n.consume(h), c);
  }
  function u(h) {
    return h === 96 ? (n.consume(h), i++, u) : i === r ? (n.exit("codeTextSequence"), n.exit("codeText"), e(h)) : (s.type = "codeTextData", c(h));
  }
}
class rq {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(e) {
    this.left = e ? [...e] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(e) {
    if (e < 0 || e >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(e, t) {
    const r = t ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(e, r) : e > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(e, t, r) {
    const i = t || 0;
    this.setCursor(Math.trunc(e));
    const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && Fu(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(e) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(e) {
    this.setCursor(Number.POSITIVE_INFINITY), Fu(this.left, e);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(e) {
    this.setCursor(0), this.right.push(e);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(e) {
    this.setCursor(0), Fu(this.right, e.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(e) {
    if (!(e === this.left.length || e > this.left.length && this.right.length === 0 || e < 0 && this.left.length === 0))
      if (e < this.left.length) {
        const t = this.left.splice(e, Number.POSITIVE_INFINITY);
        Fu(this.right, t.reverse());
      } else {
        const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
        Fu(this.left, t.reverse());
      }
  }
}
function Fu(n, e) {
  let t = 0;
  if (e.length < 1e4)
    n.push(...e);
  else
    for (; t < e.length; )
      n.push(...e.slice(t, t + 1e4)), t += 1e4;
}
function DT(n) {
  const e = {};
  let t = -1, r, i, s, o, l, a, c;
  const u = new rq(n);
  for (; ++t < u.length; ) {
    for (; t in e; )
      t = e[t];
    if (r = u.get(t), t && r[1].type === "chunkFlow" && u.get(t - 1)[1].type === "listItemPrefix" && (a = r[1]._tokenizer.events, s = 0, s < a.length && a[s][1].type === "lineEndingBlank" && (s += 2), s < a.length && a[s][1].type === "content"))
      for (; ++s < a.length && a[s][1].type !== "content"; )
        a[s][1].type === "chunkText" && (a[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(e, iq(u, t)), t = e[t], c = !0);
    else if (r[1]._container) {
      for (s = t, i = void 0; s--; )
        if (o = u.get(s), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank")
          o[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = s);
        else if (!(o[1].type === "linePrefix" || o[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...u.get(i)[1].start
      }, l = u.slice(i, t), l.unshift(r), u.splice(i, t - i + 1, l));
    }
  }
  return Jr(n, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function iq(n, e) {
  const t = n.get(e)[1], r = n.get(e)[2];
  let i = e - 1;
  const s = [];
  let o = t._tokenizer;
  o || (o = r.parser[t.contentType](t.start), t._contentTypeTextTrailing && (o._contentTypeTextTrailing = !0));
  const l = o.events, a = [], c = {};
  let u, h, f = -1, d = t, p = 0, m = 0;
  const g = [m];
  for (; d; ) {
    for (; n.get(++i)[1] !== d; )
      ;
    s.push(i), d._tokenizer || (u = r.sliceStream(d), d.next || u.push(null), h && o.defineSkip(d.start), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = d, d = d.next;
  }
  for (d = t; ++f < l.length; )
    // Find a void token that includes a break.
    l[f][0] === "exit" && l[f - 1][0] === "enter" && l[f][1].type === l[f - 1][1].type && l[f][1].start.line !== l[f][1].end.line && (m = f + 1, g.push(m), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (o.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : g.pop(), f = g.length; f--; ) {
    const b = l.slice(g[f], g[f + 1]), w = s.pop();
    a.push([w, w + b.length - 1]), n.splice(w, 2, b);
  }
  for (a.reverse(), f = -1; ++f < a.length; )
    c[p + a[f][0]] = p + a[f][1], p += a[f][1] - a[f][0] - 1;
  return c;
}
const sq = {
  resolve: lq,
  tokenize: aq
}, oq = {
  partial: !0,
  tokenize: cq
};
function lq(n) {
  return DT(n), n;
}
function aq(n, e) {
  let t;
  return r;
  function r(l) {
    return n.enter("content"), t = n.enter("chunkContent", {
      contentType: "content"
    }), i(l);
  }
  function i(l) {
    return l === null ? s(l) : Ne(l) ? n.check(oq, o, s)(l) : (n.consume(l), i);
  }
  function s(l) {
    return n.exit("chunkContent"), n.exit("content"), e(l);
  }
  function o(l) {
    return n.consume(l), n.exit("chunkContent"), t.next = n.enter("chunkContent", {
      contentType: "content",
      previous: t
    }), t = t.next, i;
  }
}
function cq(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return n.exit("chunkContent"), n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), it(n, s, "linePrefix");
  }
  function s(o) {
    if (o === null || Ne(o))
      return t(o);
    const l = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? e(o) : n.interrupt(r.parser.constructs.flow, t, e)(o);
  }
}
function NT(n, e, t, r, i, s, o, l, a) {
  const c = a || Number.POSITIVE_INFINITY;
  let u = 0;
  return h;
  function h(b) {
    return b === 60 ? (n.enter(r), n.enter(i), n.enter(s), n.consume(b), n.exit(s), f) : b === null || b === 32 || b === 41 || pm(b) ? t(b) : (n.enter(r), n.enter(o), n.enter(l), n.enter("chunkString", {
      contentType: "string"
    }), m(b));
  }
  function f(b) {
    return b === 62 ? (n.enter(s), n.consume(b), n.exit(s), n.exit(i), n.exit(r), e) : (n.enter(l), n.enter("chunkString", {
      contentType: "string"
    }), d(b));
  }
  function d(b) {
    return b === 62 ? (n.exit("chunkString"), n.exit(l), f(b)) : b === null || b === 60 || Ne(b) ? t(b) : (n.consume(b), b === 92 ? p : d);
  }
  function p(b) {
    return b === 60 || b === 62 || b === 92 ? (n.consume(b), d) : d(b);
  }
  function m(b) {
    return !u && (b === null || b === 41 || Dt(b)) ? (n.exit("chunkString"), n.exit(l), n.exit(o), n.exit(r), e(b)) : u < c && b === 40 ? (n.consume(b), u++, m) : b === 41 ? (n.consume(b), u--, m) : b === null || b === 32 || b === 40 || pm(b) ? t(b) : (n.consume(b), b === 92 ? g : m);
  }
  function g(b) {
    return b === 40 || b === 41 || b === 92 ? (n.consume(b), m) : m(b);
  }
}
function RT(n, e, t, r, i, s) {
  const o = this;
  let l = 0, a;
  return c;
  function c(d) {
    return n.enter(r), n.enter(i), n.consume(d), n.exit(i), n.enter(s), u;
  }
  function u(d) {
    return l > 999 || d === null || d === 91 || d === 93 && !a || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !l && "_hiddenFootnoteSupport" in o.parser.constructs ? t(d) : d === 93 ? (n.exit(s), n.enter(i), n.consume(d), n.exit(i), n.exit(r), e) : Ne(d) ? (n.enter("lineEnding"), n.consume(d), n.exit("lineEnding"), u) : (n.enter("chunkString", {
      contentType: "string"
    }), h(d));
  }
  function h(d) {
    return d === null || d === 91 || d === 93 || Ne(d) || l++ > 999 ? (n.exit("chunkString"), u(d)) : (n.consume(d), a || (a = !lt(d)), d === 92 ? f : h);
  }
  function f(d) {
    return d === 91 || d === 92 || d === 93 ? (n.consume(d), l++, h) : h(d);
  }
}
function PT(n, e, t, r, i, s) {
  let o;
  return l;
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? (n.enter(r), n.enter(i), n.consume(f), n.exit(i), o = f === 40 ? 41 : f, a) : t(f);
  }
  function a(f) {
    return f === o ? (n.enter(i), n.consume(f), n.exit(i), n.exit(r), e) : (n.enter(s), c(f));
  }
  function c(f) {
    return f === o ? (n.exit(s), a(o)) : f === null ? t(f) : Ne(f) ? (n.enter("lineEnding"), n.consume(f), n.exit("lineEnding"), it(n, c, "linePrefix")) : (n.enter("chunkString", {
      contentType: "string"
    }), u(f));
  }
  function u(f) {
    return f === o || f === null || Ne(f) ? (n.exit("chunkString"), c(f)) : (n.consume(f), f === 92 ? h : u);
  }
  function h(f) {
    return f === o || f === 92 ? (n.consume(f), u) : u(f);
  }
}
function jh(n, e) {
  let t;
  return r;
  function r(i) {
    return Ne(i) ? (n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), t = !0, r) : lt(i) ? it(n, r, t ? "linePrefix" : "lineSuffix")(i) : e(i);
  }
}
const uq = {
  name: "definition",
  tokenize: fq
}, hq = {
  partial: !0,
  tokenize: dq
};
function fq(n, e, t) {
  const r = this;
  let i;
  return s;
  function s(d) {
    return n.enter("definition"), o(d);
  }
  function o(d) {
    return RT.call(
      r,
      n,
      l,
      // Note: we don’t need to reset the way `markdown-rs` does.
      t,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function l(d) {
    return i = Ri(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), d === 58 ? (n.enter("definitionMarker"), n.consume(d), n.exit("definitionMarker"), a) : t(d);
  }
  function a(d) {
    return Dt(d) ? jh(n, c)(d) : c(d);
  }
  function c(d) {
    return NT(
      n,
      u,
      // Note: we don’t need to reset the way `markdown-rs` does.
      t,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function u(d) {
    return n.attempt(hq, h, h)(d);
  }
  function h(d) {
    return lt(d) ? it(n, f, "whitespace")(d) : f(d);
  }
  function f(d) {
    return d === null || Ne(d) ? (n.exit("definition"), r.parser.defined.push(i), e(d)) : t(d);
  }
}
function dq(n, e, t) {
  return r;
  function r(l) {
    return Dt(l) ? jh(n, i)(l) : t(l);
  }
  function i(l) {
    return PT(n, s, t, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(l);
  }
  function s(l) {
    return lt(l) ? it(n, o, "whitespace")(l) : o(l);
  }
  function o(l) {
    return l === null || Ne(l) ? e(l) : t(l);
  }
}
const pq = {
  name: "hardBreakEscape",
  tokenize: mq
};
function mq(n, e, t) {
  return r;
  function r(s) {
    return n.enter("hardBreakEscape"), n.consume(s), i;
  }
  function i(s) {
    return Ne(s) ? (n.exit("hardBreakEscape"), e(s)) : t(s);
  }
}
const gq = {
  name: "headingAtx",
  resolve: yq,
  tokenize: bq
};
function yq(n, e) {
  let t = n.length - 2, r = 3, i, s;
  return n[r][1].type === "whitespace" && (r += 2), t - 2 > r && n[t][1].type === "whitespace" && (t -= 2), n[t][1].type === "atxHeadingSequence" && (r === t - 1 || t - 4 > r && n[t - 2][1].type === "whitespace") && (t -= r + 1 === t ? 2 : 4), t > r && (i = {
    type: "atxHeadingText",
    start: n[r][1].start,
    end: n[t][1].end
  }, s = {
    type: "chunkText",
    start: n[r][1].start,
    end: n[t][1].end,
    contentType: "text"
  }, Jr(n, r, t - r + 1, [["enter", i, e], ["enter", s, e], ["exit", s, e], ["exit", i, e]])), n;
}
function bq(n, e, t) {
  let r = 0;
  return i;
  function i(u) {
    return n.enter("atxHeading"), s(u);
  }
  function s(u) {
    return n.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (n.consume(u), o) : u === null || Dt(u) ? (n.exit("atxHeadingSequence"), l(u)) : t(u);
  }
  function l(u) {
    return u === 35 ? (n.enter("atxHeadingSequence"), a(u)) : u === null || Ne(u) ? (n.exit("atxHeading"), e(u)) : lt(u) ? it(n, l, "whitespace")(u) : (n.enter("atxHeadingText"), c(u));
  }
  function a(u) {
    return u === 35 ? (n.consume(u), a) : (n.exit("atxHeadingSequence"), l(u));
  }
  function c(u) {
    return u === null || u === 35 || Dt(u) ? (n.exit("atxHeadingText"), l(u)) : (n.consume(u), c);
  }
}
const vq = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], dx = ["pre", "script", "style", "textarea"], wq = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: Sq,
  tokenize: Cq
}, xq = {
  partial: !0,
  tokenize: Tq
}, kq = {
  partial: !0,
  tokenize: Mq
};
function Sq(n) {
  let e = n.length;
  for (; e-- && !(n[e][0] === "enter" && n[e][1].type === "htmlFlow"); )
    ;
  return e > 1 && n[e - 2][1].type === "linePrefix" && (n[e][1].start = n[e - 2][1].start, n[e + 1][1].start = n[e - 2][1].start, n.splice(e - 2, 2)), n;
}
function Cq(n, e, t) {
  const r = this;
  let i, s, o, l, a;
  return c;
  function c(O) {
    return u(O);
  }
  function u(O) {
    return n.enter("htmlFlow"), n.enter("htmlFlowData"), n.consume(O), h;
  }
  function h(O) {
    return O === 33 ? (n.consume(O), f) : O === 47 ? (n.consume(O), s = !0, m) : O === 63 ? (n.consume(O), i = 3, r.interrupt ? e : I) : lr(O) ? (n.consume(O), o = String.fromCharCode(O), g) : t(O);
  }
  function f(O) {
    return O === 45 ? (n.consume(O), i = 2, d) : O === 91 ? (n.consume(O), i = 5, l = 0, p) : lr(O) ? (n.consume(O), i = 4, r.interrupt ? e : I) : t(O);
  }
  function d(O) {
    return O === 45 ? (n.consume(O), r.interrupt ? e : I) : t(O);
  }
  function p(O) {
    const dt = "CDATA[";
    return O === dt.charCodeAt(l++) ? (n.consume(O), l === dt.length ? r.interrupt ? e : z : p) : t(O);
  }
  function m(O) {
    return lr(O) ? (n.consume(O), o = String.fromCharCode(O), g) : t(O);
  }
  function g(O) {
    if (O === null || O === 47 || O === 62 || Dt(O)) {
      const dt = O === 47, Ue = o.toLowerCase();
      return !dt && !s && dx.includes(Ue) ? (i = 1, r.interrupt ? e(O) : z(O)) : vq.includes(o.toLowerCase()) ? (i = 6, dt ? (n.consume(O), b) : r.interrupt ? e(O) : z(O)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? t(O) : s ? w(O) : k(O));
    }
    return O === 45 || Tr(O) ? (n.consume(O), o += String.fromCharCode(O), g) : t(O);
  }
  function b(O) {
    return O === 62 ? (n.consume(O), r.interrupt ? e : z) : t(O);
  }
  function w(O) {
    return lt(O) ? (n.consume(O), w) : R(O);
  }
  function k(O) {
    return O === 47 ? (n.consume(O), R) : O === 58 || O === 95 || lr(O) ? (n.consume(O), C) : lt(O) ? (n.consume(O), k) : R(O);
  }
  function C(O) {
    return O === 45 || O === 46 || O === 58 || O === 95 || Tr(O) ? (n.consume(O), C) : M(O);
  }
  function M(O) {
    return O === 61 ? (n.consume(O), T) : lt(O) ? (n.consume(O), M) : k(O);
  }
  function T(O) {
    return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? t(O) : O === 34 || O === 39 ? (n.consume(O), a = O, N) : lt(O) ? (n.consume(O), T) : B(O);
  }
  function N(O) {
    return O === a ? (n.consume(O), a = null, $) : O === null || Ne(O) ? t(O) : (n.consume(O), N);
  }
  function B(O) {
    return O === null || O === 34 || O === 39 || O === 47 || O === 60 || O === 61 || O === 62 || O === 96 || Dt(O) ? M(O) : (n.consume(O), B);
  }
  function $(O) {
    return O === 47 || O === 62 || lt(O) ? k(O) : t(O);
  }
  function R(O) {
    return O === 62 ? (n.consume(O), V) : t(O);
  }
  function V(O) {
    return O === null || Ne(O) ? z(O) : lt(O) ? (n.consume(O), V) : t(O);
  }
  function z(O) {
    return O === 45 && i === 2 ? (n.consume(O), Se) : O === 60 && i === 1 ? (n.consume(O), ge) : O === 62 && i === 4 ? (n.consume(O), Ie) : O === 63 && i === 3 ? (n.consume(O), I) : O === 93 && i === 5 ? (n.consume(O), ze) : Ne(O) && (i === 6 || i === 7) ? (n.exit("htmlFlowData"), n.check(xq, Ve, ue)(O)) : O === null || Ne(O) ? (n.exit("htmlFlowData"), ue(O)) : (n.consume(O), z);
  }
  function ue(O) {
    return n.check(kq, ie, Ve)(O);
  }
  function ie(O) {
    return n.enter("lineEnding"), n.consume(O), n.exit("lineEnding"), he;
  }
  function he(O) {
    return O === null || Ne(O) ? ue(O) : (n.enter("htmlFlowData"), z(O));
  }
  function Se(O) {
    return O === 45 ? (n.consume(O), I) : z(O);
  }
  function ge(O) {
    return O === 47 ? (n.consume(O), o = "", ye) : z(O);
  }
  function ye(O) {
    if (O === 62) {
      const dt = o.toLowerCase();
      return dx.includes(dt) ? (n.consume(O), Ie) : z(O);
    }
    return lr(O) && o.length < 8 ? (n.consume(O), o += String.fromCharCode(O), ye) : z(O);
  }
  function ze(O) {
    return O === 93 ? (n.consume(O), I) : z(O);
  }
  function I(O) {
    return O === 62 ? (n.consume(O), Ie) : O === 45 && i === 2 ? (n.consume(O), I) : z(O);
  }
  function Ie(O) {
    return O === null || Ne(O) ? (n.exit("htmlFlowData"), Ve(O)) : (n.consume(O), Ie);
  }
  function Ve(O) {
    return n.exit("htmlFlow"), e(O);
  }
}
function Mq(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return Ne(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s) : t(o);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
function Tq(n, e, t) {
  return r;
  function r(i) {
    return n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), n.attempt(fd, e, t);
  }
}
const Aq = {
  name: "htmlText",
  tokenize: Oq
};
function Oq(n, e, t) {
  const r = this;
  let i, s, o;
  return l;
  function l(I) {
    return n.enter("htmlText"), n.enter("htmlTextData"), n.consume(I), a;
  }
  function a(I) {
    return I === 33 ? (n.consume(I), c) : I === 47 ? (n.consume(I), M) : I === 63 ? (n.consume(I), k) : lr(I) ? (n.consume(I), B) : t(I);
  }
  function c(I) {
    return I === 45 ? (n.consume(I), u) : I === 91 ? (n.consume(I), s = 0, p) : lr(I) ? (n.consume(I), w) : t(I);
  }
  function u(I) {
    return I === 45 ? (n.consume(I), d) : t(I);
  }
  function h(I) {
    return I === null ? t(I) : I === 45 ? (n.consume(I), f) : Ne(I) ? (o = h, ge(I)) : (n.consume(I), h);
  }
  function f(I) {
    return I === 45 ? (n.consume(I), d) : h(I);
  }
  function d(I) {
    return I === 62 ? Se(I) : I === 45 ? f(I) : h(I);
  }
  function p(I) {
    const Ie = "CDATA[";
    return I === Ie.charCodeAt(s++) ? (n.consume(I), s === Ie.length ? m : p) : t(I);
  }
  function m(I) {
    return I === null ? t(I) : I === 93 ? (n.consume(I), g) : Ne(I) ? (o = m, ge(I)) : (n.consume(I), m);
  }
  function g(I) {
    return I === 93 ? (n.consume(I), b) : m(I);
  }
  function b(I) {
    return I === 62 ? Se(I) : I === 93 ? (n.consume(I), b) : m(I);
  }
  function w(I) {
    return I === null || I === 62 ? Se(I) : Ne(I) ? (o = w, ge(I)) : (n.consume(I), w);
  }
  function k(I) {
    return I === null ? t(I) : I === 63 ? (n.consume(I), C) : Ne(I) ? (o = k, ge(I)) : (n.consume(I), k);
  }
  function C(I) {
    return I === 62 ? Se(I) : k(I);
  }
  function M(I) {
    return lr(I) ? (n.consume(I), T) : t(I);
  }
  function T(I) {
    return I === 45 || Tr(I) ? (n.consume(I), T) : N(I);
  }
  function N(I) {
    return Ne(I) ? (o = N, ge(I)) : lt(I) ? (n.consume(I), N) : Se(I);
  }
  function B(I) {
    return I === 45 || Tr(I) ? (n.consume(I), B) : I === 47 || I === 62 || Dt(I) ? $(I) : t(I);
  }
  function $(I) {
    return I === 47 ? (n.consume(I), Se) : I === 58 || I === 95 || lr(I) ? (n.consume(I), R) : Ne(I) ? (o = $, ge(I)) : lt(I) ? (n.consume(I), $) : Se(I);
  }
  function R(I) {
    return I === 45 || I === 46 || I === 58 || I === 95 || Tr(I) ? (n.consume(I), R) : V(I);
  }
  function V(I) {
    return I === 61 ? (n.consume(I), z) : Ne(I) ? (o = V, ge(I)) : lt(I) ? (n.consume(I), V) : $(I);
  }
  function z(I) {
    return I === null || I === 60 || I === 61 || I === 62 || I === 96 ? t(I) : I === 34 || I === 39 ? (n.consume(I), i = I, ue) : Ne(I) ? (o = z, ge(I)) : lt(I) ? (n.consume(I), z) : (n.consume(I), ie);
  }
  function ue(I) {
    return I === i ? (n.consume(I), i = void 0, he) : I === null ? t(I) : Ne(I) ? (o = ue, ge(I)) : (n.consume(I), ue);
  }
  function ie(I) {
    return I === null || I === 34 || I === 39 || I === 60 || I === 61 || I === 96 ? t(I) : I === 47 || I === 62 || Dt(I) ? $(I) : (n.consume(I), ie);
  }
  function he(I) {
    return I === 47 || I === 62 || Dt(I) ? $(I) : t(I);
  }
  function Se(I) {
    return I === 62 ? (n.consume(I), n.exit("htmlTextData"), n.exit("htmlText"), e) : t(I);
  }
  function ge(I) {
    return n.exit("htmlTextData"), n.enter("lineEnding"), n.consume(I), n.exit("lineEnding"), ye;
  }
  function ye(I) {
    return lt(I) ? it(n, ze, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(I) : ze(I);
  }
  function ze(I) {
    return n.enter("htmlTextData"), o(I);
  }
}
const B3 = {
  name: "labelEnd",
  resolveAll: Nq,
  resolveTo: Rq,
  tokenize: Pq
}, Eq = {
  tokenize: _q
}, Iq = {
  tokenize: Lq
}, Dq = {
  tokenize: Bq
};
function Nq(n) {
  let e = -1;
  const t = [];
  for (; ++e < n.length; ) {
    const r = n[e][1];
    if (t.push(n[e]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", e += i;
    }
  }
  return n.length !== t.length && Jr(n, 0, n.length, t), n;
}
function Rq(n, e) {
  let t = n.length, r = 0, i, s, o, l;
  for (; t--; )
    if (i = n[t][1], s) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      n[t][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (n[t][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = t, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (o = t);
  const a = {
    type: n[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...n[s][1].start
    },
    end: {
      ...n[n.length - 1][1].end
    }
  }, c = {
    type: "label",
    start: {
      ...n[s][1].start
    },
    end: {
      ...n[o][1].end
    }
  }, u = {
    type: "labelText",
    start: {
      ...n[s + r + 2][1].end
    },
    end: {
      ...n[o - 2][1].start
    }
  };
  return l = [["enter", a, e], ["enter", c, e]], l = oi(l, n.slice(s + 1, s + r + 3)), l = oi(l, [["enter", u, e]]), l = oi(l, w1(e.parser.constructs.insideSpan.null, n.slice(s + r + 4, o - 3), e)), l = oi(l, [["exit", u, e], n[o - 2], n[o - 1], ["exit", c, e]]), l = oi(l, n.slice(o + 1)), l = oi(l, [["exit", a, e]]), Jr(n, s, n.length, l), n;
}
function Pq(n, e, t) {
  const r = this;
  let i = r.events.length, s, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return l;
  function l(f) {
    return s ? s._inactive ? h(f) : (o = r.parser.defined.includes(Ri(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), n.enter("labelEnd"), n.enter("labelMarker"), n.consume(f), n.exit("labelMarker"), n.exit("labelEnd"), a) : t(f);
  }
  function a(f) {
    return f === 40 ? n.attempt(Eq, u, o ? u : h)(f) : f === 91 ? n.attempt(Iq, u, o ? c : h)(f) : o ? u(f) : h(f);
  }
  function c(f) {
    return n.attempt(Dq, u, h)(f);
  }
  function u(f) {
    return e(f);
  }
  function h(f) {
    return s._balanced = !0, t(f);
  }
}
function _q(n, e, t) {
  return r;
  function r(h) {
    return n.enter("resource"), n.enter("resourceMarker"), n.consume(h), n.exit("resourceMarker"), i;
  }
  function i(h) {
    return Dt(h) ? jh(n, s)(h) : s(h);
  }
  function s(h) {
    return h === 41 ? u(h) : NT(n, o, l, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function o(h) {
    return Dt(h) ? jh(n, a)(h) : u(h);
  }
  function l(h) {
    return t(h);
  }
  function a(h) {
    return h === 34 || h === 39 || h === 40 ? PT(n, c, t, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : u(h);
  }
  function c(h) {
    return Dt(h) ? jh(n, u)(h) : u(h);
  }
  function u(h) {
    return h === 41 ? (n.enter("resourceMarker"), n.consume(h), n.exit("resourceMarker"), n.exit("resource"), e) : t(h);
  }
}
function Lq(n, e, t) {
  const r = this;
  return i;
  function i(l) {
    return RT.call(r, n, s, o, "reference", "referenceMarker", "referenceString")(l);
  }
  function s(l) {
    return r.parser.defined.includes(Ri(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(l) : t(l);
  }
  function o(l) {
    return t(l);
  }
}
function Bq(n, e, t) {
  return r;
  function r(s) {
    return n.enter("reference"), n.enter("referenceMarker"), n.consume(s), n.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (n.enter("referenceMarker"), n.consume(s), n.exit("referenceMarker"), n.exit("reference"), e) : t(s);
  }
}
const zq = {
  name: "labelStartImage",
  resolveAll: B3.resolveAll,
  tokenize: Fq
};
function Fq(n, e, t) {
  const r = this;
  return i;
  function i(l) {
    return n.enter("labelImage"), n.enter("labelImageMarker"), n.consume(l), n.exit("labelImageMarker"), s;
  }
  function s(l) {
    return l === 91 ? (n.enter("labelMarker"), n.consume(l), n.exit("labelMarker"), n.exit("labelImage"), o) : t(l);
  }
  function o(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(l) : e(l);
  }
}
const Hq = {
  name: "labelStartLink",
  resolveAll: B3.resolveAll,
  tokenize: $q
};
function $q(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return n.enter("labelLink"), n.enter("labelMarker"), n.consume(o), n.exit("labelMarker"), n.exit("labelLink"), s;
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(o) : e(o);
  }
}
const i2 = {
  name: "lineEnding",
  tokenize: Vq
};
function Vq(n, e) {
  return t;
  function t(r) {
    return n.enter("lineEnding"), n.consume(r), n.exit("lineEnding"), it(n, e, "linePrefix");
  }
}
const ip = {
  name: "thematicBreak",
  tokenize: qq
};
function qq(n, e, t) {
  let r = 0, i;
  return s;
  function s(c) {
    return n.enter("thematicBreak"), o(c);
  }
  function o(c) {
    return i = c, l(c);
  }
  function l(c) {
    return c === i ? (n.enter("thematicBreakSequence"), a(c)) : r >= 3 && (c === null || Ne(c)) ? (n.exit("thematicBreak"), e(c)) : t(c);
  }
  function a(c) {
    return c === i ? (n.consume(c), r++, a) : (n.exit("thematicBreakSequence"), lt(c) ? it(n, l, "whitespace")(c) : l(c));
  }
}
const vr = {
  continuation: {
    tokenize: Kq
  },
  exit: Yq,
  name: "list",
  tokenize: Uq
}, Wq = {
  partial: !0,
  tokenize: Jq
}, jq = {
  partial: !0,
  tokenize: Gq
};
function Uq(n, e, t) {
  const r = this, i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return l;
  function l(d) {
    const p = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (p === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : Ay(d)) {
      if (r.containerState.type || (r.containerState.type = p, n.enter(p, {
        _container: !0
      })), p === "listUnordered")
        return n.enter("listItemPrefix"), d === 42 || d === 45 ? n.check(ip, t, c)(d) : c(d);
      if (!r.interrupt || d === 49)
        return n.enter("listItemPrefix"), n.enter("listItemValue"), a(d);
    }
    return t(d);
  }
  function a(d) {
    return Ay(d) && ++o < 10 ? (n.consume(d), a) : (!r.interrupt || o < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (n.exit("listItemValue"), c(d)) : t(d);
  }
  function c(d) {
    return n.enter("listItemMarker"), n.consume(d), n.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, n.check(
      fd,
      // Can’t be empty when interrupting.
      r.interrupt ? t : u,
      n.attempt(Wq, f, h)
    );
  }
  function u(d) {
    return r.containerState.initialBlankLine = !0, s++, f(d);
  }
  function h(d) {
    return lt(d) ? (n.enter("listItemPrefixWhitespace"), n.consume(d), n.exit("listItemPrefixWhitespace"), f) : t(d);
  }
  function f(d) {
    return r.containerState.size = s + r.sliceSerialize(n.exit("listItemPrefix"), !0).length, e(d);
  }
}
function Kq(n, e, t) {
  const r = this;
  return r.containerState._closeFlow = void 0, n.check(fd, i, s);
  function i(l) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, it(n, e, "listItemIndent", r.containerState.size + 1)(l);
  }
  function s(l) {
    return r.containerState.furtherBlankLines || !lt(l) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(l)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, n.attempt(jq, e, o)(l));
  }
  function o(l) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, it(n, n.attempt(vr, e, t), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l);
  }
}
function Gq(n, e, t) {
  const r = this;
  return it(n, i, "listItemIndent", r.containerState.size + 1);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(s) : t(s);
  }
}
function Yq(n) {
  n.exit(this.containerState.type);
}
function Jq(n, e, t) {
  const r = this;
  return it(n, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return !lt(s) && o && o[1].type === "listItemPrefixWhitespace" ? e(s) : t(s);
  }
}
const px = {
  name: "setextUnderline",
  resolveTo: Xq,
  tokenize: Zq
};
function Xq(n, e) {
  let t = n.length, r, i, s;
  for (; t--; )
    if (n[t][0] === "enter") {
      if (n[t][1].type === "content") {
        r = t;
        break;
      }
      n[t][1].type === "paragraph" && (i = t);
    } else
      n[t][1].type === "content" && n.splice(t, 1), !s && n[t][1].type === "definition" && (s = t);
  const o = {
    type: "setextHeading",
    start: {
      ...n[r][1].start
    },
    end: {
      ...n[n.length - 1][1].end
    }
  };
  return n[i][1].type = "setextHeadingText", s ? (n.splice(i, 0, ["enter", o, e]), n.splice(s + 1, 0, ["exit", n[r][1], e]), n[r][1].end = {
    ...n[s][1].end
  }) : n[r][1] = o, n.push(["exit", o, e]), n;
}
function Zq(n, e, t) {
  const r = this;
  let i;
  return s;
  function s(c) {
    let u = r.events.length, h;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        h = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (n.enter("setextHeadingLine"), i = c, o(c)) : t(c);
  }
  function o(c) {
    return n.enter("setextHeadingLineSequence"), l(c);
  }
  function l(c) {
    return c === i ? (n.consume(c), l) : (n.exit("setextHeadingLineSequence"), lt(c) ? it(n, a, "lineSuffix")(c) : a(c));
  }
  function a(c) {
    return c === null || Ne(c) ? (n.exit("setextHeadingLine"), e(c)) : t(c);
  }
}
const Qq = {
  tokenize: eW
};
function eW(n) {
  const e = this, t = n.attempt(
    // Try to parse a blank line.
    fd,
    r,
    // Try to parse initial flow (essentially, only code).
    n.attempt(this.parser.constructs.flowInitial, i, it(n, n.attempt(this.parser.constructs.flow, i, n.attempt(sq, i)), "linePrefix"))
  );
  return t;
  function r(s) {
    if (s === null) {
      n.consume(s);
      return;
    }
    return n.enter("lineEndingBlank"), n.consume(s), n.exit("lineEndingBlank"), e.currentConstruct = void 0, t;
  }
  function i(s) {
    if (s === null) {
      n.consume(s);
      return;
    }
    return n.enter("lineEnding"), n.consume(s), n.exit("lineEnding"), e.currentConstruct = void 0, t;
  }
}
const tW = {
  resolveAll: LT()
}, nW = _T("string"), rW = _T("text");
function _T(n) {
  return {
    resolveAll: LT(n === "text" ? iW : void 0),
    tokenize: e
  };
  function e(t) {
    const r = this, i = this.parser.constructs[n], s = t.attempt(i, o, l);
    return o;
    function o(u) {
      return c(u) ? s(u) : l(u);
    }
    function l(u) {
      if (u === null) {
        t.consume(u);
        return;
      }
      return t.enter("data"), t.consume(u), a;
    }
    function a(u) {
      return c(u) ? (t.exit("data"), s(u)) : (t.consume(u), a);
    }
    function c(u) {
      if (u === null)
        return !0;
      const h = i[u];
      let f = -1;
      if (h)
        for (; ++f < h.length; ) {
          const d = h[f];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function LT(n) {
  return e;
  function e(t, r) {
    let i = -1, s;
    for (; ++i <= t.length; )
      s === void 0 ? t[i] && t[i][1].type === "data" && (s = i, i++) : (!t[i] || t[i][1].type !== "data") && (i !== s + 2 && (t[s][1].end = t[i - 1][1].end, t.splice(s + 2, i - s - 2), i = s + 2), s = void 0);
    return n ? n(t, r) : t;
  }
}
function iW(n, e) {
  let t = 0;
  for (; ++t <= n.length; )
    if ((t === n.length || n[t][1].type === "lineEnding") && n[t - 1][1].type === "data") {
      const r = n[t - 1][1], i = e.sliceStream(r);
      let s = i.length, o = -1, l = 0, a;
      for (; s--; ) {
        const c = i[s];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; )
            l++, o--;
          if (o) break;
          o = -1;
        } else if (c === -2)
          a = !0, l++;
        else if (c !== -1) {
          s++;
          break;
        }
      }
      if (e._contentTypeTextTrailing && t === n.length && (l = 0), l) {
        const c = {
          type: t === n.length || a || l < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? o : r.start._bufferIndex + o,
            _index: r.start._index + s,
            line: r.end.line,
            column: r.end.column - l,
            offset: r.end.offset - l
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...c.start
        }, r.start.offset === r.end.offset ? Object.assign(r, c) : (n.splice(t, 0, ["enter", c, e], ["exit", c, e]), t += 2);
      }
      t++;
    }
  return n;
}
const sW = {
  42: vr,
  43: vr,
  45: vr,
  48: vr,
  49: vr,
  50: vr,
  51: vr,
  52: vr,
  53: vr,
  54: vr,
  55: vr,
  56: vr,
  57: vr,
  62: OT
}, oW = {
  91: uq
}, lW = {
  [-2]: r2,
  [-1]: r2,
  32: r2
}, aW = {
  35: gq,
  42: ip,
  45: [px, ip],
  60: wq,
  61: px,
  95: ip,
  96: fx,
  126: fx
}, cW = {
  38: IT,
  92: ET
}, uW = {
  [-5]: i2,
  [-4]: i2,
  [-3]: i2,
  33: zq,
  38: IT,
  42: Oy,
  60: [HV, Aq],
  91: Hq,
  92: [pq, ET],
  93: B3,
  95: Oy,
  96: QV
}, hW = {
  null: [Oy, tW]
}, fW = {
  null: [42, 95]
}, dW = {
  null: []
}, pW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: fW,
  contentInitial: oW,
  disable: dW,
  document: sW,
  flow: aW,
  flowInitial: lW,
  insideSpan: hW,
  string: cW,
  text: uW
}, Symbol.toStringTag, { value: "Module" }));
function mW(n, e, t) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: t && t.line || 1,
    column: t && t.column || 1,
    offset: t && t.offset || 0
  };
  const i = {}, s = [];
  let o = [], l = [];
  const a = {
    attempt: N(M),
    check: N(T),
    consume: w,
    enter: k,
    exit: C,
    interrupt: N(T, {
      interrupt: !0
    })
  }, c = {
    code: null,
    containerState: {},
    defineSkip: m,
    events: [],
    now: p,
    parser: n,
    previous: null,
    sliceSerialize: f,
    sliceStream: d,
    write: h
  };
  let u = e.tokenize.call(c, a);
  return e.resolveAll && s.push(e), c;
  function h(V) {
    return o = oi(o, V), g(), o[o.length - 1] !== null ? [] : (B(e, 0), c.events = w1(s, c.events, c), c.events);
  }
  function f(V, z) {
    return yW(d(V), z);
  }
  function d(V) {
    return gW(o, V);
  }
  function p() {
    const {
      _bufferIndex: V,
      _index: z,
      line: ue,
      column: ie,
      offset: he
    } = r;
    return {
      _bufferIndex: V,
      _index: z,
      line: ue,
      column: ie,
      offset: he
    };
  }
  function m(V) {
    i[V.line] = V.column, R();
  }
  function g() {
    let V;
    for (; r._index < o.length; ) {
      const z = o[r._index];
      if (typeof z == "string")
        for (V = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === V && r._bufferIndex < z.length; )
          b(z.charCodeAt(r._bufferIndex));
      else
        b(z);
    }
  }
  function b(V) {
    u = u(V);
  }
  function w(V) {
    Ne(V) ? (r.line++, r.column = 1, r.offset += V === -3 ? 2 : 1, R()) : V !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = V;
  }
  function k(V, z) {
    const ue = z || {};
    return ue.type = V, ue.start = p(), c.events.push(["enter", ue, c]), l.push(ue), ue;
  }
  function C(V) {
    const z = l.pop();
    return z.end = p(), c.events.push(["exit", z, c]), z;
  }
  function M(V, z) {
    B(V, z.from);
  }
  function T(V, z) {
    z.restore();
  }
  function N(V, z) {
    return ue;
    function ue(ie, he, Se) {
      let ge, ye, ze, I;
      return Array.isArray(ie) ? (
        /* c8 ignore next 1 */
        Ve(ie)
      ) : "tokenize" in ie ? (
        // Looks like a construct.
        Ve([
          /** @type {Construct} */
          ie
        ])
      ) : Ie(ie);
      function Ie(et) {
        return Mt;
        function Mt(Ft) {
          const sn = Ft !== null && et[Ft], Gt = Ft !== null && et.null, _r = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(sn) ? sn : sn ? [sn] : [],
            ...Array.isArray(Gt) ? Gt : Gt ? [Gt] : []
          ];
          return Ve(_r)(Ft);
        }
      }
      function Ve(et) {
        return ge = et, ye = 0, et.length === 0 ? Se : O(et[ye]);
      }
      function O(et) {
        return Mt;
        function Mt(Ft) {
          return I = $(), ze = et, et.partial || (c.currentConstruct = et), et.name && c.parser.constructs.disable.null.includes(et.name) ? Ue() : et.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            z ? Object.assign(Object.create(c), z) : c,
            a,
            dt,
            Ue
          )(Ft);
        }
      }
      function dt(et) {
        return V(ze, I), he;
      }
      function Ue(et) {
        return I.restore(), ++ye < ge.length ? O(ge[ye]) : Se;
      }
    }
  }
  function B(V, z) {
    V.resolveAll && !s.includes(V) && s.push(V), V.resolve && Jr(c.events, z, c.events.length - z, V.resolve(c.events.slice(z), c)), V.resolveTo && (c.events = V.resolveTo(c.events, c));
  }
  function $() {
    const V = p(), z = c.previous, ue = c.currentConstruct, ie = c.events.length, he = Array.from(l);
    return {
      from: ie,
      restore: Se
    };
    function Se() {
      r = V, c.previous = z, c.currentConstruct = ue, c.events.length = ie, l = he, R();
    }
  }
  function R() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function gW(n, e) {
  const t = e.start._index, r = e.start._bufferIndex, i = e.end._index, s = e.end._bufferIndex;
  let o;
  if (t === i)
    o = [n[t].slice(r, s)];
  else {
    if (o = n.slice(t, i), r > -1) {
      const l = o[0];
      typeof l == "string" ? o[0] = l.slice(r) : o.shift();
    }
    s > 0 && o.push(n[i].slice(0, s));
  }
  return o;
}
function yW(n, e) {
  let t = -1;
  const r = [];
  let i;
  for (; ++t < n.length; ) {
    const s = n[t];
    let o;
    if (typeof s == "string")
      o = s;
    else switch (s) {
      case -5: {
        o = "\r";
        break;
      }
      case -4: {
        o = `
`;
        break;
      }
      case -3: {
        o = `\r
`;
        break;
      }
      case -2: {
        o = e ? " " : "	";
        break;
      }
      case -1: {
        if (!e && i) continue;
        o = " ";
        break;
      }
      default:
        o = String.fromCharCode(s);
    }
    i = s === -2, r.push(o);
  }
  return r.join("");
}
function bW(n) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      TT([pW, ...(n || {}).extensions || []])
    ),
    content: i(RV),
    defined: [],
    document: i(_V),
    flow: i(Qq),
    lazy: {},
    string: i(nW),
    text: i(rW)
  };
  return r;
  function i(s) {
    return o;
    function o(l) {
      return mW(r, s, l);
    }
  }
}
function vW(n) {
  for (; !DT(n); )
    ;
  return n;
}
const mx = /[\0\t\n\r]/g;
function wW() {
  let n = 1, e = "", t = !0, r;
  return i;
  function i(s, o, l) {
    const a = [];
    let c, u, h, f, d;
    for (s = e + (typeof s == "string" ? s.toString() : new TextDecoder(o || void 0).decode(s)), h = 0, e = "", t && (s.charCodeAt(0) === 65279 && h++, t = void 0); h < s.length; ) {
      if (mx.lastIndex = h, c = mx.exec(s), f = c && c.index !== void 0 ? c.index : s.length, d = s.charCodeAt(f), !c) {
        e = s.slice(h);
        break;
      }
      if (d === 10 && h === f && r)
        a.push(-3), r = void 0;
      else
        switch (r && (a.push(-5), r = void 0), h < f && (a.push(s.slice(h, f)), n += f - h), d) {
          case 0: {
            a.push(65533), n++;
            break;
          }
          case 9: {
            for (u = Math.ceil(n / 4) * 4, a.push(-2); n++ < u; ) a.push(-1);
            break;
          }
          case 10: {
            a.push(-4), n = 1;
            break;
          }
          default:
            r = !0, n = 1;
        }
      h = f + 1;
    }
    return l && (r && a.push(-5), e && a.push(e), a.push(null)), a;
  }
}
const xW = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function BT(n) {
  return n.replace(xW, kW);
}
function kW(n, e, t) {
  if (e)
    return e;
  if (t.charCodeAt(0) === 35) {
    const i = t.charCodeAt(1), s = i === 120 || i === 88;
    return AT(t.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return L3(t) || n;
}
function Uh(n) {
  return !n || typeof n != "object" ? "" : "position" in n || "type" in n ? gx(n.position) : "start" in n || "end" in n ? gx(n) : "line" in n || "column" in n ? Ey(n) : "";
}
function Ey(n) {
  return yx(n && n.line) + ":" + yx(n && n.column);
}
function gx(n) {
  return Ey(n && n.start) + "-" + Ey(n && n.end);
}
function yx(n) {
  return n && typeof n == "number" ? n : 1;
}
const zT = {}.hasOwnProperty;
function SW(n, e, t) {
  return typeof e != "string" && (t = e, e = void 0), CW(t)(vW(bW(t).document().write(wW()(n, e, !0))));
}
function CW(n) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(re),
      autolinkProtocol: $,
      autolinkEmail: $,
      atxHeading: s(Q),
      blockQuote: s(Gt),
      characterEscape: $,
      characterReference: $,
      codeFenced: s(_r),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: s(_r, o),
      codeText: s(E, o),
      codeTextData: $,
      data: $,
      codeFlowValue: $,
      definition: s(P),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: s(W),
      hardBreakEscape: s(J),
      hardBreakTrailing: s(J),
      htmlFlow: s(Y, o),
      htmlFlowData: $,
      htmlText: s(Y, o),
      htmlTextData: $,
      image: s(ae),
      label: o,
      link: s(re),
      listItem: s(te),
      listItemValue: f,
      listOrdered: s(oe, h),
      listUnordered: s(oe),
      paragraph: s(De),
      reference: O,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: s(Q),
      strong: s(de),
      thematicBreak: s(Pe)
    },
    exit: {
      atxHeading: a(),
      atxHeadingSequence: M,
      autolink: a(),
      autolinkEmail: sn,
      autolinkProtocol: Ft,
      blockQuote: a(),
      characterEscapeValue: R,
      characterReferenceMarkerHexadecimal: Ue,
      characterReferenceMarkerNumeric: Ue,
      characterReferenceValue: et,
      characterReference: Mt,
      codeFenced: a(g),
      codeFencedFence: m,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: p,
      codeFlowValue: R,
      codeIndented: a(b),
      codeText: a(he),
      codeTextData: R,
      data: R,
      definition: a(),
      definitionDestinationString: C,
      definitionLabelString: w,
      definitionTitleString: k,
      emphasis: a(),
      hardBreakEscape: a(z),
      hardBreakTrailing: a(z),
      htmlFlow: a(ue),
      htmlFlowData: R,
      htmlText: a(ie),
      htmlTextData: R,
      image: a(ge),
      label: ze,
      labelText: ye,
      lineEnding: V,
      link: a(Se),
      listItem: a(),
      listOrdered: a(),
      listUnordered: a(),
      paragraph: a(),
      referenceString: dt,
      resourceDestinationString: I,
      resourceTitleString: Ie,
      resource: Ve,
      setextHeading: a(B),
      setextHeadingLineSequence: N,
      setextHeadingText: T,
      strong: a(),
      thematicBreak: a()
    }
  };
  FT(e, (n || {}).mdastExtensions || []);
  const t = {};
  return r;
  function r(F) {
    let X = {
      type: "root",
      children: []
    };
    const pe = {
      stack: [X],
      tokenStack: [],
      config: e,
      enter: l,
      exit: c,
      buffer: o,
      resume: u,
      data: t
    }, _e = [];
    let je = -1;
    for (; ++je < F.length; )
      if (F[je][1].type === "listOrdered" || F[je][1].type === "listUnordered")
        if (F[je][0] === "enter")
          _e.push(je);
        else {
          const xt = _e.pop();
          je = i(F, xt, je);
        }
    for (je = -1; ++je < F.length; ) {
      const xt = e[F[je][0]];
      zT.call(xt, F[je][1].type) && xt[F[je][1].type].call(Object.assign({
        sliceSerialize: F[je][2].sliceSerialize
      }, pe), F[je][1]);
    }
    if (pe.tokenStack.length > 0) {
      const xt = pe.tokenStack[pe.tokenStack.length - 1];
      (xt[1] || bx).call(pe, void 0, xt[0]);
    }
    for (X.position = {
      start: Io(F.length > 0 ? F[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Io(F.length > 0 ? F[F.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, je = -1; ++je < e.transforms.length; )
      X = e.transforms[je](X) || X;
    return X;
  }
  function i(F, X, pe) {
    let _e = X - 1, je = -1, xt = !1, Pt, Yt, on, wt;
    for (; ++_e <= pe; ) {
      const pt = F[_e];
      switch (pt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          pt[0] === "enter" ? je++ : je--, wt = void 0;
          break;
        }
        case "lineEndingBlank": {
          pt[0] === "enter" && (Pt && !wt && !je && !on && (on = _e), wt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          wt = void 0;
      }
      if (!je && pt[0] === "enter" && pt[1].type === "listItemPrefix" || je === -1 && pt[0] === "exit" && (pt[1].type === "listUnordered" || pt[1].type === "listOrdered")) {
        if (Pt) {
          let Vn = _e;
          for (Yt = void 0; Vn--; ) {
            const En = F[Vn];
            if (En[1].type === "lineEnding" || En[1].type === "lineEndingBlank") {
              if (En[0] === "exit") continue;
              Yt && (F[Yt][1].type = "lineEndingBlank", xt = !0), En[1].type = "lineEnding", Yt = Vn;
            } else if (!(En[1].type === "linePrefix" || En[1].type === "blockQuotePrefix" || En[1].type === "blockQuotePrefixWhitespace" || En[1].type === "blockQuoteMarker" || En[1].type === "listItemIndent")) break;
          }
          on && (!Yt || on < Yt) && (Pt._spread = !0), Pt.end = Object.assign({}, Yt ? F[Yt][1].start : pt[1].end), F.splice(Yt || _e, 0, ["exit", Pt, pt[2]]), _e++, pe++;
        }
        if (pt[1].type === "listItemPrefix") {
          const Vn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, pt[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          Pt = Vn, F.splice(_e, 0, ["enter", Vn, pt[2]]), _e++, pe++, on = void 0, wt = !0;
        }
      }
    }
    return F[X][1]._spread = xt, pe;
  }
  function s(F, X) {
    return pe;
    function pe(_e) {
      l.call(this, F(_e), _e), X && X.call(this, _e);
    }
  }
  function o() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function l(F, X, pe) {
    this.stack[this.stack.length - 1].children.push(F), this.stack.push(F), this.tokenStack.push([X, pe || void 0]), F.position = {
      start: Io(X.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function a(F) {
    return X;
    function X(pe) {
      F && F.call(this, pe), c.call(this, pe);
    }
  }
  function c(F, X) {
    const pe = this.stack.pop(), _e = this.tokenStack.pop();
    if (_e)
      _e[0].type !== F.type && (X ? X.call(this, F, _e[0]) : (_e[1] || bx).call(this, F, _e[0]));
    else throw new Error("Cannot close `" + F.type + "` (" + Uh({
      start: F.start,
      end: F.end
    }) + "): it’s not open");
    pe.position.end = Io(F.end);
  }
  function u() {
    return _3(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f(F) {
    if (this.data.expectingFirstListItemValue) {
      const X = this.stack[this.stack.length - 2];
      X.start = Number.parseInt(this.sliceSerialize(F), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.lang = F;
  }
  function p() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.meta = F;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function g() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function b() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F.replace(/(\r?\n|\r)$/g, "");
  }
  function w(F) {
    const X = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.label = X, pe.identifier = Ri(this.sliceSerialize(F)).toLowerCase();
  }
  function k() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.title = F;
  }
  function C() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.url = F;
  }
  function M(F) {
    const X = this.stack[this.stack.length - 1];
    if (!X.depth) {
      const pe = this.sliceSerialize(F).length;
      X.depth = pe;
    }
  }
  function T() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function N(F) {
    const X = this.stack[this.stack.length - 1];
    X.depth = this.sliceSerialize(F).codePointAt(0) === 61 ? 1 : 2;
  }
  function B() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function $(F) {
    const pe = this.stack[this.stack.length - 1].children;
    let _e = pe[pe.length - 1];
    (!_e || _e.type !== "text") && (_e = Te(), _e.position = {
      start: Io(F.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, pe.push(_e)), this.stack.push(_e);
  }
  function R(F) {
    const X = this.stack.pop();
    X.value += this.sliceSerialize(F), X.position.end = Io(F.end);
  }
  function V(F) {
    const X = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const pe = X.children[X.children.length - 1];
      pe.position.end = Io(F.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(X.type) && ($.call(this, F), R.call(this, F));
  }
  function z() {
    this.data.atHardBreak = !0;
  }
  function ue() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F;
  }
  function ie() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F;
  }
  function he() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F;
  }
  function Se() {
    const F = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const X = this.data.referenceType || "shortcut";
      F.type += "Reference", F.referenceType = X, delete F.url, delete F.title;
    } else
      delete F.identifier, delete F.label;
    this.data.referenceType = void 0;
  }
  function ge() {
    const F = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const X = this.data.referenceType || "shortcut";
      F.type += "Reference", F.referenceType = X, delete F.url, delete F.title;
    } else
      delete F.identifier, delete F.label;
    this.data.referenceType = void 0;
  }
  function ye(F) {
    const X = this.sliceSerialize(F), pe = this.stack[this.stack.length - 2];
    pe.label = BT(X), pe.identifier = Ri(X).toLowerCase();
  }
  function ze() {
    const F = this.stack[this.stack.length - 1], X = this.resume(), pe = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, pe.type === "link") {
      const _e = F.children;
      pe.children = _e;
    } else
      pe.alt = X;
  }
  function I() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.url = F;
  }
  function Ie() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.title = F;
  }
  function Ve() {
    this.data.inReference = void 0;
  }
  function O() {
    this.data.referenceType = "collapsed";
  }
  function dt(F) {
    const X = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.label = X, pe.identifier = Ri(this.sliceSerialize(F)).toLowerCase(), this.data.referenceType = "full";
  }
  function Ue(F) {
    this.data.characterReferenceType = F.type;
  }
  function et(F) {
    const X = this.sliceSerialize(F), pe = this.data.characterReferenceType;
    let _e;
    pe ? (_e = AT(X, pe === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : _e = L3(X);
    const je = this.stack[this.stack.length - 1];
    je.value += _e;
  }
  function Mt(F) {
    const X = this.stack.pop();
    X.position.end = Io(F.end);
  }
  function Ft(F) {
    R.call(this, F);
    const X = this.stack[this.stack.length - 1];
    X.url = this.sliceSerialize(F);
  }
  function sn(F) {
    R.call(this, F);
    const X = this.stack[this.stack.length - 1];
    X.url = "mailto:" + this.sliceSerialize(F);
  }
  function Gt() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function _r() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function E() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function P() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function W() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Q() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function J() {
    return {
      type: "break"
    };
  }
  function Y() {
    return {
      type: "html",
      value: ""
    };
  }
  function ae() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function re() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function oe(F) {
    return {
      type: "list",
      ordered: F.type === "listOrdered",
      start: null,
      spread: F._spread,
      children: []
    };
  }
  function te(F) {
    return {
      type: "listItem",
      spread: F._spread,
      checked: null,
      children: []
    };
  }
  function De() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function de() {
    return {
      type: "strong",
      children: []
    };
  }
  function Te() {
    return {
      type: "text",
      value: ""
    };
  }
  function Pe() {
    return {
      type: "thematicBreak"
    };
  }
}
function Io(n) {
  return {
    line: n.line,
    column: n.column,
    offset: n.offset
  };
}
function FT(n, e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const r = e[t];
    Array.isArray(r) ? FT(n, r) : MW(n, r);
  }
}
function MW(n, e) {
  let t;
  for (t in e)
    if (zT.call(e, t))
      switch (t) {
        case "canContainEols": {
          const r = e[t];
          r && n[t].push(...r);
          break;
        }
        case "transforms": {
          const r = e[t];
          r && n[t].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = e[t];
          r && Object.assign(n[t], r);
          break;
        }
      }
}
function bx(n, e) {
  throw n ? new Error("Cannot close `" + n.type + "` (" + Uh({
    start: n.start,
    end: n.end
  }) + "): a different token (`" + e.type + "`, " + Uh({
    start: e.start,
    end: e.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + Uh({
    start: e.start,
    end: e.end
  }) + ") is still open");
}
function Iy(n) {
  const e = this;
  e.parser = t;
  function t(r) {
    return SW(r, {
      ...e.data("settings"),
      ...n,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("micromarkExtensions") || [],
      mdastExtensions: e.data("fromMarkdownExtensions") || []
    });
  }
}
const vx = {}.hasOwnProperty;
function TW(n, e) {
  const t = e || {};
  function r(i, ...s) {
    let o = r.invalid;
    const l = r.handlers;
    if (i && vx.call(i, n)) {
      const a = String(i[n]);
      o = vx.call(l, a) ? l[a] : r.unknown;
    }
    if (o)
      return o.call(this, i, ...s);
  }
  return r.handlers = t.handlers || {}, r.invalid = t.invalid, r.unknown = t.unknown, r;
}
const AW = {}.hasOwnProperty;
function HT(n, e) {
  let t = -1, r;
  if (e.extensions)
    for (; ++t < e.extensions.length; )
      HT(n, e.extensions[t]);
  for (r in e)
    if (AW.call(e, r))
      switch (r) {
        case "extensions":
          break;
        /* c8 ignore next 4 */
        case "unsafe": {
          wx(n[r], e[r]);
          break;
        }
        case "join": {
          wx(n[r], e[r]);
          break;
        }
        case "handlers": {
          OW(n[r], e[r]);
          break;
        }
        default:
          n.options[r] = e[r];
      }
  return n;
}
function wx(n, e) {
  e && n.push(...e);
}
function OW(n, e) {
  e && Object.assign(n, e);
}
function EW(n, e, t, r) {
  const i = t.enter("blockquote"), s = t.createTracker(r);
  s.move("> "), s.shift(2);
  const o = t.indentLines(
    t.containerFlow(n, s.current()),
    IW
  );
  return i(), o;
}
function IW(n, e, t) {
  return ">" + (t ? "" : " ") + n;
}
function $T(n, e) {
  return xx(n, e.inConstruct, !0) && !xx(n, e.notInConstruct, !1);
}
function xx(n, e, t) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return t;
  let r = -1;
  for (; ++r < e.length; )
    if (n.includes(e[r]))
      return !0;
  return !1;
}
function kx(n, e, t, r) {
  let i = -1;
  for (; ++i < t.unsafe.length; )
    if (t.unsafe[i].character === `
` && $T(t.stack, t.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function VT(n, e) {
  const t = String(n);
  let r = t.indexOf(e), i = r, s = 0, o = 0;
  if (typeof e != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++s > o && (o = s) : s = 1, i = r + e.length, r = t.indexOf(e, i);
  return o;
}
function Dy(n, e) {
  return !!(e.options.fences === !1 && n.value && // If there’s no info…
  !n.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(n.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(n.value));
}
function DW(n) {
  const e = n.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function NW(n, e, t, r) {
  const i = DW(t), s = n.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (Dy(n, t)) {
    const h = t.enter("codeIndented"), f = t.indentLines(s, RW);
    return h(), f;
  }
  const l = t.createTracker(r), a = i.repeat(Math.max(VT(s, i) + 1, 3)), c = t.enter("codeFenced");
  let u = l.move(a);
  if (n.lang) {
    const h = t.enter(`codeFencedLang${o}`);
    u += l.move(
      t.safe(n.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...l.current()
      })
    ), h();
  }
  if (n.lang && n.meta) {
    const h = t.enter(`codeFencedMeta${o}`);
    u += l.move(" "), u += l.move(
      t.safe(n.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...l.current()
      })
    ), h();
  }
  return u += l.move(`
`), s && (u += l.move(s + `
`)), u += l.move(a), c(), u;
}
function RW(n, e, t) {
  return (t ? "" : "    ") + n;
}
function z3(n) {
  const e = n.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function PW(n, e, t, r) {
  const i = z3(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.enter("definition");
  let l = t.enter("label");
  const a = t.createTracker(r);
  let c = a.move("[");
  return c += a.move(
    t.safe(t.associationId(n), {
      before: c,
      after: "]",
      ...a.current()
    })
  ), c += a.move("]: "), l(), // If there’s no url, or…
  !n.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (l = t.enter("destinationLiteral"), c += a.move("<"), c += a.move(
    t.safe(n.url, { before: c, after: ">", ...a.current() })
  ), c += a.move(">")) : (l = t.enter("destinationRaw"), c += a.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : `
`,
      ...a.current()
    })
  )), l(), n.title && (l = t.enter(`title${s}`), c += a.move(" " + i), c += a.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...a.current()
    })
  ), c += a.move(i), l()), o(), c;
}
function _W(n) {
  const e = n.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function ml(n) {
  return "&#x" + n.toString(16).toUpperCase() + ";";
}
function mm(n, e, t) {
  const r = Fc(n), i = Fc(e);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    t === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
qT.peek = LW;
function qT(n, e, t, r) {
  const i = _W(t), s = t.enter("emphasis"), o = t.createTracker(r), l = o.move(i);
  let a = o.move(
    t.containerPhrasing(n, {
      after: i,
      before: l,
      ...o.current()
    })
  );
  const c = a.charCodeAt(0), u = mm(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (a = ml(c) + a.slice(1));
  const h = a.charCodeAt(a.length - 1), f = mm(r.after.charCodeAt(0), h, i);
  f.inside && (a = a.slice(0, -1) + ml(h));
  const d = o.move(i);
  return s(), t.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, l + a + d;
}
function LW(n, e, t) {
  return t.options.emphasis || "*";
}
const x1 = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(n) {
    if (n == null)
      return HW;
    if (typeof n == "function")
      return k1(n);
    if (typeof n == "object")
      return Array.isArray(n) ? BW(n) : zW(n);
    if (typeof n == "string")
      return FW(n);
    throw new Error("Expected function, string, or object as test");
  })
);
function BW(n) {
  const e = [];
  let t = -1;
  for (; ++t < n.length; )
    e[t] = x1(n[t]);
  return k1(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function zW(n) {
  const e = (
    /** @type {Record<string, unknown>} */
    n
  );
  return k1(t);
  function t(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in n)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function FW(n) {
  return k1(e);
  function e(t) {
    return t && t.type === n;
  }
}
function k1(n) {
  return e;
  function e(t, r, i) {
    return !!($W(t) && n.call(
      this,
      t,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function HW() {
  return !0;
}
function $W(n) {
  return n !== null && typeof n == "object" && "type" in n;
}
const WT = [], VW = !0, Ny = !1, Ry = "skip";
function F3(n, e, t, r) {
  let i;
  typeof e == "function" && typeof t != "function" ? (r = t, t = e) : i = e;
  const s = x1(i), o = r ? -1 : 1;
  l(n, void 0, [])();
  function l(a, c, u) {
    const h = (
      /** @type {Record<string, unknown>} */
      a && typeof a == "object" ? a : {}
    );
    if (typeof h.type == "string") {
      const d = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(f, "name", {
        value: "node (" + (a.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return f;
    function f() {
      let d = WT, p, m, g;
      if ((!e || s(a, c, u[u.length - 1] || void 0)) && (d = qW(t(a, u)), d[0] === Ny))
        return d;
      if ("children" in a && a.children) {
        const b = (
          /** @type {UnistParent} */
          a
        );
        if (b.children && d[0] !== Ry)
          for (m = (r ? b.children.length : -1) + o, g = u.concat(b); m > -1 && m < b.children.length; ) {
            const w = b.children[m];
            if (p = l(w, m, g)(), p[0] === Ny)
              return p;
            m = typeof p[1] == "number" ? p[1] : m + o;
          }
      }
      return d;
    }
  }
}
function qW(n) {
  return Array.isArray(n) ? n : typeof n == "number" ? [VW, n] : n == null ? WT : [n];
}
function Tl(n, e, t, r) {
  let i, s, o;
  typeof e == "function" && typeof t != "function" ? (s = void 0, o = e, i = t) : (s = e, o = t, i = r), F3(n, s, l, i);
  function l(a, c) {
    const u = c[c.length - 1], h = u ? u.children.indexOf(a) : void 0;
    return o(a, h, u);
  }
}
function jT(n, e) {
  let t = !1;
  return Tl(n, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return t = !0, Ny;
  }), !!((!n.depth || n.depth < 3) && _3(n) && (e.options.setext || t));
}
function WW(n, e, t, r) {
  const i = Math.max(Math.min(6, n.depth || 1), 1), s = t.createTracker(r);
  if (jT(n, t)) {
    const u = t.enter("headingSetext"), h = t.enter("phrasing"), f = t.containerPhrasing(n, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return h(), u(), f + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), l = t.enter("headingAtx"), a = t.enter("phrasing");
  s.move(o + " ");
  let c = t.containerPhrasing(n, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(c) && (c = ml(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, t.options.closeAtx && (c += " " + o), a(), l(), c;
}
UT.peek = jW;
function UT(n) {
  return n.value || "";
}
function jW() {
  return "<";
}
KT.peek = UW;
function KT(n, e, t, r) {
  const i = z3(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.enter("image");
  let l = t.enter("label");
  const a = t.createTracker(r);
  let c = a.move("![");
  return c += a.move(
    t.safe(n.alt, { before: c, after: "]", ...a.current() })
  ), c += a.move("]("), l(), // If there’s no url but there is a title…
  !n.url && n.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (l = t.enter("destinationLiteral"), c += a.move("<"), c += a.move(
    t.safe(n.url, { before: c, after: ">", ...a.current() })
  ), c += a.move(">")) : (l = t.enter("destinationRaw"), c += a.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : ")",
      ...a.current()
    })
  )), l(), n.title && (l = t.enter(`title${s}`), c += a.move(" " + i), c += a.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...a.current()
    })
  ), c += a.move(i), l()), c += a.move(")"), o(), c;
}
function UW() {
  return "!";
}
GT.peek = KW;
function GT(n, e, t, r) {
  const i = n.referenceType, s = t.enter("imageReference");
  let o = t.enter("label");
  const l = t.createTracker(r);
  let a = l.move("![");
  const c = t.safe(n.alt, {
    before: a,
    after: "]",
    ...l.current()
  });
  a += l.move(c + "]["), o();
  const u = t.stack;
  t.stack = [], o = t.enter("reference");
  const h = t.safe(t.associationId(n), {
    before: a,
    after: "]",
    ...l.current()
  });
  return o(), t.stack = u, s(), i === "full" || !c || c !== h ? a += l.move(h + "]") : i === "shortcut" ? a = a.slice(0, -1) : a += l.move("]"), a;
}
function KW() {
  return "!";
}
YT.peek = GW;
function YT(n, e, t) {
  let r = n.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < t.unsafe.length; ) {
    const o = t.unsafe[s], l = t.compilePattern(o);
    let a;
    if (o.atBreak)
      for (; a = l.exec(r); ) {
        let c = a.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(a.index + 1);
      }
  }
  return i + r + i;
}
function GW() {
  return "`";
}
function JT(n, e) {
  const t = _3(n);
  return !!(!e.options.resourceLink && // If there’s a url…
  n.url && // And there’s a no title…
  !n.title && // And the content of `node` is a single text node…
  n.children && n.children.length === 1 && n.children[0].type === "text" && // And if the url is the same as the content…
  (t === n.url || "mailto:" + t === n.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(n.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(n.url));
}
XT.peek = YW;
function XT(n, e, t, r) {
  const i = z3(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.createTracker(r);
  let l, a;
  if (JT(n, t)) {
    const u = t.stack;
    t.stack = [], l = t.enter("autolink");
    let h = o.move("<");
    return h += o.move(
      t.containerPhrasing(n, {
        before: h,
        after: ">",
        ...o.current()
      })
    ), h += o.move(">"), l(), t.stack = u, h;
  }
  l = t.enter("link"), a = t.enter("label");
  let c = o.move("[");
  return c += o.move(
    t.containerPhrasing(n, {
      before: c,
      after: "](",
      ...o.current()
    })
  ), c += o.move("]("), a(), // If there’s no url but there is a title…
  !n.url && n.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (a = t.enter("destinationLiteral"), c += o.move("<"), c += o.move(
    t.safe(n.url, { before: c, after: ">", ...o.current() })
  ), c += o.move(">")) : (a = t.enter("destinationRaw"), c += o.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : ")",
      ...o.current()
    })
  )), a(), n.title && (a = t.enter(`title${s}`), c += o.move(" " + i), c += o.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...o.current()
    })
  ), c += o.move(i), a()), c += o.move(")"), l(), c;
}
function YW(n, e, t) {
  return JT(n, t) ? "<" : "[";
}
ZT.peek = JW;
function ZT(n, e, t, r) {
  const i = n.referenceType, s = t.enter("linkReference");
  let o = t.enter("label");
  const l = t.createTracker(r);
  let a = l.move("[");
  const c = t.containerPhrasing(n, {
    before: a,
    after: "]",
    ...l.current()
  });
  a += l.move(c + "]["), o();
  const u = t.stack;
  t.stack = [], o = t.enter("reference");
  const h = t.safe(t.associationId(n), {
    before: a,
    after: "]",
    ...l.current()
  });
  return o(), t.stack = u, s(), i === "full" || !c || c !== h ? a += l.move(h + "]") : i === "shortcut" ? a = a.slice(0, -1) : a += l.move("]"), a;
}
function JW() {
  return "[";
}
function H3(n) {
  const e = n.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function XW(n) {
  const e = H3(n), t = n.options.bulletOther;
  if (!t)
    return e === "*" ? "-" : "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (t === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + t + "`) to be different"
    );
  return t;
}
function ZW(n) {
  const e = n.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function QT(n) {
  const e = n.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function QW(n, e, t, r) {
  const i = t.enter("list"), s = t.bulletCurrent;
  let o = n.ordered ? ZW(t) : H3(t);
  const l = n.ordered ? o === "." ? ")" : "." : XW(t);
  let a = e && t.bulletLastUsed ? o === t.bulletLastUsed : !1;
  if (!n.ordered) {
    const u = n.children ? n.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      t.stack[t.stack.length - 1] === "list" && t.stack[t.stack.length - 2] === "listItem" && t.stack[t.stack.length - 3] === "list" && t.stack[t.stack.length - 4] === "listItem" && // That are each the first child.
      t.indexStack[t.indexStack.length - 1] === 0 && t.indexStack[t.indexStack.length - 2] === 0 && t.indexStack[t.indexStack.length - 3] === 0 && (a = !0), QT(t) === o && u
    ) {
      let h = -1;
      for (; ++h < n.children.length; ) {
        const f = n.children[h];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          a = !0;
          break;
        }
      }
    }
  }
  a && (o = l), t.bulletCurrent = o;
  const c = t.containerFlow(n, r);
  return t.bulletLastUsed = o, t.bulletCurrent = s, i(), c;
}
function ej(n) {
  const e = n.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function tj(n, e, t, r) {
  const i = ej(t);
  let s = t.bulletCurrent || H3(t);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (t.options.incrementListMarker === !1 ? 0 : e.children.indexOf(n)) + s);
  let o = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || n.spread)) && (o = Math.ceil(o / 4) * 4);
  const l = t.createTracker(r);
  l.move(s + " ".repeat(o - s.length)), l.shift(o);
  const a = t.enter("listItem"), c = t.indentLines(
    t.containerFlow(n, l.current()),
    u
  );
  return a(), c;
  function u(h, f, d) {
    return f ? (d ? "" : " ".repeat(o)) + h : (d ? s : s + " ".repeat(o - s.length)) + h;
  }
}
function nj(n, e, t, r) {
  const i = t.enter("paragraph"), s = t.enter("phrasing"), o = t.containerPhrasing(n, r);
  return s(), i(), o;
}
const rj = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  x1([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function ij(n, e, t, r) {
  return (n.children.some(function(o) {
    return rj(o);
  }) ? t.containerPhrasing : t.containerFlow).call(t, n, r);
}
function sj(n) {
  const e = n.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
eA.peek = oj;
function eA(n, e, t, r) {
  const i = sj(t), s = t.enter("strong"), o = t.createTracker(r), l = o.move(i + i);
  let a = o.move(
    t.containerPhrasing(n, {
      after: i,
      before: l,
      ...o.current()
    })
  );
  const c = a.charCodeAt(0), u = mm(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (a = ml(c) + a.slice(1));
  const h = a.charCodeAt(a.length - 1), f = mm(r.after.charCodeAt(0), h, i);
  f.inside && (a = a.slice(0, -1) + ml(h));
  const d = o.move(i + i);
  return s(), t.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, l + a + d;
}
function oj(n, e, t) {
  return t.options.strong || "*";
}
function lj(n, e, t, r) {
  return t.safe(n.value, r);
}
function aj(n) {
  const e = n.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function cj(n, e, t) {
  const r = (QT(t) + (t.options.ruleSpaces ? " " : "")).repeat(aj(t));
  return t.options.ruleSpaces ? r.slice(0, -1) : r;
}
const $3 = {
  blockquote: EW,
  break: kx,
  code: NW,
  definition: PW,
  emphasis: qT,
  hardBreak: kx,
  heading: WW,
  html: UT,
  image: KT,
  imageReference: GT,
  inlineCode: YT,
  link: XT,
  linkReference: ZT,
  list: QW,
  listItem: tj,
  paragraph: nj,
  root: ij,
  strong: eA,
  text: lj,
  thematicBreak: cj
}, uj = [hj];
function hj(n, e, t, r) {
  if (e.type === "code" && Dy(e, r) && (n.type === "list" || n.type === e.type && Dy(n, r)))
    return !1;
  if ("spread" in t && typeof t.spread == "boolean")
    return n.type === "paragraph" && // Two paragraphs.
    (n.type === e.type || e.type === "definition" || // Paragraph followed by a setext heading.
    e.type === "heading" && jT(e, r)) ? void 0 : t.spread ? 1 : 0;
}
const _l = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
], fj = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: `
`,
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: _l
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: !0, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)` },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: _l
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: !0, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: !0, character: "*", after: `(?:[ 	\r
*])` },
  { character: "*", inConstruct: "phrasing", notInConstruct: _l },
  // A plus sign could start a list item.
  { atBreak: !0, character: "+", after: `(?:[ 	\r
])` },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: !0, character: "-", after: `(?:[ 	\r
-])` },
  // A dot could start a list item.
  { atBreak: !0, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)` },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: _l
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: !0, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: !0, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: !0, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: _l },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: !0, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: _l },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: !0, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: _l },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: !0, character: "~" }
];
function dj(n) {
  return n.label || !n.identifier ? n.label || "" : BT(n.identifier);
}
function pj(n) {
  if (!n._compiled) {
    const e = (n.atBreak ? "[\\r\\n][\\t ]*" : "") + (n.before ? "(?:" + n.before + ")" : "");
    n._compiled = new RegExp(
      (e ? "(" + e + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(n.character) ? "\\" : "") + n.character + (n.after ? "(?:" + n.after + ")" : ""),
      "g"
    );
  }
  return n._compiled;
}
function mj(n, e, t) {
  const r = e.indexStack, i = n.children || [], s = [];
  let o = -1, l = t.before, a;
  r.push(-1);
  let c = e.createTracker(t);
  for (; ++o < i.length; ) {
    const u = i[o];
    let h;
    if (r[r.length - 1] = o, o + 1 < i.length) {
      let p = e.handle.handlers[i[o + 1].type];
      p && p.peek && (p = p.peek), h = p ? p(i[o + 1], n, e, {
        before: "",
        after: "",
        ...c.current()
      }).charAt(0) : "";
    } else
      h = t.after;
    s.length > 0 && (l === "\r" || l === `
`) && u.type === "html" && (s[s.length - 1] = s[s.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), l = " ", c = e.createTracker(t), c.move(s.join("")));
    let f = e.handle(u, n, e, {
      ...c.current(),
      after: h,
      before: l
    });
    a && a === f.slice(0, 1) && (f = ml(a.charCodeAt(0)) + f.slice(1));
    const d = e.attentionEncodeSurroundingInfo;
    e.attentionEncodeSurroundingInfo = void 0, a = void 0, d && (s.length > 0 && d.before && l === s[s.length - 1].slice(-1) && (s[s.length - 1] = s[s.length - 1].slice(0, -1) + ml(l.charCodeAt(0))), d.after && (a = h)), c.move(f), s.push(f), l = f.slice(-1);
  }
  return r.pop(), s.join("");
}
function gj(n, e, t) {
  const r = e.indexStack, i = n.children || [], s = e.createTracker(t), o = [];
  let l = -1;
  for (r.push(-1); ++l < i.length; ) {
    const a = i[l];
    r[r.length - 1] = l, o.push(
      s.move(
        e.handle(a, n, e, {
          before: `
`,
          after: `
`,
          ...s.current()
        })
      )
    ), a.type !== "list" && (e.bulletLastUsed = void 0), l < i.length - 1 && o.push(
      s.move(yj(a, i[l + 1], n, e))
    );
  }
  return r.pop(), o.join("");
}
function yj(n, e, t, r) {
  let i = r.join.length;
  for (; i--; ) {
    const s = r.join[i](n, e, t, r);
    if (s === !0 || s === 1)
      break;
    if (typeof s == "number")
      return `
`.repeat(1 + s);
    if (s === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const bj = /\r?\n|\r/g;
function vj(n, e) {
  const t = [];
  let r = 0, i = 0, s;
  for (; s = bj.exec(n); )
    o(n.slice(r, s.index)), t.push(s[0]), r = s.index + s[0].length, i++;
  return o(n.slice(r)), t.join("");
  function o(l) {
    t.push(e(l, i, !l));
  }
}
function wj(n, e, t) {
  const r = (t.before || "") + (e || "") + (t.after || ""), i = [], s = [], o = {};
  let l = -1;
  for (; ++l < n.unsafe.length; ) {
    const u = n.unsafe[l];
    if (!$T(n.stack, u))
      continue;
    const h = n.compilePattern(u);
    let f;
    for (; f = h.exec(r); ) {
      const d = "before" in u || !!u.atBreak, p = "after" in u, m = f.index + (d ? f[1].length : 0);
      i.includes(m) ? (o[m].before && !d && (o[m].before = !1), o[m].after && !p && (o[m].after = !1)) : (i.push(m), o[m] = { before: d, after: p });
    }
  }
  i.sort(xj);
  let a = t.before ? t.before.length : 0;
  const c = r.length - (t.after ? t.after.length : 0);
  for (l = -1; ++l < i.length; ) {
    const u = i[l];
    u < a || u >= c || u + 1 < c && i[l + 1] === u + 1 && o[u].after && !o[u + 1].before && !o[u + 1].after || i[l - 1] === u - 1 && o[u].before && !o[u - 1].before && !o[u - 1].after || (a !== u && s.push(Sx(r.slice(a, u), "\\")), a = u, /[!-/:-@[-`{-~]/.test(r.charAt(u)) && (!t.encode || !t.encode.includes(r.charAt(u))) ? s.push("\\") : (s.push(ml(r.charCodeAt(u))), a++));
  }
  return s.push(Sx(r.slice(a, c), t.after)), s.join("");
}
function xj(n, e) {
  return n - e;
}
function Sx(n, e) {
  const t = /\\(?=[!-/:-@[-`{-~])/g, r = [], i = [], s = n + e;
  let o = -1, l = 0, a;
  for (; a = t.exec(s); )
    r.push(a.index);
  for (; ++o < r.length; )
    l !== r[o] && i.push(n.slice(l, r[o])), i.push("\\"), l = r[o];
  return i.push(n.slice(l)), i.join("");
}
function kj(n) {
  const e = n || {}, t = e.now || {};
  let r = e.lineShift || 0, i = t.line || 1, s = t.column || 1;
  return { move: a, current: o, shift: l };
  function o() {
    return { now: { line: i, column: s }, lineShift: r };
  }
  function l(c) {
    r += c;
  }
  function a(c) {
    const u = c || "", h = u.split(/\r?\n|\r/g), f = h[h.length - 1];
    return i += h.length - 1, s = h.length === 1 ? s + f.length : 1 + f.length + r, u;
  }
}
function Sj(n, e) {
  const t = e || {}, r = {
    associationId: dj,
    containerPhrasing: Aj,
    containerFlow: Oj,
    createTracker: kj,
    compilePattern: pj,
    enter: s,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...$3 },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines: vj,
    indexStack: [],
    join: [...uj],
    options: {},
    safe: Ej,
    stack: [],
    unsafe: [...fj]
  };
  HT(r, t), r.options.tightDefinitions && r.join.push(Tj), r.handle = TW("type", {
    invalid: Cj,
    unknown: Mj,
    handlers: r.handlers
  });
  let i = r.handle(n, void 0, r, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  return i && i.charCodeAt(i.length - 1) !== 10 && i.charCodeAt(i.length - 1) !== 13 && (i += `
`), i;
  function s(o) {
    return r.stack.push(o), l;
    function l() {
      r.stack.pop();
    }
  }
}
function Cj(n) {
  throw new Error("Cannot handle value `" + n + "`, expected node");
}
function Mj(n) {
  const e = (
    /** @type {Nodes} */
    n
  );
  throw new Error("Cannot handle unknown node `" + e.type + "`");
}
function Tj(n, e) {
  if (n.type === "definition" && n.type === e.type)
    return 0;
}
function Aj(n, e) {
  return mj(n, this, e);
}
function Oj(n, e) {
  return gj(n, this, e);
}
function Ej(n, e) {
  return wj(this, n, e);
}
function Py(n) {
  const e = this;
  e.compiler = t;
  function t(r) {
    return Sj(r, {
      ...e.data("settings"),
      ...n,
      // Note: this option is not in the readme.
      // The goal is for it to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("toMarkdownExtensions") || []
    });
  }
}
function Cx(n) {
  if (n)
    throw n;
}
function Ij(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var s2, Mx;
function Dj() {
  if (Mx) return s2;
  Mx = 1;
  var n = Object.prototype.hasOwnProperty, e = Object.prototype.toString, t = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : e.call(c) === "[object Array]";
  }, s = function(c) {
    if (!c || e.call(c) !== "[object Object]")
      return !1;
    var u = n.call(c, "constructor"), h = c.constructor && c.constructor.prototype && n.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !u && !h)
      return !1;
    var f;
    for (f in c)
      ;
    return typeof f > "u" || n.call(c, f);
  }, o = function(c, u) {
    t && u.name === "__proto__" ? t(c, u.name, {
      enumerable: !0,
      configurable: !0,
      value: u.newValue,
      writable: !0
    }) : c[u.name] = u.newValue;
  }, l = function(c, u) {
    if (u === "__proto__")
      if (n.call(c, u)) {
        if (r)
          return r(c, u).value;
      } else return;
    return c[u];
  };
  return s2 = function a() {
    var c, u, h, f, d, p, m = arguments[0], g = 1, b = arguments.length, w = !1;
    for (typeof m == "boolean" && (w = m, m = arguments[1] || {}, g = 2), (m == null || typeof m != "object" && typeof m != "function") && (m = {}); g < b; ++g)
      if (c = arguments[g], c != null)
        for (u in c)
          h = l(m, u), f = l(c, u), m !== f && (w && f && (s(f) || (d = i(f))) ? (d ? (d = !1, p = h && i(h) ? h : []) : p = h && s(h) ? h : {}, o(m, { name: u, newValue: a(w, p, f) })) : typeof f < "u" && o(m, { name: u, newValue: f }));
    return m;
  }, s2;
}
var Nj = Dj();
const o2 = /* @__PURE__ */ Ij(Nj);
function _y(n) {
  if (typeof n != "object" || n === null)
    return !1;
  const e = Object.getPrototypeOf(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}
function Rj() {
  const n = [], e = { run: t, use: r };
  return e;
  function t(...i) {
    let s = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    l(null, ...i);
    function l(a, ...c) {
      const u = n[++s];
      let h = -1;
      if (a) {
        o(a);
        return;
      }
      for (; ++h < i.length; )
        (c[h] === null || c[h] === void 0) && (c[h] = i[h]);
      i = c, u ? Pj(u, l)(...c) : o(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return n.push(i), e;
  }
}
function Pj(n, e) {
  let t;
  return r;
  function r(...o) {
    const l = n.length > o.length;
    let a;
    l && o.push(i);
    try {
      a = n.apply(this, o);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (l && t)
        throw u;
      return i(u);
    }
    l || (a && a.then && typeof a.then == "function" ? a.then(s, i) : a instanceof Error ? i(a) : s(a));
  }
  function i(o, ...l) {
    t || (t = !0, e(o, ...l));
  }
  function s(o) {
    i(null, o);
  }
}
class Nr extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(e, t, r) {
    super(), typeof t == "string" && (r = t, t = void 0);
    let i = "", s = {}, o = !1;
    if (t && ("line" in t && "column" in t ? s = { place: t } : "start" in t && "end" in t ? s = { place: t } : "type" in t ? s = {
      ancestors: [t],
      place: t.position
    } : s = { ...t }), typeof e == "string" ? i = e : !s.cause && e && (o = !0, i = e.message, s.cause = e), !s.ruleId && !s.source && typeof r == "string") {
      const a = r.indexOf(":");
      a === -1 ? s.ruleId = r : (s.source = r.slice(0, a), s.ruleId = r.slice(a + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const a = s.ancestors[s.ancestors.length - 1];
      a && (s.place = a.position);
    }
    const l = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = l ? l.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = l ? l.line : void 0, this.name = Uh(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = o && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
Nr.prototype.file = "";
Nr.prototype.name = "";
Nr.prototype.reason = "";
Nr.prototype.message = "";
Nr.prototype.stack = "";
Nr.prototype.column = void 0;
Nr.prototype.line = void 0;
Nr.prototype.ancestors = void 0;
Nr.prototype.cause = void 0;
Nr.prototype.fatal = void 0;
Nr.prototype.place = void 0;
Nr.prototype.ruleId = void 0;
Nr.prototype.source = void 0;
const ns = { basename: _j, dirname: Lj, extname: Bj, join: zj, sep: "/" };
function _j(n, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  dd(n);
  let t = 0, r = -1, i = n.length, s;
  if (e === void 0 || e.length === 0 || e.length > n.length) {
    for (; i--; )
      if (n.codePointAt(i) === 47) {
        if (s) {
          t = i + 1;
          break;
        }
      } else r < 0 && (s = !0, r = i + 1);
    return r < 0 ? "" : n.slice(t, r);
  }
  if (e === n)
    return "";
  let o = -1, l = e.length - 1;
  for (; i--; )
    if (n.codePointAt(i) === 47) {
      if (s) {
        t = i + 1;
        break;
      }
    } else
      o < 0 && (s = !0, o = i + 1), l > -1 && (n.codePointAt(i) === e.codePointAt(l--) ? l < 0 && (r = i) : (l = -1, r = o));
  return t === r ? r = o : r < 0 && (r = n.length), n.slice(t, r);
}
function Lj(n) {
  if (dd(n), n.length === 0)
    return ".";
  let e = -1, t = n.length, r;
  for (; --t; )
    if (n.codePointAt(t) === 47) {
      if (r) {
        e = t;
        break;
      }
    } else r || (r = !0);
  return e < 0 ? n.codePointAt(0) === 47 ? "/" : "." : e === 1 && n.codePointAt(0) === 47 ? "//" : n.slice(0, e);
}
function Bj(n) {
  dd(n);
  let e = n.length, t = -1, r = 0, i = -1, s = 0, o;
  for (; e--; ) {
    const l = n.codePointAt(e);
    if (l === 47) {
      if (o) {
        r = e + 1;
        break;
      }
      continue;
    }
    t < 0 && (o = !0, t = e + 1), l === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1);
  }
  return i < 0 || t < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && i === t - 1 && i === r + 1 ? "" : n.slice(i, t);
}
function zj(...n) {
  let e = -1, t;
  for (; ++e < n.length; )
    dd(n[e]), n[e] && (t = t === void 0 ? n[e] : t + "/" + n[e]);
  return t === void 0 ? "." : Fj(t);
}
function Fj(n) {
  dd(n);
  const e = n.codePointAt(0) === 47;
  let t = Hj(n, !e);
  return t.length === 0 && !e && (t = "."), t.length > 0 && n.codePointAt(n.length - 1) === 47 && (t += "/"), e ? "/" + t : t;
}
function Hj(n, e) {
  let t = "", r = 0, i = -1, s = 0, o = -1, l, a;
  for (; ++o <= n.length; ) {
    if (o < n.length)
      l = n.codePointAt(o);
    else {
      if (l === 47)
        break;
      l = 47;
    }
    if (l === 47) {
      if (!(i === o - 1 || s === 1)) if (i !== o - 1 && s === 2) {
        if (t.length < 2 || r !== 2 || t.codePointAt(t.length - 1) !== 46 || t.codePointAt(t.length - 2) !== 46) {
          if (t.length > 2) {
            if (a = t.lastIndexOf("/"), a !== t.length - 1) {
              a < 0 ? (t = "", r = 0) : (t = t.slice(0, a), r = t.length - 1 - t.lastIndexOf("/")), i = o, s = 0;
              continue;
            }
          } else if (t.length > 0) {
            t = "", r = 0, i = o, s = 0;
            continue;
          }
        }
        e && (t = t.length > 0 ? t + "/.." : "..", r = 2);
      } else
        t.length > 0 ? t += "/" + n.slice(i + 1, o) : t = n.slice(i + 1, o), r = o - i - 1;
      i = o, s = 0;
    } else l === 46 && s > -1 ? s++ : s = -1;
  }
  return t;
}
function dd(n) {
  if (typeof n != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(n)
    );
}
const $j = { cwd: Vj };
function Vj() {
  return "/";
}
function Ly(n) {
  return !!(n !== null && typeof n == "object" && "href" in n && n.href && "protocol" in n && n.protocol && // @ts-expect-error: indexing is fine.
  n.auth === void 0);
}
function qj(n) {
  if (typeof n == "string")
    n = new URL(n);
  else if (!Ly(n)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + n + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (n.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return Wj(n);
}
function Wj(n) {
  if (n.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = n.pathname;
  let t = -1;
  for (; ++t < e.length; )
    if (e.codePointAt(t) === 37 && e.codePointAt(t + 1) === 50) {
      const r = e.codePointAt(t + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(e);
}
const l2 = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class jj {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let t;
    e ? Ly(e) ? t = { path: e } : typeof e == "string" || Uj(e) ? t = { value: e } : t = e : t = {}, this.cwd = "cwd" in t ? "" : $j.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < l2.length; ) {
      const s = l2[r];
      s in t && t[s] !== void 0 && t[s] !== null && (this[s] = s === "history" ? [...t[s]] : t[s]);
    }
    let i;
    for (i in t)
      l2.includes(i) || (this[i] = t[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? ns.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(e) {
    c2(e, "basename"), a2(e, "basename"), this.path = ns.join(this.dirname || "", e);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? ns.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(e) {
    Tx(this.basename, "dirname"), this.path = ns.join(e || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? ns.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(e) {
    if (a2(e, "extname"), Tx(this.dirname, "extname"), e) {
      if (e.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = ns.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(e) {
    Ly(e) && (e = qj(e)), c2(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? ns.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(e) {
    c2(e, "stem"), a2(e, "stem"), this.path = ns.join(this.dirname || "", e + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, t, r) {
    const i = this.message(e, t, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, t, r) {
    const i = this.message(e, t, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, t, r) {
    const i = new Nr(
      // @ts-expect-error: the overloads are fine.
      e,
      t,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value);
  }
}
function a2(n, e) {
  if (n && n.includes(ns.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + ns.sep + "`"
    );
}
function c2(n, e) {
  if (!n)
    throw new Error("`" + e + "` cannot be empty");
}
function Tx(n, e) {
  if (!n)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function Uj(n) {
  return !!(n && typeof n == "object" && "byteLength" in n && "byteOffset" in n);
}
const Kj = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(n) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[n], s = function() {
      return i.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, r), s;
  })
), Gj = {}.hasOwnProperty;
class V3 extends Kj {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Rj();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const e = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new V3()
    );
    let t = -1;
    for (; ++t < this.attachers.length; ) {
      const r = this.attachers[t];
      e.use(...r);
    }
    return e.data(o2(!0, {}, this.namespace)), e;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(e, t) {
    return typeof e == "string" ? arguments.length === 2 ? (f2("data", this.frozen), this.namespace[e] = t, this) : Gj.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (f2("data", this.frozen), this.namespace = e, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const e = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [t, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = t.call(e, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(e) {
    this.freeze();
    const t = p0(e), r = this.parser || this.Parser;
    return u2("parse", r), r(String(t), t);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(e, t) {
    const r = this;
    return this.freeze(), u2("process", this.parser || this.Parser), h2("process", this.compiler || this.Compiler), t ? i(void 0, t) : new Promise(i);
    function i(s, o) {
      const l = p0(e), a = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(l)
      );
      r.run(a, l, function(u, h, f) {
        if (u || !h || !f)
          return c(u);
        const d = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), p = r.stringify(d, f);
        Jj(p) ? f.value = p : f.result = p, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          f
        );
      });
      function c(u, h) {
        u || !h ? o(u) : s ? s(h) : t(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(e) {
    let t = !1, r;
    return this.freeze(), u2("processSync", this.parser || this.Parser), h2("processSync", this.compiler || this.Compiler), this.process(e, i), Ox("processSync", "process", t), r;
    function i(s, o) {
      t = !0, Cx(s), r = o;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(e, t, r) {
    Ax(e), this.freeze();
    const i = this.transformers;
    return !r && typeof t == "function" && (r = t, t = void 0), r ? s(void 0, r) : new Promise(s);
    function s(o, l) {
      const a = p0(t);
      i.run(e, a, c);
      function c(u, h, f) {
        const d = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || e
        );
        u ? l(u) : o ? o(d) : r(void 0, d, f);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(e, t) {
    let r = !1, i;
    return this.run(e, t, s), Ox("runSync", "run", r), i;
    function s(o, l) {
      Cx(o), i = l, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(e, t) {
    this.freeze();
    const r = p0(t), i = this.compiler || this.Compiler;
    return h2("stringify", i), Ax(e), i(e, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(e, ...t) {
    const r = this.attachers, i = this.namespace;
    if (f2("use", this.frozen), e != null) if (typeof e == "function")
      a(e, t);
    else if (typeof e == "object")
      Array.isArray(e) ? l(e) : o(e);
    else
      throw new TypeError("Expected usable value, not `" + e + "`");
    return this;
    function s(c) {
      if (typeof c == "function")
        a(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          a(u, h);
        } else
          o(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function o(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      l(c.plugins), c.settings && (i.settings = o2(!0, i.settings, c.settings));
    }
    function l(c) {
      let u = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++u < c.length; ) {
          const h = c[u];
          s(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function a(c, u) {
      let h = -1, f = -1;
      for (; ++h < r.length; )
        if (r[h][0] === c) {
          f = h;
          break;
        }
      if (f === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [d, ...p] = u;
        const m = r[f][1];
        _y(m) && _y(d) && (d = o2(!0, m, d)), r[f] = [c, d, ...p];
      }
    }
  }
}
const By = new V3().freeze();
function u2(n, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + n + "` without `parser`");
}
function h2(n, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + n + "` without `compiler`");
}
function f2(n, e) {
  if (e)
    throw new Error(
      "Cannot call `" + n + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Ax(n) {
  if (!_y(n) || typeof n.type != "string")
    throw new TypeError("Expected node, got `" + n + "`");
}
function Ox(n, e, t) {
  if (!t)
    throw new Error(
      "`" + n + "` finished async. Use `" + e + "` instead"
    );
}
function p0(n) {
  return Yj(n) ? n : new jj(n);
}
function Yj(n) {
  return !!(n && typeof n == "object" && "message" in n && "messages" in n);
}
function Jj(n) {
  return typeof n == "string" || Xj(n);
}
function Xj(n) {
  return !!(n && typeof n == "object" && "byteLength" in n && "byteOffset" in n);
}
var tA = (n) => {
  throw TypeError(n);
}, nA = (n, e, t) => e.has(n) || tA("Cannot " + t), rt = (n, e, t) => (nA(n, e, "read from private field"), t ? t.call(n) : e.get(n)), fn = (n, e, t) => e.has(n) ? tA("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), $t = (n, e, t, r) => (nA(n, e, "write to private field"), e.set(n, t), t), es, oh, sp, op, lp, lh, ah, $s, ch, ap, cp, uh, up, hh, hp, fp, nc, jl, dp, fh;
class rA {
}
class iA {
  constructor() {
    this.elements = [], this.size = () => this.elements.length, this.top = () => this.elements.at(-1), this.push = (e) => {
      this.top()?.push(e);
    }, this.open = (e) => {
      this.elements.push(e);
    }, this.close = () => {
      const e = this.elements.pop();
      if (!e) throw mT();
      return e;
    };
  }
}
class q3 extends rA {
  constructor(e, t, r) {
    super(), this.type = e, this.content = t, this.attrs = r;
  }
  push(e, ...t) {
    this.content.push(e, ...t);
  }
  pop() {
    return this.content.pop();
  }
  static create(e, t, r) {
    return new q3(e, t, r);
  }
}
const zy = class extends iA {
  /// @internal
  constructor(e) {
    super(), fn(this, es), fn(this, oh), fn(this, sp), fn(this, op), fn(this, lp), fn(this, lh), fn(this, ah), $t(this, es, nt.none), $t(this, oh, (t) => t.isText), $t(this, sp, (t, r) => {
      if (rt(this, oh).call(this, t) && rt(this, oh).call(this, r) && nt.sameSet(t.marks, r.marks))
        return this.schema.text(t.text + r.text, t.marks);
    }), $t(this, op, (t) => {
      const r = Object.values({
        ...this.schema.nodes,
        ...this.schema.marks
      }).find((i) => i.spec.parseMarkdown.match(t));
      if (!r) throw K$(t);
      return r;
    }), $t(this, lp, (t) => {
      const r = rt(this, op).call(this, t);
      r.spec.parseMarkdown.runner(this, t, r);
    }), this.injectRoot = (t, r, i) => (this.openNode(r, i), this.next(t.children), this), this.openNode = (t, r) => (this.open(q3.create(t, [], r)), this), $t(this, lh, () => {
      $t(this, es, nt.none);
      const t = this.close();
      return rt(this, ah).call(this, t.type, t.attrs, t.content);
    }), this.closeNode = () => {
      try {
        rt(this, lh).call(this);
      } catch (t) {
        console.error(t);
      }
      return this;
    }, $t(this, ah, (t, r, i) => {
      const s = t.createAndFill(r, i, rt(this, es));
      if (!s) throw U$(t, r, i);
      return this.push(s), s;
    }), this.addNode = (t, r, i) => {
      try {
        rt(this, ah).call(this, t, r, i);
      } catch (s) {
        console.error(s);
      }
      return this;
    }, this.openMark = (t, r) => {
      const i = t.create(r);
      return $t(this, es, i.addToSet(rt(this, es))), this;
    }, this.closeMark = (t) => ($t(this, es, t.removeFromSet(rt(this, es))), this), this.addText = (t) => {
      try {
        const r = this.top();
        if (!r) throw mT();
        const i = r.pop(), s = this.schema.text(t, rt(this, es));
        if (!i)
          return r.push(s), this;
        const o = rt(this, sp).call(this, i, s);
        return o ? (r.push(o), this) : (r.push(i, s), this);
      } catch (r) {
        return console.error(r), this;
      }
    }, this.build = () => {
      let t;
      do
        t = rt(this, lh).call(this);
      while (this.size());
      return t;
    }, this.next = (t = []) => ([t].flat().forEach((r) => rt(this, lp).call(this, r)), this), this.toDoc = () => this.build(), this.run = (t, r) => {
      const i = t.runSync(
        t.parse(r),
        r
      );
      return this.next(i), this;
    }, this.schema = e;
  }
};
es = /* @__PURE__ */ new WeakMap();
oh = /* @__PURE__ */ new WeakMap();
sp = /* @__PURE__ */ new WeakMap();
op = /* @__PURE__ */ new WeakMap();
lp = /* @__PURE__ */ new WeakMap();
lh = /* @__PURE__ */ new WeakMap();
ah = /* @__PURE__ */ new WeakMap();
zy.create = (n, e) => {
  const t = new zy(n);
  return (r) => (t.run(e, r), t.toDoc());
};
let Zj = zy;
const Fy = class extends rA {
  constructor(e, t, r, i = {}) {
    super(), this.type = e, this.children = t, this.value = r, this.props = i, this.push = (s, ...o) => {
      this.children || (this.children = []), this.children.push(s, ...o);
    }, this.pop = () => this.children?.pop();
  }
};
Fy.create = (n, e, t, r = {}) => new Fy(n, e, t, r);
let Ex = Fy;
const Qj = (n) => Object.prototype.hasOwnProperty.call(n, "size"), Hy = class extends iA {
  /// @internal
  constructor(e) {
    super(), fn(this, $s), fn(this, ch), fn(this, ap), fn(this, cp), fn(this, uh), fn(this, up), fn(this, hh), fn(this, hp), fn(this, fp), fn(this, nc), fn(this, jl), fn(this, dp), fn(this, fh), $t(this, $s, nt.none), $t(this, ch, (t) => {
      const r = Object.values({
        ...this.schema.nodes,
        ...this.schema.marks
      }).find((i) => i.spec.toMarkdown.match(t));
      if (!r) throw G$(t.type);
      return r;
    }), $t(this, ap, (t) => rt(this, ch).call(this, t).spec.toMarkdown.runner(this, t)), $t(this, cp, (t, r) => rt(this, ch).call(this, t).spec.toMarkdown.runner(this, t, r)), $t(this, uh, (t) => {
      const { marks: r } = t, i = (l) => l.type.spec.priority ?? 50;
      [...r].sort((l, a) => i(l) - i(a)).every((l) => !rt(this, cp).call(this, l, t)) && rt(this, ap).call(this, t), r.forEach((l) => rt(this, fh).call(this, l));
    }), $t(this, up, (t, r) => {
      if (t.type === r || t.children?.length !== 1) return t;
      const i = (a) => {
        if (a.type === r) return a;
        if (a.children?.length !== 1) return null;
        const [c] = a.children;
        return c ? i(c) : null;
      }, s = i(t);
      if (!s) return t;
      const o = s.children ? [...s.children] : void 0, l = { ...t, children: o };
      return l.children = o, s.children = [l], s;
    }), $t(this, hh, (t) => {
      const { children: r } = t;
      return r && (t.children = r.reduce((i, s, o) => {
        if (o === 0) return [s];
        const l = i.at(-1);
        if (l && l.isMark && s.isMark) {
          s = rt(this, up).call(this, s, l.type);
          const { children: a, ...c } = s, { children: u, ...h } = l;
          if (s.type === l.type && a && u && JSON.stringify(c) === JSON.stringify(h)) {
            const f = {
              ...h,
              children: [...u, ...a]
            };
            return i.slice(0, -1).concat(rt(this, hh).call(this, f));
          }
        }
        return i.concat(s);
      }, [])), t;
    }), $t(this, hp, (t) => {
      const r = {
        ...t.props,
        type: t.type
      };
      return t.children && (r.children = t.children), t.value && (r.value = t.value), r;
    }), this.openNode = (t, r, i) => (this.open(Ex.create(t, void 0, r, i)), this), $t(this, fp, (t, r) => {
      let i = "", s = "";
      const o = t.children;
      let l = -1, a = -1;
      const c = (h) => {
        h && h.forEach((f, d) => {
          f.type === "text" && f.value && (l < 0 && (l = d), a = d);
        });
      };
      if (o) {
        c(o);
        const h = o?.[a], f = o?.[l];
        if (h && h.value.endsWith(" ")) {
          const d = h.value, p = d.trimEnd();
          s = d.slice(p.length), h.value = p;
        }
        if (f && f.value.startsWith(" ")) {
          const d = f.value, p = d.trimStart();
          i = d.slice(0, d.length - p.length), f.value = p;
        }
      }
      i.length && rt(this, jl).call(this, "text", void 0, i);
      const u = r();
      return s.length && rt(this, jl).call(this, "text", void 0, s), u;
    }), $t(this, nc, (t = !1) => {
      const r = this.close(), i = () => rt(this, jl).call(this, r.type, r.children, r.value, r.props);
      return t ? rt(this, fp).call(this, r, i) : i();
    }), this.closeNode = () => (rt(this, nc).call(this), this), $t(this, jl, (t, r, i, s) => {
      const o = Ex.create(t, r, i, s), l = rt(this, hh).call(this, rt(this, hp).call(this, o));
      return this.push(l), l;
    }), this.addNode = (t, r, i, s) => (rt(this, jl).call(this, t, r, i, s), this), $t(this, dp, (t, r, i, s) => t.isInSet(rt(this, $s)) ? this : ($t(this, $s, t.addToSet(rt(this, $s))), this.openNode(r, i, { ...s, isMark: !0 }))), $t(this, fh, (t) => {
      t.isInSet(rt(this, $s)) && ($t(this, $s, t.type.removeFromSet(rt(this, $s))), rt(this, nc).call(this, !0));
    }), this.withMark = (t, r, i, s) => (rt(this, dp).call(this, t, r, i, s), this), this.closeMark = (t) => (rt(this, fh).call(this, t), this), this.build = () => {
      let t = null;
      do
        t = rt(this, nc).call(this);
      while (this.size());
      return t;
    }, this.next = (t) => Qj(t) ? (t.forEach((r) => {
      rt(this, uh).call(this, r);
    }), this) : (rt(this, uh).call(this, t), this), this.toString = (t) => t.stringify(this.build()), this.run = (t) => (this.next(t), this), this.schema = e;
  }
};
$s = /* @__PURE__ */ new WeakMap();
ch = /* @__PURE__ */ new WeakMap();
ap = /* @__PURE__ */ new WeakMap();
cp = /* @__PURE__ */ new WeakMap();
uh = /* @__PURE__ */ new WeakMap();
up = /* @__PURE__ */ new WeakMap();
hh = /* @__PURE__ */ new WeakMap();
hp = /* @__PURE__ */ new WeakMap();
fp = /* @__PURE__ */ new WeakMap();
nc = /* @__PURE__ */ new WeakMap();
jl = /* @__PURE__ */ new WeakMap();
dp = /* @__PURE__ */ new WeakMap();
fh = /* @__PURE__ */ new WeakMap();
Hy.create = (n, e) => {
  const t = new Hy(n);
  return (r) => (t.run(r), t.toString(e));
};
let eU = Hy;
const W3 = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function sA(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const oA = (n, e, t) => {
  let r = sA(n, t);
  if (!r)
    return !1;
  let i = j3(r);
  if (!i) {
    let o = r.blockRange(), l = o && h1(o);
    return l == null ? !1 : (e && e(n.tr.lift(o, l).scrollIntoView()), !0);
  }
  let s = i.nodeBefore;
  if (uA(n, i, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (Hc(s, "end") || $e.isSelectable(s)))
    for (let o = r.depth; ; o--) {
      let l = d1(n.doc, r.before(o), r.after(o), be.empty);
      if (l && l.slice.size < l.to - l.from) {
        if (e) {
          let a = n.tr.step(l);
          a.setSelection(Hc(s, "end") ? Ge.findFrom(a.doc.resolve(a.mapping.map(i.pos, -1)), -1) : $e.create(a.doc, i.pos - s.nodeSize)), e(a.scrollIntoView());
        }
        return !0;
      }
      if (o == 1 || r.node(o - 1).childCount > 1)
        break;
    }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, tU = (n, e, t) => {
  let r = sA(n, t);
  if (!r)
    return !1;
  let i = j3(r);
  return i ? nU(n, i, e) : !1;
};
function nU(n, e, t) {
  let r = e.nodeBefore, i = r, s = e.pos - 1;
  for (; !i.isTextblock; s--) {
    if (i.type.spec.isolating)
      return !1;
    let u = i.lastChild;
    if (!u)
      return !1;
    i = u;
  }
  let o = e.nodeAfter, l = o, a = e.pos + 1;
  for (; !l.isTextblock; a++) {
    if (l.type.spec.isolating)
      return !1;
    let u = l.firstChild;
    if (!u)
      return !1;
    l = u;
  }
  let c = d1(n.doc, s, a, be.empty);
  if (!c || c.from != s || c instanceof Cn && c.slice.size >= a - s)
    return !1;
  if (t) {
    let u = n.tr.step(c);
    u.setSelection(Ee.create(u.doc, s)), t(u.scrollIntoView());
  }
  return !0;
}
function Hc(n, e, t = !1) {
  for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (t && r.childCount != 1)
      return !1;
  }
  return !1;
}
const lA = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0)
      return !1;
    s = j3(r);
  }
  let o = s && s.nodeBefore;
  return !o || !$e.isSelectable(o) ? !1 : (e && e(n.tr.setSelection($e.create(n.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function j3(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function rU(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const iU = (n, e, t) => {
  let r = rU(n, t);
  if (!r)
    return !1;
  let i = aA(r);
  if (!i)
    return !1;
  let s = i.nodeAfter;
  if (uA(n, i, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (Hc(s, "start") || $e.isSelectable(s))) {
    let o = d1(n.doc, r.before(), r.after(), be.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let l = n.tr.step(o);
        l.setSelection(Hc(s, "start") ? Ge.findFrom(l.doc.resolve(l.mapping.map(i.pos)), 1) : $e.create(l.doc, l.mapping.map(i.pos))), e(l.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, sU = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size)
      return !1;
    s = aA(r);
  }
  let o = s && s.nodeAfter;
  return !o || !$e.isSelectable(o) ? !1 : (e && e(n.tr.setSelection($e.create(n.doc, s.pos)).scrollIntoView()), !0);
};
function aA(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const oU = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function U3(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const cA = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(r))
    return !1;
  let i = t.node(-1), s = t.indexAfter(-1), o = U3(i.contentMatchAt(s));
  if (!o || !i.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let l = t.after(), a = n.tr.replaceWith(l, l, o.createAndFill());
    a.setSelection(Ge.near(a.doc.resolve(l), 1)), e(a.scrollIntoView());
  }
  return !0;
}, lU = (n, e) => {
  let t = n.selection, { $from: r, $to: i } = t;
  if (t instanceof Or || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let s = U3(i.parent.contentMatchAt(i.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, l = n.tr.insert(o, s.createAndFill());
    l.setSelection(Ee.create(l.doc, o + 1)), e(l.scrollIntoView());
  }
  return !0;
}, aU = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let s = t.before();
    if (Wh(n.doc, s))
      return e && e(n.tr.split(s).scrollIntoView()), !0;
  }
  let r = t.blockRange(), i = r && h1(r);
  return i == null ? !1 : (e && e(n.tr.lift(r, i).scrollIntoView()), !0);
};
function cU(n) {
  return (e, t) => {
    let { $from: r, $to: i } = e.selection;
    if (e.selection instanceof $e && e.selection.node.isBlock)
      return !r.parentOffset || !Wh(e.doc, r.pos) ? !1 : (t && t(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let s = [], o, l, a = !1, c = !1;
    for (let d = r.depth; ; d--)
      if (r.node(d).isBlock) {
        a = r.end(d) == r.pos + (r.depth - d), c = r.start(d) == r.pos - (r.depth - d), l = U3(r.node(d - 1).contentMatchAt(r.indexAfter(d - 1))), s.unshift(a && l ? { type: l } : null), o = d;
        break;
      } else {
        if (d == 1)
          return !1;
        s.unshift(null);
      }
    let u = e.tr;
    (e.selection instanceof Ee || e.selection instanceof Or) && u.deleteSelection();
    let h = u.mapping.map(r.pos), f = Wh(u.doc, h, s.length, s);
    if (f || (s[0] = l ? { type: l } : null, f = Wh(u.doc, h, s.length, s)), !f)
      return !1;
    if (u.split(h, s.length, s), !a && c && r.node(o).type != l) {
      let d = u.mapping.map(r.before(o)), p = u.doc.resolve(d);
      l && r.node(o - 1).canReplaceWith(p.index(), p.index() + 1, l) && u.setNodeMarkup(u.mapping.map(r.before(o)), l);
    }
    return t && t(u.scrollIntoView()), !0;
  };
}
const uU = cU(), hU = (n, e) => (e && e(n.tr.setSelection(new Or(n.doc))), !0);
function fU(n, e, t) {
  let r = e.nodeBefore, i = e.nodeAfter, s = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || f1(n.doc, e.pos)) ? !1 : (t && t(n.tr.join(e.pos).scrollIntoView()), !0);
}
function uA(n, e, t, r) {
  let i = e.nodeBefore, s = e.nodeAfter, o, l, a = i.type.spec.isolating || s.type.spec.isolating;
  if (!a && fU(n, e, t))
    return !0;
  let c = !a && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (o = (l = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && l.matchType(o[0] || s.type).validEnd) {
    if (t) {
      let d = e.pos + s.nodeSize, p = ce.empty;
      for (let b = o.length - 1; b >= 0; b--)
        p = ce.from(o[b].create(null, p));
      p = ce.from(i.copy(p));
      let m = n.tr.step(new Yn(e.pos - 1, d, e.pos, d, new be(p, 1, 0), o.length, !0)), g = m.doc.resolve(d + 2 * o.length);
      g.nodeAfter && g.nodeAfter.type == i.type && f1(m.doc, g.pos) && m.join(g.pos), t(m.scrollIntoView());
    }
    return !0;
  }
  let u = s.type.spec.isolating || r > 0 && a ? null : Ge.findFrom(e, 1), h = u && u.$from.blockRange(u.$to), f = h && h1(h);
  if (f != null && f >= e.depth)
    return t && t(n.tr.lift(h, f).scrollIntoView()), !0;
  if (c && Hc(s, "start", !0) && Hc(i, "end")) {
    let d = i, p = [];
    for (; p.push(d), !d.isTextblock; )
      d = d.lastChild;
    let m = s, g = 1;
    for (; !m.isTextblock; m = m.firstChild)
      g++;
    if (d.canReplace(d.childCount, d.childCount, m.content)) {
      if (t) {
        let b = ce.empty;
        for (let k = p.length - 1; k >= 0; k--)
          b = ce.from(p[k].copy(b));
        let w = n.tr.step(new Yn(e.pos - p.length, e.pos + s.nodeSize, e.pos + g, e.pos + s.nodeSize - g, new be(b, p.length, 0), 0, !0));
        t(w.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function hA(n) {
  return function(e, t) {
    let r = e.selection, i = n < 0 ? r.$from : r.$to, s = i.depth;
    for (; i.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return i.node(s).isTextblock ? (t && t(e.tr.setSelection(Ee.create(e.doc, n < 0 ? i.start(s) : i.end(s)))), !0) : !1;
  };
}
const dU = hA(-1), pU = hA(1);
function K3(n, e = null) {
  return function(t, r) {
    let { $from: i, $to: s } = t.selection, o = i.blockRange(s), l = o && E3(o, n, e);
    return l ? (r && r(t.tr.wrap(o, l).scrollIntoView()), !0) : !1;
  };
}
function Lf(n, e = null) {
  return function(t, r) {
    let i = !1;
    for (let s = 0; s < t.selection.ranges.length && !i; s++) {
      let { $from: { pos: o }, $to: { pos: l } } = t.selection.ranges[s];
      t.doc.nodesBetween(o, l, (a, c) => {
        if (i)
          return !1;
        if (!(!a.isTextblock || a.hasMarkup(n, e)))
          if (a.type == n)
            i = !0;
          else {
            let u = t.doc.resolve(c), h = u.index();
            i = u.parent.canReplaceWith(h, h + 1, n);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let s = t.tr;
      for (let o = 0; o < t.selection.ranges.length; o++) {
        let { $from: { pos: l }, $to: { pos: a } } = t.selection.ranges[o];
        s.setBlockType(l, a, n, e);
      }
      r(s.scrollIntoView());
    }
    return !0;
  };
}
function mU(n, e, t, r) {
  for (let i = 0; i < e.length; i++) {
    let { $from: s, $to: o } = e[i], l = s.depth == 0 ? n.inlineContent && n.type.allowsMarkType(t) : !1;
    if (n.nodesBetween(s.pos, o.pos, (a, c) => {
      if (l)
        return !1;
      l = a.inlineContent && a.type.allowsMarkType(t);
    }), l)
      return !0;
  }
  return !1;
}
function S1(n, e = null, t) {
  return function(r, i) {
    let { empty: s, $cursor: o, ranges: l } = r.selection;
    if (s && !o || !mU(r.doc, l, n))
      return !1;
    if (i)
      if (o)
        n.isInSet(r.storedMarks || o.marks()) ? i(r.tr.removeStoredMark(n)) : i(r.tr.addStoredMark(n.create(e)));
      else {
        let a, c = r.tr;
        a = !l.some((u) => r.doc.rangeHasMark(u.$from.pos, u.$to.pos, n));
        for (let u = 0; u < l.length; u++) {
          let { $from: h, $to: f } = l[u];
          if (!a)
            c.removeMark(h.pos, f.pos, n);
          else {
            let d = h.pos, p = f.pos, m = h.nodeAfter, g = f.nodeBefore, b = m && m.isText ? /^\s*/.exec(m.text)[0].length : 0, w = g && g.isText ? /\s*$/.exec(g.text)[0].length : 0;
            d + b < p && (d += b, p -= w), c.addMark(d, p, n.create(e));
          }
        }
        i(c.scrollIntoView());
      }
    return !0;
  };
}
function ru(...n) {
  return function(e, t, r) {
    for (let i = 0; i < n.length; i++)
      if (n[i](e, t, r))
        return !0;
    return !1;
  };
}
let d2 = ru(W3, oA, lA), Ix = ru(W3, iU, sU);
const Gs = {
  Enter: ru(oU, lU, aU, uU),
  "Mod-Enter": cA,
  Backspace: d2,
  "Mod-Backspace": d2,
  "Shift-Backspace": d2,
  Delete: Ix,
  "Mod-Delete": Ix,
  "Mod-a": hU
}, fA = {
  "Ctrl-h": Gs.Backspace,
  "Alt-Backspace": Gs["Mod-Backspace"],
  "Ctrl-d": Gs.Delete,
  "Ctrl-Alt-Backspace": Gs["Mod-Delete"],
  "Alt-Delete": Gs["Mod-Delete"],
  "Alt-d": Gs["Mod-Delete"],
  "Ctrl-a": dU,
  "Ctrl-e": pU
};
for (let n in Gs)
  fA[n] = Gs[n];
const gU = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform ? os.platform() == "darwin" : !1, yU = gU ? fA : Gs, bU = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), vU = typeof navigator < "u" && /Win/.test(navigator.platform);
function wU(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let r, i, s, o;
  for (let l = 0; l < e.length - 1; l++) {
    let a = e[l];
    if (/^(cmd|meta|m)$/i.test(a))
      o = !0;
    else if (/^a(lt)?$/i.test(a))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(a))
      i = !0;
    else if (/^s(hift)?$/i.test(a))
      s = !0;
    else if (/^mod$/i.test(a))
      bU ? o = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + a);
  }
  return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Meta-" + t), s && (t = "Shift-" + t), t;
}
function xU(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[wU(t)] = n[t];
  return e;
}
function p2(n, e, t = !0) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
}
function dA(n) {
  return new Ut({ props: { handleKeyDown: G3(n) } });
}
function G3(n) {
  let e = xU(n);
  return function(t, r) {
    let i = QS(r), s, o = e[p2(i, r)];
    if (o && o(t.state, t.dispatch, t))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let l = e[p2(i, r, !1)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(vU && r.ctrlKey && r.altKey) && (s = ao[r.keyCode]) && s != i) {
        let l = e[p2(s, r)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const _n = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, $c = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let $y = null;
const Us = function(n, e, t) {
  let r = $y || ($y = document.createRange());
  return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r;
}, kU = function() {
  $y = null;
}, Oa = function(n, e, t, r) {
  return t && (Dx(n, e, t, r, -1) || Dx(n, e, t, r, 1));
}, SU = /^(img|br|input|textarea|hr)$/i;
function Dx(n, e, t, r, i) {
  for (var s; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : li(n))) {
      let o = n.parentNode;
      if (!o || o.nodeType != 1 || pd(n) || SU.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = _n(n) + (i < 0 ? 0 : 1), n = o;
    } else if (n.nodeType == 1) {
      let o = n.childNodes[e + (i < 0 ? -1 : 0)];
      if (o.nodeType == 1 && o.contentEditable == "false")
        if (!((s = o.pmViewDesc) === null || s === void 0) && s.ignoreForSelection)
          e += i;
        else
          return !1;
      else
        n = o, e = i < 0 ? li(n) : 0;
    } else
      return !1;
  }
}
function li(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function CU(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e - 1], e = li(n);
    } else if (n.parentNode && !pd(n))
      e = _n(n), n = n.parentNode;
    else
      return null;
  }
}
function MU(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e < n.nodeValue.length)
      return n;
    if (n.nodeType == 1 && e < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e], e = 0;
    } else if (n.parentNode && !pd(n))
      e = _n(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
function TU(n, e, t) {
  for (let r = e == 0, i = e == li(n); r || i; ) {
    if (n == t)
      return !0;
    let s = _n(n);
    if (n = n.parentNode, !n)
      return !1;
    r = r && s == 0, i = i && s == li(n);
  }
}
function pd(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const C1 = function(n) {
  return n.focusNode && Oa(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function Zl(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function AU(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function OU(n, e, t) {
  if (n.caretPositionFromPoint)
    try {
      let r = n.caretPositionFromPoint(e, t);
      if (r)
        return { node: r.offsetNode, offset: Math.min(li(r.offsetNode), r.offset) };
    } catch {
    }
  if (n.caretRangeFromPoint) {
    let r = n.caretRangeFromPoint(e, t);
    if (r)
      return { node: r.startContainer, offset: Math.min(li(r.startContainer), r.startOffset) };
  }
}
const xs = typeof navigator < "u" ? navigator : null, Nx = typeof document < "u" ? document : null, Al = xs && xs.userAgent || "", Vy = /Edge\/(\d+)/.exec(Al), pA = /MSIE \d/.exec(Al), qy = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Al), Er = !!(pA || qy || Vy), il = pA ? document.documentMode : qy ? +qy[1] : Vy ? +Vy[1] : 0, pi = !Er && /gecko\/(\d+)/i.test(Al);
pi && +(/Firefox\/(\d+)/.exec(Al) || [0, 0])[1];
const Wy = !Er && /Chrome\/(\d+)/.exec(Al), Kn = !!Wy, mA = Wy ? +Wy[1] : 0, dr = !Er && !!xs && /Apple Computer/.test(xs.vendor), Vc = dr && (/Mobile\/\w+/.test(Al) || !!xs && xs.maxTouchPoints > 2), ii = Vc || (xs ? /Mac/.test(xs.platform) : !1), EU = xs ? /Win/.test(xs.platform) : !1, Qs = /Android \d/.test(Al), md = !!Nx && "webkitFontSmoothing" in Nx.documentElement.style, IU = md ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function DU(n) {
  let e = n.defaultView && n.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function Bs(n, e) {
  return typeof n == "number" ? n : n[e];
}
function NU(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * r
  };
}
function Rx(n, e, t) {
  let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, s = n.dom.ownerDocument;
  for (let o = t || n.dom; o; ) {
    if (o.nodeType != 1) {
      o = $c(o);
      continue;
    }
    let l = o, a = l == s.body, c = a ? DU(s) : NU(l), u = 0, h = 0;
    if (e.top < c.top + Bs(r, "top") ? h = -(c.top - e.top + Bs(i, "top")) : e.bottom > c.bottom - Bs(r, "bottom") && (h = e.bottom - e.top > c.bottom - c.top ? e.top + Bs(i, "top") - c.top : e.bottom - c.bottom + Bs(i, "bottom")), e.left < c.left + Bs(r, "left") ? u = -(c.left - e.left + Bs(i, "left")) : e.right > c.right - Bs(r, "right") && (u = e.right - c.right + Bs(i, "right")), u || h)
      if (a)
        s.defaultView.scrollBy(u, h);
      else {
        let d = l.scrollLeft, p = l.scrollTop;
        h && (l.scrollTop += h), u && (l.scrollLeft += u);
        let m = l.scrollLeft - d, g = l.scrollTop - p;
        e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g };
      }
    let f = a ? "fixed" : getComputedStyle(o).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    o = f == "absolute" ? o.offsetParent : $c(o);
  }
}
function RU(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i;
  for (let s = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let l = n.root.elementFromPoint(s, o);
    if (!l || l == n.dom || !n.dom.contains(l))
      continue;
    let a = l.getBoundingClientRect();
    if (a.top >= t - 20) {
      r = l, i = a.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: gA(n.dom) };
}
function gA(n) {
  let e = [], t = n.ownerDocument;
  for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = $c(r))
    ;
  return e;
}
function PU({ refDOM: n, refTop: e, stack: t }) {
  let r = n ? n.getBoundingClientRect().top : 0;
  yA(t, r == 0 ? 0 : r - e);
}
function yA(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: r, top: i, left: s } = n[t];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s);
  }
}
let Ya = null;
function _U(n) {
  if (n.setActive)
    return n.setActive();
  if (Ya)
    return n.focus(Ya);
  let e = gA(n);
  n.focus(Ya == null ? {
    get preventScroll() {
      return Ya = { preventScroll: !0 }, !0;
    }
  } : void 0), Ya || (Ya = !1, yA(e, 0));
}
function bA(n, e) {
  let t, r = 2e8, i, s = 0, o = e.top, l = e.top, a, c;
  for (let u = n.firstChild, h = 0; u; u = u.nextSibling, h++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = Us(u).getClientRects();
    else
      continue;
    for (let d = 0; d < f.length; d++) {
      let p = f[d];
      if (p.top <= o && p.bottom >= l) {
        o = Math.max(p.bottom, o), l = Math.min(p.top, l);
        let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
        if (m < r) {
          t = u, r = m, i = m && t.nodeType == 3 ? {
            left: p.right < e.left ? p.right : p.left,
            top: e.top
          } : e, u.nodeType == 1 && m && (s = h + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
          continue;
        }
      } else p.top > e.top && !a && p.left <= e.left && p.right >= e.left && (a = u, c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top });
      !t && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (s = h + 1);
    }
  }
  return !t && a && (t = a, i = c, r = 0), t && t.nodeType == 3 ? LU(t, i) : !t || r && t.nodeType == 1 ? { node: n, offset: s } : bA(t, i);
}
function LU(n, e) {
  let t = n.nodeValue.length, r = document.createRange();
  for (let i = 0; i < t; i++) {
    r.setEnd(n, i + 1), r.setStart(n, i);
    let s = Po(r, 1);
    if (s.top != s.bottom && Y3(e, s))
      return { node: n, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function Y3(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function BU(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function zU(n, e, t) {
  let { node: r, offset: i } = bA(e, t), s = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect();
    s = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(r, i, s);
}
function FU(n, e, t, r) {
  let i = -1;
  for (let s = e, o = !1; s != n.dom; ) {
    let l = n.docView.nearestDesc(s, !0), a;
    if (!l)
      return null;
    if (l.dom.nodeType == 1 && (l.node.isBlock && l.parent || !l.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((a = l.dom.getBoundingClientRect()).width || a.height) && (l.node.isBlock && l.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(l.dom.nodeName) && (!o && a.left > r.left || a.top > r.top ? i = l.posBefore : (!o && a.right < r.left || a.bottom < r.top) && (i = l.posAfter), o = !0), !l.contentDOM && i < 0 && !l.node.isText))
      return (l.node.isBlock ? r.top < (a.top + a.bottom) / 2 : r.left < (a.left + a.right) / 2) ? l.posBefore : l.posAfter;
    s = l.dom.parentNode;
  }
  return i > -1 ? i : n.docView.posFromDOM(e, t, -1);
}
function vA(n, e, t) {
  let r = n.childNodes.length;
  if (r && t.top < t.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = i; ; ) {
      let o = n.childNodes[s];
      if (o.nodeType == 1) {
        let l = o.getClientRects();
        for (let a = 0; a < l.length; a++) {
          let c = l[a];
          if (Y3(e, c))
            return vA(o, e, c);
        }
      }
      if ((s = (s + 1) % r) == i)
        break;
    }
  return n;
}
function HU(n, e) {
  let t = n.dom.ownerDocument, r, i = 0, s = OU(t, e.left, e.top);
  s && ({ node: r, offset: i } = s);
  let o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), l;
  if (!o || !n.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = n.dom.getBoundingClientRect();
    if (!Y3(e, c) || (o = vA(n.dom, e, c), !o))
      return null;
  }
  if (dr)
    for (let c = o; r && c; c = $c(c))
      c.draggable && (r = void 0);
  if (o = BU(o, e), r) {
    if (pi && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let u = r.childNodes[i], h;
      u.nodeName == "IMG" && (h = u.getBoundingClientRect()).right <= e.left && h.bottom > e.top && i++;
    }
    let c;
    md && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--, r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? l = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (l = FU(n, r, i, e));
  }
  l == null && (l = zU(n, o, e));
  let a = n.docView.nearestDesc(o, !0);
  return { pos: l, inside: a ? a.posAtStart - a.border : -1 };
}
function Px(n) {
  return n.top < n.bottom || n.left < n.right;
}
function Po(n, e) {
  let t = n.getClientRects();
  if (t.length) {
    let r = t[e < 0 ? 0 : t.length - 1];
    if (Px(r))
      return r;
  }
  return Array.prototype.find.call(t, Px) || n.getBoundingClientRect();
}
const $U = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function wA(n, e, t) {
  let { node: r, offset: i, atom: s } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = md || pi;
  if (r.nodeType == 3)
    if (o && ($U.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) {
      let a = Po(Us(r, i, i), t);
      if (pi && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let c = Po(Us(r, i - 1, i - 1), -1);
        if (c.top == a.top) {
          let u = Po(Us(r, i, i + 1), -1);
          if (u.top != a.top)
            return Hu(u, u.left < c.left);
        }
      }
      return a;
    } else {
      let a = i, c = i, u = t < 0 ? 1 : -1;
      return t < 0 && !i ? (c++, u = -1) : t >= 0 && i == r.nodeValue.length ? (a--, u = 1) : t < 0 ? a-- : c++, Hu(Po(Us(r, a, c), u), u < 0);
    }
  if (!n.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (t < 0 || i == li(r))) {
      let a = r.childNodes[i - 1];
      if (a.nodeType == 1)
        return m2(a.getBoundingClientRect(), !1);
    }
    if (s == null && i < li(r)) {
      let a = r.childNodes[i];
      if (a.nodeType == 1)
        return m2(a.getBoundingClientRect(), !0);
    }
    return m2(r.getBoundingClientRect(), t >= 0);
  }
  if (s == null && i && (t < 0 || i == li(r))) {
    let a = r.childNodes[i - 1], c = a.nodeType == 3 ? Us(a, li(a) - (o ? 0 : 1)) : a.nodeType == 1 && (a.nodeName != "BR" || !a.nextSibling) ? a : null;
    if (c)
      return Hu(Po(c, 1), !1);
  }
  if (s == null && i < li(r)) {
    let a = r.childNodes[i];
    for (; a.pmViewDesc && a.pmViewDesc.ignoreForCoords; )
      a = a.nextSibling;
    let c = a ? a.nodeType == 3 ? Us(a, 0, o ? 0 : 1) : a.nodeType == 1 ? a : null : null;
    if (c)
      return Hu(Po(c, -1), !0);
  }
  return Hu(Po(r.nodeType == 3 ? Us(r) : r, -t), t >= 0);
}
function Hu(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function m2(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function xA(n, e, t) {
  let r = n.state, i = n.root.activeElement;
  r != e && n.updateState(e), i != n.dom && n.focus();
  try {
    return t();
  } finally {
    r != e && n.updateState(r), i != n.dom && i && i.focus();
  }
}
function VU(n, e, t) {
  let r = e.selection, i = t == "up" ? r.$from : r.$to;
  return xA(n, e, () => {
    let { node: s } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let l = n.docView.nearestDesc(s, !0);
      if (!l)
        break;
      if (l.node.isBlock) {
        s = l.contentDOM || l.dom;
        break;
      }
      s = l.dom.parentNode;
    }
    let o = wA(n, i.pos, 1);
    for (let l = s.firstChild; l; l = l.nextSibling) {
      let a;
      if (l.nodeType == 1)
        a = l.getClientRects();
      else if (l.nodeType == 3)
        a = Us(l, 0, l.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < a.length; c++) {
        let u = a[c];
        if (u.bottom > u.top + 1 && (t == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const qU = /[\u0590-\u08ac]/;
function WU(n, e, t) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, s = !i, o = i == r.parent.content.size, l = n.domSelection();
  return l ? !qU.test(r.parent.textContent) || !l.modify ? t == "left" || t == "backward" ? s : o : xA(n, e, () => {
    let { focusNode: a, focusOffset: c, anchorNode: u, anchorOffset: h } = n.domSelectionRange(), f = l.caretBidiLevel;
    l.modify("move", t, "character");
    let d = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: p, focusOffset: m } = n.domSelectionRange(), g = p && !d.contains(p.nodeType == 1 ? p : p.parentNode) || a == p && c == m;
    try {
      l.collapse(u, h), a && (a != u || c != h) && l.extend && l.extend(a, c);
    } catch {
    }
    return f != null && (l.caretBidiLevel = f), g;
  }) : r.pos == r.start() || r.pos == r.end();
}
let _x = null, Lx = null, Bx = !1;
function jU(n, e, t) {
  return _x == e && Lx == t ? Bx : (_x = e, Lx = t, Bx = t == "up" || t == "down" ? VU(n, e, t) : WU(n, e, t));
}
const mi = 0, zx = 1, ta = 2, ks = 3;
class gd {
  constructor(e, t, r, i) {
    this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = mi, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, r = this.posAtStart; ; t++) {
      let i = this.children[t];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = t > _n(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (i == null && t == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i), o;
      if (s && (!t || s.node))
        if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          r = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let r = t; r; r = r.parent)
      if (r == this)
        return t;
  }
  posFromDOM(e, t, r) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i);
      if (s)
        return s.localPosFromDOM(e, t, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, r = 0; t < this.children.length; t++) {
      let i = this.children[t], s = r + i.size;
      if (r == e && s != r) {
        for (; !i.border && i.children.length; )
          for (let o = 0; o < i.children.length; o++) {
            let l = i.children[o];
            if (l.size) {
              i = l;
              break;
            }
          }
        return i;
      }
      if (e < s)
        return i.descAt(e - r - i.border);
      r = s;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r], l = s + o.size;
      if (l > e || o instanceof SA) {
        i = e - s;
        break;
      }
      s = l;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, t);
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof kA && s.side >= 0; r--)
      ;
    if (t <= 0) {
      let s, o = !0;
      for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = !1)
        ;
      return s && t && o && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : { node: this.contentDOM, offset: s ? _n(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, t) : { node: this.contentDOM, offset: s ? _n(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, s = -1;
    for (let o = r, l = 0; ; l++) {
      let a = this.children[l], c = o + a.size;
      if (i == -1 && e <= c) {
        let u = o + a.border;
        if (e >= u && t <= c - a.border && a.node && a.contentDOM && this.contentDOM.contains(a.contentDOM))
          return a.parseRange(e, t, u);
        e = o;
        for (let h = l; h > 0; h--) {
          let f = this.children[h - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            i = _n(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (c > t || l == this.children.length - 1)) {
        t = c;
        for (let u = l + 1; u < this.children.length; u++) {
          let h = this.children[u];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            s = _n(h.dom);
            break;
          }
          t += h.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = c;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: r } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || r == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, r, i = !1) {
    let s = Math.min(e, t), o = Math.max(e, t);
    for (let d = 0, p = 0; d < this.children.length; d++) {
      let m = this.children[d], g = p + m.size;
      if (s > p && o < g)
        return m.setSelection(e - p - m.border, t - p - m.border, r, i);
      p = g;
    }
    let l = this.domFromPos(e, e ? -1 : 1), a = t == e ? l : this.domFromPos(t, t ? -1 : 1), c = r.root.getSelection(), u = r.domSelectionRange(), h = !1;
    if ((pi || dr) && e == t) {
      let { node: d, offset: p } = l;
      if (d.nodeType == 3) {
        if (h = !!(p && d.nodeValue[p - 1] == `
`), h && p == d.nodeValue.length)
          for (let m = d, g; m; m = m.parentNode) {
            if (g = m.nextSibling) {
              g.nodeName == "BR" && (l = a = { node: g.parentNode, offset: _n(g) + 1 });
              break;
            }
            let b = m.pmViewDesc;
            if (b && b.node && b.node.isBlock)
              break;
          }
      } else {
        let m = d.childNodes[p - 1];
        h = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (pi && u.focusNode && u.focusNode != a.node && u.focusNode.nodeType == 1) {
      let d = u.focusNode.childNodes[u.focusOffset];
      d && d.contentEditable == "false" && (i = !0);
    }
    if (!(i || h && dr) && Oa(l.node, l.offset, u.anchorNode, u.anchorOffset) && Oa(a.node, a.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == t) && !(h && pi)) {
      c.collapse(l.node, l.offset);
      try {
        e != t && c.extend(a.node, a.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > t) {
        let p = l;
        l = a, a = p;
      }
      let d = document.createRange();
      d.setEnd(a.node, a.offset), d.setStart(l.node, l.offset), c.removeAllRanges(), c.addRange(d);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i], o = r + s.size;
      if (r == o ? e <= o && t >= r : e < o && t > r) {
        let l = r + s.border, a = o - s.border;
        if (e >= l && t <= a) {
          this.dirty = e == r || t == o ? ta : zx, e == l && t == a && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = ks : s.markDirty(e - l, t - l);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? ta : ks;
      }
      r = o;
    }
    this.dirty = ta;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let r = e == 1 ? ta : zx;
      t.dirty < r && (t.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class kA extends gd {
  constructor(e, t, r, i) {
    let s, o = t.type.toDOM;
    if (typeof o == "function" && (o = o(r, () => {
      if (!s)
        return i;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !t.type.spec.raw) {
      if (o.nodeType != 1) {
        let l = document.createElement("span");
        l.appendChild(o), o = l;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = t, this.widget = t, s = this;
  }
  matchesWidget(e) {
    return this.dirty == mi && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class UU extends gd {
  constructor(e, t, r, i) {
    super(e, [], t, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Ea extends gd {
  constructor(e, t, r, i, s) {
    super(e, [], r, i), this.mark = t, this.spec = s;
  }
  static create(e, t, r, i) {
    let s = i.nodeViews[t.type.name], o = s && s(t, i, r);
    return (!o || !o.dom) && (o = Sl.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new Ea(e, t, o.dom, o.contentDOM || o.dom, o);
  }
  parseRule() {
    return this.dirty & ks || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != ks && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != mi) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = mi;
    }
  }
  slice(e, t, r) {
    let i = Ea.create(this.parent, this.mark, !0, r), s = this.children, o = this.size;
    t < o && (s = Uy(s, t, o, r)), e > 0 && (s = Uy(s, 0, e, r));
    for (let l = 0; l < s.length; l++)
      s[l].parent = i;
    return i.children = s, i;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class sl extends gd {
  constructor(e, t, r, i, s, o, l, a, c) {
    super(e, [], s, o), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = l;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, r, i, s, o) {
    let l = s.nodeViews[t.type.name], a, c = l && l(t, s, () => {
      if (!a)
        return o;
      if (a.parent)
        return a.parent.posBeforeChild(a);
    }, r, i), u = c && c.dom, h = c && c.contentDOM;
    if (t.isText) {
      if (!u)
        u = document.createTextNode(t.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: h } = Sl.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
    !h && !t.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), t.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = TA(u, r, t), c ? a = new KU(e, t, r, i, u, h || null, f, c, s, o + 1) : t.isText ? new M1(e, t, r, i, u, f, s) : new sl(e, t, r, i, u, h || null, f, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let r = this.children[t];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => ce.empty);
    }
    return e;
  }
  matchesNode(e, t, r) {
    return this.dirty == mi && e.eq(this.node) && gm(t, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let r = this.node.inlineContent, i = t, s = e.composing ? this.localCompositionInfo(e, t) : null, o = s && s.pos > -1 ? s : null, l = s && s.pos < 0, a = new YU(this, o && o.node, e);
    ZU(this.node, this.innerDeco, (c, u, h) => {
      c.spec.marks ? a.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !h && a.syncToMarks(u == this.node.childCount ? nt.none : this.node.child(u).marks, r, e), a.placeWidget(c, e, i);
    }, (c, u, h, f) => {
      a.syncToMarks(c.marks, r, e);
      let d;
      a.findNodeMatch(c, u, h, f) || l && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (d = a.findIndexWithChild(s.node)) > -1 && a.updateNodeAt(c, u, h, d, e) || a.updateNextNode(c, u, h, e, f, i) || a.addNode(c, u, h, e, i), i += c.nodeSize;
    }), a.syncToMarks([], r, e), this.node.isTextblock && a.addTextblockHacks(), a.destroyRest(), (a.changed || this.dirty == ta) && (o && this.protectLocalComposition(e, o), CA(this.contentDOM, this.children, e), Vc && QU(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof Ee) || r < t || i > t + this.node.content.size)
      return null;
    let s = e.input.compositionNode;
    if (!s || !this.dom.contains(s.parentNode))
      return null;
    if (this.node.inlineContent) {
      let o = s.nodeValue, l = eK(this.node.content, o, r - t, i - t);
      return l < 0 ? null : { node: s, pos: l, text: o };
    } else
      return { node: s, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: r, text: i }) {
    if (this.getDesc(t))
      return;
    let s = t;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new UU(this, s, t, i);
    e.input.compositionNodes.push(o), this.children = Uy(this.children, r, r + i.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, r, i) {
    return this.dirty == ks || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, i), !0);
  }
  updateInner(e, t, r, i) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = mi;
  }
  updateOuterDeco(e) {
    if (gm(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = MA(this.dom, this.nodeDOM, jy(this.outerDeco, this.node, t), jy(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Fx(n, e, t, r, i) {
  TA(r, e, n);
  let s = new sl(void 0, n, e, t, r, r, r, i, 0);
  return s.contentDOM && s.updateChildren(i, 0), s;
}
class M1 extends sl {
  constructor(e, t, r, i, s, o, l) {
    super(e, t, r, i, s, null, o, l, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, r, i) {
    return this.dirty == ks || this.dirty != mi && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != mi || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = mi, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, r) {
    let i = this.node.cut(e, t), s = document.createTextNode(i.text);
    return new M1(this.parent, i, this.outerDeco, this.innerDeco, s, s, r);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = ks);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class SA extends gd {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == mi && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class KU extends sl {
  constructor(e, t, r, i, s, o, l, a, c, u) {
    super(e, t, r, i, s, o, l, c, u), this.spec = a;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, r, i) {
    if (this.dirty == ks)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let s = this.spec.update(e, t, r);
      return s && this.updateInner(e, t, r, i), s;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, t, r.root) : super.setSelection(e, t, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function CA(n, e, t) {
  let r = n.firstChild, i = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], l = o.dom;
    if (l.parentNode == n) {
      for (; l != r; )
        r = Hx(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, n.insertBefore(l, r);
    if (o instanceof Ea) {
      let a = r ? r.previousSibling : n.lastChild;
      CA(o.contentDOM, o.children, t), r = a ? a.nextSibling : n.firstChild;
    }
  }
  for (; r; )
    r = Hx(r), i = !0;
  i && t.trackWrites == n && (t.trackWrites = null);
}
const Kh = function(n) {
  n && (this.nodeName = n);
};
Kh.prototype = /* @__PURE__ */ Object.create(null);
const na = [new Kh()];
function jy(n, e, t) {
  if (n.length == 0)
    return na;
  let r = t ? na[0] : new Kh(), i = [r];
  for (let s = 0; s < n.length; s++) {
    let o = n[s].type.attrs;
    if (o) {
      o.nodeName && i.push(r = new Kh(o.nodeName));
      for (let l in o) {
        let a = o[l];
        a != null && (t && i.length == 1 && i.push(r = new Kh(e.isInline ? "span" : "div")), l == "class" ? r.class = (r.class ? r.class + " " : "") + a : l == "style" ? r.style = (r.style ? r.style + ";" : "") + a : l != "nodeName" && (r[l] = a));
      }
    }
  }
  return i;
}
function MA(n, e, t, r) {
  if (t == na && r == na)
    return e;
  let i = e;
  for (let s = 0; s < r.length; s++) {
    let o = r[s], l = t[s];
    if (s) {
      let a;
      l && l.nodeName == o.nodeName && i != n && (a = i.parentNode) && a.nodeName.toLowerCase() == o.nodeName || (a = document.createElement(o.nodeName), a.pmIsDeco = !0, a.appendChild(i), l = na[0]), i = a;
    }
    GU(i, l || na[0], o);
  }
  return i;
}
function GU(n, e, t) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r);
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]);
  if (e.class != t.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && n.classList.remove(r[s]);
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && n.classList.add(i[s]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        n.style.removeProperty(i[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function TA(n, e, t) {
  return MA(n, n, na, jy(e, t, n.nodeType != 1));
}
function gm(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function Hx(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class YU {
  constructor(e, t, r) {
    this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = JU(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let r = e; r < t; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, r) {
    let i = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = mi, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let l = -1;
      for (let a = this.index; a < Math.min(this.index + 3, this.top.children.length); a++) {
        let c = this.top.children[a];
        if (c.matchesMark(e[s]) && !this.isLocked(c.dom)) {
          l = a;
          break;
        }
      }
      if (l > -1)
        l > this.index && (this.changed = !0, this.destroyBetween(this.index, l)), this.top = this.top.children[this.index];
      else {
        let a = Ea.create(this.top, e[s], t, r);
        this.top.children.splice(this.index, 0, a), this.top = a, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, r, i) {
    let s = -1, o;
    if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, r))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let l = this.index, a = Math.min(this.top.children.length, l + 5); l < a; l++) {
        let c = this.top.children[l];
        if (c.matchesNode(e, t, r) && !this.preMatch.matched.has(c)) {
          s = l;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, t, r, i, s) {
    let o = this.top.children[i];
    return o.dirty == ks && o.dom == o.contentDOM && (o.dirty = ta), o.update(e, t, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, r, i, s, o) {
    for (let l = this.index; l < this.top.children.length; l++) {
      let a = this.top.children[l];
      if (a instanceof sl) {
        let c = this.preMatch.matched.get(a);
        if (c != null && c != s)
          return !1;
        let u = a.dom, h, f = this.isLocked(u) && !(e.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == e.text && a.dirty != ks && gm(t, a.outerDeco));
        if (!f && a.update(e, t, r, i))
          return this.destroyBetween(this.index, l), a.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (h = this.recreateWrapper(a, e, t, r, i, o)))
          return this.destroyBetween(this.index, l), this.top.children[this.index] = h, h.contentDOM && (h.dirty = ta, h.updateChildren(i, o + 1), h.dirty = mi), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, r, i, s, o) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !gm(r, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let l = sl.create(this.top, t, r, i, s, o);
    if (l.contentDOM) {
      l.children = e.children, e.children = [];
      for (let a of l.children)
        a.parent = l;
    }
    return e.destroy(), l;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, r, i, s) {
    let o = sl.create(this.top, e, t, r, i, s);
    o.contentDOM && o.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0;
  }
  placeWidget(e, t, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new kA(this.top, e, t, r);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof Ea; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof M1) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((dr || Kn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new SA(this.top, [], r, null);
      t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function JU(n, e) {
  let t = e, r = t.children.length, i = n.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e: for (; i > 0; ) {
    let l;
    for (; ; )
      if (r) {
        let c = t.children[r - 1];
        if (c instanceof Ea)
          t = c, r = c.children.length;
        else {
          l = c, r--;
          break;
        }
      } else {
        if (t == e)
          break e;
        r = t.parent.children.indexOf(t), t = t.parent;
      }
    let a = l.node;
    if (a) {
      if (a != n.child(i - 1))
        break;
      --i, s.set(l, i), o.push(l);
    }
  }
  return { index: i, matched: s, matches: o.reverse() };
}
function XU(n, e) {
  return n.type.side - e.type.side;
}
function ZU(n, e, t, r) {
  let i = e.locals(n), s = 0;
  if (i.length == 0) {
    for (let c = 0; c < n.childCount; c++) {
      let u = n.child(c);
      r(u, i, e.forChild(s, u), c), s += u.nodeSize;
    }
    return;
  }
  let o = 0, l = [], a = null;
  for (let c = 0; ; ) {
    let u, h;
    for (; o < i.length && i[o].to == s; ) {
      let g = i[o++];
      g.widget && (u ? (h || (h = [u])).push(g) : u = g);
    }
    if (u)
      if (h) {
        h.sort(XU);
        for (let g = 0; g < h.length; g++)
          t(h[g], c, !!a);
      } else
        t(u, c, !!a);
    let f, d;
    if (a)
      d = -1, f = a, a = null;
    else if (c < n.childCount)
      d = c, f = n.child(c++);
    else
      break;
    for (let g = 0; g < l.length; g++)
      l[g].to <= s && l.splice(g--, 1);
    for (; o < i.length && i[o].from <= s && i[o].to > s; )
      l.push(i[o++]);
    let p = s + f.nodeSize;
    if (f.isText) {
      let g = p;
      o < i.length && i[o].from < g && (g = i[o].from);
      for (let b = 0; b < l.length; b++)
        l[b].to < g && (g = l[b].to);
      g < p && (a = f.cut(g - s), f = f.cut(0, g - s), p = g, d = -1);
    } else
      for (; o < i.length && i[o].to < p; )
        o++;
    let m = f.isInline && !f.isLeaf ? l.filter((g) => !g.inline) : l.slice();
    r(f, m, e.forChild(s, f), d), s = p;
  }
}
function QU(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function eK(n, e, t, r) {
  for (let i = 0, s = 0; i < n.childCount && s <= r; ) {
    let o = n.child(i++), l = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let a = o.text;
    for (; i < n.childCount; ) {
      let c = n.child(i++);
      if (s += c.nodeSize, !c.isText)
        break;
      a += c.text;
    }
    if (s >= t) {
      if (s >= r && a.slice(r - e.length - l, r - l) == e)
        return r - e.length;
      let c = l < r ? a.lastIndexOf(e, r - l - 1) : -1;
      if (c >= 0 && c + e.length + l >= t)
        return l + c;
      if (t == r && a.length >= r + e.length - l && a.slice(r - l, r - l + e.length) == e)
        return r;
    }
  }
  return -1;
}
function Uy(n, e, t, r, i) {
  let s = [];
  for (let o = 0, l = 0; o < n.length; o++) {
    let a = n[o], c = l, u = l += a.size;
    c >= t || u <= e ? s.push(a) : (c < e && s.push(a.slice(0, e - c, r)), i && (s.push(i), i = void 0), u > t && s.push(a.slice(t - c, a.size, r)));
  }
  return s;
}
function J3(n, e = null) {
  let t = n.domSelectionRange(), r = n.state.doc;
  if (!t.focusNode)
    return null;
  let i = n.docView.nearestDesc(t.focusNode), s = i && i.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (o < 0)
    return null;
  let l = r.resolve(o), a, c;
  if (C1(t)) {
    for (a = o; i && !i.node; )
      i = i.parent;
    let h = i.node;
    if (i && h.isAtom && $e.isSelectable(h) && i.parent && !(h.isInline && TU(t.focusNode, t.focusOffset, i.dom))) {
      let f = i.posBefore;
      c = new $e(o == f ? l : r.resolve(f));
    }
  } else {
    if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
      let h = o, f = o;
      for (let d = 0; d < t.rangeCount; d++) {
        let p = t.getRangeAt(d);
        h = Math.min(h, n.docView.posFromDOM(p.startContainer, p.startOffset, 1)), f = Math.max(f, n.docView.posFromDOM(p.endContainer, p.endOffset, -1));
      }
      if (h < 0)
        return null;
      [a, o] = f == n.state.selection.anchor ? [f, h] : [h, f], l = r.resolve(o);
    } else
      a = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (a < 0)
      return null;
  }
  let u = r.resolve(a);
  if (!c) {
    let h = e == "pointer" || n.state.selection.head < l.pos && !s ? 1 : -1;
    c = X3(n, u, l, h);
  }
  return c;
}
function AA(n) {
  return n.editable ? n.hasFocus() : EA(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function io(n, e = !1) {
  let t = n.state.selection;
  if (OA(n, t), !!AA(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && Kn) {
      let r = n.domSelectionRange(), i = n.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && Oa(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      nK(n);
    else {
      let { anchor: r, head: i } = t, s, o;
      $x && !(t instanceof Ee) && (t.$from.parent.inlineContent || (s = Vx(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = Vx(n, t.to))), n.docView.setSelection(r, i, n, e), $x && (s && qx(s), o && qx(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && tK(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const $x = dr || Kn && mA < 63;
function Vx(n, e) {
  let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, s = r ? t.childNodes[r - 1] : null;
  if (dr && i && i.contentEditable == "false")
    return g2(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return g2(i);
    if (s)
      return g2(s);
  }
}
function g2(n) {
  return n.contentEditable = "true", dr && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function qx(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function tK(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!AA(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function nK(n) {
  let e = n.domSelection();
  if (!e)
    return;
  let t = n.cursorWrapper.dom, r = t.nodeName == "IMG";
  r ? e.collapse(t.parentNode, _n(t) + 1) : e.collapse(t, 0), !r && !n.state.selection.visible && Er && il <= 11 && (t.disabled = !0, t.disabled = !1);
}
function OA(n, e) {
  if (e instanceof $e) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (Wx(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    Wx(n);
}
function Wx(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function X3(n, e, t, r) {
  return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || Ee.between(e, t, r);
}
function jx(n) {
  return n.editable && !n.hasFocus() ? !1 : EA(n);
}
function EA(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function rK(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return Oa(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function Ky(n, e) {
  let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), s = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && Ge.findFrom(s, e);
}
function Ho(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Ux(n, e, t) {
  let r = n.state.selection;
  if (r instanceof Ee)
    if (t.indexOf("s") > -1) {
      let { $head: i } = r, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let o = n.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return Ho(n, new Ee(r.$anchor, o));
    } else if (r.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = Ky(n.state, e);
        return i && i instanceof $e ? Ho(n, i) : !1;
      } else if (!(ii && t.indexOf("m") > -1)) {
        let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
        if (!s || s.isText)
          return !1;
        let l = e < 0 ? i.pos - s.nodeSize : i.pos;
        return s.isAtom || (o = n.docView.descAt(l)) && !o.contentDOM ? $e.isSelectable(s) ? Ho(n, new $e(e < 0 ? n.state.doc.resolve(i.pos - s.nodeSize) : i)) : md ? Ho(n, new Ee(n.state.doc.resolve(e < 0 ? l : l + s.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof $e && r.node.isInline)
      return Ho(n, new Ee(e > 0 ? r.$to : r.$from));
    {
      let i = Ky(n.state, e);
      return i ? Ho(n, i) : !1;
    }
  }
}
function ym(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function Gh(n, e) {
  let t = n.pmViewDesc;
  return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
}
function Ja(n, e) {
  return e < 0 ? iK(n) : sK(n);
}
function iK(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i, s, o = !1;
  for (pi && t.nodeType == 1 && r < ym(t) && Gh(t.childNodes[r], -1) && (o = !0); ; )
    if (r > 0) {
      if (t.nodeType != 1)
        break;
      {
        let l = t.childNodes[r - 1];
        if (Gh(l, -1))
          i = t, s = --r;
        else if (l.nodeType == 3)
          t = l, r = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (IA(t))
        break;
      {
        let l = t.previousSibling;
        for (; l && Gh(l, -1); )
          i = t.parentNode, s = _n(l), l = l.previousSibling;
        if (l)
          t = l, r = ym(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = 0;
        }
      }
    }
  o ? Gy(n, t, r) : i && Gy(n, i, s);
}
function sK(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i = ym(t), s, o;
  for (; ; )
    if (r < i) {
      if (t.nodeType != 1)
        break;
      let l = t.childNodes[r];
      if (Gh(l, 1))
        s = t, o = ++r;
      else
        break;
    } else {
      if (IA(t))
        break;
      {
        let l = t.nextSibling;
        for (; l && Gh(l, 1); )
          s = l.parentNode, o = _n(l) + 1, l = l.nextSibling;
        if (l)
          t = l, r = 0, i = ym(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = i = 0;
        }
      }
    }
  s && Gy(n, s, o);
}
function IA(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function oK(n, e) {
  for (; n && e == n.childNodes.length && !pd(n); )
    e = _n(n) + 1, n = n.parentNode;
  for (; n && e < n.childNodes.length; ) {
    let t = n.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = 0;
  }
}
function lK(n, e) {
  for (; n && !e && !pd(n); )
    e = _n(n), n = n.parentNode;
  for (; n && e; ) {
    let t = n.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = n.childNodes.length;
  }
}
function Gy(n, e, t) {
  if (e.nodeType != 3) {
    let s, o;
    (o = oK(e, t)) ? (e = o, t = 0) : (s = lK(e, t)) && (e = s, t = s.nodeValue.length);
  }
  let r = n.domSelection();
  if (!r)
    return;
  if (C1(r)) {
    let s = document.createRange();
    s.setEnd(e, t), s.setStart(e, t), r.removeAllRanges(), r.addRange(s);
  } else r.extend && r.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: i } = n;
  setTimeout(() => {
    n.state == i && io(n);
  }, 50);
}
function Kx(n, e) {
  let t = n.state.doc.resolve(e);
  if (!(Kn || EU) && t.parent.inlineContent) {
    let i = n.coordsAtPos(e);
    if (e > t.start()) {
      let s = n.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left < i.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let s = n.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
}
function Gx(n, e, t) {
  let r = n.state.selection;
  if (r instanceof Ee && !r.empty || t.indexOf("s") > -1 || ii && t.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = r;
  if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Ky(n.state, e);
    if (o && o instanceof $e)
      return Ho(n, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s, l = r instanceof Or ? Ge.near(o, e) : Ge.findFrom(o, e);
    return l ? Ho(n, l) : !1;
  }
  return !1;
}
function Yx(n, e) {
  if (!(n.state.selection instanceof Ee))
    return !0;
  let { $head: t, $anchor: r, empty: i } = n.state.selection;
  if (!t.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (s && !s.isText) {
    let o = n.state.tr;
    return e < 0 ? o.delete(t.pos - s.nodeSize, t.pos) : o.delete(t.pos, t.pos + s.nodeSize), n.dispatch(o), !0;
  }
  return !1;
}
function Jx(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function aK(n) {
  if (!dr || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    Jx(n, r, "true"), setTimeout(() => Jx(n, r, "false"), 20);
  }
  return !1;
}
function cK(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function uK(n, e) {
  let t = e.keyCode, r = cK(e);
  if (t == 8 || ii && t == 72 && r == "c")
    return Yx(n, -1) || Ja(n, -1);
  if (t == 46 && !e.shiftKey || ii && t == 68 && r == "c")
    return Yx(n, 1) || Ja(n, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || ii && t == 66 && r == "c") {
    let i = t == 37 ? Kx(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return Ux(n, i, r) || Ja(n, i);
  } else if (t == 39 || ii && t == 70 && r == "c") {
    let i = t == 39 ? Kx(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return Ux(n, i, r) || Ja(n, i);
  } else {
    if (t == 38 || ii && t == 80 && r == "c")
      return Gx(n, -1, r) || Ja(n, -1);
    if (t == 40 || ii && t == 78 && r == "c")
      return aK(n) || Gx(n, 1, r) || Ja(n, 1);
    if (r == (ii ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function Z3(n, e) {
  n.someProp("transformCopied", (d) => {
    e = d(e, n);
  });
  let t = [], { content: r, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--;
    let d = r.firstChild;
    t.push(d.type.name, d.attrs != d.type.defaultAttrs ? d.attrs : null), r = d.content;
  }
  let o = n.someProp("clipboardSerializer") || Sl.fromSchema(n.state.schema), l = LA(), a = l.createElement("div");
  a.appendChild(o.serializeFragment(r, { document: l }));
  let c = a.firstChild, u, h = 0;
  for (; c && c.nodeType == 1 && (u = _A[c.nodeName.toLowerCase()]); ) {
    for (let d = u.length - 1; d >= 0; d--) {
      let p = l.createElement(u[d]);
      for (; a.firstChild; )
        p.appendChild(a.firstChild);
      a.appendChild(p), h++;
    }
    c = a.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${s}${h ? ` -${h}` : ""} ${JSON.stringify(t)}`);
  let f = n.someProp("clipboardTextSerializer", (d) => d(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: a, text: f, slice: e };
}
function DA(n, e, t, r, i) {
  let s = i.parent.type.spec.code, o, l;
  if (!t && !e)
    return null;
  let a = !!e && (r || s || !t);
  if (a) {
    if (n.someProp("transformPastedText", (f) => {
      e = f(e, s || r, n);
    }), s)
      return l = new be(ce.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0), n.someProp("transformPasted", (f) => {
        l = f(l, n, !0);
      }), l;
    let h = n.someProp("clipboardTextParser", (f) => f(e, i, r, n));
    if (h)
      l = h;
    else {
      let f = i.marks(), { schema: d } = n.state, p = Sl.fromSchema(d);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
        let g = o.appendChild(document.createElement("p"));
        m && g.appendChild(p.serializeNode(d.text(m, f)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (h) => {
      t = h(t, n);
    }), o = pK(t), md && mK(o);
  let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let h = +u[3]; h > 0; h--) {
      let f = o.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      o = f;
    }
  if (l || (l = (n.someProp("clipboardParser") || n.someProp("domParser") || dl.fromSchema(n.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(a || u),
    context: i,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !hK.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    l = gK(Xx(l, +u[1], +u[2]), u[4]);
  else if (l = be.maxOpen(fK(l.content, i), !0), l.openStart || l.openEnd) {
    let h = 0, f = 0;
    for (let d = l.content.firstChild; h < l.openStart && !d.type.spec.isolating; h++, d = d.firstChild)
      ;
    for (let d = l.content.lastChild; f < l.openEnd && !d.type.spec.isolating; f++, d = d.lastChild)
      ;
    l = Xx(l, h, f);
  }
  return n.someProp("transformPasted", (h) => {
    l = h(l, n, a);
  }), l;
}
const hK = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function fK(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let i = e.node(t).contentMatchAt(e.index(t)), s, o = [];
    if (n.forEach((l) => {
      if (!o)
        return;
      let a = i.findWrapping(l.type), c;
      if (!a)
        return o = null;
      if (c = o.length && s.length && RA(a, s, l, o[o.length - 1], 0))
        o[o.length - 1] = c;
      else {
        o.length && (o[o.length - 1] = PA(o[o.length - 1], s.length));
        let u = NA(l, a);
        o.push(u), i = i.matchType(u.type), s = a;
      }
    }), o)
      return ce.from(o);
  }
  return n;
}
function NA(n, e, t = 0) {
  for (let r = e.length - 1; r >= t; r--)
    n = e[r].create(null, ce.from(n));
  return n;
}
function RA(n, e, t, r, i) {
  if (i < n.length && i < e.length && n[i] == e[i]) {
    let s = RA(n, e, t, r.lastChild, i + 1);
    if (s)
      return r.copy(r.content.replaceChild(r.childCount - 1, s));
    if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1]))
      return r.copy(r.content.append(ce.from(NA(t, n, i + 1))));
  }
}
function PA(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, PA(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(ce.empty, !0);
  return n.copy(t.append(r));
}
function Yy(n, e, t, r, i, s) {
  let o = e < 0 ? n.firstChild : n.lastChild, l = o.content;
  return n.childCount > 1 && (s = 0), i < r - 1 && (l = Yy(l, e, t, r, i + 1, s)), i >= t && (l = e < 0 ? o.contentMatchAt(0).fillBefore(l, s <= i).append(l) : l.append(o.contentMatchAt(o.childCount).fillBefore(ce.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(l));
}
function Xx(n, e, t) {
  return e < n.openStart && (n = new be(Yy(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new be(Yy(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const _A = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Zx = null;
function LA() {
  return Zx || (Zx = document.implementation.createHTMLDocument("title"));
}
let y2 = null;
function dK(n) {
  let e = window.trustedTypes;
  return e ? (y2 || (y2 = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), y2.createHTML(n)) : n;
}
function pK(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = LA().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i;
  if ((i = r && _A[r[1].toLowerCase()]) && (n = i.map((s) => "<" + s + ">").join("") + n + i.map((s) => "</" + s + ">").reverse().join("")), t.innerHTML = dK(n), i)
    for (let s = 0; s < i.length; s++)
      t = t.querySelector(i[s]) || t;
  return t;
}
function mK(n) {
  let e = n.querySelectorAll(Kn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r);
  }
}
function gK(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: i, openStart: s, openEnd: o } = n;
  for (let l = r.length - 2; l >= 0; l -= 2) {
    let a = t.nodes[r[l]];
    if (!a || a.hasRequiredAttrs())
      break;
    i = ce.from(a.create(r[l + 1], i)), s++, o++;
  }
  return new be(i, s, o);
}
const pr = {}, mr = {}, yK = { touchstart: !0, touchmove: !0 };
class bK {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function vK(n) {
  for (let e in pr) {
    let t = pr[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (r) => {
      xK(n, r) && !Q3(n, r) && (n.editable || !(r.type in mr)) && t(n, r);
    }, yK[e] ? { passive: !0 } : void 0);
  }
  dr && n.dom.addEventListener("input", () => null), Jy(n);
}
function el(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function wK(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function Jy(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (r) => Q3(n, r));
  });
}
function Q3(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let r = t[e.type];
    return r ? r(n, e) || e.defaultPrevented : !1;
  });
}
function xK(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function kK(n, e) {
  !Q3(n, e) && pr[e.type] && (n.editable || !(e.type in mr)) && pr[e.type](n, e);
}
mr.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !zA(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(Qs && Kn && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), Vc && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let r = Date.now();
      n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", (i) => i(n, Zl(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else n.someProp("handleKeyDown", (r) => r(n, t)) || uK(n, t) ? t.preventDefault() : el(n, "key");
};
mr.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
mr.keypress = (n, e) => {
  let t = e;
  if (zA(n, t) || !t.charCode || t.ctrlKey && !t.altKey || ii && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (i) => i(n, t))) {
    t.preventDefault();
    return;
  }
  let r = n.state.selection;
  if (!(r instanceof Ee) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(t.charCode), s = () => n.state.tr.insertText(i).scrollIntoView();
    !/[\r\n]/.test(i) && !n.someProp("handleTextInput", (o) => o(n, r.$from.pos, r.$to.pos, i, s)) && n.dispatch(s()), t.preventDefault();
  }
};
function T1(n) {
  return { left: n.clientX, top: n.clientY };
}
function SK(n, e) {
  let t = e.x - n.clientX, r = e.y - n.clientY;
  return t * t + r * r < 100;
}
function eb(n, e, t, r, i) {
  if (r == -1)
    return !1;
  let s = n.state.doc.resolve(r);
  for (let o = s.depth + 1; o > 0; o--)
    if (n.someProp(e, (l) => o > s.depth ? l(n, t, s.nodeAfter, s.before(o), i, !0) : l(n, t, s.node(o), s.before(o), i, !1)))
      return !0;
  return !1;
}
function xc(n, e, t) {
  if (n.focused || n.focus(), n.state.selection.eq(e))
    return;
  let r = n.state.tr.setSelection(e);
  r.setMeta("pointer", !0), n.dispatch(r);
}
function CK(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), r = t.nodeAfter;
  return r && r.isAtom && $e.isSelectable(r) ? (xc(n, new $e(t)), !0) : !1;
}
function MK(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, r, i;
  t instanceof $e && (r = t.node);
  let s = n.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let l = o > s.depth ? s.nodeAfter : s.node(o);
    if ($e.isSelectable(l)) {
      r && t.$from.depth > 0 && o >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i = s.before(t.$from.depth) : i = s.before(o);
      break;
    }
  }
  return i != null ? (xc(n, $e.create(n.state.doc, i)), !0) : !1;
}
function TK(n, e, t, r, i) {
  return eb(n, "handleClickOn", e, t, r) || n.someProp("handleClick", (s) => s(n, e, r)) || (i ? MK(n, t) : CK(n, t));
}
function AK(n, e, t, r) {
  return eb(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", (i) => i(n, e, r));
}
function OK(n, e, t, r) {
  return eb(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", (i) => i(n, e, r)) || EK(n, t, r);
}
function EK(n, e, t) {
  if (t.button != 0)
    return !1;
  let r = n.state.doc;
  if (e == -1)
    return r.inlineContent ? (xc(n, Ee.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s), l = i.before(s);
    if (o.inlineContent)
      xc(n, Ee.create(r, l + 1, l + 1 + o.content.size));
    else if ($e.isSelectable(o))
      xc(n, $e.create(r, l));
    else
      continue;
    return !0;
  }
}
function tb(n) {
  return bm(n);
}
const BA = ii ? "metaKey" : "ctrlKey";
pr.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let r = tb(n), i = Date.now(), s = "singleClick";
  i - n.input.lastClick.time < 500 && SK(t, n.input.lastClick) && !t[BA] && n.input.lastClick.button == t.button && (n.input.lastClick.type == "singleClick" ? s = "doubleClick" : n.input.lastClick.type == "doubleClick" && (s = "tripleClick")), n.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: s, button: t.button };
  let o = n.posAtCoords(T1(t));
  o && (s == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new IK(n, o, t, !!r)) : (s == "doubleClick" ? AK : OK)(n, o.pos, o.inside, t) ? t.preventDefault() : el(n, "pointer"));
};
class IK {
  constructor(e, t, r, i) {
    this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[BA], this.allowDefault = r.shiftKey;
    let s, o;
    if (t.inside > -1)
      s = e.state.doc.nodeAt(t.inside), o = t.inside;
    else {
      let u = e.state.doc.resolve(t.pos);
      s = u.parent, o = u.depth ? u.before() : 0;
    }
    const l = i ? null : r.target, a = l ? e.docView.nearestDesc(l, !0) : null;
    this.target = a && a.dom.nodeType == 1 ? a.dom : null;
    let { selection: c } = e.state;
    (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof $e && c.from <= o && c.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && pi && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), el(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => io(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(T1(e))), this.updateAllowDefault(e), this.allowDefault || !t ? el(this.view, "pointer") : TK(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    dr && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Kn && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (xc(this.view, Ge.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : el(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), el(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
pr.touchstart = (n) => {
  n.input.lastTouch = Date.now(), tb(n), el(n, "pointer");
};
pr.touchmove = (n) => {
  n.input.lastTouch = Date.now(), el(n, "pointer");
};
pr.contextmenu = (n) => tb(n);
function zA(n, e) {
  return n.composing ? !0 : dr && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const DK = Qs ? 5e3 : -1;
mr.compositionstart = mr.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$to;
    if (e.selection instanceof Ee && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), bm(n, !0), n.markCursor = null;
    else if (bm(n, !e.selection.empty), pi && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let r = n.domSelectionRange();
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          let l = n.domSelection();
          l && l.collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, s = -1;
      }
    }
    n.input.composing = !0;
  }
  FA(n, DK);
};
mr.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, FA(n, 20));
};
function FA(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => bm(n), e));
}
function HA(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = RK()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function NK(n) {
  let e = n.domSelectionRange();
  if (!e.focusNode)
    return null;
  let t = CU(e.focusNode, e.focusOffset), r = MU(e.focusNode, e.focusOffset);
  if (t && r && t != r) {
    let i = r.pmViewDesc, s = n.domObserver.lastChangedTextNode;
    if (t == s || r == s)
      return s;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (n.input.compositionNode == r) {
      let o = t.pmViewDesc;
      if (!(!o || !o.isText(t.nodeValue)))
        return r;
    }
  }
  return t || r;
}
function RK() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function bm(n, e = !1) {
  if (!(Qs && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), HA(n), e || n.docView && n.docView.dirty) {
      let t = J3(n), r = n.state.selection;
      return t && !t.eq(r) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function PK(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const Bf = Er && il < 15 || Vc && IU < 604;
pr.copy = mr.cut = (n, e) => {
  let t = e, r = n.state.selection, i = t.type == "cut";
  if (r.empty)
    return;
  let s = Bf ? null : t.clipboardData, o = r.content(), { dom: l, text: a } = Z3(n, o);
  s ? (t.preventDefault(), s.clearData(), s.setData("text/html", l.innerHTML), s.setData("text/plain", a)) : PK(n, l), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function _K(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function LK(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = n.input.shiftKey && n.input.lastKeyCode != 45;
  setTimeout(() => {
    n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? zf(n, r.value, null, i, e) : zf(n, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function zf(n, e, t, r, i) {
  let s = DA(n, e, t, r, n.state.selection.$from);
  if (n.someProp("handlePaste", (a) => a(n, i, s || be.empty)))
    return !0;
  if (!s)
    return !1;
  let o = _K(s), l = o ? n.state.tr.replaceSelectionWith(o, r) : n.state.tr.replaceSelection(s);
  return n.dispatch(l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function $A(n) {
  let e = n.getData("text/plain") || n.getData("Text");
  if (e)
    return e;
  let t = n.getData("text/uri-list");
  return t ? t.replace(/\r?\n/g, " ") : "";
}
mr.paste = (n, e) => {
  let t = e;
  if (n.composing && !Qs)
    return;
  let r = Bf ? null : t.clipboardData, i = n.input.shiftKey && n.input.lastKeyCode != 45;
  r && zf(n, $A(r), r.getData("text/html"), i, t) ? t.preventDefault() : LK(n, t);
};
class VA {
  constructor(e, t, r) {
    this.slice = e, this.move = t, this.node = r;
  }
}
const BK = ii ? "altKey" : "ctrlKey";
function qA(n, e) {
  let t = n.someProp("dragCopies", (r) => !r(e));
  return t ?? !e[BK];
}
pr.dragstart = (n, e) => {
  let t = e, r = n.input.mouseDown;
  if (r && r.done(), !t.dataTransfer)
    return;
  let i = n.state.selection, s = i.empty ? null : n.posAtCoords(T1(t)), o;
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof $e ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      o = $e.create(n.state.doc, r.mightDrag.pos);
    else if (t.target && t.target.nodeType == 1) {
      let h = n.docView.nearestDesc(t.target, !0);
      h && h.node.type.spec.draggable && h != n.docView && (o = $e.create(n.state.doc, h.posBefore));
    }
  }
  let l = (o || n.state.selection).content(), { dom: a, text: c, slice: u } = Z3(n, l);
  (!t.dataTransfer.files.length || !Kn || mA > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Bf ? "Text" : "text/html", a.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Bf || t.dataTransfer.setData("text/plain", c), n.dragging = new VA(u, qA(n, t), o);
};
pr.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
mr.dragover = mr.dragenter = (n, e) => e.preventDefault();
mr.drop = (n, e) => {
  let t = e, r = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let i = n.posAtCoords(T1(t));
  if (!i)
    return;
  let s = n.state.doc.resolve(i.pos), o = r && r.slice;
  o ? n.someProp("transformPasted", (p) => {
    o = p(o, n, !1);
  }) : o = DA(n, $A(t.dataTransfer), Bf ? null : t.dataTransfer.getData("text/html"), !1, s);
  let l = !!(r && qA(n, t));
  if (n.someProp("handleDrop", (p) => p(n, t, o || be.empty, l))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let a = o ? oT(n.state.doc, s.pos, o) : s.pos;
  a == null && (a = s.pos);
  let c = n.state.tr;
  if (l) {
    let { node: p } = r;
    p ? p.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(a), h = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = c.doc;
  if (h ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(f))
    return;
  let d = c.doc.resolve(u);
  if (h && $e.isSelectable(o.content.firstChild) && d.nodeAfter && d.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new $e(d));
  else {
    let p = c.mapping.map(a);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((m, g, b, w) => p = w), c.setSelection(X3(n, d, c.doc.resolve(p)));
  }
  n.focus(), n.dispatch(c.setMeta("uiEvent", "drop"));
};
pr.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && io(n);
  }, 20));
};
pr.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
pr.beforeinput = (n, e) => {
  if (Kn && Qs && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: r } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (s) => s(n, Zl(8, "Backspace")))))
        return;
      let { $cursor: i } = n.state.selection;
      i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in mr)
  pr[n] = mr[n];
function Ff(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
class vm {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || aa, this.side = this.spec.side || 0;
  }
  map(e, t, r, i) {
    let { pos: s, deleted: o } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new mn(s - r, s - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof vm && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Ff(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class ol {
  constructor(e, t) {
    this.attrs = e, this.spec = t || aa;
  }
  map(e, t, r, i) {
    let s = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return s >= o ? null : new mn(s, o, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof ol && Ff(this.attrs, e.attrs) && Ff(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof ol;
  }
  destroy() {
  }
}
class nb {
  constructor(e, t) {
    this.attrs = e, this.spec = t || aa;
  }
  map(e, t, r, i) {
    let s = e.mapResult(t.from + i, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(t.to + i, -1);
    return o.deleted || o.pos <= s.pos ? null : new mn(s.pos - r, o.pos - r, this);
  }
  valid(e, t) {
    let { index: r, offset: i } = e.content.findIndex(t.from), s;
    return i == t.from && !(s = e.child(r)).isText && i + s.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof nb && Ff(this.attrs, e.attrs) && Ff(this.spec, e.spec);
  }
  destroy() {
  }
}
class mn {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.type = r;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new mn(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, r) {
    return this.type.map(e, this, t, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, r) {
    return new mn(e, e, new vm(t, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, r, i) {
    return new mn(e, t, new ol(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, r, i) {
    return new mn(e, t, new nb(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof ol;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof vm;
  }
}
const rc = [], aa = {};
class Et {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : rc, this.children = t.length ? t : rc;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? wm(t, e, 0, aa) : qn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, r) {
    let i = [];
    return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i;
  }
  findInner(e, t, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let l = this.local[o];
      l.from <= t && l.to >= e && (!s || s(l.spec)) && r.push(l.copy(l.from + i, l.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < t && this.children[o + 1] > e) {
        let l = this.children[o] + 1;
        this.children[o + 2].findInner(e - l, t - l, r, i + l, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, r) {
    return this == qn || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || aa);
  }
  /**
  @internal
  */
  mapInner(e, t, r, i, s) {
    let o;
    for (let l = 0; l < this.local.length; l++) {
      let a = this.local[l].map(e, r, i);
      a && a.type.valid(t, a) ? (o || (o = [])).push(a) : s.onRemove && s.onRemove(this.local[l].spec);
    }
    return this.children.length ? zK(this.children, o || [], e, t, r, i, s) : o ? new Et(o.sort(ca), rc) : qn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == qn ? Et.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, r) {
    let i, s = 0;
    e.forEach((l, a) => {
      let c = a + r, u;
      if (u = jA(t, l, c)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < a; )
          s += 3;
        i[s] == a ? i[s + 2] = i[s + 2].addInner(l, u, c + 1) : i.splice(s, 0, a, a + l.nodeSize, wm(u, l, c + 1, aa)), s += 3;
      }
    });
    let o = WA(s ? UA(t) : t, -r);
    for (let l = 0; l < o.length; l++)
      o[l].type.valid(e, o[l]) || o.splice(l--, 1);
    return new Et(o.length ? this.local.concat(o).sort(ca) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == qn ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let r = this.children, i = this.local;
    for (let s = 0; s < r.length; s += 3) {
      let o, l = r[s] + t, a = r[s + 1] + t;
      for (let u = 0, h; u < e.length; u++)
        (h = e[u]) && h.from > l && h.to < a && (e[u] = null, (o || (o = [])).push(h));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[s + 2].removeInner(o, l + 1);
      c != qn ? r[s + 2] = c : (r.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let l = 0; l < i.length; l++)
            i[l].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(l--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new Et(i, r) : qn;
  }
  forChild(e, t) {
    if (this == qn)
      return this;
    if (t.isLeaf)
      return Et.empty;
    let r, i;
    for (let l = 0; l < this.children.length; l += 3)
      if (this.children[l] >= e) {
        this.children[l] == e && (r = this.children[l + 2]);
        break;
      }
    let s = e + 1, o = s + t.content.size;
    for (let l = 0; l < this.local.length; l++) {
      let a = this.local[l];
      if (a.from < o && a.to > s && a.type instanceof ol) {
        let c = Math.max(s, a.from) - s, u = Math.min(o, a.to) - s;
        c < u && (i || (i = [])).push(a.copy(c, u));
      }
    }
    if (i) {
      let l = new Et(i.sort(ca), rc);
      return r ? new Uo([l, r]) : l;
    }
    return r || qn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Et) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return rb(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == qn)
      return rc;
    if (e.inlineContent || !this.local.some(ol.is))
      return this.local;
    let t = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof ol || t.push(this.local[r]);
    return t;
  }
  forEachSet(e) {
    e(this);
  }
}
Et.empty = new Et([], []);
Et.removeOverlap = rb;
const qn = Et.empty;
class Uo {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const r = this.members.map((i) => i.map(e, t, aa));
    return Uo.from(r);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return Et.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, t);
      s != qn && (s instanceof Uo ? r = r.concat(s.members) : r.push(s));
    }
    return Uo.from(r);
  }
  eq(e) {
    if (!(e instanceof Uo) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!t)
          t = s;
        else {
          r && (t = t.slice(), r = !1);
          for (let o = 0; o < s.length; o++)
            t.push(s[o]);
        }
    }
    return t ? rb(r ? t : t.sort(ca)) : rc;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return qn;
      case 1:
        return e[0];
      default:
        return new Uo(e.every((t) => t instanceof Et) ? e : e.reduce((t, r) => t.concat(r instanceof Et ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let t = 0; t < this.members.length; t++)
      this.members[t].forEachSet(e);
  }
}
function zK(n, e, t, r, i, s, o) {
  let l = n.slice();
  for (let c = 0, u = s; c < t.maps.length; c++) {
    let h = 0;
    t.maps[c].forEach((f, d, p, m) => {
      let g = m - p - (d - f);
      for (let b = 0; b < l.length; b += 3) {
        let w = l[b + 1];
        if (w < 0 || f > w + u - h)
          continue;
        let k = l[b] + u - h;
        d >= k ? l[b + 1] = f <= k ? -2 : -1 : f >= u && g && (l[b] += g, l[b + 1] += g);
      }
      h += g;
    }), u = t.maps[c].map(u, -1);
  }
  let a = !1;
  for (let c = 0; c < l.length; c += 3)
    if (l[c + 1] < 0) {
      if (l[c + 1] == -2) {
        a = !0, l[c + 1] = -1;
        continue;
      }
      let u = t.map(n[c] + s), h = u - i;
      if (h < 0 || h >= r.content.size) {
        a = !0;
        continue;
      }
      let f = t.map(n[c + 1] + s, -1), d = f - i, { index: p, offset: m } = r.content.findIndex(h), g = r.maybeChild(p);
      if (g && m == h && m + g.nodeSize == d) {
        let b = l[c + 2].mapInner(t, g, u + 1, n[c] + s + 1, o);
        b != qn ? (l[c] = h, l[c + 1] = d, l[c + 2] = b) : (l[c + 1] = -2, a = !0);
      } else
        a = !0;
    }
  if (a) {
    let c = FK(l, n, e, t, i, s, o), u = wm(c, r, 0, o);
    e = u.local;
    for (let h = 0; h < l.length; h += 3)
      l[h + 1] < 0 && (l.splice(h, 3), h -= 3);
    for (let h = 0, f = 0; h < u.children.length; h += 3) {
      let d = u.children[h];
      for (; f < l.length && l[f] < d; )
        f += 3;
      l.splice(f, 0, u.children[h], u.children[h + 1], u.children[h + 2]);
    }
  }
  return new Et(e.sort(ca), l);
}
function WA(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let r = 0; r < n.length; r++) {
    let i = n[r];
    t.push(new mn(i.from + e, i.to + e, i.type));
  }
  return t;
}
function FK(n, e, t, r, i, s, o) {
  function l(a, c) {
    for (let u = 0; u < a.local.length; u++) {
      let h = a.local[u].map(r, i, c);
      h ? t.push(h) : o.onRemove && o.onRemove(a.local[u].spec);
    }
    for (let u = 0; u < a.children.length; u += 3)
      l(a.children[u + 2], a.children[u] + c + 1);
  }
  for (let a = 0; a < n.length; a += 3)
    n[a + 1] == -1 && l(n[a + 2], e[a] + s + 1);
  return t;
}
function jA(n, e, t) {
  if (e.isLeaf)
    return null;
  let r = t + e.nodeSize, i = null;
  for (let s = 0, o; s < n.length; s++)
    (o = n[s]) && o.from > t && o.to < r && ((i || (i = [])).push(o), n[s] = null);
  return i;
}
function UA(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function wm(n, e, t, r) {
  let i = [], s = !1;
  e.forEach((l, a) => {
    let c = jA(n, l, a + t);
    if (c) {
      s = !0;
      let u = wm(c, l, t + a + 1, r);
      u != qn && i.push(a, a + l.nodeSize, u);
    }
  });
  let o = WA(s ? UA(n) : n, -t).sort(ca);
  for (let l = 0; l < o.length; l++)
    o[l].type.valid(e, o[l]) || (r.onRemove && r.onRemove(o[l].spec), o.splice(l--, 1));
  return o.length || i.length ? new Et(o, i) : qn;
}
function ca(n, e) {
  return n.from - e.from || n.to - e.to;
}
function rb(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let r = e[t];
    if (r.from != r.to)
      for (let i = t + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == n && (e = n.slice()), e[i] = s.copy(s.from, r.to), Qx(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, s.from), Qx(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function Qx(n, e, t) {
  for (; e < n.length && ca(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function b2(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let r = t(n.state);
    r && r != qn && e.push(r);
  }), n.cursorWrapper && e.push(Et.create(n.state.doc, [n.cursorWrapper.deco])), Uo.from(e);
}
const HK = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, $K = Er && il <= 11;
class VK {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class qK {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new VK(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      Er && il <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), $K && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, HK)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (jx(this.view)) {
      if (this.suppressingSelectionUpdates)
        return io(this.view);
      if (Er && il <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Oa(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), r;
    for (let s = e.focusNode; s; s = $c(s))
      t.add(s);
    for (let s = e.anchorNode; s; s = $c(s))
      if (t.has(s)) {
        r = s;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && jx(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, l = !1, a = [];
    if (e.editable)
      for (let u = 0; u < t.length; u++) {
        let h = this.registerMutation(t[u], a);
        h && (s = s < 0 ? h.from : Math.min(h.from, s), o = o < 0 ? h.to : Math.max(h.to, o), h.typeOver && (l = !0));
      }
    if (pi && a.length) {
      let u = a.filter((h) => h.nodeName == "BR");
      if (u.length == 2) {
        let [h, f] = u;
        h.parentNode && h.parentNode.parentNode == f.parentNode ? f.remove() : h.remove();
      } else {
        let { focusNode: h } = this.currentSelection;
        for (let f of u) {
          let d = f.parentNode;
          d && d.nodeName == "LI" && (!h || UK(e, h) != d) && f.remove();
        }
      }
    }
    let c = null;
    s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && C1(r) && (c = J3(e)) && c.eq(Ge.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, io(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), WK(e)), this.handleDOMChange(s, o, l, a), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || io(e), this.currentSelection.set(r));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let h = e.addedNodes[u];
        t.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, s = e.nextSibling;
      if (Er && il <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: h, nextSibling: f } = e.addedNodes[u];
          (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (s = f);
        }
      let o = i && i.parentNode == e.target ? _n(i) + 1 : 0, l = r.localPosFromDOM(e.target, o, -1), a = s && s.parentNode == e.target ? _n(s) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, a, 1);
      return { from: l, to: c };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let e8 = /* @__PURE__ */ new WeakMap(), t8 = !1;
function WK(n) {
  if (!e8.has(n) && (e8.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = pi, t8)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), t8 = !0;
  }
}
function n8(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.domAtPos(n.state.selection.anchor);
  return Oa(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s };
}
function jK(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return n8(n, i);
  }
  let t;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", r, !0), t ? n8(n, t) : null;
}
function UK(n, e) {
  for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) {
    let r = n.docView.nearestDesc(t, !0);
    if (r && r.node.isBlock)
      return t;
  }
  return null;
}
function KK(n, e, t) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: l } = n.docView.parseRange(e, t), a = n.domSelectionRange(), c, u = a.anchorNode;
  if (u && n.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: a.anchorOffset }], C1(a) || c.push({ node: a.focusNode, offset: a.focusOffset })), Kn && n.input.lastKeyCode === 8)
    for (let g = s; g > i; g--) {
      let b = r.childNodes[g - 1], w = b.pmViewDesc;
      if (b.nodeName == "BR" && !w) {
        s = g;
        break;
      }
      if (!w || w.size)
        break;
    }
  let h = n.state.doc, f = n.someProp("domParser") || dl.fromSchema(n.state.schema), d = h.resolve(o), p = null, m = f.parse(r, {
    topNode: d.parent,
    topMatch: d.parent.contentMatchAt(d.index()),
    topOpen: !0,
    from: i,
    to: s,
    preserveWhitespace: d.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: GK,
    context: d
  });
  if (c && c[0].pos != null) {
    let g = c[0].pos, b = c[1] && c[1].pos;
    b == null && (b = g), p = { anchor: g + o, head: b + o };
  }
  return { doc: m, sel: p, from: o, to: l };
}
function GK(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (dr && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || dr && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const YK = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function JK(n, e, t, r, i) {
  let s = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
  if (n.input.compositionPendingChanges = 0, e < 0) {
    let B = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, $ = J3(n, B);
    if ($ && !n.state.selection.eq($)) {
      if (Kn && Qs && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (V) => V(n, Zl(13, "Enter"))))
        return;
      let R = n.state.tr.setSelection($);
      B == "pointer" ? R.setMeta("pointer", !0) : B == "key" && R.scrollIntoView(), s && R.setMeta("composition", s), n.dispatch(R);
    }
    return;
  }
  let o = n.state.doc.resolve(e), l = o.sharedDepth(t);
  e = o.before(l + 1), t = n.state.doc.resolve(t).after(l + 1);
  let a = n.state.selection, c = KK(n, e, t), u = n.state.doc, h = u.slice(c.from, c.to), f, d;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (f = n.state.selection.to, d = "end") : (f = n.state.selection.from, d = "start"), n.input.lastKeyCode = null;
  let p = QK(h.content, c.doc.content, c.from, f, d);
  if (p && n.input.domChangeCount++, (Vc && n.input.lastIOSEnter > Date.now() - 225 || Qs) && i.some((B) => B.nodeType == 1 && !YK.test(B.nodeName)) && (!p || p.endA >= p.endB) && n.someProp("handleKeyDown", (B) => B(n, Zl(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!p)
    if (r && a instanceof Ee && !a.empty && a.$head.sameParent(a.$anchor) && !n.composing && !(c.sel && c.sel.anchor != c.sel.head))
      p = { start: a.from, endA: a.to, endB: a.to };
    else {
      if (c.sel) {
        let B = r8(n, n.state.doc, c.sel);
        if (B && !B.eq(n.state.selection)) {
          let $ = n.state.tr.setSelection(B);
          s && $.setMeta("composition", s), n.dispatch($);
        }
      }
      return;
    }
  n.state.selection.from < n.state.selection.to && p.start == p.endB && n.state.selection instanceof Ee && (p.start > n.state.selection.from && p.start <= n.state.selection.from + 2 && n.state.selection.from >= c.from ? p.start = n.state.selection.from : p.endA < n.state.selection.to && p.endA >= n.state.selection.to - 2 && n.state.selection.to <= c.to && (p.endB += n.state.selection.to - p.endA, p.endA = n.state.selection.to)), Er && il <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > c.from && c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == "  " && (p.start--, p.endA--, p.endB--);
  let m = c.doc.resolveNoCache(p.start - c.from), g = c.doc.resolveNoCache(p.endB - c.from), b = u.resolve(p.start), w = m.sameParent(g) && m.parent.inlineContent && b.end() >= p.endA, k;
  if ((Vc && n.input.lastIOSEnter > Date.now() - 225 && (!w || i.some((B) => B.nodeName == "DIV" || B.nodeName == "P")) || !w && m.pos < c.doc.content.size && (!m.sameParent(g) || !m.parent.inlineContent) && !/\S/.test(c.doc.textBetween(m.pos, g.pos, "", "")) && (k = Ge.findFrom(c.doc.resolve(m.pos + 1), 1, !0)) && k.head > m.pos) && n.someProp("handleKeyDown", (B) => B(n, Zl(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > p.start && ZK(u, p.start, p.endA, m, g) && n.someProp("handleKeyDown", (B) => B(n, Zl(8, "Backspace")))) {
    Qs && Kn && n.domObserver.suppressSelectionUpdates();
    return;
  }
  Kn && p.endB == p.start && (n.input.lastChromeDelete = Date.now()), Qs && !w && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == p.endA && (p.endB -= 2, g = c.doc.resolveNoCache(p.endB - c.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(B) {
      return B(n, Zl(13, "Enter"));
    });
  }, 20));
  let C = p.start, M = p.endA, T = (B) => {
    let $ = B || n.state.tr.replace(C, M, c.doc.slice(p.start - c.from, p.endB - c.from));
    if (c.sel) {
      let R = r8(n, $.doc, c.sel);
      R && !(Kn && n.composing && R.empty && (p.start != p.endB || n.input.lastChromeDelete < Date.now() - 100) && (R.head == C || R.head == $.mapping.map(M) - 1) || Er && R.empty && R.head == C) && $.setSelection(R);
    }
    return s && $.setMeta("composition", s), $.scrollIntoView();
  }, N;
  if (w) {
    if (m.pos == g.pos) {
      Er && il <= 11 && m.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => io(n), 20));
      let B = T(n.state.tr.delete(C, M)), $ = u.resolve(p.start).marksAcross(u.resolve(p.endA));
      $ && B.ensureMarks($), n.dispatch(B);
    } else if (
      // Adding or removing a mark
      p.endA == p.endB && (N = XK(m.parent.content.cut(m.parentOffset, g.parentOffset), b.parent.content.cut(b.parentOffset, p.endA - b.start())))
    ) {
      let B = T(n.state.tr);
      N.type == "add" ? B.addMark(C, M, N.mark) : B.removeMark(C, M, N.mark), n.dispatch(B);
    } else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let B = m.parent.textBetween(m.parentOffset, g.parentOffset), $ = () => T(n.state.tr.insertText(B, C, M));
      n.someProp("handleTextInput", (R) => R(n, C, M, B, $)) || n.dispatch($());
    }
  } else
    n.dispatch(T());
}
function r8(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : X3(n, e.resolve(t.anchor), e.resolve(t.head));
}
function XK(n, e) {
  let t = n.firstChild.marks, r = e.firstChild.marks, i = t, s = r, o, l, a;
  for (let u = 0; u < r.length; u++)
    i = r[u].removeFromSet(i);
  for (let u = 0; u < t.length; u++)
    s = t[u].removeFromSet(s);
  if (i.length == 1 && s.length == 0)
    l = i[0], o = "add", a = (u) => u.mark(l.addToSet(u.marks));
  else if (i.length == 0 && s.length == 1)
    l = s[0], o = "remove", a = (u) => u.mark(l.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(a(e.child(u)));
  if (ce.from(c).eq(n))
    return { mark: l, type: o };
}
function ZK(n, e, t, r, i) {
  if (
    // The content must have shrunk
    t - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    v2(r, !0, !1) < i.pos
  )
    return !1;
  let s = n.resolve(e);
  if (!r.parent.isTextblock) {
    let l = s.nodeAfter;
    return l != null && t == e + l.nodeSize;
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = n.resolve(v2(s, !0, !0));
  return !o.parent.isTextblock || o.pos > t || v2(o, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
}
function v2(n, e, t) {
  let r = n.depth, i = e ? n.end() : n.pos;
  for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount); )
    r--, i++, e = !1;
  if (t) {
    let s = n.node(r).maybeChild(n.indexAfter(r));
    for (; s && !s.isLeaf; )
      s = s.firstChild, i++;
  }
  return i;
}
function QK(n, e, t, r, i) {
  let s = n.findDiffStart(e, t);
  if (s == null)
    return null;
  let { a: o, b: l } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (i == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    r -= o + a - s;
  }
  if (o < s && n.size < e.size) {
    let a = r <= s && r >= o ? s - r : 0;
    s -= a, s && s < e.size && i8(e.textBetween(s - 1, s + 1)) && (s += a ? 1 : -1), l = s + (l - o), o = s;
  } else if (l < s) {
    let a = r <= s && r >= l ? s - r : 0;
    s -= a, s && s < n.size && i8(n.textBetween(s - 1, s + 1)) && (s += a ? 1 : -1), o = s + (o - l), l = s;
  }
  return { start: s, endA: o, endB: l };
}
function i8(n) {
  if (n.length != 2)
    return !1;
  let e = n.charCodeAt(0), t = n.charCodeAt(1);
  return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
}
class ib {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new bK(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(c8), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = l8(this), o8(this), this.nodeViews = a8(this), this.docView = Fx(this.state.doc, s8(this), b2(this), this.dom, this), this.domObserver = new qK(this, (r, i, s, o) => JK(this, r, i, s, o)), this.domObserver.start(), vK(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Jy(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(c8), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let r in this._props)
      t[r] = this._props[r];
    t.state = this.state;
    for (let r in e)
      t[r] = e[r];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    var r;
    let i = this.state, s = !1, o = !1;
    e.storedMarks && this.composing && (HA(this), o = !0), this.state = e;
    let l = i.plugins != e.plugins || this._props.plugins != t.plugins;
    if (l || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let d = a8(this);
      tG(d, this.nodeViews) && (this.nodeViews = d, s = !0);
    }
    (l || t.handleDOMEvents != this._props.handleDOMEvents) && Jy(this), this.editable = l8(this), o8(this);
    let a = b2(this), c = s8(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", h = s || !this.docView.matchesNode(e.doc, c, a);
    (h || !e.selection.eq(i.selection)) && (o = !0);
    let f = u == "preserve" && o && this.dom.style.overflowAnchor == null && RU(this);
    if (o) {
      this.domObserver.stop();
      let d = h && (Er || Kn) && !this.composing && !i.selection.empty && !e.selection.empty && eG(i.selection, e.selection);
      if (h) {
        let p = Kn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = NK(this)), (s || !this.docView.update(e.doc, c, a, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = Fx(e.doc, c, a, this.dom, this)), p && !this.trackWrites && (d = !0);
      }
      d || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && rK(this)) ? io(this, d) : (OA(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && PU(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof $e) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && Rx(this, t.getBoundingClientRect(), e);
      } else
        Rx(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let r = this.directPlugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let r = this.state.plugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, t) {
    let r = e.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let s = r.from + (this.state.doc.content.size - t.doc.content.size);
      (s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s);
    }
    this.dragging = new VA(e.slice, e.move, i < 0 ? void 0 : $e.create(this.state.doc, i));
  }
  someProp(e, t) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = t ? t(r) : r))
      return i;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let l = this.directPlugins[o].props[e];
      if (l != null && (i = t ? t(l) : l))
        return i;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let l = s[o].props[e];
        if (l != null && (i = t ? t(l) : l))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Er) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && _U(this.dom), io(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return HU(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return wA(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, r = -1) {
    let i = this.docView.posFromDOM(e, t, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return jU(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return zf(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return zf(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return Z3(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (wK(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], b2(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, kU());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return kK(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? dr && this.root.nodeType === 11 && AU(this.dom.ownerDocument) == this.dom && jK(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
ib.prototype.dispatch = function(n) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, n) : this.updateState(this.state.apply(n));
};
function s8(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let r in t)
        r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
  }), e.translate || (e.translate = "no"), [mn.node(0, n.state.doc.content.size, e)];
}
function o8(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: mn.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function l8(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function eG(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function a8(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function tG(n, e) {
  let t = 0, r = 0;
  for (let i in n) {
    if (n[i] != e[i])
      return !0;
    t++;
  }
  for (let i in e)
    r++;
  return t != r;
}
function c8(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
function Ol(n, e) {
  return n.meta = {
    package: "@milkdown/core",
    group: "System",
    ...e
  }, n;
}
const KA = {
  text: (n, e, t, r) => {
    const i = n.value;
    return /^[^*_\\]*\s+$/.test(i) ? i : t.safe(i, { ...r, encode: [] });
  },
  strong: (n, e, t, r) => {
    const i = n.marker || t.options.strong || "*", s = t.enter("strong"), o = t.createTracker(r);
    let l = o.move(i + i);
    return l += o.move(
      t.containerPhrasing(n, {
        before: l,
        after: i,
        ...o.current()
      })
    ), l += o.move(i + i), s(), l;
  },
  emphasis: (n, e, t, r) => {
    const i = n.marker || t.options.emphasis || "*", s = t.enter("emphasis"), o = t.createTracker(r);
    let l = o.move(i);
    return l += o.move(
      t.containerPhrasing(n, {
        before: l,
        after: i,
        ...o.current()
      })
    ), l += o.move(i), s(), l;
  }
}, St = at({}, "editorView"), dh = at({}, "editorState"), w2 = at([], "initTimer"), Xy = at({}, "editor"), Hf = at([], "inputRules"), ho = at([], "prosePlugins"), $f = at(
  [],
  "remarkPlugins"
), Vf = at([], "nodeView"), qf = at([], "markView"), ua = at(
  By().use(Iy).use(Py),
  "remark"
), Yh = at(
  {
    handlers: KA,
    encode: []
  },
  "remarkStringifyOptions"
), pp = ko("ConfigReady");
function nG(n) {
  const e = (t) => (t.record(pp), async () => (await n(t), t.done(pp), () => {
    t.clearTimer(pp);
  }));
  return Ol(e, {
    displayName: "Config"
  }), e;
}
const ha = ko("InitReady");
function rG(n) {
  const e = (t) => (t.inject(Xy, n).inject(ho, []).inject($f, []).inject(Hf, []).inject(Vf, []).inject(qf, []).inject(Yh, {
    handlers: KA,
    encode: []
  }).inject(ua, By().use(Iy).use(Py)).inject(w2, [pp]).record(ha), async () => {
    await t.waitTimers(w2);
    const r = t.get(Yh);
    return t.set(
      ua,
      By().use(Iy).use(Py, r)
    ), t.done(ha), () => {
      t.remove(Xy).remove(ho).remove($f).remove(Hf).remove(Vf).remove(qf).remove(Yh).remove(ua).remove(w2).clearTimer(ha);
    };
  });
  return Ol(e, {
    displayName: "Init"
  }), e;
}
const gi = ko("SchemaReady"), x2 = at([], "schemaTimer"), yi = at({}, "schema"), Jh = at([], "nodes"), Xh = at([], "marks");
function u8(n) {
  return {
    ...n,
    parseDOM: n.parseDOM?.map((e) => ({ priority: n.priority, ...e }))
  };
}
const GA = (n) => (n.inject(yi, {}).inject(Jh, []).inject(Xh, []).inject(x2, [ha]).record(gi), async () => {
  await n.waitTimers(x2);
  const e = n.get(ua), r = n.get($f).reduce(
    (l, a) => l.use(a.plugin, a.options),
    e
  );
  n.set(ua, r);
  const i = Object.fromEntries(
    n.get(Jh).map(([l, a]) => [l, u8(a)])
  ), s = Object.fromEntries(
    n.get(Xh).map(([l, a]) => [l, u8(a)])
  ), o = new JM({ nodes: i, marks: s });
  return n.set(yi, o), n.done(gi), () => {
    n.remove(yi).remove(Jh).remove(Xh).remove(x2).clearTimer(gi);
  };
});
Ol(GA, {
  displayName: "Schema"
});
class YA {
  constructor() {
    this.#t = new CT(), this.#e = null, this.setCtx = (e) => {
      this.#e = e;
    }, this.chain = () => {
      if (this.#e == null) throw t2();
      const e = this.#e, t = [], r = this.get.bind(this), i = {
        run: () => {
          const o = ru(...t), l = e.get(St);
          return o(l.state, l.dispatch, l);
        },
        inline: (o) => (t.push(o), i),
        pipe: s.bind(this)
      };
      function s(o, l) {
        const a = r(o);
        return t.push(a(l)), i;
      }
      return i;
    };
  }
  #t;
  #e;
  get ctx() {
    return this.#e;
  }
  /// Register a command into the manager.
  create(e, t) {
    const r = e.create(this.#t.sliceMap);
    return r.set(t), r;
  }
  get(e) {
    return this.#t.get(e).get();
  }
  remove(e) {
    return this.#t.remove(e);
  }
  call(e, t) {
    if (this.#e == null) throw t2();
    const i = this.get(e)(t), s = this.#e.get(St);
    return i(s.state, s.dispatch, s);
  }
  /// Call an inline command.
  inline(e) {
    if (this.#e == null) throw t2();
    const t = this.#e.get(St);
    return e(t.state, t.dispatch, t);
  }
}
function iG(n = "cmdKey") {
  return at((() => () => !1), n);
}
const Me = at(new YA(), "commands"), k2 = at([gi], "commandsTimer"), Zh = ko("CommandsReady"), JA = (n) => {
  const e = new YA();
  return e.setCtx(n), n.inject(Me, e).inject(k2, [gi]).record(Zh), async () => (await n.waitTimers(k2), n.done(Zh), () => {
    n.remove(Me).remove(k2).clearTimer(Zh);
  });
};
Ol(JA, {
  displayName: "Commands"
});
function sG(n) {
  const e = ru(
    $$,
    W3,
    tU,
    lA
  );
  return n.Backspace = e, n;
}
class XA {
  constructor() {
    this.#t = null, this.#e = [], this.setCtx = (e) => {
      this.#t = e;
    }, this.add = (e) => (this.#e.push(e), () => {
      this.#e = this.#e.filter((t) => t !== e);
    }), this.addObjectKeymap = (e) => {
      const t = [];
      return Object.entries(e).forEach(([r, i]) => {
        if (typeof i == "function") {
          const s = {
            key: r,
            onRun: () => i
          };
          this.#e.push(s), t.push(() => {
            this.#e = this.#e.filter((o) => o !== s);
          });
        } else
          this.#e.push(i), t.push(() => {
            this.#e = this.#e.filter((s) => s !== i);
          });
      }), () => {
        t.forEach((r) => r());
      };
    }, this.addBaseKeymap = () => {
      const e = sG(yU);
      return this.addObjectKeymap(e);
    }, this.build = () => {
      const e = {};
      return this.#e.forEach((r) => {
        e[r.key] = [...e[r.key] || [], r];
      }), Object.fromEntries(
        Object.entries(e).map(([r, i]) => {
          const s = i.sort(
            (l, a) => (a.priority ?? 50) - (l.priority ?? 50)
          );
          return [r, (l, a, c) => {
            const u = this.#t;
            if (u == null) throw g1();
            const h = s.map((d) => d.onRun(u));
            return ru(...h)(l, a, c);
          }];
        })
      );
    };
  }
  #t;
  #e;
  get ctx() {
    return this.#t;
  }
}
const xm = at(new XA(), "keymap"), S2 = at([gi], "keymapTimer"), Qh = ko("KeymapReady"), oG = (n) => {
  const e = new XA();
  return e.setCtx(n), n.inject(xm, e).inject(S2, [gi]).record(Qh), async () => (await n.waitTimers(S2), n.done(Qh), () => {
    n.remove(xm).remove(S2).clearTimer(Qh);
  });
}, mp = ko("ParserReady"), ZA = (() => {
  throw g1();
}), fa = at(ZA, "parser"), C2 = at([], "parserTimer"), QA = (n) => (n.inject(fa, ZA).inject(C2, [gi]).record(mp), async () => {
  await n.waitTimers(C2);
  const e = n.get(ua), t = n.get(yi);
  return n.set(fa, Zj.create(t, e)), n.done(mp), () => {
    n.remove(fa).remove(C2).clearTimer(mp);
  };
});
Ol(QA, {
  displayName: "Parser"
});
const ef = ko("SerializerReady"), M2 = at(
  [],
  "serializerTimer"
), eO = (() => {
  throw g1();
}), kc = at(
  eO,
  "serializer"
), tO = (n) => (n.inject(kc, eO).inject(M2, [gi]).record(ef), async () => {
  await n.waitTimers(M2);
  const e = n.get(ua), t = n.get(yi);
  return n.set(kc, eU.create(t, e)), n.done(ef), () => {
    n.remove(kc).remove(M2).clearTimer(ef);
  };
});
Ol(tO, {
  displayName: "Serializer"
});
const gp = at("", "defaultValue"), yp = at(
  (n) => n,
  "stateOptions"
), T2 = at(
  [],
  "editorStateTimer"
), bp = ko("EditorStateReady");
function lG(n, e, t) {
  if (typeof n == "string") return e(n);
  if (n.type === "html")
    return dl.fromSchema(t).parse(n.dom);
  if (n.type === "json")
    return ro.fromJSON(t, n.value);
  throw q$(n);
}
const aG = new en("MILKDOWN_STATE_TRACKER"), nO = (n) => (n.inject(gp, "").inject(dh, {}).inject(yp, (e) => e).inject(T2, [
  mp,
  ef,
  Zh,
  Qh
]).record(bp), async () => {
  await n.waitTimers(T2);
  const e = n.get(yi), t = n.get(fa), r = n.get(Hf), i = n.get(yp), s = n.get(ho), o = n.get(gp), l = lG(o, t, e), a = n.get(xm), c = a.addBaseKeymap(), u = [
    ...s,
    new Ut({
      key: aG,
      state: {
        init: () => {
        },
        apply: (d, p, m, g) => {
          n.set(dh, g);
        }
      }
    }),
    oV({ rules: r }),
    dA(a.build())
  ];
  n.set(ho, u);
  const h = i({
    schema: e,
    doc: l,
    plugins: u
  }), f = Qo.create(h);
  return n.set(dh, f), n.done(bp), () => {
    c(), n.remove(gp).remove(dh).remove(yp).remove(T2).clearTimer(bp);
  };
});
Ol(nO, {
  displayName: "EditorState"
});
const vp = ko("EditorViewReady"), A2 = at(
  [],
  "editorViewTimer"
), tf = at(
  {},
  "editorViewOptions"
), wp = at(null, "root"), Zy = at(null, "rootDOM"), Qy = at(
  {},
  "rootAttrs"
);
function cG(n, e) {
  const t = document.createElement("div");
  t.className = "milkdown", n.appendChild(t), e.set(Zy, t);
  const r = e.get(Qy);
  return Object.entries(r).forEach(
    ([i, s]) => t.setAttribute(i, s)
  ), t;
}
function uG(n) {
  n.classList.add("editor"), n.setAttribute("role", "textbox");
}
const hG = new en("MILKDOWN_VIEW_CLEAR"), rO = (n) => (n.inject(wp, document.body).inject(St, {}).inject(tf, {}).inject(Zy, null).inject(Qy, {}).inject(A2, [bp]).record(vp), async () => {
  await n.wait(ha);
  const e = n.get(wp) || document.body, t = typeof e == "string" ? document.querySelector(e) : e;
  n.update(ho, (a) => [
    new Ut({
      key: hG,
      view: (c) => {
        const u = t ? cG(t, n) : void 0;
        return (() => {
          if (u && t) {
            const f = c.dom;
            t.replaceChild(u, f), u.appendChild(f);
          }
        })(), {
          destroy: () => {
            u?.parentNode && u?.parentNode.replaceChild(c.dom, u), u?.remove();
          }
        };
      }
    }),
    ...a
  ]), await n.waitTimers(A2);
  const r = n.get(dh), i = n.get(tf), s = Object.fromEntries(n.get(Vf)), o = Object.fromEntries(n.get(qf)), l = new ib(t, {
    state: r,
    nodeViews: s,
    markViews: o,
    ...i
  });
  return uG(l.dom), n.set(St, l), n.done(vp), () => {
    l?.destroy(), n.remove(wp).remove(St).remove(tf).remove(Zy).remove(Qy).remove(A2).clearTimer(vp);
  };
});
Ol(rO, {
  displayName: "EditorView"
});
var km = /* @__PURE__ */ ((n) => (n.Idle = "Idle", n.OnCreate = "OnCreate", n.Created = "Created", n.OnDestroy = "OnDestroy", n.Destroyed = "Destroyed", n))(km || {});
class sb {
  constructor() {
    this.#t = !1, this.#e = "Idle", this.#r = [], this.#n = () => {
    }, this.#a = new CT(), this.#i = new SV(), this.#s = /* @__PURE__ */ new Map(), this.#o = /* @__PURE__ */ new Map(), this.#l = new P3(this.#a, this.#i), this.#c = () => {
      const e = nG(async (r) => {
        await Promise.all(this.#r.map((i) => i(r)));
      }), t = [
        GA,
        QA,
        tO,
        JA,
        oG,
        nO,
        rO,
        rG(this),
        e
      ];
      this.#u(t, this.#o);
    }, this.#u = (e, t) => {
      e.forEach((r) => {
        const i = this.#l.produce(
          this.#t ? r.meta : void 0
        ), s = r(i);
        t.set(r, { ctx: i, handler: s, cleanup: void 0 });
      });
    }, this.#h = (e, t = !1) => Promise.all(
      [e].flat().map((r) => {
        const s = this.#s.get(r)?.cleanup;
        return t ? this.#s.delete(r) : this.#s.set(r, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        }), typeof s == "function" ? s() : s;
      })
    ), this.#d = async () => {
      await Promise.all(
        [...this.#o.entries()].map(([e, { cleanup: t }]) => typeof t == "function" ? t() : t)
      ), this.#o.clear();
    }, this.#f = (e) => {
      this.#e = e, this.#n(e);
    }, this.#p = (e) => [...e.entries()].map(async ([t, r]) => {
      const { ctx: i, handler: s } = r;
      if (!s) return;
      const o = await s();
      e.set(t, { ctx: i, handler: s, cleanup: o });
    }), this.enableInspector = (e = !0) => (this.#t = e, this), this.onStatusChange = (e) => (this.#n = e, this), this.config = (e) => (this.#r.push(e), this), this.removeConfig = (e) => (this.#r = this.#r.filter((t) => t !== e), this), this.use = (e) => {
      const t = [e].flat();
      return t.flat().forEach((r) => {
        this.#s.set(r, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        });
      }), this.#e === "Created" && this.#u(t, this.#s), this;
    }, this.remove = async (e) => this.#e === "OnCreate" ? (console.warn(
      "[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code."
    ), new Promise((t) => {
      setTimeout(() => {
        t(this.remove(e));
      }, 50);
    })) : (await this.#h([e].flat(), !0), this), this.create = async () => this.#e === "OnCreate" ? this : (this.#e === "Created" && await this.destroy(), this.#f(
      "OnCreate"
      /* OnCreate */
    ), this.#c(), this.#u([...this.#s.keys()], this.#s), await Promise.all(
      [
        this.#p(this.#o),
        this.#p(this.#s)
      ].flat()
    ), this.#f(
      "Created"
      /* Created */
    ), this), this.destroy = async (e = !1) => this.#e === "Destroyed" || this.#e === "OnDestroy" ? this : this.#e === "OnCreate" ? new Promise((t) => {
      setTimeout(() => {
        t(this.destroy(e));
      }, 50);
    }) : (e && (this.#r = []), this.#f(
      "OnDestroy"
      /* OnDestroy */
    ), await this.#h([...this.#s.keys()], e), await this.#d(), this.#f(
      "Destroyed"
      /* Destroyed */
    ), this), this.action = (e) => e(this.#l), this.inspect = () => this.#t ? [...this.#o.values(), ...this.#s.values()].map(({ ctx: e }) => e?.inspector?.read()).filter((e) => !!e) : (console.warn(
      "[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first."
    ), []);
  }
  /// Create a new editor instance.
  static make() {
    return new sb();
  }
  #t;
  #e;
  #r;
  #n;
  #a;
  #i;
  #s;
  #o;
  #l;
  #c;
  #u;
  #h;
  #d;
  #f;
  #p;
  /// Get the ctx of the editor.
  get ctx() {
    return this.#l;
  }
  /// Get the status of the editor.
  get status() {
    return this.#e;
  }
}
function Ye(n, e) {
  const t = iG(n), r = (i) => async () => {
    r.key = t, await i.wait(Zh);
    const s = e(i);
    return i.get(Me).create(t, s), r.run = (o) => i.get(Me).call(n, o), () => {
      i.get(Me).remove(t);
    };
  };
  return r;
}
function Qn(n) {
  const e = (t) => async () => {
    await t.wait(gi);
    const r = n(t);
    return t.update(Hf, (i) => [...i, r]), e.inputRule = r, () => {
      t.update(Hf, (i) => i.filter((s) => s !== r));
    };
  };
  return e;
}
function fG(n, e) {
  const t = (r) => async () => {
    const i = e(r);
    return r.update(Xh, (s) => [
      ...s.filter((o) => o[0] !== n),
      [n, i]
    ]), t.id = n, t.schema = i, () => {
      r.update(Xh, (s) => s.filter(([o]) => o !== n));
    };
  };
  return t.type = (r) => {
    const i = r.get(yi).marks[n];
    if (!i) throw X$(n);
    return i;
  }, t;
}
function ob(n, e) {
  const t = (r) => async () => {
    const i = e(r);
    return r.update(Jh, (s) => [
      ...s.filter((o) => o[0] !== n),
      [n, i]
    ]), t.id = n, t.schema = i, () => {
      r.update(Jh, (s) => s.filter(([o]) => o !== n));
    };
  };
  return t.type = (r) => {
    const i = r.get(yi).nodes[n];
    if (!i) throw J$(n);
    return i;
  }, t;
}
function kn(n) {
  let e;
  const t = (r) => async () => (await r.wait(gi), e = n(r), r.update(ho, (i) => [...i, e]), () => {
    r.update(ho, (i) => i.filter((s) => s !== e));
  });
  return t.plugin = () => e, t.key = () => e.spec.key, t;
}
function iO(n) {
  const e = (t) => async () => {
    await t.wait(Qh);
    const r = t.get(xm), i = n(t), s = r.addObjectKeymap(i);
    return e.keymap = i, () => {
      s();
    };
  };
  return e;
}
function yd(n, e) {
  const t = (r) => async () => {
    await r.wait(gi);
    const i = e(r);
    return n.type(r) instanceof dm ? r.update(Vf, (s) => [
      ...s,
      [n.id, i]
    ]) : r.update(qf, (s) => [
      ...s,
      [n.id, i]
    ]), t.view = i, t.type = n, () => {
      n.type(r) instanceof dm ? r.update(Vf, (s) => s.filter((o) => o[0] !== n.id)) : r.update(qf, (s) => s.filter((o) => o[0] !== n.id));
    };
  };
  return t;
}
function Ct(n, e) {
  const t = at(n, e), r = (i) => (i.inject(t), () => () => {
    i.remove(t);
  });
  return r.key = t, r;
}
function hn(n, e) {
  const t = Ct(e, n), r = ob(n, (s) => s.get(t.key)(s)), i = [t, r];
  return i.id = r.id, i.node = r, i.type = (s) => r.type(s), i.ctx = t, i.key = t.key, i.extendSchema = (s) => {
    const o = s(e);
    return hn(n, o);
  }, i;
}
function iu(n, e) {
  const t = Ct(e, n), r = fG(n, (s) => s.get(t.key)(s)), i = [t, r];
  return i.id = r.id, i.mark = r, i.type = (s) => r.type(s), i.ctx = t, i.key = t.key, i.extendSchema = (s) => {
    const o = s(e);
    return iu(n, o);
  }, i;
}
function Rr(n, e) {
  const t = Object.fromEntries(
    Object.entries(e).map(
      ([o, { shortcuts: l, priority: a }]) => [o, { shortcuts: l, priority: a }]
    )
  ), r = Ct(t, `${n}Keymap`), i = iO((o) => {
    const l = o.get(r.key), a = Object.entries(e).flatMap(
      ([c, { command: u }]) => {
        const h = l[c], f = [h.shortcuts].flat(), d = h.priority;
        return f.map(
          (p) => [
            p,
            {
              key: p,
              onRun: u,
              priority: d
            }
          ]
        );
      }
    );
    return Object.fromEntries(a);
  }), s = [r, i];
  return s.ctx = r, s.shortcuts = i, s.key = r.key, s.keymap = i.keymap, s;
}
const Wi = (n, e = () => ({})) => Ct(e, `${n}Attr`), bd = (n, e = () => ({})) => Ct(e, `${n}Attr`);
function As(n, e, t) {
  const r = Ct({}, n), i = (o) => async () => {
    await o.wait(ha);
    const a = {
      plugin: e(o),
      options: o.get(r.key)
    };
    return o.update($f, (c) => [...c, a]), () => {
      o.update($f, (c) => c.filter((u) => u !== a));
    };
  }, s = [r, i];
  return s.id = n, s.plugin = i, s.options = r, s;
}
function dG(n) {
  return (e) => {
    const t = e.get(St);
    return e.get(yi), e.get(kc)(t.state.doc);
  };
}
function pG(n, e = !1) {
  return (t) => {
    const r = t.get(St), s = t.get(fa)(n);
    if (!s) return;
    if (!e) {
      const h = r.state.selection.content();
      return r.dispatch(
        r.state.tr.replaceSelection(
          new be(s.content, h.openStart, h.openEnd)
        ).scrollIntoView()
      );
    }
    const o = t.get(yi), l = Sl.fromSchema(o).serializeFragment(s.content), c = dl.fromSchema(o).parseSlice(l), u = kT(c);
    if (u) {
      r.dispatch(r.state.tr.replaceSelectionWith(u, !0));
      return;
    }
    r.dispatch(r.state.tr.replaceSelection(c));
  };
}
function mG(n, e = !1) {
  return (t) => {
    const r = t.get(St), s = t.get(fa)(n);
    if (!s) return;
    if (!e) {
      const { state: u } = r;
      return r.dispatch(
        u.tr.replace(
          0,
          u.doc.content.size,
          new be(s.content, 0, 0)
        )
      );
    }
    const o = t.get(yi), l = t.get(yp), a = t.get(ho), c = Qo.create({
      schema: o,
      doc: s,
      plugins: a,
      ...l
    });
    r.updateState(c);
  };
}
const e5 = Math.min, Sc = Math.max, Sm = Math.round, vs = (n) => ({
  x: n,
  y: n
}), gG = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, yG = {
  start: "end",
  end: "start"
};
function h8(n, e, t) {
  return Sc(n, e5(e, t));
}
function A1(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function Ia(n) {
  return n.split("-")[0];
}
function O1(n) {
  return n.split("-")[1];
}
function sO(n) {
  return n === "x" ? "y" : "x";
}
function oO(n) {
  return n === "y" ? "height" : "width";
}
const bG = /* @__PURE__ */ new Set(["top", "bottom"]);
function tl(n) {
  return bG.has(Ia(n)) ? "y" : "x";
}
function lO(n) {
  return sO(tl(n));
}
function vG(n, e, t) {
  t === void 0 && (t = !1);
  const r = O1(n), i = lO(n), s = oO(i);
  let o = i === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (o = Cm(o)), [o, Cm(o)];
}
function wG(n) {
  const e = Cm(n);
  return [t5(n), e, t5(e)];
}
function t5(n) {
  return n.replace(/start|end/g, (e) => yG[e]);
}
const f8 = ["left", "right"], d8 = ["right", "left"], xG = ["top", "bottom"], kG = ["bottom", "top"];
function SG(n, e, t) {
  switch (n) {
    case "top":
    case "bottom":
      return t ? e ? d8 : f8 : e ? f8 : d8;
    case "left":
    case "right":
      return e ? xG : kG;
    default:
      return [];
  }
}
function CG(n, e, t, r) {
  const i = O1(n);
  let s = SG(Ia(n), t === "start", r);
  return i && (s = s.map((o) => o + "-" + i), e && (s = s.concat(s.map(t5)))), s;
}
function Cm(n) {
  return n.replace(/left|right|bottom|top/g, (e) => gG[e]);
}
function MG(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function TG(n) {
  return typeof n != "number" ? MG(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function Mm(n) {
  const {
    x: e,
    y: t,
    width: r,
    height: i
  } = n;
  return {
    width: r,
    height: i,
    top: t,
    left: e,
    right: e + r,
    bottom: t + i,
    x: e,
    y: t
  };
}
function p8(n, e, t) {
  let {
    reference: r,
    floating: i
  } = n;
  const s = tl(e), o = lO(e), l = oO(o), a = Ia(e), c = s === "y", u = r.x + r.width / 2 - i.width / 2, h = r.y + r.height / 2 - i.height / 2, f = r[l] / 2 - i[l] / 2;
  let d;
  switch (a) {
    case "top":
      d = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      d = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      d = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      d = {
        x: r.x - i.width,
        y: h
      };
      break;
    default:
      d = {
        x: r.x,
        y: r.y
      };
  }
  switch (O1(e)) {
    case "start":
      d[o] -= f * (t && c ? -1 : 1);
      break;
    case "end":
      d[o] += f * (t && c ? -1 : 1);
      break;
  }
  return d;
}
const AG = async (n, e, t) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: o
  } = t, l = s.filter(Boolean), a = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let c = await o.getElementRects({
    reference: n,
    floating: e,
    strategy: i
  }), {
    x: u,
    y: h
  } = p8(c, r, a), f = r, d = {}, p = 0;
  for (let m = 0; m < l.length; m++) {
    const {
      name: g,
      fn: b
    } = l[m], {
      x: w,
      y: k,
      data: C,
      reset: M
    } = await b({
      x: u,
      y: h,
      initialPlacement: r,
      placement: f,
      strategy: i,
      middlewareData: d,
      rects: c,
      platform: o,
      elements: {
        reference: n,
        floating: e
      }
    });
    u = w ?? u, h = k ?? h, d = {
      ...d,
      [g]: {
        ...d[g],
        ...C
      }
    }, M && p <= 50 && (p++, typeof M == "object" && (M.placement && (f = M.placement), M.rects && (c = M.rects === !0 ? await o.getElementRects({
      reference: n,
      floating: e,
      strategy: i
    }) : M.rects), {
      x: u,
      y: h
    } = p8(c, f, a)), m = -1);
  }
  return {
    x: u,
    y: h,
    placement: f,
    strategy: i,
    middlewareData: d
  };
};
async function aO(n, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: o,
    elements: l,
    strategy: a
  } = n, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: h = "floating",
    altBoundary: f = !1,
    padding: d = 0
  } = A1(e, n), p = TG(d), g = l[f ? h === "floating" ? "reference" : "floating" : h], b = Mm(await s.getClippingRect({
    element: (t = await (s.isElement == null ? void 0 : s.isElement(g))) == null || t ? g : g.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(l.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: a
  })), w = h === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l.floating)), C = await (s.isElement == null ? void 0 : s.isElement(k)) ? await (s.getScale == null ? void 0 : s.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, M = Mm(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: w,
    offsetParent: k,
    strategy: a
  }) : w);
  return {
    top: (b.top - M.top + p.top) / C.y,
    bottom: (M.bottom - b.bottom + p.bottom) / C.y,
    left: (b.left - M.left + p.left) / C.x,
    right: (M.right - b.right + p.right) / C.x
  };
}
const OG = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: i,
        middlewareData: s,
        rects: o,
        initialPlacement: l,
        platform: a,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: h = !0,
        fallbackPlacements: f,
        fallbackStrategy: d = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: m = !0,
        ...g
      } = A1(n, e);
      if ((t = s.arrow) != null && t.alignmentOffset)
        return {};
      const b = Ia(i), w = tl(l), k = Ia(l) === l, C = await (a.isRTL == null ? void 0 : a.isRTL(c.floating)), M = f || (k || !m ? [Cm(l)] : wG(l)), T = p !== "none";
      !f && T && M.push(...CG(l, m, p, C));
      const N = [l, ...M], B = await aO(e, g), $ = [];
      let R = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (u && $.push(B[b]), h) {
        const ie = vG(i, o, C);
        $.push(B[ie[0]], B[ie[1]]);
      }
      if (R = [...R, {
        placement: i,
        overflows: $
      }], !$.every((ie) => ie <= 0)) {
        var V, z;
        const ie = (((V = s.flip) == null ? void 0 : V.index) || 0) + 1, he = N[ie];
        if (he && (!(h === "alignment" ? w !== tl(he) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        R.every((ye) => tl(ye.placement) === w ? ye.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ie,
              overflows: R
            },
            reset: {
              placement: he
            }
          };
        let Se = (z = R.filter((ge) => ge.overflows[0] <= 0).sort((ge, ye) => ge.overflows[1] - ye.overflows[1])[0]) == null ? void 0 : z.placement;
        if (!Se)
          switch (d) {
            case "bestFit": {
              var ue;
              const ge = (ue = R.filter((ye) => {
                if (T) {
                  const ze = tl(ye.placement);
                  return ze === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ze === "y";
                }
                return !0;
              }).map((ye) => [ye.placement, ye.overflows.filter((ze) => ze > 0).reduce((ze, I) => ze + I, 0)]).sort((ye, ze) => ye[1] - ze[1])[0]) == null ? void 0 : ue[0];
              ge && (Se = ge);
              break;
            }
            case "initialPlacement":
              Se = l;
              break;
          }
        if (i !== Se)
          return {
            reset: {
              placement: Se
            }
          };
      }
      return {};
    }
  };
}, EG = /* @__PURE__ */ new Set(["left", "top"]);
async function IG(n, e) {
  const {
    placement: t,
    platform: r,
    elements: i
  } = n, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = Ia(t), l = O1(t), a = tl(t) === "y", c = EG.has(o) ? -1 : 1, u = s && a ? -1 : 1, h = A1(e, n);
  let {
    mainAxis: f,
    crossAxis: d,
    alignmentAxis: p
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return l && typeof p == "number" && (d = l === "end" ? p * -1 : p), a ? {
    x: d * u,
    y: f * c
  } : {
    x: f * c,
    y: d * u
  };
}
const DG = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      var t, r;
      const {
        x: i,
        y: s,
        placement: o,
        middlewareData: l
      } = e, a = await IG(e, n);
      return o === ((t = l.offset) == null ? void 0 : t.placement) && (r = l.arrow) != null && r.alignmentOffset ? {} : {
        x: i + a.x,
        y: s + a.y,
        data: {
          ...a,
          placement: o
        }
      };
    }
  };
}, NG = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r,
        placement: i
      } = e, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: l = {
          fn: (g) => {
            let {
              x: b,
              y: w
            } = g;
            return {
              x: b,
              y: w
            };
          }
        },
        ...a
      } = A1(n, e), c = {
        x: t,
        y: r
      }, u = await aO(e, a), h = tl(Ia(i)), f = sO(h);
      let d = c[f], p = c[h];
      if (s) {
        const g = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", w = d + u[g], k = d - u[b];
        d = h8(w, d, k);
      }
      if (o) {
        const g = h === "y" ? "top" : "left", b = h === "y" ? "bottom" : "right", w = p + u[g], k = p - u[b];
        p = h8(w, p, k);
      }
      const m = l.fn({
        ...e,
        [f]: d,
        [h]: p
      });
      return {
        ...m,
        data: {
          x: m.x - t,
          y: m.y - r,
          enabled: {
            [f]: s,
            [h]: o
          }
        }
      };
    }
  };
};
function E1() {
  return typeof window < "u";
}
function su(n) {
  return cO(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Xr(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function So(n) {
  var e;
  return (e = (cO(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function cO(n) {
  return E1() ? n instanceof Node || n instanceof Xr(n).Node : !1;
}
function Hi(n) {
  return E1() ? n instanceof Element || n instanceof Xr(n).Element : !1;
}
function Ss(n) {
  return E1() ? n instanceof HTMLElement || n instanceof Xr(n).HTMLElement : !1;
}
function m8(n) {
  return !E1() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Xr(n).ShadowRoot;
}
const RG = /* @__PURE__ */ new Set(["inline", "contents"]);
function vd(n) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: r,
    display: i
  } = $i(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !RG.has(i);
}
const PG = /* @__PURE__ */ new Set(["table", "td", "th"]);
function _G(n) {
  return PG.has(su(n));
}
const LG = [":popover-open", ":modal"];
function I1(n) {
  return LG.some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
const BG = ["transform", "translate", "scale", "rotate", "perspective"], zG = ["transform", "translate", "scale", "rotate", "perspective", "filter"], FG = ["paint", "layout", "strict", "content"];
function lb(n) {
  const e = ab(), t = Hi(n) ? $i(n) : n;
  return BG.some((r) => t[r] ? t[r] !== "none" : !1) || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || zG.some((r) => (t.willChange || "").includes(r)) || FG.some((r) => (t.contain || "").includes(r));
}
function HG(n) {
  let e = gl(n);
  for (; Ss(e) && !qc(e); ) {
    if (lb(e))
      return e;
    if (I1(e))
      return null;
    e = gl(e);
  }
  return null;
}
function ab() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const $G = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function qc(n) {
  return $G.has(su(n));
}
function $i(n) {
  return Xr(n).getComputedStyle(n);
}
function D1(n) {
  return Hi(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function gl(n) {
  if (su(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    m8(n) && n.host || // Fallback.
    So(n)
  );
  return m8(e) ? e.host : e;
}
function uO(n) {
  const e = gl(n);
  return qc(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : Ss(e) && vd(e) ? e : uO(e);
}
function hO(n, e, t) {
  var r;
  e === void 0 && (e = []);
  const i = uO(n), s = i === ((r = n.ownerDocument) == null ? void 0 : r.body), o = Xr(i);
  return s ? (n5(o), e.concat(o, o.visualViewport || [], vd(i) ? i : [], [])) : e.concat(i, hO(i, []));
}
function n5(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function fO(n) {
  const e = $i(n);
  let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = Ss(n), s = i ? n.offsetWidth : t, o = i ? n.offsetHeight : r, l = Sm(t) !== s || Sm(r) !== o;
  return l && (t = s, r = o), {
    width: t,
    height: r,
    $: l
  };
}
function dO(n) {
  return Hi(n) ? n : n.contextElement;
}
function Cc(n) {
  const e = dO(n);
  if (!Ss(e))
    return vs(1);
  const t = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = fO(e);
  let o = (s ? Sm(t.width) : t.width) / r, l = (s ? Sm(t.height) : t.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: o,
    y: l
  };
}
const VG = /* @__PURE__ */ vs(0);
function pO(n) {
  const e = Xr(n);
  return !ab() || !e.visualViewport ? VG : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function qG(n, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== Xr(n) ? !1 : e;
}
function Wf(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const i = n.getBoundingClientRect(), s = dO(n);
  let o = vs(1);
  e && (r ? Hi(r) && (o = Cc(r)) : o = Cc(n));
  const l = qG(s, t, r) ? pO(s) : vs(0);
  let a = (i.left + l.x) / o.x, c = (i.top + l.y) / o.y, u = i.width / o.x, h = i.height / o.y;
  if (s) {
    const f = Xr(s), d = r && Hi(r) ? Xr(r) : r;
    let p = f, m = n5(p);
    for (; m && r && d !== p; ) {
      const g = Cc(m), b = m.getBoundingClientRect(), w = $i(m), k = b.left + (m.clientLeft + parseFloat(w.paddingLeft)) * g.x, C = b.top + (m.clientTop + parseFloat(w.paddingTop)) * g.y;
      a *= g.x, c *= g.y, u *= g.x, h *= g.y, a += k, c += C, p = Xr(m), m = n5(p);
    }
  }
  return Mm({
    width: u,
    height: h,
    x: a,
    y: c
  });
}
function N1(n, e) {
  const t = D1(n).scrollLeft;
  return e ? e.left + t : Wf(So(n)).left + t;
}
function mO(n, e) {
  const t = n.getBoundingClientRect(), r = t.left + e.scrollLeft - N1(n, t), i = t.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function WG(n) {
  let {
    elements: e,
    rect: t,
    offsetParent: r,
    strategy: i
  } = n;
  const s = i === "fixed", o = So(r), l = e ? I1(e.floating) : !1;
  if (r === o || l && s)
    return t;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = vs(1);
  const u = vs(0), h = Ss(r);
  if ((h || !h && !s) && ((su(r) !== "body" || vd(o)) && (a = D1(r)), Ss(r))) {
    const d = Wf(r);
    c = Cc(r), u.x = d.x + r.clientLeft, u.y = d.y + r.clientTop;
  }
  const f = o && !h && !s ? mO(o, a) : vs(0);
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - a.scrollLeft * c.x + u.x + f.x,
    y: t.y * c.y - a.scrollTop * c.y + u.y + f.y
  };
}
function jG(n) {
  return Array.from(n.getClientRects());
}
function UG(n) {
  const e = So(n), t = D1(n), r = n.ownerDocument.body, i = Sc(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = Sc(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -t.scrollLeft + N1(n);
  const l = -t.scrollTop;
  return $i(r).direction === "rtl" && (o += Sc(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: o,
    y: l
  };
}
const g8 = 25;
function KG(n, e) {
  const t = Xr(n), r = So(n), i = t.visualViewport;
  let s = r.clientWidth, o = r.clientHeight, l = 0, a = 0;
  if (i) {
    s = i.width, o = i.height;
    const u = ab();
    (!u || u && e === "fixed") && (l = i.offsetLeft, a = i.offsetTop);
  }
  const c = N1(r);
  if (c <= 0) {
    const u = r.ownerDocument, h = u.body, f = getComputedStyle(h), d = u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, p = Math.abs(r.clientWidth - h.clientWidth - d);
    p <= g8 && (s -= p);
  } else c <= g8 && (s += c);
  return {
    width: s,
    height: o,
    x: l,
    y: a
  };
}
const GG = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function YG(n, e) {
  const t = Wf(n, !0, e === "fixed"), r = t.top + n.clientTop, i = t.left + n.clientLeft, s = Ss(n) ? Cc(n) : vs(1), o = n.clientWidth * s.x, l = n.clientHeight * s.y, a = i * s.x, c = r * s.y;
  return {
    width: o,
    height: l,
    x: a,
    y: c
  };
}
function y8(n, e, t) {
  let r;
  if (e === "viewport")
    r = KG(n, t);
  else if (e === "document")
    r = UG(So(n));
  else if (Hi(e))
    r = YG(e, t);
  else {
    const i = pO(n);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return Mm(r);
}
function gO(n, e) {
  const t = gl(n);
  return t === e || !Hi(t) || qc(t) ? !1 : $i(t).position === "fixed" || gO(t, e);
}
function JG(n, e) {
  const t = e.get(n);
  if (t)
    return t;
  let r = hO(n, []).filter((l) => Hi(l) && su(l) !== "body"), i = null;
  const s = $i(n).position === "fixed";
  let o = s ? gl(n) : n;
  for (; Hi(o) && !qc(o); ) {
    const l = $i(o), a = lb(o);
    !a && l.position === "fixed" && (i = null), (s ? !a && !i : !a && l.position === "static" && !!i && GG.has(i.position) || vd(o) && !a && gO(n, o)) ? r = r.filter((u) => u !== o) : i = l, o = gl(o);
  }
  return e.set(n, r), r;
}
function XG(n) {
  let {
    element: e,
    boundary: t,
    rootBoundary: r,
    strategy: i
  } = n;
  const o = [...t === "clippingAncestors" ? I1(e) ? [] : JG(e, this._c) : [].concat(t), r], l = o[0], a = o.reduce((c, u) => {
    const h = y8(e, u, i);
    return c.top = Sc(h.top, c.top), c.right = e5(h.right, c.right), c.bottom = e5(h.bottom, c.bottom), c.left = Sc(h.left, c.left), c;
  }, y8(e, l, i));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function ZG(n) {
  const {
    width: e,
    height: t
  } = fO(n);
  return {
    width: e,
    height: t
  };
}
function QG(n, e, t) {
  const r = Ss(e), i = So(e), s = t === "fixed", o = Wf(n, !0, s, e);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = vs(0);
  function c() {
    a.x = N1(i);
  }
  if (r || !r && !s)
    if ((su(e) !== "body" || vd(i)) && (l = D1(e)), r) {
      const d = Wf(e, !0, s, e);
      a.x = d.x + e.clientLeft, a.y = d.y + e.clientTop;
    } else i && c();
  s && !r && i && c();
  const u = i && !r && !s ? mO(i, l) : vs(0), h = o.left + l.scrollLeft - a.x - u.x, f = o.top + l.scrollTop - a.y - u.y;
  return {
    x: h,
    y: f,
    width: o.width,
    height: o.height
  };
}
function O2(n) {
  return $i(n).position === "static";
}
function b8(n, e) {
  if (!Ss(n) || $i(n).position === "fixed")
    return null;
  if (e)
    return e(n);
  let t = n.offsetParent;
  return So(n) === t && (t = t.ownerDocument.body), t;
}
function yO(n, e) {
  const t = Xr(n);
  if (I1(n))
    return t;
  if (!Ss(n)) {
    let i = gl(n);
    for (; i && !qc(i); ) {
      if (Hi(i) && !O2(i))
        return i;
      i = gl(i);
    }
    return t;
  }
  let r = b8(n, e);
  for (; r && _G(r) && O2(r); )
    r = b8(r, e);
  return r && qc(r) && O2(r) && !lb(r) ? t : r || HG(n) || t;
}
const eY = async function(n) {
  const e = this.getOffsetParent || yO, t = this.getDimensions, r = await t(n.floating);
  return {
    reference: QG(n.reference, await e(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function tY(n) {
  return $i(n).direction === "rtl";
}
const nY = {
  convertOffsetParentRelativeRectToViewportRelativeRect: WG,
  getDocumentElement: So,
  getClippingRect: XG,
  getOffsetParent: yO,
  getElementRects: eY,
  getClientRects: jG,
  getDimensions: ZG,
  getScale: Cc,
  isElement: Hi,
  isRTL: tY
}, yl = DG, v8 = NG, Tm = OG, Vi = (n, e, t) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: nY,
    ...t
  }, s = {
    ...i.platform,
    _c: r
  };
  return AG(n, e, {
    ...i,
    platform: s
  });
};
function wd(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-block",
      ...e
    }
  }), n;
}
const rY = (n) => !bs((t) => t.type.name === "table")(n), R1 = Ct(
  { filterNodes: rY },
  "blockConfig"
);
wd(R1, {
  displayName: "Ctx<blockConfig>"
});
function iY(n, e, t) {
  if (!n.dom.parentElement) return null;
  try {
    const i = n.posAtCoords({
      left: e.x,
      top: e.y
    })?.inside;
    if (i == null || i < 0) return null;
    let s = n.state.doc.resolve(i), o = n.state.doc.nodeAt(i), l = n.nodeDOM(i);
    const a = (u) => {
      const h = s.depth >= 1 && s.index(s.depth) === 0;
      if (!(u || h)) return;
      const d = s.before(s.depth);
      o = n.state.doc.nodeAt(d), l = n.nodeDOM(d), s = n.state.doc.resolve(d), t(s, o) || a(!0);
    }, c = t(s, o);
    return a(!c), !l || !o ? null : { node: o, $pos: s, el: l };
  } catch {
    return null;
  }
}
const w8 = d0.ie && d0.ie_version < 15 || d0.ios && d0.webkit_version < 604, x8 = 20;
class sY {
  constructor() {
    this.#e = () => {
      if (!this.#n) return null;
      const e = this.#n, t = this.#o;
      if (t && $e.isSelectable(e.node)) {
        const r = $e.create(
          t.state.doc,
          e.$pos.pos
        );
        return t.dispatch(t.state.tr.setSelection(r)), t.focus(), this.#r = r, r;
      }
      return null;
    }, this.#r = null, this.#n = null, this.#a = void 0, this.#i = !1, this.#c = () => {
      this.#l?.({ type: "hide" }), this.#n = null;
    }, this.#u = (e) => {
      this.#n = e, this.#l?.({ type: "show", active: e });
    }, this.bind = (e, t) => {
      this.#t = e, this.#l = t;
    }, this.addEvent = (e) => {
      e.addEventListener("mousedown", this.#h), e.addEventListener("mouseup", this.#d), e.addEventListener("dragstart", this.#f);
    }, this.removeEvent = (e) => {
      e.removeEventListener("mousedown", this.#h), e.removeEventListener("mouseup", this.#d), e.removeEventListener("dragstart", this.#f);
    }, this.unBind = () => {
      this.#l = void 0;
    }, this.#h = () => {
      this.#a = this.#n?.el.getBoundingClientRect(), this.#e();
    }, this.#d = () => {
      if (!this.#i) {
        requestAnimationFrame(() => {
          this.#a && this.#o?.focus();
        });
        return;
      }
      this.#i = !1, this.#r = null;
    }, this.#f = (e) => {
      this.#i = !0;
      const t = this.#o;
      if (!t) return;
      t.dom.dataset.dragging = "true";
      const r = this.#r;
      if (e.dataTransfer && r) {
        const i = r.content();
        e.dataTransfer.effectAllowed = "copyMove";
        const { dom: s, text: o } = t.serializeForClipboard(i);
        e.dataTransfer.clearData(), e.dataTransfer.setData(
          w8 ? "Text" : "text/html",
          s.innerHTML
        ), w8 || e.dataTransfer.setData("text/plain", o);
        const l = this.#n?.el;
        l && e.dataTransfer.setDragImage(l, 0, 0), t.dragging = {
          slice: i,
          move: !0
        };
      }
    }, this.keydownCallback = (e) => (this.#c(), this.#i = !1, e.dom.dataset.dragging = "false", !1), this.#p = t1((e, t) => {
      if (!e.editable) return;
      const r = e.dom.getBoundingClientRect(), i = r.left + r.width / 2;
      if (!(e.root.elementFromPoint(i, t.clientY) instanceof Element)) {
        this.#c();
        return;
      }
      const o = this.#s;
      if (!o) return;
      const l = iY(
        e,
        { x: i, y: t.clientY },
        o
      );
      if (!l) {
        this.#c();
        return;
      }
      this.#u(l);
    }, 200), this.mousemoveCallback = (e, t) => (e.composing || !e.editable || this.#p(e, t), !1), this.dragoverCallback = (e, t) => {
      if (this.#i) {
        const r = this.#o?.dom.parentElement;
        if (!r) return !1;
        const i = r.scrollHeight > r.clientHeight, s = r.getBoundingClientRect();
        if (i) {
          if (r.scrollTop > 0 && Math.abs(t.y - s.y) < x8) {
            const a = r.scrollTop > 10 ? r.scrollTop - 10 : 0;
            return r.scrollTop = a, !1;
          }
          const o = Math.round(e.dom.getBoundingClientRect().height);
          if (Math.round(r.scrollTop + s.height) < o && Math.abs(t.y - (s.height + s.y)) < x8) {
            const a = r.scrollTop + 10;
            return r.scrollTop = a, !1;
          }
        }
      }
      return !1;
    }, this.dragenterCallback = (e) => {
      e.dragging && (this.#i = !0, e.dom.dataset.dragging = "true");
    }, this.dragleaveCallback = (e, t) => {
      const r = t.clientX, i = t.clientY;
      (r < 0 || i < 0 || r > window.innerWidth || i > window.innerHeight) && (this.#n = null, this.#m(e));
    }, this.dropCallback = (e) => (this.#m(e), !1), this.dragendCallback = (e) => {
      this.#m(e);
    }, this.#m = (e) => {
      this.#i = !1, e.dom.dataset.dragging = "false";
    };
  }
  /// @internal
  #t;
  #e;
  #r;
  #n;
  #a;
  #i;
  /// @internal
  get #s() {
    try {
      return this.#t?.get(R1.key).filterNodes;
    } catch {
      return;
    }
  }
  /// @internal
  get #o() {
    return this.#t?.get(St);
  }
  /// @internal
  #l;
  #c;
  #u;
  #h;
  #d;
  #f;
  #p;
  #m;
}
const cb = Ct(() => new sY(), "blockService"), P1 = Ct(
  {},
  "blockServiceInstance"
);
wd(cb, {
  displayName: "Ctx<blockService>"
});
wd(P1, {
  displayName: "Ctx<blockServiceInstance>"
});
const _1 = Ct({}, "blockSpec");
wd(_1, {
  displayName: "Ctx<blockSpec>"
});
const ub = kn((n) => {
  const e = new en("MILKDOWN_BLOCK"), r = n.get(cb.key)();
  n.set(P1.key, r);
  const i = n.get(_1.key);
  return new Ut({
    key: e,
    ...i,
    props: {
      ...i.props,
      handleDOMEvents: {
        drop: (s) => r.dropCallback(s),
        pointermove: (s, o) => r.mousemoveCallback(s, o),
        keydown: (s) => r.keydownCallback(s),
        dragover: (s, o) => r.dragoverCallback(s, o),
        dragleave: (s, o) => r.dragleaveCallback(s, o),
        dragenter: (s) => r.dragenterCallback(s),
        dragend: (s) => r.dragendCallback(s)
      }
    }
  });
});
wd(ub, {
  displayName: "Prose<block>"
});
class oY {
  constructor(e) {
    this.#n = null, this.#i = !1, this.update = () => {
      requestAnimationFrame(() => {
        if (!this.#i)
          try {
            this.#h(), this.#i = !0;
          } catch {
          }
      });
    }, this.destroy = () => {
      this.#r?.unBind(), this.#r?.removeEvent(this.#t), this.#t.remove();
    }, this.show = (t) => {
      const r = t.el, i = this.#e.get(St).dom, s = {
        ctx: this.#e,
        active: t,
        editorDom: i,
        blockDom: this.#t
      }, o = {
        contextElement: r,
        getBoundingClientRect: () => this.#c ? this.#c(s) : r.getBoundingClientRect()
      }, l = [Tm()];
      if (this.#l) {
        const a = this.#l(s), c = yl(a);
        l.push(c);
      }
      Vi(o, this.#t, {
        placement: this.#u ? this.#u(s) : "left",
        middleware: [...l, ...this.#s],
        ...this.#o
      }).then(({ x: a, y: c }) => {
        Object.assign(this.#t.style, {
          left: `${a}px`,
          top: `${c}px`
        }), this.#t.dataset.show = "true";
      }).catch(console.error);
    }, this.hide = () => {
      this.#t.dataset.show = "false";
    }, this.#e = e.ctx, this.#t = e.content, this.#l = e.getOffset, this.#c = e.getPosition, this.#u = e.getPlacement, this.#s = e.middleware ?? [], this.#o = e.floatingUIOptions ?? {}, this.#a = e.root, this.hide();
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  #n;
  /// @internal
  #a;
  #i;
  /// @internal
  #s;
  /// @internal
  #o;
  /// @internal
  #l;
  /// @internal
  #c;
  /// @internal
  #u;
  /// The context of current active node.
  get active() {
    return this.#n;
  }
  /// @internal
  #h() {
    const e = this.#e.get(St);
    (this.#a ?? e.dom.parentElement ?? document.body).appendChild(this.#t);
    const r = this.#e.get(P1.key);
    r.bind(this.#e, (i) => {
      i.type === "hide" ? (this.hide(), this.#n = null) : i.type === "show" && (this.show(i.active), this.#n = i.active);
    }), this.#r = r, this.#r.addEvent(this.#t), this.#t.draggable = !0;
  }
}
const L1 = [
  _1,
  R1,
  cb,
  P1,
  ub
];
L1.key = _1.key;
L1.pluginKey = ub.key;
function lY(n, e) {
  return function(t, r) {
    let { $from: i, $to: s, node: o } = t.selection;
    if (o && o.isBlock || i.depth < 2 || !i.sameParent(s))
      return !1;
    let l = i.node(-1);
    if (l.type != n)
      return !1;
    if (i.parent.content.size == 0 && i.node(-1).childCount == i.indexAfter(-1)) {
      if (i.depth == 3 || i.node(-3).type != n || i.index(-2) != i.node(-2).childCount - 1)
        return !1;
      if (r) {
        let h = ce.empty, f = i.index(-1) ? 1 : i.index(-2) ? 2 : 3;
        for (let b = i.depth - f; b >= i.depth - 3; b--)
          h = ce.from(i.node(b).copy(h));
        let d = i.indexAfter(-1) < i.node(-2).childCount ? 1 : i.indexAfter(-2) < i.node(-3).childCount ? 2 : 3;
        h = h.append(ce.from(n.createAndFill()));
        let p = i.before(i.depth - (f - 1)), m = t.tr.replace(p, i.after(-d), new be(h, 4 - f, 0)), g = -1;
        m.doc.nodesBetween(p, m.doc.content.size, (b, w) => {
          if (g > -1)
            return !1;
          b.isTextblock && b.content.size == 0 && (g = w + 1);
        }), g > -1 && m.setSelection(Ge.near(m.doc.resolve(g))), r(m.scrollIntoView());
      }
      return !0;
    }
    let a = s.pos == i.end() ? l.contentMatchAt(0).defaultType : null, c = t.tr.delete(i.pos, s.pos), u = a ? [null, { type: a }] : void 0;
    return Wh(c.doc, i.pos, 2, u) ? (r && r(c.split(i.pos, 2, u).scrollIntoView()), !0) : !1;
  };
}
function aY(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == n);
    return s ? t ? r.node(s.depth - 1).type == n ? cY(e, t, n, s) : uY(e, t, s) : !0 : !1;
  };
}
function cY(n, e, t, r) {
  let i = n.tr, s = r.end, o = r.$to.end(r.depth);
  s < o && (i.step(new Yn(s - 1, o, s, o, new be(ce.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new $M(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
  const l = h1(r);
  if (l == null)
    return !1;
  i.lift(r, l);
  let a = i.doc.resolve(i.mapping.map(s, -1) - 1);
  return f1(i.doc, a.pos) && a.nodeBefore.type == a.nodeAfter.type && i.join(a.pos), e(i.scrollIntoView()), !0;
}
function uY(n, e, t) {
  let r = n.tr, i = t.parent;
  for (let d = t.end, p = t.endIndex - 1, m = t.startIndex; p > m; p--)
    d -= i.child(p).nodeSize, r.delete(d - 1, d + 1);
  let s = r.doc.resolve(t.start), o = s.nodeAfter;
  if (r.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize)
    return !1;
  let l = t.startIndex == 0, a = t.endIndex == i.childCount, c = s.node(-1), u = s.index(-1);
  if (!c.canReplace(u + (l ? 0 : 1), u + 1, o.content.append(a ? ce.empty : ce.from(i))))
    return !1;
  let h = s.pos, f = h + o.nodeSize;
  return r.step(new Yn(h - (l ? 1 : 0), f + (a ? 1 : 0), h + 1, f - 1, new be((l ? ce.empty : ce.from(i.copy(ce.empty))).append(a ? ce.empty : ce.from(i.copy(ce.empty))), l ? 0 : 1, a ? 0 : 1), l ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function hY(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (c) => c.childCount > 0 && c.firstChild.type == n);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let l = s.parent, a = l.child(o - 1);
    if (a.type != n)
      return !1;
    if (t) {
      let c = a.lastChild && a.lastChild.type == l.type, u = ce.from(c ? n.create() : null), h = new be(ce.from(n.create(null, ce.from(l.type.create(null, u)))), c ? 3 : 1, 0), f = s.start, d = s.end;
      t(e.tr.step(new Yn(f - (c ? 3 : 1), d, f, d, h, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function fY(n) {
  const e = /* @__PURE__ */ new Map();
  if (!n || !n.type)
    throw new Error("mdast-util-definitions expected node");
  return Tl(n, "definition", function(r) {
    const i = k8(r.identifier);
    i && !e.get(i) && e.set(i, r);
  }), t;
  function t(r) {
    const i = k8(r);
    return e.get(i);
  }
}
function k8(n) {
  return String(n || "").toUpperCase();
}
function dY() {
  return function(n) {
    const e = fY(n);
    Tl(n, function(t, r, i) {
      if (t.type === "definition" && i !== void 0 && typeof r == "number")
        return i.children.splice(r, 1), [Ry, r];
      if (t.type === "imageReference" || t.type === "linkReference") {
        const s = e(t.identifier);
        if (s && i && typeof r == "number")
          return i.children[r] = t.type === "imageReference" ? { type: "image", url: s.url, title: s.title, alt: t.alt } : {
            type: "link",
            url: s.url,
            title: s.title,
            children: t.children
          }, [Ry, r];
      }
    });
  };
}
function bO(n, e) {
  if (!(e.childCount >= 1 && e.lastChild?.type.name === "hardbreak")) {
    n.next(e.content);
    return;
  }
  const r = [];
  e.content.forEach((i, s, o) => {
    o !== e.childCount - 1 && r.push(i);
  }), n.next(ce.fromArray(r));
}
function K(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/preset-commonmark",
      ...e
    }
  }), n;
}
const hb = bd("emphasis");
K(hb, {
  displayName: "Attr<emphasis>",
  group: "Emphasis"
});
const La = iu("emphasis", (n) => ({
  attrs: {
    marker: {
      default: n.get(Yh).emphasis || "*",
      validate: "string"
    }
  },
  parseDOM: [
    { tag: "i" },
    { tag: "em" },
    { style: "font-style", getAttrs: (e) => e === "italic" }
  ],
  toDOM: (e) => ["em", n.get(hb.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "emphasis",
    runner: (e, t, r) => {
      e.openMark(r, { marker: t.marker }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "emphasis",
    runner: (e, t) => {
      e.withMark(t, "emphasis", void 0, {
        marker: t.attrs.marker
      });
    }
  }
}));
K(La.mark, {
  displayName: "MarkSchema<emphasis>",
  group: "Emphasis"
});
K(La.ctx, {
  displayName: "MarkSchemaCtx<emphasis>",
  group: "Emphasis"
});
const B1 = Ye("ToggleEmphasis", (n) => () => S1(La.type(n)));
K(B1, {
  displayName: "Command<toggleEmphasisCommand>",
  group: "Emphasis"
});
const vO = Qn((n) => hd(/(?:^|[^*])\*([^*]+)\*$/, La.type(n), {
  getAttr: () => ({
    marker: "*"
  }),
  updateCaptured: ({ fullMatch: e, start: t }) => e.startsWith("*") ? {} : { fullMatch: e.slice(1), start: t + 1 }
}));
K(vO, {
  displayName: "InputRule<emphasis>|Star",
  group: "Emphasis"
});
const wO = Qn((n) => hd(/\b_(?![_\s])(.*?[^_\s])_\b/, La.type(n), {
  getAttr: () => ({
    marker: "_"
  }),
  updateCaptured: ({ fullMatch: e, start: t }) => e.startsWith("_") ? {} : { fullMatch: e.slice(1), start: t + 1 }
}));
K(wO, {
  displayName: "InputRule<emphasis>|Underscore",
  group: "Emphasis"
});
const fb = Rr("emphasisKeymap", {
  ToggleEmphasis: {
    shortcuts: "Mod-i",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(B1.key);
    }
  }
});
K(fb.ctx, {
  displayName: "KeymapCtx<emphasis>",
  group: "Emphasis"
});
K(fb.shortcuts, {
  displayName: "Keymap<emphasis>",
  group: "Emphasis"
});
const db = bd("strong");
K(db, {
  displayName: "Attr<strong>",
  group: "Strong"
});
const ou = iu("strong", (n) => ({
  attrs: {
    marker: {
      default: n.get(Yh).strong || "*",
      validate: "string"
    }
  },
  parseDOM: [
    // This works around a Google Docs misbehavior where
    // pasted content will be inexplicably wrapped in `<b>`
    // tags with a font-weight normal.
    {
      tag: "b",
      getAttrs: (e) => e.style.fontWeight != "normal" && null
    },
    { tag: "strong" },
    { style: "font-style", getAttrs: (e) => e === "bold" },
    { style: "font-weight=400", clearMark: (e) => e.type.name == "strong" },
    {
      style: "font-weight",
      getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
    }
  ],
  toDOM: (e) => ["strong", n.get(db.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "strong",
    runner: (e, t, r) => {
      e.openMark(r, { marker: t.marker }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strong",
    runner: (e, t) => {
      e.withMark(t, "strong", void 0, {
        marker: t.attrs.marker
      });
    }
  }
}));
K(ou.mark, {
  displayName: "MarkSchema<strong>",
  group: "Strong"
});
K(ou.ctx, {
  displayName: "MarkSchemaCtx<strong>",
  group: "Strong"
});
const z1 = Ye("ToggleStrong", (n) => () => S1(ou.type(n)));
K(z1, {
  displayName: "Command<toggleStrongCommand>",
  group: "Strong"
});
const xO = Qn((n) => hd(
  new RegExp("(?<![\\w:/])(?:\\*\\*|__)([^*_]+?)(?:\\*\\*|__)(?![\\w/])$"),
  ou.type(n),
  {
    getAttr: (e) => ({
      marker: e[0].startsWith("*") ? "*" : "_"
    })
  }
));
K(xO, {
  displayName: "InputRule<strong>",
  group: "Strong"
});
const pb = Rr("strongKeymap", {
  ToggleBold: {
    shortcuts: ["Mod-b"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(z1.key);
    }
  }
});
K(pb.ctx, {
  displayName: "KeymapCtx<strong>",
  group: "Strong"
});
K(pb.shortcuts, {
  displayName: "Keymap<strong>",
  group: "Strong"
});
const mb = bd("inlineCode");
K(mb, {
  displayName: "Attr<inlineCode>",
  group: "InlineCode"
});
const eo = iu("inlineCode", (n) => ({
  priority: 100,
  code: !0,
  parseDOM: [{ tag: "code" }],
  toDOM: (e) => ["code", n.get(mb.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "inlineCode",
    runner: (e, t, r) => {
      e.openMark(r), e.addText(t.value), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "inlineCode",
    runner: (e, t, r) => {
      e.withMark(t, "inlineCode", r.text || "");
    }
  }
}));
K(eo.mark, {
  displayName: "MarkSchema<inlineCode>",
  group: "InlineCode"
});
K(eo.ctx, {
  displayName: "MarkSchemaCtx<inlineCode>",
  group: "InlineCode"
});
const F1 = Ye(
  "ToggleInlineCode",
  (n) => () => (e, t) => {
    const { selection: r, tr: i } = e;
    if (r.empty) return !1;
    const { from: s, to: o } = r;
    return e.doc.rangeHasMark(s, o, eo.type(n)) ? (t?.(i.removeMark(s, o, eo.type(n))), !0) : (Object.keys(e.schema.marks).filter(
      (c) => c !== eo.type.name
    ).map((c) => e.schema.marks[c]).forEach((c) => {
      i.removeMark(s, o, c);
    }), t?.(i.addMark(s, o, eo.type(n).create())), !0);
  }
);
K(F1, {
  displayName: "Command<toggleInlineCodeCommand>",
  group: "InlineCode"
});
const kO = Qn((n) => hd(/(?:`)([^`]+)(?:`)$/, eo.type(n)));
K(kO, {
  displayName: "InputRule<inlineCodeInputRule>",
  group: "InlineCode"
});
const gb = Rr("inlineCodeKeymap", {
  ToggleInlineCode: {
    shortcuts: "Mod-e",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(F1.key);
    }
  }
});
K(gb.ctx, {
  displayName: "KeymapCtx<inlineCode>",
  group: "InlineCode"
});
K(gb.shortcuts, {
  displayName: "Keymap<inlineCode>",
  group: "InlineCode"
});
const yb = bd("link");
K(yb, {
  displayName: "Attr<link>",
  group: "Link"
});
const Pi = iu("link", (n) => ({
  attrs: {
    href: { validate: "string" },
    title: { default: null, validate: "string|null" }
  },
  parseDOM: [
    {
      tag: "a[href]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw qi(e);
        return {
          href: e.getAttribute("href"),
          title: e.getAttribute("title")
        };
      }
    }
  ],
  toDOM: (e) => ["a", { ...n.get(yb.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: (e) => e.type === "link",
    runner: (e, t, r) => {
      const i = t.url, s = t.title;
      e.openMark(r, { href: i, title: s }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "link",
    runner: (e, t) => {
      e.withMark(t, "link", void 0, {
        title: t.attrs.title,
        url: t.attrs.href
      });
    }
  }
}));
K(Pi.mark, {
  displayName: "MarkSchema<link>",
  group: "Link"
});
const SO = Ye(
  "ToggleLink",
  (n) => (e = {}) => S1(Pi.type(n), e)
);
K(SO, {
  displayName: "Command<toggleLinkCommand>",
  group: "Link"
});
const CO = Ye(
  "UpdateLink",
  (n) => (e = {}) => (t, r) => {
    if (!r) return !1;
    let i, s = -1;
    const { selection: o } = t, { from: l, to: a } = o;
    if (t.doc.nodesBetween(l, l === a ? a + 1 : a, (p, m) => {
      if (Pi.type(n).isInSet(p.marks))
        return i = p, s = m, !1;
    }), !i) return !1;
    const c = i.marks.find(({ type: p }) => p === Pi.type(n));
    if (!c) return !1;
    const u = s, h = s + i.nodeSize, { tr: f } = t, d = Pi.type(n).create({ ...c.attrs, ...e });
    return d ? (r(
      f.removeMark(u, h, c).addMark(u, h, d).setSelection(new Ee(f.selection.$anchor)).scrollIntoView()
    ), !0) : !1;
  }
);
K(CO, {
  displayName: "Command<updateLinkCommand>",
  group: "Link"
});
const MO = ob("doc", () => ({
  content: "block+",
  parseMarkdown: {
    match: ({ type: n }) => n === "root",
    runner: (n, e, t) => {
      n.injectRoot(e, t);
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "doc",
    runner: (n, e) => {
      n.openNode("root"), n.next(e.content);
    }
  }
}));
K(MO, {
  displayName: "NodeSchema<doc>",
  group: "Doc"
});
function pY(n) {
  return F3(
    n,
    (e) => e.type === "html" && ["<br />", "<br>", "<br >", "<br/>"].includes(
      e.value?.trim()
    ),
    (e, t) => {
      if (!t.length) return;
      const r = t[t.length - 1];
      if (!r) return;
      const i = r.children.indexOf(e);
      i !== -1 && r.children.splice(i, 1);
    },
    !0
  );
}
const H1 = As(
  "remark-preserve-empty-line",
  () => () => pY
);
K(H1.plugin, {
  displayName: "Remark<remarkPreserveEmptyLine>",
  group: "Remark"
});
K(H1.options, {
  displayName: "RemarkConfig<remarkPreserveEmptyLine>",
  group: "Remark"
});
const bb = Wi("paragraph");
K(bb, {
  displayName: "Attr<paragraph>",
  group: "Paragraph"
});
const Os = hn("paragraph", (n) => ({
  content: "inline*",
  group: "block",
  parseDOM: [{ tag: "p" }],
  toDOM: (e) => ["p", n.get(bb.key)(e), 0],
  parseMarkdown: {
    match: (e) => e.type === "paragraph",
    runner: (e, t, r) => {
      e.openNode(r), t.children ? e.next(t.children) : e.addText(t.value || ""), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "paragraph",
    runner: (e, t) => {
      const i = n.get(St).state?.doc.lastChild;
      e.openNode("paragraph"), (!t.content || t.content.size === 0) && t !== i && mY(n) ? e.addNode("html", void 0, "<br />") : bO(e, t), e.closeNode();
    }
  }
}));
function mY(n) {
  let e = !1;
  try {
    n.get(H1.id), e = !0;
  } catch {
    e = !1;
  }
  return e;
}
K(Os.node, {
  displayName: "NodeSchema<paragraph>",
  group: "Paragraph"
});
K(Os.ctx, {
  displayName: "NodeSchemaCtx<paragraph>",
  group: "Paragraph"
});
const vb = Ye(
  "TurnIntoText",
  (n) => () => Lf(Os.type(n))
);
K(vb, {
  displayName: "Command<turnIntoTextCommand>",
  group: "Paragraph"
});
const wb = Rr("paragraphKeymap", {
  TurnIntoText: {
    shortcuts: "Mod-Alt-0",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(vb.key);
    }
  }
});
K(wb.ctx, {
  displayName: "KeymapCtx<paragraph>",
  group: "Paragraph"
});
K(wb.shortcuts, {
  displayName: "Keymap<paragraph>",
  group: "Paragraph"
});
const gY = Array(6).fill(0).map((n, e) => e + 1);
function yY(n) {
  return n.textContent.toLowerCase().trim().replace(/\s+/g, "-");
}
const $1 = Ct(
  yY,
  "headingIdGenerator"
);
K($1, {
  displayName: "Ctx<HeadingIdGenerator>",
  group: "Heading"
});
const xb = Wi("heading");
K(xb, {
  displayName: "Attr<heading>",
  group: "Heading"
});
const jr = hn("heading", (n) => {
  const e = n.get($1.key);
  return {
    content: "inline*",
    group: "block",
    defining: !0,
    attrs: {
      id: {
        default: "",
        validate: "string"
      },
      level: {
        default: 1,
        validate: "number"
      }
    },
    parseDOM: gY.map((t) => ({
      tag: `h${t}`,
      getAttrs: (r) => {
        if (!(r instanceof HTMLElement)) throw qi(r);
        return { level: t, id: r.id };
      }
    })),
    toDOM: (t) => [
      `h${t.attrs.level}`,
      {
        ...n.get(xb.key)(t),
        id: t.attrs.id || e(t)
      },
      0
    ],
    parseMarkdown: {
      match: ({ type: t }) => t === "heading",
      runner: (t, r, i) => {
        const s = r.depth;
        t.openNode(i, { level: s }), t.next(r.children), t.closeNode();
      }
    },
    toMarkdown: {
      match: (t) => t.type.name === "heading",
      runner: (t, r) => {
        t.openNode("heading", void 0, { depth: r.attrs.level }), bO(t, r), t.closeNode();
      }
    }
  };
});
K(jr.node, {
  displayName: "NodeSchema<heading>",
  group: "Heading"
});
K(jr.ctx, {
  displayName: "NodeSchemaCtx<heading>",
  group: "Heading"
});
const TO = Qn((n) => N3(
  /^(?<hashes>#+)\s$/,
  jr.type(n),
  (e) => {
    const t = e.groups?.hashes?.length || 0, r = n.get(St), { $from: i } = r.state.selection, s = i.node();
    if (s.type.name === "heading") {
      let o = Number(s.attrs.level) + Number(t);
      return o > 6 && (o = 6), { level: o };
    }
    return { level: t };
  }
));
K(TO, {
  displayName: "InputRule<wrapInHeadingInputRule>",
  group: "Heading"
});
const $o = Ye("WrapInHeading", (n) => (e) => (e ??= 1, e < 1 ? Lf(Os.type(n)) : Lf(jr.type(n), { level: e })));
K($o, {
  displayName: "Command<wrapInHeadingCommand>",
  group: "Heading"
});
const kb = Ye(
  "DowngradeHeading",
  (n) => () => (e, t, r) => {
    const { $from: i } = e.selection, s = i.node();
    if (s.type !== jr.type(n) || !e.selection.empty || i.parentOffset !== 0)
      return !1;
    const o = s.attrs.level - 1;
    return o ? (t?.(
      e.tr.setNodeMarkup(e.selection.$from.before(), void 0, {
        ...s.attrs,
        level: o
      })
    ), !0) : Lf(Os.type(n))(e, t, r);
  }
);
K(kb, {
  displayName: "Command<downgradeHeadingCommand>",
  group: "Heading"
});
const Sb = Rr("headingKeymap", {
  TurnIntoH1: {
    shortcuts: "Mod-Alt-1",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call($o.key, 1);
    }
  },
  TurnIntoH2: {
    shortcuts: "Mod-Alt-2",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call($o.key, 2);
    }
  },
  TurnIntoH3: {
    shortcuts: "Mod-Alt-3",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call($o.key, 3);
    }
  },
  TurnIntoH4: {
    shortcuts: "Mod-Alt-4",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call($o.key, 4);
    }
  },
  TurnIntoH5: {
    shortcuts: "Mod-Alt-5",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call($o.key, 5);
    }
  },
  TurnIntoH6: {
    shortcuts: "Mod-Alt-6",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call($o.key, 6);
    }
  },
  DowngradeHeading: {
    shortcuts: ["Delete", "Backspace"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(kb.key);
    }
  }
});
K(Sb.ctx, {
  displayName: "KeymapCtx<heading>",
  group: "Heading"
});
K(Sb.shortcuts, {
  displayName: "Keymap<heading>",
  group: "Heading"
});
const Cb = Wi("blockquote");
K(Cb, {
  displayName: "Attr<blockquote>",
  group: "Blockquote"
});
const lu = hn(
  "blockquote",
  (n) => ({
    content: "block+",
    group: "block",
    defining: !0,
    parseDOM: [{ tag: "blockquote" }],
    toDOM: (e) => ["blockquote", n.get(Cb.key)(e), 0],
    parseMarkdown: {
      match: ({ type: e }) => e === "blockquote",
      runner: (e, t, r) => {
        e.openNode(r).next(t.children).closeNode();
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === "blockquote",
      runner: (e, t) => {
        e.openNode("blockquote").next(t.content).closeNode();
      }
    }
  })
);
K(lu.node, {
  displayName: "NodeSchema<blockquote>",
  group: "Blockquote"
});
K(lu.ctx, {
  displayName: "NodeSchemaCtx<blockquote>",
  group: "Blockquote"
});
const AO = Qn(
  (n) => D3(/^\s*>\s$/, lu.type(n))
);
K(AO, {
  displayName: "InputRule<wrapInBlockquoteInputRule>",
  group: "Blockquote"
});
const Mb = Ye(
  "WrapInBlockquote",
  (n) => () => K3(lu.type(n))
);
K(Mb, {
  displayName: "Command<wrapInBlockquoteCommand>",
  group: "Blockquote"
});
const Tb = Rr("blockquoteKeymap", {
  WrapInBlockquote: {
    shortcuts: "Mod-Shift-b",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Mb.key);
    }
  }
});
K(Tb.ctx, {
  displayName: "KeymapCtx<blockquote>",
  group: "Blockquote"
});
K(Tb.shortcuts, {
  displayName: "Keymap<blockquote>",
  group: "Blockquote"
});
const Ab = Wi("codeBlock", () => ({
  pre: {},
  code: {}
}));
K(Ab, {
  displayName: "Attr<codeBlock>",
  group: "CodeBlock"
});
const Cs = hn("code_block", (n) => ({
  content: "text*",
  group: "block",
  marks: "",
  defining: !0,
  code: !0,
  attrs: {
    language: {
      default: "",
      validate: "string"
    }
  },
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw qi(e);
        return { language: e.dataset.language };
      }
    }
  ],
  toDOM: (e) => {
    const t = n.get(Ab.key)(e), r = e.attrs.language, i = r && r.length > 0 ? { "data-language": r } : void 0;
    return [
      "pre",
      {
        ...t.pre,
        ...i
      },
      ["code", t.code, 0]
    ];
  },
  parseMarkdown: {
    match: ({ type: e }) => e === "code",
    runner: (e, t, r) => {
      const i = t.lang ?? "", s = t.value;
      e.openNode(r, { language: i }), s && e.addText(s), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "code_block",
    runner: (e, t) => {
      e.addNode("code", void 0, t.content.firstChild?.text || "", {
        lang: t.attrs.language
      });
    }
  }
}));
K(Cs.node, {
  displayName: "NodeSchema<codeBlock>",
  group: "CodeBlock"
});
K(Cs.ctx, {
  displayName: "NodeSchemaCtx<codeBlock>",
  group: "CodeBlock"
});
const OO = Qn(
  (n) => N3(
    /^```(?<language>[a-z]*)?[\s\n]$/,
    Cs.type(n),
    (e) => ({
      language: e.groups?.language ?? ""
    })
  )
);
K(OO, {
  displayName: "InputRule<createCodeBlockInputRule>",
  group: "CodeBlock"
});
const Ob = Ye(
  "CreateCodeBlock",
  (n) => (e = "") => Lf(Cs.type(n), { language: e })
);
K(Ob, {
  displayName: "Command<createCodeBlockCommand>",
  group: "CodeBlock"
});
const bY = Ye(
  "UpdateCodeBlockLanguage",
  () => ({ pos: n, language: e } = {
    pos: -1,
    language: ""
  }) => (t, r) => n >= 0 ? (r?.(t.tr.setNodeAttribute(n, "language", e)), !0) : !1
);
K(bY, {
  displayName: "Command<updateCodeBlockLanguageCommand>",
  group: "CodeBlock"
});
const Eb = Rr("codeBlockKeymap", {
  CreateCodeBlock: {
    shortcuts: "Mod-Alt-c",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ob.key);
    }
  }
});
K(Eb.ctx, {
  displayName: "KeymapCtx<codeBlock>",
  group: "CodeBlock"
});
K(Eb.shortcuts, {
  displayName: "Keymap<codeBlock>",
  group: "CodeBlock"
});
const Ib = Wi("image");
K(Ib, {
  displayName: "Attr<image>",
  group: "Image"
});
const Ba = hn("image", (n) => ({
  inline: !0,
  group: "inline",
  selectable: !0,
  draggable: !0,
  marks: "",
  atom: !0,
  defining: !0,
  isolating: !0,
  attrs: {
    src: { default: "", validate: "string" },
    alt: { default: "", validate: "string" },
    title: { default: "", validate: "string" }
  },
  parseDOM: [
    {
      tag: "img[src]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw qi(e);
        return {
          src: e.getAttribute("src") || "",
          alt: e.getAttribute("alt") || "",
          title: e.getAttribute("title") || e.getAttribute("alt") || ""
        };
      }
    }
  ],
  toDOM: (e) => ["img", { ...n.get(Ib.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: ({ type: e }) => e === "image",
    runner: (e, t, r) => {
      const i = t.url, s = t.alt, o = t.title;
      e.addNode(r, {
        src: i,
        alt: s,
        title: o
      });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "image",
    runner: (e, t) => {
      e.addNode("image", void 0, void 0, {
        title: t.attrs.title,
        url: t.attrs.src,
        alt: t.attrs.alt
      });
    }
  }
}));
K(Ba.node, {
  displayName: "NodeSchema<image>",
  group: "Image"
});
K(Ba.ctx, {
  displayName: "NodeSchemaCtx<image>",
  group: "Image"
});
const EO = Ye(
  "InsertImage",
  (n) => (e = {}) => (t, r) => {
    if (!r) return !0;
    const { src: i = "", alt: s = "", title: o = "" } = e, l = Ba.type(n).create({ src: i, alt: s, title: o });
    return l && r(t.tr.replaceSelectionWith(l).scrollIntoView()), !0;
  }
);
K(EO, {
  displayName: "Command<insertImageCommand>",
  group: "Image"
});
const IO = Ye(
  "UpdateImage",
  (n) => (e = {}) => (t, r) => {
    const i = vV(
      t.selection,
      Ba.type(n)
    );
    if (!i) return !1;
    const { node: s, pos: o } = i, l = { ...s.attrs }, { src: a, alt: c, title: u } = e;
    return a !== void 0 && (l.src = a), c !== void 0 && (l.alt = c), u !== void 0 && (l.title = u), r?.(
      t.tr.setNodeMarkup(o, void 0, l).scrollIntoView()
    ), !0;
  }
);
K(IO, {
  displayName: "Command<updateImageCommand>",
  group: "Image"
});
const vY = Qn(
  (n) => new Ir(
    /!\[(?<alt>.*?)]\((?<filename>.*?)\s*(?="|\))"?(?<title>[^"]+)?"?\)/,
    (e, t, r, i) => {
      const [s, o, l = "", a] = t;
      return s ? e.tr.replaceWith(
        r,
        i,
        Ba.type(n).create({ src: l, alt: o, title: a })
      ) : null;
    }
  )
);
K(vY, {
  displayName: "InputRule<insertImageInputRule>",
  group: "Image"
});
const Am = Wi("hardbreak", (n) => ({
  "data-type": "hardbreak",
  "data-is-inline": n.attrs.isInline
}));
K(Am, {
  displayName: "Attr<hardbreak>",
  group: "Hardbreak"
});
const da = hn("hardbreak", (n) => ({
  inline: !0,
  group: "inline",
  attrs: {
    isInline: {
      default: !1,
      validate: "boolean"
    }
  },
  selectable: !1,
  parseDOM: [
    { tag: "br" },
    {
      tag: 'span[data-type="hardbreak"]',
      getAttrs: () => ({ isInline: !0 })
    }
  ],
  toDOM: (e) => e.attrs.isInline ? ["span", n.get(Am.key)(e), " "] : ["br", n.get(Am.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "break",
    runner: (e, t, r) => {
      e.addNode(r, {
        isInline: !!t.data?.isInline
      });
    }
  },
  leafText: () => `
`,
  toMarkdown: {
    match: (e) => e.type.name === "hardbreak",
    runner: (e, t) => {
      t.attrs.isInline ? e.addNode("text", void 0, `
`) : e.addNode("break");
    }
  }
}));
K(da.node, {
  displayName: "NodeSchema<hardbreak>",
  group: "Hardbreak"
});
K(da.ctx, {
  displayName: "NodeSchemaCtx<hardbreak>",
  group: "Hardbreak"
});
const Db = Ye(
  "InsertHardbreak",
  (n) => () => (e, t) => {
    const { selection: r, tr: i } = e;
    if (!(r instanceof Ee)) return !1;
    if (r.empty) {
      const s = r.$from.node();
      if (s.childCount > 0 && s.lastChild?.type.name === "hardbreak")
        return t?.(
          i.replaceRangeWith(
            r.to - 1,
            r.to,
            e.schema.node("paragraph")
          ).setSelection(Ge.near(i.doc.resolve(r.to))).scrollIntoView()
        ), !0;
    }
    return t?.(
      i.setMeta("hardbreak", !0).replaceSelectionWith(da.type(n).create()).scrollIntoView()
    ), !0;
  }
);
K(Db, {
  displayName: "Command<insertHardbreakCommand>",
  group: "Hardbreak"
});
const Nb = Rr("hardbreakKeymap", {
  InsertHardbreak: {
    shortcuts: "Shift-Enter",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Db.key);
    }
  }
});
K(Nb.ctx, {
  displayName: "KeymapCtx<hardbreak>",
  group: "Hardbreak"
});
K(Nb.shortcuts, {
  displayName: "Keymap<hardbreak>",
  group: "Hardbreak"
});
const Rb = Wi("hr");
K(Rb, {
  displayName: "Attr<hr>",
  group: "Hr"
});
const au = hn("hr", (n) => ({
  group: "block",
  parseDOM: [{ tag: "hr" }],
  toDOM: (e) => ["hr", n.get(Rb.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "thematicBreak",
    runner: (e, t, r) => {
      e.addNode(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "hr",
    runner: (e) => {
      e.addNode("thematicBreak");
    }
  }
}));
K(au.node, {
  displayName: "NodeSchema<hr>",
  group: "Hr"
});
K(au.ctx, {
  displayName: "NodeSchemaCtx<hr>",
  group: "Hr"
});
const DO = Qn(
  (n) => new Ir(/^(?:---|___\s|\*\*\*\s)$/, (e, t, r, i) => {
    const { tr: s } = e;
    return t[0] && s.replaceWith(r - 1, i, au.type(n).create()), s;
  })
);
K(DO, {
  displayName: "InputRule<insertHrInputRule>",
  group: "Hr"
});
const NO = Ye(
  "InsertHr",
  (n) => () => (e, t) => {
    if (!t) return !0;
    const r = Os.node.type(n).create(), { tr: i, selection: s } = e, { from: o } = s, l = au.type(n).create();
    if (!l) return !0;
    const a = i.replaceSelectionWith(l).insert(o, r), c = Ge.findFrom(a.doc.resolve(o), 1, !0);
    return c && t(a.setSelection(c).scrollIntoView()), !0;
  }
);
K(NO, {
  displayName: "Command<insertHrCommand>",
  group: "Hr"
});
const Pb = Wi("bulletList");
K(Pb, {
  displayName: "Attr<bulletList>",
  group: "BulletList"
});
const za = hn("bullet_list", (n) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    spread: {
      default: !1,
      validate: "boolean"
    }
  },
  parseDOM: [
    {
      tag: "ul",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw qi(e);
        return {
          spread: e.dataset.spread === "true"
        };
      }
    }
  ],
  toDOM: (e) => [
    "ul",
    {
      ...n.get(Pb.key)(e),
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: t }) => e === "list" && !t,
    runner: (e, t, r) => {
      const i = t.spread != null ? `${t.spread}` : "false";
      e.openNode(r, { spread: i }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "bullet_list",
    runner: (e, t) => {
      e.openNode("list", void 0, {
        ordered: !1,
        spread: t.attrs.spread
      }).next(t.content).closeNode();
    }
  }
}));
K(za.node, {
  displayName: "NodeSchema<bulletList>",
  group: "BulletList"
});
K(za.ctx, {
  displayName: "NodeSchemaCtx<bulletList>",
  group: "BulletList"
});
const RO = Qn(
  (n) => D3(/^\s*([-+*])\s$/, za.type(n))
);
K(RO, {
  displayName: "InputRule<wrapInBulletListInputRule>",
  group: "BulletList"
});
const _b = Ye(
  "WrapInBulletList",
  (n) => () => K3(za.type(n))
);
K(_b, {
  displayName: "Command<wrapInBulletListCommand>",
  group: "BulletList"
});
const Lb = Rr("bulletListKeymap", {
  WrapInBulletList: {
    shortcuts: "Mod-Alt-8",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(_b.key);
    }
  }
});
K(Lb.ctx, {
  displayName: "KeymapCtx<bulletListKeymap>",
  group: "BulletList"
});
K(Lb.shortcuts, {
  displayName: "Keymap<bulletListKeymap>",
  group: "BulletList"
});
const Bb = Wi("orderedList");
K(Bb, {
  displayName: "Attr<orderedList>",
  group: "OrderedList"
});
const Fa = hn("ordered_list", (n) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    order: {
      default: 1,
      validate: "number"
    },
    spread: {
      default: !1,
      validate: "boolean"
    }
  },
  parseDOM: [
    {
      tag: "ol",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw qi(e);
        return {
          spread: e.dataset.spread,
          order: e.hasAttribute("start") ? Number(e.getAttribute("start")) : 1
        };
      }
    }
  ],
  toDOM: (e) => [
    "ol",
    {
      ...n.get(Bb.key)(e),
      ...e.attrs.order === 1 ? {} : e.attrs.order,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: t }) => e === "list" && !!t,
    runner: (e, t, r) => {
      const i = t.spread != null ? `${t.spread}` : "true";
      e.openNode(r, { spread: i }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "ordered_list",
    runner: (e, t) => {
      e.openNode("list", void 0, {
        ordered: !0,
        start: 1,
        spread: t.attrs.spread === "true"
      }), e.next(t.content), e.closeNode();
    }
  }
}));
K(Fa.node, {
  displayName: "NodeSchema<orderedList>",
  group: "OrderedList"
});
K(Fa.ctx, {
  displayName: "NodeSchemaCtx<orderedList>",
  group: "OrderedList"
});
const PO = Qn(
  (n) => D3(
    /^\s*(\d+)\.\s$/,
    Fa.type(n),
    (e) => ({ order: Number(e[1]) }),
    (e, t) => t.childCount + t.attrs.order === Number(e[1])
  )
);
K(PO, {
  displayName: "InputRule<wrapInOrderedListInputRule>",
  group: "OrderedList"
});
const zb = Ye(
  "WrapInOrderedList",
  (n) => () => K3(Fa.type(n))
);
K(zb, {
  displayName: "Command<wrapInOrderedListCommand>",
  group: "OrderedList"
});
const Fb = Rr("orderedListKeymap", {
  WrapInOrderedList: {
    shortcuts: "Mod-Alt-7",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(zb.key);
    }
  }
});
K(Fb.ctx, {
  displayName: "KeymapCtx<orderedList>",
  group: "OrderedList"
});
K(Fb.shortcuts, {
  displayName: "Keymap<orderedList>",
  group: "OrderedList"
});
const Hb = Wi("listItem");
K(Hb, {
  displayName: "Attr<listItem>",
  group: "ListItem"
});
const ji = hn("list_item", (n) => ({
  group: "listItem",
  content: "paragraph block*",
  attrs: {
    label: {
      default: "•",
      validate: "string"
    },
    listType: {
      default: "bullet",
      validate: "string"
    },
    spread: {
      default: !0,
      validate: "boolean"
    }
  },
  defining: !0,
  parseDOM: [
    {
      tag: "li",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw qi(e);
        return {
          label: e.dataset.label,
          listType: e.dataset.listType,
          spread: e.dataset.spread === "true"
        };
      }
    }
  ],
  toDOM: (e) => [
    "li",
    {
      ...n.get(Hb.key)(e),
      "data-label": e.attrs.label,
      "data-list-type": e.attrs.listType,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "listItem",
    runner: (e, t, r) => {
      const i = t.label != null ? `${t.label}.` : "•", s = t.label != null ? "ordered" : "bullet", o = t.spread != null ? `${t.spread}` : "true";
      e.openNode(r, { label: i, listType: s, spread: o }), e.next(t.children), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "list_item",
    runner: (e, t) => {
      e.openNode("listItem", void 0, {
        spread: t.attrs.spread
      }), e.next(t.content), e.closeNode();
    }
  }
}));
K(ji.node, {
  displayName: "NodeSchema<listItem>",
  group: "ListItem"
});
K(ji.ctx, {
  displayName: "NodeSchemaCtx<listItem>",
  group: "ListItem"
});
const $b = Ye(
  "SinkListItem",
  (n) => () => hY(ji.type(n))
);
K($b, {
  displayName: "Command<sinkListItemCommand>",
  group: "ListItem"
});
const Vb = Ye(
  "LiftListItem",
  (n) => () => aY(ji.type(n))
);
K(Vb, {
  displayName: "Command<liftListItemCommand>",
  group: "ListItem"
});
const qb = Ye(
  "SplitListItem",
  (n) => () => lY(ji.type(n))
);
K(qb, {
  displayName: "Command<splitListItemCommand>",
  group: "ListItem"
});
function wY(n) {
  return (e, t, r) => {
    const { selection: i } = e;
    if (!(i instanceof Ee)) return !1;
    const { empty: s, $from: o } = i;
    return !s || o.parentOffset !== 0 || o.node(-1).type !== ji.type(n) ? !1 : oA(e, t, r);
  };
}
const Wb = Ye(
  "LiftFirstListItem",
  (n) => () => wY(n)
);
K(Wb, {
  displayName: "Command<liftFirstListItemCommand>",
  group: "ListItem"
});
const jb = Rr("listItemKeymap", {
  NextListItem: {
    shortcuts: "Enter",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(qb.key);
    }
  },
  SinkListItem: {
    shortcuts: ["Tab", "Mod-]"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call($b.key);
    }
  },
  LiftListItem: {
    shortcuts: ["Shift-Tab", "Mod-["],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Vb.key);
    }
  },
  LiftFirstListItem: {
    shortcuts: ["Backspace", "Delete"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Wb.key);
    }
  }
});
K(jb.ctx, {
  displayName: "KeymapCtx<listItem>",
  group: "ListItem"
});
K(jb.shortcuts, {
  displayName: "Keymap<listItem>",
  group: "ListItem"
});
const _O = ob("text", () => ({
  group: "inline",
  parseMarkdown: {
    match: ({ type: n }) => n === "text",
    runner: (n, e) => {
      n.addText(e.value);
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "text",
    runner: (n, e) => {
      n.addNode("text", void 0, e.text);
    }
  }
}));
K(_O, {
  displayName: "NodeSchema<text>",
  group: "Text"
});
const Ub = Wi("html");
K(Ub, {
  displayName: "Attr<html>",
  group: "Html"
});
const Kb = hn("html", (n) => ({
  atom: !0,
  group: "inline",
  inline: !0,
  attrs: {
    value: {
      default: "",
      validate: "string"
    }
  },
  toDOM: (e) => {
    const t = document.createElement("span"), r = {
      ...n.get(Ub.key)(e),
      "data-value": e.attrs.value,
      "data-type": "html"
    };
    return t.textContent = e.attrs.value, ["span", r, e.attrs.value];
  },
  parseDOM: [
    {
      tag: 'span[data-type="html"]',
      getAttrs: (e) => ({
        value: e.dataset.value ?? ""
      })
    }
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "html",
    runner: (e, t, r) => {
      e.addNode(r, { value: t.value });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "html",
    runner: (e, t) => {
      e.addNode("html", void 0, t.attrs.value);
    }
  }
}));
K(Kb.node, {
  displayName: "NodeSchema<html>",
  group: "Html"
});
K(Kb.ctx, {
  displayName: "NodeSchemaCtx<html>",
  group: "Html"
});
const xY = [
  MO,
  bb,
  Os,
  $1,
  xb,
  jr,
  Am,
  da,
  Cb,
  lu,
  Ab,
  Cs,
  Rb,
  au,
  Ib,
  Ba,
  Pb,
  za,
  Bb,
  Fa,
  Hb,
  ji,
  hb,
  La,
  db,
  ou,
  mb,
  eo,
  yb,
  Pi,
  Ub,
  Kb,
  _O
].flat(), kY = [
  AO,
  RO,
  PO,
  OO,
  DO,
  TO
].flat(), SY = [
  vO,
  wO,
  kO,
  xO
], ic = Ye(
  "IsMarkSelected",
  () => (n) => (e) => {
    if (!n) return !1;
    const { doc: t, selection: r } = e;
    return t.rangeHasMark(r.from, r.to, n);
  }
), LO = Ye(
  "IsNoteSelected",
  () => (n) => (e) => n ? ST(e, n).hasNode : !1
), Dn = Ye(
  "ClearTextInCurrentBlock",
  () => () => (n, e) => {
    let t = n.tr;
    const { $from: r, $to: i } = t.selection, { pos: s } = r, { pos: o } = i, l = s - r.node().content.size;
    return l < 0 ? !1 : (t = t.deleteRange(l, o), e?.(t), !0);
  }
), Vs = Ye(
  "SetBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    const s = e.tr, { from: o, to: l } = s.selection;
    try {
      s.setBlockType(o, l, r, i);
    } catch {
      return !1;
    }
    return t?.(s), !0;
  }
), ph = Ye(
  "WrapInBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    let s = e.tr;
    try {
      const { $from: o, $to: l } = s.selection, a = o.blockRange(l), c = a && E3(a, r, i);
      if (!c) return !1;
      s = s.wrap(a, c);
    } catch {
      return !1;
    }
    return t?.(s), !0;
  }
), mh = Ye(
  "AddBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    const s = e.tr;
    try {
      const o = r instanceof ro ? r : r.createAndFill(i);
      if (!o) return !1;
      s.replaceSelectionWith(o);
    } catch {
      return !1;
    }
    return t?.(s), !0;
  }
), BO = Ye(
  "SelectTextNearPos",
  () => (n) => (e, t) => {
    const { pos: r } = n ?? {};
    if (r == null) return !1;
    const i = (o, l, a) => Math.min(Math.max(o, l), a), s = e.tr;
    try {
      const o = e.doc.resolve(i(r, 0, e.doc.content.size));
      s.setSelection(Ee.near(o));
    } catch {
      return !1;
    }
    return t?.(s.scrollIntoView()), !0;
  }
), CY = [
  vb,
  Mb,
  $o,
  kb,
  Ob,
  Db,
  NO,
  EO,
  IO,
  zb,
  _b,
  $b,
  qb,
  Vb,
  Wb,
  B1,
  F1,
  z1,
  SO,
  CO,
  ic,
  LO,
  Dn,
  Vs,
  ph,
  mh,
  BO
], MY = [
  Tb,
  Eb,
  Nb,
  Sb,
  jb,
  Fb,
  Lb,
  wb,
  fb,
  gb,
  pb
].flat(), Gb = As(
  "remarkAddOrderInList",
  () => () => (n) => {
    Tl(n, "list", (e) => {
      if (e.ordered) {
        const t = e.start ?? 1;
        e.children.forEach((r, i) => {
          r.label = i + t;
        });
      }
    });
  }
);
K(Gb.plugin, {
  displayName: "Remark<remarkAddOrderInListPlugin>",
  group: "Remark"
});
K(Gb.options, {
  displayName: "RemarkConfig<remarkAddOrderInListPlugin>",
  group: "Remark"
});
const Yb = As(
  "remarkLineBreak",
  () => () => (n) => {
    const e = /[\t ]*(?:\r?\n|\r)/g;
    Tl(
      n,
      "text",
      (t, r, i) => {
        if (!t.value || typeof t.value != "string") return;
        const s = [];
        let o = 0;
        e.lastIndex = 0;
        let l = e.exec(t.value);
        for (; l; ) {
          const c = l.index;
          o !== c && s.push({
            type: "text",
            value: t.value.slice(o, c)
          }), s.push({ type: "break", data: { isInline: !0 } }), o = c + l[0].length, l = e.exec(t.value);
        }
        if (s.length > 0 && i && typeof r == "number")
          return o < t.value.length && s.push({ type: "text", value: t.value.slice(o) }), i.children.splice(r, 1, ...s), r + s.length;
      }
    );
  }
);
K(Yb.plugin, {
  displayName: "Remark<remarkLineBreak>",
  group: "Remark"
});
K(Yb.options, {
  displayName: "RemarkConfig<remarkLineBreak>",
  group: "Remark"
});
const Jb = As(
  "remarkInlineLink",
  () => dY
);
K(Jb.plugin, {
  displayName: "Remark<remarkInlineLinkPlugin>",
  group: "Remark"
});
K(Jb.options, {
  displayName: "RemarkConfig<remarkInlineLinkPlugin>",
  group: "Remark"
});
const TY = (n) => !!n.children, AY = (n) => n.type === "html";
function OY(n, e) {
  return t(n, 0, null)[0];
  function t(r, i, s) {
    if (TY(r)) {
      const o = [];
      for (let l = 0, a = r.children.length; l < a; l++) {
        const c = r.children[l];
        if (c) {
          const u = t(c, l, r);
          if (u)
            for (let h = 0, f = u.length; h < f; h++) {
              const d = u[h];
              d && o.push(d);
            }
        }
      }
      r.children = o;
    }
    return e(r, i, s);
  }
}
const EY = ["root", "blockquote", "listItem"], Xb = As(
  "remarkHTMLTransformer",
  () => () => (n) => {
    OY(n, (e, t, r) => AY(e) ? (r && EY.includes(r.type) && (e.children = [{ ...e }], delete e.value, e.type = "paragraph"), [e]) : [e]);
  }
);
K(Xb.plugin, {
  displayName: "Remark<remarkHtmlTransformer>",
  group: "Remark"
});
K(Xb.options, {
  displayName: "RemarkConfig<remarkHtmlTransformer>",
  group: "Remark"
});
const Zb = As(
  "remarkMarker",
  () => () => (n, e) => {
    const t = (r) => e.value.charAt(r.position.start.offset);
    Tl(
      n,
      (r) => ["strong", "emphasis"].includes(r.type),
      (r) => {
        r.marker = t(r);
      }
    );
  }
);
K(Zb.plugin, {
  displayName: "Remark<remarkMarker>",
  group: "Remark"
});
K(Zb.options, {
  displayName: "RemarkConfig<remarkMarker>",
  group: "Remark"
});
const zO = kn(() => {
  let n = !1;
  const e = new en(
    "MILKDOWN_INLINE_NODES_CURSOR"
  ), t = new Ut({
    key: e,
    state: {
      init() {
        return !1;
      },
      apply(r) {
        if (!r.selection.empty) return !1;
        const i = r.selection.$from, s = i.nodeBefore, o = i.nodeAfter;
        return !!(s && o && s.isInline && !s.isText && o.isInline && !o.isText);
      }
    },
    props: {
      handleDOMEvents: {
        compositionend: (r, i) => n ? (n = !1, requestAnimationFrame(() => {
          if (t.getState(r.state)) {
            const o = r.state.selection.from;
            i.preventDefault(), r.dispatch(r.state.tr.insertText(i.data || "", o));
          }
        }), !0) : !1,
        compositionstart: (r) => (t.getState(r.state) && (n = !0), !1),
        beforeinput: (r, i) => {
          if (t.getState(r.state) && i instanceof InputEvent && i.data && !n) {
            const o = r.state.selection.from;
            return i.preventDefault(), r.dispatch(r.state.tr.insertText(i.data || "", o)), !0;
          }
          return !1;
        }
      },
      decorations(r) {
        if (t.getState(r)) {
          const o = r.selection.$from.pos, l = document.createElement("span"), a = mn.widget(o, l, {
            side: -1
          }), c = document.createElement("span"), u = mn.widget(o, c);
          return setTimeout(() => {
            l.contentEditable = "true", c.contentEditable = "true";
          }), Et.create(r.doc, [a, u]);
        }
        return Et.empty;
      }
    }
  });
  return t;
});
K(zO, {
  displayName: "Prose<inlineNodesCursorPlugin>",
  group: "Prose"
});
const FO = kn((n) => new Ut({
  key: new en("MILKDOWN_HARDBREAK_MARKS"),
  appendTransaction: (e, t, r) => {
    if (!e.length) return;
    const [i] = e;
    if (!i) return;
    const [s] = i.steps;
    if (i.getMeta("hardbreak")) {
      if (!(s instanceof Cn)) return;
      const { from: a } = s;
      return r.tr.setNodeMarkup(
        a,
        da.type(n),
        void 0,
        []
      );
    }
    if (s instanceof Zs) {
      let a = r.tr;
      const { from: c, to: u } = s;
      return r.doc.nodesBetween(c, u, (h, f) => {
        h.type === da.type(n) && (a = a.setNodeMarkup(
          f,
          da.type(n),
          void 0,
          []
        ));
      }), a;
    }
  }
}));
K(FO, {
  displayName: "Prose<hardbreakClearMarkPlugin>",
  group: "Prose"
});
const Qb = Ct(
  ["table", "code_block"],
  "hardbreakFilterNodes"
);
K(Qb, {
  displayName: "Ctx<hardbreakFilterNodes>",
  group: "Prose"
});
const HO = kn((n) => {
  const e = n.get(Qb.key);
  return new Ut({
    key: new en("MILKDOWN_HARDBREAK_FILTER"),
    filterTransaction: (t, r) => {
      const i = t.getMeta("hardbreak"), [s] = t.steps;
      if (i && s) {
        const { from: o } = s, l = r.doc.resolve(o);
        let a = l.depth, c = !0;
        for (; a > 0; )
          e.includes(l.node(a).type.name) && (c = !1), a--;
        return c;
      }
      return !0;
    }
  });
});
K(HO, {
  displayName: "Prose<hardbreakFilterPlugin>",
  group: "Prose"
});
const $O = kn((n) => {
  const e = new en("MILKDOWN_HEADING_ID"), t = (r) => {
    if (r.composing) return;
    const i = n.get($1.key), s = r.state.tr.setMeta("addToHistory", !1);
    let o = !1;
    const l = {};
    r.state.doc.descendants((a, c) => {
      if (a.type === jr.type(n)) {
        if (a.textContent.trim().length === 0) return;
        const u = a.attrs;
        let h = i(a);
        l[h] ? (l[h] += 1, h += `-#${l[h]}`) : l[h] = 1, u.id !== h && (o = !0, s.setMeta(e, !0).setNodeMarkup(c, void 0, {
          ...u,
          id: h
        }));
      }
    }), o && r.dispatch(s);
  };
  return new Ut({
    key: e,
    view: (r) => (t(r), {
      update: (i, s) => {
        i.state.doc.eq(s.doc) || t(i);
      }
    })
  });
});
K($O, {
  displayName: "Prose<syncHeadingIdPlugin>",
  group: "Prose"
});
const VO = kn((n) => {
  const e = (t, r, i) => {
    if (!i.selection || t.some(
      (h) => h.getMeta("addToHistory") === !1 || !h.isGeneric
    ))
      return null;
    const s = Fa.type(n), o = za.type(n), l = ji.type(n), a = (h, f) => {
      let d = !1;
      const p = `${f + 1}.`;
      return h.label !== p && (h.label = p, d = !0), d;
    };
    let c = i.tr, u = !1;
    return i.doc.descendants(
      (h, f, d, p) => {
        if (h.type === o) {
          const m = h.maybeChild(0);
          m?.type === l && m.attrs.listType === "ordered" && (u = !0, c.setNodeMarkup(f, s, { spread: "true" }), h.descendants(
            (g, b, w, k) => {
              if (g.type === l) {
                const C = { ...g.attrs };
                a(C, k) && (c = c.setNodeMarkup(b, void 0, C));
              }
              return !1;
            }
          ));
        } else if (h.type === l && d?.type === s) {
          const m = { ...h.attrs };
          let g = !1;
          m.listType !== "ordered" && (m.listType = "ordered", g = !0), d?.maybeChild(0) && (g = a(m, p)), g && (c = c.setNodeMarkup(f, void 0, m), u = !0);
        }
      }
    ), u ? c.setMeta("addToHistory", !1) : null;
  };
  return new Ut({
    key: new en("MILKDOWN_KEEP_LIST_ORDER"),
    appendTransaction: e
  });
});
K(VO, {
  displayName: "Prose<syncListOrderPlugin>",
  group: "Prose"
});
const IY = [
  FO,
  Qb,
  HO,
  zO,
  Gb,
  Jb,
  Yb,
  Xb,
  Zb,
  H1,
  $O,
  VO
].flat(), DY = [
  xY,
  kY,
  SY,
  CY,
  MY,
  IY
].flat();
/**
* @vue/shared v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function ev(n) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const t of n.split(",")) e[t] = 1;
  return (t) => t in e;
}
const Lt = {}, nf = [], _i = () => {
}, NY = () => !1, V1 = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // uppercase letter
(n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97), tv = (n) => n.startsWith("onUpdate:"), Xn = Object.assign, nv = (n, e) => {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}, RY = Object.prototype.hasOwnProperty, bt = (n, e) => RY.call(n, e), Ze = Array.isArray, rf = (n) => q1(n) === "[object Map]", PY = (n) => q1(n) === "[object Set]", tt = (n) => typeof n == "function", An = (n) => typeof n == "string", cu = (n) => typeof n == "symbol", un = (n) => n !== null && typeof n == "object", qO = (n) => (un(n) || tt(n)) && tt(n.then) && tt(n.catch), _Y = Object.prototype.toString, q1 = (n) => _Y.call(n), LY = (n) => q1(n).slice(8, -1), BY = (n) => q1(n) === "[object Object]", rv = (n) => An(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n, sf = /* @__PURE__ */ ev(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), W1 = (n) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = n(t));
}, zY = /-(\w)/g, bl = W1(
  (n) => n.replace(zY, (e, t) => t ? t.toUpperCase() : "")
), FY = /\B([A-Z])/g, Ha = W1(
  (n) => n.replace(FY, "-$1").toLowerCase()
), WO = W1((n) => n.charAt(0).toUpperCase() + n.slice(1)), E2 = W1(
  (n) => n ? `on${WO(n)}` : ""
), ll = (n, e) => !Object.is(n, e), I2 = (n, ...e) => {
  for (let t = 0; t < n.length; t++)
    n[t](...e);
}, jf = (n, e, t, r = !1) => {
  Object.defineProperty(n, e, {
    configurable: !0,
    enumerable: !1,
    writable: r,
    value: t
  });
}, HY = (n) => {
  const e = parseFloat(n);
  return isNaN(e) ? n : e;
};
let S8;
const pa = () => S8 || (S8 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function iv(n) {
  if (Ze(n)) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
      const r = n[t], i = An(r) ? WY(r) : iv(r);
      if (i)
        for (const s in i)
          e[s] = i[s];
    }
    return e;
  } else if (An(n) || un(n))
    return n;
}
const $Y = /;(?![^(]*\))/g, VY = /:([^]+)/, qY = /\/\*[^]*?\*\//g;
function WY(n) {
  const e = {};
  return n.replace(qY, "").split($Y).forEach((t) => {
    if (t) {
      const r = t.split(VY);
      r.length > 1 && (e[r[0].trim()] = r[1].trim());
    }
  }), e;
}
function sv(n) {
  let e = "";
  if (An(n))
    e = n;
  else if (Ze(n))
    for (let t = 0; t < n.length; t++) {
      const r = sv(n[t]);
      r && (e += r + " ");
    }
  else if (un(n))
    for (const t in n)
      n[t] && (e += t + " ");
  return e.trim();
}
const jY = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", UY = /* @__PURE__ */ ev(jY);
function jO(n) {
  return !!n || n === "";
}
/**
* @vue/reactivity v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let wr;
class KY {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = wr, !e && wr && (this.index = (wr.scopes || (wr.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, t;
      if (this.scopes)
        for (e = 0, t = this.scopes.length; e < t; e++)
          this.scopes[e].pause();
      for (e = 0, t = this.effects.length; e < t; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, t;
      if (this.scopes)
        for (e = 0, t = this.scopes.length; e < t; e++)
          this.scopes[e].resume();
      for (e = 0, t = this.effects.length; e < t; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const t = wr;
      try {
        return wr = this, e();
      } finally {
        wr = t;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = wr, wr = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (wr = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let t, r;
      for (t = 0, r = this.effects.length; t < r; t++)
        this.effects[t].stop();
      for (this.effects.length = 0, t = 0, r = this.cleanups.length; t < r; t++)
        this.cleanups[t]();
      if (this.cleanups.length = 0, this.scopes) {
        for (t = 0, r = this.scopes.length; t < r; t++)
          this.scopes[t].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function GY() {
  return wr;
}
let _t;
const D2 = /* @__PURE__ */ new WeakSet();
class UO {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, wr && wr.active && wr.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, D2.has(this) && (D2.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || GO(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, C8(this), YO(this);
    const e = _t, t = Li;
    _t = this, Li = !0;
    try {
      return this.fn();
    } finally {
      JO(this), _t = e, Li = t, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        av(e);
      this.deps = this.depsTail = void 0, C8(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? D2.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    r5(this) && this.run();
  }
  get dirty() {
    return r5(this);
  }
}
let KO = 0, of, lf;
function GO(n, e = !1) {
  if (n.flags |= 8, e) {
    n.next = lf, lf = n;
    return;
  }
  n.next = of, of = n;
}
function ov() {
  KO++;
}
function lv() {
  if (--KO > 0)
    return;
  if (lf) {
    let e = lf;
    for (lf = void 0; e; ) {
      const t = e.next;
      e.next = void 0, e.flags &= -9, e = t;
    }
  }
  let n;
  for (; of; ) {
    let e = of;
    for (of = void 0; e; ) {
      const t = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (r) {
          n || (n = r);
        }
      e = t;
    }
  }
  if (n) throw n;
}
function YO(n) {
  for (let e = n.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function JO(n) {
  let e, t = n.depsTail, r = t;
  for (; r; ) {
    const i = r.prevDep;
    r.version === -1 ? (r === t && (t = i), av(r), YY(r)) : e = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = i;
  }
  n.deps = e, n.depsTail = t;
}
function r5(n) {
  for (let e = n.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (XO(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!n._dirty;
}
function XO(n) {
  if (n.flags & 4 && !(n.flags & 16) || (n.flags &= -17, n.globalVersion === Uf) || (n.globalVersion = Uf, !n.isSSR && n.flags & 128 && (!n.deps && !n._dirty || !r5(n))))
    return;
  n.flags |= 2;
  const e = n.dep, t = _t, r = Li;
  _t = n, Li = !0;
  try {
    YO(n);
    const i = n.fn(n._value);
    (e.version === 0 || ll(i, n._value)) && (n.flags |= 128, n._value = i, e.version++);
  } catch (i) {
    throw e.version++, i;
  } finally {
    _t = t, Li = r, JO(n), n.flags &= -3;
  }
}
function av(n, e = !1) {
  const { dep: t, prevSub: r, nextSub: i } = n;
  if (r && (r.nextSub = i, n.prevSub = void 0), i && (i.prevSub = r, n.nextSub = void 0), t.subs === n && (t.subs = r, !r && t.computed)) {
    t.computed.flags &= -5;
    for (let s = t.computed.deps; s; s = s.nextDep)
      av(s, !0);
  }
  !e && !--t.sc && t.map && t.map.delete(t.key);
}
function YY(n) {
  const { prevDep: e, nextDep: t } = n;
  e && (e.nextDep = t, n.prevDep = void 0), t && (t.prevDep = e, n.nextDep = void 0);
}
let Li = !0;
const ZO = [];
function fo() {
  ZO.push(Li), Li = !1;
}
function po() {
  const n = ZO.pop();
  Li = n === void 0 ? !0 : n;
}
function C8(n) {
  const { cleanup: e } = n;
  if (n.cleanup = void 0, e) {
    const t = _t;
    _t = void 0;
    try {
      e();
    } finally {
      _t = t;
    }
  }
}
let Uf = 0;
class JY {
  constructor(e, t) {
    this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class cv {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(e) {
    if (!_t || !Li || _t === this.computed)
      return;
    let t = this.activeLink;
    if (t === void 0 || t.sub !== _t)
      t = this.activeLink = new JY(_t, this), _t.deps ? (t.prevDep = _t.depsTail, _t.depsTail.nextDep = t, _t.depsTail = t) : _t.deps = _t.depsTail = t, QO(t);
    else if (t.version === -1 && (t.version = this.version, t.nextDep)) {
      const r = t.nextDep;
      r.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = r), t.prevDep = _t.depsTail, t.nextDep = void 0, _t.depsTail.nextDep = t, _t.depsTail = t, _t.deps === t && (_t.deps = r);
    }
    return t;
  }
  trigger(e) {
    this.version++, Uf++, this.notify(e);
  }
  notify(e) {
    ov();
    try {
      for (let t = this.subs; t; t = t.prevSub)
        t.sub.notify() && t.sub.dep.notify();
    } finally {
      lv();
    }
  }
}
function QO(n) {
  if (n.dep.sc++, n.sub.flags & 4) {
    const e = n.dep.computed;
    if (e && !n.dep.subs) {
      e.flags |= 20;
      for (let r = e.deps; r; r = r.nextDep)
        QO(r);
    }
    const t = n.dep.subs;
    t !== n && (n.prevSub = t, t && (t.nextSub = n)), n.dep.subs = n;
  }
}
const i5 = /* @__PURE__ */ new WeakMap(), ma = Symbol(
  ""
), s5 = Symbol(
  ""
), Kf = Symbol(
  ""
);
function jn(n, e, t) {
  if (Li && _t) {
    let r = i5.get(n);
    r || i5.set(n, r = /* @__PURE__ */ new Map());
    let i = r.get(t);
    i || (r.set(t, i = new cv()), i.map = r, i.key = t), i.track();
  }
}
function Xs(n, e, t, r, i, s) {
  const o = i5.get(n);
  if (!o) {
    Uf++;
    return;
  }
  const l = (a) => {
    a && a.trigger();
  };
  if (ov(), e === "clear")
    o.forEach(l);
  else {
    const a = Ze(n), c = a && rv(t);
    if (a && t === "length") {
      const u = Number(r);
      o.forEach((h, f) => {
        (f === "length" || f === Kf || !cu(f) && f >= u) && l(h);
      });
    } else
      switch ((t !== void 0 || o.has(void 0)) && l(o.get(t)), c && l(o.get(Kf)), e) {
        case "add":
          a ? c && l(o.get("length")) : (l(o.get(ma)), rf(n) && l(o.get(s5)));
          break;
        case "delete":
          a || (l(o.get(ma)), rf(n) && l(o.get(s5)));
          break;
        case "set":
          rf(n) && l(o.get(ma));
          break;
      }
  }
  lv();
}
function Xa(n) {
  const e = yt(n);
  return e === n ? e : (jn(e, "iterate", Kf), Bi(n) ? e : e.map(sr));
}
function uv(n) {
  return jn(n = yt(n), "iterate", Kf), n;
}
const XY = {
  __proto__: null,
  [Symbol.iterator]() {
    return N2(this, Symbol.iterator, sr);
  },
  concat(...n) {
    return Xa(this).concat(
      ...n.map((e) => Ze(e) ? Xa(e) : e)
    );
  },
  entries() {
    return N2(this, "entries", (n) => (n[1] = sr(n[1]), n));
  },
  every(n, e) {
    return zs(this, "every", n, e, void 0, arguments);
  },
  filter(n, e) {
    return zs(this, "filter", n, e, (t) => t.map(sr), arguments);
  },
  find(n, e) {
    return zs(this, "find", n, e, sr, arguments);
  },
  findIndex(n, e) {
    return zs(this, "findIndex", n, e, void 0, arguments);
  },
  findLast(n, e) {
    return zs(this, "findLast", n, e, sr, arguments);
  },
  findLastIndex(n, e) {
    return zs(this, "findLastIndex", n, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(n, e) {
    return zs(this, "forEach", n, e, void 0, arguments);
  },
  includes(...n) {
    return R2(this, "includes", n);
  },
  indexOf(...n) {
    return R2(this, "indexOf", n);
  },
  join(n) {
    return Xa(this).join(n);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...n) {
    return R2(this, "lastIndexOf", n);
  },
  map(n, e) {
    return zs(this, "map", n, e, void 0, arguments);
  },
  pop() {
    return $u(this, "pop");
  },
  push(...n) {
    return $u(this, "push", n);
  },
  reduce(n, ...e) {
    return M8(this, "reduce", n, e);
  },
  reduceRight(n, ...e) {
    return M8(this, "reduceRight", n, e);
  },
  shift() {
    return $u(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(n, e) {
    return zs(this, "some", n, e, void 0, arguments);
  },
  splice(...n) {
    return $u(this, "splice", n);
  },
  toReversed() {
    return Xa(this).toReversed();
  },
  toSorted(n) {
    return Xa(this).toSorted(n);
  },
  toSpliced(...n) {
    return Xa(this).toSpliced(...n);
  },
  unshift(...n) {
    return $u(this, "unshift", n);
  },
  values() {
    return N2(this, "values", sr);
  }
};
function N2(n, e, t) {
  const r = uv(n), i = r[e]();
  return r !== n && !Bi(n) && (i._next = i.next, i.next = () => {
    const s = i._next();
    return s.value && (s.value = t(s.value)), s;
  }), i;
}
const ZY = Array.prototype;
function zs(n, e, t, r, i, s) {
  const o = uv(n), l = o !== n && !Bi(n), a = o[e];
  if (a !== ZY[e]) {
    const h = a.apply(n, s);
    return l ? sr(h) : h;
  }
  let c = t;
  o !== n && (l ? c = function(h, f) {
    return t.call(this, sr(h), f, n);
  } : t.length > 2 && (c = function(h, f) {
    return t.call(this, h, f, n);
  }));
  const u = a.call(o, c, r);
  return l && i ? i(u) : u;
}
function M8(n, e, t, r) {
  const i = uv(n);
  let s = t;
  return i !== n && (Bi(n) ? t.length > 3 && (s = function(o, l, a) {
    return t.call(this, o, l, a, n);
  }) : s = function(o, l, a) {
    return t.call(this, o, sr(l), a, n);
  }), i[e](s, ...r);
}
function R2(n, e, t) {
  const r = yt(n);
  jn(r, "iterate", Kf);
  const i = r[e](...t);
  return (i === -1 || i === !1) && pv(t[0]) ? (t[0] = yt(t[0]), r[e](...t)) : i;
}
function $u(n, e, t = []) {
  fo(), ov();
  const r = yt(n)[e].apply(n, t);
  return lv(), po(), r;
}
const QY = /* @__PURE__ */ ev("__proto__,__v_isRef,__isVue"), eE = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((n) => n !== "arguments" && n !== "caller").map((n) => Symbol[n]).filter(cu)
);
function eJ(n) {
  cu(n) || (n = String(n));
  const e = yt(this);
  return jn(e, "has", n), e.hasOwnProperty(n);
}
class tE {
  constructor(e = !1, t = !1) {
    this._isReadonly = e, this._isShallow = t;
  }
  get(e, t, r) {
    if (t === "__v_skip") return e.__v_skip;
    const i = this._isReadonly, s = this._isShallow;
    if (t === "__v_isReactive")
      return !i;
    if (t === "__v_isReadonly")
      return i;
    if (t === "__v_isShallow")
      return s;
    if (t === "__v_raw")
      return r === (i ? s ? uJ : sE : s ? iE : rE).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(r) ? e : void 0;
    const o = Ze(e);
    if (!i) {
      let a;
      if (o && (a = XY[t]))
        return a;
      if (t === "hasOwnProperty")
        return eJ;
    }
    const l = Reflect.get(
      e,
      t,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Jn(e) ? e : r
    );
    return (cu(t) ? eE.has(t) : QY(t)) || (i || jn(e, "get", t), s) ? l : Jn(l) ? o && rv(t) ? l : l.value : un(l) ? i ? oE(l) : fv(l) : l;
  }
}
class nE extends tE {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, t, r, i) {
    let s = e[t];
    if (!this._isShallow) {
      const a = Da(s);
      if (!Bi(r) && !Da(r) && (s = yt(s), r = yt(r)), !Ze(e) && Jn(s) && !Jn(r))
        return a ? !1 : (s.value = r, !0);
    }
    const o = Ze(e) && rv(t) ? Number(t) < e.length : bt(e, t), l = Reflect.set(
      e,
      t,
      r,
      Jn(e) ? e : i
    );
    return e === yt(i) && (o ? ll(r, s) && Xs(e, "set", t, r) : Xs(e, "add", t, r)), l;
  }
  deleteProperty(e, t) {
    const r = bt(e, t);
    e[t];
    const i = Reflect.deleteProperty(e, t);
    return i && r && Xs(e, "delete", t, void 0), i;
  }
  has(e, t) {
    const r = Reflect.has(e, t);
    return (!cu(t) || !eE.has(t)) && jn(e, "has", t), r;
  }
  ownKeys(e) {
    return jn(
      e,
      "iterate",
      Ze(e) ? "length" : ma
    ), Reflect.ownKeys(e);
  }
}
class tJ extends tE {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, t) {
    return !0;
  }
  deleteProperty(e, t) {
    return !0;
  }
}
const nJ = /* @__PURE__ */ new nE(), rJ = /* @__PURE__ */ new tJ(), iJ = /* @__PURE__ */ new nE(!0);
const o5 = (n) => n, m0 = (n) => Reflect.getPrototypeOf(n);
function sJ(n, e, t) {
  return function(...r) {
    const i = this.__v_raw, s = yt(i), o = rf(s), l = n === "entries" || n === Symbol.iterator && o, a = n === "keys" && o, c = i[n](...r), u = t ? o5 : e ? l5 : sr;
    return !e && jn(
      s,
      "iterate",
      a ? s5 : ma
    ), {
      // iterator protocol
      next() {
        const { value: h, done: f } = c.next();
        return f ? { value: h, done: f } : {
          value: l ? [u(h[0]), u(h[1])] : u(h),
          done: f
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function g0(n) {
  return function(...e) {
    return n === "delete" ? !1 : n === "clear" ? void 0 : this;
  };
}
function oJ(n, e) {
  const t = {
    get(i) {
      const s = this.__v_raw, o = yt(s), l = yt(i);
      n || (ll(i, l) && jn(o, "get", i), jn(o, "get", l));
      const { has: a } = m0(o), c = e ? o5 : n ? l5 : sr;
      if (a.call(o, i))
        return c(s.get(i));
      if (a.call(o, l))
        return c(s.get(l));
      s !== o && s.get(i);
    },
    get size() {
      const i = this.__v_raw;
      return !n && jn(yt(i), "iterate", ma), Reflect.get(i, "size", i);
    },
    has(i) {
      const s = this.__v_raw, o = yt(s), l = yt(i);
      return n || (ll(i, l) && jn(o, "has", i), jn(o, "has", l)), i === l ? s.has(i) : s.has(i) || s.has(l);
    },
    forEach(i, s) {
      const o = this, l = o.__v_raw, a = yt(l), c = e ? o5 : n ? l5 : sr;
      return !n && jn(a, "iterate", ma), l.forEach((u, h) => i.call(s, c(u), c(h), o));
    }
  };
  return Xn(
    t,
    n ? {
      add: g0("add"),
      set: g0("set"),
      delete: g0("delete"),
      clear: g0("clear")
    } : {
      add(i) {
        !e && !Bi(i) && !Da(i) && (i = yt(i));
        const s = yt(this);
        return m0(s).has.call(s, i) || (s.add(i), Xs(s, "add", i, i)), this;
      },
      set(i, s) {
        !e && !Bi(s) && !Da(s) && (s = yt(s));
        const o = yt(this), { has: l, get: a } = m0(o);
        let c = l.call(o, i);
        c || (i = yt(i), c = l.call(o, i));
        const u = a.call(o, i);
        return o.set(i, s), c ? ll(s, u) && Xs(o, "set", i, s) : Xs(o, "add", i, s), this;
      },
      delete(i) {
        const s = yt(this), { has: o, get: l } = m0(s);
        let a = o.call(s, i);
        a || (i = yt(i), a = o.call(s, i)), l && l.call(s, i);
        const c = s.delete(i);
        return a && Xs(s, "delete", i, void 0), c;
      },
      clear() {
        const i = yt(this), s = i.size !== 0, o = i.clear();
        return s && Xs(
          i,
          "clear",
          void 0,
          void 0
        ), o;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((i) => {
    t[i] = sJ(i, n, e);
  }), t;
}
function hv(n, e) {
  const t = oJ(n, e);
  return (r, i, s) => i === "__v_isReactive" ? !n : i === "__v_isReadonly" ? n : i === "__v_raw" ? r : Reflect.get(
    bt(t, i) && i in r ? t : r,
    i,
    s
  );
}
const lJ = {
  get: /* @__PURE__ */ hv(!1, !1)
}, aJ = {
  get: /* @__PURE__ */ hv(!1, !0)
}, cJ = {
  get: /* @__PURE__ */ hv(!0, !1)
};
const rE = /* @__PURE__ */ new WeakMap(), iE = /* @__PURE__ */ new WeakMap(), sE = /* @__PURE__ */ new WeakMap(), uJ = /* @__PURE__ */ new WeakMap();
function hJ(n) {
  switch (n) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function fJ(n) {
  return n.__v_skip || !Object.isExtensible(n) ? 0 : hJ(LY(n));
}
function fv(n) {
  return Da(n) ? n : dv(
    n,
    !1,
    nJ,
    lJ,
    rE
  );
}
function dJ(n) {
  return dv(
    n,
    !1,
    iJ,
    aJ,
    iE
  );
}
function oE(n) {
  return dv(
    n,
    !0,
    rJ,
    cJ,
    sE
  );
}
function dv(n, e, t, r, i) {
  if (!un(n) || n.__v_raw && !(e && n.__v_isReactive))
    return n;
  const s = fJ(n);
  if (s === 0)
    return n;
  const o = i.get(n);
  if (o)
    return o;
  const l = new Proxy(
    n,
    s === 2 ? r : t
  );
  return i.set(n, l), l;
}
function af(n) {
  return Da(n) ? af(n.__v_raw) : !!(n && n.__v_isReactive);
}
function Da(n) {
  return !!(n && n.__v_isReadonly);
}
function Bi(n) {
  return !!(n && n.__v_isShallow);
}
function pv(n) {
  return n ? !!n.__v_raw : !1;
}
function yt(n) {
  const e = n && n.__v_raw;
  return e ? yt(e) : n;
}
function pJ(n) {
  return !bt(n, "__v_skip") && Object.isExtensible(n) && jf(n, "__v_skip", !0), n;
}
const sr = (n) => un(n) ? fv(n) : n, l5 = (n) => un(n) ? oE(n) : n;
function Jn(n) {
  return n ? n.__v_isRef === !0 : !1;
}
function Ae(n) {
  return lE(n, !1);
}
function Om(n) {
  return lE(n, !0);
}
function lE(n, e) {
  return Jn(n) ? n : new mJ(n, e);
}
class mJ {
  constructor(e, t) {
    this.dep = new cv(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : yt(e), this._value = t ? e : sr(e), this.__v_isShallow = t;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    const t = this._rawValue, r = this.__v_isShallow || Bi(e) || Da(e);
    e = r ? e : yt(e), ll(e, t) && (this._rawValue = e, this._value = r ? e : sr(e), this.dep.trigger());
  }
}
function gJ(n) {
  return Jn(n) ? n.value : n;
}
const yJ = {
  get: (n, e, t) => e === "__v_raw" ? n : gJ(Reflect.get(n, e, t)),
  set: (n, e, t, r) => {
    const i = n[e];
    return Jn(i) && !Jn(t) ? (i.value = t, !0) : Reflect.set(n, e, t, r);
  }
};
function aE(n) {
  return af(n) ? n : new Proxy(n, yJ);
}
class bJ {
  constructor(e, t, r) {
    this.fn = e, this.setter = t, this._value = void 0, this.dep = new cv(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Uf - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !t, this.isSSR = r;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    _t !== this)
      return GO(this, !0), !0;
  }
  get value() {
    const e = this.dep.track();
    return XO(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
function vJ(n, e, t = !1) {
  let r, i;
  return tt(n) ? r = n : (r = n.get, i = n.set), new bJ(r, i, t);
}
const y0 = {}, Em = /* @__PURE__ */ new WeakMap();
let Ul;
function wJ(n, e = !1, t = Ul) {
  if (t) {
    let r = Em.get(t);
    r || Em.set(t, r = []), r.push(n);
  }
}
function xJ(n, e, t = Lt) {
  const { immediate: r, deep: i, once: s, scheduler: o, augmentJob: l, call: a } = t, c = (C) => i ? C : Bi(C) || i === !1 || i === 0 ? Ko(C, 1) : Ko(C);
  let u, h, f, d, p = !1, m = !1;
  if (Jn(n) ? (h = () => n.value, p = Bi(n)) : af(n) ? (h = () => c(n), p = !0) : Ze(n) ? (m = !0, p = n.some((C) => af(C) || Bi(C)), h = () => n.map((C) => {
    if (Jn(C))
      return C.value;
    if (af(C))
      return c(C);
    if (tt(C))
      return a ? a(C, 2) : C();
  })) : tt(n) ? e ? h = a ? () => a(n, 2) : n : h = () => {
    if (f) {
      fo();
      try {
        f();
      } finally {
        po();
      }
    }
    const C = Ul;
    Ul = u;
    try {
      return a ? a(n, 3, [d]) : n(d);
    } finally {
      Ul = C;
    }
  } : h = _i, e && i) {
    const C = h, M = i === !0 ? 1 / 0 : i;
    h = () => Ko(C(), M);
  }
  const g = GY(), b = () => {
    u.stop(), g && g.active && nv(g.effects, u);
  };
  if (s && e) {
    const C = e;
    e = (...M) => {
      C(...M), b();
    };
  }
  let w = m ? new Array(n.length).fill(y0) : y0;
  const k = (C) => {
    if (!(!(u.flags & 1) || !u.dirty && !C))
      if (e) {
        const M = u.run();
        if (i || p || (m ? M.some((T, N) => ll(T, w[N])) : ll(M, w))) {
          f && f();
          const T = Ul;
          Ul = u;
          try {
            const N = [
              M,
              // pass undefined as the old value when it's changed for the first time
              w === y0 ? void 0 : m && w[0] === y0 ? [] : w,
              d
            ];
            w = M, a ? a(e, 3, N) : (
              // @ts-expect-error
              e(...N)
            );
          } finally {
            Ul = T;
          }
        }
      } else
        u.run();
  };
  return l && l(k), u = new UO(h), u.scheduler = o ? () => o(k, !1) : k, d = (C) => wJ(C, !1, u), f = u.onStop = () => {
    const C = Em.get(u);
    if (C) {
      if (a)
        a(C, 4);
      else
        for (const M of C) M();
      Em.delete(u);
    }
  }, e ? r ? k(!0) : w = u.run() : o ? o(k.bind(null, !0), !0) : u.run(), b.pause = u.pause.bind(u), b.resume = u.resume.bind(u), b.stop = b, b;
}
function Ko(n, e = 1 / 0, t) {
  if (e <= 0 || !un(n) || n.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(n)))
    return n;
  if (t.add(n), e--, Jn(n))
    Ko(n.value, e, t);
  else if (Ze(n))
    for (let r = 0; r < n.length; r++)
      Ko(n[r], e, t);
  else if (PY(n) || rf(n))
    n.forEach((r) => {
      Ko(r, e, t);
    });
  else if (BY(n)) {
    for (const r in n)
      Ko(n[r], e, t);
    for (const r of Object.getOwnPropertySymbols(n))
      Object.prototype.propertyIsEnumerable.call(n, r) && Ko(n[r], e, t);
  }
  return n;
}
/**
* @vue/runtime-core v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function xd(n, e, t, r) {
  try {
    return r ? n(...r) : n();
  } catch (i) {
    j1(i, e, t);
  }
}
function Ms(n, e, t, r) {
  if (tt(n)) {
    const i = xd(n, e, t, r);
    return i && qO(i) && i.catch((s) => {
      j1(s, e, t);
    }), i;
  }
  if (Ze(n)) {
    const i = [];
    for (let s = 0; s < n.length; s++)
      i.push(Ms(n[s], e, t, r));
    return i;
  }
}
function j1(n, e, t, r = !0) {
  const i = e ? e.vnode : null, { errorHandler: s, throwUnhandledErrorInProduction: o } = e && e.appContext.config || Lt;
  if (e) {
    let l = e.parent;
    const a = e.proxy, c = `https://vuejs.org/error-reference/#runtime-${t}`;
    for (; l; ) {
      const u = l.ec;
      if (u) {
        for (let h = 0; h < u.length; h++)
          if (u[h](n, a, c) === !1)
            return;
      }
      l = l.parent;
    }
    if (s) {
      fo(), xd(s, null, 10, [
        n,
        a,
        c
      ]), po();
      return;
    }
  }
  kJ(n, t, i, r, o);
}
function kJ(n, e, t, r = !0, i = !1) {
  if (i)
    throw n;
  console.error(n);
}
const or = [];
let rs = -1;
const Mc = [];
let Vo = null, sc = 0;
const cE = /* @__PURE__ */ Promise.resolve();
let Im = null;
function SJ(n) {
  const e = Im || cE;
  return n ? e.then(this ? n.bind(this) : n) : e;
}
function CJ(n) {
  let e = rs + 1, t = or.length;
  for (; e < t; ) {
    const r = e + t >>> 1, i = or[r], s = Gf(i);
    s < n || s === n && i.flags & 2 ? e = r + 1 : t = r;
  }
  return e;
}
function mv(n) {
  if (!(n.flags & 1)) {
    const e = Gf(n), t = or[or.length - 1];
    !t || // fast path when the job id is larger than the tail
    !(n.flags & 2) && e >= Gf(t) ? or.push(n) : or.splice(CJ(e), 0, n), n.flags |= 1, uE();
  }
}
function uE() {
  Im || (Im = cE.then(fE));
}
function MJ(n) {
  Ze(n) ? Mc.push(...n) : Vo && n.id === -1 ? Vo.splice(sc + 1, 0, n) : n.flags & 1 || (Mc.push(n), n.flags |= 1), uE();
}
function T8(n, e, t = rs + 1) {
  for (; t < or.length; t++) {
    const r = or[t];
    if (r && r.flags & 2) {
      if (n && r.id !== n.uid)
        continue;
      or.splice(t, 1), t--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2);
    }
  }
}
function hE(n) {
  if (Mc.length) {
    const e = [...new Set(Mc)].sort(
      (t, r) => Gf(t) - Gf(r)
    );
    if (Mc.length = 0, Vo) {
      Vo.push(...e);
      return;
    }
    for (Vo = e, sc = 0; sc < Vo.length; sc++) {
      const t = Vo[sc];
      t.flags & 4 && (t.flags &= -2), t.flags & 8 || t(), t.flags &= -2;
    }
    Vo = null, sc = 0;
  }
}
const Gf = (n) => n.id == null ? n.flags & 2 ? -1 : 1 / 0 : n.id;
function fE(n) {
  try {
    for (rs = 0; rs < or.length; rs++) {
      const e = or[rs];
      e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), xd(
        e,
        e.i,
        e.i ? 15 : 14
      ), e.flags & 4 || (e.flags &= -2));
    }
  } finally {
    for (; rs < or.length; rs++) {
      const e = or[rs];
      e && (e.flags &= -2);
    }
    rs = -1, or.length = 0, hE(), Im = null, (or.length || Mc.length) && fE();
  }
}
let us, gh = [], a5 = !1;
function U1(n, ...e) {
  us ? us.emit(n, ...e) : a5 || gh.push({ event: n, args: e });
}
function dE(n, e) {
  var t, r;
  us = n, us ? (us.enabled = !0, gh.forEach(({ event: i, args: s }) => us.emit(i, ...s)), gh = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((r = (t = window.navigator) == null ? void 0 : t.userAgent) != null && r.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {
    dE(s, e);
  }), setTimeout(() => {
    us || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, a5 = !0, gh = []);
  }, 3e3)) : (a5 = !0, gh = []);
}
function TJ(n, e) {
  U1("app:init", n, e, {
    Fragment: Ln,
    Text: Cd,
    Comment: Na,
    Static: kp
  });
}
function AJ(n) {
  U1("app:unmount", n);
}
const OJ = /* @__PURE__ */ gv(
  "component:added"
  /* COMPONENT_ADDED */
), pE = /* @__PURE__ */ gv(
  "component:updated"
  /* COMPONENT_UPDATED */
), EJ = /* @__PURE__ */ gv(
  "component:removed"
  /* COMPONENT_REMOVED */
), IJ = (n) => {
  us && typeof us.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !us.cleanupBuffer(n) && EJ(n);
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function gv(n) {
  return (e) => {
    U1(
      n,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
function DJ(n, e, t) {
  U1(
    "component:emit",
    n.appContext.app,
    n,
    e,
    t
  );
}
let ps = null, mE = null;
function Dm(n) {
  const e = ps;
  return ps = n, mE = n && n.type.__scopeId || null, e;
}
function NJ(n, e = ps, t) {
  if (!e || n._n)
    return n;
  const r = (...i) => {
    r._d && _8(-1);
    const s = Dm(e);
    let o;
    try {
      o = n(...i);
    } finally {
      Dm(s), r._d && _8(1);
    }
    return __VUE_PROD_DEVTOOLS__ && pE(e), o;
  };
  return r._n = !0, r._c = !0, r._d = !0, r;
}
function Ll(n, e, t, r) {
  const i = n.dirs, s = e && e.dirs;
  for (let o = 0; o < i.length; o++) {
    const l = i[o];
    s && (l.oldValue = s[o].value);
    let a = l.dir[r];
    a && (fo(), Ms(a, t, 8, [
      n.el,
      l,
      n,
      e
    ]), po());
  }
}
const RJ = Symbol("_vte"), PJ = (n) => n.__isTeleport;
function yv(n, e) {
  n.shapeFlag & 6 && n.component ? (n.transition = e, yv(n.component.subTree, e)) : n.shapeFlag & 128 ? (n.ssContent.transition = e.clone(n.ssContent), n.ssFallback.transition = e.clone(n.ssFallback)) : n.transition = e;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function $n(n, e) {
  return tt(n) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Xn({ name: n.name }, e, { setup: n })
  ) : n;
}
function gE(n) {
  n.ids = [n.ids[0] + n.ids[2]++ + "-", 0, 0];
}
function cf(n, e, t, r, i = !1) {
  if (Ze(n)) {
    n.forEach(
      (p, m) => cf(
        p,
        e && (Ze(e) ? e[m] : e),
        t,
        r,
        i
      )
    );
    return;
  }
  if (uf(r) && !i) {
    r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && cf(n, e, t, r.component.subTree);
    return;
  }
  const s = r.shapeFlag & 4 ? Sv(r.component) : r.el, o = i ? null : s, { i: l, r: a } = n, c = e && e.r, u = l.refs === Lt ? l.refs = {} : l.refs, h = l.setupState, f = yt(h), d = h === Lt ? () => !1 : (p) => bt(f, p);
  if (c != null && c !== a && (An(c) ? (u[c] = null, d(c) && (h[c] = null)) : Jn(c) && (c.value = null)), tt(a))
    xd(a, l, 12, [o, u]);
  else {
    const p = An(a), m = Jn(a);
    if (p || m) {
      const g = () => {
        if (n.f) {
          const b = p ? d(a) ? h[a] : u[a] : a.value;
          i ? Ze(b) && nv(b, s) : Ze(b) ? b.includes(s) || b.push(s) : p ? (u[a] = [s], d(a) && (h[a] = u[a])) : (a.value = [s], n.k && (u[n.k] = a.value));
        } else p ? (u[a] = o, d(a) && (h[a] = o)) : m && (a.value = o, n.k && (u[n.k] = o));
      };
      o ? (g.id = -1, Vr(g, t)) : g();
    }
  }
}
pa().requestIdleCallback;
pa().cancelIdleCallback;
const uf = (n) => !!n.type.__asyncLoader, yE = (n) => n.type.__isKeepAlive;
function _J(n, e) {
  bE(n, "a", e);
}
function LJ(n, e) {
  bE(n, "da", e);
}
function bE(n, e, t = ar) {
  const r = n.__wdc || (n.__wdc = () => {
    let i = t;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return n();
  });
  if (K1(e, r, t), t) {
    let i = t.parent;
    for (; i && i.parent; )
      yE(i.parent.vnode) && BJ(r, e, t, i), i = i.parent;
  }
}
function BJ(n, e, t, r) {
  const i = K1(
    e,
    n,
    r,
    !0
    /* prepend */
  );
  Sd(() => {
    nv(r[e], i);
  }, t);
}
function K1(n, e, t = ar, r = !1) {
  if (t) {
    const i = t[n] || (t[n] = []), s = e.__weh || (e.__weh = (...o) => {
      fo();
      const l = Md(t), a = Ms(e, t, n, o);
      return l(), po(), a;
    });
    return r ? i.unshift(s) : i.push(s), s;
  }
}
const Co = (n) => (e, t = ar) => {
  (!Yf || n === "sp") && K1(n, (...r) => e(...r), t);
}, zJ = Co("bm"), kd = Co("m"), FJ = Co(
  "bu"
), HJ = Co("u"), $J = Co(
  "bum"
), Sd = Co("um"), VJ = Co(
  "sp"
), qJ = Co("rtg"), WJ = Co("rtc");
function jJ(n, e = ar) {
  K1("ec", n, e);
}
const UJ = Symbol.for("v-ndc"), c5 = (n) => n ? LE(n) ? Sv(n) : c5(n.parent) : null, hf = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Xn(/* @__PURE__ */ Object.create(null), {
    $: (n) => n,
    $el: (n) => n.vnode.el,
    $data: (n) => n.data,
    $props: (n) => n.props,
    $attrs: (n) => n.attrs,
    $slots: (n) => n.slots,
    $refs: (n) => n.refs,
    $parent: (n) => c5(n.parent),
    $root: (n) => c5(n.root),
    $host: (n) => n.ce,
    $emit: (n) => n.emit,
    $options: (n) => __VUE_OPTIONS_API__ ? wE(n) : n.type,
    $forceUpdate: (n) => n.f || (n.f = () => {
      mv(n.update);
    }),
    $nextTick: (n) => n.n || (n.n = SJ.bind(n.proxy)),
    $watch: (n) => __VUE_OPTIONS_API__ ? mX.bind(n) : _i
  })
), P2 = (n, e) => n !== Lt && !n.__isScriptSetup && bt(n, e), KJ = {
  get({ _: n }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: t, setupState: r, data: i, props: s, accessCache: o, type: l, appContext: a } = n;
    let c;
    if (e[0] !== "$") {
      const d = o[e];
      if (d !== void 0)
        switch (d) {
          case 1:
            return r[e];
          case 2:
            return i[e];
          case 4:
            return t[e];
          case 3:
            return s[e];
        }
      else {
        if (P2(r, e))
          return o[e] = 1, r[e];
        if (i !== Lt && bt(i, e))
          return o[e] = 2, i[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (c = n.propsOptions[0]) && bt(c, e)
        )
          return o[e] = 3, s[e];
        if (t !== Lt && bt(t, e))
          return o[e] = 4, t[e];
        (!__VUE_OPTIONS_API__ || u5) && (o[e] = 0);
      }
    }
    const u = hf[e];
    let h, f;
    if (u)
      return e === "$attrs" && jn(n.attrs, "get", ""), u(n);
    if (
      // css module (injected by vue-loader)
      (h = l.__cssModules) && (h = h[e])
    )
      return h;
    if (t !== Lt && bt(t, e))
      return o[e] = 4, t[e];
    if (
      // global properties
      f = a.config.globalProperties, bt(f, e)
    )
      return f[e];
  },
  set({ _: n }, e, t) {
    const { data: r, setupState: i, ctx: s } = n;
    return P2(i, e) ? (i[e] = t, !0) : r !== Lt && bt(r, e) ? (r[e] = t, !0) : bt(n.props, e) || e[0] === "$" && e.slice(1) in n ? !1 : (s[e] = t, !0);
  },
  has({
    _: { data: n, setupState: e, accessCache: t, ctx: r, appContext: i, propsOptions: s }
  }, o) {
    let l;
    return !!t[o] || n !== Lt && bt(n, o) || P2(e, o) || (l = s[0]) && bt(l, o) || bt(r, o) || bt(hf, o) || bt(i.config.globalProperties, o);
  },
  defineProperty(n, e, t) {
    return t.get != null ? n._.accessCache[e] = 0 : bt(t, "value") && this.set(n, e, t.value, null), Reflect.defineProperty(n, e, t);
  }
};
function A8(n) {
  return Ze(n) ? n.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : n;
}
let u5 = !0;
function GJ(n) {
  const e = wE(n), t = n.proxy, r = n.ctx;
  u5 = !1, e.beforeCreate && O8(e.beforeCreate, n, "bc");
  const {
    // state
    data: i,
    computed: s,
    methods: o,
    watch: l,
    provide: a,
    inject: c,
    // lifecycle
    created: u,
    beforeMount: h,
    mounted: f,
    beforeUpdate: d,
    updated: p,
    activated: m,
    deactivated: g,
    beforeDestroy: b,
    beforeUnmount: w,
    destroyed: k,
    unmounted: C,
    render: M,
    renderTracked: T,
    renderTriggered: N,
    errorCaptured: B,
    serverPrefetch: $,
    // public API
    expose: R,
    inheritAttrs: V,
    // assets
    components: z,
    directives: ue,
    filters: ie
  } = e;
  if (c && YJ(c, r, null), o)
    for (const ge in o) {
      const ye = o[ge];
      tt(ye) && (r[ge] = ye.bind(t));
    }
  if (i) {
    const ge = i.call(t, t);
    un(ge) && (n.data = fv(ge));
  }
  if (u5 = !0, s)
    for (const ge in s) {
      const ye = s[ge], ze = tt(ye) ? ye.bind(t, t) : tt(ye.get) ? ye.get.bind(t, t) : _i, I = !tt(ye) && tt(ye.set) ? ye.set.bind(t) : _i, Ie = Ra({
        get: ze,
        set: I
      });
      Object.defineProperty(r, ge, {
        enumerable: !0,
        configurable: !0,
        get: () => Ie.value,
        set: (Ve) => Ie.value = Ve
      });
    }
  if (l)
    for (const ge in l)
      vE(l[ge], r, t, ge);
  if (a) {
    const ge = tt(a) ? a.call(t) : a;
    Reflect.ownKeys(ge).forEach((ye) => {
      tX(ye, ge[ye]);
    });
  }
  u && O8(u, n, "c");
  function Se(ge, ye) {
    Ze(ye) ? ye.forEach((ze) => ge(ze.bind(t))) : ye && ge(ye.bind(t));
  }
  if (Se(zJ, h), Se(kd, f), Se(FJ, d), Se(HJ, p), Se(_J, m), Se(LJ, g), Se(jJ, B), Se(WJ, T), Se(qJ, N), Se($J, w), Se(Sd, C), Se(VJ, $), Ze(R))
    if (R.length) {
      const ge = n.exposed || (n.exposed = {});
      R.forEach((ye) => {
        Object.defineProperty(ge, ye, {
          get: () => t[ye],
          set: (ze) => t[ye] = ze,
          enumerable: !0
        });
      });
    } else n.exposed || (n.exposed = {});
  M && n.render === _i && (n.render = M), V != null && (n.inheritAttrs = V), z && (n.components = z), ue && (n.directives = ue), $ && gE(n);
}
function YJ(n, e, t = _i) {
  Ze(n) && (n = h5(n));
  for (const r in n) {
    const i = n[r];
    let s;
    un(i) ? "default" in i ? s = xp(
      i.from || r,
      i.default,
      !0
    ) : s = xp(i.from || r) : s = xp(i), Jn(s) ? Object.defineProperty(e, r, {
      enumerable: !0,
      configurable: !0,
      get: () => s.value,
      set: (o) => s.value = o
    }) : e[r] = s;
  }
}
function O8(n, e, t) {
  Ms(
    Ze(n) ? n.map((r) => r.bind(e.proxy)) : n.bind(e.proxy),
    e,
    t
  );
}
function vE(n, e, t, r) {
  let i = r.includes(".") ? NE(t, r) : () => t[r];
  if (An(n)) {
    const s = e[n];
    tt(s) && Ac(i, s);
  } else if (tt(n))
    Ac(i, n.bind(t));
  else if (un(n))
    if (Ze(n))
      n.forEach((s) => vE(s, e, t, r));
    else {
      const s = tt(n.handler) ? n.handler.bind(t) : e[n.handler];
      tt(s) && Ac(i, s, n);
    }
}
function wE(n) {
  const e = n.type, { mixins: t, extends: r } = e, {
    mixins: i,
    optionsCache: s,
    config: { optionMergeStrategies: o }
  } = n.appContext, l = s.get(e);
  let a;
  return l ? a = l : !i.length && !t && !r ? a = e : (a = {}, i.length && i.forEach(
    (c) => Nm(a, c, o, !0)
  ), Nm(a, e, o)), un(e) && s.set(e, a), a;
}
function Nm(n, e, t, r = !1) {
  const { mixins: i, extends: s } = e;
  s && Nm(n, s, t, !0), i && i.forEach(
    (o) => Nm(n, o, t, !0)
  );
  for (const o in e)
    if (!(r && o === "expose")) {
      const l = JJ[o] || t && t[o];
      n[o] = l ? l(n[o], e[o]) : e[o];
    }
  return n;
}
const JJ = {
  data: E8,
  props: I8,
  emits: I8,
  // objects
  methods: yh,
  computed: yh,
  // lifecycle
  beforeCreate: ir,
  created: ir,
  beforeMount: ir,
  mounted: ir,
  beforeUpdate: ir,
  updated: ir,
  beforeDestroy: ir,
  beforeUnmount: ir,
  destroyed: ir,
  unmounted: ir,
  activated: ir,
  deactivated: ir,
  errorCaptured: ir,
  serverPrefetch: ir,
  // assets
  components: yh,
  directives: yh,
  // watch
  watch: ZJ,
  // provide / inject
  provide: E8,
  inject: XJ
};
function E8(n, e) {
  return e ? n ? function() {
    return Xn(
      tt(n) ? n.call(this, this) : n,
      tt(e) ? e.call(this, this) : e
    );
  } : e : n;
}
function XJ(n, e) {
  return yh(h5(n), h5(e));
}
function h5(n) {
  if (Ze(n)) {
    const e = {};
    for (let t = 0; t < n.length; t++)
      e[n[t]] = n[t];
    return e;
  }
  return n;
}
function ir(n, e) {
  return n ? [...new Set([].concat(n, e))] : e;
}
function yh(n, e) {
  return n ? Xn(/* @__PURE__ */ Object.create(null), n, e) : e;
}
function I8(n, e) {
  return n ? Ze(n) && Ze(e) ? [.../* @__PURE__ */ new Set([...n, ...e])] : Xn(
    /* @__PURE__ */ Object.create(null),
    A8(n),
    A8(e ?? {})
  ) : e;
}
function ZJ(n, e) {
  if (!n) return e;
  if (!e) return n;
  const t = Xn(/* @__PURE__ */ Object.create(null), n);
  for (const r in e)
    t[r] = ir(n[r], e[r]);
  return t;
}
function xE() {
  return {
    app: null,
    config: {
      isNativeTag: NY,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let QJ = 0;
function eX(n, e) {
  return function(r, i = null) {
    tt(r) || (r = Xn({}, r)), i != null && !un(i) && (i = null);
    const s = xE(), o = /* @__PURE__ */ new WeakSet(), l = [];
    let a = !1;
    const c = s.app = {
      _uid: QJ++,
      _component: r,
      _props: i,
      _container: null,
      _context: s,
      _instance: null,
      version: z8,
      get config() {
        return s.config;
      },
      set config(u) {
      },
      use(u, ...h) {
        return o.has(u) || (u && tt(u.install) ? (o.add(u), u.install(c, ...h)) : tt(u) && (o.add(u), u(c, ...h))), c;
      },
      mixin(u) {
        return __VUE_OPTIONS_API__ && (s.mixins.includes(u) || s.mixins.push(u)), c;
      },
      component(u, h) {
        return h ? (s.components[u] = h, c) : s.components[u];
      },
      directive(u, h) {
        return h ? (s.directives[u] = h, c) : s.directives[u];
      },
      mount(u, h, f) {
        if (!a) {
          const d = c._ceVNode || Ni(r, i);
          return d.appContext = s, f === !0 ? f = "svg" : f === !1 && (f = void 0), n(d, u, f), a = !0, c._container = u, u.__vue_app__ = c, __VUE_PROD_DEVTOOLS__ && (c._instance = d.component, TJ(c, z8)), Sv(d.component);
        }
      },
      onUnmount(u) {
        l.push(u);
      },
      unmount() {
        a && (Ms(
          l,
          c._instance,
          16
        ), n(null, c._container), __VUE_PROD_DEVTOOLS__ && (c._instance = null, AJ(c)), delete c._container.__vue_app__);
      },
      provide(u, h) {
        return s.provides[u] = h, c;
      },
      runWithContext(u) {
        const h = Tc;
        Tc = c;
        try {
          return u();
        } finally {
          Tc = h;
        }
      }
    };
    return c;
  };
}
let Tc = null;
function tX(n, e) {
  if (ar) {
    let t = ar.provides;
    const r = ar.parent && ar.parent.provides;
    r === t && (t = ar.provides = Object.create(r)), t[n] = e;
  }
}
function xp(n, e, t = !1) {
  const r = DX();
  if (r || Tc) {
    let i = Tc ? Tc._context.provides : r ? r.parent == null || r.ce ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
    if (i && n in i)
      return i[n];
    if (arguments.length > 1)
      return t && tt(e) ? e.call(r && r.proxy) : e;
  }
}
const kE = {}, SE = () => Object.create(kE), CE = (n) => Object.getPrototypeOf(n) === kE;
function nX(n, e, t, r = !1) {
  const i = {}, s = SE();
  n.propsDefaults = /* @__PURE__ */ Object.create(null), ME(n, e, i, s);
  for (const o in n.propsOptions[0])
    o in i || (i[o] = void 0);
  t ? n.props = r ? i : dJ(i) : n.type.props ? n.props = i : n.props = s, n.attrs = s;
}
function rX(n, e, t, r) {
  const {
    props: i,
    attrs: s,
    vnode: { patchFlag: o }
  } = n, l = yt(i), [a] = n.propsOptions;
  let c = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (r || o > 0) && !(o & 16)
  ) {
    if (o & 8) {
      const u = n.vnode.dynamicProps;
      for (let h = 0; h < u.length; h++) {
        let f = u[h];
        if (G1(n.emitsOptions, f))
          continue;
        const d = e[f];
        if (a)
          if (bt(s, f))
            d !== s[f] && (s[f] = d, c = !0);
          else {
            const p = bl(f);
            i[p] = f5(
              a,
              l,
              p,
              d,
              n,
              !1
            );
          }
        else
          d !== s[f] && (s[f] = d, c = !0);
      }
    }
  } else {
    ME(n, e, i, s) && (c = !0);
    let u;
    for (const h in l)
      (!e || // for camelCase
      !bt(e, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((u = Ha(h)) === h || !bt(e, u))) && (a ? t && // for camelCase
      (t[h] !== void 0 || // for kebab-case
      t[u] !== void 0) && (i[h] = f5(
        a,
        l,
        h,
        void 0,
        n,
        !0
      )) : delete i[h]);
    if (s !== l)
      for (const h in s)
        (!e || !bt(e, h)) && (delete s[h], c = !0);
  }
  c && Xs(n.attrs, "set", "");
}
function ME(n, e, t, r) {
  const [i, s] = n.propsOptions;
  let o = !1, l;
  if (e)
    for (let a in e) {
      if (sf(a))
        continue;
      const c = e[a];
      let u;
      i && bt(i, u = bl(a)) ? !s || !s.includes(u) ? t[u] = c : (l || (l = {}))[u] = c : G1(n.emitsOptions, a) || (!(a in r) || c !== r[a]) && (r[a] = c, o = !0);
    }
  if (s) {
    const a = yt(t), c = l || Lt;
    for (let u = 0; u < s.length; u++) {
      const h = s[u];
      t[h] = f5(
        i,
        a,
        h,
        c[h],
        n,
        !bt(c, h)
      );
    }
  }
  return o;
}
function f5(n, e, t, r, i, s) {
  const o = n[t];
  if (o != null) {
    const l = bt(o, "default");
    if (l && r === void 0) {
      const a = o.default;
      if (o.type !== Function && !o.skipFactory && tt(a)) {
        const { propsDefaults: c } = i;
        if (t in c)
          r = c[t];
        else {
          const u = Md(i);
          r = c[t] = a.call(
            null,
            e
          ), u();
        }
      } else
        r = a;
      i.ce && i.ce._setProp(t, r);
    }
    o[
      0
      /* shouldCast */
    ] && (s && !l ? r = !1 : o[
      1
      /* shouldCastTrue */
    ] && (r === "" || r === Ha(t)) && (r = !0));
  }
  return r;
}
const iX = /* @__PURE__ */ new WeakMap();
function TE(n, e, t = !1) {
  const r = __VUE_OPTIONS_API__ && t ? iX : e.propsCache, i = r.get(n);
  if (i)
    return i;
  const s = n.props, o = {}, l = [];
  let a = !1;
  if (__VUE_OPTIONS_API__ && !tt(n)) {
    const u = (h) => {
      a = !0;
      const [f, d] = TE(h, e, !0);
      Xn(o, f), d && l.push(...d);
    };
    !t && e.mixins.length && e.mixins.forEach(u), n.extends && u(n.extends), n.mixins && n.mixins.forEach(u);
  }
  if (!s && !a)
    return un(n) && r.set(n, nf), nf;
  if (Ze(s))
    for (let u = 0; u < s.length; u++) {
      const h = bl(s[u]);
      D8(h) && (o[h] = Lt);
    }
  else if (s)
    for (const u in s) {
      const h = bl(u);
      if (D8(h)) {
        const f = s[u], d = o[h] = Ze(f) || tt(f) ? { type: f } : Xn({}, f), p = d.type;
        let m = !1, g = !0;
        if (Ze(p))
          for (let b = 0; b < p.length; ++b) {
            const w = p[b], k = tt(w) && w.name;
            if (k === "Boolean") {
              m = !0;
              break;
            } else k === "String" && (g = !1);
          }
        else
          m = tt(p) && p.name === "Boolean";
        d[
          0
          /* shouldCast */
        ] = m, d[
          1
          /* shouldCastTrue */
        ] = g, (m || bt(d, "default")) && l.push(h);
      }
    }
  const c = [o, l];
  return un(n) && r.set(n, c), c;
}
function D8(n) {
  return n[0] !== "$" && !sf(n);
}
const bv = (n) => n === "_" || n === "__" || n === "_ctx" || n === "$stable", vv = (n) => Ze(n) ? n.map(ss) : [ss(n)], sX = (n, e, t) => {
  if (e._n)
    return e;
  const r = NJ((...i) => vv(e(...i)), t);
  return r._c = !1, r;
}, AE = (n, e, t) => {
  const r = n._ctx;
  for (const i in n) {
    if (bv(i)) continue;
    const s = n[i];
    if (tt(s))
      e[i] = sX(i, s, r);
    else if (s != null) {
      const o = vv(s);
      e[i] = () => o;
    }
  }
}, OE = (n, e) => {
  const t = vv(e);
  n.slots.default = () => t;
}, EE = (n, e, t) => {
  for (const r in e)
    (t || !bv(r)) && (n[r] = e[r]);
}, oX = (n, e, t) => {
  const r = n.slots = SE();
  if (n.vnode.shapeFlag & 32) {
    const i = e.__;
    i && jf(r, "__", i, !0);
    const s = e._;
    s ? (EE(r, e, t), t && jf(r, "_", s, !0)) : AE(e, r);
  } else e && OE(n, e);
}, lX = (n, e, t) => {
  const { vnode: r, slots: i } = n;
  let s = !0, o = Lt;
  if (r.shapeFlag & 32) {
    const l = e._;
    l ? t && l === 1 ? s = !1 : EE(i, e, t) : (s = !e.$stable, AE(e, i)), o = e;
  } else e && (OE(n, e), o = { default: 1 });
  if (s)
    for (const l in i)
      !bv(l) && o[l] == null && delete i[l];
};
function aX() {
  typeof __VUE_OPTIONS_API__ != "boolean" && (pa().__VUE_OPTIONS_API__ = !0), typeof __VUE_PROD_DEVTOOLS__ != "boolean" && (pa().__VUE_PROD_DEVTOOLS__ = !1), typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" && (pa().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1);
}
const Vr = kX;
function cX(n) {
  return uX(n);
}
function uX(n, e) {
  aX();
  const t = pa();
  t.__VUE__ = !0, __VUE_PROD_DEVTOOLS__ && dE(t.__VUE_DEVTOOLS_GLOBAL_HOOK__, t);
  const {
    insert: r,
    remove: i,
    patchProp: s,
    createElement: o,
    createText: l,
    createComment: a,
    setText: c,
    setElementText: u,
    parentNode: h,
    nextSibling: f,
    setScopeId: d = _i,
    insertStaticContent: p
  } = n, m = (E, P, W, Q = null, J = null, Y = null, ae = void 0, re = null, oe = !!P.dynamicChildren) => {
    if (E === P)
      return;
    E && !Vu(E, P) && (Q = Mt(E), Ve(E, J, Y, !0), E = null), P.patchFlag === -2 && (oe = !1, P.dynamicChildren = null);
    const { type: te, ref: De, shapeFlag: de } = P;
    switch (te) {
      case Cd:
        g(E, P, W, Q);
        break;
      case Na:
        b(E, P, W, Q);
        break;
      case kp:
        E == null && w(P, W, Q, ae);
        break;
      case Ln:
        z(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        );
        break;
      default:
        de & 1 ? M(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        ) : de & 6 ? ue(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        ) : (de & 64 || de & 128) && te.process(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe,
          Gt
        );
    }
    De != null && J ? cf(De, E && E.ref, Y, P || E, !P) : De == null && E && E.ref != null && cf(E.ref, null, Y, E, !0);
  }, g = (E, P, W, Q) => {
    if (E == null)
      r(
        P.el = l(P.children),
        W,
        Q
      );
    else {
      const J = P.el = E.el;
      P.children !== E.children && c(J, P.children);
    }
  }, b = (E, P, W, Q) => {
    E == null ? r(
      P.el = a(P.children || ""),
      W,
      Q
    ) : P.el = E.el;
  }, w = (E, P, W, Q) => {
    [E.el, E.anchor] = p(
      E.children,
      P,
      W,
      Q,
      E.el,
      E.anchor
    );
  }, k = ({ el: E, anchor: P }, W, Q) => {
    let J;
    for (; E && E !== P; )
      J = f(E), r(E, W, Q), E = J;
    r(P, W, Q);
  }, C = ({ el: E, anchor: P }) => {
    let W;
    for (; E && E !== P; )
      W = f(E), i(E), E = W;
    i(P);
  }, M = (E, P, W, Q, J, Y, ae, re, oe) => {
    P.type === "svg" ? ae = "svg" : P.type === "math" && (ae = "mathml"), E == null ? T(
      P,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe
    ) : $(
      E,
      P,
      J,
      Y,
      ae,
      re,
      oe
    );
  }, T = (E, P, W, Q, J, Y, ae, re) => {
    let oe, te;
    const { props: De, shapeFlag: de, transition: Te, dirs: Pe } = E;
    if (oe = E.el = o(
      E.type,
      Y,
      De && De.is,
      De
    ), de & 8 ? u(oe, E.children) : de & 16 && B(
      E.children,
      oe,
      null,
      Q,
      J,
      _2(E, Y),
      ae,
      re
    ), Pe && Ll(E, null, Q, "created"), N(oe, E, E.scopeId, ae, Q), De) {
      for (const X in De)
        X !== "value" && !sf(X) && s(oe, X, null, De[X], Y, Q);
      "value" in De && s(oe, "value", null, De.value, Y), (te = De.onVnodeBeforeMount) && Zi(te, Q, E);
    }
    __VUE_PROD_DEVTOOLS__ && (jf(oe, "__vnode", E, !0), jf(oe, "__vueParentComponent", Q, !0)), Pe && Ll(E, null, Q, "beforeMount");
    const F = hX(J, Te);
    F && Te.beforeEnter(oe), r(oe, P, W), ((te = De && De.onVnodeMounted) || F || Pe) && Vr(() => {
      te && Zi(te, Q, E), F && Te.enter(oe), Pe && Ll(E, null, Q, "mounted");
    }, J);
  }, N = (E, P, W, Q, J) => {
    if (W && d(E, W), Q)
      for (let Y = 0; Y < Q.length; Y++)
        d(E, Q[Y]);
    if (J) {
      let Y = J.subTree;
      if (P === Y || PE(Y.type) && (Y.ssContent === P || Y.ssFallback === P)) {
        const ae = J.vnode;
        N(
          E,
          ae,
          ae.scopeId,
          ae.slotScopeIds,
          J.parent
        );
      }
    }
  }, B = (E, P, W, Q, J, Y, ae, re, oe = 0) => {
    for (let te = oe; te < E.length; te++) {
      const De = E[te] = re ? qo(E[te]) : ss(E[te]);
      m(
        null,
        De,
        P,
        W,
        Q,
        J,
        Y,
        ae,
        re
      );
    }
  }, $ = (E, P, W, Q, J, Y, ae) => {
    const re = P.el = E.el;
    __VUE_PROD_DEVTOOLS__ && (re.__vnode = P);
    let { patchFlag: oe, dynamicChildren: te, dirs: De } = P;
    oe |= E.patchFlag & 16;
    const de = E.props || Lt, Te = P.props || Lt;
    let Pe;
    if (W && Bl(W, !1), (Pe = Te.onVnodeBeforeUpdate) && Zi(Pe, W, P, E), De && Ll(P, E, W, "beforeUpdate"), W && Bl(W, !0), (de.innerHTML && Te.innerHTML == null || de.textContent && Te.textContent == null) && u(re, ""), te ? R(
      E.dynamicChildren,
      te,
      re,
      W,
      Q,
      _2(P, J),
      Y
    ) : ae || ye(
      E,
      P,
      re,
      null,
      W,
      Q,
      _2(P, J),
      Y,
      !1
    ), oe > 0) {
      if (oe & 16)
        V(re, de, Te, W, J);
      else if (oe & 2 && de.class !== Te.class && s(re, "class", null, Te.class, J), oe & 4 && s(re, "style", de.style, Te.style, J), oe & 8) {
        const F = P.dynamicProps;
        for (let X = 0; X < F.length; X++) {
          const pe = F[X], _e = de[pe], je = Te[pe];
          (je !== _e || pe === "value") && s(re, pe, _e, je, J, W);
        }
      }
      oe & 1 && E.children !== P.children && u(re, P.children);
    } else !ae && te == null && V(re, de, Te, W, J);
    ((Pe = Te.onVnodeUpdated) || De) && Vr(() => {
      Pe && Zi(Pe, W, P, E), De && Ll(P, E, W, "updated");
    }, Q);
  }, R = (E, P, W, Q, J, Y, ae) => {
    for (let re = 0; re < P.length; re++) {
      const oe = E[re], te = P[re], De = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oe.type === Ln || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Vu(oe, te) || // - In the case of a component, it could contain anything.
        oe.shapeFlag & 198) ? h(oe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          W
        )
      );
      m(
        oe,
        te,
        De,
        null,
        Q,
        J,
        Y,
        ae,
        !0
      );
    }
  }, V = (E, P, W, Q, J) => {
    if (P !== W) {
      if (P !== Lt)
        for (const Y in P)
          !sf(Y) && !(Y in W) && s(
            E,
            Y,
            P[Y],
            null,
            J,
            Q
          );
      for (const Y in W) {
        if (sf(Y)) continue;
        const ae = W[Y], re = P[Y];
        ae !== re && Y !== "value" && s(E, Y, re, ae, J, Q);
      }
      "value" in W && s(E, "value", P.value, W.value, J);
    }
  }, z = (E, P, W, Q, J, Y, ae, re, oe) => {
    const te = P.el = E ? E.el : l(""), De = P.anchor = E ? E.anchor : l("");
    let { patchFlag: de, dynamicChildren: Te, slotScopeIds: Pe } = P;
    Pe && (re = re ? re.concat(Pe) : Pe), E == null ? (r(te, W, Q), r(De, W, Q), B(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      P.children || [],
      W,
      De,
      J,
      Y,
      ae,
      re,
      oe
    )) : de > 0 && de & 64 && Te && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    E.dynamicChildren ? (R(
      E.dynamicChildren,
      Te,
      W,
      J,
      Y,
      ae,
      re
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (P.key != null || J && P === J.subTree) && IE(
      E,
      P,
      !0
      /* shallow */
    )) : ye(
      E,
      P,
      W,
      De,
      J,
      Y,
      ae,
      re,
      oe
    );
  }, ue = (E, P, W, Q, J, Y, ae, re, oe) => {
    P.slotScopeIds = re, E == null ? P.shapeFlag & 512 ? J.ctx.activate(
      P,
      W,
      Q,
      ae,
      oe
    ) : ie(
      P,
      W,
      Q,
      J,
      Y,
      ae,
      oe
    ) : he(E, P, oe);
  }, ie = (E, P, W, Q, J, Y, ae) => {
    const re = E.component = IX(
      E,
      Q,
      J
    );
    if (yE(E) && (re.ctx.renderer = Gt), NX(re, !1, ae), re.asyncDep) {
      if (J && J.registerDep(re, Se, ae), !E.el) {
        const oe = re.subTree = Ni(Na);
        b(null, oe, P, W), E.placeholder = oe.el;
      }
    } else
      Se(
        re,
        E,
        P,
        W,
        J,
        Y,
        ae
      );
  }, he = (E, P, W) => {
    const Q = P.component = E.component;
    if (wX(E, P, W))
      if (Q.asyncDep && !Q.asyncResolved) {
        ge(Q, P, W);
        return;
      } else
        Q.next = P, Q.update();
    else
      P.el = E.el, Q.vnode = P;
  }, Se = (E, P, W, Q, J, Y, ae) => {
    const re = () => {
      if (E.isMounted) {
        let { next: de, bu: Te, u: Pe, parent: F, vnode: X } = E;
        {
          const Pt = DE(E);
          if (Pt) {
            de && (de.el = X.el, ge(E, de, ae)), Pt.asyncDep.then(() => {
              E.isUnmounted || re();
            });
            return;
          }
        }
        let pe = de, _e;
        Bl(E, !1), de ? (de.el = X.el, ge(E, de, ae)) : de = X, Te && I2(Te), (_e = de.props && de.props.onVnodeBeforeUpdate) && Zi(_e, F, de, X), Bl(E, !0);
        const je = R8(E), xt = E.subTree;
        E.subTree = je, m(
          xt,
          je,
          // parent may have changed if it's in a teleport
          h(xt.el),
          // anchor may have changed if it's in a fragment
          Mt(xt),
          E,
          J,
          Y
        ), de.el = je.el, pe === null && xX(E, je.el), Pe && Vr(Pe, J), (_e = de.props && de.props.onVnodeUpdated) && Vr(
          () => Zi(_e, F, de, X),
          J
        ), __VUE_PROD_DEVTOOLS__ && pE(E);
      } else {
        let de;
        const { el: Te, props: Pe } = P, { bm: F, m: X, parent: pe, root: _e, type: je } = E, xt = uf(P);
        Bl(E, !1), F && I2(F), !xt && (de = Pe && Pe.onVnodeBeforeMount) && Zi(de, pe, P), Bl(E, !0);
        {
          _e.ce && // @ts-expect-error _def is private
          _e.ce._def.shadowRoot !== !1 && _e.ce._injectChildStyle(je);
          const Pt = E.subTree = R8(E);
          m(
            null,
            Pt,
            W,
            Q,
            E,
            J,
            Y
          ), P.el = Pt.el;
        }
        if (X && Vr(X, J), !xt && (de = Pe && Pe.onVnodeMounted)) {
          const Pt = P;
          Vr(
            () => Zi(de, pe, Pt),
            J
          );
        }
        (P.shapeFlag & 256 || pe && uf(pe.vnode) && pe.vnode.shapeFlag & 256) && E.a && Vr(E.a, J), E.isMounted = !0, __VUE_PROD_DEVTOOLS__ && OJ(E), P = W = Q = null;
      }
    };
    E.scope.on();
    const oe = E.effect = new UO(re);
    E.scope.off();
    const te = E.update = oe.run.bind(oe), De = E.job = oe.runIfDirty.bind(oe);
    De.i = E, De.id = E.uid, oe.scheduler = () => mv(De), Bl(E, !0), te();
  }, ge = (E, P, W) => {
    P.component = E;
    const Q = E.vnode.props;
    E.vnode = P, E.next = null, rX(E, P.props, Q, W), lX(E, P.children, W), fo(), T8(E), po();
  }, ye = (E, P, W, Q, J, Y, ae, re, oe = !1) => {
    const te = E && E.children, De = E ? E.shapeFlag : 0, de = P.children, { patchFlag: Te, shapeFlag: Pe } = P;
    if (Te > 0) {
      if (Te & 128) {
        I(
          te,
          de,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        );
        return;
      } else if (Te & 256) {
        ze(
          te,
          de,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        );
        return;
      }
    }
    Pe & 8 ? (De & 16 && et(te, J, Y), de !== te && u(W, de)) : De & 16 ? Pe & 16 ? I(
      te,
      de,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe
    ) : et(te, J, Y, !0) : (De & 8 && u(W, ""), Pe & 16 && B(
      de,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe
    ));
  }, ze = (E, P, W, Q, J, Y, ae, re, oe) => {
    E = E || nf, P = P || nf;
    const te = E.length, De = P.length, de = Math.min(te, De);
    let Te;
    for (Te = 0; Te < de; Te++) {
      const Pe = P[Te] = oe ? qo(P[Te]) : ss(P[Te]);
      m(
        E[Te],
        Pe,
        W,
        null,
        J,
        Y,
        ae,
        re,
        oe
      );
    }
    te > De ? et(
      E,
      J,
      Y,
      !0,
      !1,
      de
    ) : B(
      P,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe,
      de
    );
  }, I = (E, P, W, Q, J, Y, ae, re, oe) => {
    let te = 0;
    const De = P.length;
    let de = E.length - 1, Te = De - 1;
    for (; te <= de && te <= Te; ) {
      const Pe = E[te], F = P[te] = oe ? qo(P[te]) : ss(P[te]);
      if (Vu(Pe, F))
        m(
          Pe,
          F,
          W,
          null,
          J,
          Y,
          ae,
          re,
          oe
        );
      else
        break;
      te++;
    }
    for (; te <= de && te <= Te; ) {
      const Pe = E[de], F = P[Te] = oe ? qo(P[Te]) : ss(P[Te]);
      if (Vu(Pe, F))
        m(
          Pe,
          F,
          W,
          null,
          J,
          Y,
          ae,
          re,
          oe
        );
      else
        break;
      de--, Te--;
    }
    if (te > de) {
      if (te <= Te) {
        const Pe = Te + 1, F = Pe < De ? P[Pe].el : Q;
        for (; te <= Te; )
          m(
            null,
            P[te] = oe ? qo(P[te]) : ss(P[te]),
            W,
            F,
            J,
            Y,
            ae,
            re,
            oe
          ), te++;
      }
    } else if (te > Te)
      for (; te <= de; )
        Ve(E[te], J, Y, !0), te++;
    else {
      const Pe = te, F = te, X = /* @__PURE__ */ new Map();
      for (te = F; te <= Te; te++) {
        const wt = P[te] = oe ? qo(P[te]) : ss(P[te]);
        wt.key != null && X.set(wt.key, te);
      }
      let pe, _e = 0;
      const je = Te - F + 1;
      let xt = !1, Pt = 0;
      const Yt = new Array(je);
      for (te = 0; te < je; te++) Yt[te] = 0;
      for (te = Pe; te <= de; te++) {
        const wt = E[te];
        if (_e >= je) {
          Ve(wt, J, Y, !0);
          continue;
        }
        let pt;
        if (wt.key != null)
          pt = X.get(wt.key);
        else
          for (pe = F; pe <= Te; pe++)
            if (Yt[pe - F] === 0 && Vu(wt, P[pe])) {
              pt = pe;
              break;
            }
        pt === void 0 ? Ve(wt, J, Y, !0) : (Yt[pt - F] = te + 1, pt >= Pt ? Pt = pt : xt = !0, m(
          wt,
          P[pt],
          W,
          null,
          J,
          Y,
          ae,
          re,
          oe
        ), _e++);
      }
      const on = xt ? fX(Yt) : nf;
      for (pe = on.length - 1, te = je - 1; te >= 0; te--) {
        const wt = F + te, pt = P[wt], Vn = P[wt + 1], En = wt + 1 < De ? (
          // #13559, fallback to el placeholder for unresolved async component
          Vn.el || Vn.placeholder
        ) : Q;
        Yt[te] === 0 ? m(
          null,
          pt,
          W,
          En,
          J,
          Y,
          ae,
          re,
          oe
        ) : xt && (pe < 0 || te !== on[pe] ? Ie(pt, W, En, 2) : pe--);
      }
    }
  }, Ie = (E, P, W, Q, J = null) => {
    const { el: Y, type: ae, transition: re, children: oe, shapeFlag: te } = E;
    if (te & 6) {
      Ie(E.component.subTree, P, W, Q);
      return;
    }
    if (te & 128) {
      E.suspense.move(P, W, Q);
      return;
    }
    if (te & 64) {
      ae.move(E, P, W, Gt);
      return;
    }
    if (ae === Ln) {
      r(Y, P, W);
      for (let de = 0; de < oe.length; de++)
        Ie(oe[de], P, W, Q);
      r(E.anchor, P, W);
      return;
    }
    if (ae === kp) {
      k(E, P, W);
      return;
    }
    if (Q !== 2 && te & 1 && re)
      if (Q === 0)
        re.beforeEnter(Y), r(Y, P, W), Vr(() => re.enter(Y), J);
      else {
        const { leave: de, delayLeave: Te, afterLeave: Pe } = re, F = () => {
          E.ctx.isUnmounted ? i(Y) : r(Y, P, W);
        }, X = () => {
          de(Y, () => {
            F(), Pe && Pe();
          });
        };
        Te ? Te(Y, F, X) : X();
      }
    else
      r(Y, P, W);
  }, Ve = (E, P, W, Q = !1, J = !1) => {
    const {
      type: Y,
      props: ae,
      ref: re,
      children: oe,
      dynamicChildren: te,
      shapeFlag: De,
      patchFlag: de,
      dirs: Te,
      cacheIndex: Pe
    } = E;
    if (de === -2 && (J = !1), re != null && (fo(), cf(re, null, W, E, !0), po()), Pe != null && (P.renderCache[Pe] = void 0), De & 256) {
      P.ctx.deactivate(E);
      return;
    }
    const F = De & 1 && Te, X = !uf(E);
    let pe;
    if (X && (pe = ae && ae.onVnodeBeforeUnmount) && Zi(pe, P, E), De & 6)
      Ue(E.component, W, Q);
    else {
      if (De & 128) {
        E.suspense.unmount(W, Q);
        return;
      }
      F && Ll(E, null, P, "beforeUnmount"), De & 64 ? E.type.remove(
        E,
        P,
        W,
        Gt,
        Q
      ) : te && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !te.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (Y !== Ln || de > 0 && de & 64) ? et(
        te,
        P,
        W,
        !1,
        !0
      ) : (Y === Ln && de & 384 || !J && De & 16) && et(oe, P, W), Q && O(E);
    }
    (X && (pe = ae && ae.onVnodeUnmounted) || F) && Vr(() => {
      pe && Zi(pe, P, E), F && Ll(E, null, P, "unmounted");
    }, W);
  }, O = (E) => {
    const { type: P, el: W, anchor: Q, transition: J } = E;
    if (P === Ln) {
      dt(W, Q);
      return;
    }
    if (P === kp) {
      C(E);
      return;
    }
    const Y = () => {
      i(W), J && !J.persisted && J.afterLeave && J.afterLeave();
    };
    if (E.shapeFlag & 1 && J && !J.persisted) {
      const { leave: ae, delayLeave: re } = J, oe = () => ae(W, Y);
      re ? re(E.el, Y, oe) : oe();
    } else
      Y();
  }, dt = (E, P) => {
    let W;
    for (; E !== P; )
      W = f(E), i(E), E = W;
    i(P);
  }, Ue = (E, P, W) => {
    const {
      bum: Q,
      scope: J,
      job: Y,
      subTree: ae,
      um: re,
      m: oe,
      a: te,
      parent: De,
      slots: { __: de }
    } = E;
    N8(oe), N8(te), Q && I2(Q), De && Ze(de) && de.forEach((Te) => {
      De.renderCache[Te] = void 0;
    }), J.stop(), Y && (Y.flags |= 8, Ve(ae, E, P, W)), re && Vr(re, P), Vr(() => {
      E.isUnmounted = !0;
    }, P), P && P.pendingBranch && !P.isUnmounted && E.asyncDep && !E.asyncResolved && E.suspenseId === P.pendingId && (P.deps--, P.deps === 0 && P.resolve()), __VUE_PROD_DEVTOOLS__ && IJ(E);
  }, et = (E, P, W, Q = !1, J = !1, Y = 0) => {
    for (let ae = Y; ae < E.length; ae++)
      Ve(E[ae], P, W, Q, J);
  }, Mt = (E) => {
    if (E.shapeFlag & 6)
      return Mt(E.component.subTree);
    if (E.shapeFlag & 128)
      return E.suspense.next();
    const P = f(E.anchor || E.el), W = P && P[RJ];
    return W ? f(W) : P;
  };
  let Ft = !1;
  const sn = (E, P, W) => {
    E == null ? P._vnode && Ve(P._vnode, null, null, !0) : m(
      P._vnode || null,
      E,
      P,
      null,
      null,
      null,
      W
    ), P._vnode = E, Ft || (Ft = !0, T8(), hE(), Ft = !1);
  }, Gt = {
    p: m,
    um: Ve,
    m: Ie,
    r: O,
    mt: ie,
    mc: B,
    pc: ye,
    pbc: R,
    n: Mt,
    o: n
  };
  return {
    render: sn,
    hydrate: void 0,
    createApp: eX(sn)
  };
}
function _2({ type: n, props: e }, t) {
  return t === "svg" && n === "foreignObject" || t === "mathml" && n === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t;
}
function Bl({ effect: n, job: e }, t) {
  t ? (n.flags |= 32, e.flags |= 4) : (n.flags &= -33, e.flags &= -5);
}
function hX(n, e) {
  return (!n || n && !n.pendingBranch) && e && !e.persisted;
}
function IE(n, e, t = !1) {
  const r = n.children, i = e.children;
  if (Ze(r) && Ze(i))
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      let l = i[s];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = i[s] = qo(i[s]), l.el = o.el), !t && l.patchFlag !== -2 && IE(o, l)), l.type === Cd && (l.el = o.el), l.type === Na && !l.el && (l.el = o.el);
    }
}
function fX(n) {
  const e = n.slice(), t = [0];
  let r, i, s, o, l;
  const a = n.length;
  for (r = 0; r < a; r++) {
    const c = n[r];
    if (c !== 0) {
      if (i = t[t.length - 1], n[i] < c) {
        e[r] = i, t.push(r);
        continue;
      }
      for (s = 0, o = t.length - 1; s < o; )
        l = s + o >> 1, n[t[l]] < c ? s = l + 1 : o = l;
      c < n[t[s]] && (s > 0 && (e[r] = t[s - 1]), t[s] = r);
    }
  }
  for (s = t.length, o = t[s - 1]; s-- > 0; )
    t[s] = o, o = e[o];
  return t;
}
function DE(n) {
  const e = n.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : DE(e);
}
function N8(n) {
  if (n)
    for (let e = 0; e < n.length; e++)
      n[e].flags |= 8;
}
const dX = Symbol.for("v-scx"), pX = () => xp(dX);
function uu(n, e) {
  return wv(n, null, e);
}
function Ac(n, e, t) {
  return wv(n, e, t);
}
function wv(n, e, t = Lt) {
  const { immediate: r, deep: i, flush: s, once: o } = t, l = Xn({}, t), a = e && r || !e && s !== "post";
  let c;
  if (Yf) {
    if (s === "sync") {
      const d = pX();
      c = d.__watcherHandles || (d.__watcherHandles = []);
    } else if (!a) {
      const d = () => {
      };
      return d.stop = _i, d.resume = _i, d.pause = _i, d;
    }
  }
  const u = ar;
  l.call = (d, p, m) => Ms(d, u, p, m);
  let h = !1;
  s === "post" ? l.scheduler = (d) => {
    Vr(d, u && u.suspense);
  } : s !== "sync" && (h = !0, l.scheduler = (d, p) => {
    p ? d() : mv(d);
  }), l.augmentJob = (d) => {
    e && (d.flags |= 4), h && (d.flags |= 2, u && (d.id = u.uid, d.i = u));
  };
  const f = xJ(n, e, l);
  return Yf && (c ? c.push(f) : a && f()), f;
}
function mX(n, e, t) {
  const r = this.proxy, i = An(n) ? n.includes(".") ? NE(r, n) : () => r[n] : n.bind(r, r);
  let s;
  tt(e) ? s = e : (s = e.handler, t = e);
  const o = Md(this), l = wv(i, s.bind(r), t);
  return o(), l;
}
function NE(n, e) {
  const t = e.split(".");
  return () => {
    let r = n;
    for (let i = 0; i < t.length && r; i++)
      r = r[t[i]];
    return r;
  };
}
const gX = (n, e) => e === "modelValue" || e === "model-value" ? n.modelModifiers : n[`${e}Modifiers`] || n[`${bl(e)}Modifiers`] || n[`${Ha(e)}Modifiers`];
function yX(n, e, ...t) {
  if (n.isUnmounted) return;
  const r = n.vnode.props || Lt;
  let i = t;
  const s = e.startsWith("update:"), o = s && gX(r, e.slice(7));
  o && (o.trim && (i = t.map((u) => An(u) ? u.trim() : u)), o.number && (i = t.map(HY))), __VUE_PROD_DEVTOOLS__ && DJ(n, e, i);
  let l, a = r[l = E2(e)] || // also try camelCase event handler (#2249)
  r[l = E2(bl(e))];
  !a && s && (a = r[l = E2(Ha(e))]), a && Ms(
    a,
    n,
    6,
    i
  );
  const c = r[l + "Once"];
  if (c) {
    if (!n.emitted)
      n.emitted = {};
    else if (n.emitted[l])
      return;
    n.emitted[l] = !0, Ms(
      c,
      n,
      6,
      i
    );
  }
}
function RE(n, e, t = !1) {
  const r = e.emitsCache, i = r.get(n);
  if (i !== void 0)
    return i;
  const s = n.emits;
  let o = {}, l = !1;
  if (__VUE_OPTIONS_API__ && !tt(n)) {
    const a = (c) => {
      const u = RE(c, e, !0);
      u && (l = !0, Xn(o, u));
    };
    !t && e.mixins.length && e.mixins.forEach(a), n.extends && a(n.extends), n.mixins && n.mixins.forEach(a);
  }
  return !s && !l ? (un(n) && r.set(n, null), null) : (Ze(s) ? s.forEach((a) => o[a] = null) : Xn(o, s), un(n) && r.set(n, o), o);
}
function G1(n, e) {
  return !n || !V1(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), bt(n, e[0].toLowerCase() + e.slice(1)) || bt(n, Ha(e)) || bt(n, e));
}
function R8(n) {
  const {
    type: e,
    vnode: t,
    proxy: r,
    withProxy: i,
    propsOptions: [s],
    slots: o,
    attrs: l,
    emit: a,
    render: c,
    renderCache: u,
    props: h,
    data: f,
    setupState: d,
    ctx: p,
    inheritAttrs: m
  } = n, g = Dm(n);
  let b, w;
  try {
    if (t.shapeFlag & 4) {
      const C = i || r, M = C;
      b = ss(
        c.call(
          M,
          C,
          u,
          h,
          d,
          f,
          p
        )
      ), w = l;
    } else {
      const C = e;
      b = ss(
        C.length > 1 ? C(
          h,
          { attrs: l, slots: o, emit: a }
        ) : C(
          h,
          null
        )
      ), w = e.props ? l : bX(l);
    }
  } catch (C) {
    j1(C, n, 1), b = Ni(Na);
  }
  let k = b;
  if (w && m !== !1) {
    const C = Object.keys(w), { shapeFlag: M } = k;
    C.length && M & 7 && (s && C.some(tv) && (w = vX(
      w,
      s
    )), k = Wc(k, w, !1, !0));
  }
  return t.dirs && (k = Wc(k, null, !1, !0), k.dirs = k.dirs ? k.dirs.concat(t.dirs) : t.dirs), t.transition && yv(k, t.transition), b = k, Dm(g), b;
}
const bX = (n) => {
  let e;
  for (const t in n)
    (t === "class" || t === "style" || V1(t)) && ((e || (e = {}))[t] = n[t]);
  return e;
}, vX = (n, e) => {
  const t = {};
  for (const r in n)
    (!tv(r) || !(r.slice(9) in e)) && (t[r] = n[r]);
  return t;
};
function wX(n, e, t) {
  const { props: r, children: i, component: s } = n, { props: o, children: l, patchFlag: a } = e, c = s.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (t && a >= 0) {
    if (a & 1024)
      return !0;
    if (a & 16)
      return r ? P8(r, o, c) : !!o;
    if (a & 8) {
      const u = e.dynamicProps;
      for (let h = 0; h < u.length; h++) {
        const f = u[h];
        if (o[f] !== r[f] && !G1(c, f))
          return !0;
      }
    }
  } else
    return (i || l) && (!l || !l.$stable) ? !0 : r === o ? !1 : r ? o ? P8(r, o, c) : !0 : !!o;
  return !1;
}
function P8(n, e, t) {
  const r = Object.keys(e);
  if (r.length !== Object.keys(n).length)
    return !0;
  for (let i = 0; i < r.length; i++) {
    const s = r[i];
    if (e[s] !== n[s] && !G1(t, s))
      return !0;
  }
  return !1;
}
function xX({ vnode: n, parent: e }, t) {
  for (; e; ) {
    const r = e.subTree;
    if (r.suspense && r.suspense.activeBranch === n && (r.el = n.el), r === n)
      (n = e.vnode).el = t, e = e.parent;
    else
      break;
  }
}
const PE = (n) => n.__isSuspense;
function kX(n, e) {
  e && e.pendingBranch ? Ze(n) ? e.effects.push(...n) : e.effects.push(n) : MJ(n);
}
const Ln = Symbol.for("v-fgt"), Cd = Symbol.for("v-txt"), Na = Symbol.for("v-cmt"), kp = Symbol.for("v-stc");
let nl = null, xv = 1;
function _8(n, e = !1) {
  xv += n, n < 0 && nl && e && (nl.hasOnce = !0);
}
function Rm(n) {
  return n ? n.__v_isVNode === !0 : !1;
}
function Vu(n, e) {
  return n.type === e.type && n.key === e.key;
}
const _E = ({ key: n }) => n ?? null, Sp = ({
  ref: n,
  ref_key: e,
  ref_for: t
}) => (typeof n == "number" && (n = "" + n), n != null ? An(n) || Jn(n) || tt(n) ? { i: ps, r: n, k: e, f: !!t } : n : null);
function SX(n, e = null, t = null, r = 0, i = null, s = n === Ln ? 0 : 1, o = !1, l = !1) {
  const a = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n,
    props: e,
    key: e && _E(e),
    ref: e && Sp(e),
    scopeId: mE,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: r,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: ps
  };
  return l ? (kv(a, t), s & 128 && n.normalize(a)) : t && (a.shapeFlag |= An(t) ? 8 : 16), xv > 0 && // avoid a block node from tracking itself
  !o && // has current parent block
  nl && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (a.patchFlag > 0 || s & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  a.patchFlag !== 32 && nl.push(a), a;
}
const Ni = CX;
function CX(n, e = null, t = null, r = 0, i = null, s = !1) {
  if ((!n || n === UJ) && (n = Na), Rm(n)) {
    const l = Wc(
      n,
      e,
      !0
      /* mergeRef: true */
    );
    return t && kv(l, t), xv > 0 && !s && nl && (l.shapeFlag & 6 ? nl[nl.indexOf(n)] = l : nl.push(l)), l.patchFlag = -2, l;
  }
  if (LX(n) && (n = n.__vccOpts), e) {
    e = MX(e);
    let { class: l, style: a } = e;
    l && !An(l) && (e.class = sv(l)), un(a) && (pv(a) && !Ze(a) && (a = Xn({}, a)), e.style = iv(a));
  }
  const o = An(n) ? 1 : PE(n) ? 128 : PJ(n) ? 64 : un(n) ? 4 : tt(n) ? 2 : 0;
  return SX(
    n,
    e,
    t,
    r,
    i,
    o,
    s,
    !0
  );
}
function MX(n) {
  return n ? pv(n) || CE(n) ? Xn({}, n) : n : null;
}
function Wc(n, e, t = !1, r = !1) {
  const { props: i, ref: s, patchFlag: o, children: l, transition: a } = n, c = e ? AX(i || {}, e) : i, u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n.type,
    props: c,
    key: c && _E(c),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && s ? Ze(s) ? s.concat(Sp(e)) : [s, Sp(e)] : Sp(e)
    ) : s,
    scopeId: n.scopeId,
    slotScopeIds: n.slotScopeIds,
    children: l,
    target: n.target,
    targetStart: n.targetStart,
    targetAnchor: n.targetAnchor,
    staticCount: n.staticCount,
    shapeFlag: n.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && n.type !== Ln ? o === -1 ? 16 : o | 16 : o,
    dynamicProps: n.dynamicProps,
    dynamicChildren: n.dynamicChildren,
    appContext: n.appContext,
    dirs: n.dirs,
    transition: a,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: n.component,
    suspense: n.suspense,
    ssContent: n.ssContent && Wc(n.ssContent),
    ssFallback: n.ssFallback && Wc(n.ssFallback),
    placeholder: n.placeholder,
    el: n.el,
    anchor: n.anchor,
    ctx: n.ctx,
    ce: n.ce
  };
  return a && r && yv(
    u,
    a.clone(u)
  ), u;
}
function TX(n = " ", e = 0) {
  return Ni(Cd, null, n, e);
}
function ss(n) {
  return n == null || typeof n == "boolean" ? Ni(Na) : Ze(n) ? Ni(
    Ln,
    null,
    // #3666, avoid reference pollution when reusing vnode
    n.slice()
  ) : Rm(n) ? qo(n) : Ni(Cd, null, String(n));
}
function qo(n) {
  return n.el === null && n.patchFlag !== -1 || n.memo ? n : Wc(n);
}
function kv(n, e) {
  let t = 0;
  const { shapeFlag: r } = n;
  if (e == null)
    e = null;
  else if (Ze(e))
    t = 16;
  else if (typeof e == "object")
    if (r & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), kv(n, i()), i._c && (i._d = !0));
      return;
    } else {
      t = 32;
      const i = e._;
      !i && !CE(e) ? e._ctx = ps : i === 3 && ps && (ps.slots._ === 1 ? e._ = 1 : (e._ = 2, n.patchFlag |= 1024));
    }
  else tt(e) ? (e = { default: e, _ctx: ps }, t = 32) : (e = String(e), r & 64 ? (t = 16, e = [TX(e)]) : t = 8);
  n.children = e, n.shapeFlag |= t;
}
function AX(...n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = n[t];
    for (const i in r)
      if (i === "class")
        e.class !== r.class && (e.class = sv([e.class, r.class]));
      else if (i === "style")
        e.style = iv([e.style, r.style]);
      else if (V1(i)) {
        const s = e[i], o = r[i];
        o && s !== o && !(Ze(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o);
      } else i !== "" && (e[i] = r[i]);
  }
  return e;
}
function Zi(n, e, t, r = null) {
  Ms(n, e, 7, [
    t,
    r
  ]);
}
const OX = xE();
let EX = 0;
function IX(n, e, t) {
  const r = n.type, i = (e ? e.appContext : n.appContext) || OX, s = {
    uid: EX++,
    vnode: n,
    type: r,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new KY(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: TE(r, i),
    emitsOptions: RE(r, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Lt,
    // inheritAttrs
    inheritAttrs: r.inheritAttrs,
    // state
    ctx: Lt,
    data: Lt,
    props: Lt,
    attrs: Lt,
    slots: Lt,
    refs: Lt,
    setupState: Lt,
    setupContext: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return s.ctx = { _: s }, s.root = e ? e.root : s, s.emit = yX.bind(null, s), n.ce && n.ce(s), s;
}
let ar = null;
const DX = () => ar || ps;
let Pm, d5;
{
  const n = pa(), e = (t, r) => {
    let i;
    return (i = n[t]) || (i = n[t] = []), i.push(r), (s) => {
      i.length > 1 ? i.forEach((o) => o(s)) : i[0](s);
    };
  };
  Pm = e(
    "__VUE_INSTANCE_SETTERS__",
    (t) => ar = t
  ), d5 = e(
    "__VUE_SSR_SETTERS__",
    (t) => Yf = t
  );
}
const Md = (n) => {
  const e = ar;
  return Pm(n), n.scope.on(), () => {
    n.scope.off(), Pm(e);
  };
}, L8 = () => {
  ar && ar.scope.off(), Pm(null);
};
function LE(n) {
  return n.vnode.shapeFlag & 4;
}
let Yf = !1;
function NX(n, e = !1, t = !1) {
  e && d5(e);
  const { props: r, children: i } = n.vnode, s = LE(n);
  nX(n, r, s, e), oX(n, i, t || e);
  const o = s ? RX(n, e) : void 0;
  return e && d5(!1), o;
}
function RX(n, e) {
  const t = n.type;
  n.accessCache = /* @__PURE__ */ Object.create(null), n.proxy = new Proxy(n.ctx, KJ);
  const { setup: r } = t;
  if (r) {
    fo();
    const i = n.setupContext = r.length > 1 ? _X(n) : null, s = Md(n), o = xd(
      r,
      n,
      0,
      [
        n.props,
        i
      ]
    ), l = qO(o);
    if (po(), s(), (l || n.sp) && !uf(n) && gE(n), l) {
      if (o.then(L8, L8), e)
        return o.then((a) => {
          B8(n, a);
        }).catch((a) => {
          j1(a, n, 0);
        });
      n.asyncDep = o;
    } else
      B8(n, o);
  } else
    BE(n);
}
function B8(n, e, t) {
  tt(e) ? n.type.__ssrInlineRender ? n.ssrRender = e : n.render = e : un(e) && (__VUE_PROD_DEVTOOLS__ && (n.devtoolsRawSetupState = e), n.setupState = aE(e)), BE(n);
}
function BE(n, e, t) {
  const r = n.type;
  if (n.render || (n.render = r.render || _i), __VUE_OPTIONS_API__) {
    const i = Md(n);
    fo();
    try {
      GJ(n);
    } finally {
      po(), i();
    }
  }
}
const PX = {
  get(n, e) {
    return jn(n, "get", ""), n[e];
  }
};
function _X(n) {
  const e = (t) => {
    n.exposed = t || {};
  };
  return {
    attrs: new Proxy(n.attrs, PX),
    slots: n.slots,
    emit: n.emit,
    expose: e
  };
}
function Sv(n) {
  return n.exposed ? n.exposeProxy || (n.exposeProxy = new Proxy(aE(pJ(n.exposed)), {
    get(e, t) {
      if (t in e)
        return e[t];
      if (t in hf)
        return hf[t](n);
    },
    has(e, t) {
      return t in e || t in hf;
    }
  })) : n.proxy;
}
function LX(n) {
  return tt(n) && "__vccOpts" in n;
}
const Ra = (n, e) => vJ(n, e, Yf);
function j(n, e, t) {
  const r = arguments.length;
  return r === 2 ? un(e) && !Ze(e) ? Rm(e) ? Ni(n, null, [e]) : Ni(n, e) : Ni(n, null, e) : (r > 3 ? t = Array.prototype.slice.call(arguments, 2) : r === 3 && Rm(t) && (t = [t]), Ni(n, e, t));
}
const z8 = "3.5.18";
/**
* @vue/runtime-dom v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let p5;
const F8 = typeof window < "u" && window.trustedTypes;
if (F8)
  try {
    p5 = /* @__PURE__ */ F8.createPolicy("vue", {
      createHTML: (n) => n
    });
  } catch {
  }
const zE = p5 ? (n) => p5.createHTML(n) : (n) => n, BX = "http://www.w3.org/2000/svg", zX = "http://www.w3.org/1998/Math/MathML", Ks = typeof document < "u" ? document : null, H8 = Ks && /* @__PURE__ */ Ks.createElement("template"), FX = {
  insert: (n, e, t) => {
    e.insertBefore(n, t || null);
  },
  remove: (n) => {
    const e = n.parentNode;
    e && e.removeChild(n);
  },
  createElement: (n, e, t, r) => {
    const i = e === "svg" ? Ks.createElementNS(BX, n) : e === "mathml" ? Ks.createElementNS(zX, n) : t ? Ks.createElement(n, { is: t }) : Ks.createElement(n);
    return n === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple), i;
  },
  createText: (n) => Ks.createTextNode(n),
  createComment: (n) => Ks.createComment(n),
  setText: (n, e) => {
    n.nodeValue = e;
  },
  setElementText: (n, e) => {
    n.textContent = e;
  },
  parentNode: (n) => n.parentNode,
  nextSibling: (n) => n.nextSibling,
  querySelector: (n) => Ks.querySelector(n),
  setScopeId(n, e) {
    n.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(n, e, t, r, i, s) {
    const o = t ? t.previousSibling : e.lastChild;
    if (i && (i === s || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), t), !(i === s || !(i = i.nextSibling)); )
        ;
    else {
      H8.innerHTML = zE(
        r === "svg" ? `<svg>${n}</svg>` : r === "mathml" ? `<math>${n}</math>` : n
      );
      const l = H8.content;
      if (r === "svg" || r === "mathml") {
        const a = l.firstChild;
        for (; a.firstChild; )
          l.appendChild(a.firstChild);
        l.removeChild(a);
      }
      e.insertBefore(l, t);
    }
    return [
      // first
      o ? o.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
}, HX = Symbol("_vtc");
function $X(n, e, t) {
  const r = n[HX];
  r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? n.removeAttribute("class") : t ? n.setAttribute("class", e) : n.className = e;
}
const $8 = Symbol("_vod"), VX = Symbol("_vsh"), qX = Symbol(""), WX = /(^|;)\s*display\s*:/;
function jX(n, e, t) {
  const r = n.style, i = An(t);
  let s = !1;
  if (t && !i) {
    if (e)
      if (An(e))
        for (const o of e.split(";")) {
          const l = o.slice(0, o.indexOf(":")).trim();
          t[l] == null && Cp(r, l, "");
        }
      else
        for (const o in e)
          t[o] == null && Cp(r, o, "");
    for (const o in t)
      o === "display" && (s = !0), Cp(r, o, t[o]);
  } else if (i) {
    if (e !== t) {
      const o = r[qX];
      o && (t += ";" + o), r.cssText = t, s = WX.test(t);
    }
  } else e && n.removeAttribute("style");
  $8 in n && (n[$8] = s ? r.display : "", n[VX] && (r.display = "none"));
}
const V8 = /\s*!important$/;
function Cp(n, e, t) {
  if (Ze(t))
    t.forEach((r) => Cp(n, e, r));
  else if (t == null && (t = ""), e.startsWith("--"))
    n.setProperty(e, t);
  else {
    const r = UX(n, e);
    V8.test(t) ? n.setProperty(
      Ha(r),
      t.replace(V8, ""),
      "important"
    ) : n[r] = t;
  }
}
const q8 = ["Webkit", "Moz", "ms"], L2 = {};
function UX(n, e) {
  const t = L2[e];
  if (t)
    return t;
  let r = bl(e);
  if (r !== "filter" && r in n)
    return L2[e] = r;
  r = WO(r);
  for (let i = 0; i < q8.length; i++) {
    const s = q8[i] + r;
    if (s in n)
      return L2[e] = s;
  }
  return e;
}
const W8 = "http://www.w3.org/1999/xlink";
function j8(n, e, t, r, i, s = UY(e)) {
  r && e.startsWith("xlink:") ? t == null ? n.removeAttributeNS(W8, e.slice(6, e.length)) : n.setAttributeNS(W8, e, t) : t == null || s && !jO(t) ? n.removeAttribute(e) : n.setAttribute(
    e,
    s ? "" : cu(t) ? String(t) : t
  );
}
function U8(n, e, t, r, i) {
  if (e === "innerHTML" || e === "textContent") {
    t != null && (n[e] = e === "innerHTML" ? zE(t) : t);
    return;
  }
  const s = n.tagName;
  if (e === "value" && s !== "PROGRESS" && // custom elements may use _value internally
  !s.includes("-")) {
    const l = s === "OPTION" ? n.getAttribute("value") || "" : n.value, a = t == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      n.type === "checkbox" ? "on" : ""
    ) : String(t);
    (l !== a || !("_value" in n)) && (n.value = a), t == null && n.removeAttribute(e), n._value = t;
    return;
  }
  let o = !1;
  if (t === "" || t == null) {
    const l = typeof n[e];
    l === "boolean" ? t = jO(t) : t == null && l === "string" ? (t = "", o = !0) : l === "number" && (t = 0, o = !0);
  }
  try {
    n[e] = t;
  } catch {
  }
  o && n.removeAttribute(i || e);
}
function KX(n, e, t, r) {
  n.addEventListener(e, t, r);
}
function GX(n, e, t, r) {
  n.removeEventListener(e, t, r);
}
const K8 = Symbol("_vei");
function YX(n, e, t, r, i = null) {
  const s = n[K8] || (n[K8] = {}), o = s[e];
  if (r && o)
    o.value = r;
  else {
    const [l, a] = JX(e);
    if (r) {
      const c = s[e] = QX(
        r,
        i
      );
      KX(n, l, c, a);
    } else o && (GX(n, l, o, a), s[e] = void 0);
  }
}
const G8 = /(?:Once|Passive|Capture)$/;
function JX(n) {
  let e;
  if (G8.test(n)) {
    e = {};
    let r;
    for (; r = n.match(G8); )
      n = n.slice(0, n.length - r[0].length), e[r[0].toLowerCase()] = !0;
  }
  return [n[2] === ":" ? n.slice(3) : Ha(n.slice(2)), e];
}
let B2 = 0;
const XX = /* @__PURE__ */ Promise.resolve(), ZX = () => B2 || (XX.then(() => B2 = 0), B2 = Date.now());
function QX(n, e) {
  const t = (r) => {
    if (!r._vts)
      r._vts = Date.now();
    else if (r._vts <= t.attached)
      return;
    Ms(
      eZ(r, t.value),
      e,
      5,
      [r]
    );
  };
  return t.value = n, t.attached = ZX(), t;
}
function eZ(n, e) {
  if (Ze(e)) {
    const t = n.stopImmediatePropagation;
    return n.stopImmediatePropagation = () => {
      t.call(n), n._stopped = !0;
    }, e.map(
      (r) => (i) => !i._stopped && r && r(i)
    );
  } else
    return e;
}
const Y8 = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // lowercase letter
n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123, tZ = (n, e, t, r, i, s) => {
  const o = i === "svg";
  e === "class" ? $X(n, r, o) : e === "style" ? jX(n, t, r) : V1(e) ? tv(e) || YX(n, e, t, r, s) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : nZ(n, e, r, o)) ? (U8(n, e, r), !n.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && j8(n, e, r, o, s, e !== "value")) : /* #11081 force set props for possible async custom element */ n._isVueCE && (/[A-Z]/.test(e) || !An(r)) ? U8(n, bl(e), r, s, e) : (e === "true-value" ? n._trueValue = r : e === "false-value" && (n._falseValue = r), j8(n, e, r, o));
};
function nZ(n, e, t, r) {
  if (r)
    return !!(e === "innerHTML" || e === "textContent" || e in n && Y8(e) && tt(t));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "form" || e === "list" && n.tagName === "INPUT" || e === "type" && n.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = n.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return Y8(e) && An(t) ? !1 : e in n;
}
const rZ = /* @__PURE__ */ Xn({ patchProp: tZ }, FX);
let J8;
function iZ() {
  return J8 || (J8 = cX(rZ));
}
const Ui = (...n) => {
  const e = iZ().createApp(...n), { mount: t } = e;
  return e.mount = (r) => {
    const i = oZ(r);
    if (!i) return;
    const s = e._component;
    !tt(s) && !s.render && !s.template && (s.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
    const o = t(i, !1, sZ(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o;
  }, e;
};
function sZ(n) {
  if (n instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && n instanceof MathMLElement)
    return "mathml";
}
function oZ(n) {
  return An(n) ? document.querySelector(n) : n;
}
function lZ(n) {
  const e = Ct(
    {},
    `${n}_SLASH_SPEC`
  ), t = kn((i) => {
    const s = i.get(e.key);
    return new Ut({
      key: new en(`${n}_SLASH`),
      ...s
    });
  }), r = [e, t];
  return r.key = e.key, r.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Ctx<slashSpec>|${n}`
  }, t.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Prose<slash>|${n}`
  }, r;
}
class aZ {
  constructor(e) {
    this.#t = !1, this.onShow = () => {
    }, this.onHide = () => {
    }, this.#c = (t, r) => {
      const { state: i, composing: s } = t, { selection: o, doc: l } = i, { ranges: a } = o, c = Math.min(...a.map((d) => d.$from.pos)), u = Math.max(...a.map((d) => d.$to.pos)), h = r && r.doc.eq(l) && r.selection.eq(o);
      if (this.#t || ((this.#n ?? t.dom.parentElement ?? document.body).appendChild(this.element), this.#t = !0), s || h) return;
      if (!this.#s(t, r)) {
        this.hide();
        return;
      }
      Vi({
        getBoundingClientRect: () => b1(t, c, u)
      }, this.element, {
        placement: "bottom-start",
        middleware: [Tm(), yl(this.#l), ...this.#e],
        ...this.#r
      }).then(({ x: d, y: p }) => {
        Object.assign(this.element.style, {
          left: `${d}px`,
          top: `${p}px`
        });
      }).catch(console.error), this.show();
    }, this.update = (t, r) => {
      this.#o(t, r);
    }, this.getContent = (t, r = (i) => i.type.name === "paragraph") => {
      const { selection: i } = t.state, { empty: s, $from: o } = i, l = t.state.selection instanceof Ee;
      if (typeof document > "u") return;
      const a = this.element.contains(document.activeElement), c = !t.hasFocus() && !a, u = !t.editable, f = !bV(r)(t.state.selection);
      if (!(c || u || !s || !l || f))
        return o.parent.textBetween(
          Math.max(0, o.parentOffset - 500),
          o.parentOffset,
          void 0,
          "￼"
        );
    }, this.destroy = () => {
      this.#o.cancel();
    }, this.show = () => {
      this.element.dataset.show = "true", this.onShow();
    }, this.hide = () => {
      this.element.dataset.show = "false", this.onHide();
    }, this.element = e.content, this.#a = e.debounce ?? 200, this.#s = e.shouldShow ?? this.#u, this.#i = e.trigger ?? "/", this.#l = e.offset, this.#e = e.middleware ?? [], this.#r = e.floatingUIOptions ?? {}, this.#n = e.root, this.#o = e1(this.#c, this.#a);
  }
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  /// @internal
  #n;
  /// @internal
  #a;
  /// @internal
  #i;
  /// @internal
  #s;
  /// @internal
  #o;
  /// The offset to get the block. Default is 0.
  #l;
  #c;
  /// @internal
  #u(e) {
    const t = this.getContent(e);
    if (!t) return !1;
    const r = t.at(-1);
    return r ? Array.isArray(this.#i) ? this.#i.includes(r) : this.#i === r : !1;
  }
}
function FE(n) {
  var e, t, r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var i = n.length;
    for (e = 0; e < i; e++) n[e] && (t = FE(n[e])) && (r && (r += " "), r += t);
  } else for (t in n) n[t] && (r && (r += " "), r += t);
  return r;
}
function Hn() {
  for (var n, e, t = 0, r = "", i = arguments.length; t < i; t++) (n = arguments[t]) && (e = FE(n)) && (r && (r += " "), r += e);
  return r;
}
/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
const {
  entries: HE,
  setPrototypeOf: X8,
  isFrozen: cZ,
  getPrototypeOf: uZ,
  getOwnPropertyDescriptor: hZ
} = Object;
let {
  freeze: gr,
  seal: wi,
  create: $E
} = Object, {
  apply: m5,
  construct: g5
} = typeof Reflect < "u" && Reflect;
gr || (gr = function(e) {
  return e;
});
wi || (wi = function(e) {
  return e;
});
m5 || (m5 = function(e, t, r) {
  return e.apply(t, r);
});
g5 || (g5 = function(e, t) {
  return new e(...t);
});
const b0 = yr(Array.prototype.forEach), fZ = yr(Array.prototype.lastIndexOf), Z8 = yr(Array.prototype.pop), qu = yr(Array.prototype.push), dZ = yr(Array.prototype.splice), Mp = yr(String.prototype.toLowerCase), z2 = yr(String.prototype.toString), Q8 = yr(String.prototype.match), Wu = yr(String.prototype.replace), pZ = yr(String.prototype.indexOf), mZ = yr(String.prototype.trim), Ei = yr(Object.prototype.hasOwnProperty), tr = yr(RegExp.prototype.test), ju = gZ(TypeError);
function yr(n) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      r[i - 1] = arguments[i];
    return m5(n, e, r);
  };
}
function gZ(n) {
  return function() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return g5(n, t);
  };
}
function ot(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Mp;
  X8 && X8(n, null);
  let r = e.length;
  for (; r--; ) {
    let i = e[r];
    if (typeof i == "string") {
      const s = t(i);
      s !== i && (cZ(e) || (e[r] = s), i = s);
    }
    n[i] = !0;
  }
  return n;
}
function yZ(n) {
  for (let e = 0; e < n.length; e++)
    Ei(n, e) || (n[e] = null);
  return n;
}
function qs(n) {
  const e = $E(null);
  for (const [t, r] of HE(n))
    Ei(n, t) && (Array.isArray(r) ? e[t] = yZ(r) : r && typeof r == "object" && r.constructor === Object ? e[t] = qs(r) : e[t] = r);
  return e;
}
function Uu(n, e) {
  for (; n !== null; ) {
    const r = hZ(n, e);
    if (r) {
      if (r.get)
        return yr(r.get);
      if (typeof r.value == "function")
        return yr(r.value);
    }
    n = uZ(n);
  }
  function t() {
    return null;
  }
  return t;
}
const ek = gr(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), F2 = gr(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), H2 = gr(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), bZ = gr(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), $2 = gr(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), vZ = gr(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), tk = gr(["#text"]), nk = gr(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), V2 = gr(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), rk = gr(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), v0 = gr(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), wZ = wi(/\{\{[\w\W]*|[\w\W]*\}\}/gm), xZ = wi(/<%[\w\W]*|[\w\W]*%>/gm), kZ = wi(/\$\{[\w\W]*/gm), SZ = wi(/^data-[\-\w.\u00B7-\uFFFF]+$/), CZ = wi(/^aria-[\-\w]+$/), VE = wi(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), MZ = wi(/^(?:\w+script|data):/i), TZ = wi(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), qE = wi(/^html$/i), AZ = wi(/^[a-z][.\w]*(-[.\w]+)+$/i);
var ik = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: CZ,
  ATTR_WHITESPACE: TZ,
  CUSTOM_ELEMENT: AZ,
  DATA_ATTR: SZ,
  DOCTYPE_NAME: qE,
  ERB_EXPR: xZ,
  IS_ALLOWED_URI: VE,
  IS_SCRIPT_OR_DATA: MZ,
  MUSTACHE_EXPR: wZ,
  TMPLIT_EXPR: kZ
});
const Ku = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, OZ = function() {
  return typeof window > "u" ? null : window;
}, EZ = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let r = null;
  const i = "data-tt-policy-suffix";
  t && t.hasAttribute(i) && (r = t.getAttribute(i));
  const s = "dompurify" + (r ? "#" + r : "");
  try {
    return e.createPolicy(s, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
}, sk = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function WE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : OZ();
  const e = (Re) => WE(Re);
  if (e.version = "3.2.6", e.removed = [], !n || !n.document || n.document.nodeType !== Ku.document || !n.Element)
    return e.isSupported = !1, e;
  let {
    document: t
  } = n;
  const r = t, i = r.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: o,
    Node: l,
    Element: a,
    NodeFilter: c,
    NamedNodeMap: u = n.NamedNodeMap || n.MozNamedAttrMap,
    HTMLFormElement: h,
    DOMParser: f,
    trustedTypes: d
  } = n, p = a.prototype, m = Uu(p, "cloneNode"), g = Uu(p, "remove"), b = Uu(p, "nextSibling"), w = Uu(p, "childNodes"), k = Uu(p, "parentNode");
  if (typeof o == "function") {
    const Re = t.createElement("template");
    Re.content && Re.content.ownerDocument && (t = Re.content.ownerDocument);
  }
  let C, M = "";
  const {
    implementation: T,
    createNodeIterator: N,
    createDocumentFragment: B,
    getElementsByTagName: $
  } = t, {
    importNode: R
  } = r;
  let V = sk();
  e.isSupported = typeof HE == "function" && typeof k == "function" && T && T.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: z,
    ERB_EXPR: ue,
    TMPLIT_EXPR: ie,
    DATA_ATTR: he,
    ARIA_ATTR: Se,
    IS_SCRIPT_OR_DATA: ge,
    ATTR_WHITESPACE: ye,
    CUSTOM_ELEMENT: ze
  } = ik;
  let {
    IS_ALLOWED_URI: I
  } = ik, Ie = null;
  const Ve = ot({}, [...ek, ...F2, ...H2, ...$2, ...tk]);
  let O = null;
  const dt = ot({}, [...nk, ...V2, ...rk, ...v0]);
  let Ue = Object.seal($E(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), et = null, Mt = null, Ft = !0, sn = !0, Gt = !1, _r = !0, E = !1, P = !0, W = !1, Q = !1, J = !1, Y = !1, ae = !1, re = !1, oe = !0, te = !1;
  const De = "user-content-";
  let de = !0, Te = !1, Pe = {}, F = null;
  const X = ot({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let pe = null;
  const _e = ot({}, ["audio", "video", "img", "source", "image", "track"]);
  let je = null;
  const xt = ot({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Pt = "http://www.w3.org/1998/Math/MathML", Yt = "http://www.w3.org/2000/svg", on = "http://www.w3.org/1999/xhtml";
  let wt = on, pt = !1, Vn = null;
  const En = ot({}, [Pt, Yt, on], z2);
  let Nl = ot({}, ["mi", "mo", "mn", "ms", "mtext"]), Rl = ot({}, ["annotation-xml"]);
  const Fd = ot({}, ["title", "style", "font", "a", "script"]);
  let Ao = null;
  const Hd = ["application/xhtml+xml", "text/html"], $d = "text/html";
  let ln = null, _s = null;
  const Vd = t.createElement("form"), vu = function(L) {
    return L instanceof RegExp || L instanceof Function;
  }, Wa = function() {
    let L = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(_s && _s === L)) {
      if ((!L || typeof L != "object") && (L = {}), L = qs(L), Ao = // eslint-disable-next-line unicorn/prefer-includes
      Hd.indexOf(L.PARSER_MEDIA_TYPE) === -1 ? $d : L.PARSER_MEDIA_TYPE, ln = Ao === "application/xhtml+xml" ? z2 : Mp, Ie = Ei(L, "ALLOWED_TAGS") ? ot({}, L.ALLOWED_TAGS, ln) : Ve, O = Ei(L, "ALLOWED_ATTR") ? ot({}, L.ALLOWED_ATTR, ln) : dt, Vn = Ei(L, "ALLOWED_NAMESPACES") ? ot({}, L.ALLOWED_NAMESPACES, z2) : En, je = Ei(L, "ADD_URI_SAFE_ATTR") ? ot(qs(xt), L.ADD_URI_SAFE_ATTR, ln) : xt, pe = Ei(L, "ADD_DATA_URI_TAGS") ? ot(qs(_e), L.ADD_DATA_URI_TAGS, ln) : _e, F = Ei(L, "FORBID_CONTENTS") ? ot({}, L.FORBID_CONTENTS, ln) : X, et = Ei(L, "FORBID_TAGS") ? ot({}, L.FORBID_TAGS, ln) : qs({}), Mt = Ei(L, "FORBID_ATTR") ? ot({}, L.FORBID_ATTR, ln) : qs({}), Pe = Ei(L, "USE_PROFILES") ? L.USE_PROFILES : !1, Ft = L.ALLOW_ARIA_ATTR !== !1, sn = L.ALLOW_DATA_ATTR !== !1, Gt = L.ALLOW_UNKNOWN_PROTOCOLS || !1, _r = L.ALLOW_SELF_CLOSE_IN_ATTR !== !1, E = L.SAFE_FOR_TEMPLATES || !1, P = L.SAFE_FOR_XML !== !1, W = L.WHOLE_DOCUMENT || !1, Y = L.RETURN_DOM || !1, ae = L.RETURN_DOM_FRAGMENT || !1, re = L.RETURN_TRUSTED_TYPE || !1, J = L.FORCE_BODY || !1, oe = L.SANITIZE_DOM !== !1, te = L.SANITIZE_NAMED_PROPS || !1, de = L.KEEP_CONTENT !== !1, Te = L.IN_PLACE || !1, I = L.ALLOWED_URI_REGEXP || VE, wt = L.NAMESPACE || on, Nl = L.MATHML_TEXT_INTEGRATION_POINTS || Nl, Rl = L.HTML_INTEGRATION_POINTS || Rl, Ue = L.CUSTOM_ELEMENT_HANDLING || {}, L.CUSTOM_ELEMENT_HANDLING && vu(L.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ue.tagNameCheck = L.CUSTOM_ELEMENT_HANDLING.tagNameCheck), L.CUSTOM_ELEMENT_HANDLING && vu(L.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ue.attributeNameCheck = L.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), L.CUSTOM_ELEMENT_HANDLING && typeof L.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Ue.allowCustomizedBuiltInElements = L.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), E && (sn = !1), ae && (Y = !0), Pe && (Ie = ot({}, tk), O = [], Pe.html === !0 && (ot(Ie, ek), ot(O, nk)), Pe.svg === !0 && (ot(Ie, F2), ot(O, V2), ot(O, v0)), Pe.svgFilters === !0 && (ot(Ie, H2), ot(O, V2), ot(O, v0)), Pe.mathMl === !0 && (ot(Ie, $2), ot(O, rk), ot(O, v0))), L.ADD_TAGS && (Ie === Ve && (Ie = qs(Ie)), ot(Ie, L.ADD_TAGS, ln)), L.ADD_ATTR && (O === dt && (O = qs(O)), ot(O, L.ADD_ATTR, ln)), L.ADD_URI_SAFE_ATTR && ot(je, L.ADD_URI_SAFE_ATTR, ln), L.FORBID_CONTENTS && (F === X && (F = qs(F)), ot(F, L.FORBID_CONTENTS, ln)), de && (Ie["#text"] = !0), W && ot(Ie, ["html", "head", "body"]), Ie.table && (ot(Ie, ["tbody"]), delete et.tbody), L.TRUSTED_TYPES_POLICY) {
        if (typeof L.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw ju('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof L.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw ju('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        C = L.TRUSTED_TYPES_POLICY, M = C.createHTML("");
      } else
        C === void 0 && (C = EZ(d, i)), C !== null && typeof M == "string" && (M = C.createHTML(""));
      gr && gr(L), _s = L;
    }
  }, wu = ot({}, [...F2, ...H2, ...bZ]), xu = ot({}, [...$2, ...vZ]), qd = function(L) {
    let le = k(L);
    (!le || !le.tagName) && (le = {
      namespaceURI: wt,
      tagName: "template"
    });
    const Oe = Mp(L.tagName), Tt = Mp(le.tagName);
    return Vn[L.namespaceURI] ? L.namespaceURI === Yt ? le.namespaceURI === on ? Oe === "svg" : le.namespaceURI === Pt ? Oe === "svg" && (Tt === "annotation-xml" || Nl[Tt]) : !!wu[Oe] : L.namespaceURI === Pt ? le.namespaceURI === on ? Oe === "math" : le.namespaceURI === Yt ? Oe === "math" && Rl[Tt] : !!xu[Oe] : L.namespaceURI === on ? le.namespaceURI === Yt && !Rl[Tt] || le.namespaceURI === Pt && !Nl[Tt] ? !1 : !xu[Oe] && (Fd[Oe] || !wu[Oe]) : !!(Ao === "application/xhtml+xml" && Vn[L.namespaceURI]) : !1;
  }, Lr = function(L) {
    qu(e.removed, {
      element: L
    });
    try {
      k(L).removeChild(L);
    } catch {
      g(L);
    }
  }, Ls = function(L, le) {
    try {
      qu(e.removed, {
        attribute: le.getAttributeNode(L),
        from: le
      });
    } catch {
      qu(e.removed, {
        attribute: null,
        from: le
      });
    }
    if (le.removeAttribute(L), L === "is")
      if (Y || ae)
        try {
          Lr(le);
        } catch {
        }
      else
        try {
          le.setAttribute(L, "");
        } catch {
        }
  }, ku = function(L) {
    let le = null, Oe = null;
    if (J)
      L = "<remove></remove>" + L;
    else {
      const tn = Q8(L, /^[\r\n\t ]+/);
      Oe = tn && tn[0];
    }
    Ao === "application/xhtml+xml" && wt === on && (L = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + L + "</body></html>");
    const Tt = C ? C.createHTML(L) : L;
    if (wt === on)
      try {
        le = new f().parseFromString(Tt, Ao);
      } catch {
      }
    if (!le || !le.documentElement) {
      le = T.createDocument(wt, "template", null);
      try {
        le.documentElement.innerHTML = pt ? M : Tt;
      } catch {
      }
    }
    const bn = le.body || le.documentElement;
    return L && Oe && bn.insertBefore(t.createTextNode(Oe), bn.childNodes[0] || null), wt === on ? $.call(le, W ? "html" : "body")[0] : W ? le.documentElement : bn;
  }, Su = function(L) {
    return N.call(
      L.ownerDocument || L,
      L,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, ja = function(L) {
    return L instanceof h && (typeof L.nodeName != "string" || typeof L.textContent != "string" || typeof L.removeChild != "function" || !(L.attributes instanceof u) || typeof L.removeAttribute != "function" || typeof L.setAttribute != "function" || typeof L.namespaceURI != "string" || typeof L.insertBefore != "function" || typeof L.hasChildNodes != "function");
  }, Cu = function(L) {
    return typeof l == "function" && L instanceof l;
  };
  function ni(Re, L, le) {
    b0(Re, (Oe) => {
      Oe.call(e, L, le, _s);
    });
  }
  const Mu = function(L) {
    let le = null;
    if (ni(V.beforeSanitizeElements, L, null), ja(L))
      return Lr(L), !0;
    const Oe = ln(L.nodeName);
    if (ni(V.uponSanitizeElement, L, {
      tagName: Oe,
      allowedTags: Ie
    }), P && L.hasChildNodes() && !Cu(L.firstElementChild) && tr(/<[/\w!]/g, L.innerHTML) && tr(/<[/\w!]/g, L.textContent) || L.nodeType === Ku.progressingInstruction || P && L.nodeType === Ku.comment && tr(/<[/\w]/g, L.data))
      return Lr(L), !0;
    if (!Ie[Oe] || et[Oe]) {
      if (!et[Oe] && Au(Oe) && (Ue.tagNameCheck instanceof RegExp && tr(Ue.tagNameCheck, Oe) || Ue.tagNameCheck instanceof Function && Ue.tagNameCheck(Oe)))
        return !1;
      if (de && !F[Oe]) {
        const Tt = k(L) || L.parentNode, bn = w(L) || L.childNodes;
        if (bn && Tt) {
          const tn = bn.length;
          for (let In = tn - 1; In >= 0; --In) {
            const ri = m(bn[In], !0);
            ri.__removalCount = (L.__removalCount || 0) + 1, Tt.insertBefore(ri, b(L));
          }
        }
      }
      return Lr(L), !0;
    }
    return L instanceof a && !qd(L) || (Oe === "noscript" || Oe === "noembed" || Oe === "noframes") && tr(/<\/no(script|embed|frames)/i, L.innerHTML) ? (Lr(L), !0) : (E && L.nodeType === Ku.text && (le = L.textContent, b0([z, ue, ie], (Tt) => {
      le = Wu(le, Tt, " ");
    }), L.textContent !== le && (qu(e.removed, {
      element: L.cloneNode()
    }), L.textContent = le)), ni(V.afterSanitizeElements, L, null), !1);
  }, Tu = function(L, le, Oe) {
    if (oe && (le === "id" || le === "name") && (Oe in t || Oe in Vd))
      return !1;
    if (!(sn && !Mt[le] && tr(he, le))) {
      if (!(Ft && tr(Se, le))) {
        if (!O[le] || Mt[le]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(Au(L) && (Ue.tagNameCheck instanceof RegExp && tr(Ue.tagNameCheck, L) || Ue.tagNameCheck instanceof Function && Ue.tagNameCheck(L)) && (Ue.attributeNameCheck instanceof RegExp && tr(Ue.attributeNameCheck, le) || Ue.attributeNameCheck instanceof Function && Ue.attributeNameCheck(le)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            le === "is" && Ue.allowCustomizedBuiltInElements && (Ue.tagNameCheck instanceof RegExp && tr(Ue.tagNameCheck, Oe) || Ue.tagNameCheck instanceof Function && Ue.tagNameCheck(Oe)))
          ) return !1;
        } else if (!je[le]) {
          if (!tr(I, Wu(Oe, ye, ""))) {
            if (!((le === "src" || le === "xlink:href" || le === "href") && L !== "script" && pZ(Oe, "data:") === 0 && pe[L])) {
              if (!(Gt && !tr(ge, Wu(Oe, ye, "")))) {
                if (Oe)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Au = function(L) {
    return L !== "annotation-xml" && Q8(L, ze);
  }, Ou = function(L) {
    ni(V.beforeSanitizeAttributes, L, null);
    const {
      attributes: le
    } = L;
    if (!le || ja(L))
      return;
    const Oe = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: O,
      forceKeepAttr: void 0
    };
    let Tt = le.length;
    for (; Tt--; ) {
      const bn = le[Tt], {
        name: tn,
        namespaceURI: In,
        value: ri
      } = bn, Oo = ln(tn), Ua = ri;
      let vn = tn === "value" ? Ua : mZ(Ua);
      if (Oe.attrName = Oo, Oe.attrValue = vn, Oe.keepAttr = !0, Oe.forceKeepAttr = void 0, ni(V.uponSanitizeAttribute, L, Oe), vn = Oe.attrValue, te && (Oo === "id" || Oo === "name") && (Ls(tn, L), vn = De + vn), P && tr(/((--!?|])>)|<\/(style|title)/i, vn)) {
        Ls(tn, L);
        continue;
      }
      if (Oe.forceKeepAttr)
        continue;
      if (!Oe.keepAttr) {
        Ls(tn, L);
        continue;
      }
      if (!_r && tr(/\/>/i, vn)) {
        Ls(tn, L);
        continue;
      }
      E && b0([z, ue, ie], (Iu) => {
        vn = Wu(vn, Iu, " ");
      });
      const Eu = ln(L.nodeName);
      if (!Tu(Eu, Oo, vn)) {
        Ls(tn, L);
        continue;
      }
      if (C && typeof d == "object" && typeof d.getAttributeType == "function" && !In)
        switch (d.getAttributeType(Eu, Oo)) {
          case "TrustedHTML": {
            vn = C.createHTML(vn);
            break;
          }
          case "TrustedScriptURL": {
            vn = C.createScriptURL(vn);
            break;
          }
        }
      if (vn !== Ua)
        try {
          In ? L.setAttributeNS(In, tn, vn) : L.setAttribute(tn, vn), ja(L) ? Lr(L) : Z8(e.removed);
        } catch {
          Ls(tn, L);
        }
    }
    ni(V.afterSanitizeAttributes, L, null);
  }, Wd = function Re(L) {
    let le = null;
    const Oe = Su(L);
    for (ni(V.beforeSanitizeShadowDOM, L, null); le = Oe.nextNode(); )
      ni(V.uponSanitizeShadowNode, le, null), Mu(le), Ou(le), le.content instanceof s && Re(le.content);
    ni(V.afterSanitizeShadowDOM, L, null);
  };
  return e.sanitize = function(Re) {
    let L = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, le = null, Oe = null, Tt = null, bn = null;
    if (pt = !Re, pt && (Re = "<!-->"), typeof Re != "string" && !Cu(Re))
      if (typeof Re.toString == "function") {
        if (Re = Re.toString(), typeof Re != "string")
          throw ju("dirty is not a string, aborting");
      } else
        throw ju("toString is not a function");
    if (!e.isSupported)
      return Re;
    if (Q || Wa(L), e.removed = [], typeof Re == "string" && (Te = !1), Te) {
      if (Re.nodeName) {
        const ri = ln(Re.nodeName);
        if (!Ie[ri] || et[ri])
          throw ju("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Re instanceof l)
      le = ku("<!---->"), Oe = le.ownerDocument.importNode(Re, !0), Oe.nodeType === Ku.element && Oe.nodeName === "BODY" || Oe.nodeName === "HTML" ? le = Oe : le.appendChild(Oe);
    else {
      if (!Y && !E && !W && // eslint-disable-next-line unicorn/prefer-includes
      Re.indexOf("<") === -1)
        return C && re ? C.createHTML(Re) : Re;
      if (le = ku(Re), !le)
        return Y ? null : re ? M : "";
    }
    le && J && Lr(le.firstChild);
    const tn = Su(Te ? Re : le);
    for (; Tt = tn.nextNode(); )
      Mu(Tt), Ou(Tt), Tt.content instanceof s && Wd(Tt.content);
    if (Te)
      return Re;
    if (Y) {
      if (ae)
        for (bn = B.call(le.ownerDocument); le.firstChild; )
          bn.appendChild(le.firstChild);
      else
        bn = le;
      return (O.shadowroot || O.shadowrootmode) && (bn = R.call(r, bn, !0)), bn;
    }
    let In = W ? le.outerHTML : le.innerHTML;
    return W && Ie["!doctype"] && le.ownerDocument && le.ownerDocument.doctype && le.ownerDocument.doctype.name && tr(qE, le.ownerDocument.doctype.name) && (In = "<!DOCTYPE " + le.ownerDocument.doctype.name + `>
` + In), E && b0([z, ue, ie], (ri) => {
      In = Wu(In, ri, " ");
    }), C && re ? C.createHTML(In) : In;
  }, e.setConfig = function() {
    let Re = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Wa(Re), Q = !0;
  }, e.clearConfig = function() {
    _s = null, Q = !1;
  }, e.isValidAttribute = function(Re, L, le) {
    _s || Wa({});
    const Oe = ln(Re), Tt = ln(L);
    return Tu(Oe, Tt, le);
  }, e.addHook = function(Re, L) {
    typeof L == "function" && qu(V[Re], L);
  }, e.removeHook = function(Re, L) {
    if (L !== void 0) {
      const le = fZ(V[Re], L);
      return le === -1 ? void 0 : dZ(V[Re], le, 1)[0];
    }
    return Z8(V[Re]);
  }, e.removeHooks = function(Re) {
    V[Re] = [];
  }, e.removeAllHooks = function() {
    V = sk();
  }, e;
}
var Ki = WE();
function jc({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ki.sanitize(n.trim()));
      }
    }
  );
}
jc.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
let IZ = (n) => crypto.getRandomValues(new Uint8Array(n)), DZ = (n, e, t) => {
  let r = (2 << Math.log2(n.length - 1)) - 1, i = -~(1.6 * r * e / n.length);
  return (s = e) => {
    let o = "";
    for (; ; ) {
      let l = t(i), a = i | 0;
      for (; a--; )
        if (o += n[l[a] & r] || "", o.length >= s) return o;
    }
  };
}, jE = (n, e = 21) => DZ(n, e | 0, IZ);
var NZ = Object.defineProperty, ok = Object.getOwnPropertySymbols, RZ = Object.prototype.hasOwnProperty, PZ = Object.prototype.propertyIsEnumerable, lk = (n, e, t) => e in n ? NZ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, _Z = (n, e) => {
  for (var t in e || (e = {}))
    RZ.call(e, t) && lk(n, t, e[t]);
  if (ok)
    for (var t of ok(e))
      PZ.call(e, t) && lk(n, t, e[t]);
  return n;
};
function Td(n, e) {
  return Object.assign(n, {
    meta: _Z({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const LZ = {
  imageIcon: "🌌",
  captionIcon: "💬",
  uploadButton: "Upload file",
  confirmButton: "Confirm ⏎",
  uploadPlaceholderText: "or paste the image link ...",
  captionPlaceholderText: "Image caption",
  onUpload: (n) => Promise.resolve(URL.createObjectURL(n))
}, Y1 = Ct(
  LZ,
  "imageBlockConfigCtx"
);
Td(Y1, {
  displayName: "Config<image-block>",
  group: "ImageBlock"
});
function BZ(n) {
  return Tl(
    n,
    "paragraph",
    (e, t, r) => {
      var i, s;
      if (((i = e.children) == null ? void 0 : i.length) !== 1) return;
      const o = (s = e.children) == null ? void 0 : s[0];
      if (!o || o.type !== "image") return;
      const { url: l, alt: a, title: c } = o, u = {
        type: "image-block",
        url: l,
        alt: a,
        title: c
      };
      r.children.splice(t, 1, u);
    }
  );
}
const Cv = As(
  "remark-image-block",
  () => () => BZ
);
Td(Cv.plugin, {
  displayName: "Remark<remarkImageBlock>",
  group: "ImageBlock"
});
Td(Cv.options, {
  displayName: "RemarkConfig<remarkImageBlock>",
  group: "ImageBlock"
});
var zZ = Object.defineProperty, ak = Object.getOwnPropertySymbols, FZ = Object.prototype.hasOwnProperty, HZ = Object.prototype.propertyIsEnumerable, ck = (n, e, t) => e in n ? zZ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, $Z = (n, e) => {
  for (var t in e || (e = {}))
    FZ.call(e, t) && ck(n, t, e[t]);
  if (ak)
    for (var t of ak(e))
      HZ.call(e, t) && ck(n, t, e[t]);
  return n;
};
const y5 = "image-block", J1 = hn("image-block", () => ({
  inline: !1,
  group: "block",
  selectable: !0,
  draggable: !0,
  isolating: !0,
  marks: "",
  atom: !0,
  priority: 100,
  attrs: {
    src: { default: "", validate: "string" },
    caption: { default: "", validate: "string" },
    ratio: { default: 1, validate: "number" }
  },
  parseDOM: [
    {
      tag: `img[data-type="${y5}"]`,
      getAttrs: (n) => {
        var e;
        if (!(n instanceof HTMLElement)) throw qi(n);
        return {
          src: n.getAttribute("src") || "",
          caption: n.getAttribute("caption") || "",
          ratio: Number((e = n.getAttribute("ratio")) != null ? e : 1)
        };
      }
    }
  ],
  toDOM: (n) => ["img", $Z({ "data-type": y5 }, n.attrs)],
  parseMarkdown: {
    match: ({ type: n }) => n === "image-block",
    runner: (n, e, t) => {
      const r = e.url, i = e.title;
      let s = Number(e.alt || 1);
      (Number.isNaN(s) || s === 0) && (s = 1), n.addNode(t, {
        src: r,
        caption: i,
        ratio: s
      });
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "image-block",
    runner: (n, e) => {
      n.openNode("paragraph"), n.addNode("image", void 0, void 0, {
        title: e.attrs.caption,
        url: e.attrs.src,
        alt: `${Number.parseFloat(e.attrs.ratio).toFixed(2)}`
      }), n.closeNode();
    }
  }
}));
Td(J1.node, {
  displayName: "NodeSchema<image-block>",
  group: "ImageBlock"
});
function ff({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ki.sanitize(n.trim()));
      }
    }
  );
}
ff.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const VZ = jE("abcdefg", 8), qZ = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setLink: {
      type: Function,
      required: !0
    },
    imageIcon: {
      type: String,
      required: !1
    },
    uploadButton: {
      type: String,
      required: !1
    },
    confirmButton: {
      type: String,
      required: !1
    },
    uploadPlaceholderText: {
      type: String,
      required: !1
    },
    onUpload: {
      type: Function,
      required: !0
    }
  },
  setup({
    readonly: n,
    src: e,
    setLink: t,
    onUpload: r,
    imageIcon: i,
    uploadButton: s,
    confirmButton: o,
    uploadPlaceholderText: l,
    className: a
  }) {
    var c, u;
    const h = Ae(!1), f = Ae(), d = Ae((c = e.value) != null ? c : ""), p = Ae(VZ()), m = Ae(((u = e.value) == null ? void 0 : u.length) !== 0), g = (C) => {
      const T = C.target.value;
      m.value = T.length !== 0, d.value = T;
    }, b = (C) => {
      var M, T;
      C.key === "Enter" && t((T = (M = f.value) == null ? void 0 : M.value) != null ? T : "");
    }, w = () => {
      var C, M;
      t((M = (C = f.value) == null ? void 0 : C.value) != null ? M : "");
    }, k = (C) => {
      var M;
      const T = (M = C.target.files) == null ? void 0 : M[0];
      T && r(T).then((N) => {
        N && (t(N), m.value = !0);
      }).catch((N) => {
        console.error("An error occurred while uploading image"), console.error(N);
      });
    };
    return () => /* @__PURE__ */ j("div", { class: Hn("image-edit", a) }, /* @__PURE__ */ j(ff, { icon: i, class: "image-icon" }), /* @__PURE__ */ j("div", { class: Hn("link-importer", h.value && "focus") }, /* @__PURE__ */ j(
      "input",
      {
        ref: f,
        draggable: "true",
        onDragstart: (C) => {
          C.preventDefault(), C.stopPropagation();
        },
        disabled: n.value,
        class: "link-input-area",
        value: d.value,
        onInput: g,
        onKeydown: b,
        onFocus: () => h.value = !0,
        onBlur: () => h.value = !1
      }
    ), !m.value && /* @__PURE__ */ j("div", { class: "placeholder" }, /* @__PURE__ */ j(
      "input",
      {
        disabled: n.value,
        class: "hidden",
        id: p.value,
        type: "file",
        accept: "image/*",
        onChange: k
      }
    ), /* @__PURE__ */ j("label", { class: "uploader", for: p.value }, /* @__PURE__ */ j(ff, { icon: s })), /* @__PURE__ */ j("span", { class: "text", onClick: () => {
      var C;
      return (C = f.value) == null ? void 0 : C.focus();
    } }, l))), d.value && /* @__PURE__ */ j("div", { class: "confirm", onClick: () => w() }, /* @__PURE__ */ j(ff, { icon: o })));
  }
}), WZ = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    caption: {
      type: Object,
      required: !0
    },
    ratio: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup({ src: n, caption: e, ratio: t, readonly: r, setAttr: i, config: s }) {
    var o;
    const l = Ae(), a = Ae(), c = Ae(!!((o = e.value) != null && o.length)), u = Ae(0), h = () => {
      var w;
      const k = l.value;
      if (!k) return;
      const C = k.closest(".milkdown-image-block");
      if (!C) return;
      const M = C.getBoundingClientRect().width;
      if (!M) return;
      const T = k.height, N = k.width, B = N < M ? T : M * (T / N), $ = (B * ((w = t.value) != null ? w : 1)).toFixed(2);
      k.dataset.origin = B.toFixed(2), k.dataset.height = $, k.style.height = `${$}px`;
    }, f = (w) => {
      w.preventDefault(), w.stopPropagation(), !r.value && (c.value = !c.value);
    }, d = (w) => {
      const C = w.target.value;
      u.value && window.clearTimeout(u.value), u.value = window.setTimeout(() => {
        i("caption", C);
      }, 1e3);
    }, p = (w) => {
      const C = w.target.value;
      u.value && (window.clearTimeout(u.value), u.value = 0), i("caption", C);
    }, m = (w) => {
      w.preventDefault();
      const k = l.value;
      if (!k) return;
      const C = k.getBoundingClientRect().top, M = w.clientY - C, T = Number(M < 100 ? 100 : M).toFixed(2);
      k.dataset.height = T, k.style.height = `${T}px`;
    }, g = () => {
      window.removeEventListener("pointermove", m), window.removeEventListener("pointerup", g);
      const w = l.value;
      if (!w) return;
      const k = Number(w.dataset.origin), C = Number(w.dataset.height), M = Number.parseFloat(
        Number(C / k).toFixed(2)
      );
      Number.isNaN(M) || i("ratio", M);
    }, b = (w) => {
      r.value || (w.preventDefault(), w.stopPropagation(), window.addEventListener("pointermove", m), window.addEventListener("pointerup", g));
    };
    return () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("div", { class: "image-wrapper" }, /* @__PURE__ */ j("div", { class: "operation" }, /* @__PURE__ */ j("div", { class: "operation-item", onPointerdown: f }, /* @__PURE__ */ j(ff, { icon: s.captionIcon }))), /* @__PURE__ */ j(
      "img",
      {
        ref: l,
        "data-type": y5,
        onLoad: h,
        src: n.value,
        alt: e.value
      }
    ), /* @__PURE__ */ j(
      "div",
      {
        ref: a,
        class: "image-resize-handle",
        onPointerdown: b
      }
    )), c.value && /* @__PURE__ */ j(
      "input",
      {
        draggable: "true",
        onDragstart: (w) => {
          w.preventDefault(), w.stopPropagation();
        },
        class: "caption-input",
        placeholder: s?.captionPlaceholderText,
        onInput: d,
        onBlur: p,
        value: e.value
      }
    ));
  }
});
var jZ = Object.defineProperty, uk = Object.getOwnPropertySymbols, UZ = Object.prototype.hasOwnProperty, KZ = Object.prototype.propertyIsEnumerable, hk = (n, e, t) => e in n ? jZ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, GZ = (n, e) => {
  for (var t in e || (e = {}))
    UZ.call(e, t) && hk(n, t, e[t]);
  if (uk)
    for (var t of uk(e))
      KZ.call(e, t) && hk(n, t, e[t]);
  return n;
};
const YZ = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    caption: {
      type: Object,
      required: !0
    },
    ratio: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { src: e } = n;
    return () => {
      var t;
      return (t = e.value) != null && t.length ? /* @__PURE__ */ j(WZ, GZ({}, n)) : /* @__PURE__ */ j(
        qZ,
        {
          src: n.src,
          selected: n.selected,
          readonly: n.readonly,
          setLink: (r) => n.setAttr("src", r),
          imageIcon: n.config.imageIcon,
          uploadButton: n.config.uploadButton,
          confirmButton: n.config.confirmButton,
          uploadPlaceholderText: n.config.uploadPlaceholderText,
          onUpload: n.config.onUpload
        }
      );
    };
  }
}), UE = yd(
  J1.node,
  (n) => (e, t, r) => {
    const i = Ae(e.attrs.src), s = Ae(e.attrs.caption), o = Ae(e.attrs.ratio), l = Ae(!1), a = Ae(!t.editable), c = (g, b) => {
      if (!t.editable) return;
      const w = r();
      w != null && t.dispatch(
        t.state.tr.setNodeAttribute(
          w,
          g,
          g === "src" ? Ki.sanitize(b) : b
        )
      );
    }, u = n.get(Y1.key), h = Ui(YZ, {
      src: i,
      caption: s,
      ratio: o,
      selected: l,
      readonly: a,
      setAttr: c,
      config: u
    }), f = document.createElement("div");
    f.className = "milkdown-image-block", h.mount(f);
    const d = uu(() => {
      l.value ? f.classList.add("selected") : f.classList.remove("selected");
    }), p = u.proxyDomURL, m = (g) => {
      if (!p)
        i.value = g.attrs.src;
      else {
        const b = p(g.attrs.src);
        typeof b == "string" ? i.value = b : b.then((w) => {
          i.value = w;
        }).catch(console.error);
      }
      o.value = g.attrs.ratio, s.value = g.attrs.caption, a.value = !t.editable;
    };
    return m(e), {
      dom: f,
      update: (g) => g.type !== e.type ? !1 : (m(g), !0),
      stopEvent: (g) => g.target instanceof HTMLInputElement,
      selectNode: () => {
        l.value = !0;
      },
      deselectNode: () => {
        l.value = !1;
      },
      destroy: () => {
        d(), h.unmount(), f.remove();
      }
    };
  }
);
Td(UE, {
  displayName: "NodeView<image-block>",
  group: "ImageBlock"
});
const JZ = [
  Cv,
  J1,
  UE,
  Y1
].flat();
var b5, v5;
if (typeof WeakMap < "u") {
  let n = /* @__PURE__ */ new WeakMap();
  b5 = (e) => n.get(e), v5 = (e, t) => (n.set(e, t), t);
} else {
  const n = [];
  let t = 0;
  b5 = (r) => {
    for (let i = 0; i < n.length; i += 2)
      if (n[i] == r) return n[i + 1];
  }, v5 = (r, i) => (t == 10 && (t = 0), n[t++] = r, n[t++] = i);
}
var vt = class {
  constructor(n, e, t, r) {
    this.width = n, this.height = e, this.map = t, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(n) {
    for (let e = 0; e < this.map.length; e++) {
      const t = this.map[e];
      if (t != n) continue;
      const r = e % this.width, i = e / this.width | 0;
      let s = r + 1, o = i + 1;
      for (let l = 1; s < this.width && this.map[e + l] == t; l++)
        s++;
      for (let l = 1; o < this.height && this.map[e + this.width * l] == t; l++)
        o++;
      return { left: r, top: i, right: s, bottom: o };
    }
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(n) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == n)
        return e % this.width;
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(n, e, t) {
    const { left: r, right: i, top: s, bottom: o } = this.findCell(n);
    return e == "horiz" ? (t < 0 ? r == 0 : i == this.width) ? null : this.map[s * this.width + (t < 0 ? r - 1 : i)] : (t < 0 ? s == 0 : o == this.height) ? null : this.map[r + this.width * (t < 0 ? s - 1 : o)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(n, e) {
    const {
      left: t,
      right: r,
      top: i,
      bottom: s
    } = this.findCell(n), {
      left: o,
      right: l,
      top: a,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(t, o),
      top: Math.min(i, a),
      right: Math.max(r, l),
      bottom: Math.max(s, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(n) {
    const e = [], t = {};
    for (let r = n.top; r < n.bottom; r++)
      for (let i = n.left; i < n.right; i++) {
        const s = r * this.width + i, o = this.map[s];
        t[o] || (t[o] = !0, !(i == n.left && i && this.map[s - 1] == o || r == n.top && r && this.map[s - this.width] == o) && e.push(o));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(n, e, t) {
    for (let r = 0, i = 0; ; r++) {
      const s = i + t.child(r).nodeSize;
      if (r == n) {
        let o = e + n * this.width;
        const l = (n + 1) * this.width;
        for (; o < l && this.map[o] < i; ) o++;
        return o == l ? s - 1 : this.map[o];
      }
      i = s;
    }
  }
  // Find the table map for the given table node.
  static get(n) {
    return b5(n) || v5(n, XZ(n));
  }
};
function XZ(n) {
  if (n.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + n.type.name);
  const e = ZZ(n), t = n.childCount, r = [];
  let i = 0, s = null;
  const o = [];
  for (let c = 0, u = e * t; c < u; c++) r[c] = 0;
  for (let c = 0, u = 0; c < t; c++) {
    const h = n.child(c);
    u++;
    for (let p = 0; ; p++) {
      for (; i < r.length && r[i] != 0; ) i++;
      if (p == h.childCount) break;
      const m = h.child(p), { colspan: g, rowspan: b, colwidth: w } = m.attrs;
      for (let k = 0; k < b; k++) {
        if (k + c >= t) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: b - k
          });
          break;
        }
        const C = i + k * e;
        for (let M = 0; M < g; M++) {
          r[C + M] == 0 ? r[C + M] = u : (s || (s = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: g - M
          });
          const T = w && w[M];
          if (T) {
            const N = (C + M) % e * 2, B = o[N];
            B == null || B != T && o[N + 1] == 1 ? (o[N] = T, o[N + 1] = 1) : B == T && o[N + 1]++;
          }
        }
      }
      i += g, u += m.nodeSize;
    }
    const f = (c + 1) * e;
    let d = 0;
    for (; i < f; ) r[i++] == 0 && d++;
    d && (s || (s = [])).push({ type: "missing", row: c, n: d }), u++;
  }
  (e === 0 || t === 0) && (s || (s = [])).push({ type: "zero_sized" });
  const l = new vt(e, t, r, s);
  let a = !1;
  for (let c = 0; !a && c < o.length; c += 2)
    o[c] != null && o[c + 1] < t && (a = !0);
  return a && QZ(l, o, n), l;
}
function ZZ(n) {
  let e = -1, t = !1;
  for (let r = 0; r < n.childCount; r++) {
    const i = n.child(r);
    let s = 0;
    if (t)
      for (let o = 0; o < r; o++) {
        const l = n.child(o);
        for (let a = 0; a < l.childCount; a++) {
          const c = l.child(a);
          o + c.attrs.rowspan > r && (s += c.attrs.colspan);
        }
      }
    for (let o = 0; o < i.childCount; o++) {
      const l = i.child(o);
      s += l.attrs.colspan, l.attrs.rowspan > 1 && (t = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function QZ(n, e, t) {
  n.problems || (n.problems = []);
  const r = {};
  for (let i = 0; i < n.map.length; i++) {
    const s = n.map[i];
    if (r[s]) continue;
    r[s] = !0;
    const o = t.nodeAt(s);
    if (!o)
      throw new RangeError(`No cell with offset ${s} found`);
    let l = null;
    const a = o.attrs;
    for (let c = 0; c < a.colspan; c++) {
      const u = (i + c) % n.width, h = e[u * 2];
      h != null && (!a.colwidth || a.colwidth[c] != h) && ((l || (l = eQ(a)))[c] = h);
    }
    l && n.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: l
    });
  }
}
function eQ(n) {
  if (n.colwidth) return n.colwidth.slice();
  const e = [];
  for (let t = 0; t < n.colspan; t++) e.push(0);
  return e;
}
function fk(n, e) {
  if (typeof n == "string")
    return {};
  const t = n.getAttribute("data-colwidth"), r = t && /^\d+(,\d+)*$/.test(t) ? t.split(",").map((o) => Number(o)) : null, i = Number(n.getAttribute("colspan") || 1), s = {
    colspan: i,
    rowspan: Number(n.getAttribute("rowspan") || 1),
    colwidth: r && r.length == i ? r : null
  };
  for (const o in e) {
    const l = e[o].getFromDOM, a = l && l(n);
    a != null && (s[o] = a);
  }
  return s;
}
function dk(n, e) {
  const t = {};
  n.attrs.colspan != 1 && (t.colspan = n.attrs.colspan), n.attrs.rowspan != 1 && (t.rowspan = n.attrs.rowspan), n.attrs.colwidth && (t["data-colwidth"] = n.attrs.colwidth.join(","));
  for (const r in e) {
    const i = e[r].setDOMAttr;
    i && i(n.attrs[r], t);
  }
  return t;
}
function tQ(n) {
  if (n !== null) {
    if (!Array.isArray(n))
      throw new TypeError("colwidth must be null or an array");
    for (const e of n)
      if (typeof e != "number")
        throw new TypeError("colwidth must be null or an array of numbers");
  }
}
function nQ(n) {
  const e = n.cellAttributes || {}, t = {
    colspan: { default: 1, validate: "number" },
    rowspan: { default: 1, validate: "number" },
    colwidth: { default: null, validate: tQ }
  };
  for (const r in e)
    t[r] = {
      default: e[r].default,
      validate: e[r].validate
    };
  return {
    table: {
      content: "table_row+",
      tableRole: "table",
      isolating: !0,
      group: n.tableGroup,
      parseDOM: [{ tag: "table" }],
      toDOM() {
        return ["table", ["tbody", 0]];
      }
    },
    table_row: {
      content: "(table_cell | table_header)*",
      tableRole: "row",
      parseDOM: [{ tag: "tr" }],
      toDOM() {
        return ["tr", 0];
      }
    },
    table_cell: {
      content: n.cellContent,
      attrs: t,
      tableRole: "cell",
      isolating: !0,
      parseDOM: [
        { tag: "td", getAttrs: (r) => fk(r, e) }
      ],
      toDOM(r) {
        return ["td", dk(r, e), 0];
      }
    },
    table_header: {
      content: n.cellContent,
      attrs: t,
      tableRole: "header_cell",
      isolating: !0,
      parseDOM: [
        { tag: "th", getAttrs: (r) => fk(r, e) }
      ],
      toDOM(r) {
        return ["th", dk(r, e), 0];
      }
    }
  };
}
function xi(n) {
  let e = n.cached.tableNodeTypes;
  if (!e) {
    e = n.cached.tableNodeTypes = {};
    for (const t in n.nodes) {
      const r = n.nodes[t], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var Go = new en("selectingCells");
function Ad(n) {
  for (let e = n.depth - 1; e > 0; e--)
    if (n.node(e).type.spec.tableRole == "row")
      return n.node(0).resolve(n.before(e + 1));
  return null;
}
function Ci(n) {
  const e = n.selection.$head;
  for (let t = e.depth; t > 0; t--)
    if (e.node(t).type.spec.tableRole == "row") return !0;
  return !1;
}
function X1(n) {
  const e = n.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const t = Ad(e.$head) || rQ(e.$head);
  if (t)
    return t;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function rQ(n) {
  for (let e = n.nodeAfter, t = n.pos; e; e = e.firstChild, t++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return n.doc.resolve(t);
  }
  for (let e = n.nodeBefore, t = n.pos; e; e = e.lastChild, t--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return n.doc.resolve(t - e.nodeSize);
  }
}
function w5(n) {
  return n.parent.type.spec.tableRole == "row" && !!n.nodeAfter;
}
function iQ(n) {
  return n.node(0).resolve(n.pos + n.nodeAfter.nodeSize);
}
function Mv(n, e) {
  return n.depth == e.depth && n.pos >= e.start(-1) && n.pos <= e.end(-1);
}
function KE(n, e, t) {
  const r = n.node(-1), i = vt.get(r), s = n.start(-1), o = i.nextCell(n.pos - s, e, t);
  return o == null ? null : n.node(0).resolve(s + o);
}
function Pa(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan - t };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, t), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function sQ(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan + t };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < t; i++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function oQ(n, e, t) {
  const r = xi(e.type.schema).header_cell;
  for (let i = 0; i < n.height; i++)
    if (e.nodeAt(n.map[t + i * n.width]).type != r)
      return !1;
  return !0;
}
var Nt = class Ws extends Ge {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, t = e) {
    const r = e.node(-1), i = vt.get(r), s = e.start(-1), o = i.rectBetween(
      e.pos - s,
      t.pos - s
    ), l = e.node(0), a = i.cellsInRect(o).filter((u) => u != t.pos - s);
    a.unshift(t.pos - s);
    const c = a.map((u) => {
      const h = r.nodeAt(u);
      if (!h)
        throw RangeError(`No cell with offset ${u} found`);
      const f = s + u + 1;
      return new fT(
        l.resolve(f),
        l.resolve(f + h.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = t;
  }
  map(e, t) {
    const r = e.resolve(t.map(this.$anchorCell.pos)), i = e.resolve(t.map(this.$headCell.pos));
    if (w5(r) && w5(i) && Mv(r, i)) {
      const s = this.$anchorCell.node(-1) != r.node(-1);
      return s && this.isRowSelection() ? Ws.rowSelection(r, i) : s && this.isColSelection() ? Ws.colSelection(r, i) : new Ws(r, i);
    }
    return Ee.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), t = vt.get(e), r = this.$anchorCell.start(-1), i = t.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), s = {}, o = [];
    for (let a = i.top; a < i.bottom; a++) {
      const c = [];
      for (let u = a * t.width + i.left, h = i.left; h < i.right; h++, u++) {
        const f = t.map[u];
        if (s[f]) continue;
        s[f] = !0;
        const d = t.findCell(f);
        let p = e.nodeAt(f);
        if (!p)
          throw RangeError(`No cell with offset ${f} found`);
        const m = i.left - d.left, g = d.right - i.right;
        if (m > 0 || g > 0) {
          let b = p.attrs;
          if (m > 0 && (b = Pa(b, 0, m)), g > 0 && (b = Pa(
            b,
            b.colspan - g,
            g
          )), d.left < i.left) {
            if (p = p.type.createAndFill(b), !p)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(b)}`
              );
          } else
            p = p.type.create(b, p.content);
        }
        if (d.top < i.top || d.bottom > i.bottom) {
          const b = {
            ...p.attrs,
            rowspan: Math.min(d.bottom, i.bottom) - Math.max(d.top, i.top)
          };
          d.top < i.top ? p = p.type.createAndFill(b) : p = p.type.create(b, p.content);
        }
        c.push(p);
      }
      o.push(e.child(a).copy(ce.from(c)));
    }
    const l = this.isColSelection() && this.isRowSelection() ? e : o;
    return new be(ce.from(l), 1, 1);
  }
  replace(e, t = be.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      const { $from: l, $to: a } = i[o], c = e.mapping.slice(r);
      e.replace(
        c.map(l.pos),
        c.map(a.pos),
        o ? be.empty : t
      );
    }
    const s = Ge.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    s && e.setSelection(s);
  }
  replaceWith(e, t) {
    this.replace(e, new be(ce.from(t), 0, 0));
  }
  forEachCell(e) {
    const t = this.$anchorCell.node(-1), r = vt.get(t), i = this.$anchorCell.start(-1), s = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let o = 0; o < s.length; o++)
      e(t.nodeAt(s[o]), i + s[o]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1);
    if (Math.min(e, t) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = t + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, t = e) {
    const r = e.node(-1), i = vt.get(r), s = e.start(-1), o = i.findCell(e.pos - s), l = i.findCell(t.pos - s), a = e.node(0);
    return o.top <= l.top ? (o.top > 0 && (e = a.resolve(s + i.map[o.left])), l.bottom < i.height && (t = a.resolve(
      s + i.map[i.width * (i.height - 1) + l.right - 1]
    ))) : (l.top > 0 && (t = a.resolve(s + i.map[l.left])), o.bottom < i.height && (e = a.resolve(
      s + i.map[i.width * (i.height - 1) + o.right - 1]
    ))), new Ws(e, t);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), t = vt.get(e), r = this.$anchorCell.start(-1), i = t.colCount(this.$anchorCell.pos - r), s = t.colCount(this.$headCell.pos - r);
    if (Math.min(i, s) > 0) return !1;
    const o = i + this.$anchorCell.nodeAfter.attrs.colspan, l = s + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(o, l) == t.width;
  }
  eq(e) {
    return e instanceof Ws && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, t = e) {
    const r = e.node(-1), i = vt.get(r), s = e.start(-1), o = i.findCell(e.pos - s), l = i.findCell(t.pos - s), a = e.node(0);
    return o.left <= l.left ? (o.left > 0 && (e = a.resolve(
      s + i.map[o.top * i.width]
    )), l.right < i.width && (t = a.resolve(
      s + i.map[i.width * (l.top + 1) - 1]
    ))) : (l.left > 0 && (t = a.resolve(s + i.map[l.top * i.width])), o.right < i.width && (e = a.resolve(
      s + i.map[i.width * (o.top + 1) - 1]
    ))), new Ws(e, t);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, t) {
    return new Ws(e.resolve(t.anchor), e.resolve(t.head));
  }
  static create(e, t, r = t) {
    return new Ws(e.resolve(t), e.resolve(r));
  }
  getBookmark() {
    return new lQ(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Nt.prototype.visible = !1;
Ge.jsonID("cell", Nt);
var lQ = class GE {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new GE(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const t = e.resolve(this.anchor), r = e.resolve(this.head);
    return t.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && r.index() < r.parent.childCount && Mv(t, r) ? new Nt(t, r) : Ge.near(r, 1);
  }
};
function aQ(n) {
  if (!(n.selection instanceof Nt)) return null;
  const e = [];
  return n.selection.forEachCell((t, r) => {
    e.push(
      mn.node(r, r + t.nodeSize, { class: "selectedCell" })
    );
  }), Et.create(n.doc, e);
}
function cQ({ $from: n, $to: e }) {
  if (n.pos == e.pos || n.pos < e.pos - 6) return !1;
  let t = n.pos, r = e.pos, i = n.depth;
  for (; i >= 0 && !(n.after(i + 1) < n.end(i)); i--, t++)
    ;
  for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, r--)
    ;
  return t == r && /row|table/.test(n.node(i).type.spec.tableRole);
}
function uQ({ $from: n, $to: e }) {
  let t, r;
  for (let i = n.depth; i > 0; i--) {
    const s = n.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      t = s;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const s = e.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      r = s;
      break;
    }
  }
  return t !== r && e.parentOffset === 0;
}
function hQ(n, e, t) {
  const r = (e || n).selection, i = (e || n).doc;
  let s, o;
  if (r instanceof $e && (o = r.node.type.spec.tableRole)) {
    if (o == "cell" || o == "header_cell")
      s = Nt.create(i, r.from);
    else if (o == "row") {
      const l = i.resolve(r.from + 1);
      s = Nt.rowSelection(l, l);
    } else if (!t) {
      const l = vt.get(r.node), a = r.from + 1, c = a + l.map[l.width * l.height - 1];
      s = Nt.create(i, a + 1, c);
    }
  } else r instanceof Ee && cQ(r) ? s = Ee.create(i, r.from) : r instanceof Ee && uQ(r) && (s = Ee.create(i, r.$from.start(), r.$from.end()));
  return s && (e || (e = n.tr)).setSelection(s), e;
}
var fQ = new en("fix-tables");
function YE(n, e, t, r) {
  const i = n.childCount, s = e.childCount;
  e: for (let o = 0, l = 0; o < s; o++) {
    const a = e.child(o);
    for (let c = l, u = Math.min(i, o + 3); c < u; c++)
      if (n.child(c) == a) {
        l = c + 1, t += a.nodeSize;
        continue e;
      }
    r(a, t), l < i && n.child(l).sameMarkup(a) ? YE(n.child(l), a, t + 1, r) : a.nodesBetween(0, a.content.size, r, t + 1), t += a.nodeSize;
  }
}
function dQ(n, e) {
  let t;
  const r = (i, s) => {
    i.type.spec.tableRole == "table" && (t = pQ(n, i, s, t));
  };
  return e ? e.doc != n.doc && YE(e.doc, n.doc, 0, r) : n.doc.descendants(r), t;
}
function pQ(n, e, t, r) {
  const i = vt.get(e);
  if (!i.problems) return r;
  r || (r = n.tr);
  const s = [];
  for (let a = 0; a < i.height; a++) s.push(0);
  for (let a = 0; a < i.problems.length; a++) {
    const c = i.problems[a];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      const h = u.attrs;
      for (let f = 0; f < h.rowspan; f++) s[c.row + f] += c.n;
      r.setNodeMarkup(
        r.mapping.map(t + 1 + c.pos),
        null,
        Pa(h, h.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      s[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const u = r.mapping.map(t);
      r.delete(u, u + e.nodeSize);
    }
  }
  let o, l;
  for (let a = 0; a < s.length; a++)
    s[a] && (o == null && (o = a), l = a);
  for (let a = 0, c = t + 1; a < i.height; a++) {
    const u = e.child(a), h = c + u.nodeSize, f = s[a];
    if (f > 0) {
      let d = "cell";
      u.firstChild && (d = u.firstChild.type.spec.tableRole);
      const p = [];
      for (let g = 0; g < f; g++) {
        const b = xi(n.schema)[d].createAndFill();
        b && p.push(b);
      }
      const m = (a == 0 || o == a - 1) && l == a ? c + 1 : h - 1;
      r.insert(r.mapping.map(m), p);
    }
    c = h;
  }
  return r.setMeta(fQ, { fixTables: !0 });
}
function El(n) {
  const e = n.selection, t = X1(n), r = t.node(-1), i = t.start(-1), s = vt.get(r);
  return { ...e instanceof Nt ? s.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : s.findCell(t.pos - i), tableStart: i, map: s, table: r };
}
function JE(n, { map: e, tableStart: t, table: r }, i) {
  let s = i > 0 ? -1 : 0;
  oQ(e, r, i + s) && (s = i == 0 || i == e.width ? null : 0);
  for (let o = 0; o < e.height; o++) {
    const l = o * e.width + i;
    if (i > 0 && i < e.width && e.map[l - 1] == e.map[l]) {
      const a = e.map[l], c = r.nodeAt(a);
      n.setNodeMarkup(
        n.mapping.map(t + a),
        null,
        sQ(c.attrs, i - e.colCount(a))
      ), o += c.attrs.rowspan - 1;
    } else {
      const a = s == null ? xi(r.type.schema).cell : r.nodeAt(e.map[l + s]).type, c = e.positionAt(o, i, r);
      n.insert(n.mapping.map(t + c), a.createAndFill());
    }
  }
  return n;
}
function mQ(n, e) {
  if (!Ci(n)) return !1;
  if (e) {
    const t = El(n);
    e(JE(n.tr, t, t.left));
  }
  return !0;
}
function gQ(n, e) {
  if (!Ci(n)) return !1;
  if (e) {
    const t = El(n);
    e(JE(n.tr, t, t.right));
  }
  return !0;
}
function yQ(n, { map: e, table: t, tableStart: r }, i) {
  const s = n.mapping.maps.length;
  for (let o = 0; o < e.height; ) {
    const l = o * e.width + i, a = e.map[l], c = t.nodeAt(a), u = c.attrs;
    if (i > 0 && e.map[l - 1] == a || i < e.width - 1 && e.map[l + 1] == a)
      n.setNodeMarkup(
        n.mapping.slice(s).map(r + a),
        null,
        Pa(u, i - e.colCount(a))
      );
    else {
      const h = n.mapping.slice(s).map(r + a);
      n.delete(h, h + c.nodeSize);
    }
    o += u.rowspan;
  }
}
function bQ(n, e) {
  if (!Ci(n)) return !1;
  if (e) {
    const t = El(n), r = n.tr;
    if (t.left == 0 && t.right == t.map.width) return !1;
    for (let i = t.right - 1; yQ(r, t, i), i != t.left; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = vt.get(s);
    }
    e(r);
  }
  return !0;
}
function vQ(n, { map: e, table: t, tableStart: r }, i) {
  let s = 0;
  for (let c = 0; c < i; c++) s += t.child(c).nodeSize;
  const o = s + t.child(i).nodeSize, l = n.mapping.maps.length;
  n.delete(s + r, o + r);
  const a = /* @__PURE__ */ new Set();
  for (let c = 0, u = i * e.width; c < e.width; c++, u++) {
    const h = e.map[u];
    if (!a.has(h)) {
      if (a.add(h), i > 0 && h == e.map[u - e.width]) {
        const f = t.nodeAt(h).attrs;
        n.setNodeMarkup(n.mapping.slice(l).map(h + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (i < e.height && h == e.map[u + e.width]) {
        const f = t.nodeAt(h), d = f.attrs, p = f.type.create(
          { ...d, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), m = e.positionAt(i + 1, c, t);
        n.insert(n.mapping.slice(l).map(r + m), p), c += d.colspan - 1;
      }
    }
  }
}
function wQ(n, e) {
  if (!Ci(n)) return !1;
  if (e) {
    const t = El(n), r = n.tr;
    if (t.top == 0 && t.bottom == t.map.height) return !1;
    for (let i = t.bottom - 1; vQ(r, t, i), i != t.top; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = vt.get(t.table);
    }
    e(r);
  }
  return !0;
}
function xQ(n, e) {
  return function(t, r) {
    if (!Ci(t)) return !1;
    const i = X1(t);
    if (i.nodeAfter.attrs[n] === e) return !1;
    if (r) {
      const s = t.tr;
      t.selection instanceof Nt ? t.selection.forEachCell((o, l) => {
        o.attrs[n] !== e && s.setNodeMarkup(l, null, {
          ...o.attrs,
          [n]: e
        });
      }) : s.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [n]: e
      }), r(s);
    }
    return !0;
  };
}
function kQ(n) {
  return function(e, t) {
    if (!Ci(e)) return !1;
    if (t) {
      const r = xi(e.schema), i = El(e), s = e.tr, o = i.map.cellsInRect(
        n == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : n == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), l = o.map((a) => i.table.nodeAt(a));
      for (let a = 0; a < o.length; a++)
        l[a].type == r.header_cell && s.setNodeMarkup(
          i.tableStart + o[a],
          r.cell,
          l[a].attrs
        );
      if (s.steps.length == 0)
        for (let a = 0; a < o.length; a++)
          s.setNodeMarkup(
            i.tableStart + o[a],
            r.header_cell,
            l[a].attrs
          );
      t(s);
    }
    return !0;
  };
}
function pk(n, e, t) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: n == "row" ? e.map.width : 1,
    bottom: n == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const s = e.table.nodeAt(r[i]);
    if (s && s.type !== t.header_cell)
      return !1;
  }
  return !0;
}
function Tv(n, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? kQ(n) : function(t, r) {
    if (!Ci(t)) return !1;
    if (r) {
      const i = xi(t.schema), s = El(t), o = t.tr, l = pk("row", s, i), a = pk(
        "column",
        s,
        i
      ), u = (n === "column" ? l : n === "row" ? a : !1) ? 1 : 0, h = n == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: s.map.height
      } : n == "row" ? {
        left: u,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, f = n == "column" ? a ? i.cell : i.header_cell : n == "row" ? l ? i.cell : i.header_cell : i.cell;
      s.map.cellsInRect(h).forEach((d) => {
        const p = d + s.tableStart, m = o.doc.nodeAt(p);
        m && o.setNodeMarkup(p, f, m.attrs);
      }), r(o);
    }
    return !0;
  };
}
Tv("row", {
  useDeprecatedLogic: !0
});
Tv("column", {
  useDeprecatedLogic: !0
});
Tv("cell", {
  useDeprecatedLogic: !0
});
function SQ(n, e) {
  if (e < 0) {
    const t = n.nodeBefore;
    if (t) return n.pos - t.nodeSize;
    for (let r = n.index(-1) - 1, i = n.before(); r >= 0; r--) {
      const s = n.node(-1).child(r), o = s.lastChild;
      if (o)
        return i - 1 - o.nodeSize;
      i -= s.nodeSize;
    }
  } else {
    if (n.index() < n.parent.childCount - 1)
      return n.pos + n.nodeAfter.nodeSize;
    const t = n.node(-1);
    for (let r = n.indexAfter(-1), i = n.after(); r < t.childCount; r++) {
      const s = t.child(r);
      if (s.childCount) return i + 1;
      i += s.nodeSize;
    }
  }
  return null;
}
function XE(n) {
  return function(e, t) {
    if (!Ci(e)) return !1;
    const r = SQ(X1(e), n);
    if (r == null) return !1;
    if (t) {
      const i = e.doc.resolve(r);
      t(
        e.tr.setSelection(Ee.between(i, iQ(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function CQ(n, e) {
  const t = n.selection.$anchor;
  for (let r = t.depth; r > 0; r--)
    if (t.node(r).type.spec.tableRole == "table")
      return e && e(
        n.tr.delete(t.before(r), t.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function w0(n, e) {
  const t = n.selection;
  if (!(t instanceof Nt)) return !1;
  if (e) {
    const r = n.tr, i = xi(n.schema).cell.createAndFill().content;
    t.forEachCell((s, o) => {
      s.content.eq(i) || r.replace(
        r.mapping.map(o + 1),
        r.mapping.map(o + s.nodeSize - 1),
        new be(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function MQ(n) {
  if (!n.size) return null;
  let { content: e, openStart: t, openEnd: r } = n;
  for (; e.childCount == 1 && (t > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    t--, r--, e = e.child(0).content;
  const i = e.child(0), s = i.type.spec.tableRole, o = i.type.schema, l = [];
  if (s == "row")
    for (let a = 0; a < e.childCount; a++) {
      let c = e.child(a).content;
      const u = a ? 0 : Math.max(0, t - 1), h = a < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (u || h) && (c = x5(
        xi(o).row,
        new be(c, u, h)
      ).content), l.push(c);
    }
  else if (s == "cell" || s == "header_cell")
    l.push(
      t || r ? x5(
        xi(o).row,
        new be(e, t, r)
      ).content : e
    );
  else
    return null;
  return TQ(o, l);
}
function TQ(n, e) {
  const t = [];
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    for (let o = s.childCount - 1; o >= 0; o--) {
      const { rowspan: l, colspan: a } = s.child(o).attrs;
      for (let c = i; c < i + l; c++)
        t[c] = (t[c] || 0) + a;
    }
  }
  let r = 0;
  for (let i = 0; i < t.length; i++) r = Math.max(r, t[i]);
  for (let i = 0; i < t.length; i++)
    if (i >= e.length && e.push(ce.empty), t[i] < r) {
      const s = xi(n).cell.createAndFill(), o = [];
      for (let l = t[i]; l < r; l++)
        o.push(s);
      e[i] = e[i].append(ce.from(o));
    }
  return { height: e.length, width: r, rows: e };
}
function x5(n, e) {
  const t = n.createAndFill();
  return new hT(t).replace(0, t.content.size, e).doc;
}
function AQ({ width: n, height: e, rows: t }, r, i) {
  if (n != r) {
    const s = [], o = [];
    for (let l = 0; l < t.length; l++) {
      const a = t[l], c = [];
      for (let u = s[l] || 0, h = 0; u < r; h++) {
        let f = a.child(h % a.childCount);
        u + f.attrs.colspan > r && (f = f.type.createChecked(
          Pa(
            f.attrs,
            f.attrs.colspan,
            u + f.attrs.colspan - r
          ),
          f.content
        )), c.push(f), u += f.attrs.colspan;
        for (let d = 1; d < f.attrs.rowspan; d++)
          s[l + d] = (s[l + d] || 0) + f.attrs.colspan;
      }
      o.push(ce.from(c));
    }
    t = o, n = r;
  }
  if (e != i) {
    const s = [];
    for (let o = 0, l = 0; o < i; o++, l++) {
      const a = [], c = t[l % e];
      for (let u = 0; u < c.childCount; u++) {
        let h = c.child(u);
        o + h.attrs.rowspan > i && (h = h.type.create(
          {
            ...h.attrs,
            rowspan: Math.max(1, i - h.attrs.rowspan)
          },
          h.content
        )), a.push(h);
      }
      s.push(ce.from(a));
    }
    t = s, e = i;
  }
  return { width: n, height: e, rows: t };
}
function OQ(n, e, t, r, i, s, o) {
  const l = n.doc.type.schema, a = xi(l);
  let c, u;
  if (i > e.width)
    for (let h = 0, f = 0; h < e.height; h++) {
      const d = t.child(h);
      f += d.nodeSize;
      const p = [];
      let m;
      d.lastChild == null || d.lastChild.type == a.cell ? m = c || (c = a.cell.createAndFill()) : m = u || (u = a.header_cell.createAndFill());
      for (let g = e.width; g < i; g++) p.push(m);
      n.insert(n.mapping.slice(o).map(f - 1 + r), p);
    }
  if (s > e.height) {
    const h = [];
    for (let p = 0, m = (e.height - 1) * e.width; p < Math.max(e.width, i); p++) {
      const g = p >= e.width ? !1 : t.nodeAt(e.map[m + p]).type == a.header_cell;
      h.push(
        g ? u || (u = a.header_cell.createAndFill()) : c || (c = a.cell.createAndFill())
      );
    }
    const f = a.row.create(null, ce.from(h)), d = [];
    for (let p = e.height; p < s; p++) d.push(f);
    n.insert(n.mapping.slice(o).map(r + t.nodeSize - 2), d);
  }
  return !!(c || u);
}
function mk(n, e, t, r, i, s, o, l) {
  if (o == 0 || o == e.height) return !1;
  let a = !1;
  for (let c = i; c < s; c++) {
    const u = o * e.width + c, h = e.map[u];
    if (e.map[u - e.width] == h) {
      a = !0;
      const f = t.nodeAt(h), { top: d, left: p } = e.findCell(h);
      n.setNodeMarkup(n.mapping.slice(l).map(h + r), null, {
        ...f.attrs,
        rowspan: o - d
      }), n.insert(
        n.mapping.slice(l).map(e.positionAt(o, p, t)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: d + f.attrs.rowspan - o
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return a;
}
function gk(n, e, t, r, i, s, o, l) {
  if (o == 0 || o == e.width) return !1;
  let a = !1;
  for (let c = i; c < s; c++) {
    const u = c * e.width + o, h = e.map[u];
    if (e.map[u - 1] == h) {
      a = !0;
      const f = t.nodeAt(h), d = e.colCount(h), p = n.mapping.slice(l).map(h + r);
      n.setNodeMarkup(
        p,
        null,
        Pa(
          f.attrs,
          o - d,
          f.attrs.colspan - (o - d)
        )
      ), n.insert(
        p + f.nodeSize,
        f.type.createAndFill(
          Pa(f.attrs, 0, o - d)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return a;
}
function yk(n, e, t, r, i) {
  let s = t ? n.doc.nodeAt(t - 1) : n.doc;
  if (!s)
    throw new Error("No table found");
  let o = vt.get(s);
  const { top: l, left: a } = r, c = a + i.width, u = l + i.height, h = n.tr;
  let f = 0;
  function d() {
    if (s = t ? h.doc.nodeAt(t - 1) : h.doc, !s)
      throw new Error("No table found");
    o = vt.get(s), f = h.mapping.maps.length;
  }
  OQ(h, o, s, t, c, u, f) && d(), mk(h, o, s, t, a, c, l, f) && d(), mk(h, o, s, t, a, c, u, f) && d(), gk(h, o, s, t, l, u, a, f) && d(), gk(h, o, s, t, l, u, c, f) && d();
  for (let p = l; p < u; p++) {
    const m = o.positionAt(p, a, s), g = o.positionAt(p, c, s);
    h.replace(
      h.mapping.slice(f).map(m + t),
      h.mapping.slice(f).map(g + t),
      new be(i.rows[p - l], 0, 0)
    );
  }
  d(), h.setSelection(
    new Nt(
      h.doc.resolve(t + o.positionAt(l, a, s)),
      h.doc.resolve(t + o.positionAt(u - 1, c - 1, s))
    )
  ), e(h);
}
var EQ = G3({
  ArrowLeft: x0("horiz", -1),
  ArrowRight: x0("horiz", 1),
  ArrowUp: x0("vert", -1),
  ArrowDown: x0("vert", 1),
  "Shift-ArrowLeft": k0("horiz", -1),
  "Shift-ArrowRight": k0("horiz", 1),
  "Shift-ArrowUp": k0("vert", -1),
  "Shift-ArrowDown": k0("vert", 1),
  Backspace: w0,
  "Mod-Backspace": w0,
  Delete: w0,
  "Mod-Delete": w0
});
function Tp(n, e, t) {
  return t.eq(n.selection) ? !1 : (e && e(n.tr.setSelection(t).scrollIntoView()), !0);
}
function x0(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const s = t.selection;
    if (s instanceof Nt)
      return Tp(
        t,
        r,
        Ge.near(s.$headCell, e)
      );
    if (n != "horiz" && !s.empty) return !1;
    const o = ZE(i, n, e);
    if (o == null) return !1;
    if (n == "horiz")
      return Tp(
        t,
        r,
        Ge.near(t.doc.resolve(s.head + e), e)
      );
    {
      const l = t.doc.resolve(o), a = KE(l, n, e);
      let c;
      return a ? c = Ge.near(a, 1) : e < 0 ? c = Ge.near(t.doc.resolve(l.before(-1)), -1) : c = Ge.near(t.doc.resolve(l.after(-1)), 1), Tp(t, r, c);
    }
  };
}
function k0(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const s = t.selection;
    let o;
    if (s instanceof Nt)
      o = s;
    else {
      const a = ZE(i, n, e);
      if (a == null) return !1;
      o = new Nt(t.doc.resolve(a));
    }
    const l = KE(o.$headCell, n, e);
    return l ? Tp(
      t,
      r,
      new Nt(o.$anchorCell, l)
    ) : !1;
  };
}
function IQ(n, e) {
  const t = n.state.doc, r = Ad(t.resolve(e));
  return r ? (n.dispatch(n.state.tr.setSelection(new Nt(r))), !0) : !1;
}
function DQ(n, e, t) {
  if (!Ci(n.state)) return !1;
  let r = MQ(t);
  const i = n.state.selection;
  if (i instanceof Nt) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        ce.from(
          x5(xi(n.state.schema).cell, t)
        )
      ]
    });
    const s = i.$anchorCell.node(-1), o = i.$anchorCell.start(-1), l = vt.get(s).rectBetween(
      i.$anchorCell.pos - o,
      i.$headCell.pos - o
    );
    return r = AQ(r, l.right - l.left, l.bottom - l.top), yk(n.state, n.dispatch, o, l, r), !0;
  } else if (r) {
    const s = X1(n.state), o = s.start(-1);
    return yk(
      n.state,
      n.dispatch,
      o,
      vt.get(s.node(-1)).findCell(s.pos - o),
      r
    ), !0;
  } else
    return !1;
}
function NQ(n, e) {
  var t;
  if (e.ctrlKey || e.metaKey) return;
  const r = bk(n, e.target);
  let i;
  if (e.shiftKey && n.state.selection instanceof Nt)
    s(n.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = Ad(n.state.selection.$anchor)) != null && ((t = q2(n, e)) == null ? void 0 : t.pos) != i.pos)
    s(i, e), e.preventDefault();
  else if (!r)
    return;
  function s(a, c) {
    let u = q2(n, c);
    const h = Go.getState(n.state) == null;
    if (!u || !Mv(a, u))
      if (h) u = a;
      else return;
    const f = new Nt(a, u);
    if (h || !n.state.selection.eq(f)) {
      const d = n.state.tr.setSelection(f);
      h && d.setMeta(Go, a.pos), n.dispatch(d);
    }
  }
  function o() {
    n.root.removeEventListener("mouseup", o), n.root.removeEventListener("dragstart", o), n.root.removeEventListener("mousemove", l), Go.getState(n.state) != null && n.dispatch(n.state.tr.setMeta(Go, -1));
  }
  function l(a) {
    const c = a, u = Go.getState(n.state);
    let h;
    if (u != null)
      h = n.state.doc.resolve(u);
    else if (bk(n, c.target) != r && (h = q2(n, e), !h))
      return o();
    h && s(h, c);
  }
  n.root.addEventListener("mouseup", o), n.root.addEventListener("dragstart", o), n.root.addEventListener("mousemove", l);
}
function ZE(n, e, t) {
  if (!(n.state.selection instanceof Ee)) return null;
  const { $head: r } = n.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const s = r.node(i);
    if ((t < 0 ? r.index(i) : r.indexAfter(i)) != (t < 0 ? 0 : s.childCount)) return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const l = r.before(i), a = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
      return n.endOfTextblock(a) ? l : null;
    }
  }
  return null;
}
function bk(n, e) {
  for (; e && e != n.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function q2(n, e) {
  const t = n.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return t && t ? Ad(n.state.doc.resolve(t.pos)) : null;
}
var RQ = class {
  constructor(n, e) {
    this.node = n, this.defaultCellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${e}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), k5(n, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(n) {
    return n.type != this.node.type ? !1 : (this.node = n, k5(
      n,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(n) {
    return n.type == "attributes" && (n.target == this.table || this.colgroup.contains(n.target));
  }
};
function k5(n, e, t, r, i, s) {
  var o;
  let l = 0, a = !0, c = e.firstChild;
  const u = n.firstChild;
  if (u) {
    for (let h = 0, f = 0; h < u.childCount; h++) {
      const { colspan: d, colwidth: p } = u.child(h).attrs;
      for (let m = 0; m < d; m++, f++) {
        const g = i == f ? s : p && p[m], b = g ? g + "px" : "";
        if (l += g || r, g || (a = !1), c)
          c.style.width != b && (c.style.width = b), c = c.nextSibling;
        else {
          const w = document.createElement("col");
          w.style.width = b, e.appendChild(w);
        }
      }
    }
    for (; c; ) {
      const h = c.nextSibling;
      (o = c.parentNode) == null || o.removeChild(c), c = h;
    }
    a ? (t.style.width = l + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = l + "px");
  }
}
var Kr = new en(
  "tableColumnResizing"
);
function PQ({
  handleWidth: n = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: t = 100,
  View: r = RQ,
  lastColumnResizable: i = !0
} = {}) {
  const s = new Ut({
    key: Kr,
    state: {
      init(o, l) {
        var a, c;
        const u = (c = (a = s.spec) == null ? void 0 : a.props) == null ? void 0 : c.nodeViews, h = xi(l.schema).table.name;
        return r && u && (u[h] = (f, d) => new r(f, t, d)), new _Q(-1, !1);
      },
      apply(o, l) {
        return l.apply(o);
      }
    },
    props: {
      attributes: (o) => {
        const l = Kr.getState(o);
        return l && l.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (o, l) => {
          LQ(o, l, n, i);
        },
        mouseleave: (o) => {
          BQ(o);
        },
        mousedown: (o, l) => {
          zQ(o, l, e, t);
        }
      },
      decorations: (o) => {
        const l = Kr.getState(o);
        if (l && l.activeHandle > -1)
          return qQ(o, l.activeHandle);
      },
      nodeViews: {}
    }
  });
  return s;
}
var _Q = class Ap {
  constructor(e, t) {
    this.activeHandle = e, this.dragging = t;
  }
  apply(e) {
    const t = this, r = e.getMeta(Kr);
    if (r && r.setHandle != null)
      return new Ap(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new Ap(t.activeHandle, r.setDragging);
    if (t.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(t.activeHandle, -1);
      return w5(e.doc.resolve(i)) || (i = -1), new Ap(i, t.dragging);
    }
    return t;
  }
};
function LQ(n, e, t, r) {
  if (!n.editable) return;
  const i = Kr.getState(n.state);
  if (i && !i.dragging) {
    const s = HQ(e.target);
    let o = -1;
    if (s) {
      const { left: l, right: a } = s.getBoundingClientRect();
      e.clientX - l <= t ? o = vk(n, e, "left", t) : a - e.clientX <= t && (o = vk(n, e, "right", t));
    }
    if (o != i.activeHandle) {
      if (!r && o !== -1) {
        const l = n.state.doc.resolve(o), a = l.node(-1), c = vt.get(a), u = l.start(-1);
        if (c.colCount(l.pos - u) + l.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      QE(n, o);
    }
  }
}
function BQ(n) {
  if (!n.editable) return;
  const e = Kr.getState(n.state);
  e && e.activeHandle > -1 && !e.dragging && QE(n, -1);
}
function zQ(n, e, t, r) {
  var i;
  if (!n.editable) return !1;
  const s = (i = n.dom.ownerDocument.defaultView) != null ? i : window, o = Kr.getState(n.state);
  if (!o || o.activeHandle == -1 || o.dragging)
    return !1;
  const l = n.state.doc.nodeAt(o.activeHandle), a = FQ(n, o.activeHandle, l.attrs);
  n.dispatch(
    n.state.tr.setMeta(Kr, {
      setDragging: { startX: e.clientX, startWidth: a }
    })
  );
  function c(h) {
    s.removeEventListener("mouseup", c), s.removeEventListener("mousemove", u);
    const f = Kr.getState(n.state);
    f?.dragging && ($Q(
      n,
      f.activeHandle,
      wk(f.dragging, h, t)
    ), n.dispatch(
      n.state.tr.setMeta(Kr, { setDragging: null })
    ));
  }
  function u(h) {
    if (!h.which) return c(h);
    const f = Kr.getState(n.state);
    if (f && f.dragging) {
      const d = wk(f.dragging, h, t);
      xk(
        n,
        f.activeHandle,
        d,
        r
      );
    }
  }
  return xk(
    n,
    o.activeHandle,
    a,
    r
  ), s.addEventListener("mouseup", c), s.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function FQ(n, e, { colspan: t, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i) return i;
  const s = n.domAtPos(e);
  let l = s.node.childNodes[s.offset].offsetWidth, a = t;
  if (r)
    for (let c = 0; c < t; c++)
      r[c] && (l -= r[c], a--);
  return l / a;
}
function HQ(n) {
  for (; n && n.nodeName != "TD" && n.nodeName != "TH"; )
    n = n.classList && n.classList.contains("ProseMirror") ? null : n.parentNode;
  return n;
}
function vk(n, e, t, r) {
  const i = t == "right" ? -r : r, s = n.posAtCoords({
    left: e.clientX + i,
    top: e.clientY
  });
  if (!s) return -1;
  const { pos: o } = s, l = Ad(n.state.doc.resolve(o));
  if (!l) return -1;
  if (t == "right") return l.pos;
  const a = vt.get(l.node(-1)), c = l.start(-1), u = a.map.indexOf(l.pos - c);
  return u % a.width == 0 ? -1 : c + a.map[u - 1];
}
function wk(n, e, t) {
  const r = e.clientX - n.startX;
  return Math.max(t, n.startWidth + r);
}
function QE(n, e) {
  n.dispatch(
    n.state.tr.setMeta(Kr, { setHandle: e })
  );
}
function $Q(n, e, t) {
  const r = n.state.doc.resolve(e), i = r.node(-1), s = vt.get(i), o = r.start(-1), l = s.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1, a = n.state.tr;
  for (let c = 0; c < s.height; c++) {
    const u = c * s.width + l;
    if (c && s.map[u] == s.map[u - s.width]) continue;
    const h = s.map[u], f = i.nodeAt(h).attrs, d = f.colspan == 1 ? 0 : l - s.colCount(h);
    if (f.colwidth && f.colwidth[d] == t) continue;
    const p = f.colwidth ? f.colwidth.slice() : VQ(f.colspan);
    p[d] = t, a.setNodeMarkup(o + h, null, { ...f, colwidth: p });
  }
  a.docChanged && n.dispatch(a);
}
function xk(n, e, t, r) {
  const i = n.state.doc.resolve(e), s = i.node(-1), o = i.start(-1), l = vt.get(s).colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1;
  let a = n.domAtPos(i.start(-1)).node;
  for (; a && a.nodeName != "TABLE"; )
    a = a.parentNode;
  a && k5(
    s,
    a.firstChild,
    a,
    r,
    l,
    t
  );
}
function VQ(n) {
  return Array(n).fill(0);
}
function qQ(n, e) {
  var t;
  const r = [], i = n.doc.resolve(e), s = i.node(-1);
  if (!s)
    return Et.empty;
  const o = vt.get(s), l = i.start(-1), a = o.colCount(i.pos - l) + i.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < o.height; c++) {
    const u = a + c * o.width;
    if ((a == o.width - 1 || o.map[u] != o.map[u + 1]) && (c == 0 || o.map[u] != o.map[u - o.width])) {
      const h = o.map[u], f = l + h + s.nodeAt(h).nodeSize - 1, d = document.createElement("div");
      d.className = "column-resize-handle", (t = Kr.getState(n)) != null && t.dragging && r.push(
        mn.node(
          l + h,
          l + h + s.nodeAt(h).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(mn.widget(f, d));
    }
  }
  return Et.create(n.doc, r);
}
function WQ({
  allowTableNodeSelection: n = !1
} = {}) {
  return new Ut({
    key: Go,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, t) {
        const r = e.getMeta(Go);
        if (r != null) return r == -1 ? null : r;
        if (t == null || !e.docChanged) return t;
        const { deleted: i, pos: s } = e.mapping.mapResult(t);
        return i ? null : s;
      }
    },
    props: {
      decorations: aQ,
      handleDOMEvents: {
        mousedown: NQ
      },
      createSelectionBetween(e) {
        return Go.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: IQ,
      handleKeyDown: EQ,
      handlePaste: DQ
    },
    appendTransaction(e, t, r) {
      return hQ(
        r,
        dQ(r, t),
        n
      );
    }
  });
}
var _m = typeof navigator < "u" ? navigator : null, Av = _m && _m.userAgent || "", jQ = /Edge\/(\d+)/.exec(Av), UQ = /MSIE \d/.exec(Av), KQ = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Av), GQ = !!(UQ || KQ || jQ), YQ = !GQ && !!_m && /Apple Computer/.test(_m.vendor), eI = new en("safari-ime-span"), S5 = !1, JQ = {
  key: eI,
  props: {
    decorations: XQ,
    handleDOMEvents: {
      compositionstart: () => {
        S5 = !0;
      },
      compositionend: () => {
        S5 = !1;
      }
    }
  }
};
function XQ(n) {
  const { $from: e, $to: t, to: r } = n.selection;
  if (S5 && e.sameParent(t)) {
    const i = mn.widget(r, ZQ, {
      ignoreSelection: !0,
      key: "safari-ime-span"
    });
    return Et.create(n.doc, [i]);
  }
}
function ZQ(n) {
  const e = n.dom.ownerDocument.createElement("span");
  return e.className = "ProseMirror-safari-ime-span", e;
}
var QQ = new Ut(YQ ? JQ : { key: eI });
function kk(n, e) {
  const t = String(n);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, i = t.indexOf(e);
  for (; i !== -1; )
    r++, i = t.indexOf(e, i + e.length);
  return r;
}
function eee(n) {
  if (typeof n != "string")
    throw new TypeError("Expected a string");
  return n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function tee(n, e, t) {
  const i = x1((t || {}).ignore || []), s = nee(e);
  let o = -1;
  for (; ++o < s.length; )
    F3(n, "text", l);
  function l(c, u) {
    let h = -1, f;
    for (; ++h < u.length; ) {
      const d = u[h], p = f ? f.children : void 0;
      if (i(
        d,
        p ? p.indexOf(d) : void 0,
        f
      ))
        return;
      f = d;
    }
    if (f)
      return a(c, u);
  }
  function a(c, u) {
    const h = u[u.length - 1], f = s[o][0], d = s[o][1];
    let p = 0;
    const g = h.children.indexOf(c);
    let b = !1, w = [];
    f.lastIndex = 0;
    let k = f.exec(c.value);
    for (; k; ) {
      const C = k.index, M = {
        index: k.index,
        input: k.input,
        stack: [...u, c]
      };
      let T = d(...k, M);
      if (typeof T == "string" && (T = T.length > 0 ? { type: "text", value: T } : void 0), T === !1 ? f.lastIndex = C + 1 : (p !== C && w.push({
        type: "text",
        value: c.value.slice(p, C)
      }), Array.isArray(T) ? w.push(...T) : T && w.push(T), p = C + k[0].length, b = !0), !f.global)
        break;
      k = f.exec(c.value);
    }
    return b ? (p < c.value.length && w.push({ type: "text", value: c.value.slice(p) }), h.children.splice(g, 1, ...w)) : w = [c], g + w.length;
  }
}
function nee(n) {
  const e = [];
  if (!Array.isArray(n))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const t = !n[0] || Array.isArray(n[0]) ? n : [n];
  let r = -1;
  for (; ++r < t.length; ) {
    const i = t[r];
    e.push([ree(i[0]), iee(i[1])]);
  }
  return e;
}
function ree(n) {
  return typeof n == "string" ? new RegExp(eee(n), "g") : n;
}
function iee(n) {
  return typeof n == "function" ? n : function() {
    return n;
  };
}
const W2 = "phrasing", j2 = ["autolink", "link", "image", "label"];
function see() {
  return {
    transforms: [fee],
    enter: {
      literalAutolink: lee,
      literalAutolinkEmail: U2,
      literalAutolinkHttp: U2,
      literalAutolinkWww: U2
    },
    exit: {
      literalAutolink: hee,
      literalAutolinkEmail: uee,
      literalAutolinkHttp: aee,
      literalAutolinkWww: cee
    }
  };
}
function oee() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: W2,
        notInConstruct: j2
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: W2,
        notInConstruct: j2
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: W2,
        notInConstruct: j2
      }
    ]
  };
}
function lee(n) {
  this.enter({ type: "link", title: null, url: "", children: [] }, n);
}
function U2(n) {
  this.config.enter.autolinkProtocol.call(this, n);
}
function aee(n) {
  this.config.exit.autolinkProtocol.call(this, n);
}
function cee(n) {
  this.config.exit.data.call(this, n);
  const e = this.stack[this.stack.length - 1];
  e.type, e.url = "http://" + this.sliceSerialize(n);
}
function uee(n) {
  this.config.exit.autolinkEmail.call(this, n);
}
function hee(n) {
  this.exit(n);
}
function fee(n) {
  tee(
    n,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, dee],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), pee]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function dee(n, e, t, r, i) {
  let s = "";
  if (!tI(i) || (/^w/i.test(e) && (t = e + t, e = "", s = "http://"), !mee(t)))
    return !1;
  const o = gee(t + r);
  if (!o[0]) return !1;
  const l = {
    type: "link",
    title: null,
    url: s + e + o[0],
    children: [{ type: "text", value: e + o[0] }]
  };
  return o[1] ? [l, { type: "text", value: o[1] }] : l;
}
function pee(n, e, t, r) {
  return (
    // Not an expected previous character.
    !tI(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(t) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + e + "@" + t,
      children: [{ type: "text", value: e + "@" + t }]
    }
  );
}
function mee(n) {
  const e = n.split(".");
  return !(e.length < 2 || e[e.length - 1] && (/_/.test(e[e.length - 1]) || !/[a-zA-Z\d]/.test(e[e.length - 1])) || e[e.length - 2] && (/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2])));
}
function gee(n) {
  const e = /[!"&'),.:;<>?\]}]+$/.exec(n);
  if (!e)
    return [n, void 0];
  n = n.slice(0, e.index);
  let t = e[0], r = t.indexOf(")");
  const i = kk(n, "(");
  let s = kk(n, ")");
  for (; r !== -1 && i > s; )
    n += t.slice(0, r + 1), t = t.slice(r + 1), r = t.indexOf(")"), s++;
  return [n, t];
}
function tI(n, e) {
  const t = n.input.charCodeAt(n.index - 1);
  return (n.index === 0 || Aa(t) || v1(t)) && // If it’s an email, the previous character should not be a slash.
  (!e || t !== 47);
}
nI.peek = Mee;
function yee() {
  this.buffer();
}
function bee(n) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, n);
}
function vee() {
  this.buffer();
}
function wee(n) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    n
  );
}
function xee(n) {
  const e = this.resume(), t = this.stack[this.stack.length - 1];
  t.type, t.identifier = Ri(
    this.sliceSerialize(n)
  ).toLowerCase(), t.label = e;
}
function kee(n) {
  this.exit(n);
}
function See(n) {
  const e = this.resume(), t = this.stack[this.stack.length - 1];
  t.type, t.identifier = Ri(
    this.sliceSerialize(n)
  ).toLowerCase(), t.label = e;
}
function Cee(n) {
  this.exit(n);
}
function Mee() {
  return "[";
}
function nI(n, e, t, r) {
  const i = t.createTracker(r);
  let s = i.move("[^");
  const o = t.enter("footnoteReference"), l = t.enter("reference");
  return s += i.move(
    t.safe(t.associationId(n), { after: "]", before: s })
  ), l(), o(), s += i.move("]"), s;
}
function Tee() {
  return {
    enter: {
      gfmFootnoteCallString: yee,
      gfmFootnoteCall: bee,
      gfmFootnoteDefinitionLabelString: vee,
      gfmFootnoteDefinition: wee
    },
    exit: {
      gfmFootnoteCallString: xee,
      gfmFootnoteCall: kee,
      gfmFootnoteDefinitionLabelString: See,
      gfmFootnoteDefinition: Cee
    }
  };
}
function Aee(n) {
  let e = !1;
  return n && n.firstLineBlank && (e = !0), {
    handlers: { footnoteDefinition: t, footnoteReference: nI },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function t(r, i, s, o) {
    const l = s.createTracker(o);
    let a = l.move("[^");
    const c = s.enter("footnoteDefinition"), u = s.enter("label");
    return a += l.move(
      s.safe(s.associationId(r), { before: a, after: "]" })
    ), u(), a += l.move("]:"), r.children && r.children.length > 0 && (l.shift(4), a += l.move(
      (e ? `
` : " ") + s.indentLines(
        s.containerFlow(r, l.current()),
        e ? rI : Oee
      )
    )), c(), a;
  }
}
function Oee(n, e, t) {
  return e === 0 ? n : rI(n, e, t);
}
function rI(n, e, t) {
  return (t ? "" : "    ") + n;
}
const Eee = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
iI.peek = Pee;
function Iee() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Nee },
    exit: { strikethrough: Ree }
  };
}
function Dee() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Eee
      }
    ],
    handlers: { delete: iI }
  };
}
function Nee(n) {
  this.enter({ type: "delete", children: [] }, n);
}
function Ree(n) {
  this.exit(n);
}
function iI(n, e, t, r) {
  const i = t.createTracker(r), s = t.enter("strikethrough");
  let o = i.move("~~");
  return o += t.containerPhrasing(n, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), s(), o;
}
function Pee() {
  return "~";
}
function _ee(n) {
  return n.length;
}
function Lee(n, e) {
  const t = e || {}, r = (t.align || []).concat(), i = t.stringLength || _ee, s = [], o = [], l = [], a = [];
  let c = 0, u = -1;
  for (; ++u < n.length; ) {
    const m = [], g = [];
    let b = -1;
    for (n[u].length > c && (c = n[u].length); ++b < n[u].length; ) {
      const w = Bee(n[u][b]);
      if (t.alignDelimiters !== !1) {
        const k = i(w);
        g[b] = k, (a[b] === void 0 || k > a[b]) && (a[b] = k);
      }
      m.push(w);
    }
    o[u] = m, l[u] = g;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < c; )
      s[h] = Sk(r[h]);
  else {
    const m = Sk(r);
    for (; ++h < c; )
      s[h] = m;
  }
  h = -1;
  const f = [], d = [];
  for (; ++h < c; ) {
    const m = s[h];
    let g = "", b = "";
    m === 99 ? (g = ":", b = ":") : m === 108 ? g = ":" : m === 114 && (b = ":");
    let w = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      a[h] - g.length - b.length
    );
    const k = g + "-".repeat(w) + b;
    t.alignDelimiters !== !1 && (w = g.length + w + b.length, w > a[h] && (a[h] = w), d[h] = w), f[h] = k;
  }
  o.splice(1, 0, f), l.splice(1, 0, d), u = -1;
  const p = [];
  for (; ++u < o.length; ) {
    const m = o[u], g = l[u];
    h = -1;
    const b = [];
    for (; ++h < c; ) {
      const w = m[h] || "";
      let k = "", C = "";
      if (t.alignDelimiters !== !1) {
        const M = a[h] - (g[h] || 0), T = s[h];
        T === 114 ? k = " ".repeat(M) : T === 99 ? M % 2 ? (k = " ".repeat(M / 2 + 0.5), C = " ".repeat(M / 2 - 0.5)) : (k = " ".repeat(M / 2), C = k) : C = " ".repeat(M);
      }
      t.delimiterStart !== !1 && !h && b.push("|"), t.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && w === "") && (t.delimiterStart !== !1 || h) && b.push(" "), t.alignDelimiters !== !1 && b.push(k), b.push(w), t.alignDelimiters !== !1 && b.push(C), t.padding !== !1 && b.push(" "), (t.delimiterEnd !== !1 || h !== c - 1) && b.push("|");
    }
    p.push(
      t.delimiterEnd === !1 ? b.join("").replace(/ +$/, "") : b.join("")
    );
  }
  return p.join(`
`);
}
function Bee(n) {
  return n == null ? "" : String(n);
}
function Sk(n) {
  const e = typeof n == "string" ? n.codePointAt(0) : 0;
  return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0;
}
function zee() {
  return {
    enter: {
      table: Fee,
      tableData: Ck,
      tableHeader: Ck,
      tableRow: $ee
    },
    exit: {
      codeText: Vee,
      table: Hee,
      tableData: K2,
      tableHeader: K2,
      tableRow: K2
    }
  };
}
function Fee(n) {
  const e = n._align;
  this.enter(
    {
      type: "table",
      align: e.map(function(t) {
        return t === "none" ? null : t;
      }),
      children: []
    },
    n
  ), this.data.inTable = !0;
}
function Hee(n) {
  this.exit(n), this.data.inTable = void 0;
}
function $ee(n) {
  this.enter({ type: "tableRow", children: [] }, n);
}
function K2(n) {
  this.exit(n);
}
function Ck(n) {
  this.enter({ type: "tableCell", children: [] }, n);
}
function Vee(n) {
  let e = this.resume();
  this.data.inTable && (e = e.replace(/\\([\\|])/g, qee));
  const t = this.stack[this.stack.length - 1];
  t.type, t.value = e, this.exit(n);
}
function qee(n, e) {
  return e === "|" ? e : n;
}
function Wee(n) {
  const e = n || {}, t = e.tableCellPadding, r = e.tablePipeAlign, i = e.stringLength, s = t ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: f,
      table: o,
      tableCell: a,
      tableRow: l
    }
  };
  function o(d, p, m, g) {
    return c(u(d, m, g), d.align);
  }
  function l(d, p, m, g) {
    const b = h(d, m, g), w = c([b]);
    return w.slice(0, w.indexOf(`
`));
  }
  function a(d, p, m, g) {
    const b = m.enter("tableCell"), w = m.enter("phrasing"), k = m.containerPhrasing(d, {
      ...g,
      before: s,
      after: s
    });
    return w(), b(), k;
  }
  function c(d, p) {
    return Lee(d, {
      align: p,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: t,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(d, p, m) {
    const g = d.children;
    let b = -1;
    const w = [], k = p.enter("table");
    for (; ++b < g.length; )
      w[b] = h(g[b], p, m);
    return k(), w;
  }
  function h(d, p, m) {
    const g = d.children;
    let b = -1;
    const w = [], k = p.enter("tableRow");
    for (; ++b < g.length; )
      w[b] = a(g[b], d, p, m);
    return k(), w;
  }
  function f(d, p, m) {
    let g = $3.inlineCode(d, p, m);
    return m.stack.includes("tableCell") && (g = g.replace(/\|/g, "\\$&")), g;
  }
}
function jee() {
  return {
    exit: {
      taskListCheckValueChecked: Mk,
      taskListCheckValueUnchecked: Mk,
      paragraph: Kee
    }
  };
}
function Uee() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: Gee }
  };
}
function Mk(n) {
  const e = this.stack[this.stack.length - 2];
  e.type, e.checked = n.type === "taskListCheckValueChecked";
}
function Kee(n) {
  const e = this.stack[this.stack.length - 2];
  if (e && e.type === "listItem" && typeof e.checked == "boolean") {
    const t = this.stack[this.stack.length - 1];
    t.type;
    const r = t.children[0];
    if (r && r.type === "text") {
      const i = e.children;
      let s = -1, o;
      for (; ++s < i.length; ) {
        const l = i[s];
        if (l.type === "paragraph") {
          o = l;
          break;
        }
      }
      o === t && (r.value = r.value.slice(1), r.value.length === 0 ? t.children.shift() : t.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, t.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(n);
}
function Gee(n, e, t, r) {
  const i = n.children[0], s = typeof n.checked == "boolean" && i && i.type === "paragraph", o = "[" + (n.checked ? "x" : " ") + "] ", l = t.createTracker(r);
  s && l.move(o);
  let a = $3.listItem(n, e, t, {
    ...r,
    ...l.current()
  });
  return s && (a = a.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), a;
  function c(u) {
    return u + o;
  }
}
function Yee() {
  return [
    see(),
    Tee(),
    Iee(),
    zee(),
    jee()
  ];
}
function Jee(n) {
  return {
    extensions: [
      oee(),
      Aee(n),
      Dee(),
      Wee(n),
      Uee()
    ]
  };
}
const Xee = {
  tokenize: rte,
  partial: !0
}, sI = {
  tokenize: ite,
  partial: !0
}, oI = {
  tokenize: ste,
  partial: !0
}, lI = {
  tokenize: ote,
  partial: !0
}, Zee = {
  tokenize: lte,
  partial: !0
}, aI = {
  name: "wwwAutolink",
  tokenize: tte,
  previous: uI
}, cI = {
  name: "protocolAutolink",
  tokenize: nte,
  previous: hI
}, Mo = {
  name: "emailAutolink",
  tokenize: ete,
  previous: fI
}, Es = {};
function Qee() {
  return {
    text: Es
  };
}
let zl = 48;
for (; zl < 123; )
  Es[zl] = Mo, zl++, zl === 58 ? zl = 65 : zl === 91 && (zl = 97);
Es[43] = Mo;
Es[45] = Mo;
Es[46] = Mo;
Es[95] = Mo;
Es[72] = [Mo, cI];
Es[104] = [Mo, cI];
Es[87] = [Mo, aI];
Es[119] = [Mo, aI];
function ete(n, e, t) {
  const r = this;
  let i, s;
  return o;
  function o(h) {
    return !C5(h) || !fI.call(r, r.previous) || Ov(r.events) ? t(h) : (n.enter("literalAutolink"), n.enter("literalAutolinkEmail"), l(h));
  }
  function l(h) {
    return C5(h) ? (n.consume(h), l) : h === 64 ? (n.consume(h), a) : t(h);
  }
  function a(h) {
    return h === 46 ? n.check(Zee, u, c)(h) : h === 45 || h === 95 || Tr(h) ? (s = !0, n.consume(h), a) : u(h);
  }
  function c(h) {
    return n.consume(h), i = !0, a;
  }
  function u(h) {
    return s && i && lr(r.previous) ? (n.exit("literalAutolinkEmail"), n.exit("literalAutolink"), e(h)) : t(h);
  }
}
function tte(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o !== 87 && o !== 119 || !uI.call(r, r.previous) || Ov(r.events) ? t(o) : (n.enter("literalAutolink"), n.enter("literalAutolinkWww"), n.check(Xee, n.attempt(sI, n.attempt(oI, s), t), t)(o));
  }
  function s(o) {
    return n.exit("literalAutolinkWww"), n.exit("literalAutolink"), e(o);
  }
}
function nte(n, e, t) {
  const r = this;
  let i = "", s = !1;
  return o;
  function o(h) {
    return (h === 72 || h === 104) && hI.call(r, r.previous) && !Ov(r.events) ? (n.enter("literalAutolink"), n.enter("literalAutolinkHttp"), i += String.fromCodePoint(h), n.consume(h), l) : t(h);
  }
  function l(h) {
    if (lr(h) && i.length < 5)
      return i += String.fromCodePoint(h), n.consume(h), l;
    if (h === 58) {
      const f = i.toLowerCase();
      if (f === "http" || f === "https")
        return n.consume(h), a;
    }
    return t(h);
  }
  function a(h) {
    return h === 47 ? (n.consume(h), s ? c : (s = !0, a)) : t(h);
  }
  function c(h) {
    return h === null || pm(h) || Dt(h) || Aa(h) || v1(h) ? t(h) : n.attempt(sI, n.attempt(oI, u), t)(h);
  }
  function u(h) {
    return n.exit("literalAutolinkHttp"), n.exit("literalAutolink"), e(h);
  }
}
function rte(n, e, t) {
  let r = 0;
  return i;
  function i(o) {
    return (o === 87 || o === 119) && r < 3 ? (r++, n.consume(o), i) : o === 46 && r === 3 ? (n.consume(o), s) : t(o);
  }
  function s(o) {
    return o === null ? t(o) : e(o);
  }
}
function ite(n, e, t) {
  let r, i, s;
  return o;
  function o(c) {
    return c === 46 || c === 95 ? n.check(lI, a, l)(c) : c === null || Dt(c) || Aa(c) || c !== 45 && v1(c) ? a(c) : (s = !0, n.consume(c), o);
  }
  function l(c) {
    return c === 95 ? r = !0 : (i = r, r = void 0), n.consume(c), o;
  }
  function a(c) {
    return i || r || !s ? t(c) : e(c);
  }
}
function ste(n, e) {
  let t = 0, r = 0;
  return i;
  function i(o) {
    return o === 40 ? (t++, n.consume(o), i) : o === 41 && r < t ? s(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? n.check(lI, e, s)(o) : o === null || Dt(o) || Aa(o) ? e(o) : (n.consume(o), i);
  }
  function s(o) {
    return o === 41 && r++, n.consume(o), i;
  }
}
function ote(n, e, t) {
  return r;
  function r(l) {
    return l === 33 || l === 34 || l === 39 || l === 41 || l === 42 || l === 44 || l === 46 || l === 58 || l === 59 || l === 63 || l === 95 || l === 126 ? (n.consume(l), r) : l === 38 ? (n.consume(l), s) : l === 93 ? (n.consume(l), i) : (
      // `<` is an end.
      l === 60 || // So is whitespace.
      l === null || Dt(l) || Aa(l) ? e(l) : t(l)
    );
  }
  function i(l) {
    return l === null || l === 40 || l === 91 || Dt(l) || Aa(l) ? e(l) : r(l);
  }
  function s(l) {
    return lr(l) ? o(l) : t(l);
  }
  function o(l) {
    return l === 59 ? (n.consume(l), r) : lr(l) ? (n.consume(l), o) : t(l);
  }
}
function lte(n, e, t) {
  return r;
  function r(s) {
    return n.consume(s), i;
  }
  function i(s) {
    return Tr(s) ? t(s) : e(s);
  }
}
function uI(n) {
  return n === null || n === 40 || n === 42 || n === 95 || n === 91 || n === 93 || n === 126 || Dt(n);
}
function hI(n) {
  return !lr(n);
}
function fI(n) {
  return !(n === 47 || C5(n));
}
function C5(n) {
  return n === 43 || n === 45 || n === 46 || n === 95 || Tr(n);
}
function Ov(n) {
  let e = n.length, t = !1;
  for (; e--; ) {
    const r = n[e][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      t = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      t = !1;
      break;
    }
  }
  return n.length > 0 && !t && (n[n.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), t;
}
const ate = {
  tokenize: gte,
  partial: !0
};
function cte() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: dte,
        continuation: {
          tokenize: pte
        },
        exit: mte
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: fte
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: ute,
        resolveTo: hte
      }
    }
  };
}
function ute(n, e, t) {
  const r = this;
  let i = r.events.length;
  const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o;
  for (; i--; ) {
    const a = r.events[i][1];
    if (a.type === "labelImage") {
      o = a;
      break;
    }
    if (a.type === "gfmFootnoteCall" || a.type === "labelLink" || a.type === "label" || a.type === "image" || a.type === "link")
      break;
  }
  return l;
  function l(a) {
    if (!o || !o._balanced)
      return t(a);
    const c = Ri(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !s.includes(c.slice(1)) ? t(a) : (n.enter("gfmFootnoteCallLabelMarker"), n.consume(a), n.exit("gfmFootnoteCallLabelMarker"), e(a));
  }
}
function hte(n, e) {
  let t = n.length;
  for (; t--; )
    if (n[t][1].type === "labelImage" && n[t][0] === "enter") {
      n[t][1];
      break;
    }
  n[t + 1][1].type = "data", n[t + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, n[t + 3][1].start),
    end: Object.assign({}, n[n.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, n[t + 3][1].end),
    end: Object.assign({}, n[t + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, n[n.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, l = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    n[t + 1],
    n[t + 2],
    ["enter", r, e],
    // The `[`
    n[t + 3],
    n[t + 4],
    // The `^`.
    ["enter", i, e],
    ["exit", i, e],
    // Everything in between.
    ["enter", s, e],
    ["enter", o, e],
    ["exit", o, e],
    ["exit", s, e],
    // The ending (`]`, properly parsed and labelled).
    n[n.length - 2],
    n[n.length - 1],
    ["exit", r, e]
  ];
  return n.splice(t, n.length - t + 1, ...l), n;
}
function fte(n, e, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s = 0, o;
  return l;
  function l(h) {
    return n.enter("gfmFootnoteCall"), n.enter("gfmFootnoteCallLabelMarker"), n.consume(h), n.exit("gfmFootnoteCallLabelMarker"), a;
  }
  function a(h) {
    return h !== 94 ? t(h) : (n.enter("gfmFootnoteCallMarker"), n.consume(h), n.exit("gfmFootnoteCallMarker"), n.enter("gfmFootnoteCallString"), n.enter("chunkString").contentType = "string", c);
  }
  function c(h) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      h === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Dt(h)
    )
      return t(h);
    if (h === 93) {
      n.exit("chunkString");
      const f = n.exit("gfmFootnoteCallString");
      return i.includes(Ri(r.sliceSerialize(f))) ? (n.enter("gfmFootnoteCallLabelMarker"), n.consume(h), n.exit("gfmFootnoteCallLabelMarker"), n.exit("gfmFootnoteCall"), e) : t(h);
    }
    return Dt(h) || (o = !0), s++, n.consume(h), h === 92 ? u : c;
  }
  function u(h) {
    return h === 91 || h === 92 || h === 93 ? (n.consume(h), s++, c) : c(h);
  }
}
function dte(n, e, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s, o = 0, l;
  return a;
  function a(p) {
    return n.enter("gfmFootnoteDefinition")._container = !0, n.enter("gfmFootnoteDefinitionLabel"), n.enter("gfmFootnoteDefinitionLabelMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(p) {
    return p === 94 ? (n.enter("gfmFootnoteDefinitionMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionMarker"), n.enter("gfmFootnoteDefinitionLabelString"), n.enter("chunkString").contentType = "string", u) : t(p);
  }
  function u(p) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      p === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || Dt(p)
    )
      return t(p);
    if (p === 93) {
      n.exit("chunkString");
      const m = n.exit("gfmFootnoteDefinitionLabelString");
      return s = Ri(r.sliceSerialize(m)), n.enter("gfmFootnoteDefinitionLabelMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionLabelMarker"), n.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return Dt(p) || (l = !0), o++, n.consume(p), p === 92 ? h : u;
  }
  function h(p) {
    return p === 91 || p === 92 || p === 93 ? (n.consume(p), o++, u) : u(p);
  }
  function f(p) {
    return p === 58 ? (n.enter("definitionMarker"), n.consume(p), n.exit("definitionMarker"), i.includes(s) || i.push(s), it(n, d, "gfmFootnoteDefinitionWhitespace")) : t(p);
  }
  function d(p) {
    return e(p);
  }
}
function pte(n, e, t) {
  return n.check(fd, e, n.attempt(ate, e, t));
}
function mte(n) {
  n.exit("gfmFootnoteDefinition");
}
function gte(n, e, t) {
  const r = this;
  return it(n, i, "gfmFootnoteDefinitionIndent", 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? e(s) : t(s);
  }
}
function yte(n) {
  let t = (n || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: i
  };
  return t == null && (t = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, l) {
    let a = -1;
    for (; ++a < o.length; )
      if (o[a][0] === "enter" && o[a][1].type === "strikethroughSequenceTemporary" && o[a][1]._close) {
        let c = a;
        for (; c--; )
          if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && // If the sizes are the same:
          o[a][1].end.offset - o[a][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
            o[a][1].type = "strikethroughSequence", o[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, o[c][1].start),
              end: Object.assign({}, o[a][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, o[c][1].end),
              end: Object.assign({}, o[a][1].start)
            }, f = [["enter", u, l], ["enter", o[c][1], l], ["exit", o[c][1], l], ["enter", h, l]], d = l.parser.constructs.insideSpan.null;
            d && Jr(f, f.length, 0, w1(d, o.slice(c + 1, a), l)), Jr(f, f.length, 0, [["exit", h, l], ["enter", o[a][1], l], ["exit", o[a][1], l], ["exit", u, l]]), Jr(o, c - 1, a - c + 3, f), a = c + f.length - 2;
            break;
          }
      }
    for (a = -1; ++a < o.length; )
      o[a][1].type === "strikethroughSequenceTemporary" && (o[a][1].type = "data");
    return o;
  }
  function s(o, l, a) {
    const c = this.previous, u = this.events;
    let h = 0;
    return f;
    function f(p) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? a(p) : (o.enter("strikethroughSequenceTemporary"), d(p));
    }
    function d(p) {
      const m = Fc(c);
      if (p === 126)
        return h > 1 ? a(p) : (o.consume(p), h++, d);
      if (h < 2 && !t) return a(p);
      const g = o.exit("strikethroughSequenceTemporary"), b = Fc(p);
      return g._open = !b || b === 2 && !!m, g._close = !m || m === 2 && !!b, l(p);
    }
  }
}
class bte {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(e, t, r) {
    vte(this, e, t, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(e) {
    if (this.map.sort(function(s, o) {
      return s[0] - o[0];
    }), this.map.length === 0)
      return;
    let t = this.map.length;
    const r = [];
    for (; t > 0; )
      t -= 1, r.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), e.length = this.map[t][0];
    r.push(e.slice()), e.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const s of i)
        e.push(s);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function vte(n, e, t, r) {
  let i = 0;
  if (!(t === 0 && r.length === 0)) {
    for (; i < n.map.length; ) {
      if (n.map[i][0] === e) {
        n.map[i][1] += t, n.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    n.map.push([e, t, r]);
  }
}
function wte(n, e) {
  let t = !1;
  const r = [];
  for (; e < n.length; ) {
    const i = n[e];
    if (t) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(n[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (n[e - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (t = !0);
    e += 1;
  }
  return r;
}
function xte() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: kte,
        resolveAll: Ste
      }
    }
  };
}
function kte(n, e, t) {
  const r = this;
  let i = 0, s = 0, o;
  return l;
  function l(R) {
    let V = r.events.length - 1;
    for (; V > -1; ) {
      const ie = r.events[V][1].type;
      if (ie === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      ie === "linePrefix") V--;
      else break;
    }
    const z = V > -1 ? r.events[V][1].type : null, ue = z === "tableHead" || z === "tableRow" ? T : a;
    return ue === T && r.parser.lazy[r.now().line] ? t(R) : ue(R);
  }
  function a(R) {
    return n.enter("tableHead"), n.enter("tableRow"), c(R);
  }
  function c(R) {
    return R === 124 || (o = !0, s += 1), u(R);
  }
  function u(R) {
    return R === null ? t(R) : Ne(R) ? s > 1 ? (s = 0, r.interrupt = !0, n.exit("tableRow"), n.enter("lineEnding"), n.consume(R), n.exit("lineEnding"), d) : t(R) : lt(R) ? it(n, u, "whitespace")(R) : (s += 1, o && (o = !1, i += 1), R === 124 ? (n.enter("tableCellDivider"), n.consume(R), n.exit("tableCellDivider"), o = !0, u) : (n.enter("data"), h(R)));
  }
  function h(R) {
    return R === null || R === 124 || Dt(R) ? (n.exit("data"), u(R)) : (n.consume(R), R === 92 ? f : h);
  }
  function f(R) {
    return R === 92 || R === 124 ? (n.consume(R), h) : h(R);
  }
  function d(R) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? t(R) : (n.enter("tableDelimiterRow"), o = !1, lt(R) ? it(n, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(R) : p(R));
  }
  function p(R) {
    return R === 45 || R === 58 ? g(R) : R === 124 ? (o = !0, n.enter("tableCellDivider"), n.consume(R), n.exit("tableCellDivider"), m) : M(R);
  }
  function m(R) {
    return lt(R) ? it(n, g, "whitespace")(R) : g(R);
  }
  function g(R) {
    return R === 58 ? (s += 1, o = !0, n.enter("tableDelimiterMarker"), n.consume(R), n.exit("tableDelimiterMarker"), b) : R === 45 ? (s += 1, b(R)) : R === null || Ne(R) ? C(R) : M(R);
  }
  function b(R) {
    return R === 45 ? (n.enter("tableDelimiterFiller"), w(R)) : M(R);
  }
  function w(R) {
    return R === 45 ? (n.consume(R), w) : R === 58 ? (o = !0, n.exit("tableDelimiterFiller"), n.enter("tableDelimiterMarker"), n.consume(R), n.exit("tableDelimiterMarker"), k) : (n.exit("tableDelimiterFiller"), k(R));
  }
  function k(R) {
    return lt(R) ? it(n, C, "whitespace")(R) : C(R);
  }
  function C(R) {
    return R === 124 ? p(R) : R === null || Ne(R) ? !o || i !== s ? M(R) : (n.exit("tableDelimiterRow"), n.exit("tableHead"), e(R)) : M(R);
  }
  function M(R) {
    return t(R);
  }
  function T(R) {
    return n.enter("tableRow"), N(R);
  }
  function N(R) {
    return R === 124 ? (n.enter("tableCellDivider"), n.consume(R), n.exit("tableCellDivider"), N) : R === null || Ne(R) ? (n.exit("tableRow"), e(R)) : lt(R) ? it(n, N, "whitespace")(R) : (n.enter("data"), B(R));
  }
  function B(R) {
    return R === null || R === 124 || Dt(R) ? (n.exit("data"), N(R)) : (n.consume(R), R === 92 ? $ : B);
  }
  function $(R) {
    return R === 92 || R === 124 ? (n.consume(R), B) : B(R);
  }
}
function Ste(n, e) {
  let t = -1, r = !0, i = 0, s = [0, 0, 0, 0], o = [0, 0, 0, 0], l = !1, a = 0, c, u, h;
  const f = new bte();
  for (; ++t < n.length; ) {
    const d = n[t], p = d[1];
    d[0] === "enter" ? p.type === "tableHead" ? (l = !1, a !== 0 && (Tk(f, e, a, c, u), u = void 0, a = 0), c = {
      type: "table",
      start: Object.assign({}, p.start),
      // Note: correct end is set later.
      end: Object.assign({}, p.end)
    }, f.add(t, 0, [["enter", c, e]])) : p.type === "tableRow" || p.type === "tableDelimiterRow" ? (r = !0, h = void 0, s = [0, 0, 0, 0], o = [0, t + 1, 0, 0], l && (l = !1, u = {
      type: "tableBody",
      start: Object.assign({}, p.start),
      // Note: correct end is set later.
      end: Object.assign({}, p.end)
    }, f.add(t, 0, [["enter", u, e]])), i = p.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (s[1] !== 0 && (o[0] = o[1], h = S0(f, e, s, i, void 0, h), s = [0, 0, 0, 0]), o[2] = t)) : p.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (o[0] = o[1], h = S0(f, e, s, i, void 0, h)), s = o, o = [s[1], t, 0, 0])) : p.type === "tableHead" ? (l = !0, a = t) : p.type === "tableRow" || p.type === "tableDelimiterRow" ? (a = t, s[1] !== 0 ? (o[0] = o[1], h = S0(f, e, s, i, t, h)) : o[1] !== 0 && (h = S0(f, e, o, i, t, h)), i = 0) : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") && (o[3] = t);
  }
  for (a !== 0 && Tk(f, e, a, c, u), f.consume(e.events), t = -1; ++t < e.events.length; ) {
    const d = e.events[t];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = wte(e.events, t));
  }
  return n;
}
function S0(n, e, t, r, i, s) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", l = "tableContent";
  t[0] !== 0 && (s.end = Object.assign({}, oc(e.events, t[0])), n.add(t[0], 0, [["exit", s, e]]));
  const a = oc(e.events, t[1]);
  if (s = {
    type: o,
    start: Object.assign({}, a),
    // Note: correct end is set later.
    end: Object.assign({}, a)
  }, n.add(t[1], 0, [["enter", s, e]]), t[2] !== 0) {
    const c = oc(e.events, t[2]), u = oc(e.events, t[3]), h = {
      type: l,
      start: Object.assign({}, c),
      end: Object.assign({}, u)
    };
    if (n.add(t[2], 0, [["enter", h, e]]), r !== 2) {
      const f = e.events[t[2]], d = e.events[t[3]];
      if (f[1].end = Object.assign({}, d[1].end), f[1].type = "chunkText", f[1].contentType = "text", t[3] > t[2] + 1) {
        const p = t[2] + 1, m = t[3] - t[2] - 1;
        n.add(p, m, []);
      }
    }
    n.add(t[3] + 1, 0, [["exit", h, e]]);
  }
  return i !== void 0 && (s.end = Object.assign({}, oc(e.events, i)), n.add(i, 0, [["exit", s, e]]), s = void 0), s;
}
function Tk(n, e, t, r, i) {
  const s = [], o = oc(e.events, t);
  i && (i.end = Object.assign({}, o), s.push(["exit", i, e])), r.end = Object.assign({}, o), s.push(["exit", r, e]), n.add(t + 1, 0, s);
}
function oc(n, e) {
  const t = n[e], r = t[0] === "enter" ? "start" : "end";
  return t[1][r];
}
const Cte = {
  name: "tasklistCheck",
  tokenize: Tte
};
function Mte() {
  return {
    text: {
      91: Cte
    }
  };
}
function Tte(n, e, t) {
  const r = this;
  return i;
  function i(a) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? t(a) : (n.enter("taskListCheck"), n.enter("taskListCheckMarker"), n.consume(a), n.exit("taskListCheckMarker"), s)
    );
  }
  function s(a) {
    return Dt(a) ? (n.enter("taskListCheckValueUnchecked"), n.consume(a), n.exit("taskListCheckValueUnchecked"), o) : a === 88 || a === 120 ? (n.enter("taskListCheckValueChecked"), n.consume(a), n.exit("taskListCheckValueChecked"), o) : t(a);
  }
  function o(a) {
    return a === 93 ? (n.enter("taskListCheckMarker"), n.consume(a), n.exit("taskListCheckMarker"), n.exit("taskListCheck"), l) : t(a);
  }
  function l(a) {
    return Ne(a) ? e(a) : lt(a) ? n.check({
      tokenize: Ate
    }, e, t)(a) : t(a);
  }
}
function Ate(n, e, t) {
  return it(n, r, "whitespace");
  function r(i) {
    return i === null ? t(i) : e(i);
  }
}
function Ote(n) {
  return TT([
    Qee(),
    cte(),
    yte(n),
    xte(),
    Mte()
  ]);
}
const Ete = {};
function Ite(n) {
  const e = (
    /** @type {Processor<Root>} */
    this
  ), t = n || Ete, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(Ote(t)), s.push(Yee()), o.push(Jee(t));
}
function Je(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/preset-gfm",
      ...e
    }
  }), n;
}
const Ev = bd("strike_through");
Je(Ev, {
  displayName: "Attr<strikethrough>",
  group: "Strikethrough"
});
const hu = iu("strike_through", (n) => ({
  parseDOM: [
    { tag: "del" },
    {
      style: "text-decoration",
      getAttrs: (e) => e === "line-through"
    }
  ],
  toDOM: (e) => ["del", n.get(Ev.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "delete",
    runner: (e, t, r) => {
      e.openMark(r), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strike_through",
    runner: (e, t) => {
      e.withMark(t, "delete");
    }
  }
}));
Je(hu.mark, {
  displayName: "MarkSchema<strikethrough>",
  group: "Strikethrough"
});
Je(hu.ctx, {
  displayName: "MarkSchemaCtx<strikethrough>",
  group: "Strikethrough"
});
const Z1 = Ye(
  "ToggleStrikeThrough",
  (n) => () => S1(hu.type(n))
);
Je(Z1, {
  displayName: "Command<ToggleStrikethrough>",
  group: "Strikethrough"
});
const dI = Qn((n) => hd(
  new RegExp("(?<![\\w:/])(~{1,2})(.+?)\\1(?!\\w|\\/)"),
  hu.type(n)
));
Je(dI, {
  displayName: "InputRule<strikethrough>",
  group: "Strikethrough"
});
const Iv = Rr("strikeThroughKeymap", {
  ToggleStrikethrough: {
    shortcuts: "Mod-Alt-x",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Z1.key);
    }
  }
});
Je(Iv.ctx, {
  displayName: "KeymapCtx<strikethrough>",
  group: "Strikethrough"
});
Je(Iv.shortcuts, {
  displayName: "Keymap<strikethrough>",
  group: "Strikethrough"
});
const Od = nQ({
  tableGroup: "block",
  cellContent: "paragraph",
  cellAttributes: {
    alignment: {
      default: "left",
      getFromDOM: (n) => n.style.textAlign || "left",
      setDOMAttr: (n, e) => {
        e.style = `text-align: ${n || "left"}`;
      }
    }
  }
}), $a = hn("table", () => ({
  ...Od.table,
  content: "table_header_row table_row+",
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "table",
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r,
        isHeader: o === 0
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table",
    runner: (n, e) => {
      const t = e.content.firstChild?.content;
      if (!t) return;
      const r = [];
      t.forEach((i) => {
        r.push(i.attrs.alignment);
      }), n.openNode("table", void 0, { align: r }), n.next(e.content), n.closeNode();
    }
  }
}));
Je($a.node, {
  displayName: "NodeSchema<table>",
  group: "Table"
});
Je($a.ctx, {
  displayName: "NodeSchemaCtx<table>",
  group: "Table"
});
const Q1 = hn("table_header_row", () => ({
  ...Od.table_row,
  disableDropCursor: !0,
  content: "(table_header)*",
  parseDOM: [{ tag: "tr[data-is-header]" }],
  toDOM() {
    return ["tr", { "data-is-header": !0 }, 0];
  },
  parseMarkdown: {
    match: (n) => !!(n.type === "tableRow" && n.isHeader),
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r[o],
        isHeader: e.isHeader
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_header_row",
    runner: (n, e) => {
      n.openNode("tableRow", void 0, { isHeader: !0 }), n.next(e.content), n.closeNode();
    }
  }
}));
Je(Q1.node, {
  displayName: "NodeSchema<tableHeaderRow>",
  group: "Table"
});
Je(Q1.ctx, {
  displayName: "NodeSchemaCtx<tableHeaderRow>",
  group: "Table"
});
const Ed = hn("table_row", () => ({
  ...Od.table_row,
  disableDropCursor: !0,
  content: "(table_cell)*",
  parseMarkdown: {
    match: (n) => n.type === "tableRow",
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r[o]
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_row",
    runner: (n, e) => {
      e.content.size !== 0 && (n.openNode("tableRow"), n.next(e.content), n.closeNode());
    }
  }
}));
Je(Ed.node, {
  displayName: "NodeSchema<tableRow>",
  group: "Table"
});
Je(Ed.ctx, {
  displayName: "NodeSchemaCtx<tableRow>",
  group: "Table"
});
const Id = hn("table_cell", () => ({
  ...Od.table_cell,
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "tableCell" && !n.isHeader,
    runner: (n, e, t) => {
      const r = e.align;
      n.openNode(t, { alignment: r }).openNode(n.schema.nodes.paragraph).next(e.children).closeNode().closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_cell",
    runner: (n, e) => {
      n.openNode("tableCell").next(e.content).closeNode();
    }
  }
}));
Je(Id.node, {
  displayName: "NodeSchema<tableCell>",
  group: "Table"
});
Je(Id.ctx, {
  displayName: "NodeSchemaCtx<tableCell>",
  group: "Table"
});
const eg = hn("table_header", () => ({
  ...Od.table_header,
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "tableCell" && !!n.isHeader,
    runner: (n, e, t) => {
      const r = e.align;
      n.openNode(t, { alignment: r }), n.openNode(n.schema.nodes.paragraph), n.next(e.children), n.closeNode(), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_header",
    runner: (n, e) => {
      n.openNode("tableCell"), n.next(e.content), n.closeNode();
    }
  }
}));
Je(eg.node, {
  displayName: "NodeSchema<tableHeader>",
  group: "Table"
});
Je(eg.ctx, {
  displayName: "NodeSchemaCtx<tableHeader>",
  group: "Table"
});
function Dv(n, e = 3, t = 3) {
  const r = Array(t).fill(0).map(() => Id.type(n).createAndFill()), i = Array(t).fill(0).map(() => eg.type(n).createAndFill()), s = Array(e).fill(0).map(
    (o, l) => l === 0 ? Q1.type(n).create(null, i) : Ed.type(n).create(null, r)
  );
  return $a.type(n).create(null, s);
}
function fu(n) {
  return R3(
    (e) => e.type.spec.tableRole === "table"
  )(n);
}
function lc(n, e) {
  const t = fu(e.$from);
  if (!t) return;
  const r = vt.get(t.node);
  return (Array.isArray(n) ? n : [n]).filter((s) => s >= 0 && s <= r.width - 1).flatMap((s) => r.cellsInRect({
    left: s,
    right: s + 1,
    top: 0,
    bottom: r.height
  }).map((l) => {
    const a = t.node.nodeAt(l), c = l + t.start;
    return { pos: c, start: c + 1, node: a, depth: t.depth + 2 };
  }));
}
function ac(n, e) {
  const t = fu(e.$from);
  if (!t)
    return;
  const r = vt.get(t.node);
  return (Array.isArray(n) ? n : [n]).filter((s) => s >= 0 && s <= r.height - 1).flatMap((s) => r.cellsInRect({
    left: 0,
    right: r.width,
    top: s,
    bottom: s + 1
  }).map((l) => {
    const a = t.node.nodeAt(l), c = l + t.start;
    return { pos: c, start: c + 1, node: a, depth: t.depth + 2 };
  }));
}
function pI(n) {
  return (e, t) => (r) => {
    t = t ?? r.selection.from;
    const i = r.doc.resolve(t), s = R3(
      (a) => a.type.name === "table"
    )(i), o = s ? {
      node: s.node,
      from: s.start
    } : void 0, l = n === "row";
    if (o) {
      const a = vt.get(o.node);
      if (e >= 0 && e < (l ? a.height : a.width)) {
        const c = a.positionAt(
          l ? e : a.height - 1,
          l ? a.width - 1 : e,
          o.node
        ), u = r.doc.resolve(o.from + c), h = l ? Nt.rowSelection : Nt.colSelection, f = a.positionAt(
          l ? e : 0,
          l ? 0 : e,
          o.node
        ), d = r.doc.resolve(o.from + f);
        return xT(
          r.setSelection(
            h(u, d)
          )
        );
      }
    }
    return r;
  };
}
const Dte = pI("row"), Nte = pI("col");
function mI(n, e, { map: t, tableStart: r, table: i }, s) {
  const o = Array(s).fill(0).reduce((a, c, u) => a + i.child(u).nodeSize, r), l = Array(t.width).fill(0).map((a, c) => {
    const u = i.nodeAt(t.map[c]);
    return Id.type(n).createAndFill({ alignment: u?.attrs.alignment });
  });
  return e.insert(o, Ed.type(n).create(null, l)), e;
}
function gI(n, e) {
  const t = [], r = vt.get(n);
  for (let s = 0; s < r.height; s++) {
    const o = n.child(s), l = [];
    for (let a = 0; a < r.width; a++) {
      if (!e[s][a]) continue;
      const c = r.map[s * r.width + a], u = e[s][a], f = n.nodeAt(c).type.createChecked(
        Object.assign({}, u.attrs),
        u.content,
        u.marks
      );
      l.push(f);
    }
    t.push(o.type.createChecked(o.attrs, l, o.marks));
  }
  return n.type.createChecked(
    n.attrs,
    t,
    n.marks
  );
}
function yI(n) {
  const e = vt.get(n), t = [], r = e.height, i = e.width;
  for (let s = 0; s < r; s++) {
    const o = [];
    for (let l = 0; l < i; l++) {
      let a = s * i + l, c = e.map[a];
      if (s > 0) {
        const u = a - i, h = e.map[u];
        if (c === h) {
          o.push(null);
          continue;
        }
      }
      if (l > 0) {
        const u = a - 1, h = e.map[u];
        if (c === h) {
          o.push(null);
          continue;
        }
      }
      c ? o.push(n.nodeAt(c)) : o.push(null);
    }
    t.push(o);
  }
  return t;
}
function Ak(n, e, t = e) {
  let r = e, i = t;
  for (let h = e; h >= 0; h--) {
    const f = ac(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.rowspan + h - 1;
      p >= r && (r = h), p > i && (i = p);
    });
  }
  for (let h = e; h <= i; h++) {
    const f = ac(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.rowspan + h - 1;
      d.node.attrs.rowspan > 1 && p > i && (i = p);
    });
  }
  const s = [];
  for (let h = r; h <= i; h++) {
    const f = ac(h, n.selection);
    f && f.length > 0 && s.push(h);
  }
  r = s[0], i = s[s.length - 1];
  const o = ac(r, n.selection), l = lc(0, n.selection);
  if (!o || !l)
    return;
  const a = n.doc.resolve(
    o[o.length - 1].pos
  );
  let c;
  for (let h = i; h >= r; h--) {
    const f = ac(h, n.selection);
    if (f && f.length > 0) {
      for (let d = l.length - 1; d >= 0; d--)
        if (l[d].pos === f[0].pos) {
          c = f[0];
          break;
        }
      if (c)
        break;
    }
  }
  if (!c)
    return;
  const u = n.doc.resolve(c.pos);
  return { $anchor: a, $head: u, indexes: s };
}
function bI(n, e, t, r) {
  const i = e[0] > t[0] ? -1 : 1, s = n.splice(e[0], e.length), o = s.length % 2 === 0 ? 1 : 0;
  let l;
  return l = i === -1 ? t[0] : t[t.length - 1] - o, n.splice(l, 0, ...s), n;
}
function Rte(n) {
  const { tr: e, origin: t, target: r, pos: i } = n, s = e.doc.resolve(i), o = fu(s);
  if (!o) return !1;
  const l = Ak(e, t)?.indexes, a = Ak(e, r)?.indexes;
  if (!l || !a || l.includes(r)) return !1;
  const c = Pte(
    o.node,
    l,
    a
  );
  e.replaceWith(o.pos, o.pos + o.node.nodeSize, c);
  const u = vt.get(c), h = o.start, f = r, d = u.positionAt(f, u.width - 1, c), p = e.doc.resolve(h + d), m = u.positionAt(f, 0, c), g = e.doc.resolve(h + m);
  return e.setSelection(Nt.rowSelection(p, g)), !0;
}
function Pte(n, e, t, r) {
  let i = yI(n);
  return i = bI(i, e, t), gI(n, i);
}
function Ok(n, e, t = e) {
  let r = e, i = t;
  for (let h = e; h >= 0; h--) {
    const f = lc(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.colspan + h - 1;
      p >= r && (r = h), p > i && (i = p);
    });
  }
  for (let h = e; h <= i; h++) {
    const f = lc(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.colspan + h - 1;
      d.node.attrs.colspan > 1 && p > i && (i = p);
    });
  }
  const s = [];
  for (let h = r; h <= i; h++) {
    const f = lc(h, n.selection);
    f && f.length > 0 && s.push(h);
  }
  r = s[0], i = s[s.length - 1];
  const o = lc(r, n.selection), l = ac(0, n.selection);
  if (!o || !l)
    return;
  const a = n.doc.resolve(
    o[o.length - 1].pos
  );
  let c;
  for (let h = i; h >= r; h--) {
    const f = lc(h, n.selection);
    if (f && f.length > 0) {
      for (let d = l.length - 1; d >= 0; d--)
        if (l[d].pos === f[0].pos) {
          c = f[0];
          break;
        }
      if (c)
        break;
    }
  }
  if (!c)
    return;
  const u = n.doc.resolve(c.pos);
  return { $anchor: a, $head: u, indexes: s };
}
function Ek(n) {
  return n[0].map((e, t) => n.map((r) => r[t]));
}
function _te(n) {
  const { tr: e, origin: t, target: r, pos: i } = n, s = e.doc.resolve(i), o = fu(s);
  if (!o) return !1;
  const l = Ok(e, t)?.indexes, a = Ok(e, r)?.indexes;
  if (!l || !a || l.includes(r)) return !1;
  const c = Lte(
    o.node,
    l,
    a
  );
  e.replaceWith(o.pos, o.pos + o.node.nodeSize, c);
  const u = vt.get(c), h = o.start, f = r, d = u.positionAt(u.height - 1, f, c), p = e.doc.resolve(h + d), m = u.positionAt(0, f, c), g = e.doc.resolve(h + m);
  return e.setSelection(Nt.colSelection(p, g)), !0;
}
function Lte(n, e, t, r) {
  let i = Ek(yI(n));
  return i = bI(i, e, t), i = Ek(i), gI(n, i);
}
function Bte(n) {
  const e = fu(n.$from);
  if (!e) return;
  const t = vt.get(e.node);
  return t.cellsInRect({
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  }).map((i) => {
    const s = e.node.nodeAt(i), o = i + e.start;
    return { pos: o, start: o + 1, node: s };
  });
}
function zte(n) {
  const e = Bte(n.selection);
  if (e && e[0]) {
    const t = n.doc.resolve(e[0].pos), r = e[e.length - 1];
    if (r) {
      const i = n.doc.resolve(r.pos);
      return xT(n.setSelection(new Nt(i, t)));
    }
  }
  return n;
}
const Nv = Ye(
  "GoToPrevTableCell",
  () => () => XE(-1)
);
Je(Nv, {
  displayName: "Command<goToPrevTableCellCommand>",
  group: "Table"
});
const Rv = Ye(
  "GoToNextTableCell",
  () => () => XE(1)
);
Je(Rv, {
  displayName: "Command<goToNextTableCellCommand>",
  group: "Table"
});
const Pv = Ye(
  "ExitTable",
  (n) => () => (e, t) => {
    if (!Ci(e)) return !1;
    const { $head: r } = e.selection, i = gV(r, $a.type(n));
    if (!i) return !1;
    const { to: s } = i, o = e.tr.replaceWith(
      s,
      s,
      Os.type(n).createAndFill()
    );
    return o.setSelection(Ge.near(o.doc.resolve(s), 1)).scrollIntoView(), t?.(o), !0;
  }
);
Je(Pv, {
  displayName: "Command<breakTableCommand>",
  group: "Table"
});
const vI = Ye(
  "InsertTable",
  (n) => ({ row: e, col: t } = {}) => (r, i) => {
    const { selection: s, tr: o } = r, { from: l } = s, a = Dv(n, e, t), c = o.replaceSelectionWith(a), u = Ge.findFrom(c.doc.resolve(l), 1, !0);
    return u && c.setSelection(u), i?.(c), !0;
  }
);
Je(vI, {
  displayName: "Command<insertTableCommand>",
  group: "Table"
});
const _v = Ye(
  "MoveRow",
  () => ({ from: n, to: e, pos: t } = {}) => (r, i) => {
    const { tr: s } = r;
    return Rte({
      tr: s,
      origin: n ?? 0,
      target: e ?? 0,
      pos: t ?? r.selection.from
    }) ? (i?.(s), !0) : !1;
  }
);
Je(_v, {
  displayName: "Command<moveRowCommand>",
  group: "Table"
});
const Lv = Ye(
  "MoveCol",
  () => ({ from: n, to: e, pos: t } = {}) => (r, i) => {
    const { tr: s } = r;
    return _te({
      tr: s,
      origin: n ?? 0,
      target: e ?? 0,
      pos: t ?? r.selection.from
    }) ? (i?.(s), !0) : !1;
  }
);
Je(Lv, {
  displayName: "Command<moveColCommand>",
  group: "Table"
});
const ra = Ye(
  "SelectRow",
  () => (n = { index: 0 }) => (e, t) => {
    const { tr: r } = e;
    return !!t?.(Dte(n.index, n.pos)(r));
  }
);
Je(ra, {
  displayName: "Command<selectRowCommand>",
  group: "Table"
});
const ia = Ye(
  "SelectCol",
  () => (n = { index: 0 }) => (e, t) => {
    const { tr: r } = e;
    return !!t?.(Nte(n.index, n.pos)(r));
  }
);
Je(ia, {
  displayName: "Command<selectColCommand>",
  group: "Table"
});
const wI = Ye(
  "SelectTable",
  () => () => (n, e) => {
    const { tr: t } = n;
    return !!e?.(zte(t));
  }
);
Je(wI, {
  displayName: "Command<selectTableCommand>",
  group: "Table"
});
const Bv = Ye(
  "DeleteSelectedCells",
  () => () => (n, e) => {
    const { selection: t } = n;
    if (!(t instanceof Nt)) return !1;
    const r = t.isRowSelection(), i = t.isColSelection();
    return r && i ? CQ(n, e) : i ? bQ(n, e) : wQ(n, e);
  }
);
Je(Bv, {
  displayName: "Command<deleteSelectedCellsCommand>",
  group: "Table"
});
const zv = Ye(
  "AddColBefore",
  () => () => mQ
);
Je(zv, {
  displayName: "Command<addColBeforeCommand>",
  group: "Table"
});
const Fv = Ye(
  "AddColAfter",
  () => () => gQ
);
Je(Fv, {
  displayName: "Command<addColAfterCommand>",
  group: "Table"
});
const Hv = Ye(
  "AddRowBefore",
  (n) => () => (e, t) => {
    if (!Ci(e)) return !1;
    if (t) {
      const r = El(e);
      t(mI(n, e.tr, r, r.top));
    }
    return !0;
  }
);
Je(Hv, {
  displayName: "Command<addRowBeforeCommand>",
  group: "Table"
});
const $v = Ye(
  "AddRowAfter",
  (n) => () => (e, t) => {
    if (!Ci(e)) return !1;
    if (t) {
      const r = El(e);
      t(mI(n, e.tr, r, r.bottom));
    }
    return !0;
  }
);
Je($v, {
  displayName: "Command<addRowAfterCommand>",
  group: "Table"
});
const Vv = Ye(
  "SetAlign",
  () => (n = "left") => xQ("alignment", n)
);
Je(Vv, {
  displayName: "Command<setAlignCommand>",
  group: "Table"
});
const xI = Qn(
  (n) => new Ir(
    /^\|(?<col>\d+)[xX](?<row>\d+)\|\s$/,
    (e, t, r, i) => {
      const s = e.doc.resolve(r);
      if (!s.node(-1).canReplaceWith(
        s.index(-1),
        s.indexAfter(-1),
        $a.type(n)
      ))
        return null;
      const o = Math.max(Number(t.groups?.row ?? 0), 2), l = Dv(n, o, Number(t.groups?.col)), a = e.tr.replaceRangeWith(r, i, l);
      return a.setSelection(Ee.create(a.doc, r + 3)).scrollIntoView();
    }
  )
);
Je(xI, {
  displayName: "InputRule<insertTableInputRule>",
  group: "Table"
});
const qv = Rr("tableKeymap", {
  NextCell: {
    priority: 100,
    shortcuts: ["Mod-]", "Tab"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Rv.key);
    }
  },
  PrevCell: {
    shortcuts: ["Mod-[", "Shift-Tab"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Nv.key);
    }
  },
  ExitTable: {
    shortcuts: ["Mod-Enter", "Enter"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Pv.key);
    }
  }
});
Je(qv.ctx, {
  displayName: "KeymapCtx<table>",
  group: "Table"
});
Je(qv.shortcuts, {
  displayName: "Keymap<table>",
  group: "Table"
});
const G2 = "footnote_definition", Ik = "footnoteDefinition", Wv = hn(
  "footnote_definition",
  () => ({
    group: "block",
    content: "block+",
    defining: !0,
    attrs: {
      label: {
        default: "",
        validate: "string"
      }
    },
    parseDOM: [
      {
        tag: `dl[data-type="${G2}"]`,
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement)) throw qi(n);
          return {
            label: n.dataset.label
          };
        },
        contentElement: "dd"
      }
    ],
    toDOM: (n) => {
      const e = n.attrs.label;
      return [
        "dl",
        {
          // TODO: add a prosemirror plugin to sync label on change
          "data-label": e,
          "data-type": G2
        },
        ["dt", e],
        ["dd", 0]
      ];
    },
    parseMarkdown: {
      match: ({ type: n }) => n === Ik,
      runner: (n, e, t) => {
        n.openNode(t, {
          label: e.label
        }).next(e.children).closeNode();
      }
    },
    toMarkdown: {
      match: (n) => n.type.name === G2,
      runner: (n, e) => {
        n.openNode(Ik, void 0, {
          label: e.attrs.label,
          identifier: e.attrs.label
        }).next(e.content).closeNode();
      }
    }
  })
);
Je(Wv.ctx, {
  displayName: "NodeSchemaCtx<footnodeDef>",
  group: "footnote"
});
Je(Wv.node, {
  displayName: "NodeSchema<footnodeDef>",
  group: "footnote"
});
const Y2 = "footnote_reference", jv = hn(
  "footnote_reference",
  () => ({
    group: "inline",
    inline: !0,
    atom: !0,
    attrs: {
      label: {
        default: "",
        validate: "string"
      }
    },
    parseDOM: [
      {
        tag: `sup[data-type="${Y2}"]`,
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement)) throw qi(n);
          return {
            label: n.dataset.label
          };
        }
      }
    ],
    toDOM: (n) => {
      const e = n.attrs.label;
      return [
        "sup",
        {
          // TODO: add a prosemirror plugin to sync label on change
          "data-label": e,
          "data-type": Y2
        },
        e
      ];
    },
    parseMarkdown: {
      match: ({ type: n }) => n === "footnoteReference",
      runner: (n, e, t) => {
        n.addNode(t, {
          label: e.label
        });
      }
    },
    toMarkdown: {
      match: (n) => n.type.name === Y2,
      runner: (n, e) => {
        n.addNode("footnoteReference", void 0, void 0, {
          label: e.attrs.label,
          identifier: e.attrs.label
        });
      }
    }
  })
);
Je(jv.ctx, {
  displayName: "NodeSchemaCtx<footnodeRef>",
  group: "footnote"
});
Je(jv.node, {
  displayName: "NodeSchema<footnodeRef>",
  group: "footnote"
});
const Uv = ji.extendSchema(
  (n) => (e) => {
    const t = n(e);
    return {
      ...t,
      attrs: {
        ...t.attrs,
        checked: {
          default: null,
          validate: "boolean|null"
        }
      },
      parseDOM: [
        {
          tag: 'li[data-item-type="task"]',
          getAttrs: (r) => {
            if (!(r instanceof HTMLElement)) throw qi(r);
            return {
              label: r.dataset.label,
              listType: r.dataset.listType,
              spread: r.dataset.spread,
              checked: r.dataset.checked ? r.dataset.checked === "true" : null
            };
          }
        },
        ...t?.parseDOM || []
      ],
      toDOM: (r) => t.toDOM && r.attrs.checked == null ? t.toDOM(r) : [
        "li",
        {
          "data-item-type": "task",
          "data-label": r.attrs.label,
          "data-list-type": r.attrs.listType,
          "data-spread": r.attrs.spread,
          "data-checked": r.attrs.checked
        },
        0
      ],
      parseMarkdown: {
        match: ({ type: r }) => r === "listItem",
        runner: (r, i, s) => {
          if (i.checked == null) {
            t.parseMarkdown.runner(r, i, s);
            return;
          }
          const o = i.label != null ? `${i.label}.` : "•", l = i.checked != null ? !!i.checked : null, a = i.label != null ? "ordered" : "bullet", c = i.spread != null ? `${i.spread}` : "true";
          r.openNode(s, { label: o, listType: a, spread: c, checked: l }), r.next(i.children), r.closeNode();
        }
      },
      toMarkdown: {
        match: (r) => r.type.name === "list_item",
        runner: (r, i) => {
          if (i.attrs.checked == null) {
            t.toMarkdown.runner(r, i);
            return;
          }
          const s = i.attrs.label, o = i.attrs.listType, l = i.attrs.spread === "true", a = i.attrs.checked;
          r.openNode("listItem", void 0, {
            label: s,
            listType: o,
            spread: l,
            checked: a
          }), r.next(i.content), r.closeNode();
        }
      }
    };
  }
);
Je(Uv.node, {
  displayName: "NodeSchema<taskListItem>",
  group: "ListItem"
});
Je(Uv.ctx, {
  displayName: "NodeSchemaCtx<taskListItem>",
  group: "ListItem"
});
const kI = Qn(() => new Ir(
  /^\[(?<checked>\s|x)\]\s$/,
  (n, e, t, r) => {
    const i = n.doc.resolve(t);
    let s = 0, o = i.node(s);
    for (; o && o.type.name !== "list_item"; )
      s--, o = i.node(s);
    if (!o || o.attrs.checked != null) return null;
    const l = e.groups?.checked === "x", a = i.before(s), c = n.tr;
    return c.deleteRange(t, r).setNodeMarkup(a, void 0, {
      ...o.attrs,
      checked: l
    }), c;
  }
));
Je(kI, {
  displayName: "InputRule<wrapInTaskListInputRule>",
  group: "ListItem"
});
const Fte = [
  Iv,
  qv
].flat(), Hte = [
  xI,
  kI
], $te = [dI], SI = kn(() => QQ);
Je(SI, {
  displayName: "Prose<autoInsertSpanPlugin>",
  group: "Prose"
});
const Vte = kn(() => PQ({}));
Je(Vte, {
  displayName: "Prose<columnResizingPlugin>",
  group: "Prose"
});
const CI = kn(
  () => WQ({ allowTableNodeSelection: !0 })
);
Je(CI, {
  displayName: "Prose<tableEditingPlugin>",
  group: "Prose"
});
const Kv = As("remarkGFM", () => Ite);
Je(Kv.plugin, {
  displayName: "Remark<remarkGFMPlugin>",
  group: "Remark"
});
Je(Kv.options, {
  displayName: "RemarkConfig<remarkGFMPlugin>",
  group: "Remark"
});
const qte = new en("MILKDOWN_KEEP_TABLE_ALIGN_PLUGIN");
function Wte(n, e) {
  let t = 0;
  return e.forEach((r, i, s) => {
    r === n && (t = s);
  }), t;
}
const MI = kn(() => new Ut({
  key: qte,
  appendTransaction: (n, e, t) => {
    let r;
    const i = (s, o) => {
      if (r || (r = t.tr), s.type.name !== "table_cell") return;
      const l = t.doc.resolve(o), a = l.node(l.depth), u = l.node(l.depth - 1).firstChild;
      if (!u) return;
      const h = Wte(s, a), f = u.maybeChild(h);
      if (!f) return;
      const d = f.attrs.alignment, p = s.attrs.alignment;
      d !== p && r.setNodeMarkup(o, void 0, { ...s.attrs, alignment: d });
    };
    return e.doc !== t.doc && t.doc.descendants(i), r;
  }
}));
Je(MI, {
  displayName: "Prose<keepTableAlignPlugin>",
  group: "Prose"
});
const jte = [
  MI,
  SI,
  Kv,
  CI
].flat(), Ute = [
  Uv,
  $a,
  Q1,
  Ed,
  eg,
  Id,
  Wv,
  jv,
  Ev,
  hu
].flat(), Kte = [
  Rv,
  Nv,
  Pv,
  vI,
  _v,
  Lv,
  ra,
  ia,
  wI,
  Bv,
  Hv,
  $v,
  zv,
  Fv,
  Vv,
  Z1
], Gte = [
  Ute,
  Hte,
  $te,
  Fte,
  Kte,
  jte
].flat(), Yte = (n) => {
  let { state: e } = n, t = e.doc.lineAt(e.selection.main.from), r = Yv(n.state, t.from);
  return r.line ? Jte(n) : r.block ? Zte(n) : !1;
};
function Gv(n, e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let i = n(e, t);
    return i ? (r(t.update(i)), !0) : !1;
  };
}
const Jte = /* @__PURE__ */ Gv(
  tne,
  0
  /* CommentOption.Toggle */
), Xte = /* @__PURE__ */ Gv(
  TI,
  0
  /* CommentOption.Toggle */
), Zte = /* @__PURE__ */ Gv(
  (n, e) => TI(n, e, ene(e)),
  0
  /* CommentOption.Toggle */
);
function Yv(n, e) {
  let t = n.languageDataAt("commentTokens", e, 1);
  return t.length ? t[0] : {};
}
const Gu = 50;
function Qte(n, { open: e, close: t }, r, i) {
  let s = n.sliceDoc(r - Gu, r), o = n.sliceDoc(i, i + Gu), l = /\s*$/.exec(s)[0].length, a = /^\s*/.exec(o)[0].length, c = s.length - l;
  if (s.slice(c - e.length, c) == e && o.slice(a, a + t.length) == t)
    return {
      open: { pos: r - l, margin: l && 1 },
      close: { pos: i + a, margin: a && 1 }
    };
  let u, h;
  i - r <= 2 * Gu ? u = h = n.sliceDoc(r, i) : (u = n.sliceDoc(r, r + Gu), h = n.sliceDoc(i - Gu, i));
  let f = /^\s*/.exec(u)[0].length, d = /\s*$/.exec(h)[0].length, p = h.length - d - t.length;
  return u.slice(f, f + e.length) == e && h.slice(p, p + t.length) == t ? {
    open: {
      pos: r + f + e.length,
      margin: /\s/.test(u.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: i - d - t.length,
      margin: /\s/.test(h.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function ene(n) {
  let e = [];
  for (let t of n.selection.ranges) {
    let r = n.doc.lineAt(t.from), i = t.to <= r.to ? r : n.doc.lineAt(t.to);
    i.from > r.from && i.from == t.to && (i = t.to == r.to + 1 ? r : n.doc.lineAt(t.to - 1));
    let s = e.length - 1;
    s >= 0 && e[s].to > r.from ? e[s].to = i.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function TI(n, e, t = e.selection.ranges) {
  let r = t.map((s) => Yv(e, s.from).block);
  if (!r.every((s) => s))
    return null;
  let i = t.map((s, o) => Qte(e, r[o], s.from, s.to));
  if (n != 2 && !i.every((s) => s))
    return { changes: e.changes(t.map((s, o) => i[o] ? [] : [{ from: s.from, insert: r[o].open + " " }, { from: s.to, insert: " " + r[o].close }])) };
  if (n != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, l; o < i.length; o++)
      if (l = i[o]) {
        let a = r[o], { open: c, close: u } = l;
        s.push({ from: c.pos - a.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + a.close.length });
      }
    return { changes: s };
  }
  return null;
}
function tne(n, e, t = e.selection.ranges) {
  let r = [], i = -1;
  for (let { from: s, to: o } of t) {
    let l = r.length, a = 1e9, c = Yv(e, s).line;
    if (c) {
      for (let u = s; u <= o; ) {
        let h = e.doc.lineAt(u);
        if (h.from > i && (s == o || o > h.from)) {
          i = h.from;
          let f = /^\s*/.exec(h.text)[0].length, d = f == h.length, p = h.text.slice(f, f + c.length) == c ? f : -1;
          f < h.text.length && f < a && (a = f), r.push({ line: h, comment: p, token: c, indent: f, empty: d, single: !1 });
        }
        u = h.to + 1;
      }
      if (a < 1e9)
        for (let u = l; u < r.length; u++)
          r[u].indent < r[u].line.text.length && (r[u].indent = a);
      r.length == l + 1 && (r[l].single = !0);
    }
  }
  if (n != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: a, indent: c, empty: u, single: h } of r)
      (h || !u) && s.push({ from: l.from + c, insert: a + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (n != 1 && r.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: l, token: a } of r)
      if (l >= 0) {
        let c = o.from + l, u = c + a.length;
        o.text[u - o.from] == " " && u++, s.push({ from: c, to: u });
      }
    return { changes: s };
  }
  return null;
}
const M5 = /* @__PURE__ */ wo.define(), nne = /* @__PURE__ */ wo.define(), rne = /* @__PURE__ */ xe.define(), AI = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (r, i) => e(r, i) || t(r, i)
    });
  }
}), OI = /* @__PURE__ */ On.define({
  create() {
    return df.empty;
  },
  update(n, e) {
    let t = e.state.facet(AI), r = e.annotation(M5);
    if (r) {
      let a = Ar.fromTransaction(e, r.selection), c = r.side, u = c == 0 ? n.undone : n.done;
      return a ? u = Lm(u, u.length, t.minDepth, a) : u = DI(u, e.startState.selection), new df(c == 0 ? r.rest : u, c == 0 ? u : r.rest);
    }
    let i = e.annotation(nne);
    if ((i == "full" || i == "before") && (n = n.isolate()), e.annotation(ur.addToHistory) === !1)
      return e.changes.empty ? n : n.addMapping(e.changes.desc);
    let s = Ar.fromTransaction(e), o = e.annotation(ur.time), l = e.annotation(ur.userEvent);
    return s ? n = n.addChanges(s, o, l, t, e) : e.selection && (n = n.addSelection(e.startState.selection, o, l, t.newGroupDelay)), (i == "full" || i == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((e) => e.toJSON()), undone: n.undone.map((e) => e.toJSON()) };
  },
  fromJSON(n) {
    return new df(n.done.map(Ar.fromJSON), n.undone.map(Ar.fromJSON));
  }
});
function ine(n = {}) {
  return [
    OI,
    AI.of(n),
    Ce.domEventHandlers({
      beforeinput(e, t) {
        let r = e.inputType == "historyUndo" ? EI : e.inputType == "historyRedo" ? T5 : null;
        return r ? (e.preventDefault(), r(t)) : !1;
      }
    })
  ];
}
function tg(n, e) {
  return function({ state: t, dispatch: r }) {
    if (!e && t.readOnly)
      return !1;
    let i = t.field(OI, !1);
    if (!i)
      return !1;
    let s = i.pop(n, t, e);
    return s ? (r(s), !0) : !1;
  };
}
const EI = /* @__PURE__ */ tg(0, !1), T5 = /* @__PURE__ */ tg(1, !1), sne = /* @__PURE__ */ tg(0, !0), one = /* @__PURE__ */ tg(1, !0);
class Ar {
  constructor(e, t, r, i, s) {
    this.changes = e, this.effects = t, this.mapped = r, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new Ar(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new Ar(e.changes && wn.fromJSON(e.changes), [], e.mapped && ys.fromJSON(e.mapped), e.startSelection && G.fromJSON(e.startSelection), e.selectionsAfter.map(G.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let r = ui;
    for (let i of e.startState.facet(rne)) {
      let s = i(e);
      s.length && (r = r.concat(s));
    }
    return !r.length && e.changes.empty ? null : new Ar(e.changes.invert(e.startState.doc), r, void 0, t || e.startState.selection, ui);
  }
  static selection(e) {
    return new Ar(void 0, ui, void 0, void 0, e);
  }
}
function Lm(n, e, t, r) {
  let i = e + 1 > t + 20 ? e - t - 1 : 0, s = n.slice(i, e);
  return s.push(r), s;
}
function lne(n, e) {
  let t = [], r = !1;
  return n.iterChangedRanges((i, s) => t.push(i, s)), e.iterChangedRanges((i, s, o, l) => {
    for (let a = 0; a < t.length; ) {
      let c = t[a++], u = t[a++];
      l >= c && o <= u && (r = !0);
    }
  }), r;
}
function ane(n, e) {
  return n.ranges.length == e.ranges.length && n.ranges.filter((t, r) => t.empty != e.ranges[r].empty).length === 0;
}
function II(n, e) {
  return n.length ? e.length ? n.concat(e) : n : e;
}
const ui = [], cne = 200;
function DI(n, e) {
  if (n.length) {
    let t = n[n.length - 1], r = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - cne));
    return r.length && r[r.length - 1].eq(e) ? n : (r.push(e), Lm(n, n.length - 1, 1e9, t.setSelAfter(r)));
  } else
    return [Ar.selection([e])];
}
function une(n) {
  let e = n[n.length - 1], t = n.slice();
  return t[n.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function J2(n, e) {
  if (!n.length)
    return n;
  let t = n.length, r = ui;
  for (; t; ) {
    let i = hne(n[t - 1], e, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = n.slice(0, t);
      return s[t - 1] = i, s;
    } else
      e = i.mapped, t--, r = i.selectionsAfter;
  }
  return r.length ? [Ar.selection(r)] : ui;
}
function hne(n, e, t) {
  let r = II(n.selectionsAfter.length ? n.selectionsAfter.map((l) => l.map(e)) : ui, t);
  if (!n.changes)
    return Ar.selection(r);
  let i = n.changes.map(e), s = e.mapDesc(n.changes, !0), o = n.mapped ? n.mapped.composeDesc(s) : s;
  return new Ar(i, Xe.mapEffects(n.effects, e), o, n.startSelection.map(s), r);
}
const fne = /^(input\.type|delete)($|\.)/;
let df = class bh {
  constructor(e, t, r = 0, i = void 0) {
    this.done = e, this.undone = t, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new bh(this.done, this.undone) : this;
  }
  addChanges(e, t, r, i, s) {
    let o = this.done, l = o[o.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!r || fne.test(r)) && (!l.selectionsAfter.length && t - this.prevTime < i.newGroupDelay && i.joinToEvent(s, lne(l.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? o = Lm(o, o.length - 1, i.minDepth, new Ar(e.changes.compose(l.changes), II(Xe.mapEffects(e.effects, l.changes), l.effects), l.mapped, l.startSelection, ui)) : o = Lm(o, o.length, i.minDepth, e), new bh(o, ui, t, r);
  }
  addSelection(e, t, r, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : ui;
    return s.length > 0 && t - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && ane(s[s.length - 1], e) ? this : new bh(DI(this.done, e), this.undone, t, r);
  }
  addMapping(e) {
    return new bh(J2(this.done, e), J2(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], o = s.selectionsAfter[0] || t.selection;
    if (r && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: M5.of({ side: e, rest: une(i), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let l = i.length == 1 ? ui : i.slice(0, i.length - 1);
      return s.mapped && (l = J2(l, s.mapped)), t.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: M5.of({ side: e, rest: l, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
};
df.empty = /* @__PURE__ */ new df(ui, ui);
const dne = [
  { key: "Mod-z", run: EI, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: T5, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: T5, preventDefault: !0 },
  { key: "Mod-u", run: sne, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: one, preventDefault: !0 }
];
function du(n, e) {
  return G.create(n.ranges.map(e), n.mainIndex);
}
function Is(n, e) {
  return n.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Gi({ state: n, dispatch: e }, t) {
  let r = du(n.selection, t);
  return r.eq(n.selection, !0) ? !1 : (e(Is(n, r)), !0);
}
function ng(n, e) {
  return G.cursor(e ? n.to : n.from);
}
function NI(n, e) {
  return Gi(n, (t) => t.empty ? n.moveByChar(t, e) : ng(t, e));
}
function er(n) {
  return n.textDirectionAt(n.state.selection.main.head) == qt.LTR;
}
const RI = (n) => NI(n, !er(n)), PI = (n) => NI(n, er(n));
function _I(n, e) {
  return Gi(n, (t) => t.empty ? n.moveByGroup(t, e) : ng(t, e));
}
const pne = (n) => _I(n, !er(n)), mne = (n) => _I(n, er(n));
function gne(n, e, t) {
  if (e.type.prop(t))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(n.sliceDoc(e.from, e.to))) || e.firstChild;
}
function rg(n, e, t) {
  let r = Fn(n).resolveInner(e.head), i = t ? st.closedBy : st.openedBy;
  for (let a = e.head; ; ) {
    let c = t ? r.childAfter(a) : r.childBefore(a);
    if (!c)
      break;
    gne(n, c, i) ? r = c : a = t ? c.to : c.from;
  }
  let s = r.type.prop(i), o, l;
  return s && (o = t ? fs(n, r.from, 1) : fs(n, r.to, -1)) && o.matched ? l = t ? o.end.to : o.end.from : l = t ? r.to : r.from, G.cursor(l, t ? -1 : 1);
}
const yne = (n) => Gi(n, (e) => rg(n.state, e, !er(n))), bne = (n) => Gi(n, (e) => rg(n.state, e, er(n)));
function LI(n, e) {
  return Gi(n, (t) => {
    if (!t.empty)
      return ng(t, e);
    let r = n.moveVertically(t, e);
    return r.head != t.head ? r : n.moveToLineBoundary(t, e);
  });
}
const BI = (n) => LI(n, !1), zI = (n) => LI(n, !0);
function FI(n) {
  let e = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, t = 0, r = 0, i;
  if (e) {
    for (let s of n.state.facet(Ce.scrollMargins)) {
      let o = s(n);
      o?.top && (t = Math.max(o?.top, t)), o?.bottom && (r = Math.max(o?.bottom, r));
    }
    i = n.scrollDOM.clientHeight - t - r;
  } else
    i = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(n.defaultLineHeight, i - 5)
  };
}
function HI(n, e) {
  let t = FI(n), { state: r } = n, i = du(r.selection, (o) => o.empty ? n.moveVertically(o, e, t.height) : ng(o, e));
  if (i.eq(r.selection))
    return !1;
  let s;
  if (t.selfScroll) {
    let o = n.coordsAtPos(r.selection.main.head), l = n.scrollDOM.getBoundingClientRect(), a = l.top + t.marginTop, c = l.bottom - t.marginBottom;
    o && o.top > a && o.bottom < c && (s = Ce.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - a }));
  }
  return n.dispatch(Is(r, i), { effects: s }), !0;
}
const Dk = (n) => HI(n, !1), A5 = (n) => HI(n, !0);
function Il(n, e, t) {
  let r = n.lineBlockAt(e.head), i = n.moveToLineBoundary(e, t);
  if (i.head == e.head && i.head != (t ? r.to : r.from) && (i = n.moveToLineBoundary(e, t, !1)), !t && i.head == r.from && r.length) {
    let s = /^\s*/.exec(n.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    s && e.head != r.from + s && (i = G.cursor(r.from + s));
  }
  return i;
}
const vne = (n) => Gi(n, (e) => Il(n, e, !0)), wne = (n) => Gi(n, (e) => Il(n, e, !1)), xne = (n) => Gi(n, (e) => Il(n, e, !er(n))), kne = (n) => Gi(n, (e) => Il(n, e, er(n))), Sne = (n) => Gi(n, (e) => G.cursor(n.lineBlockAt(e.head).from, 1)), Cne = (n) => Gi(n, (e) => G.cursor(n.lineBlockAt(e.head).to, -1));
function Mne(n, e, t) {
  let r = !1, i = du(n.selection, (s) => {
    let o = fs(n, s.head, -1) || fs(n, s.head, 1) || s.head > 0 && fs(n, s.head - 1, 1) || s.head < n.doc.length && fs(n, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    r = !0;
    let l = o.start.from == s.head ? o.end.to : o.end.from;
    return G.cursor(l);
  });
  return r ? (e(Is(n, i)), !0) : !1;
}
const Tne = ({ state: n, dispatch: e }) => Mne(n, e);
function Mi(n, e) {
  let t = du(n.state.selection, (r) => {
    let i = e(r);
    return G.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return t.eq(n.state.selection) ? !1 : (n.dispatch(Is(n.state, t)), !0);
}
function $I(n, e) {
  return Mi(n, (t) => n.moveByChar(t, e));
}
const VI = (n) => $I(n, !er(n)), qI = (n) => $I(n, er(n));
function WI(n, e) {
  return Mi(n, (t) => n.moveByGroup(t, e));
}
const Ane = (n) => WI(n, !er(n)), One = (n) => WI(n, er(n)), Ene = (n) => Mi(n, (e) => rg(n.state, e, !er(n))), Ine = (n) => Mi(n, (e) => rg(n.state, e, er(n)));
function jI(n, e) {
  return Mi(n, (t) => n.moveVertically(t, e));
}
const UI = (n) => jI(n, !1), KI = (n) => jI(n, !0);
function GI(n, e) {
  return Mi(n, (t) => n.moveVertically(t, e, FI(n).height));
}
const Nk = (n) => GI(n, !1), Rk = (n) => GI(n, !0), Dne = (n) => Mi(n, (e) => Il(n, e, !0)), Nne = (n) => Mi(n, (e) => Il(n, e, !1)), Rne = (n) => Mi(n, (e) => Il(n, e, !er(n))), Pne = (n) => Mi(n, (e) => Il(n, e, er(n))), _ne = (n) => Mi(n, (e) => G.cursor(n.lineBlockAt(e.head).from)), Lne = (n) => Mi(n, (e) => G.cursor(n.lineBlockAt(e.head).to)), Pk = ({ state: n, dispatch: e }) => (e(Is(n, { anchor: 0 })), !0), _k = ({ state: n, dispatch: e }) => (e(Is(n, { anchor: n.doc.length })), !0), Lk = ({ state: n, dispatch: e }) => (e(Is(n, { anchor: n.selection.main.anchor, head: 0 })), !0), Bk = ({ state: n, dispatch: e }) => (e(Is(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0), Bne = ({ state: n, dispatch: e }) => (e(n.update({ selection: { anchor: 0, head: n.doc.length }, userEvent: "select" })), !0), zne = ({ state: n, dispatch: e }) => {
  let t = ig(n).map(({ from: r, to: i }) => G.range(r, Math.min(i + 1, n.doc.length)));
  return e(n.update({ selection: G.create(t), userEvent: "select" })), !0;
}, Fne = ({ state: n, dispatch: e }) => {
  let t = du(n.selection, (r) => {
    let i = Fn(n), s = i.resolveStack(r.from, 1);
    if (r.empty) {
      let o = i.resolveStack(r.from, -1);
      o.node.from >= s.node.from && o.node.to <= s.node.to && (s = o);
    }
    for (let o = s; o; o = o.next) {
      let { node: l } = o;
      if ((l.from < r.from && l.to >= r.to || l.to > r.to && l.from <= r.from) && o.next)
        return G.range(l.to, l.from);
    }
    return r;
  });
  return t.eq(n.selection) ? !1 : (e(Is(n, t)), !0);
}, Hne = ({ state: n, dispatch: e }) => {
  let t = n.selection, r = null;
  return t.ranges.length > 1 ? r = G.create([t.main]) : t.main.empty || (r = G.create([G.cursor(t.main.head)])), r ? (e(Is(n, r)), !0) : !1;
};
function Dd(n, e) {
  if (n.state.readOnly)
    return !1;
  let t = "delete.selection", { state: r } = n, i = r.changeByRange((s) => {
    let { from: o, to: l } = s;
    if (o == l) {
      let a = e(s);
      a < o ? (t = "delete.backward", a = C0(n, a, !1)) : a > o && (t = "delete.forward", a = C0(n, a, !0)), o = Math.min(o, a), l = Math.max(l, a);
    } else
      o = C0(n, o, !1), l = C0(n, l, !0);
    return o == l ? { range: s } : { changes: { from: o, to: l }, range: G.cursor(o, o < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (n.dispatch(r.update(i, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? Ce.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function C0(n, e, t) {
  if (n instanceof Ce)
    for (let r of n.state.facet(Ce.atomicRanges).map((i) => i(n)))
      r.between(e, e, (i, s) => {
        i < e && s > e && (e = t ? s : i);
      });
  return e;
}
const YI = (n, e, t) => Dd(n, (r) => {
  let i = r.from, { state: s } = n, o = s.doc.lineAt(i), l, a;
  if (t && !e && i > o.from && i < o.from + 200 && !/[^ \t]/.test(l = o.text.slice(0, i - o.from))) {
    if (l[l.length - 1] == "	")
      return i - 1;
    let c = tu(l, s.tabSize), u = c % Sa(s) || Sa(s);
    for (let h = 0; h < u && l[l.length - 1 - h] == " "; h++)
      i--;
    a = i;
  } else
    a = zn(o.text, i - o.from, e, e) + o.from, a == i && o.number != (e ? s.doc.lines : 1) ? a += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(a - o.from, i - o.from)) && (a = zn(o.text, a - o.from, !1, !1) + o.from);
  return a;
}), O5 = (n) => YI(n, !1, !0), JI = (n) => YI(n, !0, !1), XI = (n, e) => Dd(n, (t) => {
  let r = t.head, { state: i } = n, s = i.doc.lineAt(r), o = i.charCategorizer(r);
  for (let l = null; ; ) {
    if (r == (e ? s.to : s.from)) {
      r == t.head && s.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let a = zn(s.text, r - s.from, e) + s.from, c = s.text.slice(Math.min(r, a) - s.from, Math.max(r, a) - s.from), u = o(c);
    if (l != null && u != l)
      break;
    (c != " " || r != t.head) && (l = u), r = a;
  }
  return r;
}), ZI = (n) => XI(n, !1), $ne = (n) => XI(n, !0), Vne = (n) => Dd(n, (e) => {
  let t = n.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), qne = (n) => Dd(n, (e) => {
  let t = n.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), Wne = (n) => Dd(n, (e) => {
  let t = n.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), jne = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: ft.of(["", ""]) },
    range: G.cursor(r.from)
  }));
  return e(n.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, Une = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == n.doc.length)
      return { range: r };
    let i = r.from, s = n.doc.lineAt(i), o = i == s.from ? i - 1 : zn(s.text, i - s.from, !1) + s.from, l = i == s.to ? i + 1 : zn(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: o, to: l, insert: n.doc.slice(i, l).append(n.doc.slice(o, i)) },
      range: G.cursor(l)
    };
  });
  return t.changes.empty ? !1 : (e(n.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function ig(n) {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.from), s = n.doc.lineAt(r.to);
    if (!r.empty && r.to == s.from && (s = n.doc.lineAt(r.to - 1)), t >= i.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(r);
    } else
      e.push({ from: i.from, to: s.to, ranges: [r] });
    t = s.number + 1;
  }
  return e;
}
function QI(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [], i = [];
  for (let s of ig(n)) {
    if (t ? s.to == n.doc.length : s.from == 0)
      continue;
    let o = n.doc.lineAt(t ? s.to + 1 : s.from - 1), l = o.length + 1;
    if (t) {
      r.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + n.lineBreak });
      for (let a of s.ranges)
        i.push(G.range(Math.min(n.doc.length, a.anchor + l), Math.min(n.doc.length, a.head + l)));
    } else {
      r.push({ from: o.from, to: s.from }, { from: s.to, insert: n.lineBreak + o.text });
      for (let a of s.ranges)
        i.push(G.range(a.anchor - l, a.head - l));
    }
  }
  return r.length ? (e(n.update({
    changes: r,
    scrollIntoView: !0,
    selection: G.create(i, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const Kne = ({ state: n, dispatch: e }) => QI(n, e, !1), Gne = ({ state: n, dispatch: e }) => QI(n, e, !0);
function eD(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [];
  for (let i of ig(n))
    t ? r.push({ from: i.from, insert: n.doc.slice(i.from, i.to) + n.lineBreak }) : r.push({ from: i.to, insert: n.lineBreak + n.doc.slice(i.from, i.to) });
  return e(n.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Yne = ({ state: n, dispatch: e }) => eD(n, e, !1), Jne = ({ state: n, dispatch: e }) => eD(n, e, !0), Xne = (n) => {
  if (n.state.readOnly)
    return !1;
  let { state: e } = n, t = e.changes(ig(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))), r = du(e.selection, (i) => {
    let s;
    if (n.lineWrapping) {
      let o = n.lineBlockAt(i.head), l = n.coordsAtPos(i.head, i.assoc || 1);
      l && (s = o.bottom + n.documentTop - l.bottom + n.defaultLineHeight / 2);
    }
    return n.moveVertically(i, !0, s);
  }).map(t);
  return n.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function Zne(n, e) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = Fn(n).resolveInner(e), r = t.childBefore(e), i = t.childAfter(e), s;
  return r && i && r.to <= e && i.from >= e && (s = r.type.prop(st.closedBy)) && s.indexOf(i.name) > -1 && n.doc.lineAt(r.to).from == n.doc.lineAt(i.from).from && !/\S/.test(n.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
const zk = /* @__PURE__ */ tD(!1), Qne = /* @__PURE__ */ tD(!0);
function tD(n) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((i) => {
      let { from: s, to: o } = i, l = e.doc.lineAt(s), a = !n && s == o && Zne(e, s);
      n && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let c = new a1(e, { simulateBreak: s, simulateDoubleBreak: !!a }), u = k3(c, s);
      for (u == null && (u = tu(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      a ? { from: s, to: o } = a : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let h = ["", If(e, u)];
      return a && h.push(If(e, c.lineIndent(l.from, -1))), {
        changes: { from: s, to: o, insert: ft.of(h) },
        range: G.cursor(s + 1 + h[1].length)
      };
    });
    return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Jv(n, e) {
  let t = -1;
  return n.changeByRange((r) => {
    let i = [];
    for (let o = r.from; o <= r.to; ) {
      let l = n.doc.lineAt(o);
      l.number > t && (r.empty || r.to > l.from) && (e(l, i, r), t = l.number), o = l.to + 1;
    }
    let s = n.changes(i);
    return {
      changes: i,
      range: G.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
    };
  });
}
const ere = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), r = new a1(n, { overrideIndentation: (s) => {
    let o = t[s];
    return o ?? -1;
  } }), i = Jv(n, (s, o, l) => {
    let a = k3(r, s.from);
    if (a == null)
      return;
    /\S/.test(s.text) || (a = 0);
    let c = /^\s*/.exec(s.text)[0], u = If(n, a);
    (c != u || l.from < s.from + c.length) && (t[s.from] = a, o.push({ from: s.from, to: s.from + c.length, insert: u }));
  });
  return i.changes.empty || e(n.update(i, { userEvent: "indent" })), !0;
}, nD = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(Jv(n, (t, r) => {
  r.push({ from: t.from, insert: n.facet(l1) });
}), { userEvent: "input.indent" })), !0), rD = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(Jv(n, (t, r) => {
  let i = /^\s*/.exec(t.text)[0];
  if (!i)
    return;
  let s = tu(i, n.tabSize), o = 0, l = If(n, Math.max(0, s - Sa(n)));
  for (; o < i.length && o < l.length && i.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  r.push({ from: t.from + o, to: t.from + i.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), tre = (n) => (n.setTabFocusMode(), !0), nre = [
  { key: "Ctrl-b", run: RI, shift: VI, preventDefault: !0 },
  { key: "Ctrl-f", run: PI, shift: qI },
  { key: "Ctrl-p", run: BI, shift: UI },
  { key: "Ctrl-n", run: zI, shift: KI },
  { key: "Ctrl-a", run: Sne, shift: _ne },
  { key: "Ctrl-e", run: Cne, shift: Lne },
  { key: "Ctrl-d", run: JI },
  { key: "Ctrl-h", run: O5 },
  { key: "Ctrl-k", run: Vne },
  { key: "Ctrl-Alt-h", run: ZI },
  { key: "Ctrl-o", run: jne },
  { key: "Ctrl-t", run: Une },
  { key: "Ctrl-v", run: A5 }
], rre = /* @__PURE__ */ [
  { key: "ArrowLeft", run: RI, shift: VI, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: pne, shift: Ane, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: xne, shift: Rne, preventDefault: !0 },
  { key: "ArrowRight", run: PI, shift: qI, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: mne, shift: One, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: kne, shift: Pne, preventDefault: !0 },
  { key: "ArrowUp", run: BI, shift: UI, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Pk, shift: Lk },
  { mac: "Ctrl-ArrowUp", run: Dk, shift: Nk },
  { key: "ArrowDown", run: zI, shift: KI, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: _k, shift: Bk },
  { mac: "Ctrl-ArrowDown", run: A5, shift: Rk },
  { key: "PageUp", run: Dk, shift: Nk },
  { key: "PageDown", run: A5, shift: Rk },
  { key: "Home", run: wne, shift: Nne, preventDefault: !0 },
  { key: "Mod-Home", run: Pk, shift: Lk },
  { key: "End", run: vne, shift: Dne, preventDefault: !0 },
  { key: "Mod-End", run: _k, shift: Bk },
  { key: "Enter", run: zk, shift: zk },
  { key: "Mod-a", run: Bne },
  { key: "Backspace", run: O5, shift: O5 },
  { key: "Delete", run: JI },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: ZI },
  { key: "Mod-Delete", mac: "Alt-Delete", run: $ne },
  { mac: "Mod-Backspace", run: qne },
  { mac: "Mod-Delete", run: Wne }
].concat(/* @__PURE__ */ nre.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))), iD = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: yne, shift: Ene },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: bne, shift: Ine },
  { key: "Alt-ArrowUp", run: Kne },
  { key: "Shift-Alt-ArrowUp", run: Yne },
  { key: "Alt-ArrowDown", run: Gne },
  { key: "Shift-Alt-ArrowDown", run: Jne },
  { key: "Escape", run: Hne },
  { key: "Mod-Enter", run: Qne },
  { key: "Alt-l", mac: "Ctrl-l", run: zne },
  { key: "Mod-i", run: Fne, preventDefault: !0 },
  { key: "Mod-[", run: rD },
  { key: "Mod-]", run: nD },
  { key: "Mod-Alt-\\", run: ere },
  { key: "Shift-Mod-k", run: Xne },
  { key: "Shift-Mod-\\", run: Tne },
  { key: "Mod-/", run: Yte },
  { key: "Alt-A", run: Xte },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: tre }
].concat(rre), ire = { key: "Tab", run: nD, shift: rD };
var Bm = 200, Tn = function() {
};
Tn.prototype.append = function(e) {
  return e.length ? (e = Tn.from(e), !this.length && e || e.length < Bm && this.leafAppend(e) || this.length < Bm && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Tn.prototype.prepend = function(e) {
  return e.length ? Tn.from(e).append(this) : this;
};
Tn.prototype.appendInner = function(e) {
  return new sre(this, e);
};
Tn.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? Tn.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
Tn.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Tn.prototype.forEach = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
};
Tn.prototype.map = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(s, o) {
    return i.push(e(s, o));
  }, t, r), i;
};
Tn.from = function(e) {
  return e instanceof Tn ? e : e && e.length ? new sD(e) : Tn.empty;
};
var sD = /* @__PURE__ */ (function(n) {
  function e(r) {
    n.call(this), this.values = r;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, s) {
    return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, s, o, l) {
    for (var a = s; a < o; a++)
      if (i(this.values[a], l + a) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, s, o, l) {
    for (var a = s - 1; a >= o; a--)
      if (i(this.values[a], l + a) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Bm)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Bm)
      return new e(i.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
})(Tn);
Tn.empty = new sD([]);
var sre = /* @__PURE__ */ (function(n) {
  function e(t, r) {
    n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, s, o) {
    var l = this.left.length;
    if (i < l && this.left.forEachInner(r, i, Math.min(s, l), o) === !1 || s > l && this.right.forEachInner(r, Math.max(i - l, 0), Math.min(this.length, s) - l, o + l) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, o) {
    var l = this.left.length;
    if (i > l && this.right.forEachInvertedInner(r, i - l, Math.max(s, l) - l, o + l) === !1 || s < l && this.left.forEachInvertedInner(r, Math.min(i, l), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var s = this.left.length;
    return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
})(Tn);
const ore = 500;
class Di {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, s;
    t && (i = this.remapping(r, this.items.length), s = i.maps.length);
    let o = e.tr, l, a, c = [], u = [];
    return this.items.forEach((h, f) => {
      if (!h.step) {
        i || (i = this.remapping(r, f + 1), s = i.maps.length), s--, u.push(h);
        return;
      }
      if (i) {
        u.push(new is(h.map));
        let d = h.step.map(i.slice(s)), p;
        d && o.maybeStep(d).doc && (p = o.mapping.maps[o.mapping.maps.length - 1], c.push(new is(p, void 0, void 0, c.length + u.length))), s--, p && i.appendMap(p, s);
      } else
        o.maybeStep(h.step);
      if (h.selection)
        return l = i ? h.selection.map(i.slice(s)) : h.selection, a = new Di(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: a, transform: o, selection: l };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, r, i) {
    let s = [], o = this.eventCount, l = this.items, a = !i && l.length ? l.get(l.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let h = e.steps[u].invert(e.docs[u]), f = new is(e.mapping.maps[u], h, t), d;
      (d = a && a.merge(f)) && (f = d, u ? s.pop() : l = l.slice(0, l.length - 1)), s.push(f), t && (o++, t = void 0), i || (a = f);
    }
    let c = o - r.depth;
    return c > are && (l = lre(l, c), o -= c), new Di(l.append(s), o);
  }
  remapping(e, t) {
    let r = new Pf();
    return this.items.forEach((i, s) => {
      let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, o);
    }, e, t), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new Di(this.items.append(e.map((t) => new is(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - t), s = e.mapping, o = e.steps.length, l = this.eventCount;
    this.items.forEach((f) => {
      f.selection && l--;
    }, i);
    let a = t;
    this.items.forEach((f) => {
      let d = s.getMirror(--a);
      if (d == null)
        return;
      o = Math.min(o, d);
      let p = s.maps[d];
      if (f.step) {
        let m = e.steps[d].invert(e.docs[d]), g = f.selection && f.selection.map(s.slice(a + 1, d));
        g && l++, r.push(new is(p, m, g));
      } else
        r.push(new is(p));
    }, i);
    let c = [];
    for (let f = t; f < o; f++)
      c.push(new is(s.maps[f]));
    let u = this.items.slice(0, i).append(c).append(r), h = new Di(u, l);
    return h.emptyItemCount() > ore && (h = h.compress(this.items.length - r.length)), h;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), r = t.maps.length, i = [], s = 0;
    return this.items.forEach((o, l) => {
      if (l >= e)
        i.push(o), o.selection && s++;
      else if (o.step) {
        let a = o.step.map(t.slice(r)), c = a && a.getMap();
        if (r--, c && t.appendMap(c, r), a) {
          let u = o.selection && o.selection.map(t.slice(r));
          u && s++;
          let h = new is(c.invert(), a, u), f, d = i.length - 1;
          (f = i.length && i[d].merge(h)) ? i[d] = f : i.push(h);
        }
      } else o.map && r--;
    }, this.items.length, 0), new Di(Tn.from(i.reverse()), s);
  }
}
Di.empty = new Di(Tn.empty, 0);
function lre(n, e) {
  let t;
  return n.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return t = i, !1;
  }), n.slice(t);
}
class is {
  constructor(e, t, r, i) {
    this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new is(t.getMap().invert(), t, this.selection);
    }
  }
}
class Wo {
  constructor(e, t, r, i, s) {
    this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i, this.prevComposition = s;
  }
}
const are = 20;
function cre(n, e, t, r) {
  let i = t.getMeta(ga), s;
  if (i)
    return i.historyState;
  t.getMeta(fre) && (n = new Wo(n.done, n.undone, null, 0, -1));
  let o = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (o && o.getMeta(ga))
    return o.getMeta(ga).redo ? new Wo(n.done.addTransform(t, void 0, r, Op(e)), n.undone, Fk(t.mapping.maps), n.prevTime, n.prevComposition) : new Wo(n.done, n.undone.addTransform(t, void 0, r, Op(e)), null, n.prevTime, n.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let l = t.getMeta("composition"), a = n.prevTime == 0 || !o && n.prevComposition != l && (n.prevTime < (t.time || 0) - r.newGroupDelay || !ure(t, n.prevRanges)), c = o ? X2(n.prevRanges, t.mapping) : Fk(t.mapping.maps);
    return new Wo(n.done.addTransform(t, a ? e.selection.getBookmark() : void 0, r, Op(e)), Di.empty, c, t.time, l ?? n.prevComposition);
  } else return (s = t.getMeta("rebased")) ? new Wo(n.done.rebased(t, s), n.undone.rebased(t, s), X2(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new Wo(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), X2(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
}
function ure(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((r, i) => {
    for (let s = 0; s < e.length; s += 2)
      r <= e[s + 1] && i >= e[s] && (t = !0);
  }), t;
}
function Fk(n) {
  let e = [];
  for (let t = n.length - 1; t >= 0 && e.length == 0; t--)
    n[t].forEach((r, i, s, o) => e.push(s, o));
  return e;
}
function X2(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let r = 0; r < n.length; r += 2) {
    let i = e.map(n[r], 1), s = e.map(n[r + 1], -1);
    i <= s && t.push(i, s);
  }
  return t;
}
function hre(n, e, t) {
  let r = Op(e), i = ga.get(e).spec.config, s = (t ? n.undone : n.done).popEvent(e, r);
  if (!s)
    return null;
  let o = s.selection.resolve(s.transform.doc), l = (t ? n.done : n.undone).addTransform(s.transform, e.selection.getBookmark(), i, r), a = new Wo(t ? l : s.remaining, t ? s.remaining : l, null, 0, -1);
  return s.transform.setSelection(o).setMeta(ga, { redo: t, historyState: a });
}
let Z2 = !1, Hk = null;
function Op(n) {
  let e = n.plugins;
  if (Hk != e) {
    Z2 = !1, Hk = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        Z2 = !0;
        break;
      }
  }
  return Z2;
}
const ga = new en("history"), fre = new en("closeHistory");
function dre(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new Ut({
    key: ga,
    state: {
      init() {
        return new Wo(Di.empty, Di.empty, null, 0, -1);
      },
      apply(e, t, r) {
        return cre(t, r, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let r = t.inputType, i = r == "historyUndo" ? sg : r == "historyRedo" ? Uc : null;
          return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function oD(n, e) {
  return (t, r) => {
    let i = ga.getState(t);
    if (!i || (n ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let s = hre(i, t, n);
      s && r(e ? s.scrollIntoView() : s);
    }
    return !0;
  };
}
const sg = oD(!1, !0), Uc = oD(!0, !0);
var pre = Object.defineProperty, $k = Object.getOwnPropertySymbols, mre = Object.prototype.hasOwnProperty, gre = Object.prototype.propertyIsEnumerable, Vk = (n, e, t) => e in n ? pre(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, yre = (n, e) => {
  for (var t in e || (e = {}))
    mre.call(e, t) && Vk(n, t, e[t]);
  if ($k)
    for (var t of $k(e))
      gre.call(e, t) && Vk(n, t, e[t]);
  return n;
};
function lD(n, e) {
  return Object.assign(n, {
    meta: yre({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const bre = {
  extensions: [],
  languages: [],
  expandIcon: "⬇",
  searchIcon: "🔍",
  clearSearchIcon: "⌫",
  searchPlaceholder: "Search language",
  noResultText: "No result",
  copyText: "Copy",
  copyIcon: "📋",
  onCopy: () => {
  },
  renderLanguage: (n) => n,
  renderPreview: () => null,
  previewToggleButton: (n) => n ? "Edit" : "Hide",
  previewLabel: "Preview"
}, Nd = Ct(bre, "codeBlockConfigCtx");
lD(Nd, {
  displayName: "Config<code-block>",
  group: "CodeBlock"
});
class vre {
  constructor(e) {
    this.languages = e, this.map = {}, e.forEach((t) => {
      t.alias.forEach((r) => {
        this.map[r] = t;
      });
    });
  }
  getAll() {
    return this.languages.map((e) => ({
      name: e.name,
      alias: e.alias
    }));
  }
  load(e) {
    const r = this.map[e.toLowerCase()];
    return r ? r.support ? Promise.resolve(r.support) : r.load() : Promise.resolve(void 0);
  }
}
function Oc({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ki.sanitize(n.trim()));
      }
    }
  );
}
Oc.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
var wre = (n, e, t) => new Promise((r, i) => {
  var s = (a) => {
    try {
      l(t.next(a));
    } catch (c) {
      i(c);
    }
  }, o = (a) => {
    try {
      l(t.throw(a));
    } catch (c) {
      i(c);
    }
  }, l = (a) => a.done ? r(a.value) : Promise.resolve(a.value).then(s, o);
  l((t = t.apply(n, e)).next());
});
function xre(n) {
  return wre(this, null, function* () {
    try {
      return navigator.clipboard.writeText(n);
    } catch {
      const t = document.createElement("textarea"), r = document.activeElement;
      t.value = n, t.setAttribute("readonly", ""), t.style.contain = "strict", t.style.position = "absolute", t.style.left = "-9999px", t.style.fontSize = "12pt";
      const i = document.getSelection(), s = i ? i.rangeCount > 0 && i.getRangeAt(0) : null;
      document.body.appendChild(t), t.select(), t.selectionStart = 0, t.selectionEnd = n.length, document.execCommand("copy"), document.body.removeChild(t), s && (i.removeAllRanges(), i.addRange(s)), r && r.focus();
    }
  });
}
const kre = /* @__PURE__ */ $n({
  props: {
    copyText: {
      type: String,
      required: !0
    },
    copyIcon: {
      type: String,
      required: !0
    },
    onCopy: {
      type: Function,
      required: !0
    },
    text: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = () => {
      xre(n.text).then(() => n.onCopy(n.text)).catch(console.error);
    };
    return () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("button", { type: "button", class: "copy-button", onClick: e }, /* @__PURE__ */ j(Oc, { icon: n.copyIcon }), n.copyText));
  }
}), Sre = /* @__PURE__ */ $n({
  props: {
    language: {
      type: Object,
      required: !0
    },
    getReadOnly: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    getAllLanguages: {
      type: Function,
      required: !0
    },
    setLanguage: {
      type: Function,
      required: !0
    }
  },
  setup({ language: n, config: e, setLanguage: t, getAllLanguages: r, getReadOnly: i }) {
    const s = Ae(), o = Ae(!1), l = Ae(), a = Ae(), c = Ae("");
    Ac([o, s, a], () => {
      c.value = "";
      const m = s.value, g = a.value;
      !m || !g || Vi(m, g, {
        placement: "bottom-start"
      }).then(({ x: b, y: w }) => {
        Object.assign(g.style, {
          left: `${b}px`,
          top: `${w}px`
        });
      }).catch(console.error);
    });
    const u = (m) => {
      if (m.preventDefault(), m.stopPropagation(), i()) return;
      const g = !o.value;
      o.value = g, g && setTimeout(() => {
        var b;
        return (b = l.value) == null ? void 0 : b.focus();
      }, 0);
    }, h = (m) => {
      const g = m.target;
      c.value = g.value;
    }, f = (m) => {
      m.key === "Escape" && (c.value = "");
    }, d = Ra(() => {
      var m;
      if (!o.value) return [];
      const g = (m = r()) != null ? m : [], b = g.find(
        (k) => k.name.toLowerCase() === n.value.toLowerCase()
      ), w = g.filter((k) => {
        const C = c.value.toLowerCase();
        return (k.name.toLowerCase().includes(C) || k.alias.some(
          (M) => M.toLowerCase().includes(C)
        )) && k !== b;
      });
      return w.length === 0 ? [] : b ? [b, ...w] : w;
    }), p = (m) => {
      const g = m.target;
      if (s.value && s.value.contains(g)) return;
      const b = a.value, w = s.value;
      !w || !b || w.dataset.expanded === "true" && (b.contains(g) || (o.value = !1));
    };
    return kd(() => {
      window.addEventListener("click", p);
    }), Sd(() => {
      window.removeEventListener("click", p);
    }), () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j(
      "button",
      {
        type: "button",
        ref: s,
        class: "language-button",
        onClick: u,
        "data-expanded": String(o.value)
      },
      n.value || "Text",
      /* @__PURE__ */ j("div", { class: "expand-icon" }, /* @__PURE__ */ j(Oc, { icon: e.expandIcon }))
    ), /* @__PURE__ */ j("div", { ref: a, class: "language-picker" }, o.value ? /* @__PURE__ */ j("div", { class: "list-wrapper" }, /* @__PURE__ */ j("div", { class: "search-box" }, /* @__PURE__ */ j("div", { class: "search-icon" }, /* @__PURE__ */ j(Oc, { icon: e.searchIcon })), /* @__PURE__ */ j(
      "input",
      {
        ref: l,
        class: "search-input",
        placeholder: e.searchPlaceholder,
        value: c.value,
        onInput: h,
        onKeydown: f
      }
    ), /* @__PURE__ */ j(
      "div",
      {
        class: Hn(
          "clear-icon",
          c.value.length === 0 && "hidden"
        ),
        onMousedown: (m) => {
          m.preventDefault(), c.value = "";
        }
      },
      /* @__PURE__ */ j(Oc, { icon: e.clearSearchIcon })
    )), /* @__PURE__ */ j(
      "ul",
      {
        class: "language-list",
        role: "listbox",
        onKeydown: (m) => {
          if (m.key === "Enter") {
            const g = document.activeElement;
            g instanceof HTMLElement && g.dataset.language && t(g.dataset.language);
          }
        }
      },
      d.value.length ? d.value.map((m) => /* @__PURE__ */ j(
        "li",
        {
          role: "listitem",
          tabindex: "0",
          class: "language-list-item",
          "aria-selected": m.name.toLowerCase() === n.value.toLowerCase(),
          "data-language": m.name,
          onClick: () => {
            t(m.name), o.value = !1;
          }
        },
        e.renderLanguage(
          m.name,
          m.name.toLowerCase() === n.value.toLowerCase()
        )
      )) : /* @__PURE__ */ j("li", { class: "language-list-item no-result" }, e.noResultText)
    )) : null));
  }
}), Cre = /* @__PURE__ */ $n({
  props: {
    text: {
      type: Object,
      required: !0
    },
    language: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    previewOnlyMode: {
      type: Object,
      required: !0
    },
    preview: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { previewOnlyMode: e, config: t, preview: r } = n, i = Ae();
    return uu(() => {
      const s = i.value;
      if (!s) return;
      for (; s.firstChild; )
        s.removeChild(s.firstChild);
      const o = r.value;
      (typeof o == "string" || o instanceof Element) && (s.innerHTML = Ki.sanitize(o));
    }), () => r.value ? /* @__PURE__ */ j("div", { class: "preview-panel" }, !e.value && /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("div", { class: "preview-divider" }), /* @__PURE__ */ j("div", { class: Hn("preview-label", e && "hidden") }, t.previewLabel)), /* @__PURE__ */ j("div", { ref: i, class: "preview" })) : null;
  }
}), Mre = /* @__PURE__ */ $n({
  props: {
    text: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    getReadOnly: {
      type: Function,
      required: !0
    },
    codemirror: {
      type: Object,
      required: !0
    },
    language: {
      type: Object,
      required: !0
    },
    getAllLanguages: {
      type: Function,
      required: !0
    },
    setLanguage: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = Ae(!1), t = Ae();
    kd(() => {
      for (var s; (s = t.value) != null && s.firstChild; )
        t.value.removeChild(t.value.firstChild);
      t.value && t.value.appendChild(n.codemirror.dom);
    });
    const r = Ra(() => {
      const s = n.text.value, o = n.language.value;
      return n.config.renderPreview(o, s);
    }), i = () => {
    };
    return () => {
      var s;
      return /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("div", { class: "tools" }, /* @__PURE__ */ j(
        Sre,
        {
          language: n.language,
          config: n.config,
          setLanguage: n.setLanguage,
          getAllLanguages: n.getAllLanguages,
          getReadOnly: n.getReadOnly
        }
      ), /* @__PURE__ */ j("div", { class: "tools-button-group" }, /* @__PURE__ */ j(
        kre,
        {
          copyIcon: n.config.copyIcon,
          copyText: n.config.copyText,
          onCopy: (s = n.config.onCopy) != null ? s : i,
          text: n.text.value
        }
      ), r.value ? /* @__PURE__ */ j(
        "button",
        {
          class: "preview-toggle-button",
          onClick: () => e.value = !e.value
        },
        /* @__PURE__ */ j(
          Oc,
          {
            icon: n.config.previewToggleButton(
              e.value
            )
          }
        )
      ) : null)), /* @__PURE__ */ j(
        "div",
        {
          ref: t,
          class: Hn(
            "codemirror-host",
            r.value && e.value && "hidden"
          )
        }
      ), /* @__PURE__ */ j(
        Cre,
        {
          text: n.text,
          language: n.language,
          config: n.config,
          previewOnlyMode: e,
          preview: r
        }
      ));
    };
  }
});
class Tre {
  constructor(e, t, r, i, s) {
    this.node = e, this.view = t, this.getPos = r, this.loader = i, this.config = s, this.selected = Ae(!1), this.language = Ae(""), this.text = Ae(""), this.updating = !1, this.languageName = "", this.forwardUpdate = (o) => {
      var l;
      if (this.updating || !this.cm.hasFocus) return;
      let a = ((l = this.getPos()) != null ? l : 0) + 1;
      const { main: c } = o.state.selection, u = a + c.from, h = a + c.to, f = this.view.state.selection;
      if (o.docChanged || f.from !== u || f.to !== h) {
        const d = this.view.state.tr;
        o.changes.iterChanges((p, m, g, b, w) => {
          w.length ? d.replaceWith(
            a + p,
            a + m,
            this.view.state.schema.text(w.toString())
          ) : d.delete(a + p, a + m), a += b - g - (m - p);
        }), d.setSelection(Ee.create(d.doc, u, h)), this.view.dispatch(d);
      }
    }, this.createApp = () => Ui(Mre, {
      text: this.text,
      selected: this.selected,
      codemirror: this.cm,
      language: this.language,
      getAllLanguages: this.getAllLanguages,
      getReadOnly: () => !this.view.editable,
      setLanguage: this.setLanguage,
      config: this.config
    }), this.codeMirrorKeymap = () => {
      const o = this.view;
      return [
        { key: "ArrowUp", run: () => this.maybeEscape("line", -1) },
        { key: "ArrowLeft", run: () => this.maybeEscape("char", -1) },
        { key: "ArrowDown", run: () => this.maybeEscape("line", 1) },
        { key: "ArrowRight", run: () => this.maybeEscape("char", 1) },
        {
          key: "Mod-Enter",
          run: () => cA(o.state, o.dispatch) ? (o.focus(), !0) : !1
        },
        { key: "Mod-z", run: () => sg(o.state, o.dispatch) },
        { key: "Shift-Mod-z", run: () => Uc(o.state, o.dispatch) },
        { key: "Mod-y", run: () => Uc(o.state, o.dispatch) },
        {
          key: "Backspace",
          run: () => {
            var l;
            const a = this.cm.state.selection.ranges;
            if (a.length > 1) return !1;
            const c = a[0];
            if (c && (!c.empty || c.anchor > 0) || this.cm.state.doc.lines >= 2) return !1;
            const u = this.view.state, h = (l = this.getPos()) != null ? l : 0, f = u.tr.replaceWith(
              h,
              h + this.node.nodeSize,
              u.schema.nodes.paragraph.createChecked({}, this.node.content)
            );
            return f.setSelection(Ee.near(f.doc.resolve(h))), this.view.dispatch(f), this.view.focus(), !0;
          }
        }
      ];
    }, this.maybeEscape = (o, l) => {
      var a;
      const { state: c } = this.cm;
      let u = c.selection.main;
      if (!u.empty || (o === "line" && (u = c.doc.lineAt(u.head)), l < 0 ? u.from > 0 : u.to < c.doc.length)) return !1;
      const h = ((a = this.getPos()) != null ? a : 0) + (l < 0 ? 0 : this.node.nodeSize), f = Ee.near(
        this.view.state.doc.resolve(h),
        l
      ), d = this.view.state.tr.setSelection(f).scrollIntoView();
      return this.view.dispatch(d), this.view.focus(), !0;
    }, this.setLanguage = (o) => {
      var l;
      this.view.dispatch(
        this.view.state.tr.setNodeAttribute(
          (l = this.getPos()) != null ? l : 0,
          "language",
          o
        )
      );
    }, this.getAllLanguages = () => this.loader.getAll(), this.languageConf = new Rc(), this.readOnlyConf = new Rc(), this.cm = new Ce({
      doc: this.node.textContent,
      root: this.view.root,
      extensions: [
        this.readOnlyConf.of(jt.readOnly.of(!this.view.editable)),
        tM(),
        nu.of(this.codeMirrorKeymap()),
        this.languageConf.of([]),
        jt.changeFilter.of(() => this.view.editable),
        ...s.extensions,
        Ce.updateListener.of(this.forwardUpdate)
      ]
    }), this.app = this.createApp(), this.dom = this.createDom(this.app), this.disposeSelectedWatcher = uu(() => {
      this.selected.value ? this.dom.classList.add("selected") : this.dom.classList.remove("selected");
    }), this.updateLanguage();
  }
  createDom(e) {
    const t = document.createElement("div");
    return t.className = "milkdown-code-block", this.text.value = this.node.textContent, e.mount(t), t;
  }
  updateLanguage() {
    const e = this.node.attrs.language;
    if (e === this.languageName) return;
    this.language.value = e, this.loader.load(e ?? "").then((r) => {
      r && (this.cm.dispatch({
        effects: this.languageConf.reconfigure(r)
      }), this.languageName = e);
    }).catch(console.error);
  }
  setSelection(e, t) {
    this.cm.dom.isConnected && (this.cm.focus(), this.updating = !0, this.cm.dispatch({ selection: { anchor: e, head: t } }), this.updating = !1);
  }
  update(e) {
    if (e.type !== this.node.type) return !1;
    if (this.updating) return !0;
    this.node = e, this.text.value = e.textContent, this.updateLanguage(), this.view.editable === this.cm.state.readOnly && this.cm.dispatch({
      effects: this.readOnlyConf.reconfigure(
        jt.readOnly.of(!this.view.editable)
      )
    });
    const t = Are(this.cm.state.doc.toString(), e.textContent);
    return t && (this.updating = !0, this.cm.dispatch({
      changes: { from: t.from, to: t.to, insert: t.text },
      scrollIntoView: !0
    }), this.updating = !1), !0;
  }
  selectNode() {
    this.selected.value = !0, this.cm.focus();
  }
  deselectNode() {
    this.selected.value = !1;
  }
  stopEvent() {
    return !0;
  }
  destroy() {
    this.app.unmount(), this.cm.destroy(), this.disposeSelectedWatcher();
  }
}
function Are(n, e) {
  if (n === e) return null;
  let t = 0, r = n.length, i = e.length;
  for (; t < r && n.charCodeAt(t) === e.charCodeAt(t); )
    ++t;
  for (; r > t && i > t && n.charCodeAt(r - 1) === e.charCodeAt(i - 1); )
    r--, i--;
  return { from: t, to: r, text: e.slice(t, i) };
}
const aD = yd(
  Cs.node,
  (n) => {
    const e = n.get(Nd.key), t = new vre(e.languages);
    return (r, i, s) => new Tre(r, i, s, t, e);
  }
);
lD(aD, {
  displayName: "NodeView<code-block>",
  group: "CodeBlock"
});
const Ore = [
  aD,
  Nd
], qk = typeof String.prototype.normalize == "function" ? (n) => n.normalize("NFKD") : (n) => n;
class Kc {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, r = 0, i = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = s ? (l) => s(qk(l)) : qk, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return kr(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = l3(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += as(e);
      let i = this.normalize(t);
      if (i.length)
        for (let s = 0, o = r; ; s++) {
          let l = i.charCodeAt(s), a = this.match(l, o, this.bufferPos + this.bufferStart);
          if (s == i.length - 1) {
            if (a)
              return this.value = a, this;
            break;
          }
          o == r && s < t.length && t.charCodeAt(s) == l && o++;
        }
    }
  }
  match(e, t, r) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], l = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? i = { from: this.matches[s + 1], to: r } : (this.matches[s]++, l = !0)), l || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: r } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (Kc.prototype[Symbol.iterator] = function() {
  return this;
});
const cD = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Xv = "gm" + (/x/.unicode == null ? "" : "u");
class uD {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, r, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = cD, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new hD(e, t, r, i, s);
    this.re = new RegExp(t, Xv + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.iter = e.iter();
    let o = e.lineAt(i);
    this.curLineStart = o.from, this.matchPos = zm(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let r = this.curLineStart + t.index, i = r + t[0].length;
        if (this.matchPos = zm(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Q2 = /* @__PURE__ */ new WeakMap();
class Ec {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, r) {
    let i = Q2.get(e);
    if (!i || i.from >= r || i.to <= t) {
      let l = new Ec(t, e.sliceString(t, r));
      return Q2.set(e, l), l;
    }
    if (i.from == t && i.to == r)
      return i;
    let { text: s, from: o } = i;
    return o > t && (s = e.sliceString(t, o) + s, o = t), i.to < r && (s += e.sliceString(i.to, r)), Q2.set(e, new Ec(o, s)), new Ec(t, s.slice(t - o, r - o));
  }
}
class hD {
  constructor(e, t, r, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = cD, this.matchPos = zm(e, i), this.re = new RegExp(t, Xv + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.flat = Ec.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let r = this.flat.from + t.index, i = r + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this.matchPos = zm(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Ec.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (uD.prototype[Symbol.iterator] = hD.prototype[Symbol.iterator] = function() {
  return this;
});
function Ere(n) {
  try {
    return new RegExp(n, Xv), !0;
  } catch {
    return !1;
  }
}
function zm(n, e) {
  if (e >= n.length)
    return e;
  let t = n.lineAt(e), r;
  for (; e < t.to && (r = t.text.charCodeAt(e - t.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function E5(n) {
  let e = String(n.state.doc.lineAt(n.state.selection.main.head).number), t = At("input", { class: "cm-textfield", name: "line", value: e }), r = At("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), n.dispatch({ effects: pf.of(!1) }), n.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, At("label", n.state.phrase("Go to line"), ": ", t), " ", At("button", { class: "cm-button", type: "submit" }, n.state.phrase("go")), At("button", {
    name: "close",
    onclick: () => {
      n.dispatch({ effects: pf.of(!1) }), n.focus();
    },
    "aria-label": n.state.phrase("close"),
    type: "button"
  }, ["×"]));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!s)
      return;
    let { state: o } = n, l = o.doc.lineAt(o.selection.main.head), [, a, c, u, h] = s, f = u ? +u.slice(1) : 0, d = c ? +c : l.number;
    if (c && h) {
      let g = d / 100;
      a && (g = g * (a == "-" ? -1 : 1) + l.number / o.doc.lines), d = Math.round(o.doc.lines * g);
    } else c && a && (d = d * (a == "-" ? -1 : 1) + l.number);
    let p = o.doc.line(Math.max(1, Math.min(o.doc.lines, d))), m = G.cursor(p.from + Math.max(0, Math.min(f, p.length)));
    n.dispatch({
      effects: [pf.of(!1), Ce.scrollIntoView(m.from, { y: "center" })],
      selection: m
    }), n.focus();
  }
  return { dom: r };
}
const pf = /* @__PURE__ */ Xe.define(), Wk = /* @__PURE__ */ On.define({
  create() {
    return !0;
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(pf) && (n = t.value);
    return n;
  },
  provide: (n) => Ef.from(n, (e) => e ? E5 : null)
}), Ire = (n) => {
  let e = Of(n, E5);
  if (!e) {
    let t = [pf.of(!0)];
    n.state.field(Wk, !1) == null && t.push(Xe.appendConfig.of([Wk, Dre])), n.dispatch({ effects: t }), e = Of(n, E5);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, Dre = /* @__PURE__ */ Ce.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), Nre = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, Rre = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, Nre, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Pre(n) {
  return [Fre, zre];
}
const _re = /* @__PURE__ */ He.mark({ class: "cm-selectionMatch" }), Lre = /* @__PURE__ */ He.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function jk(n, e, t, r) {
  return (t == 0 || n(e.sliceDoc(t - 1, t)) != Wt.Word) && (r == e.doc.length || n(e.sliceDoc(r, r + 1)) != Wt.Word);
}
function Bre(n, e, t, r) {
  return n(e.sliceDoc(t, t + 1)) == Wt.Word && n(e.sliceDoc(r - 1, r)) == Wt.Word;
}
const zre = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.selectionSet || n.docChanged || n.viewportChanged) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = n.state.facet(Rre), { state: t } = n, r = t.selection;
    if (r.ranges.length > 1)
      return He.none;
    let i = r.main, s, o = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return He.none;
      let a = t.wordAt(i.head);
      if (!a)
        return He.none;
      o = t.charCategorizer(i.head), s = t.sliceDoc(a.from, a.to);
    } else {
      let a = i.to - i.from;
      if (a < e.minSelectionLength || a > 200)
        return He.none;
      if (e.wholeWords) {
        if (s = t.sliceDoc(i.from, i.to), o = t.charCategorizer(i.head), !(jk(o, t, i.from, i.to) && Bre(o, t, i.from, i.to)))
          return He.none;
      } else if (s = t.sliceDoc(i.from, i.to), !s)
        return He.none;
    }
    let l = [];
    for (let a of n.visibleRanges) {
      let c = new Kc(t.doc, s, a.from, a.to);
      for (; !c.next().done; ) {
        let { from: u, to: h } = c.value;
        if ((!o || jk(o, t, u, h)) && (i.empty && u <= i.from && h >= i.to ? l.push(Lre.range(u, h)) : (u >= i.to || h <= i.from) && l.push(_re.range(u, h)), l.length > e.maxMatches))
          return He.none;
      }
    }
    return He.set(l);
  }
}, {
  decorations: (n) => n.decorations
}), Fre = /* @__PURE__ */ Ce.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Hre = ({ state: n, dispatch: e }) => {
  let { selection: t } = n, r = G.create(t.ranges.map((i) => n.wordAt(i.head) || G.cursor(i.head)), t.mainIndex);
  return r.eq(t) ? !1 : (e(n.update({ selection: r })), !0);
};
function $re(n, e) {
  let { main: t, ranges: r } = n.selection, i = n.wordAt(t.head), s = i && i.from == t.from && i.to == t.to;
  for (let o = !1, l = new Kc(n.doc, e, r[r.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new Kc(n.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((a) => a.from == l.value.from))
        continue;
      if (s) {
        let a = n.wordAt(l.value.from);
        if (!a || a.from != l.value.from || a.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const Vre = ({ state: n, dispatch: e }) => {
  let { ranges: t } = n.selection;
  if (t.some((s) => s.from === s.to))
    return Hre({ state: n, dispatch: e });
  let r = n.sliceDoc(t[0].from, t[0].to);
  if (n.selection.ranges.some((s) => n.sliceDoc(s.from, s.to) != r))
    return !1;
  let i = $re(n, r);
  return i ? (e(n.update({
    selection: n.selection.addRange(G.range(i.from, i.to), !1),
    effects: Ce.scrollIntoView(i.to)
  })), !0) : !1;
}, pu = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new eie(e),
      scrollToMatch: (e) => Ce.scrollIntoView(e)
    });
  }
});
class fD {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Ere(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new Ure(this) : new Wre(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, r) {
    let i = e.doc ? e : jt.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? uc(this, i, t, r) : cc(this, i, t, r);
  }
}
class dD {
  constructor(e) {
    this.spec = e;
  }
}
function cc(n, e, t, r) {
  return new Kc(e.doc, n.unquoted, t, r, n.caseSensitive ? void 0 : (i) => i.toLowerCase(), n.wholeWord ? qre(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function qre(n, e) {
  return (t, r, i, s) => ((s > t || s + i.length < r) && (s = Math.max(0, t - 2), i = n.sliceString(s, Math.min(n.length, r + 2))), (e(Fm(i, t - s)) != Wt.Word || e(Hm(i, t - s)) != Wt.Word) && (e(Hm(i, r - s)) != Wt.Word || e(Fm(i, r - s)) != Wt.Word));
}
class Wre extends dD {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, r) {
    let i = cc(this.spec, e, r, e.doc.length).nextOverlapping();
    if (i.done) {
      let s = Math.min(e.doc.length, t + this.spec.unquoted.length);
      i = cc(this.spec, e, 0, s).nextOverlapping();
    }
    return i.done || i.value.from == t && i.value.to == r ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, r) {
    for (let i = r; ; ) {
      let s = Math.max(t, i - 1e4 - this.spec.unquoted.length), o = cc(this.spec, e, s, i), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (s == t)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, t, r) {
    let i = this.prevMatchInRange(e, 0, t);
    return i || (i = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), i && (i.from != t || i.to != r) ? i : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let r = cc(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let s = cc(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function uc(n, e, t, r) {
  return new uD(e.doc, n.search, {
    ignoreCase: !n.caseSensitive,
    test: n.wholeWord ? jre(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, r);
}
function Fm(n, e) {
  return n.slice(zn(n, e, !1), e);
}
function Hm(n, e) {
  return n.slice(e, zn(n, e));
}
function jre(n) {
  return (e, t, r) => !r[0].length || (n(Fm(r.input, r.index)) != Wt.Word || n(Hm(r.input, r.index)) != Wt.Word) && (n(Hm(r.input, r.index + r[0].length)) != Wt.Word || n(Fm(r.input, r.index + r[0].length)) != Wt.Word);
}
class Ure extends dD {
  nextMatch(e, t, r) {
    let i = uc(this.spec, e, r, e.doc.length).next();
    return i.done && (i = uc(this.spec, e, 0, t).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, t, r) {
    for (let i = 1; ; i++) {
      let s = Math.max(
        t,
        r - i * 1e4
        /* FindPrev.ChunkSize */
      ), o = uc(this.spec, e, s, r), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (s == t || l.from > s + 10))
        return l;
      if (s == t)
        return null;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (t, r) => {
      if (r == "&")
        return e.match[0];
      if (r == "$")
        return "$";
      for (let i = r.length; i > 0; i--) {
        let s = +r.slice(0, i);
        if (s > 0 && s < e.match.length)
          return e.match[s] + r.slice(i);
      }
      return t;
    });
  }
  matchAll(e, t) {
    let r = uc(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let s = uc(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const Jf = /* @__PURE__ */ Xe.define(), Zv = /* @__PURE__ */ Xe.define(), al = /* @__PURE__ */ On.define({
  create(n) {
    return new e4(I5(n).create(), null);
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(Jf) ? n = new e4(t.value.create(), n.panel) : t.is(Zv) && (n = new e4(n.query, t.value ? Qv : null));
    return n;
  },
  provide: (n) => Ef.from(n, (e) => e.panel)
});
class e4 {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const Kre = /* @__PURE__ */ He.mark({ class: "cm-searchMatch" }), Gre = /* @__PURE__ */ He.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Yre = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.decorations = this.highlight(n.state.field(al));
  }
  update(n) {
    let e = n.state.field(al);
    (e != n.startState.field(al) || n.docChanged || n.selectionSet || n.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: n, panel: e }) {
    if (!e || !n.spec.valid)
      return He.none;
    let { view: t } = this, r = new lo();
    for (let i = 0, s = t.visibleRanges, o = s.length; i < o; i++) {
      let { from: l, to: a } = s[i];
      for (; i < o - 1 && a > s[i + 1].from - 500; )
        a = s[++i].to;
      n.highlight(t.state, l, a, (c, u) => {
        let h = t.state.selection.ranges.some((f) => f.from == c && f.to == u);
        r.add(c, u, h ? Gre : Kre);
      });
    }
    return r.finish();
  }
}, {
  decorations: (n) => n.decorations
});
function Rd(n) {
  return (e) => {
    let t = e.state.field(al, !1);
    return t && t.query.spec.valid ? n(e, t) : gD(e);
  };
}
const $m = /* @__PURE__ */ Rd((n, { query: e }) => {
  let { to: t } = n.state.selection.main, r = e.nextMatch(n.state, t, t);
  if (!r)
    return !1;
  let i = G.single(r.from, r.to), s = n.state.facet(pu);
  return n.dispatch({
    selection: i,
    effects: [e7(n, r), s.scrollToMatch(i.main, n)],
    userEvent: "select.search"
  }), mD(n), !0;
}), Vm = /* @__PURE__ */ Rd((n, { query: e }) => {
  let { state: t } = n, { from: r } = t.selection.main, i = e.prevMatch(t, r, r);
  if (!i)
    return !1;
  let s = G.single(i.from, i.to), o = n.state.facet(pu);
  return n.dispatch({
    selection: s,
    effects: [e7(n, i), o.scrollToMatch(s.main, n)],
    userEvent: "select.search"
  }), mD(n), !0;
}), Jre = /* @__PURE__ */ Rd((n, { query: e }) => {
  let t = e.matchAll(n.state, 1e3);
  return !t || !t.length ? !1 : (n.dispatch({
    selection: G.create(t.map((r) => G.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), Xre = ({ state: n, dispatch: e }) => {
  let t = n.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: r, to: i } = t.main, s = [], o = 0;
  for (let l = new Kc(n.doc, n.sliceDoc(r, i)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == r && (o = s.length), s.push(G.range(l.value.from, l.value.to));
  }
  return e(n.update({
    selection: G.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, Uk = /* @__PURE__ */ Rd((n, { query: e }) => {
  let { state: t } = n, { from: r, to: i } = t.selection.main;
  if (t.readOnly)
    return !1;
  let s = e.nextMatch(t, r, r);
  if (!s)
    return !1;
  let o = s, l = [], a, c, u = [];
  o.from == r && o.to == i && (c = t.toText(e.getReplacement(o)), l.push({ from: o.from, to: o.to, insert: c }), o = e.nextMatch(t, o.from, o.to), u.push(Ce.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(r).number) + ".")));
  let h = n.state.changes(l);
  return o && (a = G.single(o.from, o.to).map(h), u.push(e7(n, o)), u.push(t.facet(pu).scrollToMatch(a.main, n))), n.dispatch({
    changes: h,
    selection: a,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), Zre = /* @__PURE__ */ Rd((n, { query: e }) => {
  if (n.state.readOnly)
    return !1;
  let t = e.matchAll(n.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: e.getReplacement(i) };
  });
  if (!t.length)
    return !1;
  let r = n.state.phrase("replaced $ matches", t.length) + ".";
  return n.dispatch({
    changes: t,
    effects: Ce.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function Qv(n) {
  return n.state.facet(pu).createPanel(n);
}
function I5(n, e) {
  var t, r, i, s, o;
  let l = n.selection.main, a = l.empty || l.to > l.from + 100 ? "" : n.sliceDoc(l.from, l.to);
  if (e && !a)
    return e;
  let c = n.facet(pu);
  return new fD({
    search: ((t = e?.literal) !== null && t !== void 0 ? t : c.literal) ? a : a.replace(/\n/g, "\\n"),
    caseSensitive: (r = e?.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (i = e?.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (s = e?.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e?.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function pD(n) {
  let e = Of(n, Qv);
  return e && e.dom.querySelector("[main-field]");
}
function mD(n) {
  let e = pD(n);
  e && e == n.root.activeElement && e.select();
}
const gD = (n) => {
  let e = n.state.field(al, !1);
  if (e && e.panel) {
    let t = pD(n);
    if (t && t != n.root.activeElement) {
      let r = I5(n.state, e.query.spec);
      r.valid && n.dispatch({ effects: Jf.of(r) }), t.focus(), t.select();
    }
  } else
    n.dispatch({ effects: [
      Zv.of(!0),
      e ? Jf.of(I5(n.state, e.query.spec)) : Xe.appendConfig.of(nie)
    ] });
  return !0;
}, yD = (n) => {
  let e = n.state.field(al, !1);
  if (!e || !e.panel)
    return !1;
  let t = Of(n, Qv);
  return t && t.dom.contains(n.root.activeElement) && n.focus(), n.dispatch({ effects: Zv.of(!1) }), !0;
}, Qre = [
  { key: "Mod-f", run: gD, scope: "editor search-panel" },
  { key: "F3", run: $m, shift: Vm, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: $m, shift: Vm, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: yD, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Xre },
  { key: "Mod-Alt-g", run: Ire },
  { key: "Mod-d", run: Vre, preventDefault: !0 }
];
class eie {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(al).query.spec;
    this.commit = this.commit.bind(this), this.searchField = At("input", {
      value: t.search,
      placeholder: Br(e, "Find"),
      "aria-label": Br(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = At("input", {
      value: t.replace,
      placeholder: Br(e, "Replace"),
      "aria-label": Br(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = At("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = At("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = At("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function r(i, s, o) {
      return At("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = At("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => $m(e), [Br(e, "next")]),
      r("prev", () => Vm(e), [Br(e, "previous")]),
      r("select", () => Jre(e), [Br(e, "all")]),
      At("label", null, [this.caseField, Br(e, "match case")]),
      At("label", null, [this.reField, Br(e, "regexp")]),
      At("label", null, [this.wordField, Br(e, "by word")]),
      ...e.state.readOnly ? [] : [
        At("br"),
        this.replaceField,
        r("replace", () => Uk(e), [Br(e, "replace")]),
        r("replaceAll", () => Zre(e), [Br(e, "replace all")])
      ],
      At("button", {
        name: "close",
        onclick: () => yD(e),
        "aria-label": Br(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new fD({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Jf.of(e) }));
  }
  keydown(e) {
    Ez(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Vm : $m)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Uk(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(Jf) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(pu).top;
  }
}
function Br(n, e) {
  return n.state.phrase(e);
}
const M0 = 30, T0 = /[\s\.,:;?!]/;
function e7(n, { from: e, to: t }) {
  let r = n.state.doc.lineAt(e), i = n.state.doc.lineAt(t).to, s = Math.max(r.from, e - M0), o = Math.min(i, t + M0), l = n.state.sliceDoc(s, o);
  if (s != r.from) {
    for (let a = 0; a < M0; a++)
      if (!T0.test(l[a + 1]) && T0.test(l[a])) {
        l = l.slice(a);
        break;
      }
  }
  if (o != i) {
    for (let a = l.length - 1; a > l.length - M0; a--)
      if (!T0.test(l[a - 1]) && T0.test(l[a])) {
        l = l.slice(0, a);
        break;
      }
  }
  return Ce.announce.of(`${n.state.phrase("current match")}. ${l} ${n.state.phrase("on line")} ${r.number}.`);
}
const tie = /* @__PURE__ */ Ce.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), nie = [
  al,
  /* @__PURE__ */ kl.low(Yre),
  tie
];
class bD {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, r, i) {
    this.state = e, this.pos = t, this.explicit = r, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = Fn(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), r = Math.max(t.from, this.pos - 250), i = t.text.slice(r - t.from, this.pos - t.from), s = i.search(vD(e, !1));
    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, t, r) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(t), r && r.onDocChange && (this.abortOnDocChange = !0));
  }
}
function Kk(n) {
  let e = Object.keys(n).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function rie(n) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of n) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      t[i[s]] = !0;
  }
  let r = Kk(e) + Kk(t) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function iie(n) {
  let e = n.map((i) => typeof i == "string" ? { label: i } : i), [t, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : rie(e);
  return (i) => {
    let s = i.matchBefore(r);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: t } : null;
  };
}
function Yue(n, e) {
  return (t) => {
    for (let r = Fn(t.state).resolveInner(t.pos, -1); r; r = r.parent) {
      if (n.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(t);
  };
}
class Gk {
  constructor(e, t, r, i) {
    this.completion = e, this.source = t, this.match = r, this.score = i;
  }
}
function ya(n) {
  return n.selection.main.from;
}
function vD(n, e) {
  var t;
  let { source: r } = n, i = e && r[0] != "^", s = r[r.length - 1] != "$";
  return !i && !s ? n : new RegExp(`${i ? "^" : ""}(?:${r})${s ? "$" : ""}`, (t = n.flags) !== null && t !== void 0 ? t : n.ignoreCase ? "i" : "");
}
const t7 = /* @__PURE__ */ wo.define();
function sie(n, e, t, r) {
  let { main: i } = n.selection, s = t - i.from, o = r - i.from;
  return {
    ...n.changeByRange((l) => {
      if (l != i && t != r && n.sliceDoc(l.from + s, l.from + o) != n.sliceDoc(t, r))
        return { range: l };
      let a = n.toText(e);
      return {
        changes: { from: l.from + s, to: r == i.from ? l.to : l.from + o, insert: a },
        range: G.cursor(l.from + s + a.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
const Yk = /* @__PURE__ */ new WeakMap();
function oie(n) {
  if (!Array.isArray(n))
    return n;
  let e = Yk.get(n);
  return e || Yk.set(n, e = iie(n)), e;
}
const qm = /* @__PURE__ */ Xe.define(), Xf = /* @__PURE__ */ Xe.define();
class lie {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let r = kr(e, t), i = as(r);
      this.chars.push(r);
      let s = e.slice(t, t + i), o = s.toUpperCase();
      this.folded.push(kr(o == s ? s.toLowerCase() : o, 0)), t += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: r, any: i, precise: s, byWord: o } = this;
    if (t.length == 1) {
      let w = kr(e, 0), k = as(w), C = k == e.length ? 0 : -100;
      if (w != t[0]) if (w == r[0])
        C += -200;
      else
        return null;
      return this.ret(C, [0, k]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let a = t.length, c = 0;
    if (l < 0) {
      for (let w = 0, k = Math.min(e.length, 200); w < k && c < a; ) {
        let C = kr(e, w);
        (C == t[c] || C == r[c]) && (i[c++] = w), w += as(C);
      }
      if (c < a)
        return null;
    }
    let u = 0, h = 0, f = !1, d = 0, p = -1, m = -1, g = /[a-z]/.test(e), b = !0;
    for (let w = 0, k = Math.min(e.length, 200), C = 0; w < k && h < a; ) {
      let M = kr(e, w);
      l < 0 && (u < a && M == t[u] && (s[u++] = w), d < a && (M == t[d] || M == r[d] ? (d == 0 && (p = w), m = w + 1, d++) : d = 0));
      let T, N = M < 255 ? M >= 48 && M <= 57 || M >= 97 && M <= 122 ? 2 : M >= 65 && M <= 90 ? 1 : 0 : (T = l3(M)) != T.toLowerCase() ? 1 : T != T.toUpperCase() ? 2 : 0;
      (!w || N == 1 && g || C == 0 && N != 0) && (t[h] == M || r[h] == M && (f = !0) ? o[h++] = w : o.length && (b = !1)), C = N, w += as(M);
    }
    return h == a && o[0] == 0 && b ? this.result(-100 + (f ? -200 : 0), o, e) : d == a && p == 0 ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : d == a ? this.ret(-900 - e.length, [p, m]) : h == a ? this.result(-100 + (f ? -200 : 0) + -700 + (b ? 0 : -1100), o, e) : t.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, t, r) {
    let i = [], s = 0;
    for (let o of t) {
      let l = o + (this.astral ? as(kr(r, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = l : (i[s++] = o, i[s++] = l);
    }
    return this.ret(e - r.length, i);
  }
}
class aie {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let t = e.slice(0, this.pattern.length), r = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, t.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const Mn = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: cie,
      filterStrict: !1,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (r) => Jk(e(r), t(r)),
      optionClass: (e, t) => (r) => Jk(e(r), t(r)),
      addToOptions: (e, t) => e.concat(t),
      filterStrict: (e, t) => e || t
    });
  }
});
function Jk(n, e) {
  return n ? e ? n + " " + e : n : e;
}
function cie(n, e, t, r, i, s) {
  let o = n.textDirection == qt.RTL, l = o, a = !1, c = "top", u, h, f = e.left - i.left, d = i.right - e.right, p = r.right - r.left, m = r.bottom - r.top;
  if (l && f < Math.min(p, d) ? l = !1 : !l && d < Math.min(p, f) && (l = !0), p <= (l ? f : d))
    u = Math.max(i.top, Math.min(t.top, i.bottom - m)) - e.top, h = Math.min(400, l ? f : d);
  else {
    a = !0, h = Math.min(
      400,
      (o ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let w = i.bottom - e.bottom;
    w >= m || w > e.top ? u = t.bottom - e.top : (c = "bottom", u = e.bottom - t.top);
  }
  let g = (e.bottom - e.top) / s.offsetHeight, b = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${u / g}px; max-width: ${h / b}px`,
    class: "cm-completionInfo-" + (a ? o ? "left-narrow" : "right-narrow" : l ? "left" : "right")
  };
}
function uie(n) {
  let e = n.addToOptions.slice();
  return n.icons && e.push({
    render(t) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), t.type && r.classList.add(...t.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(t, r, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let l = t.displayLabel || t.label, a = 0;
      for (let c = 0; c < s.length; ) {
        let u = s[c++], h = s[c++];
        u > a && o.appendChild(document.createTextNode(l.slice(a, u)));
        let f = o.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(l.slice(u, h))), f.className = "cm-completionMatchedText", a = h;
      }
      return a < l.length && o.appendChild(document.createTextNode(l.slice(a))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = t.detail, r;
    },
    position: 80
  }), e.sort((t, r) => t.position - r.position).map((t) => t.render);
}
function t4(n, e, t) {
  if (n <= t)
    return { from: 0, to: n };
  if (e < 0 && (e = 0), e <= n >> 1) {
    let i = Math.floor(e / t);
    return { from: i * t, to: (i + 1) * t };
  }
  let r = Math.floor((n - e) / t);
  return { from: n - (r + 1) * t, to: n - r * t };
}
class hie {
  constructor(e, t, r) {
    this.view = e, this.stateField = t, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (a) => this.placeInfo(a),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(t), { options: s, selected: o } = i.open, l = e.state.facet(Mn);
    this.optionContent = uie(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = t4(s.length, o, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (a) => {
      let { options: c } = e.state.field(t).open;
      for (let u = a.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
          this.applyCompletion(e, c[+h[1]]), a.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (a) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Mn).closeOnBlur && a.relatedTarget != e.contentDOM && e.dispatch({ effects: Xf.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != i) {
      let { options: s, selected: o, disabled: l } = r.open;
      (!i.open || i.open.options != s) && (this.range = t4(s.length, o, e.state.facet(Mn).maxRenderedOptions), this.showOptions(s, r.id)), this.updateSel(), l != ((t = i.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of t.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = t4(t.options.length, t.selected, this.view.state.facet(Mn).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: r } = t.options[t.selected], { info: i } = r;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);
      }).catch((o) => Mr(this.view.state, o, "completion info")) : this.addInfoPane(s, r);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      r.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), t = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return t && die(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.documentElement;
      s = { left: 0, top: 0, right: o.clientWidth, bottom: o.clientHeight };
    }
    return i.top > Math.min(s.bottom, t.bottom) - 10 || i.bottom < Math.max(s.top, t.top) + 10 ? null : this.view.state.facet(Mn).positionInfo(this.view, t, i, r, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, r) {
    const i = document.createElement("ul");
    i.id = t, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (o) => {
      o.target == i && o.preventDefault();
    });
    let s = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: l, match: a } = e[o], { section: c } = l;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != s && (o > r.from || r.from == 0))
          if (s = f, typeof c != "string" && c.header)
            i.appendChild(c.header(c));
          else {
            let d = i.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      u.id = t + "-" + o, u.setAttribute("role", "option");
      let h = this.optionClass(l);
      h && (u.className = h);
      for (let f of this.optionContent) {
        let d = f(l, this.view.state, this.view, a);
        d && u.appendChild(d);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function fie(n, e) {
  return (t) => new hie(t, n, e);
}
function die(n, e) {
  let t = n.getBoundingClientRect(), r = e.getBoundingClientRect(), i = t.height / n.offsetHeight;
  r.top < t.top ? n.scrollTop -= (t.top - r.top) / i : r.bottom > t.bottom && (n.scrollTop += (r.bottom - t.bottom) / i);
}
function Xk(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
function pie(n, e) {
  let t = [], r = null, i = (c) => {
    t.push(c);
    let { section: u } = c.completion;
    if (u) {
      r || (r = []);
      let h = typeof u == "string" ? u : u.name;
      r.some((f) => f.name == h) || r.push(typeof u == "string" ? { name: h } : u);
    }
  }, s = e.facet(Mn);
  for (let c of n)
    if (c.hasResult()) {
      let u = c.result.getMatch;
      if (c.result.filter === !1)
        for (let h of c.result.options)
          i(new Gk(h, c.source, u ? u(h) : [], 1e9 - t.length));
      else {
        let h = e.sliceDoc(c.from, c.to), f, d = s.filterStrict ? new aie(h) : new lie(h);
        for (let p of c.result.options)
          if (f = d.match(p.label)) {
            let m = p.displayLabel ? u ? u(p, f.matched) : [] : f.matched;
            i(new Gk(p, c.source, m, f.score + (p.boost || 0)));
          }
      }
    }
  if (r) {
    let c = /* @__PURE__ */ Object.create(null), u = 0, h = (f, d) => {
      var p, m;
      return ((p = f.rank) !== null && p !== void 0 ? p : 1e9) - ((m = d.rank) !== null && m !== void 0 ? m : 1e9) || (f.name < d.name ? -1 : 1);
    };
    for (let f of r.sort(h))
      u -= 1e5, c[f.name] = u;
    for (let f of t) {
      let { section: d } = f.completion;
      d && (f.score += c[typeof d == "string" ? d : d.name]);
    }
  }
  let o = [], l = null, a = s.compareCompletions;
  for (let c of t.sort((u, h) => h.score - u.score || a(u.completion, h.completion))) {
    let u = c.completion;
    !l || l.label != u.label || l.detail != u.detail || l.type != null && u.type != null && l.type != u.type || l.apply != u.apply || l.boost != u.boost ? o.push(c) : Xk(c.completion) > Xk(l) && (o[o.length - 1] = c), l = c.completion;
  }
  return o;
}
class gc {
  constructor(e, t, r, i, s, o) {
    this.options = e, this.attrs = t, this.tooltip = r, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new gc(this.options, Zk(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, r, i, s, o) {
    if (i && !o && e.some((c) => c.isPending))
      return i.setDisabled();
    let l = pie(e, t);
    if (!l.length)
      return i && e.some((c) => c.isPending) ? i.setDisabled() : null;
    let a = t.facet(Mn).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let c = i.options[i.selected].completion;
      for (let u = 0; u < l.length; u++)
        if (l[u].completion == c) {
          a = u;
          break;
        }
    }
    return new gc(l, Zk(r, a), {
      pos: e.reduce((c, u) => u.hasResult() ? Math.min(c, u.from) : c, 1e8),
      create: wie,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new gc(this.options, this.attrs, { ...this.tooltip, pos: e.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new gc(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class Wm {
  constructor(e, t, r) {
    this.active = e, this.id = t, this.open = r;
  }
  static start() {
    return new Wm(bie, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, r = t.facet(Mn), s = (r.override || t.languageDataAt("autocomplete", ya(t)).map(oie)).map((a) => (this.active.find((u) => u.source == a) || new hi(
      a,
      this.active.some(
        (u) => u.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    s.length == this.active.length && s.every((a, c) => a == this.active[c]) && (s = this.active);
    let o = this.open, l = e.effects.some((a) => a.is(n7));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !mie(s, this.active) || l ? o = gc.build(s, t, this.id, o, r, l) : o && o.disabled && !s.some((a) => a.isPending) && (o = null), !o && s.every((a) => !a.isPending) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new hi(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(xD) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new Wm(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? gie : yie;
  }
}
function mie(n, e) {
  if (n == e)
    return !0;
  for (let t = 0, r = 0; ; ) {
    for (; t < n.length && !n[t].hasResult(); )
      t++;
    for (; r < e.length && !e[r].hasResult(); )
      r++;
    let i = t == n.length, s = r == e.length;
    if (i || s)
      return i == s;
    if (n[t++].result != e[r++].result)
      return !1;
  }
}
const gie = {
  "aria-autocomplete": "list"
}, yie = {};
function Zk(n, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return e > -1 && (t["aria-activedescendant"] = n + "-" + e), t;
}
const bie = [];
function wD(n, e) {
  if (n.isUserEvent("input.complete")) {
    let r = n.annotation(t7);
    if (r && e.activateOnCompletion(r))
      return 12;
  }
  let t = n.isUserEvent("input.type");
  return t && e.activateOnTyping ? 5 : t ? 1 : n.isUserEvent("delete.backward") ? 2 : n.selection ? 8 : n.docChanged ? 16 : 0;
}
class hi {
  constructor(e, t, r = !1) {
    this.source = e, this.state = t, this.explicit = r;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, t) {
    let r = wD(e, t), i = this;
    (r & 8 || r & 16 && this.touches(e)) && (i = new hi(
      i.source,
      0
      /* State.Inactive */
    )), r & 4 && i.state == 0 && (i = new hi(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(e, r);
    for (let s of e.effects)
      if (s.is(qm))
        i = new hi(i.source, 1, s.value);
      else if (s.is(Xf))
        i = new hi(
          i.source,
          0
          /* State.Inactive */
        );
      else if (s.is(n7))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  updateFor(e, t) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(ya(e.state));
  }
}
class Ic extends hi {
  constructor(e, t, r, i, s, o) {
    super(e, 3, t), this.limit = r, this.result = i, this.from = s, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, t) {
    var r;
    if (!(t & 3))
      return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), l = ya(e.state);
    if (l > o || !i || t & 2 && (ya(e.startState) == this.from || l < this.limit))
      return new hi(
        this.source,
        t & 4 ? 1 : 0
        /* State.Inactive */
      );
    let a = e.changes.mapPos(this.limit);
    return vie(i.validFor, e.state, s, o) ? new Ic(this.source, this.explicit, a, i, s, o) : i.update && (i = i.update(i, s, o, new bD(e.state, l, !1))) ? new Ic(this.source, this.explicit, a, i, i.from, (r = i.to) !== null && r !== void 0 ? r : ya(e.state)) : new hi(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Ic(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new hi(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function vie(n, e, t, r) {
  if (!n)
    return !1;
  let i = e.sliceDoc(t, r);
  return typeof n == "function" ? n(i, t, r, e) : vD(n, !0).test(i);
}
const n7 = /* @__PURE__ */ Xe.define({
  map(n, e) {
    return n.map((t) => t.map(e));
  }
}), xD = /* @__PURE__ */ Xe.define(), Cr = /* @__PURE__ */ On.define({
  create() {
    return Wm.start();
  },
  update(n, e) {
    return n.update(e);
  },
  provide: (n) => [
    x3.from(n, (e) => e.tooltip),
    Ce.contentAttributes.from(n, (e) => e.attrs)
  ]
});
function r7(n, e) {
  const t = e.completion.apply || e.completion.label;
  let r = n.state.field(Cr).active.find((i) => i.source == e.source);
  return r instanceof Ic ? (typeof t == "string" ? n.dispatch({
    ...sie(n.state, t, r.from, r.to),
    annotations: t7.of(e.completion)
  }) : t(n, e.completion, r.from, r.to), !0) : !1;
}
const wie = /* @__PURE__ */ fie(Cr, r7);
function A0(n, e = "option") {
  return (t) => {
    let r = t.state.field(Cr, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < t.state.facet(Mn).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = sM(t, r.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, l = r.open.selected > -1 ? r.open.selected + i * (n ? 1 : -1) : n ? 0 : o - 1;
    return l < 0 ? l = e == "page" ? 0 : o - 1 : l >= o && (l = e == "page" ? o - 1 : 0), t.dispatch({ effects: xD.of(l) }), !0;
  };
}
const xie = (n) => {
  let e = n.state.field(Cr, !1);
  return n.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < n.state.facet(Mn).interactionDelay ? !1 : r7(n, e.open.options[e.open.selected]);
}, n4 = (n) => n.state.field(Cr, !1) ? (n.dispatch({ effects: qm.of(!0) }), !0) : !1, kie = (n) => {
  let e = n.state.field(Cr, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: Xf.of(null) }), !0);
};
class Sie {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const Cie = 50, Mie = 1e3, Tie = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of n.state.field(Cr).active)
      e.isPending && this.startQuery(e);
  }
  update(n) {
    let e = n.state.field(Cr), t = n.state.facet(Mn);
    if (!n.selectionSet && !n.docChanged && n.startState.field(Cr) == e)
      return;
    let r = n.transactions.some((s) => {
      let o = wD(s, t);
      return o & 8 || (s.selection || s.docChanged) && !(o & 3);
    });
    for (let s = 0; s < this.running.length; s++) {
      let o = this.running[s];
      if (r || o.context.abortOnDocChange && n.docChanged || o.updates.length + n.transactions.length > Cie && Date.now() - o.time > Mie) {
        for (let l of o.context.abortListeners)
          try {
            l();
          } catch (a) {
            Mr(this.view.state, a);
          }
        o.context.abortListeners = null, this.running.splice(s--, 1);
      } else
        o.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((s) => s.effects.some((o) => o.is(qm))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : t.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((s) => s.isPending && !this.running.some((o) => o.active.source == s.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let s of n.transactions)
        s.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && s.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, e = n.field(Cr);
    for (let t of e.active)
      t.isPending && !this.running.some((r) => r.active.source == t.source) && this.startQuery(t);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Mn).updateSyncTime));
  }
  startQuery(n) {
    let { state: e } = this.view, t = ya(e), r = new bD(e, t, n.explicit, this.view), i = new Sie(n, r);
    this.running.push(i), Promise.resolve(n.source(r)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: Xf.of(null) }), Mr(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Mn).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Mn), r = this.view.state.field(Cr);
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (s.done === void 0)
        continue;
      if (this.running.splice(i--, 1), s.done) {
        let l = ya(s.updates.length ? s.updates[0].startState : this.view.state), a = Math.min(l, s.done.from + (s.active.explicit ? 0 : 1)), c = new Ic(s.active.source, s.active.explicit, a, s.done, s.done.from, (n = s.done.to) !== null && n !== void 0 ? n : l);
        for (let u of s.updates)
          c = c.update(u, t);
        if (c.hasResult()) {
          e.push(c);
          continue;
        }
      }
      let o = r.active.find((l) => l.source == s.active.source);
      if (o && o.isPending)
        if (s.done == null) {
          let l = new hi(
            s.active.source,
            0
            /* State.Inactive */
          );
          for (let a of s.updates)
            l = l.update(a, t);
          l.isPending || e.push(l);
        } else
          this.startQuery(o);
    }
    (e.length || r.open && r.open.disabled) && this.view.dispatch({ effects: n7.of(e) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let e = this.view.state.field(Cr, !1);
      if (e && e.tooltip && this.view.state.facet(Mn).closeOnBlur) {
        let t = e.open && sM(this.view, e.open.tooltip);
        (!t || !t.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Xf.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: qm.of(!1) }), 20), this.composing = 0;
    }
  }
}), Aie = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), Oie = /* @__PURE__ */ kl.highest(/* @__PURE__ */ Ce.domEventHandlers({
  keydown(n, e) {
    let t = e.state.field(Cr, !1);
    if (!t || !t.open || t.open.disabled || t.open.selected < 0 || n.key.length > 1 || n.ctrlKey && !(Aie && n.altKey) || n.metaKey)
      return !1;
    let r = t.open.options[t.open.selected], i = t.active.find((o) => o.source == r.source), s = r.completion.commitCharacters || i.result.commitCharacters;
    return s && s.indexOf(n.key) > -1 && r7(e, r), !1;
  }
})), kD = /* @__PURE__ */ Ce.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class Eie {
  constructor(e, t, r, i) {
    this.field = e, this.line = t, this.from = r, this.to = i;
  }
}
class i7 {
  constructor(e, t, r) {
    this.field = e, this.from = t, this.to = r;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, Bn.TrackDel), r = e.mapPos(this.to, 1, Bn.TrackDel);
    return t == null || r == null ? null : new i7(this.field, t, r);
  }
}
class s7 {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let r = [], i = [t], s = e.doc.lineAt(t), o = /^\s*/.exec(s.text)[0];
    for (let a of this.lines) {
      if (r.length) {
        let c = o, u = /^\t*/.exec(a)[0].length;
        for (let h = 0; h < u; h++)
          c += e.facet(l1);
        i.push(t + c.length - u), a = c + a.slice(u);
      }
      r.push(a), t += a.length + 1;
    }
    let l = this.fieldPositions.map((a) => new i7(a.field, i[a.line] + a.from, i[a.line] + a.to));
    return { text: r, ranges: l };
  }
  static parse(e) {
    let t = [], r = [], i = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(o); ) {
        let l = s[1] ? +s[1] : null, a = s[2] || s[3] || "", c = -1, u = a.replace(/\\[{}]/g, (h) => h[1]);
        for (let h = 0; h < t.length; h++)
          (l != null ? t[h].seq == l : u && t[h].name == u) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < t.length && (l == null || t[h].seq != null && t[h].seq < l); )
            h++;
          t.splice(h, 0, { seq: l, name: u }), c = h;
          for (let f of i)
            f.field >= c && f.field++;
        }
        for (let h of i)
          if (h.line == r.length && h.from > s.index) {
            let f = s[2] ? 3 + (s[1] || "").length : 2;
            h.from -= f, h.to -= f;
          }
        i.push(new Eie(c, r.length, s.index, s.index + u.length)), o = o.slice(0, s.index) + a + o.slice(s.index + s[0].length);
      }
      o = o.replace(/\\([{}])/g, (l, a, c) => {
        for (let u of i)
          u.line == r.length && u.from > c && (u.from--, u.to--);
        return a;
      }), r.push(o);
    }
    return new s7(r, i);
  }
}
let Iie = /* @__PURE__ */ He.widget({ widget: /* @__PURE__ */ new class extends xo {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Die = /* @__PURE__ */ He.mark({ class: "cm-snippetField" });
class mu {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = He.set(e.map((r) => (r.from == r.to ? Iie : Die).range(r.from, r.to)), !0);
  }
  map(e) {
    let t = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i)
        return null;
      t.push(i);
    }
    return new mu(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((r) => r.field == this.active && r.from <= t.from && r.to >= t.to));
  }
}
const Pd = /* @__PURE__ */ Xe.define({
  map(n, e) {
    return n && n.map(e);
  }
}), Nie = /* @__PURE__ */ Xe.define(), Zf = /* @__PURE__ */ On.define({
  create() {
    return null;
  },
  update(n, e) {
    for (let t of e.effects) {
      if (t.is(Pd))
        return t.value;
      if (t.is(Nie) && n)
        return new mu(n.ranges, t.value);
    }
    return n && e.docChanged && (n = n.map(e.changes)), n && e.selection && !n.selectionInsideField(e.selection) && (n = null), n;
  },
  provide: (n) => Ce.decorations.from(n, (e) => e ? e.deco : He.none)
});
function o7(n, e) {
  return G.create(n.filter((t) => t.field == e).map((t) => G.range(t.from, t.to)));
}
function Rie(n) {
  let e = s7.parse(n);
  return (t, r, i, s) => {
    let { text: o, ranges: l } = e.instantiate(t.state, i), { main: a } = t.state.selection, c = {
      changes: { from: i, to: s == a.from ? a.to : s, insert: ft.of(o) },
      scrollIntoView: !0,
      annotations: r ? [t7.of(r), ur.userEvent.of("input.complete")] : void 0
    };
    if (l.length && (c.selection = o7(l, 0)), l.some((u) => u.field > 0)) {
      let u = new mu(l, 0), h = c.effects = [Pd.of(u)];
      t.state.field(Zf, !1) === void 0 && h.push(Xe.appendConfig.of([Zf, zie, Fie, kD]));
    }
    t.dispatch(t.state.update(c));
  };
}
function SD(n) {
  return ({ state: e, dispatch: t }) => {
    let r = e.field(Zf, !1);
    if (!r || n < 0 && r.active == 0)
      return !1;
    let i = r.active + n, s = n > 0 && !r.ranges.some((o) => o.field == i + n);
    return t(e.update({
      selection: o7(r.ranges, i),
      effects: Pd.of(s ? null : new mu(r.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const Pie = ({ state: n, dispatch: e }) => n.field(Zf, !1) ? (e(n.update({ effects: Pd.of(null) })), !0) : !1, _ie = /* @__PURE__ */ SD(1), Lie = /* @__PURE__ */ SD(-1), Bie = [
  { key: "Tab", run: _ie, shift: Lie },
  { key: "Escape", run: Pie }
], Qk = /* @__PURE__ */ xe.define({
  combine(n) {
    return n.length ? n[0] : Bie;
  }
}), zie = /* @__PURE__ */ kl.highest(/* @__PURE__ */ nu.compute([Qk], (n) => n.facet(Qk)));
function Jue(n, e) {
  return { ...e, apply: Rie(n) };
}
const Fie = /* @__PURE__ */ Ce.domEventHandlers({
  mousedown(n, e) {
    let t = e.state.field(Zf, !1), r;
    if (!t || (r = e.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let i = t.ranges.find((s) => s.from <= r && s.to >= r);
    return !i || i.field == t.active ? !1 : (e.dispatch({
      selection: o7(t.ranges, i.field),
      effects: Pd.of(t.ranges.some((s) => s.field > i.field) ? new mu(t.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), Qf = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, sa = /* @__PURE__ */ Xe.define({
  map(n, e) {
    let t = e.mapPos(n, -1, Bn.TrackAfter);
    return t ?? void 0;
  }
}), l7 = /* @__PURE__ */ new class extends va {
}();
l7.startSide = 1;
l7.endSide = -1;
const CD = /* @__PURE__ */ On.define({
  create() {
    return ut.empty;
  },
  update(n, e) {
    if (n = n.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      n = n.update({ filter: (r) => r >= t.from && r <= t.to });
    }
    for (let t of e.effects)
      t.is(sa) && (n = n.update({ add: [l7.range(t.value, t.value + 1)] }));
    return n;
  }
});
function Hie() {
  return [Vie, CD];
}
const r4 = "()[]{}<>«»»«［］｛｝";
function MD(n) {
  for (let e = 0; e < r4.length; e += 2)
    if (r4.charCodeAt(e) == n)
      return r4.charAt(e + 1);
  return l3(n < 128 ? n : n + 1);
}
function TD(n, e) {
  return n.languageDataAt("closeBrackets", e)[0] || Qf;
}
const $ie = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Vie = /* @__PURE__ */ Ce.inputHandler.of((n, e, t, r) => {
  if (($ie ? n.composing : n.compositionStarted) || n.state.readOnly)
    return !1;
  let i = n.state.selection.main;
  if (r.length > 2 || r.length == 2 && as(kr(r, 0)) == 1 || e != i.from || t != i.to)
    return !1;
  let s = jie(n.state, r);
  return s ? (n.dispatch(s), !0) : !1;
}), qie = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let r = TD(n, n.selection.main.head).brackets || Qf.brackets, i = null, s = n.changeByRange((o) => {
    if (o.empty) {
      let l = Uie(n.doc, o.head);
      for (let a of r)
        if (a == l && og(n.doc, o.head) == MD(kr(a, 0)))
          return {
            changes: { from: o.head - a.length, to: o.head + a.length },
            range: G.cursor(o.head - a.length)
          };
    }
    return { range: i = o };
  });
  return i || e(n.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, Wie = [
  { key: "Backspace", run: qie }
];
function jie(n, e) {
  let t = TD(n, n.selection.main.head), r = t.brackets || Qf.brackets;
  for (let i of r) {
    let s = MD(kr(i, 0));
    if (e == i)
      return s == i ? Yie(n, i, r.indexOf(i + i + i) > -1, t) : Kie(n, i, s, t.before || Qf.before);
    if (e == s && AD(n, n.selection.main.from))
      return Gie(n, i, s);
  }
  return null;
}
function AD(n, e) {
  let t = !1;
  return n.field(CD).between(0, n.doc.length, (r) => {
    r == e && (t = !0);
  }), t;
}
function og(n, e) {
  let t = n.sliceString(e, e + 2);
  return t.slice(0, as(kr(t, 0)));
}
function Uie(n, e) {
  let t = n.sliceString(e - 2, e);
  return as(kr(t, 0)) == t.length ? t : t.slice(1);
}
function Kie(n, e, t, r) {
  let i = null, s = n.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: sa.of(o.to + e.length),
        range: G.range(o.anchor + e.length, o.head + e.length)
      };
    let l = og(n.doc, o.head);
    return !l || /\s/.test(l) || r.indexOf(l) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: sa.of(o.head + e.length),
      range: G.cursor(o.head + e.length)
    } : { range: i = o };
  });
  return i ? null : n.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Gie(n, e, t) {
  let r = null, i = n.changeByRange((s) => s.empty && og(n.doc, s.head) == t ? {
    changes: { from: s.head, to: s.head + t.length, insert: t },
    range: G.cursor(s.head + t.length)
  } : r = { range: s });
  return r ? null : n.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Yie(n, e, t, r) {
  let i = r.stringPrefixes || Qf.stringPrefixes, s = null, o = n.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: sa.of(l.to + e.length),
        range: G.range(l.anchor + e.length, l.head + e.length)
      };
    let a = l.head, c = og(n.doc, a), u;
    if (c == e) {
      if (e9(n, a))
        return {
          changes: { insert: e + e, from: a },
          effects: sa.of(a + e.length),
          range: G.cursor(a + e.length)
        };
      if (AD(n, a)) {
        let f = t && n.sliceDoc(a, a + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: a, to: a + f.length, insert: f },
          range: G.cursor(a + f.length)
        };
      }
    } else {
      if (t && n.sliceDoc(a - 2 * e.length, a) == e + e && (u = t9(n, a - 2 * e.length, i)) > -1 && e9(n, u))
        return {
          changes: { insert: e + e + e + e, from: a },
          effects: sa.of(a + e.length),
          range: G.cursor(a + e.length)
        };
      if (n.charCategorizer(a)(c) != Wt.Word && t9(n, a, i) > -1 && !Jie(n, a, e, i))
        return {
          changes: { insert: e + e, from: a },
          effects: sa.of(a + e.length),
          range: G.cursor(a + e.length)
        };
    }
    return { range: s = l };
  });
  return s ? null : n.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function e9(n, e) {
  let t = Fn(n).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function Jie(n, e, t, r) {
  let i = Fn(n).resolveInner(e, -1), s = r.reduce((o, l) => Math.max(o, l.length), 0);
  for (let o = 0; o < 5; o++) {
    let l = n.sliceDoc(i.from, Math.min(i.to, i.from + t.length + s)), a = l.indexOf(t);
    if (!a || a > -1 && r.indexOf(l.slice(0, a)) > -1) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > t.length + a; ) {
        if (n.sliceDoc(u.to - t.length, u.to) == t)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return !1;
}
function t9(n, e, t) {
  let r = n.charCategorizer(e);
  if (r(n.sliceDoc(e - 1, e)) != Wt.Word)
    return e;
  for (let i of t) {
    let s = e - i.length;
    if (n.sliceDoc(s, e) == i && r(n.sliceDoc(s - 1, s)) != Wt.Word)
      return s;
  }
  return -1;
}
function Xie(n = {}) {
  return [
    Oie,
    Cr,
    Mn.of(n),
    Tie,
    Zie,
    kD
  ];
}
const OD = [
  { key: "Ctrl-Space", run: n4 },
  { mac: "Alt-`", run: n4 },
  { mac: "Alt-i", run: n4 },
  { key: "Escape", run: kie },
  { key: "ArrowDown", run: /* @__PURE__ */ A0(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ A0(!1) },
  { key: "PageDown", run: /* @__PURE__ */ A0(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ A0(!1, "page") },
  { key: "Enter", run: xie }
], Zie = /* @__PURE__ */ kl.highest(/* @__PURE__ */ nu.computeN([Mn], (n) => n.facet(Mn).defaultKeymap ? [OD] : []));
class n9 {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.diagnostic = r;
  }
}
class Ql {
  constructor(e, t, r) {
    this.diagnostics = e, this.panel = t, this.selected = r;
  }
  static init(e, t, r) {
    let i = r.facet(ed).markerFilter;
    i && (e = i(e, r));
    let s = e.slice().sort((u, h) => u.from - h.from || u.to - h.to), o = new lo(), l = [], a = 0;
    for (let u = 0; ; ) {
      let h = u == s.length ? null : s[u];
      if (!h && !l.length)
        break;
      let f, d;
      for (l.length ? (f = a, d = l.reduce((m, g) => Math.min(m, g.to), h && h.from > f ? h.from : 1e8)) : (f = h.from, d = h.to, l.push(h), u++); u < s.length; ) {
        let m = s[u];
        if (m.from == f && (m.to > m.from || m.to == f))
          l.push(m), u++, d = Math.min(m.to, d);
        else {
          d = Math.min(m.from, d);
          break;
        }
      }
      let p = hse(l);
      if (l.some((m) => m.from == m.to || m.from == m.to - 1 && r.doc.lineAt(m.from).to == m.from))
        o.add(f, f, He.widget({
          widget: new lse(p),
          diagnostics: l.slice()
        }));
      else {
        let m = l.reduce((g, b) => b.markClass ? g + " " + b.markClass : g, "");
        o.add(f, d, He.mark({
          class: "cm-lintRange cm-lintRange-" + p + m,
          diagnostics: l.slice(),
          inclusiveEnd: l.some((g) => g.to > d)
        }));
      }
      a = d;
      for (let m = 0; m < l.length; m++)
        l[m].to <= a && l.splice(m--, 1);
    }
    let c = o.finish();
    return new Ql(c, t, Gc(c));
  }
}
function Gc(n, e = null, t = 0) {
  let r = null;
  return n.between(t, 1e9, (i, s, { spec: o }) => {
    if (!(e && o.diagnostics.indexOf(e) < 0))
      if (!r)
        r = new n9(i, s, e || o.diagnostics[0]);
      else {
        if (o.diagnostics.indexOf(r.diagnostic) < 0)
          return !1;
        r = new n9(r.from, s, r.diagnostic);
      }
  }), r;
}
function Qie(n, e) {
  let t = e.pos, r = e.end || t, i = n.state.facet(ed).hideOn(n, t, r);
  if (i != null)
    return i;
  let s = n.startState.doc.lineAt(e.pos);
  return !!(n.effects.some((o) => o.is(ED)) || n.changes.touchesRange(s.from, Math.max(s.to, r)));
}
function ese(n, e) {
  return n.field(Yr, !1) ? e : e.concat(Xe.appendConfig.of(fse));
}
const ED = /* @__PURE__ */ Xe.define(), a7 = /* @__PURE__ */ Xe.define(), ID = /* @__PURE__ */ Xe.define(), Yr = /* @__PURE__ */ On.define({
  create() {
    return new Ql(He.none, null, null);
  },
  update(n, e) {
    if (e.docChanged && n.diagnostics.size) {
      let t = n.diagnostics.map(e.changes), r = null, i = n.panel;
      if (n.selected) {
        let s = e.changes.mapPos(n.selected.from, 1);
        r = Gc(t, n.selected.diagnostic, s) || Gc(t, null, s);
      }
      !t.size && i && e.state.facet(ed).autoPanel && (i = null), n = new Ql(t, i, r);
    }
    for (let t of e.effects)
      if (t.is(ED)) {
        let r = e.state.facet(ed).autoPanel ? t.value.length ? td.open : null : n.panel;
        n = Ql.init(t.value, r, e.state);
      } else t.is(a7) ? n = new Ql(n.diagnostics, t.value ? td.open : null, n.selected) : t.is(ID) && (n = new Ql(n.diagnostics, n.panel, t.value));
    return n;
  },
  provide: (n) => [
    Ef.from(n, (e) => e.panel),
    Ce.decorations.from(n, (e) => e.diagnostics)
  ]
}), tse = /* @__PURE__ */ He.mark({ class: "cm-lintRange cm-lintRange-active" });
function nse(n, e, t) {
  let { diagnostics: r } = n.state.field(Yr), i, s = -1, o = -1;
  r.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (a, c, { spec: u }) => {
    if (e >= a && e <= c && (a == c || (e > a || t > 0) && (e < c || t < 0)))
      return i = u.diagnostics, s = a, o = c, !1;
  });
  let l = n.state.facet(ed).tooltipFilter;
  return i && l && (i = l(i, n.state)), i ? {
    pos: s,
    end: o,
    above: n.state.doc.lineAt(s).to < o,
    create() {
      return { dom: rse(n, i) };
    }
  } : null;
}
function rse(n, e) {
  return At("ul", { class: "cm-tooltip-lint" }, e.map((t) => ND(n, t, !1)));
}
const ise = (n) => {
  let e = n.state.field(Yr, !1);
  (!e || !e.panel) && n.dispatch({ effects: ese(n.state, [a7.of(!0)]) });
  let t = Of(n, td.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, r9 = (n) => {
  let e = n.state.field(Yr, !1);
  return !e || !e.panel ? !1 : (n.dispatch({ effects: a7.of(!1) }), !0);
}, sse = (n) => {
  let e = n.state.field(Yr, !1);
  if (!e)
    return !1;
  let t = n.state.selection.main, r = e.diagnostics.iter(t.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == t.from && r.to == t.to) ? !1 : (n.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, ose = [
  { key: "Mod-Shift-m", run: ise, preventDefault: !0 },
  { key: "F8", run: sse }
], ed = /* @__PURE__ */ xe.define({
  combine(n) {
    return Object.assign({ sources: n.map((e) => e.source).filter((e) => e != null) }, Ts(n.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, t) => e ? t ? (r) => e(r) || t(r) : e : t
    }));
  }
});
function DD(n) {
  let e = [];
  if (n)
    e: for (let { name: t } of n) {
      for (let r = 0; r < t.length; r++) {
        let i = t[r];
        if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function ND(n, e, t) {
  var r;
  let i = t ? DD(e.actions) : [];
  return At("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, At("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(n) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((s, o) => {
    let l = !1, a = (f) => {
      if (f.preventDefault(), l)
        return;
      l = !0;
      let d = Gc(n.state.field(Yr).diagnostics, e);
      d && s.apply(n, d.from, d.to);
    }, { name: c } = s, u = i[o] ? c.indexOf(i[o]) : -1, h = u < 0 ? c : [
      c.slice(0, u),
      At("u", c.slice(u, u + 1)),
      c.slice(u + 1)
    ];
    return At("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: a,
      onmousedown: a,
      "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[o]})"`}.`
    }, h);
  }), e.source && At("div", { class: "cm-diagnosticSource" }, e.source));
}
class lse extends xo {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return At("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class i9 {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = ND(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class td {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (i) => {
      if (i.keyCode == 27)
        r9(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = DD(s.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == i.keyCode) {
            let a = Gc(this.view.state.field(Yr).diagnostics, s);
            a && s.actions[l].apply(e, a.from, a.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = At("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: r
    }), this.dom = At("div", { class: "cm-panel-lint" }, this.list, At("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => r9(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Yr).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Yr), r = 0, i = !1, s = null, o = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (l, a, { spec: c }) => {
      for (let u of c.diagnostics) {
        if (o.has(u))
          continue;
        o.add(u);
        let h = -1, f;
        for (let d = r; d < this.items.length; d++)
          if (this.items[d].diagnostic == u) {
            h = d;
            break;
          }
        h < 0 ? (f = new i9(this.view, u), this.items.splice(r, 0, f), i = !0) : (f = this.items[h], h > r && (this.items.splice(r, h - r), i = !0)), t && f.diagnostic == t.diagnostic ? f.dom.hasAttribute("aria-selected") || (f.dom.setAttribute("aria-selected", "true"), s = f) : f.dom.hasAttribute("aria-selected") && f.dom.removeAttribute("aria-selected"), r++;
      }
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new i9(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: l, panel: a }) => {
        let c = a.height / this.list.offsetHeight;
        l.top < a.top ? this.list.scrollTop -= (a.top - l.top) / c : l.bottom > a.bottom && (this.list.scrollTop += (l.bottom - a.bottom) / c);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          t();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Yr), r = Gc(t.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: ID.of(r)
    });
  }
  static open(e) {
    return new td(e);
  }
}
function ase(n, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(n)}</svg>')`;
}
function O0(n) {
  return ase(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const cse = /* @__PURE__ */ Ce.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ O0("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ O0("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ O0("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ O0("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function use(n) {
  return n == "error" ? 4 : n == "warning" ? 3 : n == "info" ? 2 : 1;
}
function hse(n) {
  let e = "hint", t = 1;
  for (let r of n) {
    let i = use(r.severity);
    i > t && (t = i, e = r.severity);
  }
  return e;
}
const fse = [
  Yr,
  /* @__PURE__ */ Ce.decorations.compute([Yr], (n) => {
    let { selected: e, panel: t } = n.field(Yr);
    return !e || !t || e.from == e.to ? He.none : He.set([
      tse.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ pF(nse, { hideOn: Qie }),
  cse
], dse = [
  MF(),
  OF(),
  jz(),
  ine(),
  uH(),
  tM(),
  Fz(),
  jt.allowMultipleSelections.of(!0),
  JF(),
  CM(pH, { fallback: !0 }),
  xH(),
  Hie(),
  Xie(),
  rF(),
  oF(),
  Xz(),
  Pre(),
  nu.of([
    ...Wie,
    ...iD,
    ...Qre,
    ...dne,
    ...oH,
    ...OD,
    ...ose
  ])
];
function pse(n = {}) {
  return new Ut({
    view(e) {
      return new mse(e, n);
    }
  });
}
class mse {
  constructor(e, t) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = t.width) !== null && r !== void 0 ? r : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let s = (o) => {
        this[i](o);
      };
      return e.dom.addEventListener(i, s), { name: i, handler: s };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
  }
  update(e, t) {
    this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, r, i = this.editorView.dom, s = i.getBoundingClientRect(), o = s.width / i.offsetWidth, l = s.height / i.offsetHeight;
    if (t) {
      let h = e.nodeBefore, f = e.nodeAfter;
      if (h || f) {
        let d = this.editorView.nodeDOM(this.cursorPos - (h ? h.nodeSize : 0));
        if (d) {
          let p = d.getBoundingClientRect(), m = h ? p.bottom : p.top;
          h && f && (m = (m + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let g = this.width / 2 * l;
          r = { left: p.left, right: p.right, top: m - g, bottom: m + g };
        }
      }
    }
    if (!r) {
      let h = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * o;
      r = { left: h.left - f, right: h.left + f, top: h.top, bottom: h.bottom };
    }
    let a = this.editorView.dom.offsetParent;
    this.element || (this.element = a.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
    let c, u;
    if (!a || a == document.body && getComputedStyle(a).position == "static")
      c = -pageXOffset, u = -pageYOffset;
    else {
      let h = a.getBoundingClientRect(), f = h.width / a.offsetWidth, d = h.height / a.offsetHeight;
      c = h.left - a.scrollLeft * f, u = h.top - a.scrollTop * d;
    }
    this.element.style.left = (r.left - c) / o + "px", this.element.style.top = (r.top - u) / l + "px", this.element.style.width = (r.right - r.left) / o + "px", this.element.style.height = (r.bottom - r.top) / l + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i = r && r.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, t, e) : i;
    if (t && !s) {
      let o = t.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let l = oT(this.editorView.state.doc, o, this.editorView.dragging.slice);
        l != null && (o = l);
      }
      this.setCursor(o), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
  }
}
class rn extends Ge {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    return rn.valid(r) ? new rn(r) : Ge.near(r);
  }
  content() {
    return be.empty;
  }
  eq(e) {
    return e instanceof rn && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new rn(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new c7(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !gse(e) || !yse(e))
      return !1;
    let r = t.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = t.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, r = !1) {
    e: for (; ; ) {
      if (!r && rn.valid(e))
        return e;
      let i = e.pos, s = null;
      for (let o = e.depth; ; o--) {
        let l = e.node(o);
        if (t > 0 ? e.indexAfter(o) < l.childCount : e.index(o) > 0) {
          s = l.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1);
          break;
        } else if (o == 0)
          return null;
        i += t;
        let a = e.doc.resolve(i);
        if (rn.valid(a))
          return a;
      }
      for (; ; ) {
        let o = t > 0 ? s.firstChild : s.lastChild;
        if (!o) {
          if (s.isAtom && !s.isText && !$e.isSelectable(s)) {
            e = e.doc.resolve(i + s.nodeSize * t), r = !1;
            continue e;
          }
          break;
        }
        s = o, i += t;
        let l = e.doc.resolve(i);
        if (rn.valid(l))
          return l;
      }
      return null;
    }
  }
}
rn.prototype.visible = !1;
rn.findFrom = rn.findGapCursorFrom;
Ge.jsonID("gapcursor", rn);
class c7 {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new c7(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return rn.valid(t) ? new rn(t) : Ge.near(t);
  }
}
function gse(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), r = n.node(e);
    if (t == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function yse(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), r = n.node(e);
    if (t == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function bse() {
  return new Ut({
    props: {
      decorations: kse,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && rn.valid(t) ? new rn(t) : null;
      },
      handleClick: wse,
      handleKeyDown: vse,
      handleDOMEvents: { beforeinput: xse }
    }
  });
}
const vse = G3({
  ArrowLeft: E0("horiz", -1),
  ArrowRight: E0("horiz", 1),
  ArrowUp: E0("vert", -1),
  ArrowDown: E0("vert", 1)
});
function E0(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, s) {
    let o = r.selection, l = e > 0 ? o.$to : o.$from, a = o.empty;
    if (o instanceof Ee) {
      if (!s.endOfTextblock(t) || l.depth == 0)
        return !1;
      a = !1, l = r.doc.resolve(e > 0 ? l.after() : l.before());
    }
    let c = rn.findGapCursorFrom(l, e, a);
    return c ? (i && i(r.tr.setSelection(new rn(c))), !0) : !1;
  };
}
function wse(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let r = n.state.doc.resolve(e);
  if (!rn.valid(r))
    return !1;
  let i = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return i && i.inside > -1 && $e.isSelectable(n.state.doc.nodeAt(i.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new rn(r))), !0);
}
function xse(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof rn))
    return !1;
  let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = ce.empty;
  for (let o = r.length - 1; o >= 0; o--)
    i = ce.from(r[o].createAndFill(null, i));
  let s = n.state.tr.replace(t.pos, t.pos, new be(i, 0, 0));
  return s.setSelection(Ee.near(s.doc.resolve(t.pos + 1))), n.dispatch(s), !1;
}
function kse(n) {
  if (!(n.selection instanceof rn))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Et.create(n.doc, [mn.widget(n.selection.head, e, { key: "gapcursor" })]);
}
function u7(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-cursor",
      ...e
    }
  }), n;
}
const lg = Ct(
  {},
  "dropCursorConfig"
);
u7(lg, {
  displayName: "Ctx<dropCursor>"
});
const RD = kn(
  (n) => pse(n.get(lg.key))
);
u7(RD, {
  displayName: "Prose<dropCursor>"
});
const PD = kn(() => bse());
u7(PD, {
  displayName: "Prose<gapCursor>"
});
const Sse = [
  lg,
  RD,
  PD
];
function Cse(n) {
  var e;
  const t = (e = void 0) != null ? e : !1;
  let r = typeof document > "u" ? null : document.createElement("div");
  return new Ut({
    key: Mse,
    view: (i) => {
      t !== !0 && Ese(i.state.schema, t || []);
      const s = i.dom.ownerDocument;
      r = r || document.createElement("div");
      const o = r, l = () => {
        Ase(i, o);
      };
      let a;
      return window.ResizeObserver && (a = new window.ResizeObserver(() => l()), a.observe(i.dom)), s.addEventListener("selectionchange", l), {
        update: () => {
          l();
        },
        destroy: () => {
          s.removeEventListener("selectionchange", l), a && a.unobserve(i.dom);
        }
      };
    },
    props: {
      handleKeyDown: (i, s) => {
        var o;
        const { selection: l } = i.state;
        if (s.altKey || s.ctrlKey || s.metaKey || s.shiftKey || s.isComposing || !["ArrowLeft", "ArrowRight"].includes(s.key) || !D5(l) || !l.empty)
          return !1;
        const a = l.$head, [c, u] = _D(a), h = i.state.storedMarks || a.marks();
        if (c && u && !nt.sameSet(c, u)) {
          if (s.key === "ArrowLeft" && !nt.sameSet(c, h))
            return i.dispatch(i.state.tr.setStoredMarks(c)), !0;
          if (s.key === "ArrowRight" && !nt.sameSet(u, h))
            return i.dispatch(i.state.tr.setStoredMarks(u)), !0;
        }
        return s.key === "ArrowLeft" && a.textOffset === 1 ? (i.dispatch(
          i.state.tr.setSelection(Ee.create(i.state.doc, a.pos - 1)).setStoredMarks(a.marks())
        ), !0) : s.key === "ArrowRight" && a.textOffset + 1 === ((o = a.parent.maybeChild(a.index())) == null ? void 0 : o.nodeSize) ? (i.dispatch(
          i.state.tr.setSelection(Ee.create(i.state.doc, a.pos + 1)).setStoredMarks(a.marks())
        ), !0) : !1;
      },
      decorations: (i) => {
        if (!(!r || !D5(i.selection) || !i.selection.empty))
          return Et.create(i.doc, [
            mn.widget(0, r, {
              key: "prosemirror-virtual-cursor"
            })
          ]);
      },
      attributes: {
        class: "virtual-cursor-enabled"
      }
    }
  });
}
var Mse = new en("prosemirror-virtual-cursor");
function Tse(n, e) {
  var t;
  const r = window.getSelection();
  if (!r || !r.rangeCount)
    return null;
  const i = (t = r?.getRangeAt(0)) == null ? void 0 : t.cloneRange();
  if (!i)
    return null;
  i.collapse(e);
  const s = i.getClientRects(), o = s?.length ? s[s.length - 1] : null;
  return o?.height ? o : n.coordsAtPos(n.state.selection.head);
}
function _D(n) {
  const e = n.index(), t = n.parent.maybeChild(e);
  let r = n.textOffset ? t : null;
  return !r && e > 0 && (r = n.parent.maybeChild(e - 1)), [r?.marks, t?.marks];
}
function D5(n) {
  return n && typeof n == "object" && "$cursor" in n;
}
function Ase(n, e) {
  if (!n || !n.dom || n.isDestroyed || !e)
    return;
  const { state: t, dom: r } = n, { selection: i } = t;
  if (!D5(i))
    return;
  const s = Tse(n, i.$head === i.$from);
  if (!s)
    return e;
  const o = r.getBoundingClientRect();
  let l = "prosemirror-virtual-cursor";
  const a = t.selection.$head, [c, u] = _D(a), h = t.storedMarks || a.marks();
  i.$cursor && c && u && h && !nt.sameSet(c, u) && (nt.sameSet(c, h) ? l += " prosemirror-virtual-cursor-left" : nt.sameSet(u, h) && (l += " prosemirror-virtual-cursor-right")), e.className = l, Ose(e, "prosemirror-virtual-cursor-animation"), e.style.height = `${s.bottom - s.top}px`, e.style.left = `${s.left - o.left}px`, e.style.top = `${s.top - o.top}px`;
}
function Ose(n, e) {
  n.classList.remove(e), n.offsetWidth, n.classList.add(e);
}
function Ese(n, e) {
  for (const [t, r] of Object.entries(n.marks))
    r.spec.inclusive === !1 && !e.includes(t) && console.warn(
      `[prosemirror-virtual-cursor] Virtual cursor does not work well with marks that have inclusive set to false. Please consider removing the inclusive option from the "${t}" mark or adding it to the "skipWarning" option.`
    );
}
var Ise = Object.defineProperty, s9 = Object.getOwnPropertySymbols, Dse = Object.prototype.hasOwnProperty, Nse = Object.prototype.propertyIsEnumerable, o9 = (n, e, t) => e in n ? Ise(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Rse = (n, e) => {
  for (var t in e || (e = {}))
    Dse.call(e, t) && o9(n, t, e[t]);
  if (s9)
    for (var t of s9(e))
      Nse.call(e, t) && o9(n, t, e[t]);
  return n;
};
function LD(n, e) {
  return Object.assign(n, {
    meta: Rse({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const Pse = {
  imageIcon: "🌌",
  uploadButton: "Upload",
  confirmButton: "⏎",
  uploadPlaceholderText: "/Paste",
  onUpload: (n) => Promise.resolve(URL.createObjectURL(n))
}, ag = Ct(
  Pse,
  "inlineImageConfigCtx"
);
LD(ag, {
  displayName: "Config<image-inline>",
  group: "ImageInline"
});
function Ep({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ki.sanitize(n.trim()));
      }
    }
  );
}
Ep.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const _se = jE("abcdefg", 8), Lse = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setLink: {
      type: Function,
      required: !0
    },
    imageIcon: {
      type: String,
      required: !1
    },
    uploadButton: {
      type: String,
      required: !1
    },
    confirmButton: {
      type: String,
      required: !1
    },
    uploadPlaceholderText: {
      type: String,
      required: !1
    },
    onUpload: {
      type: Function,
      required: !0
    }
  },
  setup({
    readonly: n,
    src: e,
    setLink: t,
    onUpload: r,
    imageIcon: i,
    uploadButton: s,
    confirmButton: o,
    uploadPlaceholderText: l,
    className: a
  }) {
    var c, u;
    const h = Ae(!1), f = Ae(), d = Ae((c = e.value) != null ? c : ""), p = Ae(_se()), m = Ae(((u = e.value) == null ? void 0 : u.length) !== 0), g = (C) => {
      const T = C.target.value;
      m.value = T.length !== 0, d.value = T;
    }, b = (C) => {
      var M, T;
      C.key === "Enter" && t((T = (M = f.value) == null ? void 0 : M.value) != null ? T : "");
    }, w = () => {
      var C, M;
      t((M = (C = f.value) == null ? void 0 : C.value) != null ? M : "");
    }, k = (C) => {
      var M;
      const T = (M = C.target.files) == null ? void 0 : M[0];
      T && r(T).then((N) => {
        N && (t(N), m.value = !0);
      }).catch((N) => {
        console.error("An error occurred while uploading image"), console.error(N);
      });
    };
    return () => /* @__PURE__ */ j("div", { class: Hn("image-edit", a) }, /* @__PURE__ */ j(Ep, { icon: i, class: "image-icon" }), /* @__PURE__ */ j("div", { class: Hn("link-importer", h.value && "focus") }, /* @__PURE__ */ j(
      "input",
      {
        ref: f,
        draggable: "true",
        onDragstart: (C) => {
          C.preventDefault(), C.stopPropagation();
        },
        disabled: n.value,
        class: "link-input-area",
        value: d.value,
        onInput: g,
        onKeydown: b,
        onFocus: () => h.value = !0,
        onBlur: () => h.value = !1
      }
    ), !m.value && /* @__PURE__ */ j("div", { class: "placeholder" }, /* @__PURE__ */ j(
      "input",
      {
        disabled: n.value,
        class: "hidden",
        id: p.value,
        type: "file",
        accept: "image/*",
        onChange: k
      }
    ), /* @__PURE__ */ j("label", { class: "uploader", for: p.value }, /* @__PURE__ */ j(Ep, { icon: s })), /* @__PURE__ */ j("span", { class: "text", onClick: () => {
      var C;
      return (C = f.value) == null ? void 0 : C.focus();
    } }, l))), d.value && /* @__PURE__ */ j("div", { class: "confirm", onClick: () => w() }, /* @__PURE__ */ j(Ep, { icon: o })));
  }
}), Bse = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    alt: {
      type: Object,
      required: !0
    },
    title: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { src: e, alt: t, title: r } = n;
    return () => {
      var i;
      return (i = e.value) != null && i.length ? /* @__PURE__ */ j(
        "img",
        {
          class: "image-inline",
          src: e.value,
          alt: t.value,
          title: r.value
        }
      ) : /* @__PURE__ */ j(
        Lse,
        {
          src: n.src,
          selected: n.selected,
          readonly: n.readonly,
          setLink: (s) => n.setAttr("src", s),
          imageIcon: n.config.imageIcon,
          uploadButton: n.config.uploadButton,
          confirmButton: n.config.confirmButton,
          uploadPlaceholderText: n.config.uploadPlaceholderText,
          onUpload: n.config.onUpload,
          className: "empty-image-inline"
        }
      );
    };
  }
}), BD = yd(
  Ba.node,
  (n) => (e, t, r) => {
    const i = Ae(e.attrs.src), s = Ae(e.attrs.alt), o = Ae(e.attrs.title), l = Ae(!1), a = Ae(!t.editable), c = (g, b) => {
      if (!t.editable) return;
      const w = r();
      w != null && t.dispatch(
        t.state.tr.setNodeAttribute(
          w,
          g,
          g === "src" ? Ki.sanitize(b) : b
        )
      );
    }, u = n.get(ag.key), h = Ui(Bse, {
      src: i,
      alt: s,
      title: o,
      selected: l,
      readonly: a,
      setAttr: c,
      config: u
    }), f = document.createElement("span");
    f.className = "milkdown-image-inline", h.mount(f);
    const d = uu(() => {
      l.value ? f.classList.add("selected") : f.classList.remove("selected");
    }), p = u.proxyDomURL, m = (g) => {
      if (!p)
        i.value = g.attrs.src;
      else {
        const b = p(g.attrs.src);
        typeof b == "string" ? i.value = b : b.then((w) => {
          i.value = w;
        }).catch(console.error);
      }
      s.value = g.attrs.alt, o.value = g.attrs.title;
    };
    return m(e), {
      dom: f,
      update: (g) => g.type !== e.type ? !1 : (m(g), !0),
      stopEvent: (g) => g.target instanceof HTMLInputElement,
      selectNode: () => {
        l.value = !0;
      },
      deselectNode: () => {
        l.value = !1;
      },
      destroy: () => {
        d(), h.unmount(), f.remove();
      }
    };
  }
);
LD(BD, {
  displayName: "NodeView<image-inline>",
  group: "ImageInline"
});
const zse = [
  ag,
  BD
];
class Wr {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(e, t, r) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = t, this.end = r;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, t) {
    return t ? !e || !e.loc || !t.loc || e.loc.lexer !== t.loc.lexer ? null : new Wr(e.loc.lexer, e.loc.start, t.loc.end) : e && e.loc;
  }
}
class bi {
  // don't expand the token
  // used in \noexpand
  constructor(e, t) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = t;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, t) {
    return new bi(t, Wr.range(this, e));
  }
}
class se {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(e, t) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var r = "KaTeX parse error: " + e, i, s, o = t && t.loc;
    if (o && o.start <= o.end) {
      var l = o.lexer.input;
      i = o.start, s = o.end, i === l.length ? r += " at end of input: " : r += " at position " + (i + 1) + ": ";
      var a = l.slice(i, s).replace(/[^]/g, "$&̲"), c;
      i > 15 ? c = "…" + l.slice(i - 15, i) : c = l.slice(0, i);
      var u;
      s + 15 < l.length ? u = l.slice(s, s + 15) + "…" : u = l.slice(s), r += c + a + u;
    }
    var h = new Error(r);
    return h.name = "ParseError", h.__proto__ = se.prototype, h.position = i, i != null && s != null && (h.length = s - i), h.rawMessage = e, h;
  }
}
se.prototype.__proto__ = Error.prototype;
var Fse = function(e, t) {
  return e.indexOf(t) !== -1;
}, Hse = function(e, t) {
  return e === void 0 ? t : e;
}, $se = /([A-Z])/g, Vse = function(e) {
  return e.replace($se, "-$1").toLowerCase();
}, qse = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, Wse = /[&><"']/g;
function jse(n) {
  return String(n).replace(Wse, (e) => qse[e]);
}
var zD = function n(e) {
  return e.type === "ordgroup" || e.type === "color" ? e.body.length === 1 ? n(e.body[0]) : e : e.type === "font" ? n(e.body) : e;
}, Use = function(e) {
  var t = zD(e);
  return t.type === "mathord" || t.type === "textord" || t.type === "atom";
}, Kse = function(e) {
  if (!e)
    throw new Error("Expected non-null, but got " + String(e));
  return e;
}, Gse = function(e) {
  var t = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
  return t ? t[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(t[1]) ? null : t[1].toLowerCase() : "_relative";
}, Be = {
  contains: Fse,
  deflt: Hse,
  escape: jse,
  hyphenate: Vse,
  getBaseElem: zD,
  isCharacterBox: Use,
  protocolFromUrl: Gse
}, Ip = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (n) => "#" + n
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (n, e) => (e.push(n), e)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (n) => Math.max(0, n),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (n) => Math.max(0, n),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n) => Math.max(0, n),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n) => n === "Infinity" ? 1 / 0 : parseInt(n)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function Yse(n) {
  if (n.default)
    return n.default;
  var e = n.type, t = Array.isArray(e) ? e[0] : e;
  if (typeof t != "string")
    return t.enum[0];
  switch (t) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class h7 {
  constructor(e) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, e = e || {};
    for (var t in Ip)
      if (Ip.hasOwnProperty(t)) {
        var r = Ip[t];
        this[t] = e[t] !== void 0 ? r.processor ? r.processor(e[t]) : e[t] : Yse(r);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(e, t, r) {
    var i = this.strict;
    if (typeof i == "function" && (i = i(e, t, r)), !(!i || i === "ignore")) {
      if (i === !0 || i === "error")
        throw new se("LaTeX-incompatible input and strict mode is set to 'error': " + (t + " [" + e + "]"), r);
      i === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(e, t, r) {
    var i = this.strict;
    if (typeof i == "function")
      try {
        i = i(e, t, r);
      } catch {
        i = "error";
      }
    return !i || i === "ignore" ? !1 : i === !0 || i === "error" ? !0 : i === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(e) {
    if (e.url && !e.protocol) {
      var t = Be.protocolFromUrl(e.url);
      if (t == null)
        return !1;
      e.protocol = t;
    }
    var r = typeof this.trust == "function" ? this.trust(e) : this.trust;
    return !!r;
  }
}
class Do {
  constructor(e, t, r) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = t, this.cramped = r;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return ls[Jse[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return ls[Xse[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return ls[Zse[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return ls[Qse[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return ls[eoe[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return ls[toe[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var f7 = 0, jm = 1, Dc = 2, so = 3, nd = 4, fi = 5, Yc = 6, cr = 7, ls = [new Do(f7, 0, !1), new Do(jm, 0, !0), new Do(Dc, 1, !1), new Do(so, 1, !0), new Do(nd, 2, !1), new Do(fi, 2, !0), new Do(Yc, 3, !1), new Do(cr, 3, !0)], Jse = [nd, fi, nd, fi, Yc, cr, Yc, cr], Xse = [fi, fi, fi, fi, cr, cr, cr, cr], Zse = [Dc, so, nd, fi, Yc, cr, Yc, cr], Qse = [so, so, fi, fi, cr, cr, cr, cr], eoe = [jm, jm, so, so, fi, fi, cr, cr], toe = [f7, jm, Dc, so, Dc, so, Dc, so], We = {
  DISPLAY: ls[f7],
  TEXT: ls[Dc],
  SCRIPT: ls[nd],
  SCRIPTSCRIPT: ls[Yc]
}, N5 = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function noe(n) {
  for (var e = 0; e < N5.length; e++)
    for (var t = N5[e], r = 0; r < t.blocks.length; r++) {
      var i = t.blocks[r];
      if (n >= i[0] && n <= i[1])
        return t.name;
    }
  return null;
}
var Dp = [];
N5.forEach((n) => n.blocks.forEach((e) => Dp.push(...e)));
function FD(n) {
  for (var e = 0; e < Dp.length; e += 2)
    if (n >= Dp[e] && n <= Dp[e + 1])
      return !0;
  return !1;
}
var Za = 80, roe = function(e, t) {
  return "M95," + (622 + e + t) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, ioe = function(e, t) {
  return "M263," + (601 + e + t) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, soe = function(e, t) {
  return "M983 " + (10 + e + t) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, ooe = function(e, t) {
  return "M424," + (2398 + e + t) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + t + `
h400000v` + (40 + e) + "h-400000z";
}, loe = function(e, t) {
  return "M473," + (2713 + e + t) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "H1017.7z";
}, aoe = function(e) {
  var t = e / 2;
  return "M400000 " + e + " H0 L" + t + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, coe = function(e, t, r) {
  var i = r - 54 - t - e;
  return "M702 " + (e + t) + "H400000" + (40 + e) + `
H742v` + i + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + t + "H400000v" + (40 + e) + "H742z";
}, uoe = function(e, t, r) {
  t = 1e3 * t;
  var i = "";
  switch (e) {
    case "sqrtMain":
      i = roe(t, Za);
      break;
    case "sqrtSize1":
      i = ioe(t, Za);
      break;
    case "sqrtSize2":
      i = soe(t, Za);
      break;
    case "sqrtSize3":
      i = ooe(t, Za);
      break;
    case "sqrtSize4":
      i = loe(t, Za);
      break;
    case "sqrtTall":
      i = coe(t, Za, r);
  }
  return i;
}, hoe = function(e, t) {
  switch (e) {
    case "⎜":
      return "M291 0 H417 V" + t + " H291z M291 0 H417 V" + t + " H291z";
    case "∣":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z";
    case "∥":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z" + ("M367 0 H410 V" + t + " H367z M367 0 H410 V" + t + " H367z");
    case "⎟":
      return "M457 0 H583 V" + t + " H457z M457 0 H583 V" + t + " H457z";
    case "⎢":
      return "M319 0 H403 V" + t + " H319z M319 0 H403 V" + t + " H319z";
    case "⎥":
      return "M263 0 H347 V" + t + " H263z M263 0 H347 V" + t + " H263z";
    case "⎪":
      return "M384 0 H504 V" + t + " H384z M384 0 H504 V" + t + " H384z";
    case "⏐":
      return "M312 0 H355 V" + t + " H312z M312 0 H355 V" + t + " H312z";
    case "‖":
      return "M257 0 H300 V" + t + " H257z M257 0 H300 V" + t + " H257z" + ("M478 0 H521 V" + t + " H478z M478 0 H521 V" + t + " H478z");
    default:
      return "";
  }
}, l9 = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, foe = function(e, t) {
  switch (e) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + t + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + t + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + ` v585 h43z
M367 15 v585 v` + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + t + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v602 h84z
M403 1759 V0 H319 V1759 v` + t + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + t + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (t + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (t + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (t + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (t + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class _d {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(e) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var e = document.createDocumentFragment(), t = 0; t < this.children.length; t++)
      e.appendChild(this.children[t].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var e = "", t = 0; t < this.children.length; t++)
      e += this.children[t].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var e = (t) => t.toText();
    return this.children.map(e).join("");
  }
}
var ms = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, I0 = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, a9 = {
  // Latin-1
  Å: "A",
  Ð: "D",
  Þ: "o",
  å: "a",
  ð: "d",
  þ: "o",
  // Cyrillic
  А: "A",
  Б: "B",
  В: "B",
  Г: "F",
  Д: "A",
  Е: "E",
  Ж: "K",
  З: "3",
  И: "N",
  Й: "N",
  К: "K",
  Л: "N",
  М: "M",
  Н: "H",
  О: "O",
  П: "N",
  Р: "P",
  С: "C",
  Т: "T",
  У: "y",
  Ф: "O",
  Х: "X",
  Ц: "U",
  Ч: "h",
  Ш: "W",
  Щ: "W",
  Ъ: "B",
  Ы: "X",
  Ь: "B",
  Э: "3",
  Ю: "X",
  Я: "R",
  а: "a",
  б: "b",
  в: "a",
  г: "r",
  д: "y",
  е: "e",
  ж: "m",
  з: "e",
  и: "n",
  й: "n",
  к: "n",
  л: "n",
  м: "m",
  н: "n",
  о: "o",
  п: "n",
  р: "p",
  с: "c",
  т: "o",
  у: "y",
  ф: "b",
  х: "x",
  ц: "n",
  ч: "n",
  ш: "w",
  щ: "w",
  ъ: "a",
  ы: "m",
  ь: "a",
  э: "e",
  ю: "m",
  я: "r"
};
function doe(n, e) {
  ms[n] = e;
}
function d7(n, e, t) {
  if (!ms[e])
    throw new Error("Font metrics not found for font: " + e + ".");
  var r = n.charCodeAt(0), i = ms[e][r];
  if (!i && n[0] in a9 && (r = a9[n[0]].charCodeAt(0), i = ms[e][r]), !i && t === "text" && FD(r) && (i = ms[e][77]), i)
    return {
      depth: i[0],
      height: i[1],
      italic: i[2],
      skew: i[3],
      width: i[4]
    };
}
var i4 = {};
function poe(n) {
  var e;
  if (n >= 5 ? e = 0 : n >= 3 ? e = 1 : e = 2, !i4[e]) {
    var t = i4[e] = {
      cssEmPerMu: I0.quad[e] / 18
    };
    for (var r in I0)
      I0.hasOwnProperty(r) && (t[r] = I0[r][e]);
  }
  return i4[e];
}
var moe = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], c9 = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], u9 = function(e, t) {
  return t.size < 2 ? e : moe[e - 1][t.size - 1];
};
class Ys {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(e) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = e.style, this.color = e.color, this.size = e.size || Ys.BASESIZE, this.textSize = e.textSize || this.size, this.phantom = !!e.phantom, this.font = e.font || "", this.fontFamily = e.fontFamily || "", this.fontWeight = e.fontWeight || "", this.fontShape = e.fontShape || "", this.sizeMultiplier = c9[this.size - 1], this.maxSize = e.maxSize, this.minRuleThickness = e.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(e) {
    var t = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var r in e)
      e.hasOwnProperty(r) && (t[r] = e[r]);
    return new Ys(t);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(e) {
    return this.style === e ? this : this.extend({
      style: e,
      size: u9(this.textSize, e)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(e) {
    return this.size === e && this.textSize === e ? this : this.extend({
      style: this.style.text(),
      size: e,
      textSize: e,
      sizeMultiplier: c9[e - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(e) {
    e = e || this.style.text();
    var t = u9(Ys.BASESIZE, e);
    return this.size === t && this.textSize === Ys.BASESIZE && this.style === e ? this : this.extend({
      style: e,
      size: t
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var e;
    switch (this.style.id) {
      case 4:
      case 5:
        e = 3;
        break;
      case 6:
      case 7:
        e = 1;
        break;
      default:
        e = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: e
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(e) {
    return this.extend({
      color: e
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(e) {
    return this.extend({
      font: e
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(e) {
    return this.extend({
      fontFamily: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(e) {
    return this.extend({
      fontWeight: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(e) {
    return this.extend({
      fontShape: e,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(e) {
    return e.size !== this.size ? ["sizing", "reset-size" + e.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Ys.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Ys.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = poe(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Ys.BASESIZE = 6;
var R5 = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, goe = {
  ex: !0,
  em: !0,
  mu: !0
}, HD = function(e) {
  return typeof e != "string" && (e = e.unit), e in R5 || e in goe || e === "ex";
}, Qt = function(e, t) {
  var r;
  if (e.unit in R5)
    r = R5[e.unit] / t.fontMetrics().ptPerEm / t.sizeMultiplier;
  else if (e.unit === "mu")
    r = t.fontMetrics().cssEmPerMu;
  else {
    var i;
    if (t.style.isTight() ? i = t.havingStyle(t.style.text()) : i = t, e.unit === "ex")
      r = i.fontMetrics().xHeight;
    else if (e.unit === "em")
      r = i.fontMetrics().quad;
    else
      throw new se("Invalid unit: '" + e.unit + "'");
    i !== t && (r *= i.sizeMultiplier / t.sizeMultiplier);
  }
  return Math.min(e.number * r, t.maxSize);
}, fe = function(e) {
  return +e.toFixed(4) + "em";
}, vl = function(e) {
  return e.filter((t) => t).join(" ");
}, $D = function(e, t, r) {
  if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = r || {}, t) {
    t.style.isTight() && this.classes.push("mtight");
    var i = t.getColor();
    i && (this.style.color = i);
  }
}, VD = function(e) {
  var t = document.createElement(e);
  t.className = vl(this.classes);
  for (var r in this.style)
    this.style.hasOwnProperty(r) && (t.style[r] = this.style[r]);
  for (var i in this.attributes)
    this.attributes.hasOwnProperty(i) && t.setAttribute(i, this.attributes[i]);
  for (var s = 0; s < this.children.length; s++)
    t.appendChild(this.children[s].toNode());
  return t;
}, yoe = /[\s"'>/=\x00-\x1f]/, qD = function(e) {
  var t = "<" + e;
  this.classes.length && (t += ' class="' + Be.escape(vl(this.classes)) + '"');
  var r = "";
  for (var i in this.style)
    this.style.hasOwnProperty(i) && (r += Be.hyphenate(i) + ":" + this.style[i] + ";");
  r && (t += ' style="' + Be.escape(r) + '"');
  for (var s in this.attributes)
    if (this.attributes.hasOwnProperty(s)) {
      if (yoe.test(s))
        throw new se("Invalid attribute name '" + s + "'");
      t += " " + s + '="' + Be.escape(this.attributes[s]) + '"';
    }
  t += ">";
  for (var o = 0; o < this.children.length; o++)
    t += this.children[o].toMarkup();
  return t += "</" + e + ">", t;
};
class Ld {
  constructor(e, t, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, $D.call(this, e, r, i), this.children = t || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  toNode() {
    return VD.call(this, "span");
  }
  toMarkup() {
    return qD.call(this, "span");
  }
}
class p7 {
  constructor(e, t, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, $D.call(this, t, i), this.children = r || [], this.setAttribute("href", e);
  }
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  toNode() {
    return VD.call(this, "a");
  }
  toMarkup() {
    return qD.call(this, "a");
  }
}
class boe {
  constructor(e, t, r) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = t, this.src = e, this.classes = ["mord"], this.style = r;
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  toNode() {
    var e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (var t in this.style)
      this.style.hasOwnProperty(t) && (e.style[t] = this.style[t]);
    return e;
  }
  toMarkup() {
    var e = '<img src="' + Be.escape(this.src) + '"' + (' alt="' + Be.escape(this.alt) + '"'), t = "";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t += Be.hyphenate(r) + ":" + this.style[r] + ";");
    return t && (e += ' style="' + Be.escape(t) + '"'), e += "'/>", e;
  }
}
var voe = {
  î: "ı̂",
  ï: "ı̈",
  í: "ı́",
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  ì: "ı̀"
};
class ki {
  constructor(e, t, r, i, s, o, l, a) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = t || 0, this.depth = r || 0, this.italic = i || 0, this.skew = s || 0, this.width = o || 0, this.classes = l || [], this.style = a || {}, this.maxFontSize = 0;
    var c = noe(this.text.charCodeAt(0));
    c && this.classes.push(c + "_fallback"), /[îïíì]/.test(this.text) && (this.text = voe[this.text]);
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var e = document.createTextNode(this.text), t = null;
    this.italic > 0 && (t = document.createElement("span"), t.style.marginRight = fe(this.italic)), this.classes.length > 0 && (t = t || document.createElement("span"), t.className = vl(this.classes));
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t = t || document.createElement("span"), t.style[r] = this.style[r]);
    return t ? (t.appendChild(e), t) : e;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var e = !1, t = "<span";
    this.classes.length && (e = !0, t += ' class="', t += Be.escape(vl(this.classes)), t += '"');
    var r = "";
    this.italic > 0 && (r += "margin-right:" + this.italic + "em;");
    for (var i in this.style)
      this.style.hasOwnProperty(i) && (r += Be.hyphenate(i) + ":" + this.style[i] + ";");
    r && (e = !0, t += ' style="' + Be.escape(r) + '"');
    var s = Be.escape(this.text);
    return e ? (t += ">", t += s, t += "</span>", t) : s;
  }
}
class mo {
  constructor(e, t) {
    this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = t || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "svg");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    for (var i = 0; i < this.children.length; i++)
      t.appendChild(this.children[i].toNode());
    return t;
  }
  toMarkup() {
    var e = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + Be.escape(this.attributes[t]) + '"');
    e += ">";
    for (var r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</svg>", e;
  }
}
class wl {
  constructor(e, t) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = t;
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "path");
    return this.alternate ? t.setAttribute("d", this.alternate) : t.setAttribute("d", l9[this.pathName]), t;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + Be.escape(this.alternate) + '"/>' : '<path d="' + Be.escape(l9[this.pathName]) + '"/>';
  }
}
class P5 {
  constructor(e) {
    this.attributes = void 0, this.attributes = e || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "line");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    return t;
  }
  toMarkup() {
    var e = "<line";
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + Be.escape(this.attributes[t]) + '"');
    return e += "/>", e;
  }
}
function h9(n) {
  if (n instanceof ki)
    return n;
  throw new Error("Expected symbolNode but got " + String(n) + ".");
}
function woe(n) {
  if (n instanceof Ld)
    return n;
  throw new Error("Expected span<HtmlDomNode> but got " + String(n) + ".");
}
var xoe = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, koe = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, zt = {
  math: {},
  text: {}
};
function y(n, e, t, r, i, s) {
  zt[n][i] = {
    font: e,
    group: t,
    replace: r
  }, s && r && (zt[n][r] = zt[n][i]);
}
var v = "math", ee = "text", x = "main", A = "ams", Kt = "accent-token", ke = "bin", br = "close", gu = "inner", qe = "mathord", yn = "op-token", ti = "open", cg = "punct", D = "rel", To = "spacing", _ = "textord";
y(v, x, D, "≡", "\\equiv", !0);
y(v, x, D, "≺", "\\prec", !0);
y(v, x, D, "≻", "\\succ", !0);
y(v, x, D, "∼", "\\sim", !0);
y(v, x, D, "⊥", "\\perp");
y(v, x, D, "⪯", "\\preceq", !0);
y(v, x, D, "⪰", "\\succeq", !0);
y(v, x, D, "≃", "\\simeq", !0);
y(v, x, D, "∣", "\\mid", !0);
y(v, x, D, "≪", "\\ll", !0);
y(v, x, D, "≫", "\\gg", !0);
y(v, x, D, "≍", "\\asymp", !0);
y(v, x, D, "∥", "\\parallel");
y(v, x, D, "⋈", "\\bowtie", !0);
y(v, x, D, "⌣", "\\smile", !0);
y(v, x, D, "⊑", "\\sqsubseteq", !0);
y(v, x, D, "⊒", "\\sqsupseteq", !0);
y(v, x, D, "≐", "\\doteq", !0);
y(v, x, D, "⌢", "\\frown", !0);
y(v, x, D, "∋", "\\ni", !0);
y(v, x, D, "∝", "\\propto", !0);
y(v, x, D, "⊢", "\\vdash", !0);
y(v, x, D, "⊣", "\\dashv", !0);
y(v, x, D, "∋", "\\owns");
y(v, x, cg, ".", "\\ldotp");
y(v, x, cg, "⋅", "\\cdotp");
y(v, x, _, "#", "\\#");
y(ee, x, _, "#", "\\#");
y(v, x, _, "&", "\\&");
y(ee, x, _, "&", "\\&");
y(v, x, _, "ℵ", "\\aleph", !0);
y(v, x, _, "∀", "\\forall", !0);
y(v, x, _, "ℏ", "\\hbar", !0);
y(v, x, _, "∃", "\\exists", !0);
y(v, x, _, "∇", "\\nabla", !0);
y(v, x, _, "♭", "\\flat", !0);
y(v, x, _, "ℓ", "\\ell", !0);
y(v, x, _, "♮", "\\natural", !0);
y(v, x, _, "♣", "\\clubsuit", !0);
y(v, x, _, "℘", "\\wp", !0);
y(v, x, _, "♯", "\\sharp", !0);
y(v, x, _, "♢", "\\diamondsuit", !0);
y(v, x, _, "ℜ", "\\Re", !0);
y(v, x, _, "♡", "\\heartsuit", !0);
y(v, x, _, "ℑ", "\\Im", !0);
y(v, x, _, "♠", "\\spadesuit", !0);
y(v, x, _, "§", "\\S", !0);
y(ee, x, _, "§", "\\S");
y(v, x, _, "¶", "\\P", !0);
y(ee, x, _, "¶", "\\P");
y(v, x, _, "†", "\\dag");
y(ee, x, _, "†", "\\dag");
y(ee, x, _, "†", "\\textdagger");
y(v, x, _, "‡", "\\ddag");
y(ee, x, _, "‡", "\\ddag");
y(ee, x, _, "‡", "\\textdaggerdbl");
y(v, x, br, "⎱", "\\rmoustache", !0);
y(v, x, ti, "⎰", "\\lmoustache", !0);
y(v, x, br, "⟯", "\\rgroup", !0);
y(v, x, ti, "⟮", "\\lgroup", !0);
y(v, x, ke, "∓", "\\mp", !0);
y(v, x, ke, "⊖", "\\ominus", !0);
y(v, x, ke, "⊎", "\\uplus", !0);
y(v, x, ke, "⊓", "\\sqcap", !0);
y(v, x, ke, "∗", "\\ast");
y(v, x, ke, "⊔", "\\sqcup", !0);
y(v, x, ke, "◯", "\\bigcirc", !0);
y(v, x, ke, "∙", "\\bullet", !0);
y(v, x, ke, "‡", "\\ddagger");
y(v, x, ke, "≀", "\\wr", !0);
y(v, x, ke, "⨿", "\\amalg");
y(v, x, ke, "&", "\\And");
y(v, x, D, "⟵", "\\longleftarrow", !0);
y(v, x, D, "⇐", "\\Leftarrow", !0);
y(v, x, D, "⟸", "\\Longleftarrow", !0);
y(v, x, D, "⟶", "\\longrightarrow", !0);
y(v, x, D, "⇒", "\\Rightarrow", !0);
y(v, x, D, "⟹", "\\Longrightarrow", !0);
y(v, x, D, "↔", "\\leftrightarrow", !0);
y(v, x, D, "⟷", "\\longleftrightarrow", !0);
y(v, x, D, "⇔", "\\Leftrightarrow", !0);
y(v, x, D, "⟺", "\\Longleftrightarrow", !0);
y(v, x, D, "↦", "\\mapsto", !0);
y(v, x, D, "⟼", "\\longmapsto", !0);
y(v, x, D, "↗", "\\nearrow", !0);
y(v, x, D, "↩", "\\hookleftarrow", !0);
y(v, x, D, "↪", "\\hookrightarrow", !0);
y(v, x, D, "↘", "\\searrow", !0);
y(v, x, D, "↼", "\\leftharpoonup", !0);
y(v, x, D, "⇀", "\\rightharpoonup", !0);
y(v, x, D, "↙", "\\swarrow", !0);
y(v, x, D, "↽", "\\leftharpoondown", !0);
y(v, x, D, "⇁", "\\rightharpoondown", !0);
y(v, x, D, "↖", "\\nwarrow", !0);
y(v, x, D, "⇌", "\\rightleftharpoons", !0);
y(v, A, D, "≮", "\\nless", !0);
y(v, A, D, "", "\\@nleqslant");
y(v, A, D, "", "\\@nleqq");
y(v, A, D, "⪇", "\\lneq", !0);
y(v, A, D, "≨", "\\lneqq", !0);
y(v, A, D, "", "\\@lvertneqq");
y(v, A, D, "⋦", "\\lnsim", !0);
y(v, A, D, "⪉", "\\lnapprox", !0);
y(v, A, D, "⊀", "\\nprec", !0);
y(v, A, D, "⋠", "\\npreceq", !0);
y(v, A, D, "⋨", "\\precnsim", !0);
y(v, A, D, "⪹", "\\precnapprox", !0);
y(v, A, D, "≁", "\\nsim", !0);
y(v, A, D, "", "\\@nshortmid");
y(v, A, D, "∤", "\\nmid", !0);
y(v, A, D, "⊬", "\\nvdash", !0);
y(v, A, D, "⊭", "\\nvDash", !0);
y(v, A, D, "⋪", "\\ntriangleleft");
y(v, A, D, "⋬", "\\ntrianglelefteq", !0);
y(v, A, D, "⊊", "\\subsetneq", !0);
y(v, A, D, "", "\\@varsubsetneq");
y(v, A, D, "⫋", "\\subsetneqq", !0);
y(v, A, D, "", "\\@varsubsetneqq");
y(v, A, D, "≯", "\\ngtr", !0);
y(v, A, D, "", "\\@ngeqslant");
y(v, A, D, "", "\\@ngeqq");
y(v, A, D, "⪈", "\\gneq", !0);
y(v, A, D, "≩", "\\gneqq", !0);
y(v, A, D, "", "\\@gvertneqq");
y(v, A, D, "⋧", "\\gnsim", !0);
y(v, A, D, "⪊", "\\gnapprox", !0);
y(v, A, D, "⊁", "\\nsucc", !0);
y(v, A, D, "⋡", "\\nsucceq", !0);
y(v, A, D, "⋩", "\\succnsim", !0);
y(v, A, D, "⪺", "\\succnapprox", !0);
y(v, A, D, "≆", "\\ncong", !0);
y(v, A, D, "", "\\@nshortparallel");
y(v, A, D, "∦", "\\nparallel", !0);
y(v, A, D, "⊯", "\\nVDash", !0);
y(v, A, D, "⋫", "\\ntriangleright");
y(v, A, D, "⋭", "\\ntrianglerighteq", !0);
y(v, A, D, "", "\\@nsupseteqq");
y(v, A, D, "⊋", "\\supsetneq", !0);
y(v, A, D, "", "\\@varsupsetneq");
y(v, A, D, "⫌", "\\supsetneqq", !0);
y(v, A, D, "", "\\@varsupsetneqq");
y(v, A, D, "⊮", "\\nVdash", !0);
y(v, A, D, "⪵", "\\precneqq", !0);
y(v, A, D, "⪶", "\\succneqq", !0);
y(v, A, D, "", "\\@nsubseteqq");
y(v, A, ke, "⊴", "\\unlhd");
y(v, A, ke, "⊵", "\\unrhd");
y(v, A, D, "↚", "\\nleftarrow", !0);
y(v, A, D, "↛", "\\nrightarrow", !0);
y(v, A, D, "⇍", "\\nLeftarrow", !0);
y(v, A, D, "⇏", "\\nRightarrow", !0);
y(v, A, D, "↮", "\\nleftrightarrow", !0);
y(v, A, D, "⇎", "\\nLeftrightarrow", !0);
y(v, A, D, "△", "\\vartriangle");
y(v, A, _, "ℏ", "\\hslash");
y(v, A, _, "▽", "\\triangledown");
y(v, A, _, "◊", "\\lozenge");
y(v, A, _, "Ⓢ", "\\circledS");
y(v, A, _, "®", "\\circledR");
y(ee, A, _, "®", "\\circledR");
y(v, A, _, "∡", "\\measuredangle", !0);
y(v, A, _, "∄", "\\nexists");
y(v, A, _, "℧", "\\mho");
y(v, A, _, "Ⅎ", "\\Finv", !0);
y(v, A, _, "⅁", "\\Game", !0);
y(v, A, _, "‵", "\\backprime");
y(v, A, _, "▲", "\\blacktriangle");
y(v, A, _, "▼", "\\blacktriangledown");
y(v, A, _, "■", "\\blacksquare");
y(v, A, _, "⧫", "\\blacklozenge");
y(v, A, _, "★", "\\bigstar");
y(v, A, _, "∢", "\\sphericalangle", !0);
y(v, A, _, "∁", "\\complement", !0);
y(v, A, _, "ð", "\\eth", !0);
y(ee, x, _, "ð", "ð");
y(v, A, _, "╱", "\\diagup");
y(v, A, _, "╲", "\\diagdown");
y(v, A, _, "□", "\\square");
y(v, A, _, "□", "\\Box");
y(v, A, _, "◊", "\\Diamond");
y(v, A, _, "¥", "\\yen", !0);
y(ee, A, _, "¥", "\\yen", !0);
y(v, A, _, "✓", "\\checkmark", !0);
y(ee, A, _, "✓", "\\checkmark");
y(v, A, _, "ℶ", "\\beth", !0);
y(v, A, _, "ℸ", "\\daleth", !0);
y(v, A, _, "ℷ", "\\gimel", !0);
y(v, A, _, "ϝ", "\\digamma", !0);
y(v, A, _, "ϰ", "\\varkappa");
y(v, A, ti, "┌", "\\@ulcorner", !0);
y(v, A, br, "┐", "\\@urcorner", !0);
y(v, A, ti, "└", "\\@llcorner", !0);
y(v, A, br, "┘", "\\@lrcorner", !0);
y(v, A, D, "≦", "\\leqq", !0);
y(v, A, D, "⩽", "\\leqslant", !0);
y(v, A, D, "⪕", "\\eqslantless", !0);
y(v, A, D, "≲", "\\lesssim", !0);
y(v, A, D, "⪅", "\\lessapprox", !0);
y(v, A, D, "≊", "\\approxeq", !0);
y(v, A, ke, "⋖", "\\lessdot");
y(v, A, D, "⋘", "\\lll", !0);
y(v, A, D, "≶", "\\lessgtr", !0);
y(v, A, D, "⋚", "\\lesseqgtr", !0);
y(v, A, D, "⪋", "\\lesseqqgtr", !0);
y(v, A, D, "≑", "\\doteqdot");
y(v, A, D, "≓", "\\risingdotseq", !0);
y(v, A, D, "≒", "\\fallingdotseq", !0);
y(v, A, D, "∽", "\\backsim", !0);
y(v, A, D, "⋍", "\\backsimeq", !0);
y(v, A, D, "⫅", "\\subseteqq", !0);
y(v, A, D, "⋐", "\\Subset", !0);
y(v, A, D, "⊏", "\\sqsubset", !0);
y(v, A, D, "≼", "\\preccurlyeq", !0);
y(v, A, D, "⋞", "\\curlyeqprec", !0);
y(v, A, D, "≾", "\\precsim", !0);
y(v, A, D, "⪷", "\\precapprox", !0);
y(v, A, D, "⊲", "\\vartriangleleft");
y(v, A, D, "⊴", "\\trianglelefteq");
y(v, A, D, "⊨", "\\vDash", !0);
y(v, A, D, "⊪", "\\Vvdash", !0);
y(v, A, D, "⌣", "\\smallsmile");
y(v, A, D, "⌢", "\\smallfrown");
y(v, A, D, "≏", "\\bumpeq", !0);
y(v, A, D, "≎", "\\Bumpeq", !0);
y(v, A, D, "≧", "\\geqq", !0);
y(v, A, D, "⩾", "\\geqslant", !0);
y(v, A, D, "⪖", "\\eqslantgtr", !0);
y(v, A, D, "≳", "\\gtrsim", !0);
y(v, A, D, "⪆", "\\gtrapprox", !0);
y(v, A, ke, "⋗", "\\gtrdot");
y(v, A, D, "⋙", "\\ggg", !0);
y(v, A, D, "≷", "\\gtrless", !0);
y(v, A, D, "⋛", "\\gtreqless", !0);
y(v, A, D, "⪌", "\\gtreqqless", !0);
y(v, A, D, "≖", "\\eqcirc", !0);
y(v, A, D, "≗", "\\circeq", !0);
y(v, A, D, "≜", "\\triangleq", !0);
y(v, A, D, "∼", "\\thicksim");
y(v, A, D, "≈", "\\thickapprox");
y(v, A, D, "⫆", "\\supseteqq", !0);
y(v, A, D, "⋑", "\\Supset", !0);
y(v, A, D, "⊐", "\\sqsupset", !0);
y(v, A, D, "≽", "\\succcurlyeq", !0);
y(v, A, D, "⋟", "\\curlyeqsucc", !0);
y(v, A, D, "≿", "\\succsim", !0);
y(v, A, D, "⪸", "\\succapprox", !0);
y(v, A, D, "⊳", "\\vartriangleright");
y(v, A, D, "⊵", "\\trianglerighteq");
y(v, A, D, "⊩", "\\Vdash", !0);
y(v, A, D, "∣", "\\shortmid");
y(v, A, D, "∥", "\\shortparallel");
y(v, A, D, "≬", "\\between", !0);
y(v, A, D, "⋔", "\\pitchfork", !0);
y(v, A, D, "∝", "\\varpropto");
y(v, A, D, "◀", "\\blacktriangleleft");
y(v, A, D, "∴", "\\therefore", !0);
y(v, A, D, "∍", "\\backepsilon");
y(v, A, D, "▶", "\\blacktriangleright");
y(v, A, D, "∵", "\\because", !0);
y(v, A, D, "⋘", "\\llless");
y(v, A, D, "⋙", "\\gggtr");
y(v, A, ke, "⊲", "\\lhd");
y(v, A, ke, "⊳", "\\rhd");
y(v, A, D, "≂", "\\eqsim", !0);
y(v, x, D, "⋈", "\\Join");
y(v, A, D, "≑", "\\Doteq", !0);
y(v, A, ke, "∔", "\\dotplus", !0);
y(v, A, ke, "∖", "\\smallsetminus");
y(v, A, ke, "⋒", "\\Cap", !0);
y(v, A, ke, "⋓", "\\Cup", !0);
y(v, A, ke, "⩞", "\\doublebarwedge", !0);
y(v, A, ke, "⊟", "\\boxminus", !0);
y(v, A, ke, "⊞", "\\boxplus", !0);
y(v, A, ke, "⋇", "\\divideontimes", !0);
y(v, A, ke, "⋉", "\\ltimes", !0);
y(v, A, ke, "⋊", "\\rtimes", !0);
y(v, A, ke, "⋋", "\\leftthreetimes", !0);
y(v, A, ke, "⋌", "\\rightthreetimes", !0);
y(v, A, ke, "⋏", "\\curlywedge", !0);
y(v, A, ke, "⋎", "\\curlyvee", !0);
y(v, A, ke, "⊝", "\\circleddash", !0);
y(v, A, ke, "⊛", "\\circledast", !0);
y(v, A, ke, "⋅", "\\centerdot");
y(v, A, ke, "⊺", "\\intercal", !0);
y(v, A, ke, "⋒", "\\doublecap");
y(v, A, ke, "⋓", "\\doublecup");
y(v, A, ke, "⊠", "\\boxtimes", !0);
y(v, A, D, "⇢", "\\dashrightarrow", !0);
y(v, A, D, "⇠", "\\dashleftarrow", !0);
y(v, A, D, "⇇", "\\leftleftarrows", !0);
y(v, A, D, "⇆", "\\leftrightarrows", !0);
y(v, A, D, "⇚", "\\Lleftarrow", !0);
y(v, A, D, "↞", "\\twoheadleftarrow", !0);
y(v, A, D, "↢", "\\leftarrowtail", !0);
y(v, A, D, "↫", "\\looparrowleft", !0);
y(v, A, D, "⇋", "\\leftrightharpoons", !0);
y(v, A, D, "↶", "\\curvearrowleft", !0);
y(v, A, D, "↺", "\\circlearrowleft", !0);
y(v, A, D, "↰", "\\Lsh", !0);
y(v, A, D, "⇈", "\\upuparrows", !0);
y(v, A, D, "↿", "\\upharpoonleft", !0);
y(v, A, D, "⇃", "\\downharpoonleft", !0);
y(v, x, D, "⊶", "\\origof", !0);
y(v, x, D, "⊷", "\\imageof", !0);
y(v, A, D, "⊸", "\\multimap", !0);
y(v, A, D, "↭", "\\leftrightsquigarrow", !0);
y(v, A, D, "⇉", "\\rightrightarrows", !0);
y(v, A, D, "⇄", "\\rightleftarrows", !0);
y(v, A, D, "↠", "\\twoheadrightarrow", !0);
y(v, A, D, "↣", "\\rightarrowtail", !0);
y(v, A, D, "↬", "\\looparrowright", !0);
y(v, A, D, "↷", "\\curvearrowright", !0);
y(v, A, D, "↻", "\\circlearrowright", !0);
y(v, A, D, "↱", "\\Rsh", !0);
y(v, A, D, "⇊", "\\downdownarrows", !0);
y(v, A, D, "↾", "\\upharpoonright", !0);
y(v, A, D, "⇂", "\\downharpoonright", !0);
y(v, A, D, "⇝", "\\rightsquigarrow", !0);
y(v, A, D, "⇝", "\\leadsto");
y(v, A, D, "⇛", "\\Rrightarrow", !0);
y(v, A, D, "↾", "\\restriction");
y(v, x, _, "‘", "`");
y(v, x, _, "$", "\\$");
y(ee, x, _, "$", "\\$");
y(ee, x, _, "$", "\\textdollar");
y(v, x, _, "%", "\\%");
y(ee, x, _, "%", "\\%");
y(v, x, _, "_", "\\_");
y(ee, x, _, "_", "\\_");
y(ee, x, _, "_", "\\textunderscore");
y(v, x, _, "∠", "\\angle", !0);
y(v, x, _, "∞", "\\infty", !0);
y(v, x, _, "′", "\\prime");
y(v, x, _, "△", "\\triangle");
y(v, x, _, "Γ", "\\Gamma", !0);
y(v, x, _, "Δ", "\\Delta", !0);
y(v, x, _, "Θ", "\\Theta", !0);
y(v, x, _, "Λ", "\\Lambda", !0);
y(v, x, _, "Ξ", "\\Xi", !0);
y(v, x, _, "Π", "\\Pi", !0);
y(v, x, _, "Σ", "\\Sigma", !0);
y(v, x, _, "Υ", "\\Upsilon", !0);
y(v, x, _, "Φ", "\\Phi", !0);
y(v, x, _, "Ψ", "\\Psi", !0);
y(v, x, _, "Ω", "\\Omega", !0);
y(v, x, _, "A", "Α");
y(v, x, _, "B", "Β");
y(v, x, _, "E", "Ε");
y(v, x, _, "Z", "Ζ");
y(v, x, _, "H", "Η");
y(v, x, _, "I", "Ι");
y(v, x, _, "K", "Κ");
y(v, x, _, "M", "Μ");
y(v, x, _, "N", "Ν");
y(v, x, _, "O", "Ο");
y(v, x, _, "P", "Ρ");
y(v, x, _, "T", "Τ");
y(v, x, _, "X", "Χ");
y(v, x, _, "¬", "\\neg", !0);
y(v, x, _, "¬", "\\lnot");
y(v, x, _, "⊤", "\\top");
y(v, x, _, "⊥", "\\bot");
y(v, x, _, "∅", "\\emptyset");
y(v, A, _, "∅", "\\varnothing");
y(v, x, qe, "α", "\\alpha", !0);
y(v, x, qe, "β", "\\beta", !0);
y(v, x, qe, "γ", "\\gamma", !0);
y(v, x, qe, "δ", "\\delta", !0);
y(v, x, qe, "ϵ", "\\epsilon", !0);
y(v, x, qe, "ζ", "\\zeta", !0);
y(v, x, qe, "η", "\\eta", !0);
y(v, x, qe, "θ", "\\theta", !0);
y(v, x, qe, "ι", "\\iota", !0);
y(v, x, qe, "κ", "\\kappa", !0);
y(v, x, qe, "λ", "\\lambda", !0);
y(v, x, qe, "μ", "\\mu", !0);
y(v, x, qe, "ν", "\\nu", !0);
y(v, x, qe, "ξ", "\\xi", !0);
y(v, x, qe, "ο", "\\omicron", !0);
y(v, x, qe, "π", "\\pi", !0);
y(v, x, qe, "ρ", "\\rho", !0);
y(v, x, qe, "σ", "\\sigma", !0);
y(v, x, qe, "τ", "\\tau", !0);
y(v, x, qe, "υ", "\\upsilon", !0);
y(v, x, qe, "ϕ", "\\phi", !0);
y(v, x, qe, "χ", "\\chi", !0);
y(v, x, qe, "ψ", "\\psi", !0);
y(v, x, qe, "ω", "\\omega", !0);
y(v, x, qe, "ε", "\\varepsilon", !0);
y(v, x, qe, "ϑ", "\\vartheta", !0);
y(v, x, qe, "ϖ", "\\varpi", !0);
y(v, x, qe, "ϱ", "\\varrho", !0);
y(v, x, qe, "ς", "\\varsigma", !0);
y(v, x, qe, "φ", "\\varphi", !0);
y(v, x, ke, "∗", "*", !0);
y(v, x, ke, "+", "+");
y(v, x, ke, "−", "-", !0);
y(v, x, ke, "⋅", "\\cdot", !0);
y(v, x, ke, "∘", "\\circ", !0);
y(v, x, ke, "÷", "\\div", !0);
y(v, x, ke, "±", "\\pm", !0);
y(v, x, ke, "×", "\\times", !0);
y(v, x, ke, "∩", "\\cap", !0);
y(v, x, ke, "∪", "\\cup", !0);
y(v, x, ke, "∖", "\\setminus", !0);
y(v, x, ke, "∧", "\\land");
y(v, x, ke, "∨", "\\lor");
y(v, x, ke, "∧", "\\wedge", !0);
y(v, x, ke, "∨", "\\vee", !0);
y(v, x, _, "√", "\\surd");
y(v, x, ti, "⟨", "\\langle", !0);
y(v, x, ti, "∣", "\\lvert");
y(v, x, ti, "∥", "\\lVert");
y(v, x, br, "?", "?");
y(v, x, br, "!", "!");
y(v, x, br, "⟩", "\\rangle", !0);
y(v, x, br, "∣", "\\rvert");
y(v, x, br, "∥", "\\rVert");
y(v, x, D, "=", "=");
y(v, x, D, ":", ":");
y(v, x, D, "≈", "\\approx", !0);
y(v, x, D, "≅", "\\cong", !0);
y(v, x, D, "≥", "\\ge");
y(v, x, D, "≥", "\\geq", !0);
y(v, x, D, "←", "\\gets");
y(v, x, D, ">", "\\gt", !0);
y(v, x, D, "∈", "\\in", !0);
y(v, x, D, "", "\\@not");
y(v, x, D, "⊂", "\\subset", !0);
y(v, x, D, "⊃", "\\supset", !0);
y(v, x, D, "⊆", "\\subseteq", !0);
y(v, x, D, "⊇", "\\supseteq", !0);
y(v, A, D, "⊈", "\\nsubseteq", !0);
y(v, A, D, "⊉", "\\nsupseteq", !0);
y(v, x, D, "⊨", "\\models");
y(v, x, D, "←", "\\leftarrow", !0);
y(v, x, D, "≤", "\\le");
y(v, x, D, "≤", "\\leq", !0);
y(v, x, D, "<", "\\lt", !0);
y(v, x, D, "→", "\\rightarrow", !0);
y(v, x, D, "→", "\\to");
y(v, A, D, "≱", "\\ngeq", !0);
y(v, A, D, "≰", "\\nleq", !0);
y(v, x, To, " ", "\\ ");
y(v, x, To, " ", "\\space");
y(v, x, To, " ", "\\nobreakspace");
y(ee, x, To, " ", "\\ ");
y(ee, x, To, " ", " ");
y(ee, x, To, " ", "\\space");
y(ee, x, To, " ", "\\nobreakspace");
y(v, x, To, null, "\\nobreak");
y(v, x, To, null, "\\allowbreak");
y(v, x, cg, ",", ",");
y(v, x, cg, ";", ";");
y(v, A, ke, "⊼", "\\barwedge", !0);
y(v, A, ke, "⊻", "\\veebar", !0);
y(v, x, ke, "⊙", "\\odot", !0);
y(v, x, ke, "⊕", "\\oplus", !0);
y(v, x, ke, "⊗", "\\otimes", !0);
y(v, x, _, "∂", "\\partial", !0);
y(v, x, ke, "⊘", "\\oslash", !0);
y(v, A, ke, "⊚", "\\circledcirc", !0);
y(v, A, ke, "⊡", "\\boxdot", !0);
y(v, x, ke, "△", "\\bigtriangleup");
y(v, x, ke, "▽", "\\bigtriangledown");
y(v, x, ke, "†", "\\dagger");
y(v, x, ke, "⋄", "\\diamond");
y(v, x, ke, "⋆", "\\star");
y(v, x, ke, "◃", "\\triangleleft");
y(v, x, ke, "▹", "\\triangleright");
y(v, x, ti, "{", "\\{");
y(ee, x, _, "{", "\\{");
y(ee, x, _, "{", "\\textbraceleft");
y(v, x, br, "}", "\\}");
y(ee, x, _, "}", "\\}");
y(ee, x, _, "}", "\\textbraceright");
y(v, x, ti, "{", "\\lbrace");
y(v, x, br, "}", "\\rbrace");
y(v, x, ti, "[", "\\lbrack", !0);
y(ee, x, _, "[", "\\lbrack", !0);
y(v, x, br, "]", "\\rbrack", !0);
y(ee, x, _, "]", "\\rbrack", !0);
y(v, x, ti, "(", "\\lparen", !0);
y(v, x, br, ")", "\\rparen", !0);
y(ee, x, _, "<", "\\textless", !0);
y(ee, x, _, ">", "\\textgreater", !0);
y(v, x, ti, "⌊", "\\lfloor", !0);
y(v, x, br, "⌋", "\\rfloor", !0);
y(v, x, ti, "⌈", "\\lceil", !0);
y(v, x, br, "⌉", "\\rceil", !0);
y(v, x, _, "\\", "\\backslash");
y(v, x, _, "∣", "|");
y(v, x, _, "∣", "\\vert");
y(ee, x, _, "|", "\\textbar", !0);
y(v, x, _, "∥", "\\|");
y(v, x, _, "∥", "\\Vert");
y(ee, x, _, "∥", "\\textbardbl");
y(ee, x, _, "~", "\\textasciitilde");
y(ee, x, _, "\\", "\\textbackslash");
y(ee, x, _, "^", "\\textasciicircum");
y(v, x, D, "↑", "\\uparrow", !0);
y(v, x, D, "⇑", "\\Uparrow", !0);
y(v, x, D, "↓", "\\downarrow", !0);
y(v, x, D, "⇓", "\\Downarrow", !0);
y(v, x, D, "↕", "\\updownarrow", !0);
y(v, x, D, "⇕", "\\Updownarrow", !0);
y(v, x, yn, "∐", "\\coprod");
y(v, x, yn, "⋁", "\\bigvee");
y(v, x, yn, "⋀", "\\bigwedge");
y(v, x, yn, "⨄", "\\biguplus");
y(v, x, yn, "⋂", "\\bigcap");
y(v, x, yn, "⋃", "\\bigcup");
y(v, x, yn, "∫", "\\int");
y(v, x, yn, "∫", "\\intop");
y(v, x, yn, "∬", "\\iint");
y(v, x, yn, "∭", "\\iiint");
y(v, x, yn, "∏", "\\prod");
y(v, x, yn, "∑", "\\sum");
y(v, x, yn, "⨂", "\\bigotimes");
y(v, x, yn, "⨁", "\\bigoplus");
y(v, x, yn, "⨀", "\\bigodot");
y(v, x, yn, "∮", "\\oint");
y(v, x, yn, "∯", "\\oiint");
y(v, x, yn, "∰", "\\oiiint");
y(v, x, yn, "⨆", "\\bigsqcup");
y(v, x, yn, "∫", "\\smallint");
y(ee, x, gu, "…", "\\textellipsis");
y(v, x, gu, "…", "\\mathellipsis");
y(ee, x, gu, "…", "\\ldots", !0);
y(v, x, gu, "…", "\\ldots", !0);
y(v, x, gu, "⋯", "\\@cdots", !0);
y(v, x, gu, "⋱", "\\ddots", !0);
y(v, x, _, "⋮", "\\varvdots");
y(ee, x, _, "⋮", "\\varvdots");
y(v, x, Kt, "ˊ", "\\acute");
y(v, x, Kt, "ˋ", "\\grave");
y(v, x, Kt, "¨", "\\ddot");
y(v, x, Kt, "~", "\\tilde");
y(v, x, Kt, "ˉ", "\\bar");
y(v, x, Kt, "˘", "\\breve");
y(v, x, Kt, "ˇ", "\\check");
y(v, x, Kt, "^", "\\hat");
y(v, x, Kt, "⃗", "\\vec");
y(v, x, Kt, "˙", "\\dot");
y(v, x, Kt, "˚", "\\mathring");
y(v, x, qe, "", "\\@imath");
y(v, x, qe, "", "\\@jmath");
y(v, x, _, "ı", "ı");
y(v, x, _, "ȷ", "ȷ");
y(ee, x, _, "ı", "\\i", !0);
y(ee, x, _, "ȷ", "\\j", !0);
y(ee, x, _, "ß", "\\ss", !0);
y(ee, x, _, "æ", "\\ae", !0);
y(ee, x, _, "œ", "\\oe", !0);
y(ee, x, _, "ø", "\\o", !0);
y(ee, x, _, "Æ", "\\AE", !0);
y(ee, x, _, "Œ", "\\OE", !0);
y(ee, x, _, "Ø", "\\O", !0);
y(ee, x, Kt, "ˊ", "\\'");
y(ee, x, Kt, "ˋ", "\\`");
y(ee, x, Kt, "ˆ", "\\^");
y(ee, x, Kt, "˜", "\\~");
y(ee, x, Kt, "ˉ", "\\=");
y(ee, x, Kt, "˘", "\\u");
y(ee, x, Kt, "˙", "\\.");
y(ee, x, Kt, "¸", "\\c");
y(ee, x, Kt, "˚", "\\r");
y(ee, x, Kt, "ˇ", "\\v");
y(ee, x, Kt, "¨", '\\"');
y(ee, x, Kt, "˝", "\\H");
y(ee, x, Kt, "◯", "\\textcircled");
var WD = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
y(ee, x, _, "–", "--", !0);
y(ee, x, _, "–", "\\textendash");
y(ee, x, _, "—", "---", !0);
y(ee, x, _, "—", "\\textemdash");
y(ee, x, _, "‘", "`", !0);
y(ee, x, _, "‘", "\\textquoteleft");
y(ee, x, _, "’", "'", !0);
y(ee, x, _, "’", "\\textquoteright");
y(ee, x, _, "“", "``", !0);
y(ee, x, _, "“", "\\textquotedblleft");
y(ee, x, _, "”", "''", !0);
y(ee, x, _, "”", "\\textquotedblright");
y(v, x, _, "°", "\\degree", !0);
y(ee, x, _, "°", "\\degree");
y(ee, x, _, "°", "\\textdegree", !0);
y(v, x, _, "£", "\\pounds");
y(v, x, _, "£", "\\mathsterling", !0);
y(ee, x, _, "£", "\\pounds");
y(ee, x, _, "£", "\\textsterling", !0);
y(v, A, _, "✠", "\\maltese");
y(ee, A, _, "✠", "\\maltese");
var f9 = '0123456789/@."';
for (var s4 = 0; s4 < f9.length; s4++) {
  var d9 = f9.charAt(s4);
  y(v, x, _, d9, d9);
}
var p9 = '0123456789!@*()-=+";:?/.,';
for (var o4 = 0; o4 < p9.length; o4++) {
  var m9 = p9.charAt(o4);
  y(ee, x, _, m9, m9);
}
var Um = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var l4 = 0; l4 < Um.length; l4++) {
  var D0 = Um.charAt(l4);
  y(v, x, qe, D0, D0), y(ee, x, _, D0, D0);
}
y(v, A, _, "C", "ℂ");
y(ee, A, _, "C", "ℂ");
y(v, A, _, "H", "ℍ");
y(ee, A, _, "H", "ℍ");
y(v, A, _, "N", "ℕ");
y(ee, A, _, "N", "ℕ");
y(v, A, _, "P", "ℙ");
y(ee, A, _, "P", "ℙ");
y(v, A, _, "Q", "ℚ");
y(ee, A, _, "Q", "ℚ");
y(v, A, _, "R", "ℝ");
y(ee, A, _, "R", "ℝ");
y(v, A, _, "Z", "ℤ");
y(ee, A, _, "Z", "ℤ");
y(v, x, qe, "h", "ℎ");
y(ee, x, qe, "h", "ℎ");
var Ke = "";
for (var nr = 0; nr < Um.length; nr++) {
  var nn = Um.charAt(nr);
  Ke = String.fromCharCode(55349, 56320 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56372 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56424 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56580 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56684 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56736 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56788 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56840 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56944 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), nr < 26 && (Ke = String.fromCharCode(55349, 56632 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56476 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke));
}
Ke = "𝕜";
y(v, x, qe, "k", Ke);
y(ee, x, _, "k", Ke);
for (var Fl = 0; Fl < 10; Fl++) {
  var No = Fl.toString();
  Ke = String.fromCharCode(55349, 57294 + Fl), y(v, x, qe, No, Ke), y(ee, x, _, No, Ke), Ke = String.fromCharCode(55349, 57314 + Fl), y(v, x, qe, No, Ke), y(ee, x, _, No, Ke), Ke = String.fromCharCode(55349, 57324 + Fl), y(v, x, qe, No, Ke), y(ee, x, _, No, Ke), Ke = String.fromCharCode(55349, 57334 + Fl), y(v, x, qe, No, Ke), y(ee, x, _, No, Ke);
}
var _5 = "ÐÞþ";
for (var a4 = 0; a4 < _5.length; a4++) {
  var N0 = _5.charAt(a4);
  y(v, x, qe, N0, N0), y(ee, x, _, N0, N0);
}
var R0 = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], g9 = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], Soe = function(e, t) {
  var r = e.charCodeAt(0), i = e.charCodeAt(1), s = (r - 55296) * 1024 + (i - 56320) + 65536, o = t === "math" ? 0 : 1;
  if (119808 <= s && s < 120484) {
    var l = Math.floor((s - 119808) / 26);
    return [R0[l][2], R0[l][o]];
  } else if (120782 <= s && s <= 120831) {
    var a = Math.floor((s - 120782) / 10);
    return [g9[a][2], g9[a][o]];
  } else {
    if (s === 120485 || s === 120486)
      return [R0[0][2], R0[0][o]];
    if (120486 < s && s < 120782)
      return ["", ""];
    throw new se("Unsupported character: " + e);
  }
}, ug = function(e, t, r) {
  return zt[r][e] && zt[r][e].replace && (e = zt[r][e].replace), {
    value: e,
    metrics: d7(e, t, r)
  };
}, Ii = function(e, t, r, i, s) {
  var o = ug(e, t, r), l = o.metrics;
  e = o.value;
  var a;
  if (l) {
    var c = l.italic;
    (r === "text" || i && i.font === "mathit") && (c = 0), a = new ki(e, l.height, l.depth, c, l.skew, l.width, s);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + e + "' in style '" + t + "' and mode '" + r + "'")), a = new ki(e, 0, 0, 0, 0, 0, s);
  if (i) {
    a.maxFontSize = i.sizeMultiplier, i.style.isTight() && a.classes.push("mtight");
    var u = i.getColor();
    u && (a.style.color = u);
  }
  return a;
}, Coe = function(e, t, r, i) {
  return i === void 0 && (i = []), r.font === "boldsymbol" && ug(e, "Main-Bold", t).metrics ? Ii(e, "Main-Bold", t, r, i.concat(["mathbf"])) : e === "\\" || zt[t][e].font === "main" ? Ii(e, "Main-Regular", t, r, i) : Ii(e, "AMS-Regular", t, r, i.concat(["amsrm"]));
}, Moe = function(e, t, r, i, s) {
  return s !== "textord" && ug(e, "Math-BoldItalic", t).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, Toe = function(e, t, r) {
  var i = e.mode, s = e.text, o = ["mord"], l = i === "math" || i === "text" && t.font, a = l ? t.font : t.fontFamily, c = "", u = "";
  if (s.charCodeAt(0) === 55349 && ([c, u] = Soe(s, i)), c.length > 0)
    return Ii(s, c, i, t, o.concat(u));
  if (a) {
    var h, f;
    if (a === "boldsymbol") {
      var d = Moe(s, i, t, o, r);
      h = d.fontName, f = [d.fontClass];
    } else l ? (h = KD[a].fontName, f = [a]) : (h = P0(a, t.fontWeight, t.fontShape), f = [a, t.fontWeight, t.fontShape]);
    if (ug(s, h, i).metrics)
      return Ii(s, h, i, t, o.concat(f));
    if (WD.hasOwnProperty(s) && h.slice(0, 10) === "Typewriter") {
      for (var p = [], m = 0; m < s.length; m++)
        p.push(Ii(s[m], h, i, t, o.concat(f)));
      return UD(p);
    }
  }
  if (r === "mathord")
    return Ii(s, "Math-Italic", i, t, o.concat(["mathnormal"]));
  if (r === "textord") {
    var g = zt[i][s] && zt[i][s].font;
    if (g === "ams") {
      var b = P0("amsrm", t.fontWeight, t.fontShape);
      return Ii(s, b, i, t, o.concat("amsrm", t.fontWeight, t.fontShape));
    } else if (g === "main" || !g) {
      var w = P0("textrm", t.fontWeight, t.fontShape);
      return Ii(s, w, i, t, o.concat(t.fontWeight, t.fontShape));
    } else {
      var k = P0(g, t.fontWeight, t.fontShape);
      return Ii(s, k, i, t, o.concat(k, t.fontWeight, t.fontShape));
    }
  } else
    throw new Error("unexpected type: " + r + " in makeOrd");
}, Aoe = (n, e) => {
  if (vl(n.classes) !== vl(e.classes) || n.skew !== e.skew || n.maxFontSize !== e.maxFontSize)
    return !1;
  if (n.classes.length === 1) {
    var t = n.classes[0];
    if (t === "mbin" || t === "mord")
      return !1;
  }
  for (var r in n.style)
    if (n.style.hasOwnProperty(r) && n.style[r] !== e.style[r])
      return !1;
  for (var i in e.style)
    if (e.style.hasOwnProperty(i) && n.style[i] !== e.style[i])
      return !1;
  return !0;
}, Ooe = (n) => {
  for (var e = 0; e < n.length - 1; e++) {
    var t = n[e], r = n[e + 1];
    t instanceof ki && r instanceof ki && Aoe(t, r) && (t.text += r.text, t.height = Math.max(t.height, r.height), t.depth = Math.max(t.depth, r.depth), t.italic = r.italic, n.splice(e + 1, 1), e--);
  }
  return n;
}, m7 = function(e) {
  for (var t = 0, r = 0, i = 0, s = 0; s < e.children.length; s++) {
    var o = e.children[s];
    o.height > t && (t = o.height), o.depth > r && (r = o.depth), o.maxFontSize > i && (i = o.maxFontSize);
  }
  e.height = t, e.depth = r, e.maxFontSize = i;
}, xr = function(e, t, r, i) {
  var s = new Ld(e, t, r, i);
  return m7(s), s;
}, jD = (n, e, t, r) => new Ld(n, e, t, r), Eoe = function(e, t, r) {
  var i = xr([e], [], t);
  return i.height = Math.max(r || t.fontMetrics().defaultRuleThickness, t.minRuleThickness), i.style.borderBottomWidth = fe(i.height), i.maxFontSize = 1, i;
}, Ioe = function(e, t, r, i) {
  var s = new p7(e, t, r, i);
  return m7(s), s;
}, UD = function(e) {
  var t = new _d(e);
  return m7(t), t;
}, Doe = function(e, t) {
  return e instanceof _d ? xr([], [e], t) : e;
}, Noe = function(e) {
  if (e.positionType === "individualShift") {
    for (var t = e.children, r = [t[0]], i = -t[0].shift - t[0].elem.depth, s = i, o = 1; o < t.length; o++) {
      var l = -t[o].shift - s - t[o].elem.depth, a = l - (t[o - 1].elem.height + t[o - 1].elem.depth);
      s = s + l, r.push({
        type: "kern",
        size: a
      }), r.push(t[o]);
    }
    return {
      children: r,
      depth: i
    };
  }
  var c;
  if (e.positionType === "top") {
    for (var u = e.positionData, h = 0; h < e.children.length; h++) {
      var f = e.children[h];
      u -= f.type === "kern" ? f.size : f.elem.height + f.elem.depth;
    }
    c = u;
  } else if (e.positionType === "bottom")
    c = -e.positionData;
  else {
    var d = e.children[0];
    if (d.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (e.positionType === "shift")
      c = -d.elem.depth - e.positionData;
    else if (e.positionType === "firstBaseline")
      c = -d.elem.depth;
    else
      throw new Error("Invalid positionType " + e.positionType + ".");
  }
  return {
    children: e.children,
    depth: c
  };
}, Roe = function(e, t) {
  for (var {
    children: r,
    depth: i
  } = Noe(e), s = 0, o = 0; o < r.length; o++) {
    var l = r[o];
    if (l.type === "elem") {
      var a = l.elem;
      s = Math.max(s, a.maxFontSize, a.height);
    }
  }
  s += 2;
  var c = xr(["pstrut"], []);
  c.style.height = fe(s);
  for (var u = [], h = i, f = i, d = i, p = 0; p < r.length; p++) {
    var m = r[p];
    if (m.type === "kern")
      d += m.size;
    else {
      var g = m.elem, b = m.wrapperClasses || [], w = m.wrapperStyle || {}, k = xr(b, [c, g], void 0, w);
      k.style.top = fe(-s - d - g.depth), m.marginLeft && (k.style.marginLeft = m.marginLeft), m.marginRight && (k.style.marginRight = m.marginRight), u.push(k), d += g.height + g.depth;
    }
    h = Math.min(h, d), f = Math.max(f, d);
  }
  var C = xr(["vlist"], u);
  C.style.height = fe(f);
  var M;
  if (h < 0) {
    var T = xr([], []), N = xr(["vlist"], [T]);
    N.style.height = fe(-h);
    var B = xr(["vlist-s"], [new ki("​")]);
    M = [xr(["vlist-r"], [C, B]), xr(["vlist-r"], [N])];
  } else
    M = [xr(["vlist-r"], [C])];
  var $ = xr(["vlist-t"], M);
  return M.length === 2 && $.classes.push("vlist-t2"), $.height = f, $.depth = -h, $;
}, Poe = (n, e) => {
  var t = xr(["mspace"], [], e), r = Qt(n, e);
  return t.style.marginRight = fe(r), t;
}, P0 = function(e, t, r) {
  var i = "";
  switch (e) {
    case "amsrm":
      i = "AMS";
      break;
    case "textrm":
      i = "Main";
      break;
    case "textsf":
      i = "SansSerif";
      break;
    case "texttt":
      i = "Typewriter";
      break;
    default:
      i = e;
  }
  var s;
  return t === "textbf" && r === "textit" ? s = "BoldItalic" : t === "textbf" ? s = "Bold" : t === "textit" ? s = "Italic" : s = "Regular", i + "-" + s;
}, KD = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  mathsfit: {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, GD = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, _oe = function(e, t) {
  var [r, i, s] = GD[e], o = new wl(r), l = new mo([o], {
    width: fe(i),
    height: fe(s),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + fe(i),
    viewBox: "0 0 " + 1e3 * i + " " + 1e3 * s,
    preserveAspectRatio: "xMinYMin"
  }), a = jD(["overlay"], [l], t);
  return a.height = s, a.style.height = fe(s), a.style.width = fe(i), a;
}, H = {
  fontMap: KD,
  makeSymbol: Ii,
  mathsym: Coe,
  makeSpan: xr,
  makeSvgSpan: jD,
  makeLineSpan: Eoe,
  makeAnchor: Ioe,
  makeFragment: UD,
  wrapFragment: Doe,
  makeVList: Roe,
  makeOrd: Toe,
  makeGlue: Poe,
  staticSvg: _oe,
  svgData: GD,
  tryCombineChars: Ooe
}, Xt = {
  number: 3,
  unit: "mu"
}, Hl = {
  number: 4,
  unit: "mu"
}, Fs = {
  number: 5,
  unit: "mu"
}, Loe = {
  mord: {
    mop: Xt,
    mbin: Hl,
    mrel: Fs,
    minner: Xt
  },
  mop: {
    mord: Xt,
    mop: Xt,
    mrel: Fs,
    minner: Xt
  },
  mbin: {
    mord: Hl,
    mop: Hl,
    mopen: Hl,
    minner: Hl
  },
  mrel: {
    mord: Fs,
    mop: Fs,
    mopen: Fs,
    minner: Fs
  },
  mopen: {},
  mclose: {
    mop: Xt,
    mbin: Hl,
    mrel: Fs,
    minner: Xt
  },
  mpunct: {
    mord: Xt,
    mop: Xt,
    mrel: Fs,
    mopen: Xt,
    mclose: Xt,
    mpunct: Xt,
    minner: Xt
  },
  minner: {
    mord: Xt,
    mop: Xt,
    mbin: Hl,
    mrel: Fs,
    mopen: Xt,
    mpunct: Xt,
    minner: Xt
  }
}, Boe = {
  mord: {
    mop: Xt
  },
  mop: {
    mord: Xt,
    mop: Xt
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: Xt
  },
  mpunct: {},
  minner: {
    mop: Xt
  }
}, YD = {}, Km = {}, Gm = {};
function ve(n) {
  for (var {
    type: e,
    names: t,
    props: r,
    handler: i,
    htmlBuilder: s,
    mathmlBuilder: o
  } = n, l = {
    type: e,
    numArgs: r.numArgs,
    argTypes: r.argTypes,
    allowedInArgument: !!r.allowedInArgument,
    allowedInText: !!r.allowedInText,
    allowedInMath: r.allowedInMath === void 0 ? !0 : r.allowedInMath,
    numOptionalArgs: r.numOptionalArgs || 0,
    infix: !!r.infix,
    primitive: !!r.primitive,
    handler: i
  }, a = 0; a < t.length; ++a)
    YD[t[a]] = l;
  e && (s && (Km[e] = s), o && (Gm[e] = o));
}
function Va(n) {
  var {
    type: e,
    htmlBuilder: t,
    mathmlBuilder: r
  } = n;
  ve({
    type: e,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: t,
    mathmlBuilder: r
  });
}
var Ym = function(e) {
  return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
}, cn = function(e) {
  return e.type === "ordgroup" ? e.body : [e];
}, go = H.makeSpan, zoe = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], Foe = ["rightmost", "mrel", "mclose", "mpunct"], Hoe = {
  display: We.DISPLAY,
  text: We.TEXT,
  script: We.SCRIPT,
  scriptscript: We.SCRIPTSCRIPT
}, $oe = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, xn = function(e, t, r, i) {
  i === void 0 && (i = [null, null]);
  for (var s = [], o = 0; o < e.length; o++) {
    var l = ht(e[o], t);
    if (l instanceof _d) {
      var a = l.children;
      s.push(...a);
    } else
      s.push(l);
  }
  if (H.tryCombineChars(s), !r)
    return s;
  var c = t;
  if (e.length === 1) {
    var u = e[0];
    u.type === "sizing" ? c = t.havingSize(u.size) : u.type === "styling" && (c = t.havingStyle(Hoe[u.style]));
  }
  var h = go([i[0] || "leftmost"], [], t), f = go([i[1] || "rightmost"], [], t), d = r === "root";
  return y9(s, (p, m) => {
    var g = m.classes[0], b = p.classes[0];
    g === "mbin" && Be.contains(Foe, b) ? m.classes[0] = "mord" : b === "mbin" && Be.contains(zoe, g) && (p.classes[0] = "mord");
  }, {
    node: h
  }, f, d), y9(s, (p, m) => {
    var g = L5(m), b = L5(p), w = g && b ? p.hasClass("mtight") ? Boe[g][b] : Loe[g][b] : null;
    if (w)
      return H.makeGlue(w, c);
  }, {
    node: h
  }, f, d), s;
}, y9 = function n(e, t, r, i, s) {
  i && e.push(i);
  for (var o = 0; o < e.length; o++) {
    var l = e[o], a = JD(l);
    if (a) {
      n(a.children, t, r, null, s);
      continue;
    }
    var c = !l.hasClass("mspace");
    if (c) {
      var u = t(l, r.node);
      u && (r.insertAfter ? r.insertAfter(u) : (e.unshift(u), o++));
    }
    c ? r.node = l : s && l.hasClass("newline") && (r.node = go(["leftmost"])), r.insertAfter = /* @__PURE__ */ ((h) => (f) => {
      e.splice(h + 1, 0, f), o++;
    })(o);
  }
  i && e.pop();
}, JD = function(e) {
  return e instanceof _d || e instanceof p7 || e instanceof Ld && e.hasClass("enclosing") ? e : null;
}, Voe = function n(e, t) {
  var r = JD(e);
  if (r) {
    var i = r.children;
    if (i.length) {
      if (t === "right")
        return n(i[i.length - 1], "right");
      if (t === "left")
        return n(i[0], "left");
    }
  }
  return e;
}, L5 = function(e, t) {
  return e ? (t && (e = Voe(e, t)), $oe[e.classes[0]] || null) : null;
}, rd = function(e, t) {
  var r = ["nulldelimiter"].concat(e.baseSizingClasses());
  return go(t.concat(r));
}, ht = function(e, t, r) {
  if (!e)
    return go();
  if (Km[e.type]) {
    var i = Km[e.type](e, t);
    if (r && t.size !== r.size) {
      i = go(t.sizingClasses(r), [i], t);
      var s = t.sizeMultiplier / r.sizeMultiplier;
      i.height *= s, i.depth *= s;
    }
    return i;
  } else
    throw new se("Got group of unknown type: '" + e.type + "'");
};
function _0(n, e) {
  var t = go(["base"], n, e), r = go(["strut"]);
  return r.style.height = fe(t.height + t.depth), t.depth && (r.style.verticalAlign = fe(-t.depth)), t.children.unshift(r), t;
}
function B5(n, e) {
  var t = null;
  n.length === 1 && n[0].type === "tag" && (t = n[0].tag, n = n[0].body);
  var r = xn(n, e, "root"), i;
  r.length === 2 && r[1].hasClass("tag") && (i = r.pop());
  for (var s = [], o = [], l = 0; l < r.length; l++)
    if (o.push(r[l]), r[l].hasClass("mbin") || r[l].hasClass("mrel") || r[l].hasClass("allowbreak")) {
      for (var a = !1; l < r.length - 1 && r[l + 1].hasClass("mspace") && !r[l + 1].hasClass("newline"); )
        l++, o.push(r[l]), r[l].hasClass("nobreak") && (a = !0);
      a || (s.push(_0(o, e)), o = []);
    } else r[l].hasClass("newline") && (o.pop(), o.length > 0 && (s.push(_0(o, e)), o = []), s.push(r[l]));
  o.length > 0 && s.push(_0(o, e));
  var c;
  t ? (c = _0(xn(t, e, !0)), c.classes = ["tag"], s.push(c)) : i && s.push(i);
  var u = go(["katex-html"], s);
  if (u.setAttribute("aria-hidden", "true"), c) {
    var h = c.children[0];
    h.style.height = fe(u.height + u.depth), u.depth && (h.style.verticalAlign = fe(-u.depth));
  }
  return u;
}
function XD(n) {
  return new _d(n);
}
class Gr {
  constructor(e, t, r) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = t || [], this.classes = r || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && e.setAttribute(t, this.attributes[t]);
    this.classes.length > 0 && (e.className = vl(this.classes));
    for (var r = 0; r < this.children.length; r++)
      if (this.children[r] instanceof gs && this.children[r + 1] instanceof gs) {
        for (var i = this.children[r].toText() + this.children[++r].toText(); this.children[r + 1] instanceof gs; )
          i += this.children[++r].toText();
        e.appendChild(new gs(i).toNode());
      } else
        e.appendChild(this.children[r].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var e = "<" + this.type;
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="', e += Be.escape(this.attributes[t]), e += '"');
    this.classes.length > 0 && (e += ' class ="' + Be.escape(vl(this.classes)) + '"'), e += ">";
    for (var r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
}
class gs {
  constructor(e) {
    this.text = void 0, this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return Be.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class qoe {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(e) {
    this.width = void 0, this.character = void 0, this.width = e, e >= 0.05555 && e <= 0.05556 ? this.character = " " : e >= 0.1666 && e <= 0.1667 ? this.character = " " : e >= 0.2222 && e <= 0.2223 ? this.character = " " : e >= 0.2777 && e <= 0.2778 ? this.character = "  " : e >= -0.05556 && e <= -0.05555 ? this.character = " ⁣" : e >= -0.1667 && e <= -0.1666 ? this.character = " ⁣" : e >= -0.2223 && e <= -0.2222 ? this.character = " ⁣" : e >= -0.2778 && e <= -0.2777 ? this.character = " ⁣" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return e.setAttribute("width", fe(this.width)), e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + fe(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var ne = {
  MathNode: Gr,
  TextNode: gs,
  SpaceNode: qoe,
  newDocumentFragment: XD
}, Si = function(e, t, r) {
  return zt[t][e] && zt[t][e].replace && e.charCodeAt(0) !== 55349 && !(WD.hasOwnProperty(e) && r && (r.fontFamily && r.fontFamily.slice(4, 6) === "tt" || r.font && r.font.slice(4, 6) === "tt")) && (e = zt[t][e].replace), new ne.TextNode(e);
}, g7 = function(e) {
  return e.length === 1 ? e[0] : new ne.MathNode("mrow", e);
}, y7 = function(e, t) {
  if (t.fontFamily === "texttt")
    return "monospace";
  if (t.fontFamily === "textsf")
    return t.fontShape === "textit" && t.fontWeight === "textbf" ? "sans-serif-bold-italic" : t.fontShape === "textit" ? "sans-serif-italic" : t.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (t.fontShape === "textit" && t.fontWeight === "textbf")
    return "bold-italic";
  if (t.fontShape === "textit")
    return "italic";
  if (t.fontWeight === "textbf")
    return "bold";
  var r = t.font;
  if (!r || r === "mathnormal")
    return null;
  var i = e.mode;
  if (r === "mathit")
    return "italic";
  if (r === "boldsymbol")
    return e.type === "textord" ? "bold" : "bold-italic";
  if (r === "mathbf")
    return "bold";
  if (r === "mathbb")
    return "double-struck";
  if (r === "mathsfit")
    return "sans-serif-italic";
  if (r === "mathfrak")
    return "fraktur";
  if (r === "mathscr" || r === "mathcal")
    return "script";
  if (r === "mathsf")
    return "sans-serif";
  if (r === "mathtt")
    return "monospace";
  var s = e.text;
  if (Be.contains(["\\imath", "\\jmath"], s))
    return null;
  zt[i][s] && zt[i][s].replace && (s = zt[i][s].replace);
  var o = H.fontMap[r].fontName;
  return d7(s, o, i) ? H.fontMap[r].variant : null;
};
function c4(n) {
  if (!n)
    return !1;
  if (n.type === "mi" && n.children.length === 1) {
    var e = n.children[0];
    return e instanceof gs && e.text === ".";
  } else if (n.type === "mo" && n.children.length === 1 && n.getAttribute("separator") === "true" && n.getAttribute("lspace") === "0em" && n.getAttribute("rspace") === "0em") {
    var t = n.children[0];
    return t instanceof gs && t.text === ",";
  } else
    return !1;
}
var Pr = function(e, t, r) {
  if (e.length === 1) {
    var i = Rt(e[0], t);
    return r && i instanceof Gr && i.type === "mo" && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
  }
  for (var s = [], o, l = 0; l < e.length; l++) {
    var a = Rt(e[l], t);
    if (a instanceof Gr && o instanceof Gr) {
      if (a.type === "mtext" && o.type === "mtext" && a.getAttribute("mathvariant") === o.getAttribute("mathvariant")) {
        o.children.push(...a.children);
        continue;
      } else if (a.type === "mn" && o.type === "mn") {
        o.children.push(...a.children);
        continue;
      } else if (c4(a) && o.type === "mn") {
        o.children.push(...a.children);
        continue;
      } else if (a.type === "mn" && c4(o))
        a.children = [...o.children, ...a.children], s.pop();
      else if ((a.type === "msup" || a.type === "msub") && a.children.length >= 1 && (o.type === "mn" || c4(o))) {
        var c = a.children[0];
        c instanceof Gr && c.type === "mn" && (c.children = [...o.children, ...c.children], s.pop());
      } else if (o.type === "mi" && o.children.length === 1) {
        var u = o.children[0];
        if (u instanceof gs && u.text === "̸" && (a.type === "mo" || a.type === "mi" || a.type === "mn")) {
          var h = a.children[0];
          h instanceof gs && h.text.length > 0 && (h.text = h.text.slice(0, 1) + "̸" + h.text.slice(1), s.pop());
        }
      }
    }
    s.push(a), o = a;
  }
  return s;
}, xl = function(e, t, r) {
  return g7(Pr(e, t, r));
}, Rt = function(e, t) {
  if (!e)
    return new ne.MathNode("mrow");
  if (Gm[e.type]) {
    var r = Gm[e.type](e, t);
    return r;
  } else
    throw new se("Got group of unknown type: '" + e.type + "'");
};
function b9(n, e, t, r, i) {
  var s = Pr(n, t), o;
  s.length === 1 && s[0] instanceof Gr && Be.contains(["mrow", "mtable"], s[0].type) ? o = s[0] : o = new ne.MathNode("mrow", s);
  var l = new ne.MathNode("annotation", [new ne.TextNode(e)]);
  l.setAttribute("encoding", "application/x-tex");
  var a = new ne.MathNode("semantics", [o, l]), c = new ne.MathNode("math", [a]);
  c.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), r && c.setAttribute("display", "block");
  var u = i ? "katex" : "katex-mathml";
  return H.makeSpan([u], [c]);
}
var ZD = function(e) {
  return new Ys({
    style: e.displayMode ? We.DISPLAY : We.TEXT,
    maxSize: e.maxSize,
    minRuleThickness: e.minRuleThickness
  });
}, QD = function(e, t) {
  if (t.displayMode) {
    var r = ["katex-display"];
    t.leqno && r.push("leqno"), t.fleqn && r.push("fleqn"), e = H.makeSpan(r, [e]);
  }
  return e;
}, Woe = function(e, t, r) {
  var i = ZD(r), s;
  if (r.output === "mathml")
    return b9(e, t, i, r.displayMode, !0);
  if (r.output === "html") {
    var o = B5(e, i);
    s = H.makeSpan(["katex"], [o]);
  } else {
    var l = b9(e, t, i, r.displayMode, !1), a = B5(e, i);
    s = H.makeSpan(["katex"], [l, a]);
  }
  return QD(s, r);
}, joe = function(e, t, r) {
  var i = ZD(r), s = B5(e, i), o = H.makeSpan(["katex"], [s]);
  return QD(o, r);
}, Uoe = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "←",
  underleftarrow: "←",
  xleftarrow: "←",
  overrightarrow: "→",
  underrightarrow: "→",
  xrightarrow: "→",
  underbrace: "⏟",
  overbrace: "⏞",
  overgroup: "⏠",
  undergroup: "⏡",
  overleftrightarrow: "↔",
  underleftrightarrow: "↔",
  xleftrightarrow: "↔",
  Overrightarrow: "⇒",
  xRightarrow: "⇒",
  overleftharpoon: "↼",
  xleftharpoonup: "↼",
  overrightharpoon: "⇀",
  xrightharpoonup: "⇀",
  xLeftarrow: "⇐",
  xLeftrightarrow: "⇔",
  xhookleftarrow: "↩",
  xhookrightarrow: "↪",
  xmapsto: "↦",
  xrightharpoondown: "⇁",
  xleftharpoondown: "↽",
  xrightleftharpoons: "⇌",
  xleftrightharpoons: "⇋",
  xtwoheadleftarrow: "↞",
  xtwoheadrightarrow: "↠",
  xlongequal: "=",
  xtofrom: "⇄",
  xrightleftarrows: "⇄",
  xrightequilibrium: "⇌",
  // Not a perfect match.
  xleftequilibrium: "⇋",
  // None better available.
  "\\cdrightarrow": "→",
  "\\cdleftarrow": "←",
  "\\cdlongequal": "="
}, Koe = function(e) {
  var t = new ne.MathNode("mo", [new ne.TextNode(Uoe[e.replace(/^\\/, "")])]);
  return t.setAttribute("stretchy", "true"), t;
}, Goe = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, Yoe = function(e) {
  return e.type === "ordgroup" ? e.body.length : 1;
}, Joe = function(e, t) {
  function r() {
    var l = 4e5, a = e.label.slice(1);
    if (Be.contains(["widehat", "widecheck", "widetilde", "utilde"], a)) {
      var c = e, u = Yoe(c.base), h, f, d;
      if (u > 5)
        a === "widehat" || a === "widecheck" ? (h = 420, l = 2364, d = 0.42, f = a + "4") : (h = 312, l = 2340, d = 0.34, f = "tilde4");
      else {
        var p = [1, 1, 2, 2, 3, 3][u];
        a === "widehat" || a === "widecheck" ? (l = [0, 1062, 2364, 2364, 2364][p], h = [0, 239, 300, 360, 420][p], d = [0, 0.24, 0.3, 0.3, 0.36, 0.42][p], f = a + p) : (l = [0, 600, 1033, 2339, 2340][p], h = [0, 260, 286, 306, 312][p], d = [0, 0.26, 0.286, 0.3, 0.306, 0.34][p], f = "tilde" + p);
      }
      var m = new wl(f), g = new mo([m], {
        width: "100%",
        height: fe(d),
        viewBox: "0 0 " + l + " " + h,
        preserveAspectRatio: "none"
      });
      return {
        span: H.makeSvgSpan([], [g], t),
        minWidth: 0,
        height: d
      };
    } else {
      var b = [], w = Goe[a], [k, C, M] = w, T = M / 1e3, N = k.length, B, $;
      if (N === 1) {
        var R = w[3];
        B = ["hide-tail"], $ = [R];
      } else if (N === 2)
        B = ["halfarrow-left", "halfarrow-right"], $ = ["xMinYMin", "xMaxYMin"];
      else if (N === 3)
        B = ["brace-left", "brace-center", "brace-right"], $ = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + N + " children.");
      for (var V = 0; V < N; V++) {
        var z = new wl(k[V]), ue = new mo([z], {
          width: "400em",
          height: fe(T),
          viewBox: "0 0 " + l + " " + M,
          preserveAspectRatio: $[V] + " slice"
        }), ie = H.makeSvgSpan([B[V]], [ue], t);
        if (N === 1)
          return {
            span: ie,
            minWidth: C,
            height: T
          };
        ie.style.height = fe(T), b.push(ie);
      }
      return {
        span: H.makeSpan(["stretchy"], b, t),
        minWidth: C,
        height: T
      };
    }
  }
  var {
    span: i,
    minWidth: s,
    height: o
  } = r();
  return i.height = o, i.style.height = fe(o), s > 0 && (i.style.minWidth = fe(s)), i;
}, Xoe = function(e, t, r, i, s) {
  var o, l = e.height + e.depth + r + i;
  if (/fbox|color|angl/.test(t)) {
    if (o = H.makeSpan(["stretchy", t], [], s), t === "fbox") {
      var a = s.color && s.getColor();
      a && (o.style.borderColor = a);
    }
  } else {
    var c = [];
    /^[bx]cancel$/.test(t) && c.push(new P5({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(t) && c.push(new P5({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var u = new mo(c, {
      width: "100%",
      height: fe(l)
    });
    o = H.makeSvgSpan([], [u], s);
  }
  return o.height = l, o.style.height = fe(l), o;
}, yo = {
  encloseSpan: Xoe,
  mathMLnode: Koe,
  svgSpan: Joe
};
function Qe(n, e) {
  if (!n || n.type !== e)
    throw new Error("Expected node of type " + e + ", but got " + (n ? "node of type " + n.type : String(n)));
  return n;
}
function b7(n) {
  var e = hg(n);
  if (!e)
    throw new Error("Expected node of symbol group type, but got " + (n ? "node of type " + n.type : String(n)));
  return e;
}
function hg(n) {
  return n && (n.type === "atom" || koe.hasOwnProperty(n.type)) ? n : null;
}
var v7 = (n, e) => {
  var t, r, i;
  n && n.type === "supsub" ? (r = Qe(n.base, "accent"), t = r.base, n.base = t, i = woe(ht(n, e)), n.base = r) : (r = Qe(n, "accent"), t = r.base);
  var s = ht(t, e.havingCrampedStyle()), o = r.isShifty && Be.isCharacterBox(t), l = 0;
  if (o) {
    var a = Be.getBaseElem(t), c = ht(a, e.havingCrampedStyle());
    l = h9(c).skew;
  }
  var u = r.label === "\\c", h = u ? s.height + s.depth : Math.min(s.height, e.fontMetrics().xHeight), f;
  if (r.isStretchy)
    f = yo.svgSpan(r, e), f = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "elem",
        elem: f,
        wrapperClasses: ["svg-align"],
        wrapperStyle: l > 0 ? {
          width: "calc(100% - " + fe(2 * l) + ")",
          marginLeft: fe(2 * l)
        } : void 0
      }]
    }, e);
  else {
    var d, p;
    r.label === "\\vec" ? (d = H.staticSvg("vec", e), p = H.svgData.vec[1]) : (d = H.makeOrd({
      mode: r.mode,
      text: r.label
    }, e, "textord"), d = h9(d), d.italic = 0, p = d.width, u && (h += d.depth)), f = H.makeSpan(["accent-body"], [d]);
    var m = r.label === "\\textcircled";
    m && (f.classes.push("accent-full"), h = s.height);
    var g = l;
    m || (g -= p / 2), f.style.left = fe(g), r.label === "\\textcircled" && (f.style.top = ".2em"), f = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "kern",
        size: -h
      }, {
        type: "elem",
        elem: f
      }]
    }, e);
  }
  var b = H.makeSpan(["mord", "accent"], [f], e);
  return i ? (i.children[0] = b, i.height = Math.max(b.height, i.height), i.classes[0] = "mord", i) : b;
}, eN = (n, e) => {
  var t = n.isStretchy ? yo.mathMLnode(n.label) : new ne.MathNode("mo", [Si(n.label, n.mode)]), r = new ne.MathNode("mover", [Rt(n.base, e), t]);
  return r.setAttribute("accent", "true"), r;
}, Zoe = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((n) => "\\" + n).join("|"));
ve({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var t = Ym(e[0]), r = !Zoe.test(n.funcName), i = !r || n.funcName === "\\widehat" || n.funcName === "\\widetilde" || n.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: n.parser.mode,
      label: n.funcName,
      isStretchy: r,
      isShifty: i,
      base: t
    };
  },
  htmlBuilder: v7,
  mathmlBuilder: eN
});
ve({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (n, e) => {
    var t = e[0], r = n.parser.mode;
    return r === "math" && (n.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + n.funcName + " works only in text mode"), r = "text"), {
      type: "accent",
      mode: r,
      label: n.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: t
    };
  },
  htmlBuilder: v7,
  mathmlBuilder: eN
});
ve({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "accentUnder",
      mode: t.mode,
      label: r,
      base: i
    };
  },
  htmlBuilder: (n, e) => {
    var t = ht(n.base, e), r = yo.svgSpan(n, e), i = n.label === "\\utilde" ? 0.12 : 0, s = H.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return H.makeSpan(["mord", "accentunder"], [s], e);
  },
  mathmlBuilder: (n, e) => {
    var t = yo.mathMLnode(n.label), r = new ne.MathNode("munder", [Rt(n.base, e), t]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
var L0 = (n) => {
  var e = new ne.MathNode("mpadded", n ? [n] : []);
  return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
};
ve({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n;
    return {
      type: "xArrow",
      mode: r.mode,
      label: i,
      body: e[0],
      below: t[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(n, e) {
    var t = e.style, r = e.havingStyle(t.sup()), i = H.wrapFragment(ht(n.body, r, e), e), s = n.label.slice(0, 2) === "\\x" ? "x" : "cd";
    i.classes.push(s + "-arrow-pad");
    var o;
    n.below && (r = e.havingStyle(t.sub()), o = H.wrapFragment(ht(n.below, r, e), e), o.classes.push(s + "-arrow-pad"));
    var l = yo.svgSpan(n, e), a = -e.fontMetrics().axisHeight + 0.5 * l.height, c = -e.fontMetrics().axisHeight - 0.5 * l.height - 0.111;
    (i.depth > 0.25 || n.label === "\\xleftequilibrium") && (c -= i.depth);
    var u;
    if (o) {
      var h = -e.fontMetrics().axisHeight + o.height + 0.5 * l.height + 0.111;
      u = H.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: c
        }, {
          type: "elem",
          elem: l,
          shift: a
        }, {
          type: "elem",
          elem: o,
          shift: h
        }]
      }, e);
    } else
      u = H.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: c
        }, {
          type: "elem",
          elem: l,
          shift: a
        }]
      }, e);
    return u.children[0].children[0].children[1].classes.push("svg-align"), H.makeSpan(["mrel", "x-arrow"], [u], e);
  },
  mathmlBuilder(n, e) {
    var t = yo.mathMLnode(n.label);
    t.setAttribute("minsize", n.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var r;
    if (n.body) {
      var i = L0(Rt(n.body, e));
      if (n.below) {
        var s = L0(Rt(n.below, e));
        r = new ne.MathNode("munderover", [t, s, i]);
      } else
        r = new ne.MathNode("mover", [t, i]);
    } else if (n.below) {
      var o = L0(Rt(n.below, e));
      r = new ne.MathNode("munder", [t, o]);
    } else
      r = L0(), r = new ne.MathNode("mover", [t, r]);
    return r;
  }
});
var Qoe = H.makeSpan;
function tN(n, e) {
  var t = xn(n.body, e, !0);
  return Qoe([n.mclass], t, e);
}
function nN(n, e) {
  var t, r = Pr(n.body, e);
  return n.mclass === "minner" ? t = new ne.MathNode("mpadded", r) : n.mclass === "mord" ? n.isCharacterBox ? (t = r[0], t.type = "mi") : t = new ne.MathNode("mi", r) : (n.isCharacterBox ? (t = r[0], t.type = "mo") : t = new ne.MathNode("mo", r), n.mclass === "mbin" ? (t.attributes.lspace = "0.22em", t.attributes.rspace = "0.22em") : n.mclass === "mpunct" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0.17em") : n.mclass === "mopen" || n.mclass === "mclose" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0em") : n.mclass === "minner" && (t.attributes.lspace = "0.0556em", t.attributes.width = "+0.1111em")), t;
}
ve({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "mclass",
      mode: t.mode,
      mclass: "m" + r.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: cn(i),
      isCharacterBox: Be.isCharacterBox(i)
    };
  },
  htmlBuilder: tN,
  mathmlBuilder: nN
});
var fg = (n) => {
  var e = n.type === "ordgroup" && n.body.length ? n.body[0] : n;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
ve({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "mclass",
      mode: t.mode,
      mclass: fg(e[0]),
      body: cn(e[1]),
      isCharacterBox: Be.isCharacterBox(e[1])
    };
  }
});
ve({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[1], s = e[0], o;
    r !== "\\stackrel" ? o = fg(i) : o = "mrel";
    var l = {
      type: "op",
      mode: i.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: r !== "\\stackrel",
      body: cn(i)
    }, a = {
      type: "supsub",
      mode: s.mode,
      base: l,
      sup: r === "\\underset" ? null : s,
      sub: r === "\\underset" ? s : null
    };
    return {
      type: "mclass",
      mode: t.mode,
      mclass: o,
      body: [a],
      isCharacterBox: Be.isCharacterBox(a)
    };
  },
  htmlBuilder: tN,
  mathmlBuilder: nN
});
ve({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "pmb",
      mode: t.mode,
      mclass: fg(e[0]),
      body: cn(e[0])
    };
  },
  htmlBuilder(n, e) {
    var t = xn(n.body, e, !0), r = H.makeSpan([n.mclass], t, e);
    return r.style.textShadow = "0.02em 0.01em 0.04px", r;
  },
  mathmlBuilder(n, e) {
    var t = Pr(n.body, e), r = new ne.MathNode("mstyle", t);
    return r.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), r;
  }
});
var ele = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, v9 = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), w9 = (n) => n.type === "textord" && n.text === "@", tle = (n, e) => (n.type === "mathord" || n.type === "atom") && n.text === e;
function nle(n, e, t) {
  var r = ele[n];
  switch (r) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return t.callFunction(r, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var i = t.callFunction("\\\\cdleft", [e[0]], []), s = {
        type: "atom",
        text: r,
        mode: "math",
        family: "rel"
      }, o = t.callFunction("\\Big", [s], []), l = t.callFunction("\\\\cdright", [e[1]], []), a = {
        type: "ordgroup",
        mode: "math",
        body: [i, o, l]
      };
      return t.callFunction("\\\\cdparent", [a], []);
    }
    case "\\\\cdlongequal":
      return t.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var c = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return t.callFunction("\\Big", [c], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function rle(n) {
  var e = [];
  for (n.gullet.beginGroup(), n.gullet.macros.set("\\cr", "\\\\\\relax"), n.gullet.beginGroup(); ; ) {
    e.push(n.parseExpression(!1, "\\\\")), n.gullet.endGroup(), n.gullet.beginGroup();
    var t = n.fetch().text;
    if (t === "&" || t === "\\\\")
      n.consume();
    else if (t === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new se("Expected \\\\ or \\cr or \\end", n.nextToken);
  }
  for (var r = [], i = [r], s = 0; s < e.length; s++) {
    for (var o = e[s], l = v9(), a = 0; a < o.length; a++)
      if (!w9(o[a]))
        l.body.push(o[a]);
      else {
        r.push(l), a += 1;
        var c = b7(o[a]).text, u = new Array(2);
        if (u[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, u[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(c) > -1)) if ("<>AV".indexOf(c) > -1)
          for (var h = 0; h < 2; h++) {
            for (var f = !0, d = a + 1; d < o.length; d++) {
              if (tle(o[d], c)) {
                f = !1, a = d;
                break;
              }
              if (w9(o[d]))
                throw new se("Missing a " + c + " character to complete a CD arrow.", o[d]);
              u[h].body.push(o[d]);
            }
            if (f)
              throw new se("Missing a " + c + " character to complete a CD arrow.", o[a]);
          }
        else
          throw new se('Expected one of "<>AV=|." after @', o[a]);
        var p = nle(c, u, n), m = {
          type: "styling",
          body: [p],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        r.push(m), l = v9();
      }
    s % 2 === 0 ? r.push(l) : r.shift(), r = [], i.push(r);
  }
  n.gullet.endGroup(), n.gullet.endGroup();
  var g = new Array(i[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: i,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: g,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(i.length + 1).fill([])
  };
}
ve({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n;
    return {
      type: "cdlabel",
      mode: t.mode,
      side: r.slice(4),
      label: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = e.havingStyle(e.style.sup()), r = H.wrapFragment(ht(n.label, t, e), e);
    return r.classes.push("cd-label-" + n.side), r.style.bottom = fe(0.8 - r.depth), r.height = 0, r.depth = 0, r;
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mrow", [Rt(n.label, e)]);
    return t = new ne.MathNode("mpadded", [t]), t.setAttribute("width", "0"), n.side === "left" && t.setAttribute("lspace", "-1width"), t.setAttribute("voffset", "0.7em"), t = new ne.MathNode("mstyle", [t]), t.setAttribute("displaystyle", "false"), t.setAttribute("scriptlevel", "1"), t;
  }
});
ve({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "cdlabelparent",
      mode: t.mode,
      fragment: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = H.wrapFragment(ht(n.fragment, e), e);
    return t.classes.push("cd-vert-arrow"), t;
  },
  mathmlBuilder(n, e) {
    return new ne.MathNode("mrow", [Rt(n.fragment, e)]);
  }
});
ve({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    for (var {
      parser: t
    } = n, r = Qe(e[0], "ordgroup"), i = r.body, s = "", o = 0; o < i.length; o++) {
      var l = Qe(i[o], "textord");
      s += l.text;
    }
    var a = parseInt(s), c;
    if (isNaN(a))
      throw new se("\\@char has non-numeric argument " + s);
    if (a < 0 || a >= 1114111)
      throw new se("\\@char with invalid code point " + s);
    return a <= 65535 ? c = String.fromCharCode(a) : (a -= 65536, c = String.fromCharCode((a >> 10) + 55296, (a & 1023) + 56320)), {
      type: "textord",
      mode: t.mode,
      text: c
    };
  }
});
var rN = (n, e) => {
  var t = xn(n.body, e.withColor(n.color), !1);
  return H.makeFragment(t);
}, iN = (n, e) => {
  var t = Pr(n.body, e.withColor(n.color)), r = new ne.MathNode("mstyle", t);
  return r.setAttribute("mathcolor", n.color), r;
};
ve({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = Qe(e[0], "color-token").color, i = e[1];
    return {
      type: "color",
      mode: t.mode,
      color: r,
      body: cn(i)
    };
  },
  htmlBuilder: rN,
  mathmlBuilder: iN
});
ve({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(n, e) {
    var {
      parser: t,
      breakOnTokenText: r
    } = n, i = Qe(e[0], "color-token").color;
    t.gullet.macros.set("\\current@color", i);
    var s = t.parseExpression(!0, r);
    return {
      type: "color",
      mode: t.mode,
      color: i,
      body: s
    };
  },
  htmlBuilder: rN,
  mathmlBuilder: iN
});
ve({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = r.gullet.future().text === "[" ? r.parseSizeGroup(!0) : null, s = !r.settings.displayMode || !r.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: r.mode,
      newLine: s,
      size: i && Qe(i, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(n, e) {
    var t = H.makeSpan(["mspace"], [], e);
    return n.newLine && (t.classes.push("newline"), n.size && (t.style.marginTop = fe(Qt(n.size, e)))), t;
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mspace");
    return n.newLine && (t.setAttribute("linebreak", "newline"), n.size && t.setAttribute("height", fe(Qt(n.size, e)))), t;
  }
});
var z5 = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, sN = (n) => {
  var e = n.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new se("Expected a control sequence", n);
  return e;
}, ile = (n) => {
  var e = n.gullet.popToken();
  return e.text === "=" && (e = n.gullet.popToken(), e.text === " " && (e = n.gullet.popToken())), e;
}, oN = (n, e, t, r) => {
  var i = n.gullet.macros.get(t.text);
  i == null && (t.noexpand = !0, i = {
    tokens: [t],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !n.gullet.isExpandable(t.text)
  }), n.gullet.macros.set(e, i, r);
};
ve({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    e.consumeSpaces();
    var r = e.fetch();
    if (z5[r.text])
      return (t === "\\global" || t === "\\\\globallong") && (r.text = z5[r.text]), Qe(e.parseFunction(), "internal");
    throw new se("Invalid token after macro prefix", r);
  }
});
ve({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = e.gullet.popToken(), i = r.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(i))
      throw new se("Expected a control sequence", r);
    for (var s = 0, o, l = [[]]; e.gullet.future().text !== "{"; )
      if (r = e.gullet.popToken(), r.text === "#") {
        if (e.gullet.future().text === "{") {
          o = e.gullet.future(), l[s].push("{");
          break;
        }
        if (r = e.gullet.popToken(), !/^[1-9]$/.test(r.text))
          throw new se('Invalid argument number "' + r.text + '"');
        if (parseInt(r.text) !== s + 1)
          throw new se('Argument number "' + r.text + '" out of order');
        s++, l.push([]);
      } else {
        if (r.text === "EOF")
          throw new se("Expected a macro definition");
        l[s].push(r.text);
      }
    var {
      tokens: a
    } = e.gullet.consumeArg();
    return o && a.unshift(o), (t === "\\edef" || t === "\\xdef") && (a = e.gullet.expandTokens(a), a.reverse()), e.gullet.macros.set(i, {
      tokens: a,
      numArgs: s,
      delimiters: l
    }, t === z5[t]), {
      type: "internal",
      mode: e.mode
    };
  }
});
ve({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = sN(e.gullet.popToken());
    e.gullet.consumeSpaces();
    var i = ile(e);
    return oN(e, r, i, t === "\\\\globallet"), {
      type: "internal",
      mode: e.mode
    };
  }
});
ve({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = sN(e.gullet.popToken()), i = e.gullet.popToken(), s = e.gullet.popToken();
    return oN(e, r, s, t === "\\\\globalfuture"), e.gullet.pushToken(s), e.gullet.pushToken(i), {
      type: "internal",
      mode: e.mode
    };
  }
});
var vh = function(e, t, r) {
  var i = zt.math[e] && zt.math[e].replace, s = d7(i || e, t, r);
  if (!s)
    throw new Error("Unsupported symbol " + e + " and font size " + t + ".");
  return s;
}, w7 = function(e, t, r, i) {
  var s = r.havingBaseStyle(t), o = H.makeSpan(i.concat(s.sizingClasses(r)), [e], r), l = s.sizeMultiplier / r.sizeMultiplier;
  return o.height *= l, o.depth *= l, o.maxFontSize = s.sizeMultiplier, o;
}, lN = function(e, t, r) {
  var i = t.havingBaseStyle(r), s = (1 - t.sizeMultiplier / i.sizeMultiplier) * t.fontMetrics().axisHeight;
  e.classes.push("delimcenter"), e.style.top = fe(s), e.height -= s, e.depth += s;
}, sle = function(e, t, r, i, s, o) {
  var l = H.makeSymbol(e, "Main-Regular", s, i), a = w7(l, t, i, o);
  return r && lN(a, i, t), a;
}, ole = function(e, t, r, i) {
  return H.makeSymbol(e, "Size" + t + "-Regular", r, i);
}, aN = function(e, t, r, i, s, o) {
  var l = ole(e, t, s, i), a = w7(H.makeSpan(["delimsizing", "size" + t], [l], i), We.TEXT, i, o);
  return r && lN(a, i, We.TEXT), a;
}, u4 = function(e, t, r) {
  var i;
  t === "Size1-Regular" ? i = "delim-size1" : i = "delim-size4";
  var s = H.makeSpan(["delimsizinginner", i], [H.makeSpan([], [H.makeSymbol(e, t, r)])]);
  return {
    type: "elem",
    elem: s
  };
}, h4 = function(e, t, r) {
  var i = ms["Size4-Regular"][e.charCodeAt(0)] ? ms["Size4-Regular"][e.charCodeAt(0)][4] : ms["Size1-Regular"][e.charCodeAt(0)][4], s = new wl("inner", hoe(e, Math.round(1e3 * t))), o = new mo([s], {
    width: fe(i),
    height: fe(t),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + fe(i),
    viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * t),
    preserveAspectRatio: "xMinYMin"
  }), l = H.makeSvgSpan([], [o], r);
  return l.height = t, l.style.height = fe(t), l.style.width = fe(i), {
    type: "elem",
    elem: l
  };
}, F5 = 8e-3, B0 = {
  type: "kern",
  size: -1 * F5
}, lle = ["|", "\\lvert", "\\rvert", "\\vert"], ale = ["\\|", "\\lVert", "\\rVert", "\\Vert"], cN = function(e, t, r, i, s, o) {
  var l, a, c, u, h = "", f = 0;
  l = c = u = e, a = null;
  var d = "Size1-Regular";
  e === "\\uparrow" ? c = u = "⏐" : e === "\\Uparrow" ? c = u = "‖" : e === "\\downarrow" ? l = c = "⏐" : e === "\\Downarrow" ? l = c = "‖" : e === "\\updownarrow" ? (l = "\\uparrow", c = "⏐", u = "\\downarrow") : e === "\\Updownarrow" ? (l = "\\Uparrow", c = "‖", u = "\\Downarrow") : Be.contains(lle, e) ? (c = "∣", h = "vert", f = 333) : Be.contains(ale, e) ? (c = "∥", h = "doublevert", f = 556) : e === "[" || e === "\\lbrack" ? (l = "⎡", c = "⎢", u = "⎣", d = "Size4-Regular", h = "lbrack", f = 667) : e === "]" || e === "\\rbrack" ? (l = "⎤", c = "⎥", u = "⎦", d = "Size4-Regular", h = "rbrack", f = 667) : e === "\\lfloor" || e === "⌊" ? (c = l = "⎢", u = "⎣", d = "Size4-Regular", h = "lfloor", f = 667) : e === "\\lceil" || e === "⌈" ? (l = "⎡", c = u = "⎢", d = "Size4-Regular", h = "lceil", f = 667) : e === "\\rfloor" || e === "⌋" ? (c = l = "⎥", u = "⎦", d = "Size4-Regular", h = "rfloor", f = 667) : e === "\\rceil" || e === "⌉" ? (l = "⎤", c = u = "⎥", d = "Size4-Regular", h = "rceil", f = 667) : e === "(" || e === "\\lparen" ? (l = "⎛", c = "⎜", u = "⎝", d = "Size4-Regular", h = "lparen", f = 875) : e === ")" || e === "\\rparen" ? (l = "⎞", c = "⎟", u = "⎠", d = "Size4-Regular", h = "rparen", f = 875) : e === "\\{" || e === "\\lbrace" ? (l = "⎧", a = "⎨", u = "⎩", c = "⎪", d = "Size4-Regular") : e === "\\}" || e === "\\rbrace" ? (l = "⎫", a = "⎬", u = "⎭", c = "⎪", d = "Size4-Regular") : e === "\\lgroup" || e === "⟮" ? (l = "⎧", u = "⎩", c = "⎪", d = "Size4-Regular") : e === "\\rgroup" || e === "⟯" ? (l = "⎫", u = "⎭", c = "⎪", d = "Size4-Regular") : e === "\\lmoustache" || e === "⎰" ? (l = "⎧", u = "⎭", c = "⎪", d = "Size4-Regular") : (e === "\\rmoustache" || e === "⎱") && (l = "⎫", u = "⎩", c = "⎪", d = "Size4-Regular");
  var p = vh(l, d, s), m = p.height + p.depth, g = vh(c, d, s), b = g.height + g.depth, w = vh(u, d, s), k = w.height + w.depth, C = 0, M = 1;
  if (a !== null) {
    var T = vh(a, d, s);
    C = T.height + T.depth, M = 2;
  }
  var N = m + k + C, B = Math.max(0, Math.ceil((t - N) / (M * b))), $ = N + B * M * b, R = i.fontMetrics().axisHeight;
  r && (R *= i.sizeMultiplier);
  var V = $ / 2 - R, z = [];
  if (h.length > 0) {
    var ue = $ - m - k, ie = Math.round($ * 1e3), he = foe(h, Math.round(ue * 1e3)), Se = new wl(h, he), ge = (f / 1e3).toFixed(3) + "em", ye = (ie / 1e3).toFixed(3) + "em", ze = new mo([Se], {
      width: ge,
      height: ye,
      viewBox: "0 0 " + f + " " + ie
    }), I = H.makeSvgSpan([], [ze], i);
    I.height = ie / 1e3, I.style.width = ge, I.style.height = ye, z.push({
      type: "elem",
      elem: I
    });
  } else {
    if (z.push(u4(u, d, s)), z.push(B0), a === null) {
      var Ie = $ - m - k + 2 * F5;
      z.push(h4(c, Ie, i));
    } else {
      var Ve = ($ - m - k - C) / 2 + 2 * F5;
      z.push(h4(c, Ve, i)), z.push(B0), z.push(u4(a, d, s)), z.push(B0), z.push(h4(c, Ve, i));
    }
    z.push(B0), z.push(u4(l, d, s));
  }
  var O = i.havingBaseStyle(We.TEXT), dt = H.makeVList({
    positionType: "bottom",
    positionData: V,
    children: z
  }, O);
  return w7(H.makeSpan(["delimsizing", "mult"], [dt], O), We.TEXT, i, o);
}, f4 = 80, d4 = 0.08, p4 = function(e, t, r, i, s) {
  var o = uoe(e, i, r), l = new wl(e, o), a = new mo([l], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: fe(t),
    viewBox: "0 0 400000 " + r,
    preserveAspectRatio: "xMinYMin slice"
  });
  return H.makeSvgSpan(["hide-tail"], [a], s);
}, cle = function(e, t) {
  var r = t.havingBaseSizing(), i = dN("\\surd", e * r.sizeMultiplier, fN, r), s = r.sizeMultiplier, o = Math.max(0, t.minRuleThickness - t.fontMetrics().sqrtRuleThickness), l, a = 0, c = 0, u = 0, h;
  return i.type === "small" ? (u = 1e3 + 1e3 * o + f4, e < 1 ? s = 1 : e < 1.4 && (s = 0.7), a = (1 + o + d4) / s, c = (1 + o) / s, l = p4("sqrtMain", a, u, o, t), l.style.minWidth = "0.853em", h = 0.833 / s) : i.type === "large" ? (u = (1e3 + f4) * mf[i.size], c = (mf[i.size] + o) / s, a = (mf[i.size] + o + d4) / s, l = p4("sqrtSize" + i.size, a, u, o, t), l.style.minWidth = "1.02em", h = 1 / s) : (a = e + o + d4, c = e + o, u = Math.floor(1e3 * e + o) + f4, l = p4("sqrtTall", a, u, o, t), l.style.minWidth = "0.742em", h = 1.056), l.height = c, l.style.height = fe(a), {
    span: l,
    advanceWidth: h,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (t.fontMetrics().sqrtRuleThickness + o) * s
  };
}, uN = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"], ule = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"], hN = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], mf = [0, 1.2, 1.8, 2.4, 3], hle = function(e, t, r, i, s) {
  if (e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle"), Be.contains(uN, e) || Be.contains(hN, e))
    return aN(e, t, !1, r, i, s);
  if (Be.contains(ule, e))
    return cN(e, mf[t], !1, r, i, s);
  throw new se("Illegal delimiter: '" + e + "'");
}, fle = [{
  type: "small",
  style: We.SCRIPTSCRIPT
}, {
  type: "small",
  style: We.SCRIPT
}, {
  type: "small",
  style: We.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], dle = [{
  type: "small",
  style: We.SCRIPTSCRIPT
}, {
  type: "small",
  style: We.SCRIPT
}, {
  type: "small",
  style: We.TEXT
}, {
  type: "stack"
}], fN = [{
  type: "small",
  style: We.SCRIPTSCRIPT
}, {
  type: "small",
  style: We.SCRIPT
}, {
  type: "small",
  style: We.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], ple = function(e) {
  if (e.type === "small")
    return "Main-Regular";
  if (e.type === "large")
    return "Size" + e.size + "-Regular";
  if (e.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + e.type + "' here.");
}, dN = function(e, t, r, i) {
  for (var s = Math.min(2, 3 - i.style.size), o = s; o < r.length && r[o].type !== "stack"; o++) {
    var l = vh(e, ple(r[o]), "math"), a = l.height + l.depth;
    if (r[o].type === "small") {
      var c = i.havingBaseStyle(r[o].style);
      a *= c.sizeMultiplier;
    }
    if (a > t)
      return r[o];
  }
  return r[r.length - 1];
}, pN = function(e, t, r, i, s, o) {
  e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle");
  var l;
  Be.contains(hN, e) ? l = fle : Be.contains(uN, e) ? l = fN : l = dle;
  var a = dN(e, t, l, i);
  return a.type === "small" ? sle(e, a.style, r, i, s, o) : a.type === "large" ? aN(e, a.size, r, i, s, o) : cN(e, t, r, i, s, o);
}, mle = function(e, t, r, i, s, o) {
  var l = i.fontMetrics().axisHeight * i.sizeMultiplier, a = 901, c = 5 / i.fontMetrics().ptPerEm, u = Math.max(t - l, r + l), h = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    u / 500 * a,
    2 * u - c
  );
  return pN(e, h, !0, i, s, o);
}, oo = {
  sqrtImage: cle,
  sizedDelim: hle,
  sizeToMaxHeight: mf,
  customSizedDelim: pN,
  leftRightDelim: mle
}, x9 = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, gle = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function dg(n, e) {
  var t = hg(n);
  if (t && Be.contains(gle, t.text))
    return t;
  throw t ? new se("Invalid delimiter '" + t.text + "' after '" + e.funcName + "'", n) : new se("Invalid delimiter type '" + n.type + "'", n);
}
ve({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (n, e) => {
    var t = dg(e[0], n);
    return {
      type: "delimsizing",
      mode: n.parser.mode,
      size: x9[n.funcName].size,
      mclass: x9[n.funcName].mclass,
      delim: t.text
    };
  },
  htmlBuilder: (n, e) => n.delim === "." ? H.makeSpan([n.mclass]) : oo.sizedDelim(n.delim, n.size, e, n.mode, [n.mclass]),
  mathmlBuilder: (n) => {
    var e = [];
    n.delim !== "." && e.push(Si(n.delim, n.mode));
    var t = new ne.MathNode("mo", e);
    n.mclass === "mopen" || n.mclass === "mclose" ? t.setAttribute("fence", "true") : t.setAttribute("fence", "false"), t.setAttribute("stretchy", "true");
    var r = fe(oo.sizeToMaxHeight[n.size]);
    return t.setAttribute("minsize", r), t.setAttribute("maxsize", r), t;
  }
});
function k9(n) {
  if (!n.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
ve({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = n.parser.gullet.macros.get("\\current@color");
    if (t && typeof t != "string")
      throw new se("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: n.parser.mode,
      delim: dg(e[0], n).text,
      color: t
      // undefined if not set via \color
    };
  }
});
ve({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = dg(e[0], n), r = n.parser;
    ++r.leftrightDepth;
    var i = r.parseExpression(!1);
    --r.leftrightDepth, r.expect("\\right", !1);
    var s = Qe(r.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: r.mode,
      body: i,
      left: t.text,
      right: s.delim,
      rightColor: s.color
    };
  },
  htmlBuilder: (n, e) => {
    k9(n);
    for (var t = xn(n.body, e, !0, ["mopen", "mclose"]), r = 0, i = 0, s = !1, o = 0; o < t.length; o++)
      t[o].isMiddle ? s = !0 : (r = Math.max(t[o].height, r), i = Math.max(t[o].depth, i));
    r *= e.sizeMultiplier, i *= e.sizeMultiplier;
    var l;
    if (n.left === "." ? l = rd(e, ["mopen"]) : l = oo.leftRightDelim(n.left, r, i, e, n.mode, ["mopen"]), t.unshift(l), s)
      for (var a = 1; a < t.length; a++) {
        var c = t[a], u = c.isMiddle;
        u && (t[a] = oo.leftRightDelim(u.delim, r, i, u.options, n.mode, []));
      }
    var h;
    if (n.right === ".")
      h = rd(e, ["mclose"]);
    else {
      var f = n.rightColor ? e.withColor(n.rightColor) : e;
      h = oo.leftRightDelim(n.right, r, i, f, n.mode, ["mclose"]);
    }
    return t.push(h), H.makeSpan(["minner"], t, e);
  },
  mathmlBuilder: (n, e) => {
    k9(n);
    var t = Pr(n.body, e);
    if (n.left !== ".") {
      var r = new ne.MathNode("mo", [Si(n.left, n.mode)]);
      r.setAttribute("fence", "true"), t.unshift(r);
    }
    if (n.right !== ".") {
      var i = new ne.MathNode("mo", [Si(n.right, n.mode)]);
      i.setAttribute("fence", "true"), n.rightColor && i.setAttribute("mathcolor", n.rightColor), t.push(i);
    }
    return g7(t);
  }
});
ve({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = dg(e[0], n);
    if (!n.parser.leftrightDepth)
      throw new se("\\middle without preceding \\left", t);
    return {
      type: "middle",
      mode: n.parser.mode,
      delim: t.text
    };
  },
  htmlBuilder: (n, e) => {
    var t;
    if (n.delim === ".")
      t = rd(e, []);
    else {
      t = oo.sizedDelim(n.delim, 1, e, n.mode, []);
      var r = {
        delim: n.delim,
        options: e
      };
      t.isMiddle = r;
    }
    return t;
  },
  mathmlBuilder: (n, e) => {
    var t = n.delim === "\\vert" || n.delim === "|" ? Si("|", "text") : Si(n.delim, n.mode), r = new ne.MathNode("mo", [t]);
    return r.setAttribute("fence", "true"), r.setAttribute("lspace", "0.05em"), r.setAttribute("rspace", "0.05em"), r;
  }
});
var x7 = (n, e) => {
  var t = H.wrapFragment(ht(n.body, e), e), r = n.label.slice(1), i = e.sizeMultiplier, s, o = 0, l = Be.isCharacterBox(n.body);
  if (r === "sout")
    s = H.makeSpan(["stretchy", "sout"]), s.height = e.fontMetrics().defaultRuleThickness / i, o = -0.5 * e.fontMetrics().xHeight;
  else if (r === "phase") {
    var a = Qt({
      number: 0.6,
      unit: "pt"
    }, e), c = Qt({
      number: 0.35,
      unit: "ex"
    }, e), u = e.havingBaseSizing();
    i = i / u.sizeMultiplier;
    var h = t.height + t.depth + a + c;
    t.style.paddingLeft = fe(h / 2 + a);
    var f = Math.floor(1e3 * h * i), d = aoe(f), p = new mo([new wl("phase", d)], {
      width: "400em",
      height: fe(f / 1e3),
      viewBox: "0 0 400000 " + f,
      preserveAspectRatio: "xMinYMin slice"
    });
    s = H.makeSvgSpan(["hide-tail"], [p], e), s.style.height = fe(h), o = t.depth + a + c;
  } else {
    /cancel/.test(r) ? l || t.classes.push("cancel-pad") : r === "angl" ? t.classes.push("anglpad") : t.classes.push("boxpad");
    var m = 0, g = 0, b = 0;
    /box/.test(r) ? (b = Math.max(
      e.fontMetrics().fboxrule,
      // default
      e.minRuleThickness
      // User override.
    ), m = e.fontMetrics().fboxsep + (r === "colorbox" ? 0 : b), g = m) : r === "angl" ? (b = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness), m = 4 * b, g = Math.max(0, 0.25 - t.depth)) : (m = l ? 0.2 : 0, g = m), s = yo.encloseSpan(t, r, m, g, e), /fbox|boxed|fcolorbox/.test(r) ? (s.style.borderStyle = "solid", s.style.borderWidth = fe(b)) : r === "angl" && b !== 0.049 && (s.style.borderTopWidth = fe(b), s.style.borderRightWidth = fe(b)), o = t.depth + g, n.backgroundColor && (s.style.backgroundColor = n.backgroundColor, n.borderColor && (s.style.borderColor = n.borderColor));
  }
  var w;
  if (n.backgroundColor)
    w = H.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: s,
          shift: o
        },
        {
          type: "elem",
          elem: t,
          shift: 0
        }
      ]
    }, e);
  else {
    var k = /cancel|phase/.test(r) ? ["svg-align"] : [];
    w = H.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: t,
          shift: 0
        },
        {
          type: "elem",
          elem: s,
          shift: o,
          wrapperClasses: k
        }
      ]
    }, e);
  }
  return /cancel/.test(r) && (w.height = t.height, w.depth = t.depth), /cancel/.test(r) && !l ? H.makeSpan(["mord", "cancel-lap"], [w], e) : H.makeSpan(["mord"], [w], e);
}, k7 = (n, e) => {
  var t = 0, r = new ne.MathNode(n.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [Rt(n.body, e)]);
  switch (n.label) {
    case "\\cancel":
      r.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      r.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      r.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      r.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      r.setAttribute("notation", "box");
      break;
    case "\\angl":
      r.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (t = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm, r.setAttribute("width", "+" + 2 * t + "pt"), r.setAttribute("height", "+" + 2 * t + "pt"), r.setAttribute("lspace", t + "pt"), r.setAttribute("voffset", t + "pt"), n.label === "\\fcolorbox") {
        var i = Math.max(
          e.fontMetrics().fboxrule,
          // default
          e.minRuleThickness
          // user override
        );
        r.setAttribute("style", "border: " + i + "em solid " + String(n.borderColor));
      }
      break;
    case "\\xcancel":
      r.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return n.backgroundColor && r.setAttribute("mathbackground", n.backgroundColor), r;
};
ve({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n, s = Qe(e[0], "color-token").color, o = e[1];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: s,
      body: o
    };
  },
  htmlBuilder: x7,
  mathmlBuilder: k7
});
ve({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n, s = Qe(e[0], "color-token").color, o = Qe(e[1], "color-token").color, l = e[2];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: o,
      borderColor: s,
      body: l
    };
  },
  htmlBuilder: x7,
  mathmlBuilder: k7
});
ve({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
ve({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "enclose",
      mode: t.mode,
      label: r,
      body: i
    };
  },
  htmlBuilder: x7,
  mathmlBuilder: k7
});
ve({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\angl",
      body: e[0]
    };
  }
});
var mN = {};
function Ds(n) {
  for (var {
    type: e,
    names: t,
    props: r,
    handler: i,
    htmlBuilder: s,
    mathmlBuilder: o
  } = n, l = {
    type: e,
    numArgs: r.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: i
  }, a = 0; a < t.length; ++a)
    mN[t[a]] = l;
  s && (Km[e] = s), o && (Gm[e] = o);
}
var gN = {};
function S(n, e) {
  gN[n] = e;
}
function S9(n) {
  var e = [];
  n.consumeSpaces();
  var t = n.fetch().text;
  for (t === "\\relax" && (n.consume(), n.consumeSpaces(), t = n.fetch().text); t === "\\hline" || t === "\\hdashline"; )
    n.consume(), e.push(t === "\\hdashline"), n.consumeSpaces(), t = n.fetch().text;
  return e;
}
var pg = (n) => {
  var e = n.parser.settings;
  if (!e.displayMode)
    throw new se("{" + n.envName + "} can be used only in display mode.");
};
function S7(n) {
  if (n.indexOf("ed") === -1)
    return n.indexOf("*") === -1;
}
function Dl(n, e, t) {
  var {
    hskipBeforeAndAfter: r,
    addJot: i,
    cols: s,
    arraystretch: o,
    colSeparationType: l,
    autoTag: a,
    singleRow: c,
    emptySingleRow: u,
    maxNumCols: h,
    leqno: f
  } = e;
  if (n.gullet.beginGroup(), c || n.gullet.macros.set("\\cr", "\\\\\\relax"), !o) {
    var d = n.gullet.expandMacroAsText("\\arraystretch");
    if (d == null)
      o = 1;
    else if (o = parseFloat(d), !o || o < 0)
      throw new se("Invalid \\arraystretch: " + d);
  }
  n.gullet.beginGroup();
  var p = [], m = [p], g = [], b = [], w = a != null ? [] : void 0;
  function k() {
    a && n.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function C() {
    w && (n.gullet.macros.get("\\df@tag") ? (w.push(n.subparse([new bi("\\df@tag")])), n.gullet.macros.set("\\df@tag", void 0, !0)) : w.push(!!a && n.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (k(), b.push(S9(n)); ; ) {
    var M = n.parseExpression(!1, c ? "\\end" : "\\\\");
    n.gullet.endGroup(), n.gullet.beginGroup(), M = {
      type: "ordgroup",
      mode: n.mode,
      body: M
    }, t && (M = {
      type: "styling",
      mode: n.mode,
      style: t,
      body: [M]
    }), p.push(M);
    var T = n.fetch().text;
    if (T === "&") {
      if (h && p.length === h) {
        if (c || l)
          throw new se("Too many tab characters: &", n.nextToken);
        n.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      n.consume();
    } else if (T === "\\end") {
      C(), p.length === 1 && M.type === "styling" && M.body[0].body.length === 0 && (m.length > 1 || !u) && m.pop(), b.length < m.length + 1 && b.push([]);
      break;
    } else if (T === "\\\\") {
      n.consume();
      var N = void 0;
      n.gullet.future().text !== " " && (N = n.parseSizeGroup(!0)), g.push(N ? N.value : null), C(), b.push(S9(n)), p = [], m.push(p), k();
    } else
      throw new se("Expected & or \\\\ or \\cr or \\end", n.nextToken);
  }
  return n.gullet.endGroup(), n.gullet.endGroup(), {
    type: "array",
    mode: n.mode,
    addJot: i,
    arraystretch: o,
    body: m,
    cols: s,
    rowGaps: g,
    hskipBeforeAndAfter: r,
    hLinesBeforeRow: b,
    colSeparationType: l,
    tags: w,
    leqno: f
  };
}
function C7(n) {
  return n.slice(0, 1) === "d" ? "display" : "text";
}
var Ns = function(e, t) {
  var r, i, s = e.body.length, o = e.hLinesBeforeRow, l = 0, a = new Array(s), c = [], u = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    t.fontMetrics().arrayRuleWidth,
    t.minRuleThickness
    // User override.
  ), h = 1 / t.fontMetrics().ptPerEm, f = 5 * h;
  if (e.colSeparationType && e.colSeparationType === "small") {
    var d = t.havingStyle(We.SCRIPT).sizeMultiplier;
    f = 0.2778 * (d / t.sizeMultiplier);
  }
  var p = e.colSeparationType === "CD" ? Qt({
    number: 3,
    unit: "ex"
  }, t) : 12 * h, m = 3 * h, g = e.arraystretch * p, b = 0.7 * g, w = 0.3 * g, k = 0;
  function C(ae) {
    for (var re = 0; re < ae.length; ++re)
      re > 0 && (k += 0.25), c.push({
        pos: k,
        isDashed: ae[re]
      });
  }
  for (C(o[0]), r = 0; r < e.body.length; ++r) {
    var M = e.body[r], T = b, N = w;
    l < M.length && (l = M.length);
    var B = new Array(M.length);
    for (i = 0; i < M.length; ++i) {
      var $ = ht(M[i], t);
      N < $.depth && (N = $.depth), T < $.height && (T = $.height), B[i] = $;
    }
    var R = e.rowGaps[r], V = 0;
    R && (V = Qt(R, t), V > 0 && (V += w, N < V && (N = V), V = 0)), e.addJot && (N += m), B.height = T, B.depth = N, k += T, B.pos = k, k += N + V, a[r] = B, C(o[r + 1]);
  }
  var z = k / 2 + t.fontMetrics().axisHeight, ue = e.cols || [], ie = [], he, Se, ge = [];
  if (e.tags && e.tags.some((ae) => ae))
    for (r = 0; r < s; ++r) {
      var ye = a[r], ze = ye.pos - z, I = e.tags[r], Ie = void 0;
      I === !0 ? Ie = H.makeSpan(["eqn-num"], [], t) : I === !1 ? Ie = H.makeSpan([], [], t) : Ie = H.makeSpan([], xn(I, t, !0), t), Ie.depth = ye.depth, Ie.height = ye.height, ge.push({
        type: "elem",
        elem: Ie,
        shift: ze
      });
    }
  for (
    i = 0, Se = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    i < l || Se < ue.length;
    ++i, ++Se
  ) {
    for (var Ve = ue[Se] || {}, O = !0; Ve.type === "separator"; ) {
      if (O || (he = H.makeSpan(["arraycolsep"], []), he.style.width = fe(t.fontMetrics().doubleRuleSep), ie.push(he)), Ve.separator === "|" || Ve.separator === ":") {
        var dt = Ve.separator === "|" ? "solid" : "dashed", Ue = H.makeSpan(["vertical-separator"], [], t);
        Ue.style.height = fe(k), Ue.style.borderRightWidth = fe(u), Ue.style.borderRightStyle = dt, Ue.style.margin = "0 " + fe(-u / 2);
        var et = k - z;
        et && (Ue.style.verticalAlign = fe(-et)), ie.push(Ue);
      } else
        throw new se("Invalid separator type: " + Ve.separator);
      Se++, Ve = ue[Se] || {}, O = !1;
    }
    if (!(i >= l)) {
      var Mt = void 0;
      (i > 0 || e.hskipBeforeAndAfter) && (Mt = Be.deflt(Ve.pregap, f), Mt !== 0 && (he = H.makeSpan(["arraycolsep"], []), he.style.width = fe(Mt), ie.push(he)));
      var Ft = [];
      for (r = 0; r < s; ++r) {
        var sn = a[r], Gt = sn[i];
        if (Gt) {
          var _r = sn.pos - z;
          Gt.depth = sn.depth, Gt.height = sn.height, Ft.push({
            type: "elem",
            elem: Gt,
            shift: _r
          });
        }
      }
      Ft = H.makeVList({
        positionType: "individualShift",
        children: Ft
      }, t), Ft = H.makeSpan(["col-align-" + (Ve.align || "c")], [Ft]), ie.push(Ft), (i < l - 1 || e.hskipBeforeAndAfter) && (Mt = Be.deflt(Ve.postgap, f), Mt !== 0 && (he = H.makeSpan(["arraycolsep"], []), he.style.width = fe(Mt), ie.push(he)));
    }
  }
  if (a = H.makeSpan(["mtable"], ie), c.length > 0) {
    for (var E = H.makeLineSpan("hline", t, u), P = H.makeLineSpan("hdashline", t, u), W = [{
      type: "elem",
      elem: a,
      shift: 0
    }]; c.length > 0; ) {
      var Q = c.pop(), J = Q.pos - z;
      Q.isDashed ? W.push({
        type: "elem",
        elem: P,
        shift: J
      }) : W.push({
        type: "elem",
        elem: E,
        shift: J
      });
    }
    a = H.makeVList({
      positionType: "individualShift",
      children: W
    }, t);
  }
  if (ge.length === 0)
    return H.makeSpan(["mord"], [a], t);
  var Y = H.makeVList({
    positionType: "individualShift",
    children: ge
  }, t);
  return Y = H.makeSpan(["tag"], [Y], t), H.makeFragment([a, Y]);
}, yle = {
  c: "center ",
  l: "left ",
  r: "right "
}, Rs = function(e, t) {
  for (var r = [], i = new ne.MathNode("mtd", [], ["mtr-glue"]), s = new ne.MathNode("mtd", [], ["mml-eqn-num"]), o = 0; o < e.body.length; o++) {
    for (var l = e.body[o], a = [], c = 0; c < l.length; c++)
      a.push(new ne.MathNode("mtd", [Rt(l[c], t)]));
    e.tags && e.tags[o] && (a.unshift(i), a.push(i), e.leqno ? a.unshift(s) : a.push(s)), r.push(new ne.MathNode("mtr", a));
  }
  var u = new ne.MathNode("mtable", r), h = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
  u.setAttribute("rowspacing", fe(h));
  var f = "", d = "";
  if (e.cols && e.cols.length > 0) {
    var p = e.cols, m = "", g = !1, b = 0, w = p.length;
    p[0].type === "separator" && (f += "top ", b = 1), p[p.length - 1].type === "separator" && (f += "bottom ", w -= 1);
    for (var k = b; k < w; k++)
      p[k].type === "align" ? (d += yle[p[k].align], g && (m += "none "), g = !0) : p[k].type === "separator" && g && (m += p[k].separator === "|" ? "solid " : "dashed ", g = !1);
    u.setAttribute("columnalign", d.trim()), /[sd]/.test(m) && u.setAttribute("columnlines", m.trim());
  }
  if (e.colSeparationType === "align") {
    for (var C = e.cols || [], M = "", T = 1; T < C.length; T++)
      M += T % 2 ? "0em " : "1em ";
    u.setAttribute("columnspacing", M.trim());
  } else e.colSeparationType === "alignat" || e.colSeparationType === "gather" ? u.setAttribute("columnspacing", "0em") : e.colSeparationType === "small" ? u.setAttribute("columnspacing", "0.2778em") : e.colSeparationType === "CD" ? u.setAttribute("columnspacing", "0.5em") : u.setAttribute("columnspacing", "1em");
  var N = "", B = e.hLinesBeforeRow;
  f += B[0].length > 0 ? "left " : "", f += B[B.length - 1].length > 0 ? "right " : "";
  for (var $ = 1; $ < B.length - 1; $++)
    N += B[$].length === 0 ? "none " : B[$][0] ? "dashed " : "solid ";
  return /[sd]/.test(N) && u.setAttribute("rowlines", N.trim()), f !== "" && (u = new ne.MathNode("menclose", [u]), u.setAttribute("notation", f.trim())), e.arraystretch && e.arraystretch < 1 && (u = new ne.MathNode("mstyle", [u]), u.setAttribute("scriptlevel", "1")), u;
}, yN = function(e, t) {
  e.envName.indexOf("ed") === -1 && pg(e);
  var r = [], i = e.envName.indexOf("at") > -1 ? "alignat" : "align", s = e.envName === "split", o = Dl(e.parser, {
    cols: r,
    addJot: !0,
    autoTag: s ? void 0 : S7(e.envName),
    emptySingleRow: !0,
    colSeparationType: i,
    maxNumCols: s ? 2 : void 0,
    leqno: e.parser.settings.leqno
  }, "display"), l, a = 0, c = {
    type: "ordgroup",
    mode: e.mode,
    body: []
  };
  if (t[0] && t[0].type === "ordgroup") {
    for (var u = "", h = 0; h < t[0].body.length; h++) {
      var f = Qe(t[0].body[h], "textord");
      u += f.text;
    }
    l = Number(u), a = l * 2;
  }
  var d = !a;
  o.body.forEach(function(b) {
    for (var w = 1; w < b.length; w += 2) {
      var k = Qe(b[w], "styling"), C = Qe(k.body[0], "ordgroup");
      C.body.unshift(c);
    }
    if (d)
      a < b.length && (a = b.length);
    else {
      var M = b.length / 2;
      if (l < M)
        throw new se("Too many math in a row: " + ("expected " + l + ", but got " + M), b[0]);
    }
  });
  for (var p = 0; p < a; ++p) {
    var m = "r", g = 0;
    p % 2 === 1 ? m = "l" : p > 0 && d && (g = 1), r[p] = {
      type: "align",
      align: m,
      pregap: g,
      postgap: 0
    };
  }
  return o.colSeparationType = d ? "align" : "alignat", o;
};
Ds({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var t = hg(e[0]), r = t ? [e[0]] : Qe(e[0], "ordgroup").body, i = r.map(function(o) {
      var l = b7(o), a = l.text;
      if ("lcr".indexOf(a) !== -1)
        return {
          type: "align",
          align: a
        };
      if (a === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (a === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new se("Unknown column alignment: " + a, o);
    }), s = {
      cols: i,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: i.length
    };
    return Dl(n.parser, s, C7(n.envName));
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[n.envName.replace("*", "")], t = "c", r = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: t
      }]
    };
    if (n.envName.charAt(n.envName.length - 1) === "*") {
      var i = n.parser;
      if (i.consumeSpaces(), i.fetch().text === "[") {
        if (i.consume(), i.consumeSpaces(), t = i.fetch().text, "lcr".indexOf(t) === -1)
          throw new se("Expected l or c or r", i.nextToken);
        i.consume(), i.consumeSpaces(), i.expect("]"), i.consume(), r.cols = [{
          type: "align",
          align: t
        }];
      }
    }
    var s = Dl(n.parser, r, C7(n.envName)), o = Math.max(0, ...s.body.map((l) => l.length));
    return s.cols = new Array(o).fill({
      type: "align",
      align: t
    }), e ? {
      type: "leftright",
      mode: n.mode,
      body: [s],
      left: e[0],
      right: e[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : s;
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      arraystretch: 0.5
    }, t = Dl(n.parser, e, "script");
    return t.colSeparationType = "small", t;
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var t = hg(e[0]), r = t ? [e[0]] : Qe(e[0], "ordgroup").body, i = r.map(function(o) {
      var l = b7(o), a = l.text;
      if ("lc".indexOf(a) !== -1)
        return {
          type: "align",
          align: a
        };
      throw new se("Unknown column alignment: " + a, o);
    });
    if (i.length > 1)
      throw new se("{subarray} can contain only one column");
    var s = {
      cols: i,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (s = Dl(n.parser, s, "script"), s.body.length > 0 && s.body[0].length > 1)
      throw new se("{subarray} can contain only one column");
    return s;
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, t = Dl(n.parser, e, C7(n.envName));
    return {
      type: "leftright",
      mode: n.mode,
      body: [t],
      left: n.envName.indexOf("r") > -1 ? "." : "\\{",
      right: n.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: yN,
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    Be.contains(["gather", "gather*"], n.envName) && pg(n);
    var e = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: S7(n.envName),
      emptySingleRow: !0,
      leqno: n.parser.settings.leqno
    };
    return Dl(n.parser, e, "display");
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: yN,
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    pg(n);
    var e = {
      autoTag: S7(n.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: n.parser.settings.leqno
    };
    return Dl(n.parser, e, "display");
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(n) {
    return pg(n), rle(n.parser);
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
S("\\nonumber", "\\gdef\\@eqnsw{0}");
S("\\notag", "\\nonumber");
ve({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(n, e) {
    throw new se(n.funcName + " valid only within array environment");
  }
});
var C9 = mN;
ve({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    if (i.type !== "ordgroup")
      throw new se("Invalid environment name", i);
    for (var s = "", o = 0; o < i.body.length; ++o)
      s += Qe(i.body[o], "textord").text;
    if (r === "\\begin") {
      if (!C9.hasOwnProperty(s))
        throw new se("No such environment: " + s, i);
      var l = C9[s], {
        args: a,
        optArgs: c
      } = t.parseArguments("\\begin{" + s + "}", l), u = {
        mode: t.mode,
        envName: s,
        parser: t
      }, h = l.handler(u, a, c);
      t.expect("\\end", !1);
      var f = t.nextToken, d = Qe(t.parseFunction(), "environment");
      if (d.name !== s)
        throw new se("Mismatch: \\begin{" + s + "} matched by \\end{" + d.name + "}", f);
      return h;
    }
    return {
      type: "environment",
      mode: t.mode,
      name: s,
      nameGroup: i
    };
  }
});
var bN = (n, e) => {
  var t = n.font, r = e.withFont(t);
  return ht(n.body, r);
}, vN = (n, e) => {
  var t = n.font, r = e.withFont(t);
  return Rt(n.body, r);
}, M9 = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
ve({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = Ym(e[0]), s = r;
    return s in M9 && (s = M9[s]), {
      type: "font",
      mode: t.mode,
      font: s.slice(1),
      body: i
    };
  },
  htmlBuilder: bN,
  mathmlBuilder: vN
});
ve({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0], i = Be.isCharacterBox(r);
    return {
      type: "mclass",
      mode: t.mode,
      mclass: fg(r),
      body: [{
        type: "font",
        mode: t.mode,
        font: "boldsymbol",
        body: r
      }],
      isCharacterBox: i
    };
  }
});
ve({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r,
      breakOnTokenText: i
    } = n, {
      mode: s
    } = t, o = t.parseExpression(!0, i), l = "math" + r.slice(1);
    return {
      type: "font",
      mode: s,
      font: l,
      body: {
        type: "ordgroup",
        mode: t.mode,
        body: o
      }
    };
  },
  htmlBuilder: bN,
  mathmlBuilder: vN
});
var wN = (n, e) => {
  var t = e;
  return n === "display" ? t = t.id >= We.SCRIPT.id ? t.text() : We.DISPLAY : n === "text" && t.size === We.DISPLAY.size ? t = We.TEXT : n === "script" ? t = We.SCRIPT : n === "scriptscript" && (t = We.SCRIPTSCRIPT), t;
}, M7 = (n, e) => {
  var t = wN(n.size, e.style), r = t.fracNum(), i = t.fracDen(), s;
  s = e.havingStyle(r);
  var o = ht(n.numer, s, e);
  if (n.continued) {
    var l = 8.5 / e.fontMetrics().ptPerEm, a = 3.5 / e.fontMetrics().ptPerEm;
    o.height = o.height < l ? l : o.height, o.depth = o.depth < a ? a : o.depth;
  }
  s = e.havingStyle(i);
  var c = ht(n.denom, s, e), u, h, f;
  n.hasBarLine ? (n.barSize ? (h = Qt(n.barSize, e), u = H.makeLineSpan("frac-line", e, h)) : u = H.makeLineSpan("frac-line", e), h = u.height, f = u.height) : (u = null, h = 0, f = e.fontMetrics().defaultRuleThickness);
  var d, p, m;
  t.size === We.DISPLAY.size || n.size === "display" ? (d = e.fontMetrics().num1, h > 0 ? p = 3 * f : p = 7 * f, m = e.fontMetrics().denom1) : (h > 0 ? (d = e.fontMetrics().num2, p = f) : (d = e.fontMetrics().num3, p = 3 * f), m = e.fontMetrics().denom2);
  var g;
  if (u) {
    var w = e.fontMetrics().axisHeight;
    d - o.depth - (w + 0.5 * h) < p && (d += p - (d - o.depth - (w + 0.5 * h))), w - 0.5 * h - (c.height - m) < p && (m += p - (w - 0.5 * h - (c.height - m)));
    var k = -(w - 0.5 * h);
    g = H.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: c,
        shift: m
      }, {
        type: "elem",
        elem: u,
        shift: k
      }, {
        type: "elem",
        elem: o,
        shift: -d
      }]
    }, e);
  } else {
    var b = d - o.depth - (c.height - m);
    b < p && (d += 0.5 * (p - b), m += 0.5 * (p - b)), g = H.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: c,
        shift: m
      }, {
        type: "elem",
        elem: o,
        shift: -d
      }]
    }, e);
  }
  s = e.havingStyle(t), g.height *= s.sizeMultiplier / e.sizeMultiplier, g.depth *= s.sizeMultiplier / e.sizeMultiplier;
  var C;
  t.size === We.DISPLAY.size ? C = e.fontMetrics().delim1 : t.size === We.SCRIPTSCRIPT.size ? C = e.havingStyle(We.SCRIPT).fontMetrics().delim2 : C = e.fontMetrics().delim2;
  var M, T;
  return n.leftDelim == null ? M = rd(e, ["mopen"]) : M = oo.customSizedDelim(n.leftDelim, C, !0, e.havingStyle(t), n.mode, ["mopen"]), n.continued ? T = H.makeSpan([]) : n.rightDelim == null ? T = rd(e, ["mclose"]) : T = oo.customSizedDelim(n.rightDelim, C, !0, e.havingStyle(t), n.mode, ["mclose"]), H.makeSpan(["mord"].concat(s.sizingClasses(e)), [M, H.makeSpan(["mfrac"], [g]), T], e);
}, T7 = (n, e) => {
  var t = new ne.MathNode("mfrac", [Rt(n.numer, e), Rt(n.denom, e)]);
  if (!n.hasBarLine)
    t.setAttribute("linethickness", "0px");
  else if (n.barSize) {
    var r = Qt(n.barSize, e);
    t.setAttribute("linethickness", fe(r));
  }
  var i = wN(n.size, e.style);
  if (i.size !== e.style.size) {
    t = new ne.MathNode("mstyle", [t]);
    var s = i.size === We.DISPLAY.size ? "true" : "false";
    t.setAttribute("displaystyle", s), t.setAttribute("scriptlevel", "0");
  }
  if (n.leftDelim != null || n.rightDelim != null) {
    var o = [];
    if (n.leftDelim != null) {
      var l = new ne.MathNode("mo", [new ne.TextNode(n.leftDelim.replace("\\", ""))]);
      l.setAttribute("fence", "true"), o.push(l);
    }
    if (o.push(t), n.rightDelim != null) {
      var a = new ne.MathNode("mo", [new ne.TextNode(n.rightDelim.replace("\\", ""))]);
      a.setAttribute("fence", "true"), o.push(a);
    }
    return g7(o);
  }
  return t;
};
ve({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = e[1], o, l = null, a = null, c = "auto";
    switch (r) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        o = !0;
        break;
      case "\\\\atopfrac":
        o = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        o = !1, l = "(", a = ")";
        break;
      case "\\\\bracefrac":
        o = !1, l = "\\{", a = "\\}";
        break;
      case "\\\\brackfrac":
        o = !1, l = "[", a = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (r) {
      case "\\dfrac":
      case "\\dbinom":
        c = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        c = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !1,
      numer: i,
      denom: s,
      hasBarLine: o,
      leftDelim: l,
      rightDelim: a,
      size: c,
      barSize: null
    };
  },
  htmlBuilder: M7,
  mathmlBuilder: T7
});
ve({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = e[1];
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !0,
      numer: i,
      denom: s,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
ve({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t,
      token: r
    } = n, i;
    switch (t) {
      case "\\over":
        i = "\\frac";
        break;
      case "\\choose":
        i = "\\binom";
        break;
      case "\\atop":
        i = "\\\\atopfrac";
        break;
      case "\\brace":
        i = "\\\\bracefrac";
        break;
      case "\\brack":
        i = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: e.mode,
      replaceWith: i,
      token: r
    };
  }
});
var T9 = ["display", "text", "script", "scriptscript"], A9 = function(e) {
  var t = null;
  return e.length > 0 && (t = e, t = t === "." ? null : t), t;
};
ve({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = e[4], i = e[5], s = Ym(e[0]), o = s.type === "atom" && s.family === "open" ? A9(s.text) : null, l = Ym(e[1]), a = l.type === "atom" && l.family === "close" ? A9(l.text) : null, c = Qe(e[2], "size"), u, h = null;
    c.isBlank ? u = !0 : (h = c.value, u = h.number > 0);
    var f = "auto", d = e[3];
    if (d.type === "ordgroup") {
      if (d.body.length > 0) {
        var p = Qe(d.body[0], "textord");
        f = T9[Number(p.text)];
      }
    } else
      d = Qe(d, "textord"), f = T9[Number(d.text)];
    return {
      type: "genfrac",
      mode: t.mode,
      numer: r,
      denom: i,
      continued: !1,
      hasBarLine: u,
      barSize: h,
      leftDelim: o,
      rightDelim: a,
      size: f
    };
  },
  htmlBuilder: M7,
  mathmlBuilder: T7
});
ve({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r,
      token: i
    } = n;
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: "\\\\abovefrac",
      size: Qe(e[0], "size").value,
      token: i
    };
  }
});
ve({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = Kse(Qe(e[1], "infix").size), o = e[2], l = s.number > 0;
    return {
      type: "genfrac",
      mode: t.mode,
      numer: i,
      denom: o,
      continued: !1,
      hasBarLine: l,
      barSize: s,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: M7,
  mathmlBuilder: T7
});
var xN = (n, e) => {
  var t = e.style, r, i;
  n.type === "supsub" ? (r = n.sup ? ht(n.sup, e.havingStyle(t.sup()), e) : ht(n.sub, e.havingStyle(t.sub()), e), i = Qe(n.base, "horizBrace")) : i = Qe(n, "horizBrace");
  var s = ht(i.base, e.havingBaseStyle(We.DISPLAY)), o = yo.svgSpan(i, e), l;
  if (i.isOver ? (l = H.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: s
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: o
    }]
  }, e), l.children[0].children[0].children[1].classes.push("svg-align")) : (l = H.makeVList({
    positionType: "bottom",
    positionData: s.depth + 0.1 + o.height,
    children: [{
      type: "elem",
      elem: o
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: s
    }]
  }, e), l.children[0].children[0].children[0].classes.push("svg-align")), r) {
    var a = H.makeSpan(["mord", i.isOver ? "mover" : "munder"], [l], e);
    i.isOver ? l = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: r
      }]
    }, e) : l = H.makeVList({
      positionType: "bottom",
      positionData: a.depth + 0.2 + r.height + r.depth,
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: a
      }]
    }, e);
  }
  return H.makeSpan(["mord", i.isOver ? "mover" : "munder"], [l], e);
}, ble = (n, e) => {
  var t = yo.mathMLnode(n.label);
  return new ne.MathNode(n.isOver ? "mover" : "munder", [Rt(n.base, e), t]);
};
ve({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n;
    return {
      type: "horizBrace",
      mode: t.mode,
      label: r,
      isOver: /^\\over/.test(r),
      base: e[0]
    };
  },
  htmlBuilder: xN,
  mathmlBuilder: ble
});
ve({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[1], i = Qe(e[0], "url").url;
    return t.settings.isTrusted({
      command: "\\href",
      url: i
    }) ? {
      type: "href",
      mode: t.mode,
      href: i,
      body: cn(r)
    } : t.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.body, e, !1);
    return H.makeAnchor(n.href, [], t, e);
  },
  mathmlBuilder: (n, e) => {
    var t = xl(n.body, e);
    return t instanceof Gr || (t = new Gr("mrow", [t])), t.setAttribute("href", n.href), t;
  }
});
ve({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = Qe(e[0], "url").url;
    if (!t.settings.isTrusted({
      command: "\\url",
      url: r
    }))
      return t.formatUnsupportedCmd("\\url");
    for (var i = [], s = 0; s < r.length; s++) {
      var o = r[s];
      o === "~" && (o = "\\textasciitilde"), i.push({
        type: "textord",
        mode: "text",
        text: o
      });
    }
    var l = {
      type: "text",
      mode: t.mode,
      font: "\\texttt",
      body: i
    };
    return {
      type: "href",
      mode: t.mode,
      href: r,
      body: cn(l)
    };
  }
});
ve({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "hbox",
      mode: t.mode,
      body: cn(e[0])
    };
  },
  htmlBuilder(n, e) {
    var t = xn(n.body, e, !1);
    return H.makeFragment(t);
  },
  mathmlBuilder(n, e) {
    return new ne.MathNode("mrow", Pr(n.body, e));
  }
});
ve({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r,
      token: i
    } = n, s = Qe(e[0], "raw").string, o = e[1];
    t.settings.strict && t.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var l, a = {};
    switch (r) {
      case "\\htmlClass":
        a.class = s, l = {
          command: "\\htmlClass",
          class: s
        };
        break;
      case "\\htmlId":
        a.id = s, l = {
          command: "\\htmlId",
          id: s
        };
        break;
      case "\\htmlStyle":
        a.style = s, l = {
          command: "\\htmlStyle",
          style: s
        };
        break;
      case "\\htmlData": {
        for (var c = s.split(","), u = 0; u < c.length; u++) {
          var h = c[u].split("=");
          if (h.length !== 2)
            throw new se("Error parsing key-value for \\htmlData");
          a["data-" + h[0].trim()] = h[1].trim();
        }
        l = {
          command: "\\htmlData",
          attributes: a
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return t.settings.isTrusted(l) ? {
      type: "html",
      mode: t.mode,
      attributes: a,
      body: cn(o)
    } : t.formatUnsupportedCmd(r);
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.body, e, !1), r = ["enclosing"];
    n.attributes.class && r.push(...n.attributes.class.trim().split(/\s+/));
    var i = H.makeSpan(r, t, e);
    for (var s in n.attributes)
      s !== "class" && n.attributes.hasOwnProperty(s) && i.setAttribute(s, n.attributes[s]);
    return i;
  },
  mathmlBuilder: (n, e) => xl(n.body, e)
});
ve({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n;
    return {
      type: "htmlmathml",
      mode: t.mode,
      html: cn(e[0]),
      mathml: cn(e[1])
    };
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.html, e, !1);
    return H.makeFragment(t);
  },
  mathmlBuilder: (n, e) => xl(n.mathml, e)
});
var m4 = function(e) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e))
    return {
      number: +e,
      unit: "bp"
    };
  var t = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
  if (!t)
    throw new se("Invalid size: '" + e + "' in \\includegraphics");
  var r = {
    number: +(t[1] + t[2]),
    // sign + magnitude, cast to number
    unit: t[3]
  };
  if (!HD(r))
    throw new se("Invalid unit: '" + r.unit + "' in \\includegraphics.");
  return r;
};
ve({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (n, e, t) => {
    var {
      parser: r
    } = n, i = {
      number: 0,
      unit: "em"
    }, s = {
      number: 0.9,
      unit: "em"
    }, o = {
      number: 0,
      unit: "em"
    }, l = "";
    if (t[0])
      for (var a = Qe(t[0], "raw").string, c = a.split(","), u = 0; u < c.length; u++) {
        var h = c[u].split("=");
        if (h.length === 2) {
          var f = h[1].trim();
          switch (h[0].trim()) {
            case "alt":
              l = f;
              break;
            case "width":
              i = m4(f);
              break;
            case "height":
              s = m4(f);
              break;
            case "totalheight":
              o = m4(f);
              break;
            default:
              throw new se("Invalid key: '" + h[0] + "' in \\includegraphics.");
          }
        }
      }
    var d = Qe(e[0], "url").url;
    return l === "" && (l = d, l = l.replace(/^.*[\\/]/, ""), l = l.substring(0, l.lastIndexOf("."))), r.settings.isTrusted({
      command: "\\includegraphics",
      url: d
    }) ? {
      type: "includegraphics",
      mode: r.mode,
      alt: l,
      width: i,
      height: s,
      totalheight: o,
      src: d
    } : r.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (n, e) => {
    var t = Qt(n.height, e), r = 0;
    n.totalheight.number > 0 && (r = Qt(n.totalheight, e) - t);
    var i = 0;
    n.width.number > 0 && (i = Qt(n.width, e));
    var s = {
      height: fe(t + r)
    };
    i > 0 && (s.width = fe(i)), r > 0 && (s.verticalAlign = fe(-r));
    var o = new boe(n.src, n.alt, s);
    return o.height = t, o.depth = r, o;
  },
  mathmlBuilder: (n, e) => {
    var t = new ne.MathNode("mglyph", []);
    t.setAttribute("alt", n.alt);
    var r = Qt(n.height, e), i = 0;
    if (n.totalheight.number > 0 && (i = Qt(n.totalheight, e) - r, t.setAttribute("valign", fe(-i))), t.setAttribute("height", fe(r + i)), n.width.number > 0) {
      var s = Qt(n.width, e);
      t.setAttribute("width", fe(s));
    }
    return t.setAttribute("src", n.src), t;
  }
});
ve({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = Qe(e[0], "size");
    if (t.settings.strict) {
      var s = r[1] === "m", o = i.value.unit === "mu";
      s ? (o || t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " supports only mu units, " + ("not " + i.value.unit + " units")), t.mode !== "math" && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " works only in math mode")) : o && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: t.mode,
      dimension: i.value
    };
  },
  htmlBuilder(n, e) {
    return H.makeGlue(n.dimension, e);
  },
  mathmlBuilder(n, e) {
    var t = Qt(n.dimension, e);
    return new ne.SpaceNode(t);
  }
});
ve({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "lap",
      mode: t.mode,
      alignment: r.slice(5),
      body: i
    };
  },
  htmlBuilder: (n, e) => {
    var t;
    n.alignment === "clap" ? (t = H.makeSpan([], [ht(n.body, e)]), t = H.makeSpan(["inner"], [t], e)) : t = H.makeSpan(["inner"], [ht(n.body, e)]);
    var r = H.makeSpan(["fix"], []), i = H.makeSpan([n.alignment], [t, r], e), s = H.makeSpan(["strut"]);
    return s.style.height = fe(i.height + i.depth), i.depth && (s.style.verticalAlign = fe(-i.depth)), i.children.unshift(s), i = H.makeSpan(["thinbox"], [i], e), H.makeSpan(["mord", "vbox"], [i], e);
  },
  mathmlBuilder: (n, e) => {
    var t = new ne.MathNode("mpadded", [Rt(n.body, e)]);
    if (n.alignment !== "rlap") {
      var r = n.alignment === "llap" ? "-1" : "-0.5";
      t.setAttribute("lspace", r + "width");
    }
    return t.setAttribute("width", "0px"), t;
  }
});
ve({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(n, e) {
    var {
      funcName: t,
      parser: r
    } = n, i = r.mode;
    r.switchMode("math");
    var s = t === "\\(" ? "\\)" : "$", o = r.parseExpression(!1, s);
    return r.expect(s), r.switchMode(i), {
      type: "styling",
      mode: r.mode,
      style: "text",
      body: o
    };
  }
});
ve({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(n, e) {
    throw new se("Mismatched " + n.funcName);
  }
});
var O9 = (n, e) => {
  switch (e.style.size) {
    case We.DISPLAY.size:
      return n.display;
    case We.TEXT.size:
      return n.text;
    case We.SCRIPT.size:
      return n.script;
    case We.SCRIPTSCRIPT.size:
      return n.scriptscript;
    default:
      return n.text;
  }
};
ve({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n;
    return {
      type: "mathchoice",
      mode: t.mode,
      display: cn(e[0]),
      text: cn(e[1]),
      script: cn(e[2]),
      scriptscript: cn(e[3])
    };
  },
  htmlBuilder: (n, e) => {
    var t = O9(n, e), r = xn(t, e, !1);
    return H.makeFragment(r);
  },
  mathmlBuilder: (n, e) => {
    var t = O9(n, e);
    return xl(t, e);
  }
});
var kN = (n, e, t, r, i, s, o) => {
  n = H.makeSpan([], [n]);
  var l = t && Be.isCharacterBox(t), a, c;
  if (e) {
    var u = ht(e, r.havingStyle(i.sup()), r);
    c = {
      elem: u,
      kern: Math.max(r.fontMetrics().bigOpSpacing1, r.fontMetrics().bigOpSpacing3 - u.depth)
    };
  }
  if (t) {
    var h = ht(t, r.havingStyle(i.sub()), r);
    a = {
      elem: h,
      kern: Math.max(r.fontMetrics().bigOpSpacing2, r.fontMetrics().bigOpSpacing4 - h.height)
    };
  }
  var f;
  if (c && a) {
    var d = r.fontMetrics().bigOpSpacing5 + a.elem.height + a.elem.depth + a.kern + n.depth + o;
    f = H.makeVList({
      positionType: "bottom",
      positionData: d,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: a.elem,
        marginLeft: fe(-s)
      }, {
        type: "kern",
        size: a.kern
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: fe(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else if (a) {
    var p = n.height - o;
    f = H.makeVList({
      positionType: "top",
      positionData: p,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: a.elem,
        marginLeft: fe(-s)
      }, {
        type: "kern",
        size: a.kern
      }, {
        type: "elem",
        elem: n
      }]
    }, r);
  } else if (c) {
    var m = n.depth + o;
    f = H.makeVList({
      positionType: "bottom",
      positionData: m,
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: fe(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else
    return n;
  var g = [f];
  if (a && s !== 0 && !l) {
    var b = H.makeSpan(["mspace"], [], r);
    b.style.marginRight = fe(s), g.unshift(b);
  }
  return H.makeSpan(["mop", "op-limits"], g, r);
}, SN = ["\\smallint"], yu = (n, e) => {
  var t, r, i = !1, s;
  n.type === "supsub" ? (t = n.sup, r = n.sub, s = Qe(n.base, "op"), i = !0) : s = Qe(n, "op");
  var o = e.style, l = !1;
  o.size === We.DISPLAY.size && s.symbol && !Be.contains(SN, s.name) && (l = !0);
  var a;
  if (s.symbol) {
    var c = l ? "Size2-Regular" : "Size1-Regular", u = "";
    if ((s.name === "\\oiint" || s.name === "\\oiiint") && (u = s.name.slice(1), s.name = u === "oiint" ? "\\iint" : "\\iiint"), a = H.makeSymbol(s.name, c, "math", e, ["mop", "op-symbol", l ? "large-op" : "small-op"]), u.length > 0) {
      var h = a.italic, f = H.staticSvg(u + "Size" + (l ? "2" : "1"), e);
      a = H.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: a,
          shift: 0
        }, {
          type: "elem",
          elem: f,
          shift: l ? 0.08 : 0
        }]
      }, e), s.name = "\\" + u, a.classes.unshift("mop"), a.italic = h;
    }
  } else if (s.body) {
    var d = xn(s.body, e, !0);
    d.length === 1 && d[0] instanceof ki ? (a = d[0], a.classes[0] = "mop") : a = H.makeSpan(["mop"], d, e);
  } else {
    for (var p = [], m = 1; m < s.name.length; m++)
      p.push(H.mathsym(s.name[m], s.mode, e));
    a = H.makeSpan(["mop"], p, e);
  }
  var g = 0, b = 0;
  return (a instanceof ki || s.name === "\\oiint" || s.name === "\\oiiint") && !s.suppressBaseShift && (g = (a.height - a.depth) / 2 - e.fontMetrics().axisHeight, b = a.italic), i ? kN(a, t, r, e, o, b, g) : (g && (a.style.position = "relative", a.style.top = fe(g)), a);
}, Bd = (n, e) => {
  var t;
  if (n.symbol)
    t = new Gr("mo", [Si(n.name, n.mode)]), Be.contains(SN, n.name) && t.setAttribute("largeop", "false");
  else if (n.body)
    t = new Gr("mo", Pr(n.body, e));
  else {
    t = new Gr("mi", [new gs(n.name.slice(1))]);
    var r = new Gr("mo", [Si("⁡", "text")]);
    n.parentIsSupSub ? t = new Gr("mrow", [t, r]) : t = XD([t, r]);
  }
  return t;
}, vle = {
  "∏": "\\prod",
  "∐": "\\coprod",
  "∑": "\\sum",
  "⋀": "\\bigwedge",
  "⋁": "\\bigvee",
  "⋂": "\\bigcap",
  "⋃": "\\bigcup",
  "⨀": "\\bigodot",
  "⨁": "\\bigoplus",
  "⨂": "\\bigotimes",
  "⨄": "\\biguplus",
  "⨆": "\\bigsqcup"
};
ve({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
  props: {
    numArgs: 0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = r;
    return i.length === 1 && (i = vle[i]), {
      type: "op",
      mode: t.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: i
    };
  },
  htmlBuilder: yu,
  mathmlBuilder: Bd
});
ve({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: cn(r)
    };
  },
  htmlBuilder: yu,
  mathmlBuilder: Bd
});
var wle = {
  "∫": "\\int",
  "∬": "\\iint",
  "∭": "\\iiint",
  "∮": "\\oint",
  "∯": "\\oiint",
  "∰": "\\oiiint"
};
ve({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    return {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: yu,
  mathmlBuilder: Bd
});
ve({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    return {
      type: "op",
      mode: e.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: yu,
  mathmlBuilder: Bd
});
ve({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = t;
    return r.length === 1 && (r = wle[r]), {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: r
    };
  },
  htmlBuilder: yu,
  mathmlBuilder: Bd
});
var CN = (n, e) => {
  var t, r, i = !1, s;
  n.type === "supsub" ? (t = n.sup, r = n.sub, s = Qe(n.base, "operatorname"), i = !0) : s = Qe(n, "operatorname");
  var o;
  if (s.body.length > 0) {
    for (var l = s.body.map((h) => {
      var f = h.text;
      return typeof f == "string" ? {
        type: "textord",
        mode: h.mode,
        text: f
      } : h;
    }), a = xn(l, e.withFont("mathrm"), !0), c = 0; c < a.length; c++) {
      var u = a[c];
      u instanceof ki && (u.text = u.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    o = H.makeSpan(["mop"], a, e);
  } else
    o = H.makeSpan(["mop"], [], e);
  return i ? kN(o, t, r, e, e.style, 0, 0) : o;
}, xle = (n, e) => {
  for (var t = Pr(n.body, e.withFont("mathrm")), r = !0, i = 0; i < t.length; i++) {
    var s = t[i];
    if (!(s instanceof ne.SpaceNode)) if (s instanceof ne.MathNode)
      switch (s.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        // Do nothing yet.
        case "mo": {
          var o = s.children[0];
          s.children.length === 1 && o instanceof ne.TextNode ? o.text = o.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : r = !1;
          break;
        }
        default:
          r = !1;
      }
    else
      r = !1;
  }
  if (r) {
    var l = t.map((u) => u.toText()).join("");
    t = [new ne.TextNode(l)];
  }
  var a = new ne.MathNode("mi", t);
  a.setAttribute("mathvariant", "normal");
  var c = new ne.MathNode("mo", [Si("⁡", "text")]);
  return n.parentIsSupSub ? new ne.MathNode("mrow", [a, c]) : ne.newDocumentFragment([a, c]);
};
ve({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "operatorname",
      mode: t.mode,
      body: cn(i),
      alwaysHandleSupSub: r === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: CN,
  mathmlBuilder: xle
});
S("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
Va({
  type: "ordgroup",
  htmlBuilder(n, e) {
    return n.semisimple ? H.makeFragment(xn(n.body, e, !1)) : H.makeSpan(["mord"], xn(n.body, e, !0), e);
  },
  mathmlBuilder(n, e) {
    return xl(n.body, e, !0);
  }
});
ve({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "overline",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder(n, e) {
    var t = ht(n.body, e.havingCrampedStyle()), r = H.makeLineSpan("overline-line", e), i = e.fontMetrics().defaultRuleThickness, s = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: i
      }]
    }, e);
    return H.makeSpan(["mord", "overline"], [s], e);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mo", [new ne.TextNode("‾")]);
    t.setAttribute("stretchy", "true");
    var r = new ne.MathNode("mover", [Rt(n.body, e), t]);
    return r.setAttribute("accent", "true"), r;
  }
});
ve({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "phantom",
      mode: t.mode,
      body: cn(r)
    };
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.body, e.withPhantom(), !1);
    return H.makeFragment(t);
  },
  mathmlBuilder: (n, e) => {
    var t = Pr(n.body, e);
    return new ne.MathNode("mphantom", t);
  }
});
ve({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "hphantom",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder: (n, e) => {
    var t = H.makeSpan([], [ht(n.body, e.withPhantom())]);
    if (t.height = 0, t.depth = 0, t.children)
      for (var r = 0; r < t.children.length; r++)
        t.children[r].height = 0, t.children[r].depth = 0;
    return t = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e), H.makeSpan(["mord"], [t], e);
  },
  mathmlBuilder: (n, e) => {
    var t = Pr(cn(n.body), e), r = new ne.MathNode("mphantom", t), i = new ne.MathNode("mpadded", [r]);
    return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
  }
});
ve({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "vphantom",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder: (n, e) => {
    var t = H.makeSpan(["inner"], [ht(n.body, e.withPhantom())]), r = H.makeSpan(["fix"], []);
    return H.makeSpan(["mord", "rlap"], [t, r], e);
  },
  mathmlBuilder: (n, e) => {
    var t = Pr(cn(n.body), e), r = new ne.MathNode("mphantom", t), i = new ne.MathNode("mpadded", [r]);
    return i.setAttribute("width", "0px"), i;
  }
});
ve({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = Qe(e[0], "size").value, i = e[1];
    return {
      type: "raisebox",
      mode: t.mode,
      dy: r,
      body: i
    };
  },
  htmlBuilder(n, e) {
    var t = ht(n.body, e), r = Qt(n.dy, e);
    return H.makeVList({
      positionType: "shift",
      positionData: -r,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mpadded", [Rt(n.body, e)]), r = n.dy.number + n.dy.unit;
    return t.setAttribute("voffset", r), t;
  }
});
ve({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInArgument: !0
  },
  handler(n) {
    var {
      parser: e
    } = n;
    return {
      type: "internal",
      mode: e.mode
    };
  }
});
ve({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    argTypes: ["size", "size", "size"]
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = t[0], s = Qe(e[0], "size"), o = Qe(e[1], "size");
    return {
      type: "rule",
      mode: r.mode,
      shift: i && Qe(i, "size").value,
      width: s.value,
      height: o.value
    };
  },
  htmlBuilder(n, e) {
    var t = H.makeSpan(["mord", "rule"], [], e), r = Qt(n.width, e), i = Qt(n.height, e), s = n.shift ? Qt(n.shift, e) : 0;
    return t.style.borderRightWidth = fe(r), t.style.borderTopWidth = fe(i), t.style.bottom = fe(s), t.width = r, t.height = i + s, t.depth = -s, t.maxFontSize = i * 1.125 * e.sizeMultiplier, t;
  },
  mathmlBuilder(n, e) {
    var t = Qt(n.width, e), r = Qt(n.height, e), i = n.shift ? Qt(n.shift, e) : 0, s = e.color && e.getColor() || "black", o = new ne.MathNode("mspace");
    o.setAttribute("mathbackground", s), o.setAttribute("width", fe(t)), o.setAttribute("height", fe(r));
    var l = new ne.MathNode("mpadded", [o]);
    return i >= 0 ? l.setAttribute("height", fe(i)) : (l.setAttribute("height", fe(i)), l.setAttribute("depth", fe(-i))), l.setAttribute("voffset", fe(i)), l;
  }
});
function MN(n, e, t) {
  for (var r = xn(n, e, !1), i = e.sizeMultiplier / t.sizeMultiplier, s = 0; s < r.length; s++) {
    var o = r[s].classes.indexOf("sizing");
    o < 0 ? Array.prototype.push.apply(r[s].classes, e.sizingClasses(t)) : r[s].classes[o + 1] === "reset-size" + e.size && (r[s].classes[o + 1] = "reset-size" + t.size), r[s].height *= i, r[s].depth *= i;
  }
  return H.makeFragment(r);
}
var E9 = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], kle = (n, e) => {
  var t = e.havingSize(n.size);
  return MN(n.body, t, e);
};
ve({
  type: "sizing",
  names: E9,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      breakOnTokenText: t,
      funcName: r,
      parser: i
    } = n, s = i.parseExpression(!1, t);
    return {
      type: "sizing",
      mode: i.mode,
      // Figure out what size to use based on the list of functions above
      size: E9.indexOf(r) + 1,
      body: s
    };
  },
  htmlBuilder: kle,
  mathmlBuilder: (n, e) => {
    var t = e.havingSize(n.size), r = Pr(n.body, t), i = new ne.MathNode("mstyle", r);
    return i.setAttribute("mathsize", fe(t.sizeMultiplier)), i;
  }
});
ve({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (n, e, t) => {
    var {
      parser: r
    } = n, i = !1, s = !1, o = t[0] && Qe(t[0], "ordgroup");
    if (o)
      for (var l = "", a = 0; a < o.body.length; ++a) {
        var c = o.body[a];
        if (l = c.text, l === "t")
          i = !0;
        else if (l === "b")
          s = !0;
        else {
          i = !1, s = !1;
          break;
        }
      }
    else
      i = !0, s = !0;
    var u = e[0];
    return {
      type: "smash",
      mode: r.mode,
      body: u,
      smashHeight: i,
      smashDepth: s
    };
  },
  htmlBuilder: (n, e) => {
    var t = H.makeSpan([], [ht(n.body, e)]);
    if (!n.smashHeight && !n.smashDepth)
      return t;
    if (n.smashHeight && (t.height = 0, t.children))
      for (var r = 0; r < t.children.length; r++)
        t.children[r].height = 0;
    if (n.smashDepth && (t.depth = 0, t.children))
      for (var i = 0; i < t.children.length; i++)
        t.children[i].depth = 0;
    var s = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
    return H.makeSpan(["mord"], [s], e);
  },
  mathmlBuilder: (n, e) => {
    var t = new ne.MathNode("mpadded", [Rt(n.body, e)]);
    return n.smashHeight && t.setAttribute("height", "0px"), n.smashDepth && t.setAttribute("depth", "0px"), t;
  }
});
ve({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = t[0], s = e[0];
    return {
      type: "sqrt",
      mode: r.mode,
      body: s,
      index: i
    };
  },
  htmlBuilder(n, e) {
    var t = ht(n.body, e.havingCrampedStyle());
    t.height === 0 && (t.height = e.fontMetrics().xHeight), t = H.wrapFragment(t, e);
    var r = e.fontMetrics(), i = r.defaultRuleThickness, s = i;
    e.style.id < We.TEXT.id && (s = e.fontMetrics().xHeight);
    var o = i + s / 4, l = t.height + t.depth + o + i, {
      span: a,
      ruleWidth: c,
      advanceWidth: u
    } = oo.sqrtImage(l, e), h = a.height - c;
    h > t.height + t.depth + o && (o = (o + h - t.height - t.depth) / 2);
    var f = a.height - t.height - o - c;
    t.style.paddingLeft = fe(u);
    var d = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(t.height + f)
      }, {
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: c
      }]
    }, e);
    if (n.index) {
      var p = e.havingStyle(We.SCRIPTSCRIPT), m = ht(n.index, p, e), g = 0.6 * (d.height - d.depth), b = H.makeVList({
        positionType: "shift",
        positionData: -g,
        children: [{
          type: "elem",
          elem: m
        }]
      }, e), w = H.makeSpan(["root"], [b]);
      return H.makeSpan(["mord", "sqrt"], [w, d], e);
    } else
      return H.makeSpan(["mord", "sqrt"], [d], e);
  },
  mathmlBuilder(n, e) {
    var {
      body: t,
      index: r
    } = n;
    return r ? new ne.MathNode("mroot", [Rt(t, e), Rt(r, e)]) : new ne.MathNode("msqrt", [Rt(t, e)]);
  }
});
var I9 = {
  display: We.DISPLAY,
  text: We.TEXT,
  script: We.SCRIPT,
  scriptscript: We.SCRIPTSCRIPT
};
ve({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n, e) {
    var {
      breakOnTokenText: t,
      funcName: r,
      parser: i
    } = n, s = i.parseExpression(!0, t), o = r.slice(1, r.length - 5);
    return {
      type: "styling",
      mode: i.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: o,
      body: s
    };
  },
  htmlBuilder(n, e) {
    var t = I9[n.style], r = e.havingStyle(t).withFont("");
    return MN(n.body, r, e);
  },
  mathmlBuilder(n, e) {
    var t = I9[n.style], r = e.havingStyle(t), i = Pr(n.body, r), s = new ne.MathNode("mstyle", i), o = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, l = o[n.style];
    return s.setAttribute("scriptlevel", l[0]), s.setAttribute("displaystyle", l[1]), s;
  }
});
var Sle = function(e, t) {
  var r = e.base;
  if (r)
    if (r.type === "op") {
      var i = r.limits && (t.style.size === We.DISPLAY.size || r.alwaysHandleSupSub);
      return i ? yu : null;
    } else if (r.type === "operatorname") {
      var s = r.alwaysHandleSupSub && (t.style.size === We.DISPLAY.size || r.limits);
      return s ? CN : null;
    } else {
      if (r.type === "accent")
        return Be.isCharacterBox(r.base) ? v7 : null;
      if (r.type === "horizBrace") {
        var o = !e.sub;
        return o === r.isOver ? xN : null;
      } else
        return null;
    }
  else return null;
};
Va({
  type: "supsub",
  htmlBuilder(n, e) {
    var t = Sle(n, e);
    if (t)
      return t(n, e);
    var {
      base: r,
      sup: i,
      sub: s
    } = n, o = ht(r, e), l, a, c = e.fontMetrics(), u = 0, h = 0, f = r && Be.isCharacterBox(r);
    if (i) {
      var d = e.havingStyle(e.style.sup());
      l = ht(i, d, e), f || (u = o.height - d.fontMetrics().supDrop * d.sizeMultiplier / e.sizeMultiplier);
    }
    if (s) {
      var p = e.havingStyle(e.style.sub());
      a = ht(s, p, e), f || (h = o.depth + p.fontMetrics().subDrop * p.sizeMultiplier / e.sizeMultiplier);
    }
    var m;
    e.style === We.DISPLAY ? m = c.sup1 : e.style.cramped ? m = c.sup3 : m = c.sup2;
    var g = e.sizeMultiplier, b = fe(0.5 / c.ptPerEm / g), w = null;
    if (a) {
      var k = n.base && n.base.type === "op" && n.base.name && (n.base.name === "\\oiint" || n.base.name === "\\oiiint");
      (o instanceof ki || k) && (w = fe(-o.italic));
    }
    var C;
    if (l && a) {
      u = Math.max(u, m, l.depth + 0.25 * c.xHeight), h = Math.max(h, c.sub2);
      var M = c.defaultRuleThickness, T = 4 * M;
      if (u - l.depth - (a.height - h) < T) {
        h = T - (u - l.depth) + a.height;
        var N = 0.8 * c.xHeight - (u - l.depth);
        N > 0 && (u += N, h -= N);
      }
      var B = [{
        type: "elem",
        elem: a,
        shift: h,
        marginRight: b,
        marginLeft: w
      }, {
        type: "elem",
        elem: l,
        shift: -u,
        marginRight: b
      }];
      C = H.makeVList({
        positionType: "individualShift",
        children: B
      }, e);
    } else if (a) {
      h = Math.max(h, c.sub1, a.height - 0.8 * c.xHeight);
      var $ = [{
        type: "elem",
        elem: a,
        marginLeft: w,
        marginRight: b
      }];
      C = H.makeVList({
        positionType: "shift",
        positionData: h,
        children: $
      }, e);
    } else if (l)
      u = Math.max(u, m, l.depth + 0.25 * c.xHeight), C = H.makeVList({
        positionType: "shift",
        positionData: -u,
        children: [{
          type: "elem",
          elem: l,
          marginRight: b
        }]
      }, e);
    else
      throw new Error("supsub must have either sup or sub.");
    var R = L5(o, "right") || "mord";
    return H.makeSpan([R], [o, H.makeSpan(["msupsub"], [C])], e);
  },
  mathmlBuilder(n, e) {
    var t = !1, r, i;
    n.base && n.base.type === "horizBrace" && (i = !!n.sup, i === n.base.isOver && (t = !0, r = n.base.isOver)), n.base && (n.base.type === "op" || n.base.type === "operatorname") && (n.base.parentIsSupSub = !0);
    var s = [Rt(n.base, e)];
    n.sub && s.push(Rt(n.sub, e)), n.sup && s.push(Rt(n.sup, e));
    var o;
    if (t)
      o = r ? "mover" : "munder";
    else if (n.sub)
      if (n.sup) {
        var c = n.base;
        c && c.type === "op" && c.limits && e.style === We.DISPLAY || c && c.type === "operatorname" && c.alwaysHandleSupSub && (e.style === We.DISPLAY || c.limits) ? o = "munderover" : o = "msubsup";
      } else {
        var a = n.base;
        a && a.type === "op" && a.limits && (e.style === We.DISPLAY || a.alwaysHandleSupSub) || a && a.type === "operatorname" && a.alwaysHandleSupSub && (a.limits || e.style === We.DISPLAY) ? o = "munder" : o = "msub";
      }
    else {
      var l = n.base;
      l && l.type === "op" && l.limits && (e.style === We.DISPLAY || l.alwaysHandleSupSub) || l && l.type === "operatorname" && l.alwaysHandleSupSub && (l.limits || e.style === We.DISPLAY) ? o = "mover" : o = "msup";
    }
    return new ne.MathNode(o, s);
  }
});
Va({
  type: "atom",
  htmlBuilder(n, e) {
    return H.mathsym(n.text, n.mode, e, ["m" + n.family]);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mo", [Si(n.text, n.mode)]);
    if (n.family === "bin") {
      var r = y7(n, e);
      r === "bold-italic" && t.setAttribute("mathvariant", r);
    } else n.family === "punct" ? t.setAttribute("separator", "true") : (n.family === "open" || n.family === "close") && t.setAttribute("stretchy", "false");
    return t;
  }
});
var TN = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
Va({
  type: "mathord",
  htmlBuilder(n, e) {
    return H.makeOrd(n, e, "mathord");
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mi", [Si(n.text, n.mode, e)]), r = y7(n, e) || "italic";
    return r !== TN[t.type] && t.setAttribute("mathvariant", r), t;
  }
});
Va({
  type: "textord",
  htmlBuilder(n, e) {
    return H.makeOrd(n, e, "textord");
  },
  mathmlBuilder(n, e) {
    var t = Si(n.text, n.mode, e), r = y7(n, e) || "normal", i;
    return n.mode === "text" ? i = new ne.MathNode("mtext", [t]) : /[0-9]/.test(n.text) ? i = new ne.MathNode("mn", [t]) : n.text === "\\prime" ? i = new ne.MathNode("mo", [t]) : i = new ne.MathNode("mi", [t]), r !== TN[i.type] && i.setAttribute("mathvariant", r), i;
  }
});
var g4 = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, y4 = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
Va({
  type: "spacing",
  htmlBuilder(n, e) {
    if (y4.hasOwnProperty(n.text)) {
      var t = y4[n.text].className || "";
      if (n.mode === "text") {
        var r = H.makeOrd(n, e, "textord");
        return r.classes.push(t), r;
      } else
        return H.makeSpan(["mspace", t], [H.mathsym(n.text, n.mode, e)], e);
    } else {
      if (g4.hasOwnProperty(n.text))
        return H.makeSpan(["mspace", g4[n.text]], [], e);
      throw new se('Unknown type of space "' + n.text + '"');
    }
  },
  mathmlBuilder(n, e) {
    var t;
    if (y4.hasOwnProperty(n.text))
      t = new ne.MathNode("mtext", [new ne.TextNode(" ")]);
    else {
      if (g4.hasOwnProperty(n.text))
        return new ne.MathNode("mspace");
      throw new se('Unknown type of space "' + n.text + '"');
    }
    return t;
  }
});
var D9 = () => {
  var n = new ne.MathNode("mtd", []);
  return n.setAttribute("width", "50%"), n;
};
Va({
  type: "tag",
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mtable", [new ne.MathNode("mtr", [D9(), new ne.MathNode("mtd", [xl(n.body, e)]), D9(), new ne.MathNode("mtd", [xl(n.tag, e)])])]);
    return t.setAttribute("width", "100%"), t;
  }
});
var N9 = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, R9 = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, Cle = {
  "\\textit": "textit",
  "\\textup": "textup"
}, P9 = (n, e) => {
  var t = n.font;
  if (t) {
    if (N9[t])
      return e.withTextFontFamily(N9[t]);
    if (R9[t])
      return e.withTextFontWeight(R9[t]);
    if (t === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(Cle[t]);
};
ve({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "text",
      mode: t.mode,
      body: cn(i),
      font: r
    };
  },
  htmlBuilder(n, e) {
    var t = P9(n, e), r = xn(n.body, t, !0);
    return H.makeSpan(["mord", "text"], r, t);
  },
  mathmlBuilder(n, e) {
    var t = P9(n, e);
    return xl(n.body, t);
  }
});
ve({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "underline",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = ht(n.body, e), r = H.makeLineSpan("underline-line", e), i = e.fontMetrics().defaultRuleThickness, s = H.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return H.makeSpan(["mord", "underline"], [s], e);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mo", [new ne.TextNode("‾")]);
    t.setAttribute("stretchy", "true");
    var r = new ne.MathNode("munder", [Rt(n.body, e), t]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
ve({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "vcenter",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = ht(n.body, e), r = e.fontMetrics().axisHeight, i = 0.5 * (t.height - r - (t.depth + r));
    return H.makeVList({
      positionType: "shift",
      positionData: i,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(n, e) {
    return new ne.MathNode("mpadded", [Rt(n.body, e)], ["vcenter"]);
  }
});
ve({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(n, e, t) {
    throw new se("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(n, e) {
    for (var t = _9(n), r = [], i = e.havingStyle(e.style.text()), s = 0; s < t.length; s++) {
      var o = t[s];
      o === "~" && (o = "\\textasciitilde"), r.push(H.makeSymbol(o, "Typewriter-Regular", n.mode, i, ["mord", "texttt"]));
    }
    return H.makeSpan(["mord", "text"].concat(i.sizingClasses(e)), H.tryCombineChars(r), i);
  },
  mathmlBuilder(n, e) {
    var t = new ne.TextNode(_9(n)), r = new ne.MathNode("mtext", [t]);
    return r.setAttribute("mathvariant", "monospace"), r;
  }
});
var _9 = (n) => n.body.replace(/ /g, n.star ? "␣" : " "), rl = YD, AN = `[ \r
	]`, Mle = "\\\\[a-zA-Z@]+", Tle = "\\\\[^\uD800-\uDFFF]", Ale = "(" + Mle + ")" + AN + "*", Ole = `\\\\(
|[ \r	]+
?)[ \r	]*`, H5 = "[̀-ͯ]", Ele = new RegExp(H5 + "+$"), Ile = "(" + AN + "+)|" + // whitespace
(Ole + "|") + // \whitespace
"([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
(H5 + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(H5 + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + Ale) + // \macroName + spaces
("|" + Tle + ")");
class L9 {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(e, t) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = e, this.settings = t, this.tokenRegex = new RegExp(Ile, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(e, t) {
    this.catcodes[e] = t;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var e = this.input, t = this.tokenRegex.lastIndex;
    if (t === e.length)
      return new bi("EOF", new Wr(this, t, t));
    var r = this.tokenRegex.exec(e);
    if (r === null || r.index !== t)
      throw new se("Unexpected character: '" + e[t] + "'", new bi(e[t], new Wr(this, t, t + 1)));
    var i = r[6] || r[3] || (r[2] ? "\\ " : " ");
    if (this.catcodes[i] === 14) {
      var s = e.indexOf(`
`, this.tokenRegex.lastIndex);
      return s === -1 ? (this.tokenRegex.lastIndex = e.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = s + 1, this.lex();
    }
    return new bi(i, new Wr(this, t, this.tokenRegex.lastIndex));
  }
}
class Dle {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(e, t) {
    e === void 0 && (e = {}), t === void 0 && (t = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = t, this.builtins = e, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new se("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var e = this.undefStack.pop();
    for (var t in e)
      e.hasOwnProperty(t) && (e[t] == null ? delete this.current[t] : this.current[t] = e[t]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(e) {
    return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(e) {
    return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(e, t, r) {
    if (r === void 0 && (r = !1), r) {
      for (var i = 0; i < this.undefStack.length; i++)
        delete this.undefStack[i][e];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = t);
    } else {
      var s = this.undefStack[this.undefStack.length - 1];
      s && !s.hasOwnProperty(e) && (s[e] = this.current[e]);
    }
    t == null ? delete this.current[e] : this.current[e] = t;
  }
}
var Nle = gN;
S("\\noexpand", function(n) {
  var e = n.popToken();
  return n.isExpandable(e.text) && (e.noexpand = !0, e.treatAsRelax = !0), {
    tokens: [e],
    numArgs: 0
  };
});
S("\\expandafter", function(n) {
  var e = n.popToken();
  return n.expandOnce(!0), {
    tokens: [e],
    numArgs: 0
  };
});
S("\\@firstoftwo", function(n) {
  var e = n.consumeArgs(2);
  return {
    tokens: e[0],
    numArgs: 0
  };
});
S("\\@secondoftwo", function(n) {
  var e = n.consumeArgs(2);
  return {
    tokens: e[1],
    numArgs: 0
  };
});
S("\\@ifnextchar", function(n) {
  var e = n.consumeArgs(3);
  n.consumeSpaces();
  var t = n.future();
  return e[0].length === 1 && e[0][0].text === t.text ? {
    tokens: e[1],
    numArgs: 0
  } : {
    tokens: e[2],
    numArgs: 0
  };
});
S("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
S("\\TextOrMath", function(n) {
  var e = n.consumeArgs(2);
  return n.mode === "text" ? {
    tokens: e[0],
    numArgs: 0
  } : {
    tokens: e[1],
    numArgs: 0
  };
});
var B9 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
S("\\char", function(n) {
  var e = n.popToken(), t, r = "";
  if (e.text === "'")
    t = 8, e = n.popToken();
  else if (e.text === '"')
    t = 16, e = n.popToken();
  else if (e.text === "`")
    if (e = n.popToken(), e.text[0] === "\\")
      r = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new se("\\char` missing argument");
      r = e.text.charCodeAt(0);
    }
  else
    t = 10;
  if (t) {
    if (r = B9[e.text], r == null || r >= t)
      throw new se("Invalid base-" + t + " digit " + e.text);
    for (var i; (i = B9[n.future().text]) != null && i < t; )
      r *= t, r += i, n.popToken();
  }
  return "\\@char{" + r + "}";
});
var A7 = (n, e, t, r) => {
  var i = n.consumeArg().tokens;
  if (i.length !== 1)
    throw new se("\\newcommand's first argument must be a macro name");
  var s = i[0].text, o = n.isDefined(s);
  if (o && !e)
    throw new se("\\newcommand{" + s + "} attempting to redefine " + (s + "; use \\renewcommand"));
  if (!o && !t)
    throw new se("\\renewcommand{" + s + "} when command " + s + " does not yet exist; use \\newcommand");
  var l = 0;
  if (i = n.consumeArg().tokens, i.length === 1 && i[0].text === "[") {
    for (var a = "", c = n.expandNextToken(); c.text !== "]" && c.text !== "EOF"; )
      a += c.text, c = n.expandNextToken();
    if (!a.match(/^\s*[0-9]+\s*$/))
      throw new se("Invalid number of arguments: " + a);
    l = parseInt(a), i = n.consumeArg().tokens;
  }
  return o && r || n.macros.set(s, {
    tokens: i,
    numArgs: l
  }), "";
};
S("\\newcommand", (n) => A7(n, !1, !0, !1));
S("\\renewcommand", (n) => A7(n, !0, !1, !1));
S("\\providecommand", (n) => A7(n, !0, !0, !0));
S("\\message", (n) => {
  var e = n.consumeArgs(1)[0];
  return console.log(e.reverse().map((t) => t.text).join("")), "";
});
S("\\errmessage", (n) => {
  var e = n.consumeArgs(1)[0];
  return console.error(e.reverse().map((t) => t.text).join("")), "";
});
S("\\show", (n) => {
  var e = n.popToken(), t = e.text;
  return console.log(e, n.macros.get(t), rl[t], zt.math[t], zt.text[t]), "";
});
S("\\bgroup", "{");
S("\\egroup", "}");
S("~", "\\nobreakspace");
S("\\lq", "`");
S("\\rq", "'");
S("\\aa", "\\r a");
S("\\AA", "\\r A");
S("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
S("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
S("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
S("ℬ", "\\mathscr{B}");
S("ℰ", "\\mathscr{E}");
S("ℱ", "\\mathscr{F}");
S("ℋ", "\\mathscr{H}");
S("ℐ", "\\mathscr{I}");
S("ℒ", "\\mathscr{L}");
S("ℳ", "\\mathscr{M}");
S("ℛ", "\\mathscr{R}");
S("ℭ", "\\mathfrak{C}");
S("ℌ", "\\mathfrak{H}");
S("ℨ", "\\mathfrak{Z}");
S("\\Bbbk", "\\Bbb{k}");
S("·", "\\cdotp");
S("\\llap", "\\mathllap{\\textrm{#1}}");
S("\\rlap", "\\mathrlap{\\textrm{#1}}");
S("\\clap", "\\mathclap{\\textrm{#1}}");
S("\\mathstrut", "\\vphantom{(}");
S("\\underbar", "\\underline{\\text{#1}}");
S("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
S("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
S("\\ne", "\\neq");
S("≠", "\\neq");
S("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
S("∉", "\\notin");
S("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
S("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
S("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
S("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
S("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
S("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
S("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
S("⟂", "\\perp");
S("‼", "\\mathclose{!\\mkern-0.8mu!}");
S("∌", "\\notni");
S("⌜", "\\ulcorner");
S("⌝", "\\urcorner");
S("⌞", "\\llcorner");
S("⌟", "\\lrcorner");
S("©", "\\copyright");
S("®", "\\textregistered");
S("️", "\\textregistered");
S("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
S("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
S("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
S("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
S("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
S("⋮", "\\vdots");
S("\\varGamma", "\\mathit{\\Gamma}");
S("\\varDelta", "\\mathit{\\Delta}");
S("\\varTheta", "\\mathit{\\Theta}");
S("\\varLambda", "\\mathit{\\Lambda}");
S("\\varXi", "\\mathit{\\Xi}");
S("\\varPi", "\\mathit{\\Pi}");
S("\\varSigma", "\\mathit{\\Sigma}");
S("\\varUpsilon", "\\mathit{\\Upsilon}");
S("\\varPhi", "\\mathit{\\Phi}");
S("\\varPsi", "\\mathit{\\Psi}");
S("\\varOmega", "\\mathit{\\Omega}");
S("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
S("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
S("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
S("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
S("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
S("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
S("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
S("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var z9 = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
S("\\dots", function(n) {
  var e = "\\dotso", t = n.expandAfterFuture().text;
  return t in z9 ? e = z9[t] : (t.slice(0, 4) === "\\not" || t in zt.math && Be.contains(["bin", "rel"], zt.math[t].group)) && (e = "\\dotsb"), e;
});
var O7 = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
S("\\dotso", function(n) {
  var e = n.future().text;
  return e in O7 ? "\\ldots\\," : "\\ldots";
});
S("\\dotsc", function(n) {
  var e = n.future().text;
  return e in O7 && e !== "," ? "\\ldots\\," : "\\ldots";
});
S("\\cdots", function(n) {
  var e = n.future().text;
  return e in O7 ? "\\@cdots\\," : "\\@cdots";
});
S("\\dotsb", "\\cdots");
S("\\dotsm", "\\cdots");
S("\\dotsi", "\\!\\cdots");
S("\\dotsx", "\\ldots\\,");
S("\\DOTSI", "\\relax");
S("\\DOTSB", "\\relax");
S("\\DOTSX", "\\relax");
S("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
S("\\,", "\\tmspace+{3mu}{.1667em}");
S("\\thinspace", "\\,");
S("\\>", "\\mskip{4mu}");
S("\\:", "\\tmspace+{4mu}{.2222em}");
S("\\medspace", "\\:");
S("\\;", "\\tmspace+{5mu}{.2777em}");
S("\\thickspace", "\\;");
S("\\!", "\\tmspace-{3mu}{.1667em}");
S("\\negthinspace", "\\!");
S("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
S("\\negthickspace", "\\tmspace-{5mu}{.277em}");
S("\\enspace", "\\kern.5em ");
S("\\enskip", "\\hskip.5em\\relax");
S("\\quad", "\\hskip1em\\relax");
S("\\qquad", "\\hskip2em\\relax");
S("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
S("\\tag@paren", "\\tag@literal{({#1})}");
S("\\tag@literal", (n) => {
  if (n.macros.get("\\df@tag"))
    throw new se("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
S("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
S("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
S("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
S("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
S("\\newline", "\\\\\\relax");
S("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var ON = fe(ms["Main-Regular"][84][1] - 0.7 * ms["Main-Regular"][65][1]);
S("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + ON + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
S("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + ON + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
S("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
S("\\@hspace", "\\hskip #1\\relax");
S("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
S("\\ordinarycolon", ":");
S("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
S("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
S("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
S("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
S("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
S("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
S("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
S("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
S("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
S("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
S("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
S("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
S("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
S("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
S("∷", "\\dblcolon");
S("∹", "\\eqcolon");
S("≔", "\\coloneqq");
S("≕", "\\eqqcolon");
S("⩴", "\\Coloneqq");
S("\\ratio", "\\vcentcolon");
S("\\coloncolon", "\\dblcolon");
S("\\colonequals", "\\coloneqq");
S("\\coloncolonequals", "\\Coloneqq");
S("\\equalscolon", "\\eqqcolon");
S("\\equalscoloncolon", "\\Eqqcolon");
S("\\colonminus", "\\coloneq");
S("\\coloncolonminus", "\\Coloneq");
S("\\minuscolon", "\\eqcolon");
S("\\minuscoloncolon", "\\Eqcolon");
S("\\coloncolonapprox", "\\Colonapprox");
S("\\coloncolonsim", "\\Colonsim");
S("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
S("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
S("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
S("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
S("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
S("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
S("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
S("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
S("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
S("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
S("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
S("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
S("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
S("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
S("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
S("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
S("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
S("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
S("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
S("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
S("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
S("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
S("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
S("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
S("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
S("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
S("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
S("\\imath", "\\html@mathml{\\@imath}{ı}");
S("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
S("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
S("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
S("⟦", "\\llbracket");
S("⟧", "\\rrbracket");
S("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
S("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
S("⦃", "\\lBrace");
S("⦄", "\\rBrace");
S("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
S("⦵", "\\minuso");
S("\\darr", "\\downarrow");
S("\\dArr", "\\Downarrow");
S("\\Darr", "\\Downarrow");
S("\\lang", "\\langle");
S("\\rang", "\\rangle");
S("\\uarr", "\\uparrow");
S("\\uArr", "\\Uparrow");
S("\\Uarr", "\\Uparrow");
S("\\N", "\\mathbb{N}");
S("\\R", "\\mathbb{R}");
S("\\Z", "\\mathbb{Z}");
S("\\alef", "\\aleph");
S("\\alefsym", "\\aleph");
S("\\Alpha", "\\mathrm{A}");
S("\\Beta", "\\mathrm{B}");
S("\\bull", "\\bullet");
S("\\Chi", "\\mathrm{X}");
S("\\clubs", "\\clubsuit");
S("\\cnums", "\\mathbb{C}");
S("\\Complex", "\\mathbb{C}");
S("\\Dagger", "\\ddagger");
S("\\diamonds", "\\diamondsuit");
S("\\empty", "\\emptyset");
S("\\Epsilon", "\\mathrm{E}");
S("\\Eta", "\\mathrm{H}");
S("\\exist", "\\exists");
S("\\harr", "\\leftrightarrow");
S("\\hArr", "\\Leftrightarrow");
S("\\Harr", "\\Leftrightarrow");
S("\\hearts", "\\heartsuit");
S("\\image", "\\Im");
S("\\infin", "\\infty");
S("\\Iota", "\\mathrm{I}");
S("\\isin", "\\in");
S("\\Kappa", "\\mathrm{K}");
S("\\larr", "\\leftarrow");
S("\\lArr", "\\Leftarrow");
S("\\Larr", "\\Leftarrow");
S("\\lrarr", "\\leftrightarrow");
S("\\lrArr", "\\Leftrightarrow");
S("\\Lrarr", "\\Leftrightarrow");
S("\\Mu", "\\mathrm{M}");
S("\\natnums", "\\mathbb{N}");
S("\\Nu", "\\mathrm{N}");
S("\\Omicron", "\\mathrm{O}");
S("\\plusmn", "\\pm");
S("\\rarr", "\\rightarrow");
S("\\rArr", "\\Rightarrow");
S("\\Rarr", "\\Rightarrow");
S("\\real", "\\Re");
S("\\reals", "\\mathbb{R}");
S("\\Reals", "\\mathbb{R}");
S("\\Rho", "\\mathrm{P}");
S("\\sdot", "\\cdot");
S("\\sect", "\\S");
S("\\spades", "\\spadesuit");
S("\\sub", "\\subset");
S("\\sube", "\\subseteq");
S("\\supe", "\\supseteq");
S("\\Tau", "\\mathrm{T}");
S("\\thetasym", "\\vartheta");
S("\\weierp", "\\wp");
S("\\Zeta", "\\mathrm{Z}");
S("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
S("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
S("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
S("\\bra", "\\mathinner{\\langle{#1}|}");
S("\\ket", "\\mathinner{|{#1}\\rangle}");
S("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
S("\\Bra", "\\left\\langle#1\\right|");
S("\\Ket", "\\left|#1\\right\\rangle");
var EN = (n) => (e) => {
  var t = e.consumeArg().tokens, r = e.consumeArg().tokens, i = e.consumeArg().tokens, s = e.consumeArg().tokens, o = e.macros.get("|"), l = e.macros.get("\\|");
  e.macros.beginGroup();
  var a = (h) => (f) => {
    n && (f.macros.set("|", o), i.length && f.macros.set("\\|", l));
    var d = h;
    if (!h && i.length) {
      var p = f.future();
      p.text === "|" && (f.popToken(), d = !0);
    }
    return {
      tokens: d ? i : r,
      numArgs: 0
    };
  };
  e.macros.set("|", a(!1)), i.length && e.macros.set("\\|", a(!0));
  var c = e.consumeArg().tokens, u = e.expandTokens([
    ...s,
    ...c,
    ...t
    // reversed
  ]);
  return e.macros.endGroup(), {
    tokens: u.reverse(),
    numArgs: 0
  };
};
S("\\bra@ket", EN(!1));
S("\\bra@set", EN(!0));
S("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
S("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
S("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
S("\\angln", "{\\angl n}");
S("\\blue", "\\textcolor{##6495ed}{#1}");
S("\\orange", "\\textcolor{##ffa500}{#1}");
S("\\pink", "\\textcolor{##ff00af}{#1}");
S("\\red", "\\textcolor{##df0030}{#1}");
S("\\green", "\\textcolor{##28ae7b}{#1}");
S("\\gray", "\\textcolor{gray}{#1}");
S("\\purple", "\\textcolor{##9d38bd}{#1}");
S("\\blueA", "\\textcolor{##ccfaff}{#1}");
S("\\blueB", "\\textcolor{##80f6ff}{#1}");
S("\\blueC", "\\textcolor{##63d9ea}{#1}");
S("\\blueD", "\\textcolor{##11accd}{#1}");
S("\\blueE", "\\textcolor{##0c7f99}{#1}");
S("\\tealA", "\\textcolor{##94fff5}{#1}");
S("\\tealB", "\\textcolor{##26edd5}{#1}");
S("\\tealC", "\\textcolor{##01d1c1}{#1}");
S("\\tealD", "\\textcolor{##01a995}{#1}");
S("\\tealE", "\\textcolor{##208170}{#1}");
S("\\greenA", "\\textcolor{##b6ffb0}{#1}");
S("\\greenB", "\\textcolor{##8af281}{#1}");
S("\\greenC", "\\textcolor{##74cf70}{#1}");
S("\\greenD", "\\textcolor{##1fab54}{#1}");
S("\\greenE", "\\textcolor{##0d923f}{#1}");
S("\\goldA", "\\textcolor{##ffd0a9}{#1}");
S("\\goldB", "\\textcolor{##ffbb71}{#1}");
S("\\goldC", "\\textcolor{##ff9c39}{#1}");
S("\\goldD", "\\textcolor{##e07d10}{#1}");
S("\\goldE", "\\textcolor{##a75a05}{#1}");
S("\\redA", "\\textcolor{##fca9a9}{#1}");
S("\\redB", "\\textcolor{##ff8482}{#1}");
S("\\redC", "\\textcolor{##f9685d}{#1}");
S("\\redD", "\\textcolor{##e84d39}{#1}");
S("\\redE", "\\textcolor{##bc2612}{#1}");
S("\\maroonA", "\\textcolor{##ffbde0}{#1}");
S("\\maroonB", "\\textcolor{##ff92c6}{#1}");
S("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
S("\\maroonD", "\\textcolor{##ca337c}{#1}");
S("\\maroonE", "\\textcolor{##9e034e}{#1}");
S("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
S("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
S("\\purpleC", "\\textcolor{##aa87ff}{#1}");
S("\\purpleD", "\\textcolor{##7854ab}{#1}");
S("\\purpleE", "\\textcolor{##543b78}{#1}");
S("\\mintA", "\\textcolor{##f5f9e8}{#1}");
S("\\mintB", "\\textcolor{##edf2df}{#1}");
S("\\mintC", "\\textcolor{##e0e5cc}{#1}");
S("\\grayA", "\\textcolor{##f6f7f7}{#1}");
S("\\grayB", "\\textcolor{##f0f1f2}{#1}");
S("\\grayC", "\\textcolor{##e3e5e6}{#1}");
S("\\grayD", "\\textcolor{##d6d8da}{#1}");
S("\\grayE", "\\textcolor{##babec2}{#1}");
S("\\grayF", "\\textcolor{##888d93}{#1}");
S("\\grayG", "\\textcolor{##626569}{#1}");
S("\\grayH", "\\textcolor{##3b3e40}{#1}");
S("\\grayI", "\\textcolor{##21242c}{#1}");
S("\\kaBlue", "\\textcolor{##314453}{#1}");
S("\\kaGreen", "\\textcolor{##71B307}{#1}");
var IN = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class Rle {
  constructor(e, t, r) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = t, this.expansionCount = 0, this.feed(e), this.macros = new Dle(Nle, t.macros), this.mode = r, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(e) {
    this.lexer = new L9(e, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(e) {
    this.stack.push(e);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(e) {
    this.stack.push(...e);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(e) {
    var t, r, i;
    if (e) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      t = this.popToken(), {
        tokens: i,
        end: r
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: i,
        start: t,
        end: r
      } = this.consumeArg());
    return this.pushToken(new bi("EOF", r.loc)), this.pushTokens(i), t.range(r, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var e = this.future();
      if (e.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(e) {
    var t = [], r = e && e.length > 0;
    r || this.consumeSpaces();
    var i = this.future(), s, o = 0, l = 0;
    do {
      if (s = this.popToken(), t.push(s), s.text === "{")
        ++o;
      else if (s.text === "}") {
        if (--o, o === -1)
          throw new se("Extra }", s);
      } else if (s.text === "EOF")
        throw new se("Unexpected end of input in a macro argument, expected '" + (e && r ? e[l] : "}") + "'", s);
      if (e && r)
        if ((o === 0 || o === 1 && e[l] === "{") && s.text === e[l]) {
          if (++l, l === e.length) {
            t.splice(-l, l);
            break;
          }
        } else
          l = 0;
    } while (o !== 0 || r);
    return i.text === "{" && t[t.length - 1].text === "}" && (t.pop(), t.shift()), t.reverse(), {
      tokens: t,
      start: i,
      end: s
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(e, t) {
    if (t) {
      if (t.length !== e + 1)
        throw new se("The length of delimiters doesn't match the number of args!");
      for (var r = t[0], i = 0; i < r.length; i++) {
        var s = this.popToken();
        if (r[i] !== s.text)
          throw new se("Use of the macro doesn't match its definition", s);
      }
    }
    for (var o = [], l = 0; l < e; l++)
      o.push(this.consumeArg(t && t[l + 1]).tokens);
    return o;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(e) {
    if (this.expansionCount += e, this.expansionCount > this.settings.maxExpand)
      throw new se("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(e) {
    var t = this.popToken(), r = t.text, i = t.noexpand ? null : this._getExpansion(r);
    if (i == null || e && i.unexpandable) {
      if (e && i == null && r[0] === "\\" && !this.isDefined(r))
        throw new se("Undefined control sequence: " + r);
      return this.pushToken(t), !1;
    }
    this.countExpansion(1);
    var s = i.tokens, o = this.consumeArgs(i.numArgs, i.delimiters);
    if (i.numArgs) {
      s = s.slice();
      for (var l = s.length - 1; l >= 0; --l) {
        var a = s[l];
        if (a.text === "#") {
          if (l === 0)
            throw new se("Incomplete placeholder at end of macro body", a);
          if (a = s[--l], a.text === "#")
            s.splice(l + 1, 1);
          else if (/^[1-9]$/.test(a.text))
            s.splice(l, 2, ...o[+a.text - 1]);
          else
            throw new se("Not a valid argument number", a);
        }
      }
    }
    return this.pushTokens(s), s.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var e = this.stack.pop();
        return e.treatAsRelax && (e.text = "\\relax"), e;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(e) {
    return this.macros.has(e) ? this.expandTokens([new bi(e)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(e) {
    var t = [], r = this.stack.length;
    for (this.pushTokens(e); this.stack.length > r; )
      if (this.expandOnce(!0) === !1) {
        var i = this.stack.pop();
        i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), t.push(i);
      }
    return this.countExpansion(t.length), t;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(e) {
    var t = this.expandMacro(e);
    return t && t.map((r) => r.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(e) {
    var t = this.macros.get(e);
    if (t == null)
      return t;
    if (e.length === 1) {
      var r = this.lexer.catcodes[e];
      if (r != null && r !== 13)
        return;
    }
    var i = typeof t == "function" ? t(this) : t;
    if (typeof i == "string") {
      var s = 0;
      if (i.indexOf("#") !== -1)
        for (var o = i.replace(/##/g, ""); o.indexOf("#" + (s + 1)) !== -1; )
          ++s;
      for (var l = new L9(i, this.settings), a = [], c = l.lex(); c.text !== "EOF"; )
        a.push(c), c = l.lex();
      a.reverse();
      var u = {
        tokens: a,
        numArgs: s
      };
      return u;
    }
    return i;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(e) {
    return this.macros.has(e) || rl.hasOwnProperty(e) || zt.math.hasOwnProperty(e) || zt.text.hasOwnProperty(e) || IN.hasOwnProperty(e);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(e) {
    var t = this.macros.get(e);
    return t != null ? typeof t == "string" || typeof t == "function" || !t.unexpandable : rl.hasOwnProperty(e) && !rl[e].primitive;
  }
}
var F9 = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/, z0 = Object.freeze({
  "₊": "+",
  "₋": "-",
  "₌": "=",
  "₍": "(",
  "₎": ")",
  "₀": "0",
  "₁": "1",
  "₂": "2",
  "₃": "3",
  "₄": "4",
  "₅": "5",
  "₆": "6",
  "₇": "7",
  "₈": "8",
  "₉": "9",
  "ₐ": "a",
  "ₑ": "e",
  "ₕ": "h",
  "ᵢ": "i",
  "ⱼ": "j",
  "ₖ": "k",
  "ₗ": "l",
  "ₘ": "m",
  "ₙ": "n",
  "ₒ": "o",
  "ₚ": "p",
  "ᵣ": "r",
  "ₛ": "s",
  "ₜ": "t",
  "ᵤ": "u",
  "ᵥ": "v",
  "ₓ": "x",
  "ᵦ": "β",
  "ᵧ": "γ",
  "ᵨ": "ρ",
  "ᵩ": "ϕ",
  "ᵪ": "χ",
  "⁺": "+",
  "⁻": "-",
  "⁼": "=",
  "⁽": "(",
  "⁾": ")",
  "⁰": "0",
  "¹": "1",
  "²": "2",
  "³": "3",
  "⁴": "4",
  "⁵": "5",
  "⁶": "6",
  "⁷": "7",
  "⁸": "8",
  "⁹": "9",
  "ᴬ": "A",
  "ᴮ": "B",
  "ᴰ": "D",
  "ᴱ": "E",
  "ᴳ": "G",
  "ᴴ": "H",
  "ᴵ": "I",
  "ᴶ": "J",
  "ᴷ": "K",
  "ᴸ": "L",
  "ᴹ": "M",
  "ᴺ": "N",
  "ᴼ": "O",
  "ᴾ": "P",
  "ᴿ": "R",
  "ᵀ": "T",
  "ᵁ": "U",
  "ⱽ": "V",
  "ᵂ": "W",
  "ᵃ": "a",
  "ᵇ": "b",
  "ᶜ": "c",
  "ᵈ": "d",
  "ᵉ": "e",
  "ᶠ": "f",
  "ᵍ": "g",
  ʰ: "h",
  "ⁱ": "i",
  ʲ: "j",
  "ᵏ": "k",
  ˡ: "l",
  "ᵐ": "m",
  ⁿ: "n",
  "ᵒ": "o",
  "ᵖ": "p",
  ʳ: "r",
  ˢ: "s",
  "ᵗ": "t",
  "ᵘ": "u",
  "ᵛ": "v",
  ʷ: "w",
  ˣ: "x",
  ʸ: "y",
  "ᶻ": "z",
  "ᵝ": "β",
  "ᵞ": "γ",
  "ᵟ": "δ",
  "ᵠ": "ϕ",
  "ᵡ": "χ",
  "ᶿ": "θ"
}), b4 = {
  "́": {
    text: "\\'",
    math: "\\acute"
  },
  "̀": {
    text: "\\`",
    math: "\\grave"
  },
  "̈": {
    text: '\\"',
    math: "\\ddot"
  },
  "̃": {
    text: "\\~",
    math: "\\tilde"
  },
  "̄": {
    text: "\\=",
    math: "\\bar"
  },
  "̆": {
    text: "\\u",
    math: "\\breve"
  },
  "̌": {
    text: "\\v",
    math: "\\check"
  },
  "̂": {
    text: "\\^",
    math: "\\hat"
  },
  "̇": {
    text: "\\.",
    math: "\\dot"
  },
  "̊": {
    text: "\\r",
    math: "\\mathring"
  },
  "̋": {
    text: "\\H"
  },
  "̧": {
    text: "\\c"
  }
}, H9 = {
  á: "á",
  à: "à",
  ä: "ä",
  ǟ: "ǟ",
  ã: "ã",
  ā: "ā",
  ă: "ă",
  ắ: "ắ",
  ằ: "ằ",
  ẵ: "ẵ",
  ǎ: "ǎ",
  â: "â",
  ấ: "ấ",
  ầ: "ầ",
  ẫ: "ẫ",
  ȧ: "ȧ",
  ǡ: "ǡ",
  å: "å",
  ǻ: "ǻ",
  ḃ: "ḃ",
  ć: "ć",
  ḉ: "ḉ",
  č: "č",
  ĉ: "ĉ",
  ċ: "ċ",
  ç: "ç",
  ď: "ď",
  ḋ: "ḋ",
  ḑ: "ḑ",
  é: "é",
  è: "è",
  ë: "ë",
  ẽ: "ẽ",
  ē: "ē",
  ḗ: "ḗ",
  ḕ: "ḕ",
  ĕ: "ĕ",
  ḝ: "ḝ",
  ě: "ě",
  ê: "ê",
  ế: "ế",
  ề: "ề",
  ễ: "ễ",
  ė: "ė",
  ȩ: "ȩ",
  ḟ: "ḟ",
  ǵ: "ǵ",
  ḡ: "ḡ",
  ğ: "ğ",
  ǧ: "ǧ",
  ĝ: "ĝ",
  ġ: "ġ",
  ģ: "ģ",
  ḧ: "ḧ",
  ȟ: "ȟ",
  ĥ: "ĥ",
  ḣ: "ḣ",
  ḩ: "ḩ",
  í: "í",
  ì: "ì",
  ï: "ï",
  ḯ: "ḯ",
  ĩ: "ĩ",
  ī: "ī",
  ĭ: "ĭ",
  ǐ: "ǐ",
  î: "î",
  ǰ: "ǰ",
  ĵ: "ĵ",
  ḱ: "ḱ",
  ǩ: "ǩ",
  ķ: "ķ",
  ĺ: "ĺ",
  ľ: "ľ",
  ļ: "ļ",
  ḿ: "ḿ",
  ṁ: "ṁ",
  ń: "ń",
  ǹ: "ǹ",
  ñ: "ñ",
  ň: "ň",
  ṅ: "ṅ",
  ņ: "ņ",
  ó: "ó",
  ò: "ò",
  ö: "ö",
  ȫ: "ȫ",
  õ: "õ",
  ṍ: "ṍ",
  ṏ: "ṏ",
  ȭ: "ȭ",
  ō: "ō",
  ṓ: "ṓ",
  ṑ: "ṑ",
  ŏ: "ŏ",
  ǒ: "ǒ",
  ô: "ô",
  ố: "ố",
  ồ: "ồ",
  ỗ: "ỗ",
  ȯ: "ȯ",
  ȱ: "ȱ",
  ő: "ő",
  ṕ: "ṕ",
  ṗ: "ṗ",
  ŕ: "ŕ",
  ř: "ř",
  ṙ: "ṙ",
  ŗ: "ŗ",
  ś: "ś",
  ṥ: "ṥ",
  š: "š",
  ṧ: "ṧ",
  ŝ: "ŝ",
  ṡ: "ṡ",
  ş: "ş",
  ẗ: "ẗ",
  ť: "ť",
  ṫ: "ṫ",
  ţ: "ţ",
  ú: "ú",
  ù: "ù",
  ü: "ü",
  ǘ: "ǘ",
  ǜ: "ǜ",
  ǖ: "ǖ",
  ǚ: "ǚ",
  ũ: "ũ",
  ṹ: "ṹ",
  ū: "ū",
  ṻ: "ṻ",
  ŭ: "ŭ",
  ǔ: "ǔ",
  û: "û",
  ů: "ů",
  ű: "ű",
  ṽ: "ṽ",
  ẃ: "ẃ",
  ẁ: "ẁ",
  ẅ: "ẅ",
  ŵ: "ŵ",
  ẇ: "ẇ",
  ẘ: "ẘ",
  ẍ: "ẍ",
  ẋ: "ẋ",
  ý: "ý",
  ỳ: "ỳ",
  ÿ: "ÿ",
  ỹ: "ỹ",
  ȳ: "ȳ",
  ŷ: "ŷ",
  ẏ: "ẏ",
  ẙ: "ẙ",
  ź: "ź",
  ž: "ž",
  ẑ: "ẑ",
  ż: "ż",
  Á: "Á",
  À: "À",
  Ä: "Ä",
  Ǟ: "Ǟ",
  Ã: "Ã",
  Ā: "Ā",
  Ă: "Ă",
  Ắ: "Ắ",
  Ằ: "Ằ",
  Ẵ: "Ẵ",
  Ǎ: "Ǎ",
  Â: "Â",
  Ấ: "Ấ",
  Ầ: "Ầ",
  Ẫ: "Ẫ",
  Ȧ: "Ȧ",
  Ǡ: "Ǡ",
  Å: "Å",
  Ǻ: "Ǻ",
  Ḃ: "Ḃ",
  Ć: "Ć",
  Ḉ: "Ḉ",
  Č: "Č",
  Ĉ: "Ĉ",
  Ċ: "Ċ",
  Ç: "Ç",
  Ď: "Ď",
  Ḋ: "Ḋ",
  Ḑ: "Ḑ",
  É: "É",
  È: "È",
  Ë: "Ë",
  Ẽ: "Ẽ",
  Ē: "Ē",
  Ḗ: "Ḗ",
  Ḕ: "Ḕ",
  Ĕ: "Ĕ",
  Ḝ: "Ḝ",
  Ě: "Ě",
  Ê: "Ê",
  Ế: "Ế",
  Ề: "Ề",
  Ễ: "Ễ",
  Ė: "Ė",
  Ȩ: "Ȩ",
  Ḟ: "Ḟ",
  Ǵ: "Ǵ",
  Ḡ: "Ḡ",
  Ğ: "Ğ",
  Ǧ: "Ǧ",
  Ĝ: "Ĝ",
  Ġ: "Ġ",
  Ģ: "Ģ",
  Ḧ: "Ḧ",
  Ȟ: "Ȟ",
  Ĥ: "Ĥ",
  Ḣ: "Ḣ",
  Ḩ: "Ḩ",
  Í: "Í",
  Ì: "Ì",
  Ï: "Ï",
  Ḯ: "Ḯ",
  Ĩ: "Ĩ",
  Ī: "Ī",
  Ĭ: "Ĭ",
  Ǐ: "Ǐ",
  Î: "Î",
  İ: "İ",
  Ĵ: "Ĵ",
  Ḱ: "Ḱ",
  Ǩ: "Ǩ",
  Ķ: "Ķ",
  Ĺ: "Ĺ",
  Ľ: "Ľ",
  Ļ: "Ļ",
  Ḿ: "Ḿ",
  Ṁ: "Ṁ",
  Ń: "Ń",
  Ǹ: "Ǹ",
  Ñ: "Ñ",
  Ň: "Ň",
  Ṅ: "Ṅ",
  Ņ: "Ņ",
  Ó: "Ó",
  Ò: "Ò",
  Ö: "Ö",
  Ȫ: "Ȫ",
  Õ: "Õ",
  Ṍ: "Ṍ",
  Ṏ: "Ṏ",
  Ȭ: "Ȭ",
  Ō: "Ō",
  Ṓ: "Ṓ",
  Ṑ: "Ṑ",
  Ŏ: "Ŏ",
  Ǒ: "Ǒ",
  Ô: "Ô",
  Ố: "Ố",
  Ồ: "Ồ",
  Ỗ: "Ỗ",
  Ȯ: "Ȯ",
  Ȱ: "Ȱ",
  Ő: "Ő",
  Ṕ: "Ṕ",
  Ṗ: "Ṗ",
  Ŕ: "Ŕ",
  Ř: "Ř",
  Ṙ: "Ṙ",
  Ŗ: "Ŗ",
  Ś: "Ś",
  Ṥ: "Ṥ",
  Š: "Š",
  Ṧ: "Ṧ",
  Ŝ: "Ŝ",
  Ṡ: "Ṡ",
  Ş: "Ş",
  Ť: "Ť",
  Ṫ: "Ṫ",
  Ţ: "Ţ",
  Ú: "Ú",
  Ù: "Ù",
  Ü: "Ü",
  Ǘ: "Ǘ",
  Ǜ: "Ǜ",
  Ǖ: "Ǖ",
  Ǚ: "Ǚ",
  Ũ: "Ũ",
  Ṹ: "Ṹ",
  Ū: "Ū",
  Ṻ: "Ṻ",
  Ŭ: "Ŭ",
  Ǔ: "Ǔ",
  Û: "Û",
  Ů: "Ů",
  Ű: "Ű",
  Ṽ: "Ṽ",
  Ẃ: "Ẃ",
  Ẁ: "Ẁ",
  Ẅ: "Ẅ",
  Ŵ: "Ŵ",
  Ẇ: "Ẇ",
  Ẍ: "Ẍ",
  Ẋ: "Ẋ",
  Ý: "Ý",
  Ỳ: "Ỳ",
  Ÿ: "Ÿ",
  Ỹ: "Ỹ",
  Ȳ: "Ȳ",
  Ŷ: "Ŷ",
  Ẏ: "Ẏ",
  Ź: "Ź",
  Ž: "Ž",
  Ẑ: "Ẑ",
  Ż: "Ż",
  ά: "ά",
  ὰ: "ὰ",
  ᾱ: "ᾱ",
  ᾰ: "ᾰ",
  έ: "έ",
  ὲ: "ὲ",
  ή: "ή",
  ὴ: "ὴ",
  ί: "ί",
  ὶ: "ὶ",
  ϊ: "ϊ",
  ΐ: "ΐ",
  ῒ: "ῒ",
  ῑ: "ῑ",
  ῐ: "ῐ",
  ό: "ό",
  ὸ: "ὸ",
  ύ: "ύ",
  ὺ: "ὺ",
  ϋ: "ϋ",
  ΰ: "ΰ",
  ῢ: "ῢ",
  ῡ: "ῡ",
  ῠ: "ῠ",
  ώ: "ώ",
  ὼ: "ὼ",
  Ύ: "Ύ",
  Ὺ: "Ὺ",
  Ϋ: "Ϋ",
  Ῡ: "Ῡ",
  Ῠ: "Ῠ",
  Ώ: "Ώ",
  Ὼ: "Ὼ"
};
class mg {
  constructor(e, t) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new Rle(e, t, this.mode), this.settings = t, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(e, t) {
    if (t === void 0 && (t = !0), this.fetch().text !== e)
      throw new se("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
    t && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e, this.gullet.switchMode(e);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var e = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(e) {
    var t = this.nextToken;
    this.consume(), this.gullet.pushToken(new bi("}")), this.gullet.pushTokens(e);
    var r = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = t, r;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(e, t) {
    for (var r = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var i = this.fetch();
      if (mg.endOfExpression.indexOf(i.text) !== -1 || t && i.text === t || e && rl[i.text] && rl[i.text].infix)
        break;
      var s = this.parseAtom(t);
      if (s) {
        if (s.type === "internal")
          continue;
      } else break;
      r.push(s);
    }
    return this.mode === "text" && this.formLigatures(r), this.handleInfixNodes(r);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(e) {
    for (var t = -1, r, i = 0; i < e.length; i++)
      if (e[i].type === "infix") {
        if (t !== -1)
          throw new se("only one infix operator per group", e[i].token);
        t = i, r = e[i].replaceWith;
      }
    if (t !== -1 && r) {
      var s, o, l = e.slice(0, t), a = e.slice(t + 1);
      l.length === 1 && l[0].type === "ordgroup" ? s = l[0] : s = {
        type: "ordgroup",
        mode: this.mode,
        body: l
      }, a.length === 1 && a[0].type === "ordgroup" ? o = a[0] : o = {
        type: "ordgroup",
        mode: this.mode,
        body: a
      };
      var c;
      return r === "\\\\abovefrac" ? c = this.callFunction(r, [s, e[t], o], []) : c = this.callFunction(r, [s, o], []), [c];
    } else
      return e;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(e) {
    var t = this.fetch(), r = t.text;
    this.consume(), this.consumeSpaces();
    var i;
    do {
      var s;
      i = this.parseGroup(e);
    } while (((s = i) == null ? void 0 : s.type) === "internal");
    if (!i)
      throw new se("Expected group after '" + r + "'", t);
    return i;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.push({
        type: "textord",
        mode: "text",
        text: e[r]
      });
    var i = {
      type: "text",
      mode: this.mode,
      body: t
    }, s = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [i]
    };
    return s;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(e) {
    var t = this.parseGroup("atom", e);
    if (t?.type === "internal" || this.mode === "text")
      return t;
    for (var r, i; ; ) {
      this.consumeSpaces();
      var s = this.fetch();
      if (s.text === "\\limits" || s.text === "\\nolimits") {
        if (t && t.type === "op") {
          var o = s.text === "\\limits";
          t.limits = o, t.alwaysHandleSupSub = !0;
        } else if (t && t.type === "operatorname")
          t.alwaysHandleSupSub && (t.limits = s.text === "\\limits");
        else
          throw new se("Limit controls must follow a math operator", s);
        this.consume();
      } else if (s.text === "^") {
        if (r)
          throw new se("Double superscript", s);
        r = this.handleSupSubscript("superscript");
      } else if (s.text === "_") {
        if (i)
          throw new se("Double subscript", s);
        i = this.handleSupSubscript("subscript");
      } else if (s.text === "'") {
        if (r)
          throw new se("Double superscript", s);
        var l = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, a = [l];
        for (this.consume(); this.fetch().text === "'"; )
          a.push(l), this.consume();
        this.fetch().text === "^" && a.push(this.handleSupSubscript("superscript")), r = {
          type: "ordgroup",
          mode: this.mode,
          body: a
        };
      } else if (z0[s.text]) {
        var c = F9.test(s.text), u = [];
        for (u.push(new bi(z0[s.text])), this.consume(); ; ) {
          var h = this.fetch().text;
          if (!z0[h] || F9.test(h) !== c)
            break;
          u.unshift(new bi(z0[h])), this.consume();
        }
        var f = this.subparse(u);
        c ? i = {
          type: "ordgroup",
          mode: "math",
          body: f
        } : r = {
          type: "ordgroup",
          mode: "math",
          body: f
        };
      } else
        break;
    }
    return r || i ? {
      type: "supsub",
      mode: this.mode,
      base: t,
      sup: r,
      sub: i
    } : t;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(e, t) {
    var r = this.fetch(), i = r.text, s = rl[i];
    if (!s)
      return null;
    if (this.consume(), t && t !== "atom" && !s.allowedInArgument)
      throw new se("Got function '" + i + "' with no arguments" + (t ? " as " + t : ""), r);
    if (this.mode === "text" && !s.allowedInText)
      throw new se("Can't use function '" + i + "' in text mode", r);
    if (this.mode === "math" && s.allowedInMath === !1)
      throw new se("Can't use function '" + i + "' in math mode", r);
    var {
      args: o,
      optArgs: l
    } = this.parseArguments(i, s);
    return this.callFunction(i, o, l, r, e);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(e, t, r, i, s) {
    var o = {
      funcName: e,
      parser: this,
      token: i,
      breakOnTokenText: s
    }, l = rl[e];
    if (l && l.handler)
      return l.handler(o, t, r);
    throw new se("No function handler for " + e);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(e, t) {
    var r = t.numArgs + t.numOptionalArgs;
    if (r === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var i = [], s = [], o = 0; o < r; o++) {
      var l = t.argTypes && t.argTypes[o], a = o < t.numOptionalArgs;
      (t.primitive && l == null || // \sqrt expands into primitive if optional argument doesn't exist
      t.type === "sqrt" && o === 1 && s[0] == null) && (l = "primitive");
      var c = this.parseGroupOfType("argument to '" + e + "'", l, a);
      if (a)
        s.push(c);
      else if (c != null)
        i.push(c);
      else
        throw new se("Null argument, please report this as a bug");
    }
    return {
      args: i,
      optArgs: s
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(e, t, r) {
    switch (t) {
      case "color":
        return this.parseColorGroup(r);
      case "size":
        return this.parseSizeGroup(r);
      case "url":
        return this.parseUrlGroup(r);
      case "math":
      case "text":
        return this.parseArgumentGroup(r, t);
      case "hbox": {
        var i = this.parseArgumentGroup(r, "text");
        return i != null ? {
          type: "styling",
          mode: i.mode,
          body: [i],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var s = this.parseStringGroup("raw", r);
        return s != null ? {
          type: "raw",
          mode: "text",
          string: s.text
        } : null;
      }
      case "primitive": {
        if (r)
          throw new se("A primitive argument cannot be optional");
        var o = this.parseGroup(e);
        if (o == null)
          throw new se("Expected group as " + e, this.fetch());
        return o;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(r);
      default:
        throw new se("Unknown group type as " + e, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(e, t) {
    var r = this.gullet.scanArgument(t);
    if (r == null)
      return null;
    for (var i = "", s; (s = this.fetch()).text !== "EOF"; )
      i += s.text, this.consume();
    return this.consume(), r.text = i, r;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(e, t) {
    for (var r = this.fetch(), i = r, s = "", o; (o = this.fetch()).text !== "EOF" && e.test(s + o.text); )
      i = o, s += i.text, this.consume();
    if (s === "")
      throw new se("Invalid " + t + ": '" + r.text + "'", r);
    return r.range(i, s);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(e) {
    var t = this.parseStringGroup("color", e);
    if (t == null)
      return null;
    var r = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(t.text);
    if (!r)
      throw new se("Invalid color: '" + t.text + "'", t);
    var i = r[0];
    return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
      type: "color-token",
      mode: this.mode,
      color: i
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(e) {
    var t, r = !1;
    if (this.gullet.consumeSpaces(), !e && this.gullet.future().text !== "{" ? t = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : t = this.parseStringGroup("size", e), !t)
      return null;
    !e && t.text.length === 0 && (t.text = "0pt", r = !0);
    var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t.text);
    if (!i)
      throw new se("Invalid size: '" + t.text + "'", t);
    var s = {
      number: +(i[1] + i[2]),
      // sign + magnitude, cast to number
      unit: i[3]
    };
    if (!HD(s))
      throw new se("Invalid unit: '" + s.unit + "'", t);
    return {
      type: "size",
      mode: this.mode,
      value: s,
      isBlank: r
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(e) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var t = this.parseStringGroup("url", e);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), t == null)
      return null;
    var r = t.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: r
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(e, t) {
    var r = this.gullet.scanArgument(e);
    if (r == null)
      return null;
    var i = this.mode;
    t && this.switchMode(t), this.gullet.beginGroup();
    var s = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var o = {
      type: "ordgroup",
      mode: this.mode,
      loc: r.loc,
      body: s
    };
    return t && this.switchMode(i), o;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(e, t) {
    var r = this.fetch(), i = r.text, s;
    if (i === "{" || i === "\\begingroup") {
      this.consume();
      var o = i === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var l = this.parseExpression(!1, o), a = this.fetch();
      this.expect(o), this.gullet.endGroup(), s = {
        type: "ordgroup",
        mode: this.mode,
        loc: Wr.range(r, a),
        body: l,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: i === "\\begingroup" || void 0
      };
    } else if (s = this.parseFunction(t, e) || this.parseSymbol(), s == null && i[0] === "\\" && !IN.hasOwnProperty(i)) {
      if (this.settings.throwOnError)
        throw new se("Undefined control sequence: " + i, r);
      s = this.formatUnsupportedCmd(i), this.consume();
    }
    return s;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(e) {
    for (var t = e.length - 1, r = 0; r < t; ++r) {
      var i = e[r], s = i.text;
      s === "-" && e[r + 1].text === "-" && (r + 1 < t && e[r + 2].text === "-" ? (e.splice(r, 3, {
        type: "textord",
        mode: "text",
        loc: Wr.range(i, e[r + 2]),
        text: "---"
      }), t -= 2) : (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Wr.range(i, e[r + 1]),
        text: "--"
      }), t -= 1)), (s === "'" || s === "`") && e[r + 1].text === s && (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Wr.range(i, e[r + 1]),
        text: s + s
      }), t -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var e = this.fetch(), t = e.text;
    if (/^\\verb[^a-zA-Z]/.test(t)) {
      this.consume();
      var r = t.slice(5), i = r.charAt(0) === "*";
      if (i && (r = r.slice(1)), r.length < 2 || r.charAt(0) !== r.slice(-1))
        throw new se(`\\verb assertion failed --
                    please report what input caused this bug`);
      return r = r.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: r,
        star: i
      };
    }
    H9.hasOwnProperty(t[0]) && !zt[this.mode][t[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + t[0] + '" used in math mode', e), t = H9[t[0]] + t.slice(1));
    var s = Ele.exec(t);
    s && (t = t.substring(0, s.index), t === "i" ? t = "ı" : t === "j" && (t = "ȷ"));
    var o;
    if (zt[this.mode][t]) {
      this.settings.strict && this.mode === "math" && _5.indexOf(t) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + t[0] + '" used in math mode', e);
      var l = zt[this.mode][t].group, a = Wr.range(e), c;
      if (xoe.hasOwnProperty(l)) {
        var u = l;
        c = {
          type: "atom",
          mode: this.mode,
          family: u,
          loc: a,
          text: t
        };
      } else
        c = {
          type: l,
          mode: this.mode,
          loc: a,
          text: t
        };
      o = c;
    } else if (t.charCodeAt(0) >= 128)
      this.settings.strict && (FD(t.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + t[0] + '" used in math mode', e) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + t[0] + '"' + (" (" + t.charCodeAt(0) + ")"), e)), o = {
        type: "textord",
        mode: "text",
        loc: Wr.range(e),
        text: t
      };
    else
      return null;
    if (this.consume(), s)
      for (var h = 0; h < s[0].length; h++) {
        var f = s[0][h];
        if (!b4[f])
          throw new se("Unknown accent ' " + f + "'", e);
        var d = b4[f][this.mode] || b4[f].text;
        if (!d)
          throw new se("Accent " + f + " unsupported in " + this.mode + " mode", e);
        o = {
          type: "accent",
          mode: this.mode,
          loc: Wr.range(e),
          label: d,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: o
        };
      }
    return o;
  }
}
mg.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var E7 = function(e, t) {
  if (!(typeof e == "string" || e instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var r = new mg(e, t);
  delete r.gullet.macros.current["\\df@tag"];
  var i = r.parse();
  if (delete r.gullet.macros.current["\\current@color"], delete r.gullet.macros.current["\\color"], r.gullet.macros.get("\\df@tag")) {
    if (!t.displayMode)
      throw new se("\\tag works only in display equations");
    i = [{
      type: "tag",
      mode: "text",
      body: i,
      tag: r.subparse([new bi("\\df@tag")])
    }];
  }
  return i;
}, DN = function(e, t, r) {
  t.textContent = "";
  var i = I7(e, r).toNode();
  t.appendChild(i);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), DN = function() {
  throw new se("KaTeX doesn't work in quirks mode.");
});
var Ple = function(e, t) {
  var r = I7(e, t).toMarkup();
  return r;
}, _le = function(e, t) {
  var r = new h7(t);
  return E7(e, r);
}, NN = function(e, t, r) {
  if (r.throwOnError || !(e instanceof se))
    throw e;
  var i = H.makeSpan(["katex-error"], [new ki(t)]);
  return i.setAttribute("title", e.toString()), i.setAttribute("style", "color:" + r.errorColor), i;
}, I7 = function(e, t) {
  var r = new h7(t);
  try {
    var i = E7(e, r);
    return Woe(i, e, r);
  } catch (s) {
    return NN(s, e, r);
  }
}, Lle = function(e, t) {
  var r = new h7(t);
  try {
    var i = E7(e, r);
    return joe(i, e, r);
  } catch (s) {
    return NN(s, e, r);
  }
}, Ble = "0.16.22", zle = {
  Span: Ld,
  Anchor: p7,
  SymbolNode: ki,
  SvgNode: mo,
  PathNode: wl,
  LineNode: P5
}, RN = {
  /**
   * Current KaTeX version
   */
  version: Ble,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: DN,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: Ple,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: se,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA: Ip,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: _le,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: I7,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: Lle,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: doe,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: y,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: ve,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: S,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: zle
};
class gg {
  constructor(e) {
    this.#i = !1, this.onShow = () => {
    }, this.onHide = () => {
    }, this.#c = (t, r) => {
      const { state: i, composing: s } = t, { selection: o, doc: l } = i, { ranges: a } = o, c = Math.min(...a.map((d) => d.$from.pos)), u = Math.max(...a.map((d) => d.$to.pos)), h = r && r.doc.eq(l) && r.selection.eq(o);
      if (this.#i || ((this.#a ?? t.dom.parentElement ?? document.body).appendChild(this.element), this.#i = !0), s || h) return;
      if (!this.#e(t, r)) {
        this.hide();
        return;
      }
      Vi({
        getBoundingClientRect: () => b1(t, c, u)
      }, this.element, {
        placement: this.#n.placement ?? "top",
        middleware: [
          Tm(),
          yl(this.#s),
          v8(this.#o),
          ...this.#r
        ]
      }).then(({ x: d, y: p }) => {
        Object.assign(this.element.style, {
          left: `${d}px`,
          top: `${p}px`
        });
      }).catch(console.error), this.show();
    }, this.update = (t, r) => {
      this.#l(t, r);
    }, this.destroy = () => {
      this.#l.cancel();
    }, this.show = (t) => {
      this.element.dataset.show = "true", t && Vi(t, this.element, {
        placement: "top",
        middleware: [
          Tm(),
          yl(this.#s),
          v8(this.#o),
          ...this.#r
        ],
        ...this.#n
      }).then(({ x: r, y: i }) => {
        Object.assign(this.element.style, {
          left: `${r}px`,
          top: `${i}px`
        });
      }).catch(console.error), this.onShow();
    }, this.hide = () => {
      this.element.dataset.show !== "false" && (this.element.dataset.show = "false", this.onHide());
    }, this.element = e.content, this.#t = e.debounce ?? 200, this.#e = e.shouldShow ?? this.#u, this.#s = e.offset, this.#o = e.shift, this.#r = e.middleware ?? [], this.#n = e.floatingUIOptions ?? {}, this.#a = e.root, this.element.dataset.show = "false", this.#l = t1(this.#c, this.#t);
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  /// @internal
  #n;
  /// @internal
  #a;
  #i;
  /// @internal
  #s;
  /// @internal
  #o;
  /// @internal
  #l;
  #c;
  /// @internal
  #u(e) {
    const { doc: t, selection: r } = e.state, { empty: i, from: s, to: o } = r, l = !t.textBetween(s, o).length && e.state.selection instanceof Ee, a = this.element.contains(document.activeElement), c = !e.hasFocus() && !a, u = !e.editable;
    return !(c || i || l || u);
  }
}
function yg(n) {
  const e = Ct(
    {},
    `${n}_TOOLTIP_SPEC`
  ), t = kn((i) => {
    const s = i.get(e.key);
    return new Ut({
      key: new en(`${n}_TOOLTIP`),
      ...s
    });
  }), r = [e, t];
  return r.key = e.key, r.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Ctx<tooltipSpec>|${n}`
  }, t.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Prose<tooltip>|${n}`
  }, r;
}
function Fle() {
  return {
    enter: {
      mathFlow: n,
      mathFlowFenceMeta: e,
      mathText: s
    },
    exit: {
      mathFlow: i,
      mathFlowFence: r,
      mathFlowFenceMeta: t,
      mathFlowValue: l,
      mathText: o,
      mathTextData: l
    }
  };
  function n(a) {
    const c = {
      type: "element",
      tagName: "code",
      properties: { className: ["language-math", "math-display"] },
      children: []
    };
    this.enter(
      {
        type: "math",
        meta: null,
        value: "",
        data: { hName: "pre", hChildren: [c] }
      },
      a
    );
  }
  function e() {
    this.buffer();
  }
  function t() {
    const a = this.resume(), c = this.stack[this.stack.length - 1];
    c.type, c.meta = a;
  }
  function r() {
    this.data.mathFlowInside || (this.buffer(), this.data.mathFlowInside = !0);
  }
  function i(a) {
    const c = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), u = this.stack[this.stack.length - 1];
    u.type, this.exit(a), u.value = c;
    const h = (
      /** @type {HastElement} */
      u.data.hChildren[0]
    );
    h.type, h.tagName, h.children.push({ type: "text", value: c }), this.data.mathFlowInside = void 0;
  }
  function s(a) {
    this.enter(
      {
        type: "inlineMath",
        value: "",
        data: {
          hName: "code",
          hProperties: { className: ["language-math", "math-inline"] },
          hChildren: []
        }
      },
      a
    ), this.buffer();
  }
  function o(a) {
    const c = this.resume(), u = this.stack[this.stack.length - 1];
    u.type, this.exit(a), u.value = c, /** @type {Array<HastElementContent>} */
    // @ts-expect-error: we defined it in `enterMathFlow`.
    u.data.hChildren.push({ type: "text", value: c });
  }
  function l(a) {
    this.config.enter.data.call(this, a), this.config.exit.data.call(this, a);
  }
}
function Hle(n) {
  let e = (n || {}).singleDollarTextMath;
  return e == null && (e = !0), r.peek = i, {
    unsafe: [
      { character: "\r", inConstruct: "mathFlowMeta" },
      { character: `
`, inConstruct: "mathFlowMeta" },
      {
        character: "$",
        after: e ? void 0 : "\\$",
        inConstruct: "phrasing"
      },
      { character: "$", inConstruct: "mathFlowMeta" },
      { atBreak: !0, character: "$", after: "\\$" }
    ],
    handlers: { math: t, inlineMath: r }
  };
  function t(s, o, l, a) {
    const c = s.value || "", u = l.createTracker(a), h = "$".repeat(Math.max(VT(c, "$") + 1, 2)), f = l.enter("mathFlow");
    let d = u.move(h);
    if (s.meta) {
      const p = l.enter("mathFlowMeta");
      d += u.move(
        l.safe(s.meta, {
          after: `
`,
          before: d,
          encode: ["$"],
          ...u.current()
        })
      ), p();
    }
    return d += u.move(`
`), c && (d += u.move(c + `
`)), d += u.move(h), f(), d;
  }
  function r(s, o, l) {
    let a = s.value || "", c = 1;
    for (e || c++; new RegExp("(^|[^$])" + "\\$".repeat(c) + "([^$]|$)").test(a); )
      c++;
    const u = "$".repeat(c);
    // Contains non-space.
    /[^ \r\n]/.test(a) && // Starts with space and ends with space.
    (/^[ \r\n]/.test(a) && /[ \r\n]$/.test(a) || // Starts or ends with dollar.
    /^\$|\$$/.test(a)) && (a = " " + a + " ");
    let h = -1;
    for (; ++h < l.unsafe.length; ) {
      const f = l.unsafe[h];
      if (!f.atBreak) continue;
      const d = l.compilePattern(f);
      let p;
      for (; p = d.exec(a); ) {
        let m = p.index;
        a.codePointAt(m) === 10 && a.codePointAt(m - 1) === 13 && m--, a = a.slice(0, m) + " " + a.slice(p.index + 1);
      }
    }
    return u + a + u;
  }
  function i() {
    return "$";
  }
}
const $le = {
  tokenize: Vle,
  concrete: !0,
  name: "mathFlow"
}, $9 = {
  tokenize: qle,
  partial: !0
};
function Vle(n, e, t) {
  const r = this, i = r.events[r.events.length - 1], s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let o = 0;
  return l;
  function l(w) {
    return n.enter("mathFlow"), n.enter("mathFlowFence"), n.enter("mathFlowFenceSequence"), a(w);
  }
  function a(w) {
    return w === 36 ? (n.consume(w), o++, a) : o < 2 ? t(w) : (n.exit("mathFlowFenceSequence"), it(n, c, "whitespace")(w));
  }
  function c(w) {
    return w === null || Ne(w) ? h(w) : (n.enter("mathFlowFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), u(w));
  }
  function u(w) {
    return w === null || Ne(w) ? (n.exit("chunkString"), n.exit("mathFlowFenceMeta"), h(w)) : w === 36 ? t(w) : (n.consume(w), u);
  }
  function h(w) {
    return n.exit("mathFlowFence"), r.interrupt ? e(w) : n.attempt($9, f, g)(w);
  }
  function f(w) {
    return n.attempt({
      tokenize: b,
      partial: !0
    }, g, d)(w);
  }
  function d(w) {
    return (s ? it(n, p, "linePrefix", s + 1) : p)(w);
  }
  function p(w) {
    return w === null ? g(w) : Ne(w) ? n.attempt($9, f, g)(w) : (n.enter("mathFlowValue"), m(w));
  }
  function m(w) {
    return w === null || Ne(w) ? (n.exit("mathFlowValue"), p(w)) : (n.consume(w), m);
  }
  function g(w) {
    return n.exit("mathFlow"), e(w);
  }
  function b(w, k, C) {
    let M = 0;
    return it(w, T, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function T($) {
      return w.enter("mathFlowFence"), w.enter("mathFlowFenceSequence"), N($);
    }
    function N($) {
      return $ === 36 ? (M++, w.consume($), N) : M < o ? C($) : (w.exit("mathFlowFenceSequence"), it(w, B, "whitespace")($));
    }
    function B($) {
      return $ === null || Ne($) ? (w.exit("mathFlowFence"), k($)) : C($);
    }
  }
}
function qle(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? e(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
function Wle(n) {
  let t = (n || {}).singleDollarTextMath;
  return t == null && (t = !0), {
    tokenize: r,
    resolve: jle,
    previous: Ule,
    name: "mathText"
  };
  function r(i, s, o) {
    let l = 0, a, c;
    return u;
    function u(m) {
      return i.enter("mathText"), i.enter("mathTextSequence"), h(m);
    }
    function h(m) {
      return m === 36 ? (i.consume(m), l++, h) : l < 2 && !t ? o(m) : (i.exit("mathTextSequence"), f(m));
    }
    function f(m) {
      return m === null ? o(m) : m === 36 ? (c = i.enter("mathTextSequence"), a = 0, p(m)) : m === 32 ? (i.enter("space"), i.consume(m), i.exit("space"), f) : Ne(m) ? (i.enter("lineEnding"), i.consume(m), i.exit("lineEnding"), f) : (i.enter("mathTextData"), d(m));
    }
    function d(m) {
      return m === null || m === 32 || m === 36 || Ne(m) ? (i.exit("mathTextData"), f(m)) : (i.consume(m), d);
    }
    function p(m) {
      return m === 36 ? (i.consume(m), a++, p) : a === l ? (i.exit("mathTextSequence"), i.exit("mathText"), s(m)) : (c.type = "mathTextData", d(m));
    }
  }
}
function jle(n) {
  let e = n.length - 4, t = 3, r, i;
  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {
    for (r = t; ++r < e; )
      if (n[r][1].type === "mathTextData") {
        n[e][1].type = "mathTextPadding", n[t][1].type = "mathTextPadding", t += 2, e -= 2;
        break;
      }
  }
  for (r = t - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "mathTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function Ule(n) {
  return n !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Kle(n) {
  return {
    flow: {
      36: $le
    },
    text: {
      36: Wle(n)
    }
  };
}
const Gle = {};
function Yle(n) {
  const e = (
    /** @type {Processor} */
    this
  ), t = n || Gle, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(Kle(t)), s.push(Fle()), o.push(Hle(t));
}
var Jle = Object.defineProperty, V9 = Object.getOwnPropertySymbols, Xle = Object.prototype.hasOwnProperty, Zle = Object.prototype.propertyIsEnumerable, q9 = (n, e, t) => e in n ? Jle(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Qle = (n, e) => {
  for (var t in e || (e = {}))
    Xle.call(e, t) && q9(n, t, e[t]);
  if (V9)
    for (var t of V9(e))
      Zle.call(e, t) && q9(n, t, e[t]);
  return n;
};
function qa(n, e) {
  return Object.assign(n, {
    meta: Qle({
      package: "@milkdown/components"
    }, e)
  }), n;
}
var eae = Object.defineProperty, W9 = Object.getOwnPropertySymbols, tae = Object.prototype.hasOwnProperty, nae = Object.prototype.propertyIsEnumerable, j9 = (n, e, t) => e in n ? eae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, D7 = (n, e) => {
  for (var t in e || (e = {}))
    tae.call(e, t) && j9(n, t, e[t]);
  if (W9)
    for (var t of W9(e))
      nae.call(e, t) && j9(n, t, e[t]);
  return n;
};
const rae = {
  mode: "preview"
}, bo = Ct(D7({}, rae), "linkTooltipStateCtx");
qa(bo, {
  displayName: "State<link-tooltip>",
  group: "LinkTooltip"
});
const iae = {
  addLink: () => {
  },
  editLink: () => {
  },
  removeLink: () => {
  }
}, Jc = Ct(D7({}, iae), "linkTooltipAPICtx");
qa(bo, {
  displayName: "API<link-tooltip>",
  group: "LinkTooltip"
});
const sae = {
  linkIcon: "🔗",
  editButton: "✎",
  removeButton: "⌫",
  confirmButton: "Confirm ⏎",
  onCopyLink: () => {
  },
  inputPlaceholder: "Paste link..."
}, Xc = Ct(
  D7({}, sae),
  "linkTooltipConfigCtx"
);
qa(bo, {
  displayName: "Config<link-tooltip>",
  group: "LinkTooltip"
});
const PN = Ye("ToggleLink", (n) => () => (e) => {
  const { doc: t, selection: r } = e, i = Pi.type(n);
  return t.rangeHasMark(r.from, r.to, i) ? (n.get(Jc.key).removeLink(r.from, r.to), !0) : (n.get(Jc.key).addLink(r.from, r.to), !0);
}), zd = yg("LINK_PREVIEW");
qa(zd[0], {
  displayName: "PreviewTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
qa(zd[1], {
  displayName: "PreviewTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
const bg = yg("LINK_EDIT");
qa(bg[0], {
  displayName: "EditTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
qa(bg[1], {
  displayName: "EditTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
function gf({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ki.sanitize(n.trim()));
      }
    }
  );
}
gf.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const oae = /* @__PURE__ */ $n({
  props: {
    config: {
      type: Object,
      required: !0
    },
    src: {
      type: Object,
      required: !0
    },
    onConfirm: {
      type: Function,
      required: !0
    },
    onCancel: {
      type: Function,
      required: !0
    }
  },
  setup({ config: n, src: e, onConfirm: t, onCancel: r }) {
    const i = Ae(e);
    Ac(e, (l) => {
      i.value = l;
    });
    const s = () => {
      t(i.value);
    }, o = (l) => {
      l.stopPropagation(), l.key === "Enter" && (l.preventDefault(), s()), l.key === "Escape" && (l.preventDefault(), r());
    };
    return () => /* @__PURE__ */ j("div", { class: "link-edit" }, /* @__PURE__ */ j(
      "input",
      {
        class: "input-area",
        placeholder: n.value.inputPlaceholder,
        onKeydown: o,
        onInput: (l) => {
          i.value = l.target.value;
        },
        value: i.value
      }
    ), i.value ? /* @__PURE__ */ j(
      gf,
      {
        class: "button confirm",
        icon: n.value.confirmButton,
        onClick: s
      }
    ) : null);
  }
});
var lae = Object.defineProperty, aae = Object.defineProperties, cae = Object.getOwnPropertyDescriptors, U9 = Object.getOwnPropertySymbols, uae = Object.prototype.hasOwnProperty, hae = Object.prototype.propertyIsEnumerable, _N = (n) => {
  throw TypeError(n);
}, K9 = (n, e, t) => e in n ? lae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, F0 = (n, e) => {
  for (var t in e || (e = {}))
    uae.call(e, t) && K9(n, t, e[t]);
  if (U9)
    for (var t of U9(e))
      hae.call(e, t) && K9(n, t, e[t]);
  return n;
}, G9 = (n, e) => aae(n, cae(e)), LN = (n, e, t) => e.has(n) || _N("Cannot " + t), Jt = (n, e, t) => (LN(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Hs = (n, e, t) => e.has(n) ? _N("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), $l = (n, e, t, r) => (LN(n, e, "write to private field"), e.set(n, t), t), wh, _o, Lo, Np, xh, Rp, Kl, $5, Pp;
const Y9 = {
  from: -1,
  to: -1,
  mark: null
};
class fae {
  constructor(e, t) {
    this.ctx = e, Hs(this, wh), Hs(this, _o), Hs(this, Lo, F0({}, Y9)), Hs(this, Np), Hs(this, xh), Hs(this, Rp, Ae("")), Hs(this, Kl, () => {
      Jt(this, _o).hide(), this.ctx.update(bo.key, (s) => G9(F0({}, s), {
        mode: "preview"
      })), $l(this, Lo, F0({}, Y9));
    }), Hs(this, $5, (s) => {
      const o = this.ctx.get(St), { from: l, to: a, mark: c } = Jt(this, Lo), u = Pi.type(this.ctx), h = Ki.sanitize(s);
      if (c && c.attrs.href === h) {
        Jt(this, Kl).call(this);
        return;
      }
      const f = o.state.tr;
      c && f.removeMark(l, a, c), f.addMark(l, a, u.create({ href: h })), o.dispatch(f), Jt(this, Kl).call(this);
    }), Hs(this, Pp, (s, o, l) => {
      const a = this.ctx.get(Xc.key);
      Jt(this, xh).value = a, Jt(this, Rp).value = s, this.ctx.update(bo.key, (u) => G9(F0({}, u), {
        mode: "edit"
      }));
      const c = this.ctx.get(St);
      c.dispatch(
        c.state.tr.setSelection(Ee.create(c.state.doc, o, l))
      ), Jt(this, _o).show({
        getBoundingClientRect: () => b1(c, o, l)
      }), requestAnimationFrame(() => {
        var u;
        (u = Jt(this, wh).querySelector("input")) == null || u.focus();
      });
    }), this.update = (s) => {
      const { state: o } = s, { selection: l } = o;
      if (!(l instanceof Ee)) return;
      const { from: a, to: c } = l;
      a === Jt(this, Lo).from && c === Jt(this, Lo).to || Jt(this, Kl).call(this);
    }, this.destroy = () => {
      Jt(this, Np).unmount(), Jt(this, _o).destroy(), Jt(this, wh).remove();
    }, this.addLink = (s, o) => {
      $l(this, Lo, {
        from: s,
        to: o,
        mark: null
      }), Jt(this, Pp).call(this, "", s, o);
    }, this.editLink = (s, o, l) => {
      $l(this, Lo, {
        from: o,
        to: l,
        mark: s
      }), Jt(this, Pp).call(this, s.attrs.href, o, l);
    }, this.removeLink = (s, o) => {
      const l = this.ctx.get(St), a = l.state.tr;
      a.removeMark(s, o, Pi.type(this.ctx)), l.dispatch(a), Jt(this, Kl).call(this);
    }, $l(this, xh, Ae(this.ctx.get(Xc.key)));
    const r = document.createElement("div");
    r.className = "milkdown-link-edit";
    const i = Ui(oae, {
      config: Jt(this, xh),
      src: Jt(this, Rp),
      onConfirm: Jt(this, $5),
      onCancel: Jt(this, Kl)
    });
    i.mount(r), $l(this, Np, i), $l(this, wh, r), $l(this, _o, new gg({
      content: r,
      debounce: 0,
      shouldShow: () => !1
    })), Jt(this, _o).onHide = () => {
      requestAnimationFrame(() => {
        t.dom.focus({ preventScroll: !0 });
      });
    }, Jt(this, _o).update(t);
  }
}
wh = /* @__PURE__ */ new WeakMap();
_o = /* @__PURE__ */ new WeakMap();
Lo = /* @__PURE__ */ new WeakMap();
Np = /* @__PURE__ */ new WeakMap();
xh = /* @__PURE__ */ new WeakMap();
Rp = /* @__PURE__ */ new WeakMap();
Kl = /* @__PURE__ */ new WeakMap();
$5 = /* @__PURE__ */ new WeakMap();
Pp = /* @__PURE__ */ new WeakMap();
var dae = Object.defineProperty, pae = Object.defineProperties, mae = Object.getOwnPropertyDescriptors, J9 = Object.getOwnPropertySymbols, gae = Object.prototype.hasOwnProperty, yae = Object.prototype.propertyIsEnumerable, X9 = (n, e, t) => e in n ? dae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, bae = (n, e) => {
  for (var t in e || (e = {}))
    gae.call(e, t) && X9(n, t, e[t]);
  if (J9)
    for (var t of J9(e))
      yae.call(e, t) && X9(n, t, e[t]);
  return n;
}, vae = (n, e) => pae(n, mae(e));
function wae(n) {
  let e;
  n.update(Jc.key, (t) => vae(bae({}, t), {
    addLink: (r, i) => {
      e?.addLink(r, i);
    },
    editLink: (r, i, s) => {
      e?.editLink(r, i, s);
    },
    removeLink: (r, i) => {
      e?.removeLink(r, i);
    }
  })), n.set(bg.key, {
    view: (t) => (e = new fae(n, t), e)
  });
}
function xae(n, e, t, r, i) {
  let s = { start: -1, end: -1 };
  return t.nodesBetween(r, i, (o, l) => {
    if (s.start > -1) return !1;
    s.start === -1 && n.isInSet(o.marks) && e === o && (s = {
      start: l,
      end: l + Math.max(o.textContent.length, 1)
    });
  }), s;
}
function kae(n, e, t) {
  const r = e.posAtCoords({ left: t.clientX, top: t.clientY });
  if (!r) return;
  const { pos: i } = r, s = e.state.doc.nodeAt(i);
  if (!s) return;
  const o = s.marks.find(
    (a) => a.type === Pi.mark.type(n)
  );
  if (!(!o || !zd.pluginKey()))
    return { show: !0, pos: i, node: s, mark: o };
}
const Sae = /* @__PURE__ */ $n({
  props: {
    config: {
      type: Object,
      required: !0
    },
    src: {
      type: Object,
      required: !0
    },
    onEdit: {
      type: Object,
      required: !0
    },
    onRemove: {
      type: Object,
      required: !0
    }
  },
  setup({ config: n, src: e, onEdit: t, onRemove: r }) {
    const i = (l) => {
      l.preventDefault(), l.stopPropagation(), t.value();
    }, s = (l) => {
      l.preventDefault(), l.stopPropagation(), r.value();
    }, o = (l) => {
      l.preventDefault();
      const a = e.value;
      navigator.clipboard && a && navigator.clipboard.writeText(a).then(() => {
        n.value.onCopyLink(a);
      }).catch((c) => console.error(c));
    };
    return () => /* @__PURE__ */ j("div", { class: "link-preview" }, /* @__PURE__ */ j(
      gf,
      {
        class: "button link-icon",
        icon: n.value.linkIcon,
        onClick: o
      }
    ), /* @__PURE__ */ j("a", { href: e.value, target: "_blank", class: "link-display" }, e.value), /* @__PURE__ */ j(
      gf,
      {
        class: "button link-edit-button",
        icon: n.value.editButton,
        onClick: i
      }
    ), /* @__PURE__ */ j(
      gf,
      {
        class: "button link-remove-button",
        icon: n.value.removeButton,
        onClick: s
      }
    ));
  }
});
var BN = (n) => {
  throw TypeError(n);
}, zN = (n, e, t) => e.has(n) || BN("Cannot " + t), ct = (n, e, t) => (zN(n, e, "read from private field"), t ? t.call(n) : e.get(n)), zr = (n, e, t) => e.has(n) ? BN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Vl = (n, e, t, r) => (zN(n, e, "write to private field"), e.set(n, t), t), Gl, Oi, kh, Sh, _p, Lp, Bp, Ch, Mh, zp, Fp, Hp, Th;
class Cae {
  constructor(e, t) {
    this.ctx = e, zr(this, Gl), zr(this, Oi), zr(this, kh, this.ctx.use(bo.key)), zr(this, Sh), zr(this, _p, Ae("")), zr(this, Lp, Ae(() => {
    })), zr(this, Bp, Ae(() => {
    })), zr(this, Ch), zr(this, Mh, !1), zr(this, zp, ({ mode: r }) => {
      r === "edit" && ct(this, Th).call(this);
    }), zr(this, Fp, () => {
      Vl(this, Mh, !0);
    }), zr(this, Hp, () => {
      Vl(this, Mh, !1);
    }), zr(this, Th, () => {
      ct(this, Oi).hide(), ct(this, Oi).element.removeEventListener("mouseenter", ct(this, Fp)), ct(this, Oi).element.removeEventListener("mouseleave", ct(this, Hp));
    }), this.show = (r, i, s, o) => {
      ct(this, Sh).value = this.ctx.get(Xc.key), ct(this, _p).value = r.attrs.href, ct(this, Lp).value = () => {
        this.ctx.get(Jc.key).editLink(r, i, s);
      }, ct(this, Bp).value = () => {
        this.ctx.get(Jc.key).removeLink(i, s), ct(this, Th).call(this);
      }, ct(this, Oi).show({
        getBoundingClientRect: () => o
      }), ct(this, Oi).element.addEventListener("mouseenter", ct(this, Fp)), ct(this, Oi).element.addEventListener("mouseleave", ct(this, Hp));
    }, this.hide = () => {
      ct(this, Mh) || ct(this, Th).call(this);
    }, this.update = () => {
    }, this.destroy = () => {
      ct(this, Ch).unmount(), ct(this, kh).off(ct(this, zp)), ct(this, Oi).destroy(), ct(this, Gl).remove();
    }, Vl(this, Sh, Ae(this.ctx.get(Xc.key))), Vl(this, Ch, Ui(Sae, {
      config: ct(this, Sh),
      src: ct(this, _p),
      onEdit: ct(this, Lp),
      onRemove: ct(this, Bp)
    })), Vl(this, Gl, document.createElement("div")), ct(this, Gl).className = "milkdown-link-preview", ct(this, Ch).mount(ct(this, Gl)), Vl(this, Oi, new gg({
      debounce: 0,
      content: ct(this, Gl),
      shouldShow: () => !1
    })), ct(this, Oi).update(t), Vl(this, kh, e.use(bo.key)), ct(this, kh).on(ct(this, zp));
  }
}
Gl = /* @__PURE__ */ new WeakMap();
Oi = /* @__PURE__ */ new WeakMap();
kh = /* @__PURE__ */ new WeakMap();
Sh = /* @__PURE__ */ new WeakMap();
_p = /* @__PURE__ */ new WeakMap();
Lp = /* @__PURE__ */ new WeakMap();
Bp = /* @__PURE__ */ new WeakMap();
Ch = /* @__PURE__ */ new WeakMap();
Mh = /* @__PURE__ */ new WeakMap();
zp = /* @__PURE__ */ new WeakMap();
Fp = /* @__PURE__ */ new WeakMap();
Hp = /* @__PURE__ */ new WeakMap();
Th = /* @__PURE__ */ new WeakMap();
function Mae(n) {
  let e;
  const r = e1((s, o) => {
    if (!e || !s.hasFocus() || n.get(bo.key).mode === "edit") return;
    const a = kae(n, s, o);
    if (a) {
      const c = s.state.doc.resolve(a.pos), u = xae(
        a.mark,
        a.node,
        s.state.doc,
        c.before(),
        c.after()
      ), h = u.start, f = u.end;
      e.show(
        a.mark,
        h,
        f,
        b1(s, h, f)
      );
      return;
    }
    e.hide();
  }, 50), i = () => {
    setTimeout(() => {
      e?.hide();
    }, 50);
  };
  n.set(zd.key, {
    props: {
      handleDOMEvents: {
        mousemove: r,
        mouseleave: i
      }
    },
    view: (s) => (e = new Cae(n, s), e)
  });
}
function Tae(n) {
  Mae(n), wae(n);
}
const Aae = [
  bo,
  Jc,
  Xc,
  zd,
  bg,
  PN
].flat();
var Oae = Object.defineProperty, Z9 = Object.getOwnPropertySymbols, Eae = Object.prototype.hasOwnProperty, Iae = Object.prototype.propertyIsEnumerable, Q9 = (n, e, t) => e in n ? Oae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Dae = (n, e) => {
  for (var t in e || (e = {}))
    Eae.call(e, t) && Q9(n, t, e[t]);
  if (Z9)
    for (var t of Z9(e))
      Iae.call(e, t) && Q9(n, t, e[t]);
  return n;
};
function FN(n, e) {
  return Object.assign(n, {
    meta: Dae({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const Nae = {
  renderLabel: ({ label: n, listType: e, checked: t }) => t == null ? e === "bullet" ? "⦿" : n : t ? "☑" : "□"
}, vg = Ct(
  Nae,
  "listItemBlockConfigCtx"
);
FN(vg, {
  displayName: "Config<list-item-block>",
  group: "ListItemBlock"
});
function HN({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ki.sanitize(n.trim()));
      }
    }
  );
}
HN.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const Rae = /* @__PURE__ */ $n({
  props: {
    label: {
      type: Object,
      required: !0
    },
    checked: {
      type: Object,
      required: !0
    },
    listType: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    onMount: {
      type: Function,
      required: !0
    }
  },
  setup({
    label: n,
    checked: e,
    listType: t,
    config: r,
    readonly: i,
    setAttr: s,
    onMount: o,
    selected: l
  }) {
    const a = (f) => {
      f != null && f instanceof Element && o(f);
    }, c = (f) => {
      f.stopPropagation(), f.preventDefault(), e.value != null && s("checked", !e.value);
    }, u = Ra(() => r.renderLabel({
      label: n.value,
      listType: t.value,
      checked: e.value,
      readonly: i.value
    })), h = Ra(() => e.value == null ? t.value === "bullet" ? "bullet" : "ordered" : e.value ? "checked" : "unchecked");
    return () => /* @__PURE__ */ j(
      "li",
      {
        class: Hn(
          "list-item",
          l.value && "ProseMirror-selectednode"
        )
      },
      /* @__PURE__ */ j(
        "div",
        {
          class: "label-wrapper",
          onPointerdown: c,
          contenteditable: !1
        },
        /* @__PURE__ */ j(
          HN,
          {
            class: Hn(
              "label",
              i.value && "readonly",
              h.value
            ),
            icon: u.value
          }
        )
      ),
      /* @__PURE__ */ j("div", { class: "children", ref: a })
    );
  }
}), $N = yd(
  ji.node,
  (n) => (e, t, r) => {
    const i = document.createElement("div");
    i.className = "milkdown-list-item-block";
    const s = document.createElement("div");
    s.setAttribute("data-content-dom", "true"), s.classList.add("content-dom");
    const o = Ae(e.attrs.label), l = Ae(e.attrs.checked), a = Ae(e.attrs.listType), c = Ae(!t.editable), u = n.get(vg.key), h = Ae(!1), f = (k, C) => {
      if (!t.editable) return;
      const M = r();
      M != null && (t.hasFocus() || t.focus(), t.dispatch(t.state.tr.setNodeAttribute(M, k, C)));
    }, d = uu(() => {
      h.value ? i.classList.add("selected") : i.classList.remove("selected");
    });
    let p = 0;
    const g = Ui(Rae, {
      label: o,
      checked: l,
      listType: a,
      readonly: c,
      config: u,
      selected: h,
      setAttr: f,
      onMount: (k) => {
        const { anchor: C, head: M } = t.state.selection;
        k.appendChild(s);
        const T = t.state.doc.resolve(C), N = t.state.doc.resolve(M);
        p = requestAnimationFrame(() => {
          if (cancelAnimationFrame(p), !T.doc.eq(t.state.doc)) return;
          const B = new Ee(T, N);
          t.dispatch(t.state.tr.setSelection(B));
        });
      }
    });
    g.mount(i);
    const b = (k) => {
      a.value = k.attrs.listType, o.value = k.attrs.label, l.value = k.attrs.checked, c.value = !t.editable;
    };
    b(e);
    let w = e;
    return {
      dom: i,
      contentDOM: s,
      update: (k) => k.type !== e.type ? !1 : (k.sameMarkup(w) && k.content.eq(w.content) || (w = k, b(k)), !0),
      ignoreMutation: (k) => !i || !s ? !0 : k.type === "selection" ? !1 : s === k.target && k.type === "attributes" ? !0 : !s.contains(k.target),
      selectNode: () => {
        h.value = !0;
      },
      deselectNode: () => {
        h.value = !1;
      },
      destroy: () => {
        d(), g.unmount(), i.remove(), s.remove();
      }
    };
  }
);
FN($N, {
  displayName: "NodeView<list-item-block>",
  group: "ListItemBlock"
});
const Pae = [
  vg,
  $N
];
var _ae = Object.defineProperty, eS = Object.getOwnPropertySymbols, Lae = Object.prototype.hasOwnProperty, Bae = Object.prototype.propertyIsEnumerable, tS = (n, e, t) => e in n ? _ae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, zae = (n, e) => {
  for (var t in e || (e = {}))
    Lae.call(e, t) && tS(n, t, e[t]);
  if (eS)
    for (var t of eS(e))
      Bae.call(e, t) && tS(n, t, e[t]);
  return n;
};
function VN(n, e) {
  return Object.assign(n, {
    meta: zae({
      package: "@milkdown/components"
    }, e)
  }), n;
}
var Fae = Object.defineProperty, nS = Object.getOwnPropertySymbols, Hae = Object.prototype.hasOwnProperty, $ae = Object.prototype.propertyIsEnumerable, rS = (n, e, t) => e in n ? Fae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Vae = (n, e) => {
  for (var t in e || (e = {}))
    Hae.call(e, t) && rS(n, t, e[t]);
  if (nS)
    for (var t of nS(e))
      $ae.call(e, t) && rS(n, t, e[t]);
  return n;
};
const qae = {
  renderButton: (n) => {
    switch (n) {
      case "add_row":
        return "+";
      case "add_col":
        return "+";
      case "delete_row":
        return "-";
      case "delete_col":
        return "-";
      case "align_col_left":
        return "left";
      case "align_col_center":
        return "center";
      case "align_col_right":
        return "right";
      case "col_drag_handle":
        return "=";
      case "row_drag_handle":
        return "=";
    }
  }
}, wg = Ct(
  Vae({}, qae),
  "tableBlockConfigCtx"
);
VN(wg, {
  displayName: "Config<table-block>",
  group: "TableBlock"
});
function ts({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ki.sanitize(n.trim()));
      }
    }
  );
}
ts.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
function qN(n) {
  const {
    dragPreviewRef: e,
    tableWrapperRef: t,
    contentWrapperRef: r,
    yLineHandleRef: i,
    xLineHandleRef: s,
    colHandleRef: o,
    rowHandleRef: l
  } = n, a = e.value;
  if (!a) return;
  const c = t.value;
  if (!c) return;
  const u = r.value;
  if (!u) return;
  const h = u.querySelector("tbody");
  if (!h) return;
  const f = a.querySelector("tbody");
  if (!f) return;
  const d = i.value;
  if (!d) return;
  const p = s.value;
  if (!p) return;
  const m = o.value;
  if (!m) return;
  const g = l.value;
  return g ? {
    preview: a,
    wrapper: c,
    content: u,
    contentRoot: h,
    previewRoot: f,
    yHandle: d,
    xHandle: p,
    colHandle: m,
    rowHandle: g
  } : void 0;
}
function WN(n) {
  for (; n.firstChild; ) n.removeChild(n.firstChild);
}
function jN(n, e, t, r, i) {
  const { width: s, height: o } = r.querySelector("tbody").getBoundingClientRect();
  if (n === "y") {
    const a = r.querySelectorAll("tr")[i];
    if (!a) return;
    t.appendChild(a.cloneNode(!0));
    const c = a.getBoundingClientRect().height;
    Object.assign(e.style, {
      width: `${s}px`,
      height: `${c}px`
    }), e.dataset.show = "true";
    return;
  }
  if (n === "x") {
    const l = r.querySelectorAll("tr");
    let a;
    Array.from(l).forEach((c) => {
      const u = c.children[i];
      if (!u) return;
      a === void 0 && (a = u.getBoundingClientRect().width);
      const h = u.parentElement.cloneNode(!1), f = u.cloneNode(!0);
      h.appendChild(f), t.appendChild(h);
    }), Object.assign(e.style, {
      width: `${a}px`,
      height: `${o}px`
    }), e.dataset.show = "true";
    return;
  }
}
function Wae(n, e) {
  return (t) => {
    KN(n, t, e, (r) => {
      UN("y", t, r, n);
      const { preview: i, content: s, previewRoot: o } = r;
      WN(o);
      const { hoverIndex: l } = n, [a] = l.value;
      jN("y", i, o, s, a);
    });
  };
}
function jae(n, e) {
  return (t) => {
    KN(n, t, e, (r) => {
      UN("x", t, r, n);
      const { preview: i, content: s, previewRoot: o } = r, { hoverIndex: l } = n, [a, c] = l.value;
      WN(o), jN("x", i, o, s, c);
    });
  };
}
function UN(n, e, t, r) {
  const { xHandle: i, yHandle: s, colHandle: o, rowHandle: l, preview: a } = t;
  i.dataset.displayType = n === "y" ? "indicator" : "none", s.dataset.displayType = n === "x" ? "indicator" : "none", n === "y" ? (o.dataset.show = "false", iS(l)) : (l.dataset.show = "false", iS(o));
  const { hoverIndex: c, dragInfo: u } = r, [h, f] = c.value;
  u.value = {
    startCoords: [e.clientX, e.clientY],
    startIndex: n === "y" ? h : f,
    endIndex: n === "y" ? h : f,
    type: n === "y" ? "row" : "col"
  }, a.dataset.direction = n === "y" ? "vertical" : "horizontal";
}
function KN(n, e, t, r) {
  const i = t?.get(St);
  if (!i?.editable) return;
  e.stopPropagation(), e.dataTransfer && (e.dataTransfer.effectAllowed = "move");
  const s = qN(n);
  s && requestAnimationFrame(() => {
    r(s);
  });
}
function iS(n) {
  var e;
  (e = n.querySelector(".button-group")) == null || e.setAttribute("data-show", "false");
}
function V5(n, e) {
  for (let t = 0; t < n.childCount; t++)
    if (n.child(t) === e) return t;
  return -1;
}
function Uae(n, e) {
  var t, r, i;
  if (e)
    try {
      const s = e.posAtCoords({
        left: n.clientX,
        top: n.clientY
      });
      if (!s) return;
      const o = s?.inside;
      if (o == null || o < 0) return;
      const l = e.state.doc.resolve(o), a = e.state.doc.nodeAt(o);
      if (!a) return;
      const c = ["table_cell", "table_header"], u = ["table_row", "table_header_row"], h = c.includes(a.type.name) ? a : (t = bs((g) => c.includes(g.type.name))(l)) == null ? void 0 : t.node, f = (r = bs((g) => u.includes(g.type.name))(
        l
      )) == null ? void 0 : r.node, d = (i = bs((g) => g.type.name === "table")(l)) == null ? void 0 : i.node;
      if (!h || !f || !d) return;
      const p = V5(f, h);
      return [V5(d, f), p];
    } catch {
      return;
    }
}
function xg(n, [e, t]) {
  const r = n.value;
  if (!r) return;
  const i = r.querySelectorAll("tr"), s = i[e];
  if (!s) return;
  const o = i[0];
  if (!o) return;
  const l = o.children[t];
  if (!l) return;
  const a = s.children[t];
  if (a)
    return {
      row: s,
      col: a,
      headerCol: l
    };
}
function Kae(n, e, t) {
  if (!t || !e) return;
  const { selection: r } = e.state;
  if (!(r instanceof Nt)) return;
  const { $from: i } = r, s = fu(i);
  if (!(!s || s.node !== t)) {
    if (r.isColSelection()) {
      const { $head: o } = r, l = o.index(o.depth - 1);
      N7({
        refs: n,
        index: [0, l],
        before: (a) => {
          var c;
          (c = a.querySelector(".button-group")) == null || c.setAttribute("data-show", "true");
        }
      });
      return;
    }
    if (r.isRowSelection()) {
      const { $head: o } = r, l = bs(
        (c) => c.type.name === "table_row" || c.type.name === "table_header_row"
      )(o);
      if (!l) return;
      const a = V5(s.node, l.node);
      R7({
        refs: n,
        index: [a, 0],
        before: (c) => {
          var u;
          a > 0 && ((u = c.querySelector(".button-group")) == null || u.setAttribute("data-show", "true"));
        }
      });
    }
  }
}
function N7({
  refs: n,
  index: e,
  before: t,
  after: r
}) {
  const { contentWrapperRef: i, colHandleRef: s, hoverIndex: o } = n, l = s.value;
  if (!l) return;
  o.value = e;
  const a = xg(i, e);
  if (!a) return;
  const { headerCol: c } = a;
  l.dataset.show = "true", t && t(l), Vi(c, l, { placement: "top" }).then(({ x: u, y: h }) => {
    Object.assign(l.style, {
      left: `${u}px`,
      top: `${h}px`
    }), r && r(l);
  }).catch(console.error);
}
function R7({
  refs: n,
  index: e,
  before: t,
  after: r
}) {
  const { contentWrapperRef: i, rowHandleRef: s, hoverIndex: o } = n, l = s.value;
  if (!l) return;
  o.value = e;
  const a = xg(i, e);
  if (!a) return;
  const { row: c } = a;
  l.dataset.show = "true", t && t(l), Vi(c, l, { placement: "left" }).then(({ x: u, y: h }) => {
    Object.assign(l.style, {
      left: `${u}px`,
      top: `${h}px`
    }), r && r(l);
  }).catch(console.error);
}
function GN(n, e, t) {
  const r = t === "x" ? "left" : "top", i = t === "x" ? "right" : "bottom", s = n.length - 1, o = n.findIndex((a, c) => {
    const u = a.getBoundingClientRect(), h = u[r], f = u[i];
    return h <= e && e <= f || c === s && e > f || c === 0 && e < h;
  }), l = n[o];
  return l ? [l, o] : void 0;
}
function Gae(n, e) {
  const t = n.querySelector("tr");
  if (!t) return;
  const r = Array.from(t.children);
  return GN(r, e, "x");
}
function Yae(n, e) {
  const t = Array.from(n.querySelectorAll("tr"));
  return GN(t, e, "y");
}
function Jae(n) {
  return t1((e) => {
    const t = qN(n);
    if (!t) return;
    const { preview: r, content: i, contentRoot: s, xHandle: o, yHandle: l } = t, { dragInfo: a, hoverIndex: c } = n;
    if (r.dataset.show === "false") return;
    const u = xg(n.contentWrapperRef, c.value);
    if (!u || !s.querySelector("tr")) return;
    const f = a.value;
    if (!f || !s.offsetParent) return;
    const d = s.offsetParent.offsetTop, p = s.offsetParent.offsetLeft;
    if (f.type === "col") {
      const m = u.col.getBoundingClientRect().width, { left: g, width: b } = s.getBoundingClientRect(), w = p - g, k = e.clientX + w - m / 2, [C] = f.startCoords, M = C < e.clientX ? "right" : "left";
      r.style.top = `${d}px`;
      const T = k < g + w - 20 ? g + w - 20 : k > g + b + w - m + 20 ? g + b + w - m + 20 : k;
      r.style.left = `${T}px`;
      const N = Gae(s, e.clientX);
      if (N) {
        const [B, $] = N, R = l.getBoundingClientRect().width, V = i.getBoundingClientRect();
        f.endIndex = $, Vi(B, l, {
          placement: M === "left" ? "left" : "right",
          middleware: [yl(M === "left" ? -1 * R : 0)]
        }).then(({ x: z }) => {
          l.dataset.show = "true", Object.assign(l.style, {
            height: `${V.height}px`,
            left: `${z}px`,
            top: `${d}px`
          });
        }).catch(console.error);
      }
    } else if (f.type === "row") {
      const m = u.row.getBoundingClientRect().height, { top: g, height: b } = s.getBoundingClientRect(), w = d - g, k = e.clientY + w - m / 2, [C, M] = f.startCoords, T = M < e.clientY ? "down" : "up", N = k < g + w - 20 ? g + w - 20 : k > g + b + w - m + 20 ? g + b + w - m + 20 : k;
      r.style.top = `${N}px`, r.style.left = `${p}px`;
      const B = Yae(s, e.clientY);
      if (B) {
        const [$, R] = B, V = o.getBoundingClientRect().height, z = i.getBoundingClientRect();
        f.endIndex = R, Vi($, o, {
          placement: T === "up" ? "top" : "bottom",
          middleware: [yl(T === "up" ? -1 * V : 0)]
        }).then(({ y: ue }) => {
          o.dataset.show = "true", Object.assign(o.style, {
            width: `${z.width}px`,
            top: `${ue}px`
          });
        }).catch(console.error);
      }
    }
  }, 20);
}
function Xae(n, e, t) {
  const { dragPreviewRef: r, yLineHandleRef: i, xLineHandleRef: s, dragInfo: o } = n, l = Wae(n, e), a = jae(n, e), c = () => {
    const f = r.value;
    if (!f || f.dataset.show === "false") return;
    const d = f?.querySelector("tbody");
    for (; d?.firstChild; )
      d?.removeChild(d.firstChild);
    f && (f.dataset.show = "false");
  }, u = () => {
    var f;
    const d = r.value;
    if (!d) return;
    const p = i.value;
    if (!p) return;
    const m = s.value;
    if (!m) return;
    const g = o.value;
    if (!g || !e || d.dataset.show === "false" || !n.colHandleRef.value || !n.rowHandleRef.value || (p.dataset.show = "false", m.dataset.show = "false", g.startIndex === g.endIndex)) return;
    const k = e.get(Me), C = {
      from: g.startIndex,
      to: g.endIndex,
      pos: ((f = t?.()) != null ? f : 0) + 1
    };
    if (g.type === "col") {
      k.call(ia.key, {
        pos: C.pos,
        index: g.startIndex
      }), k.call(Lv.key, C);
      const M = [0, g.endIndex];
      N7({
        refs: n,
        index: M
      });
    } else {
      k.call(ra.key, {
        pos: C.pos,
        index: g.startIndex
      }), k.call(_v.key, C);
      const M = [g.endIndex, 0];
      R7({
        refs: n,
        index: M
      });
    }
    requestAnimationFrame(() => {
      e.get(St).focus();
    });
  }, h = Jae(n);
  return kd(() => {
    window.addEventListener("dragover", h), window.addEventListener("dragend", c), window.addEventListener("drop", u);
  }), Sd(() => {
    window.removeEventListener("dragover", h), window.removeEventListener("dragend", c), window.removeEventListener("drop", u);
  }), {
    dragRow: l,
    dragCol: a
  };
}
function Zae(n, e, t) {
  const {
    xLineHandleRef: r,
    contentWrapperRef: i,
    colHandleRef: s,
    rowHandleRef: o,
    hoverIndex: l,
    lineHoverIndex: a
  } = n;
  return {
    onAddRow: () => {
      var m, g, b;
      if (!e) return;
      const w = r.value;
      if (!w) return;
      const [k] = a.value;
      if (k < 0 || !e.get(St).editable) return;
      const C = Array.from(
        (g = (m = i.value) == null ? void 0 : m.querySelectorAll("tr")) != null ? g : []
      ), M = e.get(Me), T = ((b = t?.()) != null ? b : 0) + 1;
      C.length === k ? (M.call(ra.key, { pos: T, index: k - 1 }), M.call($v.key)) : (M.call(ra.key, { pos: T, index: k }), M.call(Hv.key)), M.call(ra.key, { pos: T, index: k }), w.dataset.show = "false";
    },
    onAddCol: () => {
      var m, g, b, w;
      if (!e || !r.value) return;
      const [C, M] = a.value;
      if (M < 0 || !e.get(St).editable) return;
      const T = Array.from(
        (b = (g = (m = i.value) == null ? void 0 : m.querySelector("tr")) == null ? void 0 : g.children) != null ? b : []
      ), N = e.get(Me), B = ((w = t?.()) != null ? w : 0) + 1;
      T.length === M ? (N.call(ia.key, { pos: B, index: M - 1 }), N.call(Fv.key)) : (N.call(ia.key, { pos: B, index: M }), N.call(zv.key)), N.call(ia.key, { pos: B, index: M });
    },
    selectCol: () => {
      var m, g;
      if (!e) return;
      const [b, w] = l.value, k = e.get(Me), C = ((m = t?.()) != null ? m : 0) + 1;
      k.call(ia.key, { pos: C, index: w });
      const M = (g = s.value) == null ? void 0 : g.querySelector(".button-group");
      M && (M.dataset.show = M.dataset.show === "true" ? "false" : "true");
    },
    selectRow: () => {
      var m, g;
      if (!e) return;
      const [b, w] = l.value, k = e.get(Me), C = ((m = t?.()) != null ? m : 0) + 1;
      k.call(ra.key, { pos: C, index: b });
      const M = (g = o.value) == null ? void 0 : g.querySelector(".button-group");
      M && b > 0 && (M.dataset.show = M.dataset.show === "true" ? "false" : "true");
    },
    deleteSelected: (m) => {
      if (!e || !e.get(St).editable) return;
      m.preventDefault(), m.stopPropagation(), e.get(Me).call(Bv.key), requestAnimationFrame(() => {
        e.get(St).focus();
      });
    },
    onAlign: (m) => (g) => {
      if (!e || !e.get(St).editable) return;
      g.preventDefault(), g.stopPropagation(), e.get(Me).call(Vv.key, m), requestAnimationFrame(() => {
        e.get(St).focus();
      });
    }
  };
}
function Qae(n, e) {
  return t1((t) => {
    if (!e?.editable) return;
    const {
      contentWrapperRef: r,
      yLineHandleRef: i,
      xLineHandleRef: s,
      colHandleRef: o,
      rowHandleRef: l,
      hoverIndex: a,
      lineHoverIndex: c
    } = n, u = i.value;
    if (!u) return;
    const h = s.value;
    if (!h) return;
    const f = r.value;
    if (!f) return;
    const d = l.value;
    if (!d) return;
    const p = o.value;
    if (!p) return;
    const m = Uae(t, e);
    if (!m) return;
    const g = xg(r, m);
    if (!g) return;
    const [b, w] = m, k = g.col.getBoundingClientRect(), C = Math.abs(t.clientX - k.left) < 8, M = Math.abs(k.right - t.clientX) < 8, T = Math.abs(t.clientY - k.top) < 8, N = Math.abs(k.bottom - t.clientY) < 8, B = C || M || T || N, $ = d.querySelector(".button-group"), R = p.querySelector(".button-group");
    if ($ && ($.dataset.show = "false"), R && (R.dataset.show = "false"), B) {
      const V = f.getBoundingClientRect();
      d.dataset.show = "false", p.dataset.show = "false", h.dataset.displayType = "tool", u.dataset.displayType = "tool";
      const z = u.getBoundingClientRect().width, ue = h.getBoundingClientRect().height;
      C || M ? (c.value[1] = C ? w : w + 1, Vi(g.col, u, {
        placement: C ? "left" : "right",
        middleware: [yl(C ? -1 * z : 0)]
      }).then(({ x: ie }) => {
        u.dataset.show = "true", Object.assign(u.style, {
          height: `${V.height}px`,
          left: `${ie}px`
        });
      }).catch(console.error)) : u.dataset.show = "false", m[0] !== 0 && (T || N) ? (c.value[0] = T ? b : b + 1, Vi(g.row, h, {
        placement: T ? "top" : "bottom",
        middleware: [yl(T ? -1 * ue : 0)]
      }).then(({ y: ie }) => {
        h.dataset.show = "true", Object.assign(h.style, {
          width: `${V.width}px`,
          top: `${ie}px`
        });
      }).catch(console.error)) : h.dataset.show = "false";
      return;
    }
    c.value = [-1, -1], u.dataset.show = "false", h.dataset.show = "false", d.dataset.show = "true", p.dataset.show = "true", R7({
      refs: n,
      index: m
    }), N7({
      refs: n,
      index: m
    }), a.value = m;
  }, 20);
}
function ece(n) {
  return () => {
    const { rowHandleRef: e, colHandleRef: t, yLineHandleRef: r, xLineHandleRef: i } = n;
    setTimeout(() => {
      const s = e.value;
      if (!s) return;
      const o = t.value;
      if (!o) return;
      const l = r.value;
      if (!l) return;
      const a = i.value;
      a && (s.dataset.show = "false", o.dataset.show = "false", l.dataset.show = "false", a.dataset.show = "false");
    }, 200);
  };
}
function tce(n, e) {
  const t = Qae(n, e), r = ece(n);
  return {
    pointerMove: t,
    pointerLeave: r
  };
}
const nce = /* @__PURE__ */ $n({
  props: {
    view: {
      type: Object,
      required: !0
    },
    ctx: {
      type: Object,
      required: !0
    },
    getPos: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    onMount: {
      type: Function,
      required: !0
    },
    node: {
      type: Object,
      required: !0
    }
  },
  setup({ view: n, node: e, ctx: t, getPos: r, config: i, onMount: s }) {
    const o = Ae(), l = (z) => {
      z != null && (z instanceof HTMLElement ? (o.value = z, s(z)) : o.value = void 0);
    }, a = Ae(), c = Ae(), u = Ae(), h = Ae(), f = Ae(), d = Ae(), p = Ae([0, 0]), m = Ae([-1, -1]), g = Ae(), b = {
      dragPreviewRef: d,
      tableWrapperRef: f,
      contentWrapperRef: o,
      yLineHandleRef: h,
      xLineHandleRef: u,
      colHandleRef: a,
      rowHandleRef: c,
      hoverIndex: p,
      lineHoverIndex: m,
      dragInfo: g
    }, { pointerLeave: w, pointerMove: k } = tce(b, n), { dragRow: C, dragCol: M } = Xae(b, t, r), {
      onAddRow: T,
      onAddCol: N,
      selectCol: B,
      selectRow: $,
      deleteSelected: R,
      onAlign: V
    } = Zae(b, t, r);
    return kd(() => {
      requestAnimationFrame(() => {
        n.editable && Kae(b, n, e.value);
      });
    }), () => /* @__PURE__ */ j(
      "div",
      {
        onDragstart: (z) => z.preventDefault(),
        onDragover: (z) => z.preventDefault(),
        onDragleave: (z) => z.preventDefault(),
        onPointermove: k,
        onPointerleave: w
      },
      /* @__PURE__ */ j(
        "button",
        {
          type: "button",
          "data-show": "false",
          contenteditable: "false",
          draggable: "true",
          "data-role": "col-drag-handle",
          class: "handle cell-handle",
          onDragstart: M,
          onClick: B,
          onPointerdown: (z) => z.stopPropagation(),
          onPointermove: (z) => z.stopPropagation(),
          ref: a
        },
        /* @__PURE__ */ j(ts, { icon: i.renderButton("col_drag_handle") }),
        /* @__PURE__ */ j(
          "div",
          {
            "data-show": "false",
            class: "button-group",
            onPointermove: (z) => z.stopPropagation()
          },
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: V("left") }, /* @__PURE__ */ j(ts, { icon: i.renderButton("align_col_left") })),
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: V("center") }, /* @__PURE__ */ j(ts, { icon: i.renderButton("align_col_center") })),
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: V("right") }, /* @__PURE__ */ j(ts, { icon: i.renderButton("align_col_right") })),
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: R }, /* @__PURE__ */ j(ts, { icon: i.renderButton("delete_col") }))
        )
      ),
      /* @__PURE__ */ j(
        "button",
        {
          type: "button",
          "data-show": "false",
          contenteditable: "false",
          draggable: "true",
          "data-role": "row-drag-handle",
          class: "handle cell-handle",
          onDragstart: C,
          onClick: $,
          onPointerdown: (z) => z.stopPropagation(),
          onPointermove: (z) => z.stopPropagation(),
          ref: c
        },
        /* @__PURE__ */ j(ts, { icon: i.renderButton("row_drag_handle") }),
        /* @__PURE__ */ j(
          "div",
          {
            "data-show": "false",
            class: "button-group",
            onPointermove: (z) => z.stopPropagation()
          },
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: R }, /* @__PURE__ */ j(ts, { icon: i.renderButton("delete_row") }))
        )
      ),
      /* @__PURE__ */ j("div", { class: "table-wrapper", ref: f }, /* @__PURE__ */ j(
        "div",
        {
          "data-show": "false",
          class: "drag-preview",
          "data-direction": "vertical",
          ref: d
        },
        /* @__PURE__ */ j("table", null, /* @__PURE__ */ j("tbody", null))
      ), /* @__PURE__ */ j(
        "div",
        {
          "data-show": "false",
          contenteditable: "false",
          "data-display-type": "tool",
          "data-role": "x-line-drag-handle",
          class: "handle line-handle",
          onPointermove: (z) => z.stopPropagation(),
          ref: u
        },
        /* @__PURE__ */ j("button", { type: "button", onClick: T, class: "add-button" }, /* @__PURE__ */ j(ts, { icon: i.renderButton("add_row") }))
      ), /* @__PURE__ */ j(
        "div",
        {
          "data-show": "false",
          contenteditable: "false",
          "data-display-type": "tool",
          "data-role": "y-line-drag-handle",
          class: "handle line-handle",
          onPointermove: (z) => z.stopPropagation(),
          ref: h
        },
        /* @__PURE__ */ j("button", { type: "button", onClick: N, class: "add-button" }, /* @__PURE__ */ j(ts, { icon: i.renderButton("add_col") }))
      ), /* @__PURE__ */ j("table", { ref: l, class: "children" }))
    );
  }
});
var YN = (n) => {
  throw TypeError(n);
}, rce = (n, e, t) => e.has(n) || YN("Cannot " + t), ice = (n, e, t) => e.has(n) ? YN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), sce = (n, e, t) => (rce(n, e, "access private method"), t), q5, JN;
class oce {
  constructor(e, t, r, i) {
    this.ctx = e, this.node = t, this.view = r, this.getPos = i, ice(this, q5);
    const s = document.createElement("div");
    s.className = "milkdown-table-block";
    const o = document.createElement("tbody");
    this.contentDOM = o, o.setAttribute("data-content-dom", "true"), o.classList.add("content-dom"), this.nodeRef = Om(t);
    const l = Ui(nce, {
      view: r,
      ctx: e,
      getPos: i,
      config: e.get(wg.key),
      onMount: (a) => {
        a.appendChild(o);
      },
      node: this.nodeRef
    });
    l.mount(s), this.app = l, this.dom = s;
  }
  update(e) {
    return e.type !== this.node.type || e.sameMarkup(this.node) && e.content.eq(this.node.content) ? !1 : (this.node = e, this.nodeRef.value = e, !0);
  }
  stopEvent(e) {
    if (e.type === "drop" || e.type.startsWith("drag")) return !0;
    if (e.type === "mousedown" || e.type === "pointerdown") {
      if (e.target instanceof Element && e.target.closest("button")) return !0;
      const t = e.target;
      if (t instanceof HTMLElement && (t.closest("th") || t.closest("td"))) {
        const r = e;
        return sce(this, q5, JN).call(this, r);
      }
    }
    return !1;
  }
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : e.type === "selection" ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  destroy() {
    this.app.unmount(), this.dom.remove(), this.contentDOM.remove();
  }
}
q5 = /* @__PURE__ */ new WeakSet();
JN = function(n) {
  const e = this.view;
  if (!e.editable) return !1;
  const { state: t, dispatch: r } = e, i = e.posAtCoords({ left: n.clientX, top: n.clientY });
  if (!i) return !1;
  const s = t.doc.resolve(i.inside), o = bs(
    (c) => c.type.name === "table_cell" || c.type.name === "table_header"
  )(s);
  if (!o) return !1;
  if (t.selection instanceof Ee) {
    const c = bs(
      (u) => u.type.name === "table_cell" || u.type.name === "table_header"
    )(t.selection.$from);
    if (c?.node === o.node) return !1;
  }
  const { from: l } = o, a = $e.create(t.doc, l + 1);
  return t.selection.eq(a) ? !1 : (t.selection instanceof Nt ? setTimeout(() => {
    r(t.tr.setSelection(a).scrollIntoView());
  }, 20) : requestAnimationFrame(() => {
    r(t.tr.setSelection(a).scrollIntoView());
  }), !0);
};
const XN = yd(
  $a.node,
  (n) => (e, t, r) => new oce(n, e, t, r)
);
VN(XN, {
  displayName: "NodeView<table-block>",
  group: "TableBlock"
});
const lce = [wg, XN];
function W5(n) {
  if (!n) return !1;
  if (Array.isArray(n))
    return n.length > 1 ? !1 : W5(n[0]);
  const e = n.content;
  return e ? W5(e) : n.type === "text";
}
const ZN = kn((n) => {
  const e = n.get(yi);
  n.update(tf, (i) => ({
    ...i,
    editable: i.editable ?? (() => !0)
  }));
  const t = new en("MILKDOWN_CLIPBOARD");
  return new Ut({
    key: t,
    props: {
      handlePaste: (i, s) => {
        const o = n.get(fa), l = i.props.editable?.(i.state), { clipboardData: a } = s;
        if (!l || !a || i.state.selection.$from.node().type.spec.code) return !1;
        const u = a.getData("text/plain"), h = a.getData("vscode-editor-data");
        if (h) {
          const w = JSON.parse(h)?.mode;
          if (u && w) {
            const { tr: k } = i.state, C = yV("code_block", e);
            return k.replaceSelectionWith(C.create({ language: w })).setSelection(
              Ee.near(
                k.doc.resolve(Math.max(0, k.selection.from - 2))
              )
            ).insertText(u.replace(/\r\n?/g, `
`)), i.dispatch(k), !0;
          }
        }
        const f = a.getData("text/html");
        if (f.length === 0 && u.length === 0) return !1;
        const d = dl.fromSchema(e);
        let p;
        if (f.length === 0) {
          const b = o(u);
          if (!b || typeof b == "string") return !1;
          p = Sl.fromSchema(e).serializeFragment(
            b.content
          );
        } else {
          const b = document.createElement("template");
          b.innerHTML = f, p = b.content.cloneNode(!0), b.remove();
        }
        const m = d.parseSlice(p), g = kT(m);
        return g ? (i.dispatch(i.state.tr.replaceSelectionWith(g, !0)), !0) : (i.dispatch(i.state.tr.replaceSelection(m)), !0);
      },
      clipboardTextSerializer: (i) => {
        const s = n.get(kc);
        if (W5(i.content.toJSON()))
          return i.content.textBetween(
            0,
            i.content.size,
            `

`
          );
        const l = e.topNodeType.createAndFill(void 0, i.content);
        return l ? s(l) : "";
      }
    }
  });
});
ZN.meta = {
  displayName: "Prose<clipboard>",
  package: "@milkdown/plugin-clipboard"
};
function bu(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-history",
      ...e
    }
  }), n;
}
const P7 = Ye("Undo", () => () => sg);
bu(P7, {
  displayName: "Command<undo>"
});
const _7 = Ye("Redo", () => () => Uc);
bu(_7, {
  displayName: "Command<redo>"
});
const L7 = Ct({}, "historyProviderConfig");
bu(L7, {
  displayName: "Ctx<historyProviderConfig>"
});
const QN = kn(
  (n) => dre(n.get(L7.key))
);
bu(QN, {
  displayName: "Ctx<historyProviderPlugin>"
});
const B7 = Rr("historyKeymap", {
  Undo: {
    shortcuts: "Mod-z",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(P7.key);
    }
  },
  Redo: {
    shortcuts: ["Mod-y", "Shift-Mod-z"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(_7.key);
    }
  }
});
bu(B7.ctx, {
  displayName: "KeymapCtx<history>"
});
bu(B7.shortcuts, {
  displayName: "Keymap<history>"
});
const ace = [
  L7,
  QN,
  B7,
  P7,
  _7
].flat();
function cce(n, e) {
  const { doc: t, selection: r } = n;
  if (!t || !r || !(r instanceof Ee || r instanceof Or))
    return n;
  const { to: i } = r, s = e.type === "space" ? Array(e.size).fill(" ").join("") : "	";
  return n.insertText(s, i);
}
const kg = Ct(
  { type: "space", size: 2 },
  "indentConfig"
);
kg.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Ctx<indentConfig>"
};
const eR = iO((n) => ({
  Tab: (e, t) => {
    const r = n.get(kg.key), { tr: i } = e, s = cce(i, r);
    return s.docChanged ? (t?.(s), !0) : !1;
  }
}));
eR.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Shortcut<indent>"
};
const uce = [kg, eR];
class tR {
  constructor() {
    this.beforeMountedListeners = [], this.mountedListeners = [], this.updatedListeners = [], this.selectionUpdatedListeners = [], this.markdownUpdatedListeners = [], this.blurListeners = [], this.focusListeners = [], this.destroyListeners = [], this.beforeMount = (e) => (this.beforeMountedListeners.push(e), this), this.mounted = (e) => (this.mountedListeners.push(e), this), this.updated = (e) => (this.updatedListeners.push(e), this);
  }
  /// A getter to get all [subscribers](#interface-subscribers). You should not use this method directly.
  get listeners() {
    return {
      beforeMount: this.beforeMountedListeners,
      mounted: this.mountedListeners,
      updated: this.updatedListeners,
      markdownUpdated: this.markdownUpdatedListeners,
      blur: this.blurListeners,
      focus: this.focusListeners,
      destroy: this.destroyListeners,
      selectionUpdated: this.selectionUpdatedListeners
    };
  }
  /// Subscribe to the markdownUpdated event.
  /// This event will be triggered after the editor state is updated and **the document is changed**.
  /// The second parameter is the current markdown and the third parameter is the previous markdown.
  markdownUpdated(e) {
    return this.markdownUpdatedListeners.push(e), this;
  }
  /// Subscribe to the blur event.
  /// This event will be triggered when the editor is blurred.
  blur(e) {
    return this.blurListeners.push(e), this;
  }
  /// Subscribe to the focus event.
  /// This event will be triggered when the editor is focused.
  focus(e) {
    return this.focusListeners.push(e), this;
  }
  /// Subscribe to the destroy event.
  /// This event will be triggered before the editor is destroyed.
  destroy(e) {
    return this.destroyListeners.push(e), this;
  }
  /// Subscribe to the selectionUpdated event.
  /// This event will be triggered when the editor selection is updated.
  selectionUpdated(e) {
    return this.selectionUpdatedListeners.push(e), this;
  }
}
const Jm = at(
  new tR(),
  "listener"
), hce = new en("MILKDOWN_LISTENER"), nR = (n) => (n.inject(Jm, new tR()), async () => {
  await n.wait(ha);
  const e = n.get(Jm), { listeners: t } = e;
  t.beforeMount.forEach((a) => a(n)), await n.wait(ef);
  const r = n.get(kc);
  let i = null, s = null, o = null;
  const l = new Ut({
    key: hce,
    view: () => ({
      destroy: () => {
        t.destroy.forEach((a) => a(n));
      }
    }),
    props: {
      handleDOMEvents: {
        focus: () => (t.focus.forEach((a) => a(n)), !1),
        blur: () => (t.blur.forEach((a) => a(n)), !1)
      }
    },
    state: {
      init: (a, c) => {
        i = c.doc, s = r(c.doc);
      },
      apply: (a) => {
        const c = a.selection;
        return (!o && c || o && !c.eq(o)) && (t.selectionUpdated.forEach((h) => {
          h(n, c, o);
        }), o = c), !a.docChanged || a.getMeta("addToHistory") === !1 ? void 0 : e1(() => {
          const { doc: h } = a;
          if (t.updated.length > 0 && i && !i.eq(h) && t.updated.forEach((f) => {
            f(n, h, i);
          }), t.markdownUpdated.length > 0 && i && !i.eq(h)) {
            const f = r(h);
            t.markdownUpdated.forEach((d) => {
              d(n, f, s);
            }), s = f;
          }
          i = h;
        }, 200)();
      }
    }
  });
  n.update(ho, (a) => a.concat(l)), await n.wait(vp), t.mounted.forEach((a) => a(n));
});
nR.meta = {
  package: "@milkdown/plugin-listener",
  displayName: "Listener"
};
const z7 = Ct(
  {
    shouldAppend: (n) => !(!n || ["heading", "paragraph"].includes(n.type.name)),
    getNode: (n) => n.schema.nodes.paragraph.create()
  },
  "trailingConfig"
);
z7.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Ctx<trailingConfig>"
};
const rR = kn((n) => {
  const e = new en("MILKDOWN_TRAILING"), { shouldAppend: t, getNode: r } = n.get(z7.key), i = new Ut({
    key: e,
    state: {
      init: (s, o) => {
        const l = o.tr.doc.lastChild;
        return t(l, o);
      },
      apply: (s, o, l, a) => {
        if (!s.docChanged) return o;
        const c = s.doc.lastChild;
        return t(c, a);
      }
    },
    appendTransaction: (s, o, l) => {
      const { doc: a, tr: c } = l, u = r?.(l), h = i.getState(l), f = a.content.size;
      if (!(!h || !u))
        return c.insert(f, u);
    }
  });
  return i;
});
rR.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Prose<trailing>"
};
const fce = [z7, rR];
var kt = /* @__PURE__ */ ((n) => (n.CodeMirror = "code-mirror", n.ListItem = "list-item", n.LinkTooltip = "link-tooltip", n.Cursor = "cursor", n.ImageBlock = "image-block", n.BlockEdit = "block-edit", n.Toolbar = "toolbar", n.Placeholder = "placeholder", n.Table = "table", n.Latex = "latex", n))(kt || {});
const dce = {
  cursor: !0,
  "list-item": !0,
  "link-tooltip": !0,
  "image-block": !0,
  "block-edit": !0,
  placeholder: !0,
  toolbar: !0,
  "code-mirror": !0,
  table: !0,
  latex: !0
}, pce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25ZM8.25 16.625C8.0375 16.625 7.85942 16.5531 7.71575 16.4093C7.57192 16.2654 7.5 16.0872 7.5 15.8748C7.5 15.6621 7.57192 15.484 7.71575 15.3405C7.85942 15.1968 8.0375 15.125 8.25 15.125H15.75C15.9625 15.125 16.1406 15.1969 16.2843 15.3408C16.4281 15.4846 16.5 15.6628 16.5 15.8753C16.5 16.0879 16.4281 16.266 16.2843 16.4095C16.1406 16.5532 15.9625 16.625 15.75 16.625H8.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM8.25 8.875C8.0375 8.875 7.85942 8.80308 7.71575 8.65925C7.57192 8.51542 7.5 8.33725 7.5 8.12475C7.5 7.91208 7.57192 7.734 7.71575 7.5905C7.85942 7.44683 8.0375 7.375 8.25 7.375H15.75C15.9625 7.375 16.1406 7.44692 16.2843 7.59075C16.4281 7.73458 16.5 7.91275 16.5 8.12525C16.5 8.33792 16.4281 8.516 16.2843 8.6595C16.1406 8.80317 15.9625 8.875 15.75 8.875H8.25ZM4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25Z"
    />
  </svg>
`, mce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25ZM4.25 16.625C4.0375 16.625 3.85942 16.5531 3.71575 16.4093C3.57192 16.2654 3.5 16.0872 3.5 15.8748C3.5 15.6621 3.57192 15.484 3.71575 15.3405C3.85942 15.1968 4.0375 15.125 4.25 15.125H13.75C13.9625 15.125 14.1406 15.1969 14.2843 15.3408C14.4281 15.4846 14.5 15.6628 14.5 15.8753C14.5 16.0879 14.4281 16.266 14.2843 16.4095C14.1406 16.5532 13.9625 16.625 13.75 16.625H4.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM4.25 8.875C4.0375 8.875 3.85942 8.80308 3.71575 8.65925C3.57192 8.51542 3.5 8.33725 3.5 8.12475C3.5 7.91208 3.57192 7.734 3.71575 7.5905C3.85942 7.44683 4.0375 7.375 4.25 7.375H13.75C13.9625 7.375 14.1406 7.44692 14.2843 7.59075C14.4281 7.73458 14.5 7.91275 14.5 8.12525C14.5 8.33792 14.4281 8.516 14.2843 8.6595C14.1406 8.80317 13.9625 8.875 13.75 8.875H4.25ZM4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25Z"
    />
  </svg>
`, gce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25ZM10.25 8.875C10.0375 8.875 9.85942 8.80308 9.71575 8.65925C9.57192 8.51542 9.5 8.33725 9.5 8.12475C9.5 7.91208 9.57192 7.734 9.71575 7.5905C9.85942 7.44683 10.0375 7.375 10.25 7.375H19.75C19.9625 7.375 20.1406 7.44692 20.2843 7.59075C20.4281 7.73458 20.5 7.91275 20.5 8.12525C20.5 8.33792 20.4281 8.516 20.2843 8.6595C20.1406 8.80317 19.9625 8.875 19.75 8.875H10.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM10.25 16.625C10.0375 16.625 9.85942 16.5531 9.71575 16.4093C9.57192 16.2654 9.5 16.0872 9.5 15.8748C9.5 15.6621 9.57192 15.484 9.71575 15.3405C9.85942 15.1968 10.0375 15.125 10.25 15.125H19.75C19.9625 15.125 20.1406 15.1969 20.2843 15.3408C20.4281 15.4846 20.5 15.6628 20.5 15.8753C20.5 16.0879 20.4281 16.266 20.2843 16.4095C20.1406 16.5532 19.9625 16.625 19.75 16.625H10.25ZM4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25Z"
    />
  </svg>
`, yce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M8.85758 18.625C8.4358 18.625 8.07715 18.4772 7.78163 18.1817C7.48613 17.8862 7.33838 17.5275 7.33838 17.1058V6.8942C7.33838 6.47242 7.48613 6.11377 7.78163 5.81825C8.07715 5.52275 8.4358 5.375 8.85758 5.375H12.1999C13.2191 5.375 14.1406 5.69231 14.9643 6.32693C15.788 6.96154 16.1999 7.81603 16.1999 8.89038C16.1999 9.63779 16.0194 10.2471 15.6585 10.7183C15.2976 11.1894 14.9088 11.5314 14.4922 11.7442C15.005 11.9211 15.4947 12.2708 15.9614 12.7933C16.428 13.3157 16.6614 14.0192 16.6614 14.9038C16.6614 16.182 16.1902 17.1217 15.2479 17.723C14.3056 18.3243 13.3563 18.625 12.3999 18.625H8.85758ZM9.4883 16.6327H12.3191C13.1063 16.6327 13.6627 16.4141 13.9884 15.9769C14.314 15.5397 14.4768 15.1205 14.4768 14.7192C14.4768 14.3179 14.314 13.8987 13.9884 13.4615C13.6627 13.0243 13.0909 12.8057 12.273 12.8057H9.4883V16.6327ZM9.4883 10.875H12.0826C12.6903 10.875 13.172 10.7013 13.5278 10.3539C13.8836 10.0064 14.0615 9.59037 14.0615 9.10575C14.0615 8.59035 13.8733 8.16918 13.497 7.84225C13.1207 7.51533 12.6595 7.35188 12.1133 7.35188H9.4883V10.875Z"
    />
  </svg>
`, bce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_952_6527)">
      <circle cx="12" cy="12" r="3" />
    </g>
    <defs>
      <clipPath id="clip0_952_6527">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, vce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8070)">
      <path
        d="M4 10.5C3.17 10.5 2.5 11.17 2.5 12C2.5 12.83 3.17 13.5 4 13.5C4.83 13.5 5.5 12.83 5.5 12C5.5 11.17 4.83 10.5 4 10.5ZM4 4.5C3.17 4.5 2.5 5.17 2.5 6C2.5 6.83 3.17 7.5 4 7.5C4.83 7.5 5.5 6.83 5.5 6C5.5 5.17 4.83 4.5 4 4.5ZM4 16.5C3.17 16.5 2.5 17.18 2.5 18C2.5 18.82 3.18 19.5 4 19.5C4.82 19.5 5.5 18.82 5.5 18C5.5 17.18 4.83 16.5 4 16.5ZM8 19H20C20.55 19 21 18.55 21 18C21 17.45 20.55 17 20 17H8C7.45 17 7 17.45 7 18C7 18.55 7.45 19 8 19ZM8 13H20C20.55 13 21 12.55 21 12C21 11.45 20.55 11 20 11H8C7.45 11 7 11.45 7 12C7 12.55 7.45 13 8 13ZM7 6C7 6.55 7.45 7 8 7H20C20.55 7 21 6.55 21 6C21 5.45 20.55 5 20 5H8C7.45 5 7 5.45 7 6Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8070">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, wce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 24 24"
  >
    <path
      fill="currentColor"
      d="M9 22a1 1 0 0 1-1-1v-3H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6.1l-3.7 3.71c-.2.19-.45.29-.7.29zm1-6v3.08L13.08 16H20V4H4v12z"
    />
  </svg>
`, xce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1803_1151)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM10.71 16.29C10.32 16.68 9.69 16.68 9.3 16.29L5.71 12.7C5.32 12.31 5.32 11.68 5.71 11.29C6.1 10.9 6.73 10.9 7.12 11.29L10 14.17L16.88 7.29C17.27 6.9 17.9 6.9 18.29 7.29C18.68 7.68 18.68 8.31 18.29 8.7L10.71 16.29Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1803_1151">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, kce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1803_535)">
      <path
        d="M18 19H6C5.45 19 5 18.55 5 18V6C5 5.45 5.45 5 6 5H18C18.55 5 19 5.45 19 6V18C19 18.55 18.55 19 18 19ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1803_535">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, iR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M19.5 8.25l-7.5 7.5-7.5-7.5"
    />
  </svg>
`, sR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1098_15553)">
      <path
        d="M18.3007 5.70973C17.9107 5.31973 17.2807 5.31973 16.8907 5.70973L12.0007 10.5897L7.1107 5.69973C6.7207 5.30973 6.0907 5.30973 5.7007 5.69973C5.3107 6.08973 5.3107 6.71973 5.7007 7.10973L10.5907 11.9997L5.7007 16.8897C5.3107 17.2797 5.3107 17.9097 5.7007 18.2997C6.0907 18.6897 6.7207 18.6897 7.1107 18.2997L12.0007 13.4097L16.8907 18.2997C17.2807 18.6897 17.9107 18.6897 18.3007 18.2997C18.6907 17.9097 18.6907 17.2797 18.3007 16.8897L13.4107 11.9997L18.3007 7.10973C18.6807 6.72973 18.6807 6.08973 18.3007 5.70973Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1098_15553">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, oR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8081)">
      <path
        d="M9.4 16.6L4.8 12L9.4 7.4L8 6L2 12L8 18L9.4 16.6ZM14.6 16.6L19.2 12L14.6 7.4L16 6L22 12L16 18L14.6 16.6Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8081">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, F7 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
  >
    <g clip-path="url(#clip0_1013_1606)">
      <path
        d="M9.00012 16.1998L5.50012 12.6998C5.11012 12.3098 4.49012 12.3098 4.10012 12.6998C3.71012 13.0898 3.71012 13.7098 4.10012 14.0998L8.29012 18.2898C8.68012 18.6798 9.31012 18.6798 9.70012 18.2898L20.3001 7.69982C20.6901 7.30982 20.6901 6.68982 20.3001 6.29982C19.9101 5.90982 19.2901 5.90982 18.9001 6.29982L9.00012 16.1998Z"
        fill="#817567"
      />
    </g>
    <defs>
      <clipPath id="clip0_1013_1606">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, lR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    height="24px"
    viewBox="0 -960 960 960"
    width="24px"
    fill="none"
  >
    <path
      d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z"
    />
  </svg>
`, Sce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7900)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M19 13H5C4.45 13 4 12.55 4 12C4 11.45 4.45 11 5 11H19C19.55 11 20 11.45 20 12C20 12.55 19.55 13 19 13Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7900">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, sS = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="16"
    height="16"
    viewBox="0 0 16 16"
  >
    <path
      d="M3.5 9.83366C3.35833 9.83366 3.23961 9.78571 3.14383 9.68983C3.04794 9.59394 3 9.47516 3 9.33349C3 9.19171 3.04794 9.07299 3.14383 8.97733C3.23961 8.88155 3.35833 8.83366 3.5 8.83366H12.5C12.6417 8.83366 12.7604 8.8816 12.8562 8.97749C12.9521 9.07338 13 9.19216 13 9.33383C13 9.4756 12.9521 9.59433 12.8562 9.68999C12.7604 9.78577 12.6417 9.83366 12.5 9.83366H3.5ZM3.5 7.16699C3.35833 7.16699 3.23961 7.11905 3.14383 7.02316C3.04794 6.92727 3 6.80849 3 6.66683C3 6.52505 3.04794 6.40633 3.14383 6.31066C3.23961 6.21488 3.35833 6.16699 3.5 6.16699H12.5C12.6417 6.16699 12.7604 6.21494 12.8562 6.31083C12.9521 6.40671 13 6.52549 13 6.66716C13 6.80894 12.9521 6.92766 12.8562 7.02333C12.7604 7.1191 12.6417 7.16699 12.5 7.16699H3.5Z"
    />
  </svg>
`, H7 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1013_1585)">
      <path
        d="M14.06 9.02L14.98 9.94L5.92 19H5V18.08L14.06 9.02ZM17.66 3C17.41 3 17.15 3.1 16.96 3.29L15.13 5.12L18.88 8.87L20.71 7.04C21.1 6.65 21.1 6.02 20.71 5.63L18.37 3.29C18.17 3.09 17.92 3 17.66 3ZM14.06 6.19L3 17.25V21H6.75L17.81 9.94L14.06 6.19Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1013_1585">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Cce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5553)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM12 17H14V7H10V9H12V17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5553">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Mce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5559)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15H11V13H13C14.1 13 15 12.11 15 11V9C15 7.89 14.1 7 13 7H9V9H13V11H11C9.9 11 9 11.89 9 13V17H15V15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5559">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Tce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5565)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15V13.5C15 12.67 14.33 12 13.5 12C14.33 12 15 11.33 15 10.5V9C15 7.89 14.1 7 13 7H9V9H13V11H11V13H13V15H9V17H13C14.1 17 15 16.11 15 15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5565">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ace = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7757)">
      <path
        d="M19.04 3H5.04004C3.94004 3 3.04004 3.9 3.04004 5V19C3.04004 20.1 3.94004 21 5.04004 21H19.04C20.14 21 21.04 20.1 21.04 19V5C21.04 3.9 20.14 3 19.04 3ZM19.04 19H5.04004V5H19.04V19ZM13.04 17H15.04V7H13.04V11H11.04V7H9.04004V13H13.04V17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7757">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Oce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7760)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15V13C15 11.89 14.1 11 13 11H11V9H15V7H9V13H13V15H9V17H13C14.1 17 15 16.11 15 15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7760">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ece = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7763)">
      <path
        d="M11 17H13C14.1 17 15 16.11 15 15V13C15 11.89 14.1 11 13 11H11V9H15V7H11C9.9 7 9 7.89 9 9V15C9 16.11 9.9 17 11 17ZM11 13H13V15H11V13ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7763">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, j5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8075)">
      <path
        d="M19 5V19H5V5H19ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM14.14 11.86L11.14 15.73L9 13.14L6 17H18L14.14 11.86Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8075">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ice = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M6.29811 18.625C6.04505 18.625 5.83115 18.5375 5.65641 18.3626C5.48166 18.1877 5.39429 17.9736 5.39429 17.7203C5.39429 17.467 5.48166 17.2532 5.65641 17.0788C5.83115 16.9045 6.04505 16.8173 6.29811 16.8173H9.21159L12.452 7.18265H9.53851C9.28545 7.18265 9.07155 7.0952 8.89681 6.9203C8.72206 6.7454 8.63469 6.5313 8.63469 6.278C8.63469 6.02472 8.72206 5.81089 8.89681 5.63652C9.07155 5.46217 9.28545 5.375 9.53851 5.375H16.8847C17.1377 5.375 17.3516 5.46245 17.5264 5.63735C17.7011 5.81225 17.7885 6.02634 17.7885 6.27962C17.7885 6.53293 17.7011 6.74676 17.5264 6.92113C17.3516 7.09548 17.1377 7.18265 16.8847 7.18265H14.2789L11.0385 16.8173H13.6443C13.8973 16.8173 14.1112 16.9048 14.286 17.0797C14.4607 17.2546 14.5481 17.4687 14.5481 17.722C14.5481 17.9752 14.4607 18.1891 14.286 18.3634C14.1112 18.5378 13.8973 18.625 13.6443 18.625H6.29811Z"
    />
  </svg>
`, Dce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M17.0385 19.5003V16.5388H14.0769V15.0388H17.0385V12.0773H18.5384V15.0388H21.5V16.5388H18.5384V19.5003H17.0385ZM10.8077 16.5388H7.03845C5.78282 16.5388 4.7125 16.0963 3.8275 15.2114C2.9425 14.3266 2.5 13.2564 2.5 12.0009C2.5 10.7454 2.9425 9.67504 3.8275 8.78979C4.7125 7.90454 5.78282 7.46191 7.03845 7.46191H10.8077V8.96186H7.03845C6.1987 8.96186 5.48235 9.25834 4.8894 9.85129C4.29645 10.4442 3.99998 11.1606 3.99998 12.0003C3.99998 12.8401 4.29645 13.5564 4.8894 14.1494C5.48235 14.7423 6.1987 15.0388 7.03845 15.0388H10.8077V16.5388ZM8.25 12.7503V11.2504H15.75V12.7503H8.25ZM21.5 12.0003H20C20 11.1606 19.7035 10.4442 19.1106 9.85129C18.5176 9.25834 17.8013 8.96186 16.9615 8.96186H13.1923V7.46191H16.9615C18.2171 7.46191 19.2875 7.90441 20.1725 8.78939C21.0575 9.67439 21.5 10.7447 21.5 12.0003Z"
    />
  </svg>
`, Nce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_971_7680)">
      <path
        d="M11 18C11 19.1 10.1 20 9 20C7.9 20 7 19.1 7 18C7 16.9 7.9 16 9 16C10.1 16 11 16.9 11 18ZM9 10C7.9 10 7 10.9 7 12C7 13.1 7.9 14 9 14C10.1 14 11 13.1 11 12C11 10.9 10.1 10 9 10ZM9 4C7.9 4 7 4.9 7 6C7 7.1 7.9 8 9 8C10.1 8 11 7.1 11 6C11 4.9 10.1 4 9 4ZM15 8C16.1 8 17 7.1 17 6C17 4.9 16.1 4 15 4C13.9 4 13 4.9 13 6C13 7.1 13.9 8 15 8ZM15 10C13.9 10 13 10.9 13 12C13 13.1 13.9 14 15 14C16.1 14 17 13.1 17 12C17 10.9 16.1 10 15 10ZM15 16C13.9 16 13 16.9 13 18C13 19.1 13.9 20 15 20C16.1 20 17 19.1 17 18C17 16.9 16.1 16 15 16Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_971_7680">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Rce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8067)">
      <path
        d="M8 7H20C20.55 7 21 6.55 21 6C21 5.45 20.55 5 20 5H8C7.45 5 7 5.45 7 6C7 6.55 7.45 7 8 7ZM20 17H8C7.45 17 7 17.45 7 18C7 18.55 7.45 19 8 19H20C20.55 19 21 18.55 21 18C21 17.45 20.55 17 20 17ZM20 11H8C7.45 11 7 11.45 7 12C7 12.55 7.45 13 8 13H20C20.55 13 21 12.55 21 12C21 11.45 20.55 11 20 11ZM4.5 16H2.5C2.22 16 2 16.22 2 16.5C2 16.78 2.22 17 2.5 17H4V17.5H3.5C3.22 17.5 3 17.72 3 18C3 18.28 3.22 18.5 3.5 18.5H4V19H2.5C2.22 19 2 19.22 2 19.5C2 19.78 2.22 20 2.5 20H4.5C4.78 20 5 19.78 5 19.5V16.5C5 16.22 4.78 16 4.5 16ZM2.5 5H3V7.5C3 7.78 3.22 8 3.5 8C3.78 8 4 7.78 4 7.5V4.5C4 4.22 3.78 4 3.5 4H2.5C2.22 4 2 4.22 2 4.5C2 4.78 2.22 5 2.5 5ZM4.5 10H2.5C2.22 10 2 10.22 2 10.5C2 10.78 2.22 11 2.5 11H3.8L2.12 12.96C2.04 13.05 2 13.17 2 13.28V13.5C2 13.78 2.22 14 2.5 14H4.5C4.78 14 5 13.78 5 13.5C5 13.22 4.78 13 4.5 13H3.2L4.88 11.04C4.96 10.95 5 10.83 5 10.72V10.5C5 10.22 4.78 10 4.5 10Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8067">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, U5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_971_7676)">
      <path
        d="M18 13H13V18C13 18.55 12.55 19 12 19C11.45 19 11 18.55 11 18V13H6C5.45 13 5 12.55 5 12C5 11.45 5.45 11 6 11H11V6C11 5.45 11.45 5 12 5C12.55 5 13 5.45 13 6V11H18C18.55 11 19 11.45 19 12C19 12.55 18.55 13 18 13Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_971_7676">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Pce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7897)">
      <path
        d="M7.17 17C7.68 17 8.15 16.71 8.37 16.26L9.79 13.42C9.93 13.14 10 12.84 10 12.53V8C10 7.45 9.55 7 9 7H5C4.45 7 4 7.45 4 8V12C4 12.55 4.45 13 5 13H7L5.97 15.06C5.52 15.95 6.17 17 7.17 17ZM17.17 17C17.68 17 18.15 16.71 18.37 16.26L19.79 13.42C19.93 13.14 20 12.84 20 12.53V8C20 7.45 19.55 7 19 7H15C14.45 7 14 7.45 14 8V12C14 12.55 14.45 13 15 13H17L15.97 15.06C15.52 15.95 16.17 17 17.17 17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7897">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, K5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M7.30775 20.4997C6.81058 20.4997 6.385 20.3227 6.031 19.9687C5.677 19.6147 5.5 19.1892 5.5 18.692V5.99973H5.25C5.0375 5.99973 4.85942 5.92782 4.71575 5.78398C4.57192 5.64015 4.5 5.46198 4.5 5.24948C4.5 5.03682 4.57192 4.85873 4.71575 4.71523C4.85942 4.57157 5.0375 4.49973 5.25 4.49973H9C9 4.2549 9.08625 4.04624 9.25875 3.87374C9.43108 3.7014 9.63967 3.61523 9.8845 3.61523H14.1155C14.3603 3.61523 14.5689 3.7014 14.7413 3.87374C14.9138 4.04624 15 4.2549 15 4.49973H18.75C18.9625 4.49973 19.1406 4.57165 19.2843 4.71548C19.4281 4.85932 19.5 5.03748 19.5 5.24998C19.5 5.46265 19.4281 5.64073 19.2843 5.78423C19.1406 5.9279 18.9625 5.99973 18.75 5.99973H18.5V18.692C18.5 19.1892 18.323 19.6147 17.969 19.9687C17.615 20.3227 17.1894 20.4997 16.6923 20.4997H7.30775ZM17 5.99973H7V18.692C7 18.7818 7.02883 18.8556 7.0865 18.9132C7.14417 18.9709 7.21792 18.9997 7.30775 18.9997H16.6923C16.7821 18.9997 16.8558 18.9709 16.9135 18.9132C16.9712 18.8556 17 18.7818 17 18.692V5.99973ZM10.1543 16.9997C10.3668 16.9997 10.5448 16.9279 10.6885 16.7842C10.832 16.6404 10.9037 16.4622 10.9037 16.2497V8.74973C10.9037 8.53723 10.8318 8.35907 10.688 8.21523C10.5443 8.07157 10.3662 7.99973 10.1535 7.99973C9.941 7.99973 9.76292 8.07157 9.61925 8.21523C9.47575 8.35907 9.404 8.53723 9.404 8.74973V16.2497C9.404 16.4622 9.47583 16.6404 9.6195 16.7842C9.76333 16.9279 9.94158 16.9997 10.1543 16.9997ZM13.8465 16.9997C14.059 16.9997 14.2371 16.9279 14.3807 16.7842C14.5243 16.6404 14.596 16.4622 14.596 16.2497V8.74973C14.596 8.53723 14.5242 8.35907 14.3805 8.21523C14.2367 8.07157 14.0584 7.99973 13.8458 7.99973C13.6333 7.99973 13.4552 8.07157 13.3115 8.21523C13.168 8.35907 13.0962 8.53723 13.0962 8.74973V16.2497C13.0962 16.4622 13.1682 16.6404 13.312 16.7842C13.4557 16.9279 13.6338 16.9997 13.8465 16.9997Z"
    />
  </svg>
`, aR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
    />
  </svg>
`, _ce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M3.25 13.7404C3.0375 13.7404 2.85938 13.6684 2.71563 13.5246C2.57188 13.3808 2.5 13.2026 2.5 12.99C2.5 12.7774 2.57188 12.5993 2.71563 12.4558C2.85938 12.3122 3.0375 12.2404 3.25 12.2404H20.75C20.9625 12.2404 21.1406 12.3123 21.2843 12.4561C21.4281 12.5999 21.5 12.7781 21.5 12.9907C21.5 13.2033 21.4281 13.3814 21.2843 13.525C21.1406 13.6686 20.9625 13.7404 20.75 13.7404H3.25ZM10.9423 10.2596V6.62495H6.5673C6.2735 6.62495 6.02377 6.52201 5.8181 6.31613C5.61245 6.11026 5.50963 5.86027 5.50963 5.56615C5.50963 5.27205 5.61245 5.02083 5.8181 4.8125C6.02377 4.60417 6.2735 4.5 6.5673 4.5H17.4423C17.7361 4.5 17.9858 4.60294 18.1915 4.80883C18.3971 5.01471 18.5 5.2647 18.5 5.5588C18.5 5.85292 18.3971 6.10413 18.1915 6.31245C17.9858 6.52078 17.7361 6.62495 17.4423 6.62495H13.0673V10.2596H10.9423ZM10.9423 15.7211H13.0673V18.4423C13.0673 18.7361 12.9643 18.9858 12.7584 19.1915C12.5526 19.3971 12.3026 19.5 12.0085 19.5C11.7144 19.5 11.4631 19.3962 11.2548 19.1887C11.0465 18.9811 10.9423 18.7291 10.9423 18.4327V15.7211Z"
    />
  </svg>
`, Lce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8078)">
      <path
        d="M20 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H20C21.1 21 22 20.1 22 19V5C22 3.9 21.1 3 20 3ZM20 5V8H5V5H20ZM15 19H10V10H15V19ZM5 10H8V19H5V10ZM17 19V10H20V19H17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8078">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Bce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5547)">
      <path
        d="M5 5.5C5 6.33 5.67 7 6.5 7H10.5V17.5C10.5 18.33 11.17 19 12 19C12.83 19 13.5 18.33 13.5 17.5V7H17.5C18.33 7 19 6.33 19 5.5C19 4.67 18.33 4 17.5 4H6.5C5.67 4 5 4.67 5 5.5Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5547">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, zce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M5.66936 16.3389L9.39244 12.6158C9.54115 12.4671 9.71679 12.3937 9.91936 12.3957C10.1219 12.3976 10.2975 12.4761 10.4463 12.6312C10.5847 12.7823 10.654 12.9585 10.654 13.1599C10.654 13.3613 10.5847 13.5363 10.4463 13.6851L6.32704 17.8197C6.14627 18.0004 5.93538 18.0908 5.69436 18.0908C5.45333 18.0908 5.24243 18.0004 5.06166 17.8197L3.01744 15.7754C2.87899 15.637 2.81136 15.4629 2.81456 15.2533C2.81776 15.0437 2.88859 14.8697 3.02706 14.7312C3.16551 14.5928 3.34008 14.5235 3.55076 14.5235C3.76144 14.5235 3.93494 14.5928 4.07126 14.7312L5.66936 16.3389ZM5.66936 8.72359L9.39244 5.00049C9.54115 4.85177 9.71679 4.77838 9.91936 4.78031C10.1219 4.78223 10.2975 4.86075 10.4463 5.01586C10.5847 5.16691 10.654 5.34314 10.654 5.54454C10.654 5.74592 10.5847 5.92097 10.4463 6.06969L6.32704 10.2043C6.14627 10.3851 5.93538 10.4755 5.69436 10.4755C5.45333 10.4755 5.24243 10.3851 5.06166 10.2043L3.01744 8.16009C2.87899 8.02162 2.81136 7.84759 2.81456 7.63799C2.81776 7.42837 2.88859 7.25433 3.02706 7.11586C3.16551 6.97741 3.34008 6.90819 3.55076 6.90819C3.76144 6.90819 3.93494 6.97741 4.07126 7.11586L5.66936 8.72359ZM13.7597 16.5581C13.5472 16.5581 13.3691 16.4862 13.2253 16.3424C13.0816 16.1986 13.0097 16.0204 13.0097 15.8078C13.0097 15.5952 13.0816 15.4171 13.2253 15.2735C13.3691 15.13 13.5472 15.0582 13.7597 15.0582H20.7597C20.9722 15.0582 21.1503 15.1301 21.2941 15.2739C21.4378 15.4177 21.5097 15.5959 21.5097 15.8085C21.5097 16.0211 21.4378 16.1992 21.2941 16.3427C21.1503 16.4863 20.9722 16.5581 20.7597 16.5581H13.7597ZM13.7597 8.94276C13.5472 8.94276 13.3691 8.87085 13.2253 8.72704C13.0816 8.58324 13.0097 8.40504 13.0097 8.19244C13.0097 7.97985 13.0816 7.80177 13.2253 7.65819C13.3691 7.5146 13.5472 7.44281 13.7597 7.44281H20.7597C20.9722 7.44281 21.1503 7.51471 21.2941 7.65851C21.4378 7.80233 21.5097 7.98053 21.5097 8.19311C21.5097 8.40571 21.4378 8.5838 21.2941 8.72739C21.1503 8.87097 20.9722 8.94276 20.7597 8.94276H13.7597Z"
    />
  </svg>
`, cR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 24 24"
  >
    <path
      fill="currentColor"
      d="M7 19v-.808L13.096 12L7 5.808V5h10v1.25H9.102L14.727 12l-5.625 5.77H17V19z"
    />
  </svg>
`, uR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    height="24px"
    viewBox="0 -960 960 960"
    width="24px"
  >
    <path
      d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"
    />
  </svg>
`, Fce = {
  [kt.CodeMirror]: {
    theme: qH,
    languages: NH,
    expandIcon: iR,
    searchIcon: aR,
    clearSearchIcon: sR,
    searchPlaceholder: "Search language",
    noResultText: "No result",
    previewToggleIcon: (n) => n ? H7 : uR
  }
}, Hce = at([], "FeaturesCtx"), $ce = at({}, "CrepeCtx");
function Vce(n) {
  return n.get("CrepeCtx");
}
function Sg(n) {
  return n.use("FeaturesCtx");
}
function Ps(n) {
  return (e) => {
    Sg(e).update((t) => t.includes(n) ? t : [...t, n]);
  };
}
function hR(n) {
  return n.$from.parent.type.name === "code_block";
}
function fR(n) {
  var e;
  const t = (e = n.$from.node(n.$from.depth - 1)) == null ? void 0 : e.type;
  return t?.name === "list_item";
}
var dR = (n) => {
  throw TypeError(n);
}, pR = (n, e, t) => e.has(n) || dR("Cannot " + t), Yu = (n, e, t) => (pR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), oS = (n, e, t) => e.has(n) ? dR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), qce = (n, e, t, r) => (pR(n, e, "write to private field"), e.set(n, t), t), hc, $p;
class mR {
  constructor() {
    oS(this, hc, []), this.clear = () => (qce(this, hc, []), this), oS(this, $p, (e) => {
      const t = {
        group: e,
        addItem: (r, i) => {
          const s = { ...i, key: r };
          return e.items.push(s), t;
        },
        clear: () => (e.items = [], t)
      };
      return t;
    }), this.addGroup = (e, t) => {
      const i = {
        key: e,
        label: t,
        items: []
      };
      return Yu(this, hc).push(i), Yu(this, $p).call(this, i);
    }, this.getGroup = (e) => {
      const t = Yu(this, hc).find((r) => r.key === e);
      if (!t) throw new Error(`Group with key ${e} not found`);
      return Yu(this, $p).call(this, t);
    }, this.build = () => Yu(this, hc);
  }
}
hc = /* @__PURE__ */ new WeakMap();
$p = /* @__PURE__ */ new WeakMap();
function Wce(n, e, t) {
  var r, i, s, o, l, a, c, u, h, f, d, p, m, g, b, w, k, C, M, T, N, B, $, R, V, z, ue, ie, he, Se, ge, ye, ze, I, Ie, Ve, O, dt, Ue, et, Mt, Ft, sn, Gt, _r, E, P, W, Q, J, Y, ae, re, oe, te, De, de, Te, Pe, F, X, pe, _e, je, xt, Pt, Yt, on, wt, pt, Vn, En, Nl, Rl, Fd, Ao, Hd, $d, ln, _s, Vd, vu, Wa, wu, xu, qd, Lr, Ls, ku, Su, ja, Cu, ni, Mu, Tu, Au, Ou, Wd, Re, L, le, Oe, Tt, bn, tn, In, ri, Oo, Ua, vn, Eu, Iu, V7, q7, W7, j7, U7, K7, G7;
  const Ka = t && Sg(t).get(), OR = Ka?.includes(kt.Latex), ER = Ka?.includes(kt.ImageBlock), IR = Ka?.includes(kt.Table), Du = new mR();
  if (e?.textGroup !== null) {
    const gt = Du.addGroup(
      "text",
      (i = (r = e?.textGroup) == null ? void 0 : r.label) != null ? i : "Text"
    );
    ((s = e?.textGroup) == null ? void 0 : s.text) !== null && gt.addItem("text", {
      label: (a = (l = (o = e?.textGroup) == null ? void 0 : o.text) == null ? void 0 : l.label) != null ? a : "Text",
      icon: (h = (u = (c = e?.textGroup) == null ? void 0 : c.text) == null ? void 0 : u.icon) != null ? h : Bce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Os.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt
        });
      }
    }), ((f = e?.textGroup) == null ? void 0 : f.h1) !== null && gt.addItem("h1", {
      label: (m = (p = (d = e?.textGroup) == null ? void 0 : d.h1) == null ? void 0 : p.label) != null ? m : "Heading 1",
      icon: (w = (b = (g = e?.textGroup) == null ? void 0 : g.h1) == null ? void 0 : b.icon) != null ? w : Cce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 1
          }
        });
      }
    }), ((k = e?.textGroup) == null ? void 0 : k.h2) !== null && gt.addItem("h2", {
      label: (T = (M = (C = e?.textGroup) == null ? void 0 : C.h2) == null ? void 0 : M.label) != null ? T : "Heading 2",
      icon: ($ = (B = (N = e?.textGroup) == null ? void 0 : N.h2) == null ? void 0 : B.icon) != null ? $ : Mce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 2
          }
        });
      }
    }), ((R = e?.textGroup) == null ? void 0 : R.h3) !== null && gt.addItem("h3", {
      label: (ue = (z = (V = e?.textGroup) == null ? void 0 : V.h3) == null ? void 0 : z.label) != null ? ue : "Heading 3",
      icon: (Se = (he = (ie = e?.textGroup) == null ? void 0 : ie.h3) == null ? void 0 : he.icon) != null ? Se : Tce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 3
          }
        });
      }
    }), ((ge = e?.textGroup) == null ? void 0 : ge.h4) !== null && gt.addItem("h4", {
      label: (I = (ze = (ye = e?.textGroup) == null ? void 0 : ye.h4) == null ? void 0 : ze.label) != null ? I : "Heading 4",
      icon: (O = (Ve = (Ie = e?.textGroup) == null ? void 0 : Ie.h4) == null ? void 0 : Ve.icon) != null ? O : Ace,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 4
          }
        });
      }
    }), ((dt = e?.textGroup) == null ? void 0 : dt.h5) !== null && gt.addItem("h5", {
      label: (Mt = (et = (Ue = e?.textGroup) == null ? void 0 : Ue.h5) == null ? void 0 : et.label) != null ? Mt : "Heading 5",
      icon: (Gt = (sn = (Ft = e?.textGroup) == null ? void 0 : Ft.h5) == null ? void 0 : sn.icon) != null ? Gt : Oce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 5
          }
        });
      }
    }), ((_r = e?.textGroup) == null ? void 0 : _r.h6) !== null && gt.addItem("h6", {
      label: (W = (P = (E = e?.textGroup) == null ? void 0 : E.h6) == null ? void 0 : P.label) != null ? W : "Heading 6",
      icon: (Y = (J = (Q = e?.textGroup) == null ? void 0 : Q.h6) == null ? void 0 : J.icon) != null ? Y : Ece,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 6
          }
        });
      }
    }), ((ae = e?.textGroup) == null ? void 0 : ae.quote) !== null && gt.addItem("quote", {
      label: (te = (oe = (re = e?.textGroup) == null ? void 0 : re.quote) == null ? void 0 : oe.label) != null ? te : "Quote",
      icon: (Te = (de = (De = e?.textGroup) == null ? void 0 : De.quote) == null ? void 0 : de.icon) != null ? Te : Pce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = lu.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: mt
        });
      }
    }), ((Pe = e?.textGroup) == null ? void 0 : Pe.divider) !== null && gt.addItem("divider", {
      label: (pe = (X = (F = e?.textGroup) == null ? void 0 : F.divider) == null ? void 0 : X.label) != null ? pe : "Divider",
      icon: (xt = (je = (_e = e?.textGroup) == null ? void 0 : _e.divider) == null ? void 0 : je.icon) != null ? xt : Sce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = au.type(Le);
        Fe.call(Dn.key), Fe.call(mh.key, {
          nodeType: mt
        });
      }
    });
  }
  if (e?.listGroup !== null) {
    const gt = Du.addGroup(
      "list",
      (Yt = (Pt = e?.listGroup) == null ? void 0 : Pt.label) != null ? Yt : "List"
    );
    ((on = e?.listGroup) == null ? void 0 : on.bulletList) !== null && gt.addItem("bullet-list", {
      label: (Vn = (pt = (wt = e?.listGroup) == null ? void 0 : wt.bulletList) == null ? void 0 : pt.label) != null ? Vn : "Bullet List",
      icon: (Rl = (Nl = (En = e?.listGroup) == null ? void 0 : En.bulletList) == null ? void 0 : Nl.icon) != null ? Rl : vce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = za.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: mt
        });
      }
    }), ((Fd = e?.listGroup) == null ? void 0 : Fd.orderedList) !== null && gt.addItem("ordered-list", {
      label: ($d = (Hd = (Ao = e?.listGroup) == null ? void 0 : Ao.orderedList) == null ? void 0 : Hd.label) != null ? $d : "Ordered List",
      icon: (Vd = (_s = (ln = e?.listGroup) == null ? void 0 : ln.orderedList) == null ? void 0 : _s.icon) != null ? Vd : Rce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Fa.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: mt
        });
      }
    }), ((vu = e?.listGroup) == null ? void 0 : vu.taskList) !== null && gt.addItem("task-list", {
      label: (xu = (wu = (Wa = e?.listGroup) == null ? void 0 : Wa.taskList) == null ? void 0 : wu.label) != null ? xu : "Task List",
      icon: (Ls = (Lr = (qd = e?.listGroup) == null ? void 0 : qd.taskList) == null ? void 0 : Lr.icon) != null ? Ls : zce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = ji.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: mt,
          attrs: { checked: !1 }
        });
      }
    });
  }
  if (e?.advancedGroup !== null) {
    const gt = Du.addGroup(
      "advanced",
      (Su = (ku = e?.advancedGroup) == null ? void 0 : ku.label) != null ? Su : "Advanced"
    );
    ((ja = e?.advancedGroup) == null ? void 0 : ja.image) !== null && ER && gt.addItem("image", {
      label: (Mu = (ni = (Cu = e?.advancedGroup) == null ? void 0 : Cu.image) == null ? void 0 : ni.label) != null ? Mu : "Image",
      icon: (Ou = (Au = (Tu = e?.advancedGroup) == null ? void 0 : Tu.image) == null ? void 0 : Au.icon) != null ? Ou : j5,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = J1.type(Le);
        Fe.call(Dn.key), Fe.call(mh.key, {
          nodeType: mt
        });
      }
    }), ((Wd = e?.advancedGroup) == null ? void 0 : Wd.codeBlock) !== null && gt.addItem("code", {
      label: (le = (L = (Re = e?.advancedGroup) == null ? void 0 : Re.codeBlock) == null ? void 0 : L.label) != null ? le : "Code",
      icon: (bn = (Tt = (Oe = e?.advancedGroup) == null ? void 0 : Oe.codeBlock) == null ? void 0 : Tt.icon) != null ? bn : oR,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Cs.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt
        });
      }
    }), ((tn = e?.advancedGroup) == null ? void 0 : tn.table) !== null && IR && gt.addItem("table", {
      label: (Oo = (ri = (In = e?.advancedGroup) == null ? void 0 : In.table) == null ? void 0 : ri.label) != null ? Oo : "Table",
      icon: (Eu = (vn = (Ua = e?.advancedGroup) == null ? void 0 : Ua.table) == null ? void 0 : vn.icon) != null ? Eu : Lce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Le.get(St);
        Fe.call(Dn.key);
        const { from: DR } = mt.state.selection;
        Fe.call(mh.key, {
          nodeType: Dv(Le, 3, 3)
        }), Fe.call(BO.key, {
          pos: DR
        });
      }
    }), ((Iu = e?.advancedGroup) == null ? void 0 : Iu.math) !== null && OR && gt.addItem("math", {
      label: (W7 = (q7 = (V7 = e?.advancedGroup) == null ? void 0 : V7.math) == null ? void 0 : q7.label) != null ? W7 : "Math",
      icon: (K7 = (U7 = (j7 = e?.advancedGroup) == null ? void 0 : j7.math) == null ? void 0 : U7.icon) != null ? K7 : cR,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Cs.type(Le);
        Fe.call(Dn.key), Fe.call(mh.key, {
          nodeType: mt,
          attrs: { language: "LaTex" }
        });
      }
    });
  }
  (G7 = e?.buildMenu) == null || G7.call(e, Du);
  let Nu = Du.build();
  n && (Nu = Nu.map((gt) => {
    const Le = gt.items.filter(
      (Fe) => Fe.label.toLowerCase().includes(n.toLowerCase())
    );
    return {
      ...gt,
      items: Le
    };
  }).filter((gt) => gt.items.length > 0));
  const Y7 = Nu.flatMap((gt) => gt.items);
  return Y7.forEach((gt, Le) => {
    Object.assign(gt, { index: Le });
  }), Nu.reduce((gt, Le) => {
    const Fe = gt + Le.items.length;
    return Object.assign(Le, {
      range: [gt, Fe]
    }), Fe;
  }, 0), {
    groups: Nu,
    size: Y7.length
  };
}
const jce = /* @__PURE__ */ $n({
  props: {
    ctx: {
      type: Object,
      required: !0
    },
    show: {
      type: Object,
      required: !0
    },
    filter: {
      type: Object,
      required: !0
    },
    hide: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !1
    }
  },
  setup({ ctx: n, show: e, filter: t, hide: r, config: i }) {
    const s = Ae(), o = Ra(() => Wce(t.value, i, n)), l = Ae(0), a = Ae({ x: -999, y: -999 }), c = (m) => {
      const { x: g, y: b } = m;
      a.value = { x: g, y: b };
    };
    Ac([o, e], () => {
      const { size: m } = o.value;
      m === 0 && e.value ? r() : l.value >= m && (l.value = 0);
    });
    const u = (m, g) => {
      const b = l.value, w = typeof m == "function" ? m(b) : m;
      g?.(w), l.value = w;
    }, h = (m) => {
      var g, b;
      const w = (g = s.value) == null ? void 0 : g.querySelector(
        `[data-index="${m}"]`
      ), k = (b = s.value) == null ? void 0 : b.querySelector(".menu-groups");
      !w || !k || (k.scrollTop = w.offsetTop - k.offsetTop);
    }, f = (m) => {
      const g = o.value.groups.flatMap((b) => b.items).at(m);
      g && n && g.onRun(n), r();
    }, d = (m) => {
      const { size: g, groups: b } = o.value;
      if (m.key === "Escape") {
        m.preventDefault(), r?.();
        return;
      }
      if (m.key === "ArrowDown")
        return m.preventDefault(), u(
          (w) => w < g - 1 ? w + 1 : w,
          h
        );
      if (m.key === "ArrowUp")
        return m.preventDefault(), u(
          (w) => w <= 0 ? w : w - 1,
          h
        );
      if (m.key === "ArrowLeft")
        return m.preventDefault(), u((w) => {
          const k = b.find(
            (M) => M.range[0] <= w && M.range[1] > w
          );
          if (!k) return w;
          const C = b[b.indexOf(k) - 1];
          return C ? C.range[1] - 1 : w;
        }, h);
      if (m.key === "ArrowRight")
        return m.preventDefault(), u((w) => {
          const k = b.find(
            (M) => M.range[0] <= w && M.range[1] > w
          );
          if (!k) return w;
          const C = b[b.indexOf(k) + 1];
          return C ? C.range[0] : w;
        }, h);
      m.key === "Enter" && (m.preventDefault(), f(l.value));
    }, p = (m) => (g) => {
      const b = a.value;
      if (!b) return;
      const { x: w, y: k } = g;
      w === b.x && k === b.y || u(m);
    };
    return uu(() => {
      e.value ? window.addEventListener("keydown", d, { capture: !0 }) : window.removeEventListener("keydown", d, { capture: !0 });
    }), Sd(() => {
      window.removeEventListener("keydown", d, { capture: !0 });
    }), () => /* @__PURE__ */ j("div", { ref: s, onPointerdown: (m) => m.preventDefault() }, /* @__PURE__ */ j("nav", { class: "tab-group" }, /* @__PURE__ */ j("ul", null, o.value.groups.map((m) => /* @__PURE__ */ j(
      "li",
      {
        key: m.key,
        onPointerdown: () => u(m.range[0], h),
        class: l.value >= m.range[0] && l.value < m.range[1] ? "selected" : ""
      },
      m.label
    )))), /* @__PURE__ */ j("div", { class: "menu-groups", onPointermove: c }, o.value.groups.map((m) => /* @__PURE__ */ j("div", { key: m.key, class: "menu-group" }, /* @__PURE__ */ j("h6", null, m.label), /* @__PURE__ */ j("ul", null, m.items.map((g) => /* @__PURE__ */ j(
      "li",
      {
        key: g.key,
        "data-index": g.index,
        class: l.value === g.index ? "hover" : "",
        onPointerenter: p(g.index),
        onPointerdown: () => {
          var b, w;
          (w = (b = s.value) == null ? void 0 : b.querySelector(`[data-index="${g.index}"]`)) == null || w.classList.add("active");
        },
        onPointerup: () => {
          var b, w;
          (w = (b = s.value) == null ? void 0 : b.querySelector(`[data-index="${g.index}"]`)) == null || w.classList.remove("active"), f(g.index);
        }
      },
      /* @__PURE__ */ j(jc, { icon: g.icon }),
      /* @__PURE__ */ j("span", null, g.label)
    )))))));
  }
});
var gR = (n) => {
  throw TypeError(n);
}, yR = (n, e, t) => e.has(n) || gR("Cannot " + t), Ti = (n, e, t) => (yR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Ju = (n, e, t) => e.has(n) ? gR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), ql = (n, e, t, r) => (yR(n, e, "write to private field"), e.set(n, t), t), Ah, Vp, qp, js, fc;
const bR = lZ("CREPE_MENU"), $7 = Ct(
  {
    show: () => {
    },
    hide: () => {
    }
  },
  "menuAPICtx"
);
function Uce(n, e) {
  n.set(bR.key, {
    view: (t) => new Kce(n, t, e)
  });
}
class Kce {
  constructor(e, t, r) {
    Ju(this, Ah), Ju(this, Vp), Ju(this, qp), Ju(this, js), Ju(this, fc, null), this.update = (u) => {
      Ti(this, js).update(u);
    }, this.show = (u) => {
      ql(this, fc, u), Ti(this, qp).value = "", Ti(this, js).show();
    }, this.hide = () => {
      ql(this, fc, null), Ti(this, js).hide();
    }, this.destroy = () => {
      Ti(this, js).destroy(), Ti(this, Vp).unmount(), Ti(this, Ah).remove();
    };
    const i = document.createElement("div");
    i.classList.add("milkdown-slash-menu");
    const s = Ae(!1), o = Ae("");
    ql(this, qp, o);
    const l = this.hide, a = Ui(jce, {
      ctx: e,
      config: r,
      show: s,
      filter: o,
      hide: l
    });
    ql(this, Vp, a), a.mount(i), ql(this, Ah, i);
    const c = this;
    ql(this, js, new aZ({
      content: Ti(this, Ah),
      debounce: 20,
      shouldShow(u) {
        if (hR(u.state.selection) || fR(u.state.selection))
          return !1;
        const h = this.getContent(
          u,
          (d) => ["paragraph", "heading"].includes(d.type.name)
        );
        if (h == null || !Gce(u.state.selection))
          return !1;
        const f = Ti(c, fc);
        if (o.value = h.startsWith("/") ? h.slice(1) : h, typeof f == "number") {
          const d = u.state.doc.nodeSize - 2, p = Math.min(f, d);
          return u.state.doc.resolve(p).node() !== u.state.doc.resolve(u.state.selection.from).node() ? (ql(c, fc, null), !1) : !0;
        }
        return !!h.startsWith("/");
      },
      offset: 10
    })), Ti(this, js).onShow = () => {
      s.value = !0;
    }, Ti(this, js).onHide = () => {
      s.value = !1;
    }, this.update(t), e.set($7.key, {
      show: (u) => this.show(u),
      hide: () => this.hide()
    });
  }
}
Ah = /* @__PURE__ */ new WeakMap();
Vp = /* @__PURE__ */ new WeakMap();
qp = /* @__PURE__ */ new WeakMap();
js = /* @__PURE__ */ new WeakMap();
fc = /* @__PURE__ */ new WeakMap();
function Gce(n) {
  if (!(n instanceof Ee)) return !1;
  const { $head: e } = n, t = e.parent;
  return e.parentOffset === t.content.size;
}
const Yce = /* @__PURE__ */ $n({
  props: {
    onAdd: {
      type: Function,
      required: !0
    },
    addIcon: {
      type: String,
      required: !0
    },
    handleIcon: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = Ae();
    return () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j(
      "div",
      {
        ref: e,
        class: "operation-item",
        onPointerdown: (t) => {
          var r;
          t.preventDefault(), t.stopPropagation(), (r = e.value) == null || r.classList.add("active");
        },
        onPointerup: (t) => {
          var r;
          t.preventDefault(), t.stopPropagation(), (r = e.value) == null || r.classList.remove("active"), n.onAdd();
        }
      },
      /* @__PURE__ */ j(jc, { icon: n.addIcon })
    ), /* @__PURE__ */ j("div", { class: "operation-item" }, /* @__PURE__ */ j(jc, { icon: n.handleIcon })));
  }
});
var vR = (n) => {
  throw TypeError(n);
}, wR = (n, e, t) => e.has(n) || vR("Cannot " + t), Wl = (n, e, t) => (wR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), H0 = (n, e, t) => e.has(n) ? vR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), $0 = (n, e, t, r) => (wR(n, e, "write to private field"), e.set(n, t), t), Wp, Yl, jp, Up;
class Jce {
  constructor(e, t) {
    H0(this, Wp), H0(this, Yl), H0(this, jp), H0(this, Up), this.update = () => {
      Wl(this, Yl).update();
    }, this.destroy = () => {
      Wl(this, Yl).destroy(), Wl(this, Wp).remove(), Wl(this, jp).unmount();
    }, this.onAdd = () => {
      const c = Wl(this, Up), u = c.get(St);
      u.hasFocus() || u.focus();
      const { state: h, dispatch: f } = u, d = Wl(this, Yl).active;
      if (!d) return;
      const m = d.$pos.pos + d.node.nodeSize;
      let g = h.tr.insert(m, Os.type(c).create());
      g = g.setSelection(Ee.near(g.doc.resolve(m))), f(g.scrollIntoView()), Wl(this, Yl).hide(), c.get($7.key).show(g.selection.from);
    };
    var r, i, s;
    $0(this, Up, e);
    const o = document.createElement("div");
    o.classList.add("milkdown-block-handle");
    const l = Ui(Yce, {
      onAdd: this.onAdd,
      addIcon: (r = t?.handleAddIcon) != null ? r : U5,
      handleIcon: (i = t?.handleDragIcon) != null ? i : Nce
    });
    l.mount(o), $0(this, jp, l), $0(this, Wp, o);
    const a = (s = t?.blockHandle) != null ? s : {};
    $0(this, Yl, new oY({
      ctx: e,
      content: o,
      getOffset: () => 16,
      getPlacement: ({ active: c, blockDom: u }) => {
        if (c.node.type.name === "heading") return "left";
        let h = 0;
        c.node.descendants((C) => {
          h += C.childCount;
        });
        const f = c.el, d = f.getBoundingClientRect(), p = u.getBoundingClientRect(), m = window.getComputedStyle(f), g = Number.parseInt(m.paddingTop, 10) || 0, b = Number.parseInt(m.paddingBottom, 10) || 0, w = d.height - g - b, k = p.height;
        return h > 2 || k < w ? "left-start" : "left";
      },
      ...a
    })), this.update();
  }
}
Wp = /* @__PURE__ */ new WeakMap();
Yl = /* @__PURE__ */ new WeakMap();
jp = /* @__PURE__ */ new WeakMap();
Up = /* @__PURE__ */ new WeakMap();
function Xce(n, e) {
  n.set(R1.key, {
    filterNodes: (t) => !bs(
      (i) => ["table", "blockquote", "math_inline"].includes(i.type.name)
    )(t)
  }), n.set(L1.key, {
    view: () => new Jce(n, e)
  });
}
const Zce = (n, e) => {
  n.config(Ps(kt.BlockEdit)).config((t) => Xce(t, e)).config((t) => Uce(t, e)).use($7).use(L1).use(bR);
}, Qce = (n, e = {}) => {
  n.config(Ps(kt.CodeMirror)).config((t) => {
    const { languages: r = [], theme: i } = e, s = [
      nu.of(iD.concat(ire)),
      dse
    ];
    i && s.push(i), e.extensions && s.push(...e.extensions), t.update(Nd.key, (o) => ({
      extensions: s,
      languages: r,
      expandIcon: e.expandIcon || iR,
      searchIcon: e.searchIcon || aR,
      clearSearchIcon: e.clearSearchIcon || sR,
      searchPlaceholder: e.searchPlaceholder || "Search language",
      copyText: e.copyText || "Copy",
      copyIcon: e.copyIcon || lR,
      onCopy: e.onCopy || (() => {
      }),
      noResultText: e.noResultText || "No result",
      renderLanguage: e.renderLanguage || o.renderLanguage,
      renderPreview: e.renderPreview || o.renderPreview,
      previewToggleButton: (l) => {
        var a, c;
        const u = ((a = e.previewToggleIcon) == null ? void 0 : a.call(e, l)) || (l ? H7 : uR), h = ((c = e.previewToggleText) == null ? void 0 : c.call(e, l)) || (l ? "Edit" : "Hide");
        return [u, h].map((f) => f.trim()).join(" ");
      },
      previewLabel: e.previewLabel || o.previewLabel
    }));
  }).use(Ore);
}, eue = (n, e) => {
  if (n.config(Ps(kt.Cursor)).config((r) => {
    r.update(lg.key, () => {
      var i, s;
      return {
        class: "crepe-drop-cursor",
        width: (i = e?.width) != null ? i : 4,
        color: (s = e?.color) != null ? s : !1
      };
    });
  }).use(Sse), e?.virtual === !1)
    return;
  const t = Cse();
  n.use(kn(() => t));
}, tue = (n, e) => {
  n.config(Ps(kt.ImageBlock)).config((t) => {
    t.update(ag.key, (r) => {
      var i, s, o, l, a, c;
      return {
        uploadButton: (i = e?.inlineUploadButton) != null ? i : "Upload",
        imageIcon: (s = e?.inlineImageIcon) != null ? s : j5,
        confirmButton: (o = e?.inlineConfirmButton) != null ? o : F7,
        uploadPlaceholderText: (l = e?.inlineUploadPlaceholderText) != null ? l : "or paste link",
        onUpload: (c = (a = e?.inlineOnUpload) != null ? a : e?.onUpload) != null ? c : r.onUpload,
        proxyDomURL: e?.proxyDomURL
      };
    }), t.update(Y1.key, (r) => {
      var i, s, o, l, a, c, u, h;
      return {
        uploadButton: (i = e?.blockUploadButton) != null ? i : "Upload file",
        imageIcon: (s = e?.blockImageIcon) != null ? s : j5,
        captionIcon: (o = e?.blockCaptionIcon) != null ? o : wce,
        confirmButton: (l = e?.blockConfirmButton) != null ? l : "Confirm",
        captionPlaceholderText: (a = e?.blockCaptionPlaceholderText) != null ? a : "Write Image Caption",
        uploadPlaceholderText: (c = e?.blockUploadPlaceholderText) != null ? c : "or paste link",
        onUpload: (h = (u = e?.blockOnUpload) != null ? u : e?.onUpload) != null ? h : r.onUpload,
        proxyDomURL: e?.proxyDomURL
      };
    });
  }).use(JZ).use(zse);
}, nue = Cs.extendSchema((n) => (e) => {
  const t = n(e);
  return {
    ...t,
    toMarkdown: {
      match: t.toMarkdown.match,
      runner: (r, i) => {
        var s, o;
        if (((s = i.attrs.language) != null ? s : "").toLowerCase() === "latex")
          r.addNode(
            "math",
            void 0,
            ((o = i.content.firstChild) == null ? void 0 : o.text) || ""
          );
        else
          return t.toMarkdown.runner(r, i);
      }
    }
  };
}), Oh = "math_inline", id = hn(Oh, () => ({
  group: "inline",
  inline: !0,
  draggable: !0,
  atom: !0,
  attrs: {
    value: {
      default: ""
    }
  },
  parseDOM: [
    {
      tag: `span[data-type="${Oh}"]`,
      getAttrs: (n) => {
        var e;
        return {
          value: (e = n.dataset.value) != null ? e : ""
        };
      }
    }
  ],
  toDOM: (n) => {
    const e = n.attrs.value, t = document.createElement("span");
    return t.dataset.type = Oh, t.dataset.value = e, RN.render(e, t, {
      throwOnError: !1
    }), t;
  },
  parseMarkdown: {
    match: (n) => n.type === "inlineMath",
    runner: (n, e, t) => {
      n.addNode(t, { value: e.value });
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === Oh,
    runner: (n, e) => {
      n.addNode("inlineMath", void 0, e.attrs.value);
    }
  }
})), xR = Ye("ToggleLatex", (n) => () => (e, t) => {
  const {
    hasNode: r,
    pos: i,
    target: s
  } = ST(e, id.type(n)), { selection: o, doc: l, tr: a } = e;
  if (!r) {
    const d = l.textBetween(o.from, o.to);
    let p = a.replaceSelectionWith(
      id.type(n).create({
        value: d
      })
    );
    return t && t(
      p.setSelection($e.create(p.doc, o.from))
    ), !0;
  }
  const { from: c, to: u } = o;
  if (!s || i < 0) return !1;
  let h = a.delete(i, i + 1);
  const f = s.attrs.value;
  return h = h.insertText(f, i), t && t(
    h.setSelection(
      Ee.create(h.doc, c, u + f.length - 1)
    )
  ), !0;
}), lS = yg("INLINE_LATEX"), rue = /* @__PURE__ */ $n({
  props: {
    config: {
      type: Object,
      required: !0
    },
    innerView: {
      type: Object,
      required: !0
    },
    updateValue: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = (r) => {
      if (!(!r || !(r instanceof HTMLElement))) {
        for (; r.firstChild; )
          r.removeChild(r.firstChild);
        n.innerView.value && r.appendChild(n.innerView.value.dom);
      }
    }, t = (r) => {
      r.preventDefault(), n.updateValue.value();
    };
    return () => /* @__PURE__ */ j("div", { class: "container" }, n.innerView && /* @__PURE__ */ j("div", { ref: e }), /* @__PURE__ */ j("button", { onPointerdown: t }, /* @__PURE__ */ j(jc, { icon: n.config.inlineEditConfirm })));
  }
});
var kR = (n) => {
  throw TypeError(n);
}, SR = (n, e, t) => e.has(n) || kR("Cannot " + t), Sn = (n, e, t) => (SR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Ro = (n, e, t) => e.has(n) ? kR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), V0 = (n, e, t, r) => (SR(n, e, "write to private field"), e.set(n, t), t), Eh, dc, Kp, Jl, Ih, Dh, G5, Y5;
class iue {
  constructor(e, t, r) {
    this.ctx = e, Ro(this, Eh), Ro(this, dc), Ro(this, Kp), Ro(this, Jl, Om(null)), Ro(this, Ih, Om(() => {
    })), Ro(this, Dh), Ro(this, G5, () => {
      Sn(this, Jl).value && (Sn(this, Jl).value.destroy(), Sn(this, Jl).value = null);
    }), Ro(this, Y5, (s) => {
      const l = (() => {
        const { selection: a, schema: c } = s.state;
        if (a.empty || !(a instanceof $e)) return !1;
        const u = a.node;
        if (u.type.name !== Oh) return !1;
        const h = a.from, f = c.nodes.paragraph.create(
          null,
          c.text(u.attrs.value)
        ), d = new ib(Sn(this, Kp), {
          state: Qo.create({
            doc: f,
            schema: new JM({
              nodes: {
                doc: {
                  content: "block+"
                },
                paragraph: {
                  content: "inline*",
                  group: "block",
                  parseDOM: [{ tag: "p" }],
                  toDOM() {
                    return ["p", 0];
                  }
                },
                text: {
                  group: "inline"
                }
              }
            }),
            plugins: [
              dA({
                "Mod-z": sg,
                "Mod-Z": Uc,
                "Mod-y": Uc,
                Enter: () => (Sn(this, Ih).value(), !0)
              })
            ]
          })
        });
        return Sn(this, Jl).value = d, Sn(this, Ih).value = () => {
          const { tr: p } = s.state;
          p.setNodeAttribute(h, "value", d.state.doc.textContent), s.dispatch(p), requestAnimationFrame(() => {
            s.focus();
          });
        }, !0;
      })();
      return l || Sn(this, G5).call(this), l;
    }), this.update = (s, o) => {
      Sn(this, dc).update(s, o);
    }, this.destroy = () => {
      Sn(this, Dh).unmount(), Sn(this, dc).destroy(), Sn(this, Eh).remove();
    };
    const i = document.createElement("div");
    i.className = "milkdown-latex-inline-edit", V0(this, Eh, i), V0(this, Dh, Ui(rue, {
      config: r,
      innerView: Sn(this, Jl),
      updateValue: Sn(this, Ih)
    })), Sn(this, Dh).mount(i), V0(this, dc, new gg({
      debounce: 0,
      content: Sn(this, Eh),
      shouldShow: Sn(this, Y5),
      offset: 10,
      floatingUIOptions: {
        placement: "bottom"
      }
    })), Sn(this, dc).update(t), V0(this, Kp, document.createElement("div"));
  }
}
Eh = /* @__PURE__ */ new WeakMap();
dc = /* @__PURE__ */ new WeakMap();
Kp = /* @__PURE__ */ new WeakMap();
Jl = /* @__PURE__ */ new WeakMap();
Ih = /* @__PURE__ */ new WeakMap();
Dh = /* @__PURE__ */ new WeakMap();
G5 = /* @__PURE__ */ new WeakMap();
Y5 = /* @__PURE__ */ new WeakMap();
const sue = Qn(
  (n) => lV(/(?:\$)([^$]+)(?:\$)$/, id.type(n), {
    getAttr: (e) => {
      var t;
      return {
        value: (t = e[1]) != null ? t : ""
      };
    }
  })
), oue = Qn(
  (n) => N3(/^\$\$[\s\n]$/, Cs.type(n), () => ({
    language: "LaTeX"
  }))
), lue = As(
  "remarkMath",
  () => Yle
);
function aue(n) {
  return Tl(
    n,
    "math",
    (e, t, r) => {
      const { value: i } = e, s = {
        type: "code",
        lang: "LaTeX",
        value: i
      };
      r.children.splice(t, 1, s);
    }
  );
}
const cue = As(
  "remarkMathBlock",
  () => () => aue
), uue = (n, e) => {
  n.config(Ps(kt.Latex)).config((t) => {
    if (!Sg(t).get().includes(kt.CodeMirror))
      throw new Error("You need to enable CodeMirror to use LaTeX feature");
    t.update(Nd.key, (s) => ({
      ...s,
      renderPreview: (o, l) => {
        if (o.toLowerCase() === "latex" && l.length > 0)
          return hue(l, e?.katexOptions);
        const a = s.renderPreview;
        return a(o, l);
      }
    })), t.set(lS.key, {
      view: (s) => {
        var o;
        return new iue(t, s, {
          inlineEditConfirm: (o = e?.inlineEditConfirm) != null ? o : F7,
          ...e
        });
      }
    });
  }).use(lue).use(cue).use(id).use(lS).use(sue).use(oue).use(nue).use(xR);
};
function hue(n, e) {
  return RN.renderToString(n, {
    ...e,
    throwOnError: !1,
    displayMode: !0
  });
}
const fue = (n, e) => {
  n.config(Ps(kt.LinkTooltip)).config(Tae).config((t) => {
    t.update(Xc.key, (r) => {
      var i, s, o, l, a, c;
      return {
        ...r,
        linkIcon: (i = e?.linkIcon) != null ? i : lR,
        editButton: (s = e?.editButton) != null ? s : H7,
        removeButton: (o = e?.removeButton) != null ? o : K5,
        confirmButton: (l = e?.confirmButton) != null ? l : F7,
        inputPlaceholder: (a = e?.inputPlaceholder) != null ? a : "Paste link...",
        onCopyLink: (c = e?.onCopyLink) != null ? c : (() => {
        })
      };
    });
  }).use(Aae);
};
function due(n, e) {
  n.set(vg.key, {
    renderLabel: ({ label: t, listType: r, checked: i }) => {
      var s, o, l;
      return i == null ? r === "bullet" ? (s = e?.bulletIcon) != null ? s : bce : t : i ? (o = e?.checkBoxCheckedIcon) != null ? o : xce : (l = e?.checkBoxUncheckedIcon) != null ? l : kce;
    }
  });
}
const pue = (n, e) => {
  n.config(Ps(kt.ListItem)).config((t) => due(t, e)).use(Pae);
};
function mue(n) {
  var e;
  return n.childCount <= 1 && !((e = n.firstChild) != null && e.content.size);
}
function gue(n, e) {
  const { selection: t } = n;
  if (!t.empty) return null;
  const r = t.$anchor, i = r.parent;
  if (i.content.size > 0 || bs((l) => l.type.name === "table")(r)) return null;
  const o = r.before();
  return mn.node(o, o + i.nodeSize, {
    class: "crepe-placeholder",
    "data-placeholder": e
  });
}
const J5 = Ct(
  {
    text: "Please enter...",
    mode: "block"
  },
  "placeholderConfigCtx"
), yue = kn((n) => new Ut({
  key: new en("CREPE_PLACEHOLDER"),
  props: {
    decorations: (e) => {
      var t;
      if (Vce(n).readonly) return null;
      const i = n.get(J5.key);
      if (i.mode === "doc" && !mue(e.doc) || hR(e.selection) || fR(e.selection))
        return null;
      const s = (t = i.text) != null ? t : "Please enter...", o = gue(e, s);
      return o ? Et.create(e.doc, [o]) : null;
    }
  }
})), bue = (n, e) => {
  n.config(Ps(kt.Placeholder)).config((t) => {
    e && t.update(J5.key, (r) => ({
      ...r,
      ...e
    }));
  }).use(yue).use(J5);
}, vue = (n, e) => {
  n.config(Ps(kt.Table)).config((t) => {
    t.update(wg.key, (r) => ({
      ...r,
      renderButton: (i) => {
        var s, o, l, a, c, u, h, f, d;
        switch (i) {
          case "add_row":
            return (s = e?.addRowIcon) != null ? s : U5;
          case "add_col":
            return (o = e?.addColIcon) != null ? o : U5;
          case "delete_row":
            return (l = e?.deleteRowIcon) != null ? l : K5;
          case "delete_col":
            return (a = e?.deleteColIcon) != null ? a : K5;
          case "align_col_left":
            return (c = e?.alignLeftIcon) != null ? c : mce;
          case "align_col_center":
            return (u = e?.alignCenterIcon) != null ? u : pce;
          case "align_col_right":
            return (h = e?.alignRightIcon) != null ? h : gce;
          case "col_drag_handle":
            return (f = e?.colDragHandleIcon) != null ? f : sS;
          case "row_drag_handle":
            return (d = e?.rowDragHandleIcon) != null ? d : sS;
        }
      }
    }));
  }).use(lce);
};
function wue(n, e) {
  var t, r, i, s, o, l, a;
  const c = new mR();
  c.addGroup("formatting", "Formatting").addItem("bold", {
    icon: (t = n?.boldIcon) != null ? t : yce,
    active: (d) => d.get(Me).call(ic.key, ou.type(d)),
    onRun: (d) => {
      d.get(Me).call(z1.key);
    }
  }).addItem("italic", {
    icon: (r = n?.italicIcon) != null ? r : Ice,
    active: (d) => d.get(Me).call(
      ic.key,
      La.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(B1.key);
    }
  }).addItem("strikethrough", {
    icon: (i = n?.strikethroughIcon) != null ? i : _ce,
    active: (d) => d.get(Me).call(
      ic.key,
      hu.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(Z1.key);
    }
  });
  const u = c.addGroup("function", "Function");
  u.addItem("code", {
    icon: (s = n?.codeIcon) != null ? s : oR,
    active: (d) => d.get(Me).call(
      ic.key,
      eo.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(F1.key);
    }
  });
  const h = e && Sg(e).get();
  return h?.includes(kt.Latex) && u.addItem("latex", {
    icon: (o = n?.latexIcon) != null ? o : cR,
    active: (d) => d.get(Me).call(
      LO.key,
      id.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(xR.key);
    }
  }), u.addItem("link", {
    icon: (l = n?.linkIcon) != null ? l : Dce,
    active: (d) => d.get(Me).call(ic.key, Pi.type(d)),
    onRun: (d) => {
      d.get(Me).call(PN.key);
    }
  }), (a = n?.buildToolbar) == null || a.call(n, c), c.build();
}
const xue = /* @__PURE__ */ $n({
  props: {
    ctx: {
      type: Object,
      required: !0
    },
    hide: {
      type: Function,
      required: !0
    },
    show: {
      type: Object,
      required: !0
    },
    selection: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !1
    }
  },
  setup(n) {
    const { ctx: e, config: t } = n, r = (o) => (l) => {
      l.preventDefault(), e && o(e);
    };
    function i(o) {
      return n.selection.value, e.get(Xy).status !== km.Created ? !1 : o(e);
    }
    const s = Ra(() => wue(t, e));
    return () => /* @__PURE__ */ j(Ln, null, s.value.map((o) => o.items.map((l) => /* @__PURE__ */ j(
      "button",
      {
        type: "button",
        class: Hn(
          "toolbar-item",
          e && i(l.active) && "active"
        ),
        onPointerdown: r(l.onRun)
      },
      /* @__PURE__ */ j(jc, { icon: l.icon })
    ))).reduce((o, l, a) => (a === 0 ? o.push(...l) : o.push(/* @__PURE__ */ j("div", { class: "divider" }), ...l), o), []));
  }
});
var CR = (n) => {
  throw TypeError(n);
}, MR = (n, e, t) => e.has(n) || CR("Cannot " + t), Fr = (n, e, t) => (MR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Xu = (n, e, t) => e.has(n) ? CR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), q0 = (n, e, t, r) => (MR(n, e, "write to private field"), e.set(n, t), t), Bo, Nh, Gp, Rh, Ph;
const aS = yg("CREPE_TOOLBAR");
class kue {
  constructor(e, t, r) {
    Xu(this, Bo), Xu(this, Nh), Xu(this, Gp), Xu(this, Rh), Xu(this, Ph, Ae(!1)), this.update = (o, l) => {
      Fr(this, Bo).update(o, l), Fr(this, Rh).value = o.state.selection;
    }, this.destroy = () => {
      Fr(this, Bo).destroy(), Fr(this, Gp).unmount(), Fr(this, Nh).remove();
    }, this.hide = () => {
      Fr(this, Bo).hide();
    };
    const i = document.createElement("div");
    i.className = "milkdown-toolbar", q0(this, Rh, Om(t.state.selection));
    const s = Ui(xue, {
      ctx: e,
      hide: this.hide,
      config: r,
      selection: Fr(this, Rh),
      show: Fr(this, Ph)
    });
    s.mount(i), q0(this, Nh, i), q0(this, Gp, s), q0(this, Bo, new gg({
      content: Fr(this, Nh),
      debounce: 20,
      offset: 10,
      shouldShow(o) {
        const { doc: l, selection: a } = o.state, { empty: c, from: u, to: h } = a, f = !l.textBetween(u, h).length && a instanceof Ee, d = !(a instanceof Ee), p = o.dom.getRootNode().activeElement, m = i.contains(p), g = !o.hasFocus() && !m, b = !o.editable;
        return !(g || d || c || f || b);
      }
    })), Fr(this, Bo).onShow = () => {
      Fr(this, Ph).value = !0;
    }, Fr(this, Bo).onHide = () => {
      Fr(this, Ph).value = !1;
    }, this.update(t);
  }
}
Bo = /* @__PURE__ */ new WeakMap();
Nh = /* @__PURE__ */ new WeakMap();
Gp = /* @__PURE__ */ new WeakMap();
Rh = /* @__PURE__ */ new WeakMap();
Ph = /* @__PURE__ */ new WeakMap();
const Sue = (n, e) => {
  n.config(Ps(kt.Toolbar)).config((t) => {
    t.set(aS.key, {
      view: (r) => new kue(t, r, e)
    });
  }).use(aS);
};
function Cue(n, e, t) {
  switch (n) {
    case kt.CodeMirror:
      return Qce(e, t);
    case kt.ListItem:
      return pue(e, t);
    case kt.LinkTooltip:
      return fue(e, t);
    case kt.ImageBlock:
      return tue(e, t);
    case kt.Cursor:
      return eue(e, t);
    case kt.BlockEdit:
      return Zce(e, t);
    case kt.Placeholder:
      return bue(e, t);
    case kt.Toolbar:
      return Sue(e, t);
    case kt.Table:
      return vue(e, t);
    case kt.Latex:
      return uue(e, t);
  }
}
var TR = (n) => {
  throw TypeError(n);
}, AR = (n, e, t) => e.has(n) || TR("Cannot " + t), Hr = (n, e, t) => (AR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), v4 = (n, e, t) => e.has(n) ? TR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), w4 = (n, e, t, r) => (AR(n, e, "write to private field"), e.set(n, t), t), $r, Yp, _h;
class Mue {
  /// The constructor of the crepe builder.
  /// You can pass configs to the builder to configure the editor.
  constructor({ root: e, defaultValue: t = "" } = {}) {
    v4(this, $r), v4(this, Yp), v4(this, _h, !0), this.addFeature = (i, s) => (i(Hr(this, $r), s), this), this.create = () => Hr(this, $r).create(), this.destroy = () => Hr(this, $r).destroy(), this.setReadonly = (i) => (w4(this, _h, !i), Hr(this, $r).action((s) => {
      Hr(this, $r).status === km.Created && s.get(St).setProps({
        editable: () => !i
      });
    }), this), this.getMarkdown = () => Hr(this, $r).action(dG()), this.on = (i) => Hr(this, $r).status !== km.Created ? (Hr(this, $r).config((s) => {
      const o = s.get(Jm);
      i(o);
    }), this) : (Hr(this, $r).action((s) => {
      const o = s.get(Jm);
      i(o);
    }), this);
    var r;
    w4(this, Yp, (r = typeof e == "string" ? document.querySelector(e) : e) != null ? r : document.body), w4(this, $r, sb.make().config((i) => {
      i.inject($ce, this), i.inject(Hce, []);
    }).config((i) => {
      i.set(wp, Hr(this, Yp)), i.set(gp, t), i.set(tf, {
        editable: () => Hr(this, _h)
      }), i.update(kg.key, (s) => ({
        ...s,
        size: 4
      }));
    }).use(DY).use(nR).use(ace).use(uce).use(fce).use(ZN).use(Gte));
  }
  /// Get the milkdown editor instance.
  get editor() {
    return Hr(this, $r);
  }
  /// Get the readonly state of the editor.
  get readonly() {
    return !Hr(this, _h);
  }
}
$r = /* @__PURE__ */ new WeakMap();
Yp = /* @__PURE__ */ new WeakMap();
_h = /* @__PURE__ */ new WeakMap();
class X5 extends Mue {
  /// The constructor of the crepe editor.
  /// You can pass configs to the editor to configure the editor.
  /// Calling the constructor will not create the editor, you need to call `create` to create the editor.
  constructor({
    features: e = {},
    featureConfigs: t = {},
    ...r
  } = {}) {
    super(r);
    const i = gL(t, Fce);
    Object.entries({
      ...dce,
      ...e
    }).filter(([, o]) => o).map(([o]) => o).forEach((o) => {
      const l = i[o];
      Cue(o, this.editor, l);
    });
  }
}
X5.Feature = kt;
const Tue = (n, e, t = null) => {
  const r = t ?? {
    [X5.Feature.BlockEdit]: !1
  };
  return new X5({
    root: n,
    defaultValue: e,
    features: r
  });
}, Aue = async (n, e = () => {
}) => {
  await n.create(), n.on((t) => {
    t.updated(e);
  });
}, Oue = async (n) => {
  await n.destroy();
}, Eue = (n) => n.getMarkdown(), Iue = (n, e) => {
  n.editor.action(pG(e));
}, Due = (n, e) => {
  n.editor.action(mG(e));
}, Xue = {
  createEditor: Tue,
  create: Aue,
  destroy: Oue,
  getMarkdown: Eue,
  insertMarkdown: Iue,
  replaceMarkdown: Due
};
export {
  ea as A,
  jt as B,
  bD as C,
  q as D,
  Ce as E,
  fy as F,
  kH as G,
  bL as H,
  Zt as I,
  zF as J,
  Xue as K,
  $F as L,
  Rue as N,
  NS as P,
  si as T,
  hy as a,
  Yue as b,
  Wue as c,
  iie as d,
  Fn as e,
  ZF as f,
  Vue as g,
  que as h,
  dM as i,
  jue as j,
  Jue as k,
  G as l,
  Qr as m,
  st as n,
  r3 as o,
  _ue as p,
  Bt as q,
  XF as r,
  RF as s,
  U as t,
  kl as u,
  nu as v,
  ci as w,
  hM as x,
  tu as y,
  l1 as z
};
