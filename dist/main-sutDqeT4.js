var aS = typeof global == "object" && global && global.Object === Object && global, DR = typeof self == "object" && self && self.Object === Object && self, Ra = aS || DR || Function("return this")(), Yp = Ra.Symbol, cS = Object.prototype, NR = cS.hasOwnProperty, RR = cS.toString, Nu = Yp ? Yp.toStringTag : void 0;
function PR(n) {
  var e = NR.call(n, Nu), t = n[Nu];
  try {
    n[Nu] = void 0;
    var r = !0;
  } catch {
  }
  var i = RR.call(n);
  return r && (e ? n[Nu] = t : delete n[Nu]), i;
}
var _R = Object.prototype, LR = _R.toString;
function BR(n) {
  return LR.call(n);
}
var zR = "[object Null]", FR = "[object Undefined]", Y7 = Yp ? Yp.toStringTag : void 0;
function sd(n) {
  return n == null ? n === void 0 ? FR : zR : Y7 && Y7 in Object(n) ? PR(n) : BR(n);
}
function Xc(n) {
  return n != null && typeof n == "object";
}
var HR = "[object Symbol]";
function $R(n) {
  return typeof n == "symbol" || Xc(n) && sd(n) == HR;
}
var x4 = Array.isArray, VR = /\s/;
function qR(n) {
  for (var e = n.length; e-- && VR.test(n.charAt(e)); )
    ;
  return e;
}
var WR = /^\s+/;
function jR(n) {
  return n && n.slice(0, qR(n) + 1).replace(WR, "");
}
function Zr(n) {
  var e = typeof n;
  return n != null && (e == "object" || e == "function");
}
var J7 = NaN, UR = /^[-+]0x[0-9a-f]+$/i, KR = /^0b[01]+$/i, GR = /^0o[0-7]+$/i, YR = parseInt;
function X7(n) {
  if (typeof n == "number")
    return n;
  if ($R(n))
    return J7;
  if (Zr(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = Zr(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = jR(n);
  var t = KR.test(n);
  return t || GR.test(n) ? YR(n.slice(2), t ? 2 : 8) : UR.test(n) ? J7 : +n;
}
function uS(n) {
  return n;
}
var JR = "[object AsyncFunction]", XR = "[object Function]", ZR = "[object GeneratorFunction]", QR = "[object Proxy]";
function X5(n) {
  if (!Zr(n))
    return !1;
  var e = sd(n);
  return e == XR || e == ZR || e == JR || e == QR;
}
var Sg = Ra["__core-js_shared__"], Z7 = (function() {
  var n = /[^.]+$/.exec(Sg && Sg.keys && Sg.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
})();
function eP(n) {
  return !!Z7 && Z7 in n;
}
var tP = Function.prototype, nP = tP.toString;
function rP(n) {
  if (n != null) {
    try {
      return nP.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var iP = /[\\^$.*+?()[\]{}|]/g, sP = /^\[object .+?Constructor\]$/, oP = Function.prototype, lP = Object.prototype, aP = oP.toString, cP = lP.hasOwnProperty, uP = RegExp(
  "^" + aP.call(cP).replace(iP, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function hP(n) {
  if (!Zr(n) || eP(n))
    return !1;
  var e = X5(n) ? uP : sP;
  return e.test(rP(n));
}
function fP(n, e) {
  return n?.[e];
}
function Z5(n, e) {
  var t = fP(n, e);
  return hP(t) ? t : void 0;
}
var Q7 = Object.create, dP = /* @__PURE__ */ (function() {
  function n() {
  }
  return function(e) {
    if (!Zr(e))
      return {};
    if (Q7)
      return Q7(e);
    n.prototype = e;
    var t = new n();
    return n.prototype = void 0, t;
  };
})();
function hS(n, e, t) {
  switch (t.length) {
    case 0:
      return n.call(e);
    case 1:
      return n.call(e, t[0]);
    case 2:
      return n.call(e, t[0], t[1]);
    case 3:
      return n.call(e, t[0], t[1], t[2]);
  }
  return n.apply(e, t);
}
function pP(n, e) {
  var t = -1, r = n.length;
  for (e || (e = Array(r)); ++t < r; )
    e[t] = n[t];
  return e;
}
var mP = 800, gP = 16, yP = Date.now;
function bP(n) {
  var e = 0, t = 0;
  return function() {
    var r = yP(), i = gP - (r - t);
    if (t = r, i > 0) {
      if (++e >= mP)
        return arguments[0];
    } else
      e = 0;
    return n.apply(void 0, arguments);
  };
}
function vP(n) {
  return function() {
    return n;
  };
}
var Jp = (function() {
  try {
    var n = Z5(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
})(), wP = Jp ? function(n, e) {
  return Jp(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: vP(e),
    writable: !0
  });
} : uS, xP = bP(wP), kP = 9007199254740991, SP = /^(?:0|[1-9]\d*)$/;
function fS(n, e) {
  var t = typeof n;
  return e = e ?? kP, !!e && (t == "number" || t != "symbol" && SP.test(n)) && n > -1 && n % 1 == 0 && n < e;
}
function Q5(n, e, t) {
  e == "__proto__" && Jp ? Jp(n, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : n[e] = t;
}
function Jm(n, e) {
  return n === e || n !== n && e !== e;
}
var CP = Object.prototype, MP = CP.hasOwnProperty;
function TP(n, e, t) {
  var r = n[e];
  (!(MP.call(n, e) && Jm(r, t)) || t === void 0 && !(e in n)) && Q5(n, e, t);
}
function AP(n, e, t, r) {
  var i = !t;
  t || (t = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var l = e[s], a = void 0;
    a === void 0 && (a = n[l]), i ? Q5(t, l, a) : TP(t, l, a);
  }
  return t;
}
var e6 = Math.max;
function OP(n, e, t) {
  return e = e6(e === void 0 ? n.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, s = e6(r.length - e, 0), o = Array(s); ++i < s; )
      o[i] = r[e + i];
    i = -1;
    for (var l = Array(e + 1); ++i < e; )
      l[i] = r[i];
    return l[e] = t(o), hS(n, this, l);
  };
}
function dS(n, e) {
  return xP(OP(n, e, uS), n + "");
}
var EP = 9007199254740991;
function pS(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= EP;
}
function e3(n) {
  return n != null && pS(n.length) && !X5(n);
}
function IP(n, e, t) {
  if (!Zr(t))
    return !1;
  var r = typeof e;
  return (r == "number" ? e3(t) && fS(e, t.length) : r == "string" && e in t) ? Jm(t[e], n) : !1;
}
function DP(n) {
  return dS(function(e, t) {
    var r = -1, i = t.length, s = i > 1 ? t[i - 1] : void 0, o = i > 2 ? t[2] : void 0;
    for (s = n.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && IP(t[0], t[1], o) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i; ) {
      var l = t[r];
      l && n(e, l, r, s);
    }
    return e;
  });
}
var NP = Object.prototype;
function mS(n) {
  var e = n && n.constructor, t = typeof e == "function" && e.prototype || NP;
  return n === t;
}
function RP(n, e) {
  for (var t = -1, r = Array(n); ++t < n; )
    r[t] = e(t);
  return r;
}
var PP = "[object Arguments]";
function t6(n) {
  return Xc(n) && sd(n) == PP;
}
var gS = Object.prototype, _P = gS.hasOwnProperty, LP = gS.propertyIsEnumerable, k4 = t6(/* @__PURE__ */ (function() {
  return arguments;
})()) ? t6 : function(n) {
  return Xc(n) && _P.call(n, "callee") && !LP.call(n, "callee");
};
function BP() {
  return !1;
}
var yS = typeof exports == "object" && exports && !exports.nodeType && exports, n6 = yS && typeof module == "object" && module && !module.nodeType && module, zP = n6 && n6.exports === yS, r6 = zP ? Ra.Buffer : void 0, FP = r6 ? r6.isBuffer : void 0, bS = FP || BP, HP = "[object Arguments]", $P = "[object Array]", VP = "[object Boolean]", qP = "[object Date]", WP = "[object Error]", jP = "[object Function]", UP = "[object Map]", KP = "[object Number]", GP = "[object Object]", YP = "[object RegExp]", JP = "[object Set]", XP = "[object String]", ZP = "[object WeakMap]", QP = "[object ArrayBuffer]", e_ = "[object DataView]", t_ = "[object Float32Array]", n_ = "[object Float64Array]", r_ = "[object Int8Array]", i_ = "[object Int16Array]", s_ = "[object Int32Array]", o_ = "[object Uint8Array]", l_ = "[object Uint8ClampedArray]", a_ = "[object Uint16Array]", c_ = "[object Uint32Array]", Ht = {};
Ht[t_] = Ht[n_] = Ht[r_] = Ht[i_] = Ht[s_] = Ht[o_] = Ht[l_] = Ht[a_] = Ht[c_] = !0;
Ht[HP] = Ht[$P] = Ht[QP] = Ht[VP] = Ht[e_] = Ht[qP] = Ht[WP] = Ht[jP] = Ht[UP] = Ht[KP] = Ht[GP] = Ht[YP] = Ht[JP] = Ht[XP] = Ht[ZP] = !1;
function u_(n) {
  return Xc(n) && pS(n.length) && !!Ht[sd(n)];
}
function h_(n) {
  return function(e) {
    return n(e);
  };
}
var vS = typeof exports == "object" && exports && !exports.nodeType && exports, _h = vS && typeof module == "object" && module && !module.nodeType && module, f_ = _h && _h.exports === vS, Cg = f_ && aS.process, i6 = (function() {
  try {
    var n = _h && _h.require && _h.require("util").types;
    return n || Cg && Cg.binding && Cg.binding("util");
  } catch {
  }
})(), s6 = i6 && i6.isTypedArray, wS = s6 ? h_(s6) : u_;
function d_(n, e) {
  var t = x4(n), r = !t && k4(n), i = !t && !r && bS(n), s = !t && !r && !i && wS(n), o = t || r || i || s, l = o ? RP(n.length, String) : [], a = l.length;
  for (var c in n)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    fS(c, a)) || l.push(c);
  return l;
}
function p_(n, e) {
  return function(t) {
    return n(e(t));
  };
}
function m_(n) {
  var e = [];
  if (n != null)
    for (var t in Object(n))
      e.push(t);
  return e;
}
var g_ = Object.prototype, y_ = g_.hasOwnProperty;
function b_(n) {
  if (!Zr(n))
    return m_(n);
  var e = mS(n), t = [];
  for (var r in n)
    r == "constructor" && (e || !y_.call(n, r)) || t.push(r);
  return t;
}
function xS(n) {
  return e3(n) ? d_(n) : b_(n);
}
var yf = Z5(Object, "create");
function v_() {
  this.__data__ = yf ? yf(null) : {}, this.size = 0;
}
function w_(n) {
  var e = this.has(n) && delete this.__data__[n];
  return this.size -= e ? 1 : 0, e;
}
var x_ = "__lodash_hash_undefined__", k_ = Object.prototype, S_ = k_.hasOwnProperty;
function C_(n) {
  var e = this.__data__;
  if (yf) {
    var t = e[n];
    return t === x_ ? void 0 : t;
  }
  return S_.call(e, n) ? e[n] : void 0;
}
var M_ = Object.prototype, T_ = M_.hasOwnProperty;
function A_(n) {
  var e = this.__data__;
  return yf ? e[n] !== void 0 : T_.call(e, n);
}
var O_ = "__lodash_hash_undefined__";
function E_(n, e) {
  var t = this.__data__;
  return this.size += this.has(n) ? 0 : 1, t[n] = yf && e === void 0 ? O_ : e, this;
}
function ma(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
ma.prototype.clear = v_;
ma.prototype.delete = w_;
ma.prototype.get = C_;
ma.prototype.has = A_;
ma.prototype.set = E_;
function I_() {
  this.__data__ = [], this.size = 0;
}
function Xm(n, e) {
  for (var t = n.length; t--; )
    if (Jm(n[t][0], e))
      return t;
  return -1;
}
var D_ = Array.prototype, N_ = D_.splice;
function R_(n) {
  var e = this.__data__, t = Xm(e, n);
  if (t < 0)
    return !1;
  var r = e.length - 1;
  return t == r ? e.pop() : N_.call(e, t, 1), --this.size, !0;
}
function P_(n) {
  var e = this.__data__, t = Xm(e, n);
  return t < 0 ? void 0 : e[t][1];
}
function __(n) {
  return Xm(this.__data__, n) > -1;
}
function L_(n, e) {
  var t = this.__data__, r = Xm(t, n);
  return r < 0 ? (++this.size, t.push([n, e])) : t[r][1] = e, this;
}
function bo(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
bo.prototype.clear = I_;
bo.prototype.delete = R_;
bo.prototype.get = P_;
bo.prototype.has = __;
bo.prototype.set = L_;
var kS = Z5(Ra, "Map");
function B_() {
  this.size = 0, this.__data__ = {
    hash: new ma(),
    map: new (kS || bo)(),
    string: new ma()
  };
}
function z_(n) {
  var e = typeof n;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null;
}
function Zm(n, e) {
  var t = n.__data__;
  return z_(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function F_(n) {
  var e = Zm(this, n).delete(n);
  return this.size -= e ? 1 : 0, e;
}
function H_(n) {
  return Zm(this, n).get(n);
}
function $_(n) {
  return Zm(this, n).has(n);
}
function V_(n, e) {
  var t = Zm(this, n), r = t.size;
  return t.set(n, e), this.size += t.size == r ? 0 : 1, this;
}
function Zc(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
Zc.prototype.clear = B_;
Zc.prototype.delete = F_;
Zc.prototype.get = H_;
Zc.prototype.has = $_;
Zc.prototype.set = V_;
var SS = p_(Object.getPrototypeOf, Object), q_ = "[object Object]", W_ = Function.prototype, j_ = Object.prototype, CS = W_.toString, U_ = j_.hasOwnProperty, K_ = CS.call(Object);
function G_(n) {
  if (!Xc(n) || sd(n) != q_)
    return !1;
  var e = SS(n);
  if (e === null)
    return !0;
  var t = U_.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && CS.call(t) == K_;
}
function Y_() {
  this.__data__ = new bo(), this.size = 0;
}
function J_(n) {
  var e = this.__data__, t = e.delete(n);
  return this.size = e.size, t;
}
function X_(n) {
  return this.__data__.get(n);
}
function Z_(n) {
  return this.__data__.has(n);
}
var Q_ = 200;
function eL(n, e) {
  var t = this.__data__;
  if (t instanceof bo) {
    var r = t.__data__;
    if (!kS || r.length < Q_ - 1)
      return r.push([n, e]), this.size = ++t.size, this;
    t = this.__data__ = new Zc(r);
  }
  return t.set(n, e), this.size = t.size, this;
}
function Qc(n) {
  var e = this.__data__ = new bo(n);
  this.size = e.size;
}
Qc.prototype.clear = Y_;
Qc.prototype.delete = J_;
Qc.prototype.get = X_;
Qc.prototype.has = Z_;
Qc.prototype.set = eL;
var MS = typeof exports == "object" && exports && !exports.nodeType && exports, o6 = MS && typeof module == "object" && module && !module.nodeType && module, tL = o6 && o6.exports === MS, l6 = tL ? Ra.Buffer : void 0;
l6 && l6.allocUnsafe;
function nL(n, e) {
  return n.slice();
}
var a6 = Ra.Uint8Array;
function rL(n) {
  var e = new n.constructor(n.byteLength);
  return new a6(e).set(new a6(n)), e;
}
function iL(n, e) {
  var t = rL(n.buffer);
  return new n.constructor(t, n.byteOffset, n.length);
}
function sL(n) {
  return typeof n.constructor == "function" && !mS(n) ? dP(SS(n)) : {};
}
function oL(n) {
  return function(e, t, r) {
    for (var i = -1, s = Object(e), o = r(e), l = o.length; l--; ) {
      var a = o[++i];
      if (t(s[a], a, s) === !1)
        break;
    }
    return e;
  };
}
var lL = oL(), Mg = function() {
  return Ra.Date.now();
}, aL = "Expected a function", cL = Math.max, uL = Math.min;
function Qm(n, e, t) {
  var r, i, s, o, l, a, c = 0, u = !1, h = !1, f = !0;
  if (typeof n != "function")
    throw new TypeError(aL);
  e = X7(e) || 0, Zr(t) && (u = !!t.leading, h = "maxWait" in t, s = h ? cL(X7(t.maxWait) || 0, e) : s, f = "trailing" in t ? !!t.trailing : f);
  function d(T) {
    var N = r, B = i;
    return r = i = void 0, c = T, o = n.apply(B, N), o;
  }
  function p(T) {
    return c = T, l = setTimeout(b, e), u ? d(T) : o;
  }
  function m(T) {
    var N = T - a, B = T - c, $ = e - N;
    return h ? uL($, s - B) : $;
  }
  function g(T) {
    var N = T - a, B = T - c;
    return a === void 0 || N >= e || N < 0 || h && B >= s;
  }
  function b() {
    var T = Mg();
    if (g(T))
      return w(T);
    l = setTimeout(b, m(T));
  }
  function w(T) {
    return l = void 0, f && r ? d(T) : (r = i = void 0, o);
  }
  function k() {
    l !== void 0 && clearTimeout(l), c = 0, r = a = i = l = void 0;
  }
  function C() {
    return l === void 0 ? o : w(Mg());
  }
  function M() {
    var T = Mg(), N = g(T);
    if (r = arguments, i = this, a = T, N) {
      if (l === void 0)
        return p(a);
      if (h)
        return clearTimeout(l), l = setTimeout(b, e), d(a);
    }
    return l === void 0 && (l = setTimeout(b, e)), o;
  }
  return M.cancel = k, M.flush = C, M;
}
function S4(n, e, t) {
  (t !== void 0 && !Jm(n[e], t) || t === void 0 && !(e in n)) && Q5(n, e, t);
}
function hL(n) {
  return Xc(n) && e3(n);
}
function C4(n, e) {
  if (!(e === "constructor" && typeof n[e] == "function") && e != "__proto__")
    return n[e];
}
function fL(n) {
  return AP(n, xS(n));
}
function dL(n, e, t, r, i, s, o) {
  var l = C4(n, t), a = C4(e, t), c = o.get(a);
  if (c) {
    S4(n, t, c);
    return;
  }
  var u = s ? s(l, a, t + "", n, e, o) : void 0, h = u === void 0;
  if (h) {
    var f = x4(a), d = !f && bS(a), p = !f && !d && wS(a);
    u = a, f || d || p ? x4(l) ? u = l : hL(l) ? u = pP(l) : d ? (h = !1, u = nL(a)) : p ? (h = !1, u = iL(a)) : u = [] : G_(a) || k4(a) ? (u = l, k4(l) ? u = fL(l) : (!Zr(l) || X5(l)) && (u = sL(a))) : h = !1;
  }
  h && (o.set(a, u), i(u, a, r, s, o), o.delete(a)), S4(n, t, u);
}
function t3(n, e, t, r, i) {
  n !== e && lL(e, function(s, o) {
    if (i || (i = new Qc()), Zr(s))
      dL(n, e, o, t, t3, r, i);
    else {
      var l = r ? r(C4(n, o), s, o + "", n, e, i) : void 0;
      l === void 0 && (l = s), S4(n, o, l);
    }
  }, xS);
}
function TS(n, e, t, r, i, s) {
  return Zr(n) && Zr(e) && (s.set(e, n), t3(n, e, void 0, TS, s), s.delete(e)), n;
}
var pL = DP(function(n, e, t, r) {
  t3(n, e, t, r);
}), mL = dS(function(n) {
  return n.push(void 0, TS), hS(pL, void 0, n);
}), gL = "Expected a function";
function e1(n, e, t) {
  var r = !0, i = !0;
  if (typeof n != "function")
    throw new TypeError(gL);
  return Zr(t) && (r = "leading" in t ? !!t.leading : r, i = "trailing" in t ? !!t.trailing : i), Qm(n, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
const yL = 1024;
let bL = 0, ai = class {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
};
class st {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = bL++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Qr.match(e)), (t) => {
      let r = e(t);
      return r === void 0 ? null : [this, r];
    };
  }
}
st.closedBy = new st({ deserialize: (n) => n.split(" ") });
st.openedBy = new st({ deserialize: (n) => n.split(" ") });
st.group = new st({ deserialize: (n) => n.split(" ") });
st.isolate = new st({ deserialize: (n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
} });
st.contextHash = new st({ perNode: !0 });
st.lookAhead = new st({ perNode: !0 });
st.mounted = new st({ perNode: !0 });
class bf {
  constructor(e, t, r) {
    this.tree = e, this.overlay = t, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[st.mounted.id];
  }
}
const vL = /* @__PURE__ */ Object.create(null);
let Qr = class AS {
  /**
  @internal
  */
  constructor(e, t, r, i = 0) {
    this.name = e, this.props = t, this.id = r, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : vL, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new AS(e.name || "", t, e.id, r);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[s[0].id] = s[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(st.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let i of r.split(" "))
        t[i] = e[r];
    return (r) => {
      for (let i = r.prop(st.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = t[s < 0 ? r.name : i[s]];
        if (o)
          return o;
      }
    };
  }
};
Qr.none = new Qr(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class n3 {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let r of this.types) {
      let i = null;
      for (let s of e) {
        let o = s(r);
        o && (i || (i = Object.assign({}, r.props)), i[o[0].id] = o[1]);
      }
      t.push(i ? new Qr(r.name, i, r.id, r.flags) : r);
    }
    return new n3(t);
  }
}
const jd = /* @__PURE__ */ new WeakMap(), c6 = /* @__PURE__ */ new WeakMap();
var Zt;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Zt || (Zt = {}));
class Bt {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, r, i, s) {
    if (this.type = e, this.children = t, this.positions = r, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of s)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = bf.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (t && (t += ","), t += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Xp(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, r = 0) {
    let i = jd.get(this) || this.topNode, s = new Xp(i);
    return s.moveTo(e, t), jd.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Gn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let r = vf(jd.get(this) || this.topNode, e, t, !1);
    return jd.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let r = vf(c6.get(this) || this.topNode, e, t, !0);
    return c6.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return kL(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: r, from: i = 0, to: s = this.length } = e, o = e.mode || 0, l = (o & Zt.IncludeAnonymous) > 0;
    for (let a = this.cursor(o | Zt.IncludeAnonymous); ; ) {
      let c = !1;
      if (a.from <= s && a.to >= i && (!l && a.type.isAnonymous || t(a) !== !1)) {
        if (a.firstChild())
          continue;
        c = !0;
      }
      for (; c && r && (l || !a.type.isAnonymous) && r(a), !a.nextSibling(); ) {
        if (!a.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : s3(Qr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, r, i) => new Bt(this.type, t, r, i, this.propValues), e.makeTree || ((t, r, i) => new Bt(Qr.none, t, r, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return SL(e);
  }
}
Bt.empty = new Bt(Qr.none, [], [], 0);
class r3 {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new r3(this.buffer, this.index);
  }
}
class ll {
  /**
  Create a tree buffer.
  */
  constructor(e, t, r) {
    this.buffer = e, this.length = t, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return Qr.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[t], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, r == e)
      return s;
    let o = [];
    for (; e < r; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, r, i, s) {
    let { buffer: o } = this, l = -1;
    for (let a = e; a != t && !(OS(s, i, o[a + 1], o[a + 2]) && (l = a, r > 0)); a = o[a + 3])
      ;
    return l;
  }
  /**
  @internal
  */
  slice(e, t, r) {
    let i = this.buffer, s = new Uint16Array(t - e), o = 0;
    for (let l = e, a = 0; l < t; ) {
      s[a++] = i[l++], s[a++] = i[l++] - r;
      let c = s[a++] = i[l++] - r;
      s[a++] = i[l++] - e, o = Math.max(o, c);
    }
    return new ll(s, o, this.set);
  }
}
function OS(n, e, t, r) {
  switch (n) {
    case -2:
      return t < e;
    case -1:
      return r >= e && t < e;
    case 0:
      return t < e && r > e;
    case 1:
      return t <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function vf(n, e, t, r) {
  for (var i; n.from == n.to || (t < 1 ? n.from >= e : n.from > e) || (t > -1 ? n.to <= e : n.to < e); ) {
    let o = !r && n instanceof Gn && n.index < 0 ? null : n.parent;
    if (!o)
      return n;
    n = o;
  }
  let s = r ? 0 : Zt.IgnoreOverlays;
  if (r)
    for (let o = n, l = o.parent; l; o = l, l = o.parent)
      o instanceof Gn && o.index < 0 && ((i = l.enter(e, t, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (n = l);
  for (; ; ) {
    let o = n.enter(e, t, s);
    if (!o)
      return n;
    n = o;
  }
}
class ES {
  cursor(e = 0) {
    return new Xp(this, e);
  }
  getChild(e, t = null, r = null) {
    let i = u6(this, e, t, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, t = null, r = null) {
    return u6(this, e, t, r);
  }
  resolve(e, t = 0) {
    return vf(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return vf(this, e, t, !0);
  }
  matchContext(e) {
    return M4(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), r = this;
    for (; t; ) {
      let i = t.lastChild;
      if (!i || i.to != t.to)
        break;
      i.type.isError && i.from == i.to ? (r = t, t = i.prevSibling) : t = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Gn extends ES {
  constructor(e, t, r, i) {
    super(), this._tree = e, this.from = t, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, r, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: a } = o._tree, c = t > 0 ? l.length : -1; e != c; e += t) {
        let u = l[e], h = a[e] + o.from;
        if (OS(i, r, h, h + u.length)) {
          if (u instanceof ll) {
            if (s & Zt.ExcludeBuffers)
              continue;
            let f = u.findChild(0, u.buffer.length, t, r - h, i);
            if (f > -1)
              return new us(new wL(o, u, e, h), null, f);
          } else if (s & Zt.IncludeAnonymous || !u.type.isAnonymous || i3(u)) {
            let f;
            if (!(s & Zt.IgnoreMounts) && (f = bf.get(u)) && !f.overlay)
              return new Gn(f.tree, h, e, o);
            let d = new Gn(u, h, e, o);
            return s & Zt.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(t < 0 ? u.children.length - 1 : 0, t, r, i);
          }
        }
      }
      if (s & Zt.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    let i;
    if (!(r & Zt.IgnoreOverlays) && (i = bf.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: l } of i.overlay)
        if ((t > 0 ? o <= s : o < s) && (t < 0 ? l >= s : l > s))
          return new Gn(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function u6(n, e, t, r) {
  let i = n.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (t != null) {
    for (let o = !1; !o; )
      if (o = i.type.is(t), !i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return r == null ? s : [];
  }
}
function M4(n, e, t = e.length - 1) {
  for (let r = n; t >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[t] && e[t] != r.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class wL {
  constructor(e, t, r, i) {
    this.parent = e, this.buffer = t, this.index = r, this.start = i;
  }
}
class us extends ES {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, r) {
    super(), this.context = e, this._parent = t, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, t, r) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.context.start, r);
    return s < 0 ? null : new us(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    if (r & Zt.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return s < 0 ? null : new us(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new us(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new us(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: r } = this.context, i = this.index + 4, s = r.buffer[this.index + 3];
    if (s > i) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(i, s, o)), t.push(0);
    }
    return new Bt(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function IS(n) {
  if (!n.length)
    return null;
  let e = 0, t = n[0];
  for (let s = 1; s < n.length; s++) {
    let o = n[s];
    (o.from > t.from || o.to < t.to) && (t = o, e = s);
  }
  let r = t instanceof Gn && t.index < 0 ? null : t.parent, i = n.slice();
  return r ? i[e] = r : i.splice(e, 1), new xL(i, t);
}
class xL {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return IS(this.heads);
  }
}
function kL(n, e, t) {
  let r = n.resolveInner(e, t), i = null;
  for (let s = r instanceof Gn ? r : r.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [r])).push(o.resolve(e, t)), s = o;
    } else {
      let o = bf.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let l = new Gn(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [r])).push(vf(l, e, t, !1));
      }
    }
  return i ? IS(i) : r;
}
class Xp {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Gn)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return this.type = t || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Gn ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, r, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.buffer.start, r);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, r = this.mode) {
    return this.buffer ? r & Zt.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Zt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Zt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(t.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = t.buffer[this.index + 3];
      if (i < (r < 0 ? t.buffer.length : t.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, r, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: t, parent: r } = i);
    } else
      ({ index: t, _parent: r } = this._tree);
    for (; r; { index: t, _parent: r } = r)
      if (t > -1)
        for (let s = t + e, o = e < 0 ? -1 : r._tree.children.length; s != o; s += e) {
          let l = r._tree.children[s];
          if (this.mode & Zt.IncludeAnonymous || l instanceof ll || !l.type.isAnonymous || i3(l))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, r = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == i) {
            if (i == this.index)
              return o;
            t = o, r = s + 1;
            break e;
          }
        i = this.stack[--s];
      }
    for (let i = r; i < this.stack.length; i++)
      t = new us(this.buffer, t, this.stack[i]);
    return this.bufferNode = new us(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && t && t(this), i = this.type.isAnonymous, !r)
          return;
        if (this.nextSibling())
          break;
        this.parent(), r--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return M4(this.node.parent, e);
    let { buffer: t } = this.buffer, { types: r } = t.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return M4(this._tree, e, i);
      let o = r[t.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function i3(n) {
  return n.children.some((e) => e instanceof ll || !e.type.isAnonymous || i3(e));
}
function SL(n) {
  var e;
  let { buffer: t, nodeSet: r, maxBufferLength: i = yL, reused: s = [], minRepeatType: o = r.types.length } = n, l = Array.isArray(t) ? new r3(t, t.length) : t, a = r.types, c = 0, u = 0;
  function h(M, T, N, B, $, R) {
    let { id: V, start: z, end: ue, size: ie } = l, he = u, Se = c;
    for (; ie < 0; )
      if (l.next(), ie == -1) {
        let Ie = s[V];
        N.push(Ie), B.push(z - M);
        return;
      } else if (ie == -3) {
        c = V;
        return;
      } else if (ie == -4) {
        u = V;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${ie}`);
    let ge = a[V], ye, ze, I = z - M;
    if (ue - z <= i && (ze = g(l.pos - T, $))) {
      let Ie = new Uint16Array(ze.size - ze.skip), Ve = l.pos - ze.size, O = Ie.length;
      for (; l.pos > Ve; )
        O = b(ze.start, Ie, O);
      ye = new ll(Ie, ue - ze.start, r), I = ze.start - M;
    } else {
      let Ie = l.pos - ie;
      l.next();
      let Ve = [], O = [], dt = V >= o ? V : -1, Ue = 0, et = ue;
      for (; l.pos > Ie; )
        dt >= 0 && l.id == dt && l.size >= 0 ? (l.end <= et - i && (p(Ve, O, z, Ue, l.end, et, dt, he, Se), Ue = Ve.length, et = l.end), l.next()) : R > 2500 ? f(z, Ie, Ve, O) : h(z, Ie, Ve, O, dt, R + 1);
      if (dt >= 0 && Ue > 0 && Ue < Ve.length && p(Ve, O, z, Ue, z, et, dt, he, Se), Ve.reverse(), O.reverse(), dt > -1 && Ue > 0) {
        let Ct = d(ge, Se);
        ye = s3(ge, Ve, O, 0, Ve.length, 0, ue - z, Ct, Ct);
      } else
        ye = m(ge, Ve, O, ue - z, he - ue, Se);
    }
    N.push(ye), B.push(I);
  }
  function f(M, T, N, B) {
    let $ = [], R = 0, V = -1;
    for (; l.pos > T; ) {
      let { id: z, start: ue, end: ie, size: he } = l;
      if (he > 4)
        l.next();
      else {
        if (V > -1 && ue < V)
          break;
        V < 0 && (V = ie - i), $.push(z, ue, ie), R++, l.next();
      }
    }
    if (R) {
      let z = new Uint16Array(R * 4), ue = $[$.length - 2];
      for (let ie = $.length - 3, he = 0; ie >= 0; ie -= 3)
        z[he++] = $[ie], z[he++] = $[ie + 1] - ue, z[he++] = $[ie + 2] - ue, z[he++] = he;
      N.push(new ll(z, $[2] - ue, r)), B.push(ue - M);
    }
  }
  function d(M, T) {
    return (N, B, $) => {
      let R = 0, V = N.length - 1, z, ue;
      if (V >= 0 && (z = N[V]) instanceof Bt) {
        if (!V && z.type == M && z.length == $)
          return z;
        (ue = z.prop(st.lookAhead)) && (R = B[V] + z.length + ue);
      }
      return m(M, N, B, $, R, T);
    };
  }
  function p(M, T, N, B, $, R, V, z, ue) {
    let ie = [], he = [];
    for (; M.length > B; )
      ie.push(M.pop()), he.push(T.pop() + N - $);
    M.push(m(r.types[V], ie, he, R - $, z - R, ue)), T.push($ - N);
  }
  function m(M, T, N, B, $, R, V) {
    if (R) {
      let z = [st.contextHash, R];
      V = V ? [z].concat(V) : [z];
    }
    if ($ > 25) {
      let z = [st.lookAhead, $];
      V = V ? [z].concat(V) : [z];
    }
    return new Bt(M, T, N, B, V);
  }
  function g(M, T) {
    let N = l.fork(), B = 0, $ = 0, R = 0, V = N.end - i, z = { size: 0, start: 0, skip: 0 };
    e: for (let ue = N.pos - M; N.pos > ue; ) {
      let ie = N.size;
      if (N.id == T && ie >= 0) {
        z.size = B, z.start = $, z.skip = R, R += 4, B += 4, N.next();
        continue;
      }
      let he = N.pos - ie;
      if (ie < 0 || he < ue || N.start < V)
        break;
      let Se = N.id >= o ? 4 : 0, ge = N.start;
      for (N.next(); N.pos > he; ) {
        if (N.size < 0)
          if (N.size == -3)
            Se += 4;
          else
            break e;
        else N.id >= o && (Se += 4);
        N.next();
      }
      $ = ge, B += ie, R += Se;
    }
    return (T < 0 || B == M) && (z.size = B, z.start = $, z.skip = R), z.size > 4 ? z : void 0;
  }
  function b(M, T, N) {
    let { id: B, start: $, end: R, size: V } = l;
    if (l.next(), V >= 0 && B < o) {
      let z = N;
      if (V > 4) {
        let ue = l.pos - (V - 4);
        for (; l.pos > ue; )
          N = b(M, T, N);
      }
      T[--N] = z, T[--N] = R - M, T[--N] = $ - M, T[--N] = B;
    } else V == -3 ? c = B : V == -4 && (u = B);
    return N;
  }
  let w = [], k = [];
  for (; l.pos > 0; )
    h(n.start || 0, n.bufferStart || 0, w, k, -1, 0);
  let C = (e = n.length) !== null && e !== void 0 ? e : w.length ? k[0] + w[0].length : 0;
  return new Bt(a[n.topID], w.reverse(), k.reverse(), C);
}
const h6 = /* @__PURE__ */ new WeakMap();
function W0(n, e) {
  if (!n.isAnonymous || e instanceof ll || e.type != n)
    return 1;
  let t = h6.get(e);
  if (t == null) {
    t = 1;
    for (let r of e.children) {
      if (r.type != n || !(r instanceof Bt)) {
        t = 1;
        break;
      }
      t += W0(n, r);
    }
    h6.set(e, t);
  }
  return t;
}
function s3(n, e, t, r, i, s, o, l, a) {
  let c = 0;
  for (let p = r; p < i; p++)
    c += W0(n, e[p]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], f = [];
  function d(p, m, g, b, w) {
    for (let k = g; k < b; ) {
      let C = k, M = m[k], T = W0(n, p[k]);
      for (k++; k < b; k++) {
        let N = W0(n, p[k]);
        if (T + N >= u)
          break;
        T += N;
      }
      if (k == C + 1) {
        if (T > u) {
          let N = p[C];
          d(N.children, N.positions, 0, N.children.length, m[C] + w);
          continue;
        }
        h.push(p[C]);
      } else {
        let N = m[k - 1] + p[k - 1].length - M;
        h.push(s3(n, p, m, C, k, M, N, null, a));
      }
      f.push(M + w - s);
    }
  }
  return d(e, t, r, i, 0), (l || a)(h, f, o);
}
class Eue {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, r) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(t, r);
  }
  getBuffer(e, t) {
    let r = this.map.get(e);
    return r && r.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof us ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof Gn && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof us ? this.getBuffer(e.context.buffer, e.index) : e instanceof Gn ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class to {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, r, i, s = !1, o = !1) {
    this.from = e, this.to = t, this.tree = r, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], r = !1) {
    let i = [new to(0, e.length, e, 0, !1, r)];
    for (let s of t)
      s.to > e.length && i.push(s);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, r = 128) {
    if (!t.length)
      return e;
    let i = [], s = 1, o = e.length ? e[0] : null;
    for (let l = 0, a = 0, c = 0; ; l++) {
      let u = l < t.length ? t[l] : null, h = u ? u.fromA : 1e9;
      if (h - a >= r)
        for (; o && o.from < h; ) {
          let f = o;
          if (a >= f.from || h <= f.to || c) {
            let d = Math.max(f.from, a) - c, p = Math.min(f.to, h) - c;
            f = d >= p ? null : new to(d, p, f.tree, f.offset + c, l > 0, !!u);
          }
          if (f && i.push(f), o.to > h)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!u)
        break;
      a = u.toA, c = u.toA - u.toB;
    }
    return i;
  }
}
let DS = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, r) {
    return typeof e == "string" && (e = new CL(e)), r = r ? r.length ? r.map((i) => new ai(i.from, i.to)) : [new ai(0, 0)] : [new ai(0, e.length)], this.createParse(e, t || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, r) {
    let i = this.startParse(e, t, r);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
};
class CL {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function Due(n) {
  return (e, t, r, i) => new TL(e, n, t, r, i);
}
class f6 {
  constructor(e, t, r, i, s) {
    this.parser = e, this.parse = t, this.overlay = r, this.target = i, this.from = s;
  }
}
function d6(n) {
  if (!n.length || n.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(n));
}
class ML {
  constructor(e, t, r, i, s, o, l) {
    this.parser = e, this.predicate = t, this.mounts = r, this.index = i, this.start = s, this.target = o, this.prev = l, this.depth = 0, this.ranges = [];
  }
}
const T4 = new st({ perNode: !0 });
class TL {
  constructor(e, t, r, i, s) {
    this.nest = t, this.input = r, this.fragments = i, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new Bt(r.type, r.children, r.positions, r.length, r.propValues.concat([[T4, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[st.mounted.id] = new bf(t, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new EL(this.fragments), t = null, r = null, i = new Xp(new Gn(this.baseTree, this.ranges[0].from, 0, null), Zt.IncludeAnonymous | Zt.IgnoreMounts);
    e: for (let s, o; ; ) {
      let l = !0, a;
      if (this.stoppedAt != null && i.from >= this.stoppedAt)
        l = !1;
      else if (e.hasNode(i)) {
        if (t) {
          let c = t.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
          if (c)
            for (let u of c.mount.overlay) {
              let h = u.from + c.pos, f = u.to + c.pos;
              h >= i.from && f <= i.to && !t.ranges.some((d) => d.from < f && d.to > h) && t.ranges.push({ from: h, to: f });
            }
        }
        l = !1;
      } else if (r && (o = AL(r.ranges, i.from, i.to)))
        l = o != 2;
      else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
        i.tree || OL(i);
        let c = e.findMounts(i.from, s.parser);
        if (typeof s.overlay == "function")
          t = new ML(s.parser, s.overlay, c, this.inner.length, i.from, i.tree, t);
        else {
          let u = g6(this.ranges, s.overlay || (i.from < i.to ? [new ai(i.from, i.to)] : []));
          u.length && d6(u), (u.length || !s.overlay) && this.inner.push(new f6(s.parser, u.length ? s.parser.startParse(this.input, y6(c, u), u) : s.parser.startParse(""), s.overlay ? s.overlay.map((h) => new ai(h.from - i.from, h.to - i.from)) : null, i.tree, u.length ? u[0].from : i.from)), s.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : l = !1;
        }
      } else if (t && (a = t.predicate(i)) && (a === !0 && (a = new ai(i.from, i.to)), a.from < a.to)) {
        let c = t.ranges.length - 1;
        c >= 0 && t.ranges[c].to == a.from ? t.ranges[c] = { from: t.ranges[c].from, to: a.to } : t.ranges.push(a);
      }
      if (l && i.firstChild())
        t && t.depth++, r && r.depth++;
      else
        for (; !i.nextSibling(); ) {
          if (!i.parent())
            break e;
          if (t && !--t.depth) {
            let c = g6(this.ranges, t.ranges);
            c.length && (d6(c), this.inner.splice(t.index, 0, new f6(t.parser, t.parser.startParse(this.input, y6(t.mounts, c), c), t.ranges.map((u) => new ai(u.from - t.start, u.to - t.start)), t.target, c[0].from))), t = t.prev;
          }
          r && !--r.depth && (r = r.prev);
        }
    }
  }
}
function AL(n, e, t) {
  for (let r of n) {
    if (r.from >= t)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= t ? 2 : 1;
  }
  return 0;
}
function p6(n, e, t, r, i, s) {
  if (e < t) {
    let o = n.buffer[e + 1];
    r.push(n.slice(e, t, o)), i.push(o - s);
  }
}
function OL(n) {
  let { node: e } = n, t = [], r = e.context.buffer;
  do
    t.push(n.index), n.parent();
  while (!n.tree);
  let i = n.tree, s = i.children.indexOf(r), o = i.children[s], l = o.buffer, a = [s];
  function c(u, h, f, d, p, m) {
    let g = t[m], b = [], w = [];
    p6(o, u, g, b, w, d);
    let k = l[g + 1], C = l[g + 2];
    a.push(b.length);
    let M = m ? c(g + 4, l[g + 3], o.set.types[l[g]], k, C - k, m - 1) : e.toTree();
    return b.push(M), w.push(k - d), p6(o, l[g + 3], h, b, w, d), new Bt(f, b, w, p);
  }
  i.children[s] = c(0, l.length, Qr.none, 0, o.length, t.length - 1);
  for (let u of a) {
    let h = n.tree.children[u], f = n.tree.positions[u];
    n.yield(new Gn(h, f + n.from, u, n._tree));
  }
}
class m6 {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Zt.IncludeAnonymous | Zt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, r = e - this.offset;
    for (; !this.done && t.from < r; )
      t.to >= e && t.enter(r, 1, Zt.IgnoreOverlays | Zt.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof Bt)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
class EL {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (t = r.tree.prop(T4)) !== null && t !== void 0 ? t : r.to, this.inner = new m6(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(T4)) !== null && e !== void 0 ? e : t.to, this.inner = new m6(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(st.mounted);
        if (o && o.parser == t)
          for (let l = this.fragI; l < this.fragments.length; l++) {
            let a = this.fragments[l];
            if (a.from >= s.to)
              break;
            a.tree == this.curFrag.tree && i.push({
              frag: a,
              pos: s.from - a.offset,
              mount: o
            });
          }
      }
    }
    return i;
  }
}
function g6(n, e) {
  let t = null, r = e;
  for (let i = 1, s = 0; i < n.length; i++) {
    let o = n[i - 1].to, l = n[i].from;
    for (; s < r.length; s++) {
      let a = r[s];
      if (a.from >= l)
        break;
      a.to <= o || (t || (r = t = e.slice()), a.from < o ? (t[s] = new ai(a.from, o), a.to > l && t.splice(s + 1, 0, new ai(l, a.to))) : a.to > l ? t[s--] = new ai(l, a.to) : t.splice(s--, 1));
    }
  }
  return r;
}
function IL(n, e, t, r) {
  let i = 0, s = 0, o = !1, l = !1, a = -1e9, c = [];
  for (; ; ) {
    let u = i == n.length ? 1e9 : o ? n[i].to : n[i].from, h = s == e.length ? 1e9 : l ? e[s].to : e[s].from;
    if (o != l) {
      let f = Math.max(a, t), d = Math.min(u, h, r);
      f < d && c.push(new ai(f, d));
    }
    if (a = Math.min(u, h), a == 1e9)
      break;
    u == a && (o ? (o = !1, i++) : o = !0), h == a && (l ? (l = !1, s++) : l = !0);
  }
  return c;
}
function y6(n, e) {
  let t = [];
  for (let { pos: r, mount: i, frag: s } of n) {
    let o = r + (i.overlay ? i.overlay[0].from : 0), l = o + i.tree.length, a = Math.max(s.from, o), c = Math.min(s.to, l);
    if (i.overlay) {
      let u = i.overlay.map((f) => new ai(f.from + r, f.to + r)), h = IL(e, u, a, c);
      for (let f = 0, d = a; ; f++) {
        let p = f == h.length, m = p ? c : h[f].from;
        if (m > d && t.push(new to(d, m, i.tree, -o, s.from >= d || s.openStart, s.to <= m || s.openEnd)), p)
          break;
        d = h[f].to;
      }
    } else
      t.push(new to(a, c, i.tree, -o, s.from >= o || s.openStart, s.to <= l || s.openEnd));
  }
  return t;
}
let A4 = [], NS = [];
(() => {
  let n = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, t = 0; e < n.length; e++)
    (e % 2 ? NS : A4).push(t = t + n[e]);
})();
function DL(n) {
  if (n < 768) return !1;
  for (let e = 0, t = A4.length; ; ) {
    let r = e + t >> 1;
    if (n < A4[r]) t = r;
    else if (n >= NS[r]) e = r + 1;
    else return !0;
    if (e == t) return !1;
  }
}
function b6(n) {
  return n >= 127462 && n <= 127487;
}
const v6 = 8205;
function NL(n, e, t = !0, r = !0) {
  return (t ? RS : RL)(n, e, r);
}
function RS(n, e, t) {
  if (e == n.length) return e;
  e && PS(n.charCodeAt(e)) && _S(n.charCodeAt(e - 1)) && e--;
  let r = Tg(n, e);
  for (e += w6(r); e < n.length; ) {
    let i = Tg(n, e);
    if (r == v6 || i == v6 || t && DL(i))
      e += w6(i), r = i;
    else if (b6(i)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && b6(Tg(n, o)); )
        s++, o -= 2;
      if (s % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function RL(n, e, t) {
  for (; e > 0; ) {
    let r = RS(n, e - 2, t);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function Tg(n, e) {
  let t = n.charCodeAt(e);
  if (!_S(t) || e + 1 == n.length) return t;
  let r = n.charCodeAt(e + 1);
  return PS(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function PS(n) {
  return n >= 56320 && n < 57344;
}
function _S(n) {
  return n >= 55296 && n < 56320;
}
function w6(n) {
  return n < 65536 ? 1 : 2;
}
let ft = class LS {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, r) {
    [e, t] = Dc(this, e, t);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      i,
      1
      /* Open.From */
    ), j0.from(i, this.length - (t - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = Dc(this, e, t);
    let r = [];
    return this.decompose(e, t, r, 0), j0.from(r, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Lh(this), s = new Lh(e);
    for (let o = t, l = t; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (l += i.value.length, i.done || l >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Lh(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new BS(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new zS(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? LS.empty : e.length <= 32 ? new an(e) : j0.from(an.split(e, []));
  }
};
class an extends ft {
  constructor(e, t = PL(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], l = i + o.length;
      if ((t ? r : l) >= e)
        return new _L(i, l, r, o);
      i = l + 1, r++;
    }
  }
  decompose(e, t, r, i) {
    let s = e <= 0 && t >= this.length ? this : new an(x6(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = r.pop(), l = U0(s.text, o.text.slice(), 0, s.length);
      if (l.length <= 32)
        r.push(new an(l, o.length + s.length));
      else {
        let a = l.length >> 1;
        r.push(new an(l.slice(0, a)), new an(l.slice(a)));
      }
    } else
      r.push(s);
  }
  replace(e, t, r) {
    if (!(r instanceof an))
      return super.replace(e, t, r);
    [e, t] = Dc(this, e, t);
    let i = U0(this.text, U0(r.text, x6(this.text, 0, e)), t), s = this.length + r.length - (t - e);
    return i.length <= 32 ? new an(i, s) : j0.from(an.split(i, []), s);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = Dc(this, e, t);
    let i = "";
    for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
      let l = this.text[o], a = s + l.length;
      s > e && o && (i += r), e < a && t > s && (i += l.slice(Math.max(0, e - s), t - s)), s = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let r = [], i = -1;
    for (let s of e)
      r.push(s), i += s.length + 1, r.length == 32 && (t.push(new an(r, i)), r = [], i = -1);
    return i > -1 && t.push(new an(r, i)), t;
  }
}
let j0 = class Za extends ft {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], l = i + o.length, a = r + o.lines - 1;
      if ((t ? a : l) >= e)
        return o.lineInner(e, t, r, i);
      i = l + 1, r = a + 1;
    }
  }
  decompose(e, t, r, i) {
    for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
      let l = this.children[s], a = o + l.length;
      if (e <= a && t >= o) {
        let c = i & ((o <= e ? 1 : 0) | (a >= t ? 2 : 0));
        o >= e && a <= t && !c ? r.push(l) : l.decompose(e - o, t - o, r, c);
      }
      o = a + 1;
    }
  }
  replace(e, t, r) {
    if ([e, t] = Dc(this, e, t), r.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], l = s + o.length;
        if (e >= s && t <= l) {
          let a = o.replace(e - s, t - s, r), c = this.lines - o.lines + a.lines;
          if (a.lines < c >> 4 && a.lines > c >> 6) {
            let u = this.children.slice();
            return u[i] = a, new Za(u, this.length - (t - e) + r.length);
          }
          return super.replace(s, l, a);
        }
        s = l + 1;
      }
    return super.replace(e, t, r);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = Dc(this, e, t);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
      let l = this.children[s], a = o + l.length;
      o > e && s && (i += r), e < a && t > o && (i += l.sliceString(e - o, t - o, r)), o = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Za))
      return 0;
    let r = 0, [i, s, o, l] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += t, s += t) {
      if (i == o || s == l)
        return r;
      let a = this.children[i], c = e.children[s];
      if (a != c)
        return r + a.scanIdentical(c, t);
      r += a.length + 1;
    }
  }
  static from(e, t = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let d of e)
      r += d.lines;
    if (r < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new an(d, t);
    }
    let i = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), s = i << 1, o = i >> 1, l = [], a = 0, c = -1, u = [];
    function h(d) {
      let p;
      if (d.lines > s && d instanceof Za)
        for (let m of d.children)
          h(m);
      else d.lines > o && (a > o || !a) ? (f(), l.push(d)) : d instanceof an && a && (p = u[u.length - 1]) instanceof an && d.lines + p.lines <= 32 ? (a += d.lines, c += d.length + 1, u[u.length - 1] = new an(p.text.concat(d.text), p.length + 1 + d.length)) : (a + d.lines > i && f(), a += d.lines, c += d.length + 1, u.push(d));
    }
    function f() {
      a != 0 && (l.push(u.length == 1 ? u[0] : Za.from(u, c)), c = -1, a = u.length = 0);
    }
    for (let d of e)
      h(d);
    return f(), l.length == 1 ? l[0] : new Za(l, t);
  }
};
ft.empty = /* @__PURE__ */ new an([""], 0);
function PL(n) {
  let e = -1;
  for (let t of n)
    e += t.length + 1;
  return e;
}
function U0(n, e, t = 0, r = 1e9) {
  for (let i = 0, s = 0, o = !0; s < n.length && i <= r; s++) {
    let l = n[s], a = i + l.length;
    a >= t && (a > r && (l = l.slice(0, r - i)), i < t && (l = l.slice(t - i)), o ? (e[e.length - 1] += l, o = !1) : e.push(l)), i = a + 1;
  }
  return e;
}
function x6(n, e, t) {
  return U0(n, [""], e, t);
}
class Lh {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof an ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], s = this.offsets[r], o = s >> 1, l = i instanceof an ? i.text.length : i.children.length;
      if (o == (t > 0 ? l : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[r] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof an) {
        let a = i.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[r] += t, a.length > Math.max(0, e))
          return this.value = e == 0 ? a : t > 0 ? a.slice(e) : a.slice(0, a.length - e), this;
        e -= a.length;
      } else {
        let a = i.children[o + (t < 0 ? -1 : 0)];
        e > a.length ? (e -= a.length, this.offsets[r] += t) : (t < 0 && this.offsets[r]--, this.nodes.push(a), this.offsets.push(t > 0 ? 1 : (a instanceof an ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class BS {
  constructor(e, t, r) {
    this.value = "", this.done = !1, this.cursor = new Lh(e, t > r ? -1 : 1), this.pos = t > r ? e.length : 0, this.from = Math.min(t, r), this.to = Math.max(t, r);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let r = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * t, this.value = i.length <= r ? i : t < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class zS {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: r, value: i } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (ft.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Lh.prototype[Symbol.iterator] = BS.prototype[Symbol.iterator] = zS.prototype[Symbol.iterator] = function() {
  return this;
});
class _L {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.number = r, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Dc(n, e, t) {
  return e = Math.max(0, Math.min(n.length, e)), [e, Math.max(e, Math.min(n.length, t))];
}
function zn(n, e, t = !0, r = !0) {
  return NL(n, e, t, r);
}
function LL(n) {
  return n >= 56320 && n < 57344;
}
function BL(n) {
  return n >= 55296 && n < 56320;
}
function kr(n, e) {
  let t = n.charCodeAt(e);
  if (!BL(t) || e + 1 == n.length)
    return t;
  let r = n.charCodeAt(e + 1);
  return LL(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function o3(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
function ls(n) {
  return n < 65536 ? 1 : 2;
}
const O4 = /\r\n?|\n/;
var Bn = /* @__PURE__ */ (function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
})(Bn || (Bn = {}));
class gs {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t + 1];
      e += r < 0 ? this.sections[t] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, r = 0, i = 0; t < this.sections.length; ) {
      let s = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(r, i, s), i += s) : i += o, r += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    E4(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new gs(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : FS(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : I4(this, e, t);
  }
  mapPos(e, t = -1, r = Bn.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], a = this.sections[o++], c = i + l;
      if (a < 0) {
        if (c > e)
          return s + (e - i);
        s += l;
      } else {
        if (r != Bn.Simple && c >= e && (r == Bn.TrackDel && i < e && c > e || r == Bn.TrackBefore && i < e || r == Bn.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !l)
          return e == i || t < 0 ? s : s + a;
        s += a;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= t; ) {
      let s = this.sections[r++], o = this.sections[r++], l = i + s;
      if (o >= 0 && i <= t && l >= e)
        return i < e && l > t ? "cover" : !0;
      i = l;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new gs(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new gs(e);
  }
}
class wn extends gs {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return E4(this, (t, r, i, s, o) => e = e.replace(i, i + (r - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return I4(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), r = [];
    for (let i = 0, s = 0; i < t.length; i += 2) {
      let o = t[i], l = t[i + 1];
      if (l >= 0) {
        t[i] = l, t[i + 1] = o;
        let a = i >> 1;
        for (; r.length < a; )
          r.push(ft.empty);
        r.push(o ? e.slice(s, s + o) : ft.empty);
      }
      s += o;
    }
    return new wn(t, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : FS(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : I4(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    E4(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return gs.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], r = [], i = [], s = new wf(this);
    e: for (let o = 0, l = 0; ; ) {
      let a = o == e.length ? 1e9 : e[o++];
      for (; l < a || l == a && s.len == 0; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, a - l);
        Wn(i, u, -1);
        let h = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        Wn(t, u, h), h > 0 && Go(r, t, s.text), s.forward(u), l += u;
      }
      let c = e[o++];
      for (; l < c; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, c - l);
        Wn(t, u, -1), Wn(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), l += u;
      }
    }
    return {
      changes: new wn(t, r),
      filtered: gs.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t], i = this.sections[t + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, r) {
    let i = [], s = [], o = 0, l = null;
    function a(u = !1) {
      if (!u && !i.length)
        return;
      o < t && Wn(i, t - o, -1);
      let h = new wn(i, s);
      l = l ? l.compose(h.map(l)) : h, i = [], s = [], o = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let h of u)
          c(h);
      else if (u instanceof wn) {
        if (u.length != t)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${t})`);
        a(), l = l ? l.compose(u.map(l)) : u;
      } else {
        let { from: h, to: f = h, insert: d } = u;
        if (h > f || h < 0 || f > t)
          throw new RangeError(`Invalid change range ${h} to ${f} (in doc of length ${t})`);
        let p = d ? typeof d == "string" ? ft.of(d.split(r || O4)) : d : ft.empty, m = p.length;
        if (h == f && m == 0)
          return;
        h < o && a(), h > o && Wn(i, h - o, -1), Wn(i, f - h, m), Go(s, i, p), o = f;
      }
    }
    return c(e), a(!l), l;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new wn(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], r = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        t.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          t.push(s[0], 0);
        else {
          for (; r.length < i; )
            r.push(ft.empty);
          r[i] = ft.of(s.slice(1)), t.push(s[0], r[i].length);
        }
      }
    }
    return new wn(t, r);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new wn(e, t);
  }
}
function Wn(n, e, t, r = !1) {
  if (e == 0 && t <= 0)
    return;
  let i = n.length - 2;
  i >= 0 && t <= 0 && t == n[i + 1] ? n[i] += e : i >= 0 && e == 0 && n[i] == 0 ? n[i + 1] += t : r ? (n[i] += e, n[i + 1] += t) : n.push(e, t);
}
function Go(n, e, t) {
  if (t.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < n.length)
    n[n.length - 1] = n[n.length - 1].append(t);
  else {
    for (; n.length < r; )
      n.push(ft.empty);
    n.push(t);
  }
}
function E4(n, e, t) {
  let r = n.inserted;
  for (let i = 0, s = 0, o = 0; o < n.sections.length; ) {
    let l = n.sections[o++], a = n.sections[o++];
    if (a < 0)
      i += l, s += l;
    else {
      let c = i, u = s, h = ft.empty;
      for (; c += l, u += a, a && r && (h = h.append(r[o - 2 >> 1])), !(t || o == n.sections.length || n.sections[o + 1] < 0); )
        l = n.sections[o++], a = n.sections[o++];
      e(i, c, s, u, h), i = c, s = u;
    }
  }
}
function I4(n, e, t, r = !1) {
  let i = [], s = r ? [] : null, o = new wf(n), l = new wf(e);
  for (let a = -1; ; ) {
    if (o.done && l.len || l.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && l.ins == -1) {
      let c = Math.min(o.len, l.len);
      Wn(i, c, -1), o.forward(c), l.forward(c);
    } else if (l.ins >= 0 && (o.ins < 0 || a == o.i || o.off == 0 && (l.len < o.len || l.len == o.len && !t))) {
      let c = l.len;
      for (Wn(i, l.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && a < o.i && o.len <= u && (Wn(i, 0, o.ins), s && Go(s, i, o.text), a = o.i), o.forward(u), c -= u;
      }
      l.next();
    } else if (o.ins >= 0) {
      let c = 0, u = o.len;
      for (; u; )
        if (l.ins == -1) {
          let h = Math.min(u, l.len);
          c += h, u -= h, l.forward(h);
        } else if (l.ins == 0 && l.len < u)
          u -= l.len, l.next();
        else
          break;
      Wn(i, c, a < o.i ? o.ins : 0), s && a < o.i && Go(s, i, o.text), a = o.i, o.forward(o.len - u);
    } else {
      if (o.done && l.done)
        return s ? wn.createSet(i, s) : gs.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function FS(n, e, t = !1) {
  let r = [], i = t ? [] : null, s = new wf(n), o = new wf(e);
  for (let l = !1; ; ) {
    if (s.done && o.done)
      return i ? wn.createSet(r, i) : gs.create(r);
    if (s.ins == 0)
      Wn(r, s.len, 0, l), s.next();
    else if (o.len == 0 && !o.done)
      Wn(r, 0, o.ins, l), i && Go(i, r, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(s.len2, o.len), c = r.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          Wn(r, a, u, l), i && u && Go(i, r, o.text);
        } else o.ins == -1 ? (Wn(r, s.off ? 0 : s.len, a, l), i && Go(i, r, s.textBit(a))) : (Wn(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, l), i && !o.off && Go(i, r, o.text));
        l = (s.ins > a || o.ins >= 0 && o.len > a) && (l || r.length > c), s.forward2(a), o.forward(a);
      }
    }
  }
}
class wf {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? ft.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, r = this.i - 2 >> 1;
    return r >= t.length && !e ? ft.empty : t[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
let Ud = class D4 {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.flags = r;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let r, i;
    return this.empty ? r = i = e.mapPos(this.from, t) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new D4(r, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return G.range(e, t);
    let r = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return G.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return G.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new D4(e, t, r);
  }
};
class G {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : G.create(this.ranges.map((r) => r.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new G([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return G.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let r = this.ranges.slice();
    return r[t] = e, G.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new G(e.ranges.map((t) => Ud.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new G([G.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= r : s.from < r)
        return G.normalized(e.slice(), t);
      r = s.to;
    }
    return new G(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, r, i) {
    return Ud.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, r, i) {
    let s = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return t < e ? Ud.create(t, e, 48 | s) : Ud.create(e, t, (t > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let r = e[t];
    e.sort((i, s) => i.from - s.from), t = e.indexOf(r);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let l = o.from, a = Math.max(s.to, o.to);
        i <= t && t--, e.splice(--i, 2, s.anchor > s.head ? G.range(a, l) : G.range(l, a));
      }
    }
    return new G(e, t);
  }
}
function HS(n, e) {
  for (let t of n.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let l3 = 0;
class xe {
  constructor(e, t, r, i, s) {
    this.combine = e, this.compareInput = t, this.compare = r, this.isStatic = i, this.id = l3++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new xe(e.combine || ((t) => t), e.compareInput || ((t, r) => t === r), e.compare || (e.combine ? (t, r) => t === r : a3), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new K0([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new K0(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new K0(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (r) => r), this.compute([e], (r) => t(r.field(e)));
  }
}
function a3(n, e) {
  return n == e || n.length == e.length && n.every((t, r) => t === e[r]);
}
class K0 {
  constructor(e, t, r, i) {
    this.dependencies = e, this.facet = t, this.type = r, this.value = i, this.id = l3++;
  }
  dynamicSlot(e) {
    var t;
    let r = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, l = this.type == 2, a = !1, c = !1, u = [];
    for (let h of this.dependencies)
      h == "doc" ? a = !0 : h == "selection" ? c = !0 : (((t = e[h.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 && u.push(e[h.id]);
    return {
      create(h) {
        return h.values[o] = r(h), 1;
      },
      update(h, f) {
        if (a && f.docChanged || c && (f.docChanged || f.selection) || N4(h, u)) {
          let d = r(h);
          if (l ? !k6(d, h.values[o], i) : !i(d, h.values[o]))
            return h.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (h, f) => {
        let d, p = f.config.address[s];
        if (p != null) {
          let m = Zp(f, p);
          if (this.dependencies.every((g) => g instanceof xe ? f.facet(g) === h.facet(g) : g instanceof On ? f.field(g, !1) == h.field(g, !1) : !0) || (l ? k6(d = r(h), m, i) : i(d = r(h), m)))
            return h.values[o] = m, 0;
        } else
          d = r(h);
        return h.values[o] = d, 1;
      }
    };
  }
}
function k6(n, e, t) {
  if (n.length != e.length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (!t(n[r], e[r]))
      return !1;
  return !0;
}
function N4(n, e) {
  let t = !1;
  for (let r of e)
    Bh(n, r) & 1 && (t = !0);
  return t;
}
function zL(n, e, t) {
  let r = t.map((a) => n[a.id]), i = t.map((a) => a.type), s = r.filter((a) => !(a & 1)), o = n[e.id] >> 1;
  function l(a) {
    let c = [];
    for (let u = 0; u < r.length; u++) {
      let h = Zp(a, r[u]);
      if (i[u] == 2)
        for (let f of h)
          c.push(f);
      else
        c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(a) {
      for (let c of r)
        Bh(a, c);
      return a.values[o] = l(a), 1;
    },
    update(a, c) {
      if (!N4(a, s))
        return 0;
      let u = l(a);
      return e.compare(u, a.values[o]) ? 0 : (a.values[o] = u, 1);
    },
    reconfigure(a, c) {
      let u = N4(a, r), h = c.config.facets[e.id], f = c.facet(e);
      if (h && !u && a3(t, h))
        return a.values[o] = f, 0;
      let d = l(a);
      return e.compare(d, f) ? (a.values[o] = f, 0) : (a.values[o] = d, 1);
    }
  };
}
const Kd = /* @__PURE__ */ xe.define({ static: !0 });
class On {
  constructor(e, t, r, i, s) {
    this.id = e, this.createF = t, this.updateF = r, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new On(l3++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(Kd).find((r) => r.field == this);
    return (t?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (r) => (r.values[t] = this.create(r), 1),
      update: (r, i) => {
        let s = r.values[t], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (r.values[t] = o, 1);
      },
      reconfigure: (r, i) => {
        let s = r.facet(Kd), o = i.facet(Kd), l;
        return (l = s.find((a) => a.field == this)) && l != o.find((a) => a.field == this) ? (r.values[t] = l.create(r), 1) : i.config.address[this.id] != null ? (r.values[t] = i.field(this), 0) : (r.values[t] = this.create(r), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Kd.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Gl = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Ru(n) {
  return (e) => new $S(e, n);
}
const wl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Ru(Gl.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Ru(Gl.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Ru(Gl.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Ru(Gl.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Ru(Gl.lowest)
};
class $S {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class Nc {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new R4(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Nc.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class R4 {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
let S6 = class VS {
  constructor(e, t, r, i, s, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = r, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, r) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of FL(e, t, o))
      f instanceof On ? i.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let l = /* @__PURE__ */ Object.create(null), a = [], c = [];
    for (let f of i)
      l[f.id] = c.length << 1, c.push((d) => f.slot(d));
    let u = r?.config.facets;
    for (let f in s) {
      let d = s[f], p = d[0].facet, m = u && u[f] || [];
      if (d.every(
        (g) => g.type == 0
        /* Provider.Static */
      ))
        if (l[p.id] = a.length << 1 | 1, a3(m, d))
          a.push(r.facet(p));
        else {
          let g = p.combine(d.map((b) => b.value));
          a.push(r && p.compare(g, r.facet(p)) ? r.facet(p) : g);
        }
      else {
        for (let g of d)
          g.type == 0 ? (l[g.id] = a.length << 1 | 1, a.push(g.value)) : (l[g.id] = c.length << 1, c.push((b) => g.dynamicSlot(b)));
        l[p.id] = c.length << 1, c.push((g) => zL(g, p, d));
      }
    }
    let h = c.map((f) => f(l));
    return new VS(e, o, h, l, a, s);
  }
};
function FL(n, e, t) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, l) {
    let a = i.get(o);
    if (a != null) {
      if (a <= l)
        return;
      let c = r[a].indexOf(o);
      c > -1 && r[a].splice(c, 1), o instanceof R4 && t.delete(o.compartment);
    }
    if (i.set(o, l), Array.isArray(o))
      for (let c of o)
        s(c, l);
    else if (o instanceof R4) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      t.set(o.compartment, c), s(c, l);
    } else if (o instanceof $S)
      s(o.inner, o.prec);
    else if (o instanceof On)
      r[l].push(o), o.provides && s(o.provides, l);
    else if (o instanceof K0)
      r[l].push(o), o.facet.extensions && s(o.facet.extensions, Gl.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, l);
    }
  }
  return s(n, Gl.default), r.reduce((o, l) => o.concat(l));
}
function Bh(n, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, r = n.status[t];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  n.status[t] = 4;
  let i = n.computeSlot(n, n.config.dynamicSlots[t]);
  return n.status[t] = 2 | i;
}
function Zp(n, e) {
  return e & 1 ? n.config.staticValues[e >> 1] : n.values[e >> 1];
}
const qS = /* @__PURE__ */ xe.define(), P4 = /* @__PURE__ */ xe.define({
  combine: (n) => n.some((e) => e),
  static: !0
}), WS = /* @__PURE__ */ xe.define({
  combine: (n) => n.length ? n[0] : void 0,
  static: !0
}), jS = /* @__PURE__ */ xe.define(), US = /* @__PURE__ */ xe.define(), KS = /* @__PURE__ */ xe.define(), GS = /* @__PURE__ */ xe.define({
  combine: (n) => n.length ? n[0] : !1
});
class vo {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new HL();
  }
}
class HL {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new vo(this, e);
  }
}
class $L {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new Xe(this, e);
  }
}
class Xe {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new Xe(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new $L(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let r = [];
    for (let i of e) {
      let s = i.map(t);
      s && r.push(s);
    }
    return r;
  }
}
Xe.reconfigure = /* @__PURE__ */ Xe.define();
Xe.appendConfig = /* @__PURE__ */ Xe.define();
let ur = class Xu {
  constructor(e, t, r, i, s, o) {
    this.startState = e, this.changes = t, this.selection = r, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, r && HS(r, t.newLength), s.some((l) => l.type == Xu.time) || (this.annotations = s.concat(Xu.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, r, i, s, o) {
    return new Xu(e, t, r, i, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(Xu.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
};
ur.time = /* @__PURE__ */ vo.define();
ur.userEvent = /* @__PURE__ */ vo.define();
ur.addToHistory = /* @__PURE__ */ vo.define();
ur.remote = /* @__PURE__ */ vo.define();
function VL(n, e) {
  let t = [];
  for (let r = 0, i = 0; ; ) {
    let s, o;
    if (r < n.length && (i == e.length || e[i] >= n[r]))
      s = n[r++], o = n[r++];
    else if (i < e.length)
      s = e[i++], o = e[i++];
    else
      return t;
    !t.length || t[t.length - 1] < s ? t.push(s, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function YS(n, e, t) {
  var r;
  let i, s, o;
  return t ? (i = e.changes, s = wn.empty(e.changes.length), o = n.changes.compose(e.changes)) : (i = e.changes.map(n.changes), s = n.changes.mapDesc(e.changes, !0), o = n.changes.compose(i)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (r = n.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: Xe.mapEffects(n.effects, i).concat(Xe.mapEffects(e.effects, s)),
    annotations: n.annotations.length ? n.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: n.scrollIntoView || e.scrollIntoView
  };
}
function _4(n, e, t) {
  let r = e.selection, i = gc(e.annotations);
  return e.userEvent && (i = i.concat(ur.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof wn ? e.changes : wn.of(e.changes || [], t, n.facet(WS)),
    selection: r && (r instanceof G ? r : G.single(r.anchor, r.head)),
    effects: gc(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function JS(n, e, t) {
  let r = _4(n, e.length ? e[0] : {}, n.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1);
    let o = !!e[s].sequential;
    r = YS(r, _4(n, e[s], o ? r.changes.newLength : n.doc.length), o);
  }
  let i = ur.create(n, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return WL(t ? qL(i) : i);
}
function qL(n) {
  let e = n.startState, t = !0;
  for (let i of e.facet(jS)) {
    let s = i(n);
    if (s === !1) {
      t = !1;
      break;
    }
    Array.isArray(s) && (t = t === !0 ? s : VL(t, s));
  }
  if (t !== !0) {
    let i, s;
    if (t === !1)
      s = n.changes.invertedDesc, i = wn.empty(e.doc.length);
    else {
      let o = n.changes.filter(t);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    n = ur.create(e, i, n.selection && n.selection.map(s), Xe.mapEffects(n.effects, s), n.annotations, n.scrollIntoView);
  }
  let r = e.facet(US);
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](n);
    s instanceof ur ? n = s : Array.isArray(s) && s.length == 1 && s[0] instanceof ur ? n = s[0] : n = JS(e, gc(s), !1);
  }
  return n;
}
function WL(n) {
  let e = n.startState, t = e.facet(KS), r = n;
  for (let i = t.length - 1; i >= 0; i--) {
    let s = t[i](n);
    s && Object.keys(s).length && (r = YS(r, _4(e, s, n.changes.newLength), !0));
  }
  return r == n ? n : ur.create(e, n.changes, n.selection, r.effects, r.annotations, r.scrollIntoView);
}
const jL = [];
function gc(n) {
  return n == null ? jL : Array.isArray(n) ? n : [n];
}
var Wt = /* @__PURE__ */ (function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
})(Wt || (Wt = {}));
const UL = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let L4;
try {
  L4 = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function KL(n) {
  if (L4)
    return L4.test(n);
  for (let e = 0; e < n.length; e++) {
    let t = n[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || UL.test(t)))
      return !0;
  }
  return !1;
}
function GL(n) {
  return (e) => {
    if (!/\S/.test(e))
      return Wt.Space;
    if (KL(e))
      return Wt.Word;
    for (let t = 0; t < n.length; t++)
      if (e.indexOf(n[t]) > -1)
        return Wt.Word;
    return Wt.Other;
  };
}
let jt = class Ti {
  constructor(e, t, r, i, s, o) {
    this.config = e, this.doc = t, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      Bh(this, l << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Bh(this, r), Zp(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return JS(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: r, compartments: i } = t;
    for (let l of e.effects)
      l.is(Nc.reconfigure) ? (t && (i = /* @__PURE__ */ new Map(), t.compartments.forEach((a, c) => i.set(c, a)), t = null), i.set(l.value.compartment, l.value.extension)) : l.is(Xe.reconfigure) ? (t = null, r = l.value) : l.is(Xe.appendConfig) && (t = null, r = gc(r).concat(l.value));
    let s;
    t ? s = e.startState.values.slice() : (t = S6.resolve(r, i, this), s = new Ti(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (a, c) => c.reconfigure(a, this), null).values);
    let o = e.startState.facet(P4) ? e.newSelection : e.newSelection.asSingle();
    new Ti(t, e.newDoc, o, s, (l, a) => a.update(l, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: G.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, r = e(t.ranges[0]), i = this.changes(r.changes), s = [r.range], o = gc(r.effects);
    for (let l = 1; l < t.ranges.length; l++) {
      let a = e(t.ranges[l]), c = this.changes(a.changes), u = c.map(i);
      for (let f = 0; f < l; f++)
        s[f] = s[f].map(u);
      let h = i.mapDesc(c, !0);
      s.push(a.range.map(h)), i = i.compose(u), o = Xe.mapEffects(o, u).concat(Xe.mapEffects(gc(a.effects), h));
    }
    return {
      changes: i,
      selection: G.create(s, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof wn ? e : wn.of(e, this.doc.length, this.facet(Ti.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return ft.of(e.split(this.facet(Ti.lineSeparator) || O4));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (Bh(this, t), Zp(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof On && this.config.address[i.id] != null && (t[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = r[s], l = e[s];
          i.push(o.init((a) => o.spec.fromJSON(l, a)));
        }
    }
    return Ti.create({
      doc: e.doc,
      selection: G.fromJSON(e.selection),
      extensions: t.extensions ? i.concat([t.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = S6.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof ft ? e.doc : ft.of((e.doc || "").split(t.staticFacet(Ti.lineSeparator) || O4)), i = e.selection ? e.selection instanceof G ? e.selection : G.single(e.selection.anchor, e.selection.head) : G.single(0);
    return HS(i, r.length), t.staticFacet(P4) || (i = i.asSingle()), new Ti(t, r, i, t.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Ti.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Ti.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(GS);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let r of this.facet(Ti.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > t.length ? r : t[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, r = -1) {
    let i = [];
    for (let s of this.facet(qS))
      for (let o of s(this, t, r))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return GL(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: r, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - r, l = e - r;
    for (; o > 0; ) {
      let a = zn(t, o, !1);
      if (s(t.slice(a, o)) != Wt.Word)
        break;
      o = a;
    }
    for (; l < i; ) {
      let a = zn(t, l);
      if (s(t.slice(l, a)) != Wt.Word)
        break;
      l = a;
    }
    return o == l ? null : G.range(o + r, l + r);
  }
};
jt.allowMultipleSelections = P4;
jt.tabSize = /* @__PURE__ */ xe.define({
  combine: (n) => n.length ? n[0] : 4
});
jt.lineSeparator = WS;
jt.readOnly = GS;
jt.phrases = /* @__PURE__ */ xe.define({
  compare(n, e) {
    let t = Object.keys(n), r = Object.keys(e);
    return t.length == r.length && t.every((i) => n[i] == e[i]);
  }
});
jt.languageData = qS;
jt.changeFilter = jS;
jt.transactionFilter = US;
jt.transactionExtender = KS;
Nc.reconfigure = /* @__PURE__ */ Xe.define();
function Ts(n, e, t = {}) {
  let r = {};
  for (let i of n)
    for (let s of Object.keys(i)) {
      let o = i[s], l = r[s];
      if (l === void 0)
        r[s] = o;
      else if (!(l === o || o === void 0)) if (Object.hasOwnProperty.call(t, s))
        r[s] = t[s](l, o);
      else
        throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class ga {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return xf.create(e, t, this);
  }
}
ga.prototype.startSide = ga.prototype.endSide = 0;
ga.prototype.point = !1;
ga.prototype.mapMode = Bn.TrackDel;
class xf {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.value = r;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new xf(e, t, r);
  }
}
function B4(n, e) {
  return n.from - e.from || n.value.startSide - e.value.startSide;
}
class c3 {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, r, i = 0) {
    let s = r ? this.to : this.from;
    for (let o = i, l = s.length; ; ) {
      if (o == l)
        return o;
      let a = o + l >> 1, c = s[a] - e || (r ? this.value[a].endSide : this.value[a].startSide) - t;
      if (a == o)
        return c >= 0 ? o : l;
      c >= 0 ? l = a : o = a + 1;
    }
  }
  between(e, t, r, i) {
    for (let s = this.findIndex(t, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, t) {
    let r = [], i = [], s = [], o = -1, l = -1;
    for (let a = 0; a < this.value.length; a++) {
      let c = this.value[a], u = this.from[a] + e, h = this.to[a] + e, f, d;
      if (u == h) {
        let p = t.mapPos(u, c.startSide, c.mapMode);
        if (p == null || (f = d = p, c.startSide != c.endSide && (d = t.mapPos(u, c.endSide), d < f)))
          continue;
      } else if (f = t.mapPos(u, c.startSide), d = t.mapPos(h, c.endSide), f > d || f == d && c.startSide > 0 && c.endSide <= 0)
        continue;
      (d - f || c.endSide - c.startSide) < 0 || (o < 0 && (o = f), c.point && (l = Math.max(l, d - f)), r.push(c), i.push(f - o), s.push(d - o));
    }
    return { mapped: r.length ? new c3(i, s, r, l) : null, pos: o };
  }
}
class ut {
  constructor(e, t, r, i) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = r, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, t, r, i) {
    return new ut(e, t, r, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: r = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (r && (t = t.slice().sort(B4)), this.isEmpty)
      return t.length ? ut.of(t) : this;
    let l = new XS(this, null, -1).goto(0), a = 0, c = [], u = new lo();
    for (; l.value || a < t.length; )
      if (a < t.length && (l.from - t[a].from || l.startSide - t[a].value.startSide) >= 0) {
        let h = t[a++];
        u.addInner(h.from, h.to, h.value) || c.push(h);
      } else l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (a == t.length || this.chunkEnd(l.chunkIndex) < t[a].from) && (!o || i > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) && u.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || i > l.to || s < l.from || o(l.from, l.to, l.value)) && (u.addInner(l.from, l.to, l.value) || c.push(xf.create(l.from, l.to, l.value))), l.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? ut.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: i, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], r = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], a = this.chunk[o], c = e.touchesRange(l, l + a.length);
      if (c === !1)
        i = Math.max(i, a.maxPoint), t.push(a), r.push(e.mapPos(l));
      else if (c === !0) {
        let { mapped: u, pos: h } = a.map(l, e);
        u && (i = Math.max(i, u.maxPoint), t.push(u), r.push(h));
      }
    }
    let s = this.nextLayer.map(e);
    return t.length == 0 ? s : new ut(r, t, s || ut.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (t >= s && e <= s + o.length && o.between(s, e - s, t - s, r) === !1)
          return;
      }
      this.nextLayer.between(e, t, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return kf.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return kf.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, r, i, s = -1) {
    let o = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), l = t.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), a = C6(o, l, r), c = new Pu(o, a, s), u = new Pu(l, a, s);
    r.iterGaps((h, f, d) => M6(c, h, u, f, d, i)), r.empty && r.length == 0 && M6(c, 0, u, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, r = 0, i) {
    i == null && (i = 999999999);
    let s = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0), o = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let l = C6(s, o), a = new Pu(s, l, 0).goto(r), c = new Pu(o, l, 0).goto(r);
    for (; ; ) {
      if (a.to != c.to || !z4(a.active, c.active) || a.point && (!c.point || !a.point.eq(c.point)))
        return !1;
      if (a.to > i)
        return !0;
      a.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, r, i, s = -1) {
    let o = new Pu(e, null, s).goto(t), l = t, a = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, r);
      if (o.point) {
        let u = o.activeForPoint(o.to), h = o.pointFrom < t ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, a);
        i.point(l, c, o.point, u, h, o.pointRank), a = Math.min(o.openEnd(c), u.length);
      } else c > l && (i.span(l, c, o.active, a), a = o.openEnd(c));
      if (o.to > r)
        return a + (o.point && o.to > r ? 1 : 0);
      l = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let r = new lo();
    for (let i of e instanceof xf ? [e] : t ? YL(e) : e)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return ut.empty;
    let t = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != ut.empty; i = i.nextLayer)
        t = new ut(i.chunkPos, i.chunk, t, Math.max(i.maxPoint, t.maxPoint));
    return t;
  }
}
ut.empty = /* @__PURE__ */ new ut([], [], null, -1);
function YL(n) {
  if (n.length > 1)
    for (let e = n[0], t = 1; t < n.length; t++) {
      let r = n[t];
      if (B4(e, r) > 0)
        return n.slice().sort(B4);
      e = r;
    }
  return n;
}
ut.empty.nextLayer = ut.empty;
class lo {
  finishChunk(e) {
    this.chunks.push(new c3(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, r) {
    this.addInner(e, t, r) || (this.nextLayer || (this.nextLayer = new lo())).add(e, t, r);
  }
  /**
  @internal
  */
  addInner(e, t, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = t, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let r = t.value.length - 1;
    return this.last = t.value[r], this.lastFrom = t.from[r] + e, this.lastTo = t.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(ut.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = ut.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function C6(n, e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let s of n)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let l = r.get(s.chunk[o]);
      l != null && (t ? t.mapPos(l) : l) == s.chunkPos[o] && !t?.touchesRange(l, l + s.chunk[o].length) && i.add(s.chunk[o]);
    }
  return i;
}
class XS {
  constructor(e, t, r, i = 0) {
    this.layer = e, this.skip = t, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], r = e + t.from[this.rangeIndex];
        if (this.from = r, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class kf {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, r = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && i.push(new XS(o, t, r, s));
    return i.length == 1 ? i[0] : new kf(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let r of this.heap)
      r.goto(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Ag(this.heap, r);
    return this.next(), this;
  }
  forward(e, t) {
    for (let r of this.heap)
      r.forward(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Ag(this.heap, r);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Ag(this.heap, 0);
    }
  }
}
function Ag(n, e) {
  for (let t = n[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= n.length)
      break;
    let i = n[r];
    if (r + 1 < n.length && i.compare(n[r + 1]) >= 0 && (i = n[r + 1], r++), t.compare(i) < 0)
      break;
    n[r] = t, n[e] = i, e = r;
  }
}
class Pu {
  constructor(e, t, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = kf.from(e, t, r);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Gd(this.active, e), Gd(this.activeTo, e), Gd(this.activeRank, e), this.minActive = T6(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: r, to: i, rank: s } = this.cursor;
    for (; t < this.activeRank.length && (s - this.activeRank[t] || i - this.activeTo[t]) > 0; )
      t++;
    Yd(this.active, t, r), Yd(this.activeTo, t, i), Yd(this.activeRank, t, s), e && Yd(e, t, this.cursor.from), this.minActive = T6(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && Gd(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(r), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && t.push(this.active[r]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      t++;
    return t;
  }
}
function M6(n, e, t, r, i, s) {
  n.goto(e), t.goto(r);
  let o = r + i, l = r, a = r - e;
  for (; ; ) {
    let c = n.to + a - t.to, u = c || n.endSide - t.endSide, h = u < 0 ? n.to + a : t.to, f = Math.min(h, o);
    if (n.point || t.point ? n.point && t.point && (n.point == t.point || n.point.eq(t.point)) && z4(n.activeForPoint(n.to), t.activeForPoint(t.to)) || s.comparePoint(l, f, n.point, t.point) : f > l && !z4(n.active, t.active) && s.compareRange(l, f, n.active, t.active), h > o)
      break;
    (c || n.openEnd != t.openEnd) && s.boundChange && s.boundChange(h), l = h, u <= 0 && n.next(), u >= 0 && t.next();
  }
}
function z4(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] != e[t] && !n[t].eq(e[t]))
      return !1;
  return !0;
}
function Gd(n, e) {
  for (let t = e, r = n.length - 1; t < r; t++)
    n[t] = n[t + 1];
  n.pop();
}
function Yd(n, e, t) {
  for (let r = n.length - 1; r >= e; r--)
    n[r + 1] = n[r];
  n[e] = t;
}
function T6(n, e) {
  let t = -1, r = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - r || n[i].endSide - n[t].endSide) < 0 && (t = i, r = e[i]);
  return t;
}
function eu(n, e, t = n.length) {
  let r = 0;
  for (let i = 0; i < t && i < n.length; )
    n.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = zn(n, i));
  return r;
}
function F4(n, e, t, r) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == n.length)
      break;
    s += n.charCodeAt(i) == 9 ? t - s % t : 1, i = zn(n, i);
  }
  return r === !0 ? -1 : n.length;
}
const H4 = "ͼ", A6 = typeof Symbol > "u" ? "__" + H4 : Symbol.for(H4), $4 = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), O6 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class al {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: r } = t || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, l, a, c) {
      let u = [], h = /^@(\w+)\b/.exec(o[0]), f = h && h[1] == "keyframes";
      if (h && l == null) return a.push(o[0] + ";");
      for (let d in l) {
        let p = l[d];
        if (/&/.test(d))
          s(
            d.split(/,\s*/).map((m) => o.map((g) => m.replace(/&/, g))).reduce((m, g) => m.concat(g)),
            p,
            a
          );
        else if (p && typeof p == "object") {
          if (!h) throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          s(i(d), p, u, f);
        } else p != null && u.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + p + ";");
      }
      (u.length || f) && a.push((r && !h && !c ? o.map(r) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e) s(i(o), e[o], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = O6[A6] || 1;
    return O6[A6] = e + 1, H4 + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, r) {
    let i = e[$4], s = r && r.nonce;
    i ? s && i.setNonce(s) : i = new JL(e, s), i.mount(Array.isArray(t) ? t : [t], e);
  }
}
let E6 = /* @__PURE__ */ new Map();
class JL {
  constructor(e, t) {
    let r = e.ownerDocument || e, i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = E6.get(r);
      if (s) return e[$4] = s;
      this.sheet = new i.CSSStyleSheet(), E6.set(r, this);
    } else
      this.styleTag = r.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[$4] = this;
  }
  mount(e, t) {
    let r = this.sheet, i = 0, s = 0;
    for (let o = 0; o < e.length; o++) {
      let l = e[o], a = this.modules.indexOf(l);
      if (a < s && a > -1 && (this.modules.splice(a, 1), s--, a = -1), a == -1) {
        if (this.modules.splice(s++, 0, l), r) for (let c = 0; c < l.rules.length; c++)
          r.insertRule(l.rules[c], i++);
      } else {
        for (; s < a; ) i += this.modules[s++].rules.length;
        i += l.rules.length, s++;
      }
    }
    if (r)
      t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
    else {
      let o = "";
      for (let a = 0; a < this.modules.length; a++)
        o += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = o;
      let l = t.head || t;
      this.styleTag.parentNode != l && l.insertBefore(this.styleTag, l.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var ao = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Sf = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, XL = typeof navigator < "u" && /Mac/.test(navigator.platform), ZL = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Pn = 0; Pn < 10; Pn++) ao[48 + Pn] = ao[96 + Pn] = String(Pn);
for (var Pn = 1; Pn <= 24; Pn++) ao[Pn + 111] = "F" + Pn;
for (var Pn = 65; Pn <= 90; Pn++)
  ao[Pn] = String.fromCharCode(Pn + 32), Sf[Pn] = String.fromCharCode(Pn);
for (var Og in ao) Sf.hasOwnProperty(Og) || (Sf[Og] = ao[Og]);
function ZS(n) {
  var e = XL && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || ZL && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? Sf : ao)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function Tt() {
  var n = arguments[0];
  typeof n == "string" && (n = document.createElement(n));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) {
      var i = t[r];
      typeof i == "string" ? n.setAttribute(r, i) : i != null && (n[r] = i);
    }
    e++;
  }
  for (; e < arguments.length; e++) QS(n, arguments[e]);
  return n;
}
function QS(n, e) {
  if (typeof e == "string")
    n.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    n.appendChild(e);
  else if (Array.isArray(e))
    for (var t = 0; t < e.length; t++) QS(n, e[t]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
function Cf(n) {
  let e;
  return n.nodeType == 11 ? e = n.getSelection ? n : n.ownerDocument : e = n, e.getSelection();
}
function V4(n, e) {
  return e ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function G0(n, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return V4(n, e.anchorNode);
  } catch {
    return !1;
  }
}
function Mf(n) {
  return n.nodeType == 3 ? ba(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function zh(n, e, t, r) {
  return t ? I6(n, e, t, r, -1) || I6(n, e, t, r, 1) : !1;
}
function ya(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}
function Qp(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
function I6(n, e, t, r, i) {
  for (; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : ws(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let s = n.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = ya(n) + (i < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (i < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      e = i < 0 ? ws(n) : 0;
    } else
      return !1;
  }
}
function ws(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function t1(n, e) {
  let t = e ? n.left : n.right;
  return { left: t, right: t, top: n.top, bottom: n.bottom };
}
function QL(n) {
  let e = n.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function eC(n, e) {
  let t = e.width / n.offsetWidth, r = e.height / n.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - n.offsetWidth) < 1) && (t = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - n.offsetHeight) < 1) && (r = 1), { scaleX: t, scaleY: r };
}
function eB(n, e, t, r, i, s, o, l) {
  let a = n.ownerDocument, c = a.defaultView || window;
  for (let u = n, h = !1; u && !h; )
    if (u.nodeType == 1) {
      let f, d = u == a.body, p = 1, m = 1;
      if (d)
        f = QL(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let w = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: m } = eC(u, w)), f = {
          left: w.left,
          right: w.left + u.clientWidth * p,
          top: w.top,
          bottom: w.top + u.clientHeight * m
        };
      }
      let g = 0, b = 0;
      if (i == "nearest")
        e.top < f.top ? (b = e.top - (f.top + o), t > 0 && e.bottom > f.bottom + b && (b = e.bottom - f.bottom + o)) : e.bottom > f.bottom && (b = e.bottom - f.bottom + o, t < 0 && e.top - b < f.top && (b = e.top - (f.top + o)));
      else {
        let w = e.bottom - e.top, k = f.bottom - f.top;
        b = (i == "center" && w <= k ? e.top + w / 2 - k / 2 : i == "start" || i == "center" && t < 0 ? e.top - o : e.bottom - k + o) - f.top;
      }
      if (r == "nearest" ? e.left < f.left ? (g = e.left - (f.left + s), t > 0 && e.right > f.right + g && (g = e.right - f.right + s)) : e.right > f.right && (g = e.right - f.right + s, t < 0 && e.left < f.left + g && (g = e.left - (f.left + s))) : g = (r == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : r == "start" == l ? e.left - s : e.right - (f.right - f.left) + s) - f.left, g || b)
        if (d)
          c.scrollBy(g, b);
        else {
          let w = 0, k = 0;
          if (b) {
            let C = u.scrollTop;
            u.scrollTop += b / m, k = (u.scrollTop - C) * m;
          }
          if (g) {
            let C = u.scrollLeft;
            u.scrollLeft += g / p, w = (u.scrollLeft - C) * p;
          }
          e = {
            left: e.left - w,
            top: e.top - k,
            right: e.right - w,
            bottom: e.bottom - k
          }, w && Math.abs(w - g) < 1 && (r = "nearest"), k && Math.abs(k - b) < 1 && (i = "nearest");
        }
      if (d)
        break;
      (e.top < f.top || e.bottom > f.bottom || e.left < f.left || e.right > f.right) && (e = {
        left: Math.max(e.left, f.left),
        right: Math.min(e.right, f.right),
        top: Math.max(e.top, f.top),
        bottom: Math.min(e.bottom, f.bottom)
      }), u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function tB(n) {
  let e = n.ownerDocument, t, r;
  for (let i = n.parentNode; i && !(i == e.body || t && r); )
    if (i.nodeType == 1)
      !r && i.scrollHeight > i.clientHeight && (r = i), !t && i.scrollWidth > i.clientWidth && (t = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: t, y: r };
}
class nB {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: r } = e;
    this.set(t, Math.min(e.anchorOffset, t ? ws(t) : 0), r, Math.min(e.focusOffset, r ? ws(r) : 0));
  }
  set(e, t, r, i) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = r, this.focusOffset = i;
  }
}
let Ka = null;
function tC(n) {
  if (n.setActive)
    return n.setActive();
  if (Ka)
    return n.focus(Ka);
  let e = [];
  for (let t = n; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (n.focus(Ka == null ? {
    get preventScroll() {
      return Ka = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ka) {
    Ka = !1;
    for (let t = 0; t < e.length; ) {
      let r = e[t++], i = e[t++], s = e[t++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
}
let D6;
function ba(n, e, t = e) {
  let r = D6 || (D6 = document.createRange());
  return r.setEnd(n, t), r.setStart(n, e), r;
}
function yc(n, e, t, r) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let s = new KeyboardEvent("keydown", i);
  s.synthetic = !0, n.dispatchEvent(s);
  let o = new KeyboardEvent("keyup", i);
  return o.synthetic = !0, n.dispatchEvent(o), s.defaultPrevented || o.defaultPrevented;
}
function rB(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function nC(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function iB(n, e) {
  let t = e.focusNode, r = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, ws(t)); ; )
    if (r) {
      if (t.nodeType != 1)
        return !1;
      let i = t.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (t = i, r = ws(t));
    } else {
      if (t == n)
        return !0;
      r = ya(t), t = t.parentNode;
    }
}
function rC(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
function iC(n, e) {
  for (let t = n, r = e; ; ) {
    if (t.nodeType == 3 && r > 0)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r - 1], r = ws(t);
    } else if (t.parentNode && !Qp(t))
      r = ya(t), t = t.parentNode;
    else
      return null;
  }
}
function sC(n, e) {
  for (let t = n, r = e; ; ) {
    if (t.nodeType == 3 && r < t.nodeValue.length)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r], r = 0;
    } else if (t.parentNode && !Qp(t))
      r = ya(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
class Un {
  constructor(e, t, r = !0) {
    this.node = e, this.offset = t, this.precise = r;
  }
  static before(e, t) {
    return new Un(e.parentNode, ya(e), t);
  }
  static after(e, t) {
    return new Un(e.parentNode, ya(e) + 1, t);
  }
}
const u3 = [];
class Et {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return t;
      t += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let r = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
            let l = Et.get(s);
            (!l || !l.parent && l.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : r.firstChild, t && !t.written && t.node == r && s != o.dom && (t.written = !0), o.dom.parentNode == r)
          for (; s && s != o.dom; )
            s = N6(s);
        else
          r.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : r.firstChild, s && t && t.node == r && (t.written = !0); s; )
        s = N6(s);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, t), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[t];
    else {
      let i = ws(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !Et.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == r)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, r = 0) {
    let i = -1, s = -1, o = -1, l = -1;
    for (let a = 0, c = r, u = r; a < this.children.length; a++) {
      let h = this.children[a], f = c + h.length;
      if (c < e && f > t)
        return h.domBoundsAround(e, t, c);
      if (f >= e && i == -1 && (i = a, s = c), c > t && h.dom.parentNode == this.dom) {
        o = a, l = u;
        break;
      }
      u = f, c = f + h.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? r + this.length : l,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, r = u3) {
    this.markDirty();
    for (let i = e; i < t; i++) {
      let s = this.children[i];
      s.parent == this && r.indexOf(s) < 0 && s.destroy();
    }
    r.length < 250 ? this.children.splice(e, t - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(t));
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new oC(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, r, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
Et.prototype.breakAfter = 0;
function N6(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class oC {
  constructor(e, t, r) {
    this.children = e, this.pos = t, this.i = r, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function lC(n, e, t, r, i, s, o, l, a) {
  let { children: c } = n, u = c.length ? c[e] : null, h = s.length ? s[s.length - 1] : null, f = h ? h.breakAfter : o;
  if (!(e == r && u && !o && !f && s.length < 2 && u.merge(t, i, s.length ? h : null, t == 0, l, a))) {
    if (r < c.length) {
      let d = c[r];
      d && (i < d.length || d.breakAfter && h?.breakAfter) ? (e == r && (d = d.split(i), i = 0), !f && h && d.merge(0, i, h, !0, 0, a) ? s[s.length - 1] = d : ((i || d.children.length && !d.children[0].length) && d.merge(0, i, null, !1, 0, a), s.push(d))) : d?.breakAfter && (h ? h.breakAfter = 1 : o = 1), r++;
    }
    for (u && (u.breakAfter = o, t > 0 && (!o && s.length && u.merge(t, u.length, s[0], !1, l, 0) ? u.breakAfter = s.shift().breakAfter : (t < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(t, u.length, null, !1, l, 0), e++)); e < r && s.length; )
      if (c[r - 1].become(s[s.length - 1]))
        r--, s.pop(), a = s.length ? 0 : l;
      else if (c[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : a;
      else
        break;
    !s.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, l, a) && e--, (e < r || s.length) && n.replaceChildren(e, r, s);
  }
}
function aC(n, e, t, r, i, s) {
  let o = n.childCursor(), { i: l, off: a } = o.findPos(t, 1), { i: c, off: u } = o.findPos(e, -1), h = e - t;
  for (let f of r)
    h += f.length;
  n.length += h, lC(n, c, u, l, a, r, 0, i, s);
}
let Sr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, q4 = typeof document < "u" ? document : { documentElement: { style: {} } };
const W4 = /* @__PURE__ */ /Edge\/(\d+)/.exec(Sr.userAgent), cC = /* @__PURE__ */ /MSIE \d/.test(Sr.userAgent), j4 = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Sr.userAgent), n1 = !!(cC || j4 || W4), R6 = !n1 && /* @__PURE__ */ /gecko\/(\d+)/i.test(Sr.userAgent), Eg = !n1 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Sr.userAgent), sB = "webkitFontSmoothing" in q4.documentElement.style, uC = !n1 && /* @__PURE__ */ /Apple Computer/.test(Sr.vendor), P6 = uC && (/* @__PURE__ */ /Mobile\/\w+/.test(Sr.userAgent) || Sr.maxTouchPoints > 2);
var we = {
  mac: P6 || /* @__PURE__ */ /Mac/.test(Sr.platform),
  windows: /* @__PURE__ */ /Win/.test(Sr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Sr.platform),
  ie: n1,
  ie_version: cC ? q4.documentMode || 6 : j4 ? +j4[1] : W4 ? +W4[1] : 0,
  gecko: R6,
  gecko_version: R6 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Sr.userAgent) || [0, 0])[1] : 0,
  chrome: !!Eg,
  chrome_version: Eg ? +Eg[1] : 0,
  ios: P6,
  android: /* @__PURE__ */ /Android\b/.test(Sr.userAgent),
  safari: uC,
  webkit_version: sB ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Sr.userAgent) || [0, 0])[1] : 0,
  tabSize: q4.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const oB = 256;
class Bi extends Et {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, r) {
    return this.flags & 8 || r && (!(r instanceof Bi) || this.length - (t - e) + r.length > oB || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new Bi(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Un(this.dom, e);
  }
  domBoundsAround(e, t, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return lB(this.dom, e, t);
  }
}
class co extends Et {
  constructor(e, t = [], r = 0) {
    super(), this.mark = e, this.children = t, this.length = r;
    for (let i of t)
      i.setParent(this);
  }
  setAttrs(e) {
    if (nC(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof co && r.mark.eq(this.mark)) || e && s <= 0 || t < this.length && o <= 0) ? !1 : (aC(this, e, t, r ? r.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], r = 0, i = -1, s = 0;
    for (let l of this.children) {
      let a = r + l.length;
      a > e && t.push(r < e ? l.split(e - r) : l), i < 0 && r >= e && (i = s), r = a, s++;
    }
    let o = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new co(this.mark, t, o);
  }
  domAtPos(e) {
    return hC(this, e);
  }
  coordsAt(e, t) {
    return dC(this, e, t);
  }
}
function lB(n, e, t) {
  let r = n.nodeValue.length;
  e > r && (e = r);
  let i = e, s = e, o = 0;
  e == 0 && t < 0 || e == r && t >= 0 ? we.chrome || we.gecko || (e ? (i--, o = 1) : s < r && (s++, o = -1)) : t < 0 ? i-- : s < r && s++;
  let l = ba(n, i, s).getClientRects();
  if (!l.length)
    return null;
  let a = l[(o ? o < 0 : t >= 0) ? 0 : l.length - 1];
  return we.safari && !o && a.width == 0 && (a = Array.prototype.find.call(l, (c) => c.width) || a), o ? t1(a, o < 0) : a || null;
}
class Yo extends Et {
  static create(e, t, r) {
    return new Yo(e, t, r);
  }
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let t = Yo.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof Yo) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof Yo && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return ft.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, r = t && t.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : ft.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Un.before(this.dom) : Un.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    if (r)
      return r;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let l = o ? i.length - 1 : 0; s = i[l], !(e > 0 ? l == 0 : l == i.length - 1 || s.top < s.bottom); l += o ? -1 : 1)
      ;
    return t1(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Rc extends Et {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Rc && e.side == this.side;
  }
  split() {
    return new Rc(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Un.before(this.dom) : Un.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return ft.empty;
  }
  get isHidden() {
    return !0;
  }
}
Bi.prototype.children = Yo.prototype.children = Rc.prototype.children = u3;
function hC(n, e) {
  let t = n.dom, { children: r } = n, i = 0;
  for (let s = 0; i < r.length; i++) {
    let o = r[i], l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == t)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = r[s - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < r.length; s++) {
    let o = r[s];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new Un(t, 0);
}
function fC(n, e, t) {
  let r, { children: i } = n;
  t > 0 && e instanceof co && i.length && (r = i[i.length - 1]) instanceof co && r.mark.eq(e.mark) ? fC(r, e.children[0], t - 1) : (i.push(e), e.setParent(n)), n.length += e.length;
}
function dC(n, e, t) {
  let r = null, i = -1, s = null, o = -1;
  function l(c, u) {
    for (let h = 0, f = 0; h < c.children.length && f <= u; h++) {
      let d = c.children[h], p = f + d.length;
      p >= u && (d.children.length ? l(d, u - f) : (!s || s.isHidden && (t > 0 || cB(s, d))) && (p > u || f == p && d.getSide() > 0) ? (s = d, o = u - f) : (f < u || f == p && d.getSide() < 0 && !d.isHidden) && (r = d, i = u - f)), f = p;
    }
  }
  l(n, e);
  let a = (t < 0 ? r : s) || r || s;
  return a ? a.coordsAt(Math.max(0, a == r ? i : o), t) : aB(n);
}
function aB(n) {
  let e = n.dom.lastChild;
  if (!e)
    return n.dom.getBoundingClientRect();
  let t = Mf(e);
  return t[t.length - 1] || null;
}
function cB(n, e) {
  let t = n.coordsAt(0, 1), r = e.coordsAt(0, 1);
  return t && r && r.top < t.bottom;
}
function U4(n, e) {
  for (let t in n)
    t == "class" && e.class ? e.class += " " + n.class : t == "style" && e.style ? e.style += ";" + n.style : e[t] = n[t];
  return e;
}
const _6 = /* @__PURE__ */ Object.create(null);
function em(n, e, t) {
  if (n == e)
    return !0;
  n || (n = _6), e || (e = _6);
  let r = Object.keys(n), i = Object.keys(e);
  if (r.length - (t && r.indexOf(t) > -1 ? 1 : 0) != i.length - (t && i.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let s of r)
    if (s != t && (i.indexOf(s) == -1 || n[s] !== e[s]))
      return !1;
  return !0;
}
function K4(n, e, t) {
  let r = !1;
  if (e)
    for (let i in e)
      t && i in t || (r = !0, i == "style" ? n.style.cssText = "" : n.removeAttribute(i));
  if (t)
    for (let i in t)
      e && e[i] == t[i] || (r = !0, i == "style" ? n.style.cssText = t[i] : n.setAttribute(i, t[i]));
  return r;
}
function uB(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < n.attributes.length; t++) {
    let r = n.attributes[t];
    e[r.name] = r.value;
  }
  return e;
}
let wo = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
};
var hr = /* @__PURE__ */ (function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
})(hr || (hr = {}));
let He = class extends ga {
  constructor(e, t, r, i) {
    super(), this.startSide = e, this.endSide = t, this.widget = r, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new od(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return t += r && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new cl(e, t, t, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, r, i;
    if (e.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = pC(e, t);
      r = (s ? t ? -3e8 : -1 : 5e8) - 1, i = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new cl(e, r, i, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new ld(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return ut.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
};
He.none = ut.empty;
class od extends He {
  constructor(e) {
    let { start: t, end: r } = pC(e);
    super(t ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, r;
    return this == e || e instanceof od && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && em(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
od.prototype.point = !1;
class ld extends He {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof ld && this.spec.class == e.spec.class && em(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
ld.prototype.mapMode = Bn.TrackBefore;
ld.prototype.point = !0;
class cl extends He {
  constructor(e, t, r, i, s, o) {
    super(t, r, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? t <= 0 ? Bn.TrackBefore : Bn.TrackAfter : Bn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? hr.WidgetRange : this.startSide <= 0 ? hr.WidgetBefore : hr.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof cl && hB(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
cl.prototype.point = !0;
function pC(n, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: r } = n;
  return t == null && (t = n.inclusive), r == null && (r = n.inclusive), { start: t ?? e, end: r ?? e };
}
function hB(n, e) {
  return n == e || !!(n && e && n.compare(e));
}
function Y0(n, e, t, r = 0) {
  let i = t.length - 1;
  i >= 0 && t[i] + r >= n ? t[i] = Math.max(t[i], e) : t.push(n, e);
}
class dn extends Et {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, r, i, s, o) {
    if (r) {
      if (!(r instanceof dn))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), aC(this, e, t, r ? r.children.slice() : [], s, o), !0;
  }
  split(e) {
    let t = new dn();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: r, off: i } = this.childPos(e);
    i && (t.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let s = r; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    em(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    fC(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, r = e.spec.class;
    t && (this.attrs = U4(t, this.attrs || {})), r && (this.attrs = U4({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return hC(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var r;
    this.dom ? this.flags & 4 && (nC(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (K4(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let i = this.dom.lastChild;
    for (; i && Et.get(i) instanceof co; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = Et.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!we.ios || !this.children.some((s) => s instanceof Bi))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let r of this.children) {
      if (!(r instanceof Bi) || /[^ -~]/.test(r.text))
        return null;
      let i = Mf(r.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, t = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let r = dC(this, e, t);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = r.bottom - r.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return e instanceof dn && this.children.length == 0 && e.children.length == 0 && em(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let s = e.children[r], o = i + s.length;
      if (o >= t) {
        if (s instanceof dn)
          return s;
        if (o > t)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class no extends Et {
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof no) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Un.before(this.dom) : Un.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let r = new no(this.widget, t, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return u3;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : ft.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof no && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    return r || (this.widget instanceof G4 ? null : t1(this.dom.getBoundingClientRect(), this.length ? e == 0 : t <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: r } = this.deco;
    return t == r ? !1 : e < 0 ? t < 0 : r > 0;
  }
}
class G4 extends wo {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Fh {
  constructor(e, t, r, i) {
    this.doc = e, this.pos = t, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof no && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new dn()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Jd(new Rc(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof no) && this.getLine();
  }
  buildText(e, t, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - r)), this.getLine().append(Jd(new Bi(this.text.slice(this.textOff, this.textOff + i)), t), r), this.atCursorPos = !0, this.textOff += i, e -= i, r = 0;
    }
  }
  span(e, t, r, i) {
    this.buildText(t - e, r, i), this.pos = t, this.openStart < 0 && (this.openStart = i);
  }
  point(e, t, r, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof cl) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = t - e;
    if (r instanceof cl)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new no(r.widget || Pc.block, l, r));
      else {
        let a = Yo.create(r.widget || Pc.inline, l, l ? 0 : r.startSide), c = this.atCursorPos && !a.isEditable && s <= i.length && (e < t || r.startSide > 0), u = !a.isEditable && (e < t || s > i.length || r.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !c && !a.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (h.append(Jd(new Rc(1), i), s), s = i.length + Math.max(0, s - i.length)), h.append(Jd(a, i), s), this.atCursorPos = u, this.pendingBuffer = u ? e < t || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, r, i, s) {
    let o = new Fh(e, t, r, s);
    return o.openEnd = ut.spans(i, t, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Jd(n, e) {
  for (let t of e)
    n = new co(t, [n], n.length);
  return n;
}
class Pc extends wo {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
Pc.inline = /* @__PURE__ */ new Pc("span");
Pc.block = /* @__PURE__ */ new Pc("div");
var qt = /* @__PURE__ */ (function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
})(qt || (qt = {}));
const va = qt.LTR, h3 = qt.RTL;
function mC(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    e.push(1 << +n[t]);
  return e;
}
const fB = /* @__PURE__ */ mC("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), dB = /* @__PURE__ */ mC("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Y4 = /* @__PURE__ */ Object.create(null), Gi = [];
for (let n of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ n.charCodeAt(0), t = /* @__PURE__ */ n.charCodeAt(1);
  Y4[e] = t, Y4[t] = -e;
}
function gC(n) {
  return n <= 247 ? fB[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? dB[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
const pB = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Jo {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? h3 : va;
  }
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.level = r;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, r, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= t && l.to >= t) {
        if (l.level == r)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? l.from < t : l.to > t : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function yC(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++) {
    let r = n[t], i = e[t];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !yC(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const At = [];
function mB(n, e, t, r, i) {
  for (let s = 0; s <= r.length; s++) {
    let o = s ? r[s - 1].to : e, l = s < r.length ? r[s].from : t, a = s ? 256 : i;
    for (let c = o, u = a, h = a; c < l; c++) {
      let f = gC(n.charCodeAt(c));
      f == 512 ? f = u : f == 8 && h == 4 && (f = 16), At[c] = f == 4 ? 2 : f, f & 7 && (h = f), u = f;
    }
    for (let c = o, u = a, h = a; c < l; c++) {
      let f = At[c];
      if (f == 128)
        c < l - 1 && u == At[c + 1] && u & 24 ? f = At[c] = u : At[c] = 256;
      else if (f == 64) {
        let d = c + 1;
        for (; d < l && At[d] == 64; )
          d++;
        let p = c && u == 8 || d < t && At[d] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let m = c; m < d; m++)
          At[m] = p;
        c = d - 1;
      } else f == 8 && h == 1 && (At[c] = 1);
      u = f, f & 7 && (h = f);
    }
  }
}
function gB(n, e, t, r, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, l = 0, a = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e, u = o < r.length ? r[o].from : t;
    for (let h = c, f, d, p; h < u; h++)
      if (d = Y4[f = n.charCodeAt(h)])
        if (d < 0) {
          for (let m = l - 3; m >= 0; m -= 3)
            if (Gi[m + 1] == -d) {
              let g = Gi[m + 2], b = g & 2 ? i : g & 4 ? g & 1 ? s : i : 0;
              b && (At[h] = At[Gi[m]] = b), l = m;
              break;
            }
        } else {
          if (Gi.length == 189)
            break;
          Gi[l++] = h, Gi[l++] = f, Gi[l++] = a;
        }
      else if ((p = At[h]) == 2 || p == 1) {
        let m = p == i;
        a = m ? 0 : 1;
        for (let g = l - 3; g >= 0; g -= 3) {
          let b = Gi[g + 2];
          if (b & 2)
            break;
          if (m)
            Gi[g + 2] |= 2;
          else {
            if (b & 4)
              break;
            Gi[g + 2] |= 4;
          }
        }
      }
  }
}
function yB(n, e, t, r) {
  for (let i = 0, s = r; i <= t.length; i++) {
    let o = i ? t[i - 1].to : n, l = i < t.length ? t[i].from : e;
    for (let a = o; a < l; ) {
      let c = At[a];
      if (c == 256) {
        let u = a + 1;
        for (; ; )
          if (u == l) {
            if (i == t.length)
              break;
            u = t[i++].to, l = i < t.length ? t[i].from : e;
          } else if (At[u] == 256)
            u++;
          else
            break;
        let h = s == 1, f = (u < e ? At[u] : r) == 1, d = h == f ? h ? 1 : 2 : r;
        for (let p = u, m = i, g = m ? t[m - 1].to : n; p > a; )
          p == g && (p = t[--m].from, g = m ? t[m - 1].to : n), At[--p] = d;
        a = u;
      } else
        s = c, a++;
    }
  }
}
function J4(n, e, t, r, i, s, o) {
  let l = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let a = e, c = 0; a < t; ) {
      let u = !0, h = !1;
      if (c == s.length || a < s[c].from) {
        let m = At[a];
        m != l && (u = !1, h = m == 16);
      }
      let f = !u && l == 1 ? [] : null, d = u ? r : r + 1, p = a;
      e: for (; ; )
        if (c < s.length && p == s[c].from) {
          if (h)
            break e;
          let m = s[c];
          if (!u)
            for (let g = m.to, b = c + 1; ; ) {
              if (g == t)
                break e;
              if (b < s.length && s[b].from == g)
                g = s[b++].to;
              else {
                if (At[g] == l)
                  break e;
                break;
              }
            }
          if (c++, f)
            f.push(m);
          else {
            m.from > a && o.push(new Jo(a, m.from, d));
            let g = m.direction == va != !(d % 2);
            X4(n, g ? r + 1 : r, i, m.inner, m.from, m.to, o), a = m.to;
          }
          p = m.to;
        } else {
          if (p == t || (u ? At[p] != l : At[p] == l))
            break;
          p++;
        }
      f ? J4(n, a, p, r + 1, i, f, o) : a < p && o.push(new Jo(a, p, d)), a = p;
    }
  else
    for (let a = t, c = s.length; a > e; ) {
      let u = !0, h = !1;
      if (!c || a > s[c - 1].to) {
        let m = At[a - 1];
        m != l && (u = !1, h = m == 16);
      }
      let f = !u && l == 1 ? [] : null, d = u ? r : r + 1, p = a;
      e: for (; ; )
        if (c && p == s[c - 1].to) {
          if (h)
            break e;
          let m = s[--c];
          if (!u)
            for (let g = m.from, b = c; ; ) {
              if (g == e)
                break e;
              if (b && s[b - 1].to == g)
                g = s[--b].from;
              else {
                if (At[g - 1] == l)
                  break e;
                break;
              }
            }
          if (f)
            f.push(m);
          else {
            m.to < a && o.push(new Jo(m.to, a, d));
            let g = m.direction == va != !(d % 2);
            X4(n, g ? r + 1 : r, i, m.inner, m.from, m.to, o), a = m.from;
          }
          p = m.from;
        } else {
          if (p == e || (u ? At[p - 1] != l : At[p - 1] == l))
            break;
          p--;
        }
      f ? J4(n, p, a, r + 1, i, f, o) : p < a && o.push(new Jo(p, a, d)), a = p;
    }
}
function X4(n, e, t, r, i, s, o) {
  let l = e % 2 ? 2 : 1;
  mB(n, i, s, r, l), gB(n, i, s, r, l), yB(i, s, r, l), J4(n, i, s, e, t, r, o);
}
function bB(n, e, t) {
  if (!n)
    return [new Jo(0, 0, e == h3 ? 1 : 0)];
  if (e == va && !t.length && !pB.test(n))
    return bC(n.length);
  if (t.length)
    for (; n.length > At.length; )
      At[At.length] = 256;
  let r = [], i = e == va ? 0 : 1;
  return X4(n, i, i, t, 0, n.length, r), r;
}
function bC(n) {
  return [new Jo(0, n, 0)];
}
let vC = "";
function vB(n, e, t, r, i) {
  var s;
  let o = r.head - n.from, l = Jo.find(e, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc), a = e[l], c = a.side(i, t);
  if (o == c) {
    let f = l += i ? 1 : -1;
    if (f < 0 || f >= e.length)
      return null;
    a = e[l = f], o = a.side(!i, t), c = a.side(i, t);
  }
  let u = zn(n.text, o, a.forward(i, t));
  (u < a.from || u > a.to) && (u = c), vC = n.text.slice(Math.min(o, u), Math.max(o, u));
  let h = l == (i ? e.length - 1 : 0) ? null : e[l + (i ? 1 : -1)];
  return h && u == c && h.level + (i ? 0 : 1) < a.level ? G.cursor(h.side(!i, t) + n.from, h.forward(i, t) ? 1 : -1, h.level) : G.cursor(u + n.from, a.forward(i, t) ? -1 : 1, a.level);
}
function wB(n, e, t) {
  for (let r = e; r < t; r++) {
    let i = gC(n.charCodeAt(r));
    if (i == 1)
      return va;
    if (i == 2 || i == 4)
      return h3;
  }
  return va;
}
const wC = /* @__PURE__ */ xe.define(), xC = /* @__PURE__ */ xe.define(), kC = /* @__PURE__ */ xe.define(), SC = /* @__PURE__ */ xe.define(), Z4 = /* @__PURE__ */ xe.define(), CC = /* @__PURE__ */ xe.define(), MC = /* @__PURE__ */ xe.define(), f3 = /* @__PURE__ */ xe.define(), d3 = /* @__PURE__ */ xe.define(), TC = /* @__PURE__ */ xe.define({
  combine: (n) => n.some((e) => e)
}), AC = /* @__PURE__ */ xe.define({
  combine: (n) => n.some((e) => e)
}), OC = /* @__PURE__ */ xe.define();
class bc {
  constructor(e, t = "nearest", r = "nearest", i = 5, s = 5, o = !1) {
    this.range = e, this.y = t, this.x = r, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new bc(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new bc(G.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Xd = /* @__PURE__ */ Xe.define({ map: (n, e) => n.map(e) }), EC = /* @__PURE__ */ Xe.define();
function Mr(n, e, t) {
  let r = n.facet(SC);
  r.length ? r[0](e) : window.onerror && window.onerror(String(e), t, void 0, void 0, e) || (t ? console.error(t + ":", e) : console.error(e));
}
const Js = /* @__PURE__ */ xe.define({ combine: (n) => n.length ? n[0] : !0 });
let xB = 0;
const dc = /* @__PURE__ */ xe.define({
  combine(n) {
    return n.filter((e, t) => {
      for (let r = 0; r < t; r++)
        if (n[r].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class gn {
  constructor(e, t, r, i, s) {
    this.id = e, this.create = t, this.domEventHandlers = r, this.domEventObservers = i, this.baseExtensions = s(this), this.extension = this.baseExtensions.concat(dc.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(dc.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: r, eventObservers: i, provide: s, decorations: o } = t || {};
    return new gn(xB++, e, r, i, (l) => {
      let a = [];
      return o && a.push(Tf.of((c) => {
        let u = c.plugin(l);
        return u ? o(u) : He.none;
      })), s && a.push(s(l)), a;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return gn.define((r, i) => new e(r, i), t);
  }
}
class Ig {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (r) {
            if (Mr(t.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (t) {
        Mr(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Mr(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const IC = /* @__PURE__ */ xe.define(), p3 = /* @__PURE__ */ xe.define(), Tf = /* @__PURE__ */ xe.define(), DC = /* @__PURE__ */ xe.define(), r1 = /* @__PURE__ */ xe.define(), NC = /* @__PURE__ */ xe.define();
function L6(n, e) {
  let t = n.state.facet(NC);
  if (!t.length)
    return t;
  let r = t.map((s) => s instanceof Function ? s(n) : s), i = [];
  return ut.spans(r, e.from, e.to, {
    point() {
    },
    span(s, o, l, a) {
      let c = s - e.from, u = o - e.from, h = i;
      for (let f = l.length - 1; f >= 0; f--, a--) {
        let d = l[f].spec.bidiIsolate, p;
        if (d == null && (d = wB(e.text, c, u)), a > 0 && h.length && (p = h[h.length - 1]).to == c && p.direction == d)
          p.to = u, h = p.inner;
        else {
          let m = { from: c, to: u, direction: d, inner: [] };
          h.push(m), h = m.inner;
        }
      }
    }
  }), i;
}
const RC = /* @__PURE__ */ xe.define();
function m3(n) {
  let e = 0, t = 0, r = 0, i = 0;
  for (let s of n.state.facet(RC)) {
    let o = s(n);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: t, top: r, bottom: i };
}
const Zu = /* @__PURE__ */ xe.define();
class di {
  constructor(e, t, r, i) {
    this.fromA = e, this.toA = t, this.fromB = r, this.toB = i;
  }
  join(e) {
    return new di(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, r = this;
    for (; t > 0; t--) {
      let i = e[t - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, r), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let r = [];
    for (let i = 0, s = 0, o = 0, l = 0; ; i++) {
      let a = i == e.length ? null : e[i], c = o - l, u = a ? a.fromB : 1e9;
      for (; s < t.length && t[s] < u; ) {
        let h = t[s], f = t[s + 1], d = Math.max(l, h), p = Math.min(u, f);
        if (d <= p && new di(d + c, p + c, d, p).addToSet(r), f > u)
          break;
        s += 2;
      }
      if (!a)
        return r;
      new di(a.fromA, a.toA, a.fromB, a.toB).addToSet(r), o = a.toA, l = a.toB;
    }
  }
}
class tm {
  constructor(e, t, r) {
    this.view = e, this.state = t, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = wn.empty(this.startState.doc.length);
    for (let s of r)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, l, a) => i.push(new di(s, o, l, a))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new tm(e, t, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class B6 extends Et {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = He.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new dn()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new di(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? i = this.domChanged.newSel.head : !OB(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? SB(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      r = new di(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (we.ie || we.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, l = this.updateDeco(), a = TB(o, l, e.changes);
    return r = di.extendWithRanges(r, a), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = we.chrome || we.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof no && o.widget instanceof G4 && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, t, r) {
    let i = r ? r.range.addToSet(e.slice()) : e, s = this.childCursor(t);
    for (let o = i.length - 1; ; o--) {
      let l = o >= 0 ? i[o] : null;
      if (!l)
        break;
      let { fromA: a, toA: c, fromB: u, toB: h } = l, f, d, p, m;
      if (r && r.range.fromB < h && r.range.toB > u) {
        let C = Fh.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), M = Fh.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
        d = C.breakAtStart, p = C.openStart, m = M.openEnd;
        let T = this.compositionView(r);
        M.breakAtStart ? T.breakAfter = 1 : M.content.length && T.merge(T.length, T.length, M.content[0], !1, M.openStart, 0) && (T.breakAfter = M.content[0].breakAfter, M.content.shift()), C.content.length && T.merge(0, 0, C.content[C.content.length - 1], !0, 0, C.openEnd) && C.content.pop(), f = C.content.concat(T).concat(M.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: m } = Fh.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
      let { i: g, off: b } = s.findPos(c, 1), { i: w, off: k } = s.findPos(a, -1);
      lC(this, w, k, g, b, f, d, p, m);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(EC) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let t = new Bi(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: i } of e.marks)
      t = new co(i, [t], t.length);
    let r = new dn();
    return r.append(t, 0), r;
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (a) => a.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let l = Et.get(s);
      l && l != o && (l.dom = null), o.setDOM(s);
    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
    t(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      r = i.childPos(r.off, 1), i = i.children[r.i], t(s >= 0 ? e.marks[s].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, s = !i && !(this.view.state.facet(Js) || this.dom.tabIndex > -1) && G0(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || t || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, a = this.moveToLine(this.domAtPos(l.anchor)), c = l.empty ? a : this.moveToLine(this.domAtPos(l.head));
    if (we.gecko && l.empty && !this.hasComposition && kB(a)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => a.node.insertBefore(h, a.node.childNodes[a.offset] || null)), a = c = new Un(h, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || (!zh(a.node, a.offset, u.anchorNode, u.anchorOffset) || !zh(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, l)) && (this.view.observer.ignore(() => {
      we.android && we.chrome && this.dom.contains(u.focusNode) && AB(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Cf(this.view.root);
      if (h) if (l.empty) {
        if (we.gecko) {
          let f = CB(a.node, a.offset);
          if (f && f != 3) {
            let d = (f == 1 ? iC : sC)(a.node, a.offset);
            d && (a = new Un(d.node, d.offset));
          }
        }
        h.collapse(a.node, a.offset), l.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = l.bidiLevel);
      } else if (h.extend) {
        h.collapse(a.node, a.offset);
        try {
          h.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let f = document.createRange();
        l.anchor > l.head && ([a, c] = [c, a]), f.setEnd(c.node, c.offset), f.setStart(a.node, a.offset), h.removeAllRanges(), h.addRange(f);
      }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(a, c)), this.impreciseAnchor = a.precise ? null : new Un(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new Un(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && zh(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, r = Cf(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!r || !t.empty || !t.assoc || !r.modify)
      return;
    let o = dn.find(this, t.head);
    if (!o)
      return;
    let l = o.posAtStart;
    if (t.head == l || t.head == l + o.length)
      return;
    let a = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!a || !c || a.bottom > c.top)
      return;
    let u = this.domAtPos(t.head + t.assoc);
    r.collapse(u.node, u.offset), r.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != t.from && r.collapse(i, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, r;
    if (e.node != t)
      return e;
    for (let i = e.offset; !r && i < t.childNodes.length; i++) {
      let s = Et.get(t.childNodes[i]);
      s instanceof dn && (r = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let s = Et.get(t.childNodes[i]);
      s instanceof dn && (r = s.domAtPos(s.length));
    }
    return r ? new Un(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let r = Et.get(t);
      if (r && r.rootView == this)
        return r;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, t) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: r } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let i = this.children[t];
      if (r < i.length || i instanceof dn)
        break;
      t++, r = 0;
    }
    return this.children[t].domAtPos(r);
  }
  coordsAt(e, t) {
    let r = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let l = this.children[o], a = s - l.breakAfter, c = a - l.length;
      if (a < e)
        break;
      if (c <= e && (c < e || l.covers(-1)) && (a > e || l.covers(1)) && (!r || l instanceof dn && !(r instanceof dn && t >= 0)))
        r = l, i = c;
      else if (r && c == e && a == e && l instanceof no && Math.abs(t) < 2) {
        if (l.deco.startSide < 0)
          break;
        o && (r = null);
      }
      s = c;
    }
    return r ? r.coordsAt(e - i, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: r } = this.childPos(e, 1), i = this.children[t];
    if (!(i instanceof dn))
      return null;
    for (; i.children.length; ) {
      let { i: l, off: a } = i.childPos(r, 1);
      for (; ; l++) {
        if (l == i.children.length)
          return null;
        if ((i = i.children[l]).length)
          break;
      }
      r = a;
    }
    if (!(i instanceof Bi))
      return null;
    let s = zn(i.text, r);
    if (s == r)
      return null;
    let o = ba(i.dom, r, s).getClientRects();
    for (let l = 0; l < o.length; l++) {
      let a = o[l];
      if (l == o.length - 1 || a.top < a.bottom && a.left < a.right)
        return a;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: r, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, a = this.view.textDirection == qt.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let h = this.children[u], f = c + h.length;
      if (f > i)
        break;
      if (c >= r) {
        let d = h.dom.getBoundingClientRect();
        if (t.push(d.height), o) {
          let p = h.dom.lastChild, m = p ? Mf(p) : [];
          if (m.length) {
            let g = m[m.length - 1], b = a ? g.right - d.left : d.right - g.left;
            b > l && (l = b, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + h.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? qt.RTL : qt.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof dn) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, r, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Mf(e.firstChild)[0];
      t = e.getBoundingClientRect().height, r = s ? s.width / 27 : 7, i = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: r, textHeight: i };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new oC(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let s = i == t.viewports.length ? null : t.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > r) {
        let l = (t.lineBlockAt(o).bottom - t.lineBlockAt(r).top) / this.view.scaleY;
        e.push(He.replace({
          widget: new G4(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!s)
        break;
      r = s.to + 1;
    }
    return He.set(e);
  }
  updateDeco() {
    let e = 1, t = this.view.state.facet(Tf).map((s) => (this.dynamicDecorationMap[e++] = typeof s == "function") ? s(this.view) : s), r = !1, i = this.view.state.facet(DC).map((s, o) => {
      let l = typeof s == "function";
      return l && (r = !0), l ? s(this.view) : s;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = r, t.push(ut.join(i))), this.decorations = [
      this.editContextFormatting,
      ...t,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(OC))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (u) {
        Mr(this.view.state, u, "scroll handler");
      }
    let { range: t } = e, r = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), i;
    if (!r)
      return;
    !t.empty && (i = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let s = m3(this.view), o = {
      left: r.left - s.left,
      top: r.top - s.top,
      right: r.right + s.right,
      bottom: r.bottom + s.bottom
    }, { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM;
    eB(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, a), -a), this.view.textDirection == qt.LTR);
  }
}
function kB(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
function PC(n, e) {
  let t = n.observer.selectionRange;
  if (!t.focusNode)
    return null;
  let r = iC(t.focusNode, t.focusOffset), i = sC(t.focusNode, t.focusOffset), s = r || i;
  if (i && r && i.node != r.node) {
    let l = Et.get(i.node);
    if (!l || l instanceof Bi && l.text != i.node.nodeValue)
      s = i;
    else if (n.docView.lastCompositionAfterCursor) {
      let a = Et.get(r.node);
      !a || a instanceof Bi && a.text != r.node.nodeValue || (s = i);
    }
  }
  if (n.docView.lastCompositionAfterCursor = s != r, !s)
    return null;
  let o = e - s.offset;
  return { from: o, to: o + s.node.nodeValue.length, node: s.node };
}
function SB(n, e, t) {
  let r = PC(n, t);
  if (!r)
    return null;
  let { node: i, from: s, to: o } = r, l = i.nodeValue;
  if (/[\n\r]/.test(l) || n.state.doc.sliceString(r.from, r.to) != l)
    return null;
  let a = e.invertedDesc, c = new di(a.mapPos(s), a.mapPos(o), s, o), u = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let f = Et.get(h);
    if (f instanceof co)
      u.push({ node: h, deco: f.mark });
    else {
      if (f instanceof dn || h.nodeName == "DIV" && h.parentNode == n.contentDOM)
        return { range: c, text: i, marks: u, line: h };
      if (h != n.contentDOM)
        u.push({ node: h, deco: new od({
          inclusive: !0,
          attributes: uB(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function CB(n, e) {
  return n.nodeType != 1 ? 0 : (e && n.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < n.childNodes.length && n.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let MB = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    Y0(e, t, this.changes);
  }
  comparePoint(e, t) {
    Y0(e, t, this.changes);
  }
  boundChange(e) {
    Y0(e, e, this.changes);
  }
};
function TB(n, e, t) {
  let r = new MB();
  return ut.compare(n, e, t, r), r.changes;
}
function AB(n, e) {
  for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function OB(n, e) {
  let t = !1;
  return e && n.iterChangedRanges((r, i) => {
    r < e.to && i > e.from && (t = !0);
  }), t;
}
function EB(n, e, t = 1) {
  let r = n.charCategorizer(e), i = n.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return G.cursor(e);
  s == 0 ? t = 1 : s == i.length && (t = -1);
  let o = s, l = s;
  t < 0 ? o = zn(i.text, s, !1) : l = zn(i.text, s);
  let a = r(i.text.slice(o, l));
  for (; o > 0; ) {
    let c = zn(i.text, o, !1);
    if (r(i.text.slice(c, o)) != a)
      break;
    o = c;
  }
  for (; l < i.length; ) {
    let c = zn(i.text, l);
    if (r(i.text.slice(l, c)) != a)
      break;
    l = c;
  }
  return G.range(o + i.from, l + i.from);
}
function IB(n, e) {
  return e.left > n ? e.left - n : Math.max(0, n - e.right);
}
function DB(n, e) {
  return e.top > n ? e.top - n : Math.max(0, n - e.bottom);
}
function Dg(n, e) {
  return n.top < e.bottom - 1 && n.bottom > e.top + 1;
}
function z6(n, e) {
  return e < n.top ? { top: e, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function F6(n, e) {
  return e > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: e } : n;
}
function Q4(n, e, t) {
  let r, i, s, o, l = !1, a, c, u, h;
  for (let p = n.firstChild; p; p = p.nextSibling) {
    let m = Mf(p);
    for (let g = 0; g < m.length; g++) {
      let b = m[g];
      i && Dg(i, b) && (b = z6(F6(b, i.bottom), i.top));
      let w = IB(e, b), k = DB(t, b);
      if (w == 0 && k == 0)
        return p.nodeType == 3 ? H6(p, e, t) : Q4(p, e, t);
      (!r || o > k || o == k && s > w) && (r = p, i = b, s = w, o = k, l = w ? e < b.left ? g > 0 : g < m.length - 1 : !0), w == 0 ? t > b.bottom && (!u || u.bottom < b.bottom) ? (a = p, u = b) : t < b.top && (!h || h.top > b.top) && (c = p, h = b) : u && Dg(u, b) ? u = F6(u, b.bottom) : h && Dg(h, b) && (h = z6(h, b.top));
    }
  }
  if (u && u.bottom >= t ? (r = a, i = u) : h && h.top <= t && (r = c, i = h), !r)
    return { node: n, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3)
    return H6(r, f, t);
  if (l && r.contentEditable != "false")
    return Q4(r, f, t);
  let d = Array.prototype.indexOf.call(n.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: n, offset: d };
}
function H6(n, e, t) {
  let r = n.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let l = 0; l < r; l++) {
    let a = ba(n, l, l + 1).getClientRects();
    for (let c = 0; c < a.length; c++) {
      let u = a[c];
      if (u.top == u.bottom)
        continue;
      o || (o = e - u.left);
      let h = (u.top > t ? u.top - t : t - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && h < s) {
        let f = e >= (u.left + u.right) / 2, d = f;
        if ((we.chrome || we.gecko) && ba(n, l).getBoundingClientRect().left == u.right && (d = !f), h <= 0)
          return { node: n, offset: l + (d ? 1 : 0) };
        i = l + (d ? 1 : 0), s = h;
      }
    }
  }
  return { node: n, offset: i > -1 ? i : o > 0 ? n.nodeValue.length : 0 };
}
function _C(n, e, t, r = -1) {
  var i, s;
  let o = n.contentDOM.getBoundingClientRect(), l = o.top + n.viewState.paddingTop, a, { docHeight: c } = n.viewState, { x: u, y: h } = e, f = h - l;
  if (f < 0)
    return 0;
  if (f > c)
    return n.state.doc.length;
  for (let C = n.viewState.heightOracle.textHeight / 2, M = !1; a = n.elementAtHeight(f), a.type != hr.Text; )
    for (; f = r > 0 ? a.bottom + C : a.top - C, !(f >= 0 && f <= c); ) {
      if (M)
        return t ? null : 0;
      M = !0, r = -r;
    }
  h = l + f;
  let d = a.from;
  if (d < n.viewport.from)
    return n.viewport.from == 0 ? 0 : t ? null : $6(n, o, a, u, h);
  if (d > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : t ? null : $6(n, o, a, u, h);
  let p = n.dom.ownerDocument, m = n.root.elementFromPoint ? n.root : p, g = m.elementFromPoint(u, h);
  g && !n.contentDOM.contains(g) && (g = null), g || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), g = m.elementFromPoint(u, h), g && !n.contentDOM.contains(g) && (g = null));
  let b, w = -1;
  if (g && ((i = n.docView.nearest(g)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let C = p.caretPositionFromPoint(u, h);
      C && ({ offsetNode: b, offset: w } = C);
    } else if (p.caretRangeFromPoint) {
      let C = p.caretRangeFromPoint(u, h);
      C && ({ startContainer: b, startOffset: w } = C, (!n.contentDOM.contains(b) || we.safari && NB(b, w, u) || we.chrome && RB(b, w, u)) && (b = void 0));
    }
    b && (w = Math.min(ws(b), w));
  }
  if (!b || !n.docView.dom.contains(b)) {
    let C = dn.find(n.docView, d);
    if (!C)
      return f > a.top + a.height / 2 ? a.to : a.from;
    ({ node: b, offset: w } = Q4(C.dom, u, h));
  }
  let k = n.docView.nearest(b);
  if (!k)
    return null;
  if (k.isWidget && ((s = k.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let C = k.dom.getBoundingClientRect();
    return e.y < C.top || e.y <= C.bottom && e.x <= (C.left + C.right) / 2 ? k.posAtStart : k.posAtEnd;
  } else
    return k.localPosFromDOM(b, w) + k.posAtStart;
}
function $6(n, e, t, r, i) {
  let s = Math.round((r - e.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
    let l = n.viewState.heightOracle.textHeight, a = Math.floor((i - t.top - (n.defaultLineHeight - l) * 0.5) / l);
    s += a * n.viewState.heightOracle.lineLength;
  }
  let o = n.state.sliceDoc(t.from, t.to);
  return t.from + F4(o, s, n.state.tabSize);
}
function NB(n, e, t) {
  let r, i = n;
  if (n.nodeType != 3 || e != (r = n.nodeValue.length))
    return !1;
  for (; ; ) {
    let s = i.nextSibling;
    if (s) {
      if (s.nodeName == "BR")
        break;
      return !1;
    } else {
      let o = i.parentNode;
      if (!o || o.nodeName == "DIV")
        break;
      i = o;
    }
  }
  return ba(n, r - 1, r).getBoundingClientRect().right > t;
}
function RB(n, e, t) {
  if (e != 0)
    return !1;
  for (let i = n; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let r = n.nodeType == 1 ? n.getBoundingClientRect() : ba(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return t - r.left > 5;
}
function ey(n, e, t) {
  let r = n.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    let i;
    for (let s of r.type) {
      if (s.from > e)
        break;
      if (!(s.to < e)) {
        if (s.from < e && s.to > e)
          return s;
        (!i || s.type == hr.Text && (i.type != s.type || (t < 0 ? s.from < e : s.to > e))) && (i = s);
      }
    }
    return i || r;
  }
  return r;
}
function PB(n, e, t, r) {
  let i = ey(n, e.head, e.assoc || -1), s = !r || i.type != hr.Text || !(n.lineWrapping || i.widgetLineBreaks) ? null : n.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = n.dom.getBoundingClientRect(), l = n.textDirectionAt(i.from), a = n.posAtCoords({
      x: t == (l == qt.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (a != null)
      return G.cursor(a, t ? -1 : 1);
  }
  return G.cursor(t ? i.to : i.from, t ? -1 : 1);
}
function V6(n, e, t, r) {
  let i = n.state.doc.lineAt(e.head), s = n.bidiSpans(i), o = n.textDirectionAt(i.from);
  for (let l = e, a = null; ; ) {
    let c = vB(i, s, o, l, t), u = vC;
    if (!c) {
      if (i.number == (t ? n.state.doc.lines : 1))
        return l;
      u = `
`, i = n.state.doc.line(i.number + (t ? 1 : -1)), s = n.bidiSpans(i), c = n.visualLineSide(i, !t);
    }
    if (a) {
      if (!a(u))
        return l;
    } else {
      if (!r)
        return c;
      a = r(u);
    }
    l = c;
  }
}
function _B(n, e, t) {
  let r = n.state.charCategorizer(e), i = r(t);
  return (s) => {
    let o = r(s);
    return i == Wt.Space && (i = o), i == o;
  };
}
function LB(n, e, t, r) {
  let i = e.head, s = t ? 1 : -1;
  if (i == (t ? n.state.doc.length : 0))
    return G.cursor(i, e.assoc);
  let o = e.goalColumn, l, a = n.contentDOM.getBoundingClientRect(), c = n.coordsAtPos(i, e.assoc || -1), u = n.documentTop;
  if (c)
    o == null && (o = c.left - a.left), l = s < 0 ? c.top : c.bottom;
  else {
    let d = n.viewState.lineBlockAt(i);
    o == null && (o = Math.min(a.right - a.left, n.defaultCharacterWidth * (i - d.from))), l = (s < 0 ? d.top : d.bottom) + u;
  }
  let h = a.left + o, f = r ?? n.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = l + (f + d) * s, m = _C(n, { x: h, y: p }, !1, s);
    if (p < a.top || p > a.bottom || (s < 0 ? m < i : m > i)) {
      let g = n.docView.coordsForChar(m), b = !g || p < g.top ? -1 : 1;
      return G.cursor(m, b, void 0, o);
    }
  }
}
function J0(n, e, t) {
  for (; ; ) {
    let r = 0;
    for (let i of n)
      i.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let a = r || t || (e - s < o - e ? -1 : 1);
          e = a < 0 ? s : o, r = a;
        }
      });
    if (!r)
      return e;
  }
}
function LC(n, e) {
  let t = null;
  for (let r = 0; r < e.ranges.length; r++) {
    let i = e.ranges[r], s = null;
    if (i.empty) {
      let o = J0(n, i.from, 0);
      o != i.from && (s = G.cursor(o, -1));
    } else {
      let o = J0(n, i.from, -1), l = J0(n, i.to, 1);
      (o != i.from || l != i.to) && (s = G.range(i.from == i.anchor ? o : l, i.from == i.head ? o : l));
    }
    s && (t || (t = e.ranges.slice()), t[r] = s);
  }
  return t ? G.create(t, e.mainIndex) : e;
}
function Ng(n, e, t) {
  let r = J0(n.state.facet(r1).map((i) => i(n)), t.from, e.head > t.from ? -1 : 1);
  return r == t.from ? t : G.cursor(r, r < t.from ? 1 : -1);
}
const Qu = "￿";
class BB {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(jt.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Qu;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == t)
        break;
      let l = Et.get(i), a = Et.get(o);
      (l && a ? l.breakAfter : (l ? l.breakAfter : Qp(i)) || Qp(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(r, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, t.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, l;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (l = i.exec(t)) && (s = l.index, o = l[0].length), this.append(t.slice(r, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= o - 1);
      r = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Et.get(e), r = t && t.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == t && (r.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (zB(e, r.node, r.offset) ? t : 0));
  }
}
function zB(n, e, t) {
  for (; ; ) {
    if (!e || t < ws(e))
      return !1;
    if (e == n)
      return !0;
    t = ya(e) + 1, e = e.parentNode;
  }
}
class q6 {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class FB {
  constructor(e, t, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = t > -1;
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, r, 0))) {
      let l = s || o ? [] : VB(e), a = new BB(l, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = qB(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, a = s && s.node == l.focusNode && s.offset == l.focusOffset || !V4(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), c = o && o.node == l.anchorNode && o.offset == l.anchorOffset || !V4(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset), u = e.viewport;
      if ((we.ios || we.chrome) && e.state.selection.main.empty && a != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let h = Math.min(a, c), f = Math.max(a, c), d = u.from - h, p = u.to - f;
        (d == 0 || d == 1 || h == 0) && (p == 0 || p == -1 || f == e.state.doc.length) && (a = 0, c = e.state.doc.length);
      }
      this.newSel = G.single(c, a);
    }
  }
}
function BC(n, e) {
  let t, { newSel: r } = e, i = n.state.selection.main, s = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds, a = i.from, c = null;
    (s === 8 || we.android && e.text.length < l - o) && (a = i.to, c = "end");
    let u = $B(n.state.doc.sliceString(o, l, Qu), e.text, a - o, c);
    u && (we.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == Qu + Qu && u.toB--, t = {
      from: o + u.from,
      to: o + u.toA,
      insert: ft.of(e.text.slice(u.from, u.toB).split(Qu))
    });
  } else r && (!n.hasFocus && n.state.facet(Js) || r.main.eq(i)) && (r = null);
  if (!t && !r)
    return !1;
  if (!t && e.typeOver && !i.empty && r && r.main.empty ? t = { from: i.from, to: i.to, insert: n.state.doc.slice(i.from, i.to) } : (we.mac || we.android) && t && t.from == t.to && t.from == i.head - 1 && /^\. ?$/.test(t.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (r && t.insert.length == 2 && (r = G.single(r.main.anchor - 1, r.main.head - 1)), t = { from: t.from, to: t.to, insert: ft.of([t.insert.toString().replace(".", " ")]) }) : t && t.from >= i.from && t.to <= i.to && (t.from != i.from || t.to != i.to) && i.to - i.from - (t.to - t.from) <= 4 ? t = {
    from: i.from,
    to: i.to,
    insert: n.state.doc.slice(i.from, t.from).append(t.insert).append(n.state.doc.slice(t.to, i.to))
  } : we.chrome && t && t.from == t.to && t.from == i.head && t.insert.toString() == `
 ` && n.lineWrapping && (r && (r = G.single(r.main.anchor - 1, r.main.head - 1)), t = { from: i.from, to: i.to, insert: ft.of([" "]) }), t)
    return g3(n, t, r, s);
  if (r && !r.main.eq(i)) {
    let o = !1, l = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (o = !0), l = n.inputState.lastSelectionOrigin, l == "select.pointer" && (r = LC(n.state.facet(r1).map((a) => a(n)), r))), n.dispatch({ selection: r, scrollIntoView: o, userEvent: l }), !0;
  } else
    return !1;
}
function g3(n, e, t, r = -1) {
  if (we.ios && n.inputState.flushIOSKey(e))
    return !0;
  let i = n.state.selection.main;
  if (we.android && (e.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == i.from || e.from == i.from - 1 && n.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && yc(n.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && yc(n.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && yc(n.contentDOM, "Delete", 46)))
    return !0;
  let s = e.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let o, l = () => o || (o = HB(n, e, t));
  return n.state.facet(CC).some((a) => a(n, e.from, e.to, s, l)) || n.dispatch(l()), !0;
}
function HB(n, e, t) {
  let r, i = n.state, s = i.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && n.inputState.composing < 0) {
    let l = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", a = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    r = i.replaceSelection(n.state.toText(l + e.insert.sliceString(0, void 0, n.state.lineBreak) + a));
  } else {
    let l = i.changes(e), a = t && t.main.to <= l.newLength ? t.main : void 0;
    if (i.selection.ranges.length > 1 && n.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = n.state.sliceDoc(e.from, e.to), u, h = t && PC(n, t.main.head);
      if (h) {
        let p = e.insert.length - (e.to - e.from);
        u = { from: h.from, to: h.to - p };
      } else
        u = n.state.doc.lineAt(s.head);
      let f = s.to - e.to, d = s.to - s.from;
      r = i.changeByRange((p) => {
        if (p.from == s.from && p.to == s.to)
          return { changes: l, range: a || p.map(l) };
        let m = p.to - f, g = m - c.length;
        if (p.to - p.from != d || n.state.sliceDoc(g, m) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= u.from && p.from <= u.to)
          return { range: p };
        let b = i.changes({ from: g, to: m, insert: e.insert }), w = p.to - s.to;
        return {
          changes: b,
          range: a ? G.range(Math.max(0, a.anchor + w), Math.max(0, a.head + w)) : p.map(b)
        };
      });
    } else
      r = {
        changes: l,
        selection: a && i.selection.replaceRange(a)
      };
  }
  let o = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, o += ".compose", n.inputState.compositionFirstChange && (o += ".start", n.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: o, scrollIntoView: !0 });
}
function $B(n, e, t, r) {
  let i = Math.min(n.length, e.length), s = 0;
  for (; s < i && n.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && n.length == e.length)
    return null;
  let o = n.length, l = e.length;
  for (; o > 0 && l > 0 && n.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (r == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    t -= o + a - s;
  }
  if (o < s && n.length < e.length) {
    let a = t <= s && t >= o ? s - t : 0;
    s -= a, l = s + (l - o), o = s;
  } else if (l < s) {
    let a = t <= s && t >= l ? s - t : 0;
    s -= a, o = s + (o - l), l = s;
  }
  return { from: s, toA: o, toB: l };
}
function VB(n) {
  let e = [];
  if (n.root.activeElement != n.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s } = n.observer.selectionRange;
  return t && (e.push(new q6(t, r)), (i != t || s != r) && e.push(new q6(i, s))), e;
}
function qB(n, e) {
  if (n.length == 0)
    return null;
  let t = n[0].pos, r = n.length == 2 ? n[1].pos : t;
  return t > -1 && r > -1 ? G.single(t + e, r + e) : null;
}
let WB = class {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, we.safari && e.contentDOM.addEventListener("input", () => null), we.gecko && oz(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !ZB(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, t) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers)
        i(this.view, t);
      for (let i of r.handlers) {
        if (t.defaultPrevented)
          break;
        if (i(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = jB(e), r = this.handlers, i = this.view.contentDOM;
    for (let s in t)
      if (s != "scroll") {
        let o = !t[s].handlers.length, l = r[s];
        l && o != !l.handlers.length && (i.removeEventListener(s, this.handleEvent), l = null), l || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in r)
      s != "scroll" && !t[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && FC.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), we.android && we.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return we.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = zC.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || UB.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return !t || t.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, yc(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : we.safari && !we.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
function W6(n, e) {
  return (t, r) => {
    try {
      return e.call(n, r, t);
    } catch (i) {
      Mr(t.state, i);
    }
  };
}
function jB(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of n) {
    let i = r.spec, s = i && i.plugin.domEventHandlers, o = i && i.plugin.domEventObservers;
    if (s)
      for (let l in s) {
        let a = s[l];
        a && t(l).handlers.push(W6(r.value, a));
      }
    if (o)
      for (let l in o) {
        let a = o[l];
        a && t(l).observers.push(W6(r.value, a));
      }
  }
  for (let r in zi)
    t(r).handlers.push(zi[r]);
  for (let r in bi)
    t(r).observers.push(bi[r]);
  return e;
}
const zC = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], UB = "dthko", FC = [16, 17, 18, 20, 91, 92, 224, 225], Zd = 6;
function Qd(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function KB(n, e) {
  return Math.max(Math.abs(n.clientX - e.clientX), Math.abs(n.clientY - e.clientY));
}
class GB {
  constructor(e, t, r, i) {
    this.view = e, this.startEvent = t, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParents = tB(e.contentDOM), this.atoms = e.state.facet(r1).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(jt.allowMultipleSelections) && YB(e, t), this.dragging = XB(e, t) && VC(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && KB(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let t = 0, r = 0, i = 0, s = 0, o = this.view.win.innerWidth, l = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: s, bottom: l } = this.scrollParents.y.getBoundingClientRect());
    let a = m3(this.view);
    e.clientX - a.left <= i + Zd ? t = -Qd(i - e.clientX) : e.clientX + a.right >= o - Zd && (t = Qd(e.clientX - o)), e.clientY - a.top <= s + Zd ? r = -Qd(s - e.clientY) : e.clientY + a.bottom >= l - Zd && (r = Qd(e.clientY - l)), this.setScrollSpeed(t, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: t } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), t && this.scrollParents.y && (this.scrollParents.y.scrollTop += t, t = 0), (e || t) && this.view.win.scrollBy(e, t), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(e) {
    let { view: t } = this, r = LC(this.atoms, this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((t) => t.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function YB(n, e) {
  let t = n.state.facet(wC);
  return t.length ? t[0](e) : we.mac ? e.metaKey : e.ctrlKey;
}
function JB(n, e) {
  let t = n.state.facet(xC);
  return t.length ? t[0](e) : we.mac ? !e.altKey : !e.ctrlKey;
}
function XB(n, e) {
  let { main: t } = n.state.selection;
  if (t.empty)
    return !1;
  let r = Cf(n.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function ZB(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, r; t != n.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (r = Et.get(t)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const zi = /* @__PURE__ */ Object.create(null), bi = /* @__PURE__ */ Object.create(null), HC = we.ie && we.ie_version < 15 || we.ios && we.webkit_version < 604;
function QB(n) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    n.focus(), t.remove(), $C(n, t.value);
  }, 50);
}
function i1(n, e, t) {
  for (let r of n.facet(e))
    t = r(t, n);
  return t;
}
function $C(n, e) {
  e = i1(n.state, f3, e);
  let { state: t } = n, r, i = 1, s = t.toText(e), o = s.lines == t.selection.ranges.length;
  if (ty != null && t.selection.ranges.every((a) => a.empty) && ty == s.toString()) {
    let a = -1;
    r = t.changeByRange((c) => {
      let u = t.doc.lineAt(c.from);
      if (u.from == a)
        return { range: c };
      a = u.from;
      let h = t.toText((o ? s.line(i++).text : e) + t.lineBreak);
      return {
        changes: { from: u.from, insert: h },
        range: G.cursor(c.from + h.length)
      };
    });
  } else o ? r = t.changeByRange((a) => {
    let c = s.line(i++);
    return {
      changes: { from: a.from, to: a.to, insert: c.text },
      range: G.cursor(a.from + c.length)
    };
  }) : r = t.replaceSelection(s);
  n.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
bi.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
zi.keydown = (n, e) => (n.inputState.setSelectionOrigin("select"), e.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
bi.touchstart = (n, e) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
bi.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
zi.mousedown = (n, e) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let r of n.state.facet(kC))
    if (t = r(n, e), t)
      break;
  if (!t && e.button == 0 && (t = nz(n, e)), t) {
    let r = !n.hasFocus;
    n.inputState.startMouseSelection(new GB(n, e, t, r)), r && n.observer.ignore(() => {
      tC(n.contentDOM);
      let s = n.root.activeElement;
      s && !s.contains(n.contentDOM) && s.blur();
    });
    let i = n.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  } else
    n.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function j6(n, e, t, r) {
  if (r == 1)
    return G.cursor(e, t);
  if (r == 2)
    return EB(n.state, e, t);
  {
    let i = dn.find(n.docView, e), s = n.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, l = i ? i.posAtEnd : s.to;
    return l < n.state.doc.length && l == s.to && l++, G.range(o, l);
  }
}
let U6 = (n, e, t) => e >= t.top && e <= t.bottom && n >= t.left && n <= t.right;
function ez(n, e, t, r) {
  let i = dn.find(n.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && U6(t, r, o))
    return -1;
  let l = i.coordsAt(s, 1);
  return l && U6(t, r, l) ? 1 : o && o.bottom >= r ? -1 : 1;
}
function K6(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: ez(n, t, e.clientX, e.clientY) };
}
const tz = we.ie && we.ie_version <= 11;
let G6 = null, Y6 = 0, J6 = 0;
function VC(n) {
  if (!tz)
    return n.detail;
  let e = G6, t = J6;
  return G6 = n, J6 = Date.now(), Y6 = !e || t > Date.now() - 400 && Math.abs(e.clientX - n.clientX) < 2 && Math.abs(e.clientY - n.clientY) < 2 ? (Y6 + 1) % 3 : 1;
}
function nz(n, e) {
  let t = K6(n, e), r = VC(e), i = n.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), i = i.map(s.changes));
    },
    get(s, o, l) {
      let a = K6(n, s), c, u = j6(n, a.pos, a.bias, r);
      if (t.pos != a.pos && !o) {
        let h = j6(n, t.pos, t.bias, r), f = Math.min(h.from, u.from), d = Math.max(h.to, u.to);
        u = f < u.from ? G.range(f, d) : G.range(d, f);
      }
      return o ? i.replaceRange(i.main.extend(u.from, u.to)) : l && r == 1 && i.ranges.length > 1 && (c = rz(i, a.pos)) ? c : l ? i.addRange(u) : G.create([u]);
    }
  };
}
function rz(n, e) {
  for (let t = 0; t < n.ranges.length; t++) {
    let { from: r, to: i } = n.ranges[t];
    if (r <= e && i >= e)
      return G.create(n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)), n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0));
  }
  return null;
}
zi.dragstart = (n, e) => {
  let { selection: { main: t } } = n.state;
  if (e.target.draggable) {
    let i = n.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= t.to || o <= t.from) && (t = G.range(s, o));
    }
  }
  let { inputState: r } = n;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", i1(n.state, d3, n.state.sliceDoc(t.from, t.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
zi.dragend = (n) => (n.inputState.draggedContent = null, !1);
function X6(n, e, t, r) {
  if (t = i1(n.state, f3, t), !t)
    return;
  let i = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = n.inputState, o = r && s && JB(n, e) ? { from: s.from, to: s.to } : null, l = { from: i, insert: t }, a = n.state.changes(o ? [o, l] : l);
  n.focus(), n.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(i, -1), head: a.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
zi.drop = (n, e) => {
  if (!e.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let r = Array(t.length), i = 0, s = () => {
      ++i == t.length && X6(n, e, r.filter((o) => o != null).join(n.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (r[o] = l.result), s();
      }, l.readAsText(t[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return X6(n, e, r, !0), !0;
  }
  return !1;
};
zi.paste = (n, e) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let t = HC ? null : e.clipboardData;
  return t ? ($C(n, t.getData("text/plain") || t.getData("text/uri-list")), !0) : (QB(n), !1);
};
function iz(n, e) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let r = t.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), n.focus();
  }, 50);
}
function sz(n) {
  let e = [], t = [], r = !1;
  for (let i of n.selection.ranges)
    i.empty || (e.push(n.sliceDoc(i.from, i.to)), t.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of n.selection.ranges) {
      let o = n.doc.lineAt(s);
      o.number > i && (e.push(o.text), t.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })), i = o.number;
    }
    r = !0;
  }
  return { text: i1(n, d3, e.join(n.lineBreak)), ranges: t, linewise: r };
}
let ty = null;
zi.copy = zi.cut = (n, e) => {
  let { text: t, ranges: r, linewise: i } = sz(n.state);
  if (!t && !i)
    return !1;
  ty = i ? t : null, e.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = HC ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", t), !0) : (iz(n, t), !1);
};
const qC = /* @__PURE__ */ vo.define();
function WC(n, e) {
  let t = [];
  for (let r of n.facet(MC)) {
    let i = r(n, e);
    i && t.push(i);
  }
  return t.length ? n.update({ effects: t, annotations: qC.of(!0) }) : null;
}
function jC(n) {
  setTimeout(() => {
    let e = n.hasFocus;
    if (e != n.inputState.notifiedFocused) {
      let t = WC(n.state, e);
      t ? n.dispatch(t) : n.update([]);
    }
  }, 10);
}
bi.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), jC(n);
};
bi.blur = (n) => {
  n.observer.clearSelectionRange(), jC(n);
};
bi.compositionstart = bi.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
bi.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, we.chrome && we.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
bi.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
zi.beforeinput = (n, e) => {
  var t, r;
  if (e.inputType == "insertReplacementText" && n.observer.editContext) {
    let s = (t = e.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain"), o = e.getTargetRanges();
    if (s && o.length) {
      let l = o[0], a = n.posAtDOM(l.startContainer, l.startOffset), c = n.posAtDOM(l.endContainer, l.endOffset);
      return g3(n, { from: a, to: c, insert: n.state.toText(s) }, null), !0;
    }
  }
  let i;
  if (we.chrome && we.android && (i = zC.find((s) => s.inputType == e.inputType)) && (n.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let s = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > s + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return we.ios && e.inputType == "deleteContentForward" && n.observer.flushSoon(), we.safari && e.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => bi.compositionend(n, e), 20), !1;
};
const Z6 = /* @__PURE__ */ new Set();
function oz(n) {
  Z6.has(n) || (Z6.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
const Q6 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let _c = !1;
function ew() {
  _c = !1;
}
class lz {
  constructor(e) {
    this.lineWrapping = e, this.doc = ft.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, t) {
    let r = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((t - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return Q6.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (t = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, r, i, s, o) {
    let l = Q6.indexOf(e) > -1, a = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = t, this.charWidth = r, this.textHeight = i, this.lineLength = s, a) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return a;
  }
}
class az {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class as {
  /**
  @internal
  */
  constructor(e, t, r, i, s) {
    this.from = e, this.length = t, this.top = r, this.height = i, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? hr.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof cl ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new as(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Vt = /* @__PURE__ */ (function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
})(Vt || (Vt = {}));
const X0 = 1e-3;
class fr {
  constructor(e, t, r = 2) {
    this.length = e, this.height = t, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > X0 && (_c = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, r) {
    return fr.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, r, i) {
    let s = this, o = r.doc;
    for (let l = i.length - 1; l >= 0; l--) {
      let { fromA: a, toA: c, fromB: u, toB: h } = i[l], f = s.lineAt(a, Vt.ByPosNoHeight, r.setDoc(t), 0, 0), d = f.to >= c ? f : s.lineAt(c, Vt.ByPosNoHeight, r, 0, 0);
      for (h += d.to - c, c = d.to; l > 0 && f.from <= i[l - 1].toA; )
        a = i[l - 1].fromA, u = i[l - 1].fromB, l--, a < f.from && (f = s.lineAt(a, Vt.ByPosNoHeight, r, 0, 0));
      u += f.from - a, a = f.from;
      let p = y3.build(r.setDoc(o), e, u, h);
      s = nm(s, s.replace(a, c, p));
    }
    return s.updateHeight(r, 0);
  }
  static empty() {
    return new qr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, r = e.length, i = 0, s = 0;
    for (; ; )
      if (t == r)
        if (i > s * 2) {
          let l = e[t - 1];
          l.break ? e.splice(--t, 1, l.left, null, l.right) : e.splice(--t, 1, l.left, l.right), r += 1 + l.break, i -= l.size;
        } else if (s > i * 2) {
          let l = e[r];
          l.break ? e.splice(r, 1, l.left, null, l.right) : e.splice(r, 1, l.left, l.right), r += 2 + l.break, s -= l.size;
        } else
          break;
      else if (i < s) {
        let l = e[t++];
        l && (i += l.size);
      } else {
        let l = e[--r];
        l && (s += l.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, r++), new cz(fr.of(e.slice(0, t)), o, fr.of(e.slice(r)));
  }
}
function nm(n, e) {
  return n == e ? n : (n.constructor != e.constructor && (_c = !0), e);
}
fr.prototype.size = 1;
class UC extends fr {
  constructor(e, t, r) {
    super(e, t), this.deco = r;
  }
  blockAt(e, t, r, i) {
    return new as(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, t, r, i, s) {
    return this.blockAt(0, r, i, s);
  }
  forEachLine(e, t, r, i, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, r, i, s));
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class qr extends UC {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, r, i) {
    return new as(i, this.length, r, this.height, this.breaks);
  }
  replace(e, t, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof qr || i instanceof Rn && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Rn ? i = new qr(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : fr.of(r);
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more ? this.setHeight(i.heights[i.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Rn extends fr {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let r = e.doc.lineAt(t).number, i = e.doc.lineAt(t + this.length).number, s = i - r + 1, o, l = 0;
    if (e.lineWrapping) {
      let a = Math.min(this.height, e.lineHeight * s);
      o = a / s, this.length > s + 1 && (l = (this.height - a) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: r, lastLine: i, perLine: o, perChar: l };
  }
  blockAt(e, t, r, i) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: a } = this.heightMetrics(t, i);
    if (t.lineWrapping) {
      let c = i + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), u = t.doc.lineAt(c), h = l + u.length * a, f = Math.max(r, e - h / 2);
      return new as(u.from, u.length, f, h, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - r) / l))), { from: u, length: h } = t.doc.line(s + c);
      return new as(u, h, r + l * c, l, 0);
    }
  }
  lineAt(e, t, r, i, s) {
    if (t == Vt.ByHeight)
      return this.blockAt(e, r, i, s);
    if (t == Vt.ByPosNoHeight) {
      let { from: d, to: p } = r.doc.lineAt(e);
      return new as(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: a } = this.heightMetrics(r, s), c = r.doc.lineAt(e), u = l + c.length * a, h = c.number - o, f = i + l * h + a * (c.from - s - h);
    return new as(c.from, c.length, Math.max(i, Math.min(f, i + this.height - u)), u, 0);
  }
  forEachLine(e, t, r, i, s, o) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: l, perLine: a, perChar: c } = this.heightMetrics(r, s);
    for (let u = e, h = i; u <= t; ) {
      let f = r.doc.lineAt(u);
      if (u == e) {
        let p = f.number - l;
        h += a * p + c * (e - s - p);
      }
      let d = a + c * f.length;
      o(new as(f.from, f.length, h, d, 0)), h += d, u = f.to + 1;
    }
  }
  replace(e, t, r) {
    let i = this.length - t;
    if (i > 0) {
      let s = r[r.length - 1];
      s instanceof Rn ? r[r.length - 1] = new Rn(s.length + i) : r.push(null, new Rn(i - 1));
    }
    if (e > 0) {
      let s = r[0];
      s instanceof Rn ? r[0] = new Rn(e + s.length) : r.unshift(new Rn(e - 1), null);
    }
    return fr.of(r);
  }
  decomposeLeft(e, t) {
    t.push(new Rn(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new Rn(this.length - e - 1));
  }
  updateHeight(e, t = 0, r = !1, i) {
    let s = t + this.length;
    if (i && i.from <= t + this.length && i.more) {
      let o = [], l = Math.max(t, i.from), a = -1;
      for (i.from > t && o.push(new Rn(i.from - t - 1).updateHeight(e, t)); l <= s && i.more; ) {
        let u = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let h = i.heights[i.index++];
        a == -1 ? a = h : Math.abs(h - a) >= X0 && (a = -2);
        let f = new qr(u, h);
        f.outdated = !1, o.push(f), l += u + 1;
      }
      l <= s && o.push(null, new Rn(s - l).updateHeight(e, l));
      let c = fr.of(o);
      return (a < 0 || Math.abs(c.height - this.height) >= X0 || Math.abs(a - this.heightMetrics(e, t).perLine) >= X0) && (_c = !0), nm(this, c);
    } else (r || this.outdated) && (this.setHeight(e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class cz extends fr {
  constructor(e, t, r) {
    super(e.length + t + r.length, e.height + r.height, t | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, r, i) {
    let s = r + this.left.height;
    return e < s ? this.left.blockAt(e, t, r, i) : this.right.blockAt(e, t, s, i + this.left.length + this.break);
  }
  lineAt(e, t, r, i, s) {
    let o = i + this.left.height, l = s + this.left.length + this.break, a = t == Vt.ByHeight ? e < o : e < l, c = a ? this.left.lineAt(e, t, r, i, s) : this.right.lineAt(e, t, r, o, l);
    if (this.break || (a ? c.to < l : c.from > l))
      return c;
    let u = t == Vt.ByPosNoHeight ? Vt.ByPosNoHeight : Vt.ByPos;
    return a ? c.join(this.right.lineAt(l, u, r, o, l)) : this.left.lineAt(l, u, r, i, s).join(c);
  }
  forEachLine(e, t, r, i, s, o) {
    let l = i + this.left.height, a = s + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, t, r, i, s, o), t >= a && this.right.forEachLine(e, t, r, l, a, o);
    else {
      let c = this.lineAt(a, Vt.ByPos, r, i, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, s, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, r, l, a, o);
    }
  }
  replace(e, t, r) {
    let i = this.left.length + this.break;
    if (t < i)
      return this.balanced(this.left.replace(e, t, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, t - i, r));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of r)
      s.push(l);
    if (e > 0 && tw(s, o - 1), t < this.length) {
      let l = s.length;
      this.decomposeRight(t, s), tw(s, l);
    }
    return fr.of(s);
  }
  decomposeLeft(e, t) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (r++, e >= r && t.push(null)), e > r && this.right.decomposeLeft(e - r, t);
  }
  decomposeRight(e, t) {
    let r = this.left.length, i = r + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, t);
    e < r && this.left.decomposeRight(e, t), this.break && e < i && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? fr.of(this.break ? [e, null, t] : [e, t]) : (this.left = nm(this.left, e), this.right = nm(this.right, t), this.setHeight(e.height + t.height), this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, r = !1, i) {
    let { left: s, right: o } = this, l = t + s.length + this.break, a = null;
    return i && i.from <= t + s.length && i.more ? a = s = s.updateHeight(e, t, r, i) : s.updateHeight(e, t, r), i && i.from <= l + o.length && i.more ? a = o = o.updateHeight(e, l, r, i) : o.updateHeight(e, l, r), a ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function tw(n, e) {
  let t, r;
  n[e] == null && (t = n[e - 1]) instanceof Rn && (r = n[e + 1]) instanceof Rn && n.splice(e - 1, 3, new Rn(t.length + 1 + r.length));
}
const uz = 5;
class y3 {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let r = Math.min(t, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof qr ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new qr(r - this.pos, -1)), this.writtenTo = r, t > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, r) {
    if (e < t || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, s = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = t - e;
      r.block ? this.addBlock(new UC(o, i, r)) : (o || s || i >= uz) && this.addLineDeco(i, s, o);
    } else t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new qr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let r = new Rn(t - e);
    return this.oracle.doc.lineAt(e).to == t && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof qr)
      return e;
    let t = new qr(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += t, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof qr) && !this.isCovered ? this.nodes.push(new qr(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes)
      i instanceof qr && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, r, i) {
    let s = new y3(r, e);
    return ut.spans(t, r, i, s, 0), s.finish(r);
  }
}
function hz(n, e, t) {
  let r = new fz();
  return ut.compare(n, e, t, r, 0), r.changes;
}
class fz {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, r, i) {
    (e < t || r && r.heightRelevant || i && i.heightRelevant) && Y0(e, t, this.changes, 5);
  }
}
function dz(n, e) {
  let t = n.getBoundingClientRect(), r = n.ownerDocument, i = r.defaultView || window, s = Math.max(0, t.left), o = Math.min(i.innerWidth, t.right), l = Math.max(0, t.top), a = Math.min(i.innerHeight, t.bottom);
  for (let c = n.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let u = c, h = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
        let f = u.getBoundingClientRect();
        s = Math.max(s, f.left), o = Math.min(o, f.right), l = Math.max(l, f.top), a = Math.min(c == n.parentNode ? i.innerHeight : a, f.bottom);
      }
      c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: l - (t.top + e),
    bottom: Math.max(l, a) - (t.top + e)
  };
}
function pz(n) {
  let e = n.getBoundingClientRect(), t = n.ownerDocument.defaultView || window;
  return e.left < t.innerWidth && e.right > 0 && e.top < t.innerHeight && e.bottom > 0;
}
function mz(n, e) {
  let t = n.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class Rg {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.size = r, this.displaySize = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r], s = t[r];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return He.replace({
      widget: new gz(this.displaySize * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class gz extends wo {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class nw {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = rw, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = qt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(p3).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new lz(t), this.stateDeco = e.facet(Tf).filter((r) => typeof r != "function"), this.heightMap = fr.empty().applyChanges(this.stateDeco, ft.empty, this.heightOracle.setDoc(e.doc), [new di(0, 0, 0, e.doc.length)]);
    for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = He.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? t.head : t.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new e0(s, o));
      }
    }
    return this.viewports = e.sort((r, i) => r.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? rw : new b3(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(eh(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(Tf).filter((u) => typeof u != "function");
    let i = e.changedRanges, s = di.extendWithRanges(i, hz(r, this.stateDeco, e ? e.changes : wn.empty(this.state.doc.length))), o = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    ew(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), (this.heightMap.height != o || _c) && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = o);
    let a = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < a.from || t.range.head > a.to) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, t));
    let c = a.from != this.viewport.from || a.to != this.viewport.to;
    this.viewport = a, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(AC) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, r = window.getComputedStyle(t), i = this.heightOracle, s = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? qt.RTL : qt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), l = t.getBoundingClientRect(), a = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (l.width && l.height) {
      let { scaleX: C, scaleY: M } = eC(t, l);
      (C > 5e-3 && Math.abs(this.scaleX - C) > 5e-3 || M > 5e-3 && Math.abs(this.scaleY - M) > 5e-3) && (this.scaleX = C, this.scaleY = M, c |= 16, o = a = !0);
    }
    let h = (parseInt(r.paddingTop) || 0) * this.scaleY, f = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != f) && (this.paddingTop = h, this.paddingBottom = f, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (a = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
    let d = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != d && (this.scrollAnchorHeight = -1, this.scrollTop = d), this.scrolledToBottom = rC(e.scrollDOM);
    let p = (this.printing ? mz : dz)(t, this.paddingTop), m = p.top - this.pixelViewport.top, g = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let b = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (b != this.inView && (this.inView = b, b && (a = !0)), !this.inView && !this.scrollTarget && !pz(e.dom))
      return 0;
    let w = l.width;
    if ((this.contentDOMWidth != w || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), a) {
      let C = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(C) && (o = !0), o || i.lineWrapping && Math.abs(w - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: M, charWidth: T, textHeight: N } = e.docView.measureTextSize();
        o = M > 0 && i.refresh(s, M, T, N, Math.max(5, w / T), C), o && (e.docView.minWidth = 0, c |= 16);
      }
      m > 0 && g > 0 ? u = Math.max(m, g) : m < 0 && g < 0 && (u = Math.min(m, g)), ew();
      for (let M of this.viewports) {
        let T = M.from == this.viewport.from ? C : e.docView.measureVisibleLineHeights(M);
        this.heightMap = (o ? fr.empty().applyChanges(this.stateDeco, ft.empty, this.heightOracle, [new di(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new az(M.from, T));
      }
      _c && (c |= 2);
    }
    let k = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return k && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || k) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: l } = this, a = new e0(i.lineAt(o - r * 1e3, Vt.ByHeight, s, 0, 0).from, i.lineAt(l + (1 - r) * 1e3, Vt.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < a.from || c > a.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, Vt.ByPos, s, 0, 0), f;
        t.y == "center" ? f = (h.top + h.bottom) / 2 - u / 2 : t.y == "start" || t.y == "nearest" && c < a.from ? f = h.top : f = h.bottom - u, a = new e0(i.lineAt(f - 1e3 / 2, Vt.ByHeight, s, 0, 0).from, i.lineAt(f + u + 1e3 / 2, Vt.ByHeight, s, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, t) {
    let r = t.mapPos(e.from, -1), i = t.mapPos(e.to, 1);
    return new e0(this.heightMap.lineAt(r, Vt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Vt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, Vt.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, Vt.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || i <= o - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || s >= l + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && i > o - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let r = [];
    for (let i of e)
      t.touchesRange(i.from, i.to) || r.push(new Rg(t.mapPos(i.from), t.mapPos(i.to), i.size, i.displaySize));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != qt.LTR && !r)
      return [];
    let l = [], a = (u, h, f, d) => {
      if (h - u < s)
        return;
      let p = this.state.selection.main, m = [p.from];
      p.empty || m.push(p.to);
      for (let b of m)
        if (b > u && b < h) {
          a(u, b - 10, f, d), a(b + 10, h, f, d);
          return;
        }
      let g = bz(e, (b) => b.from >= f.from && b.to <= f.to && Math.abs(b.from - u) < s && Math.abs(b.to - h) < s && !m.some((w) => b.from < w && b.to > w));
      if (!g) {
        if (h < f.to && t && r && t.visibleRanges.some((k) => k.from <= h && k.to >= h)) {
          let k = t.moveToLineBoundary(G.cursor(h), !1, !0).head;
          k > u && (h = k);
        }
        let b = this.gapSize(f, u, h, d), w = r || b < 2e6 ? b : 2e6;
        g = new Rg(u, h, b, w);
      }
      l.push(g);
    }, c = (u) => {
      if (u.length < o || u.type != hr.Text)
        return;
      let h = yz(u.from, u.to, this.stateDeco);
      if (h.total < o)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, d, p;
      if (r) {
        let m = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, b;
        if (f != null) {
          let w = n0(h, f), k = ((this.visibleBottom - this.visibleTop) / 2 + m) / u.height;
          g = w - k, b = w + k;
        } else
          g = (this.visibleTop - u.top - m) / u.height, b = (this.visibleBottom - u.top + m) / u.height;
        d = t0(h, g), p = t0(h, b);
      } else {
        let m = h.total * this.heightOracle.charWidth, g = i * this.heightOracle.charWidth, b = 0;
        if (m > 2e6)
          for (let T of e)
            T.from >= u.from && T.from < u.to && T.size != T.displaySize && T.from * this.heightOracle.charWidth + b < this.pixelViewport.left && (b = T.size - T.displaySize);
        let w = this.pixelViewport.left + b, k = this.pixelViewport.right + b, C, M;
        if (f != null) {
          let T = n0(h, f), N = ((k - w) / 2 + g) / m;
          C = T - N, M = T + N;
        } else
          C = (w - g) / m, M = (k + g) / m;
        d = t0(h, C), p = t0(h, M);
      }
      d > u.from && a(u.from, d, u, h), p < u.to && a(p, u.to, u, h);
    };
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(c) : c(u);
    return l;
  }
  gapSize(e, t, r, i) {
    let s = n0(i, r) - n0(i, t);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Rg.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = He.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let r = [];
    ut.spans(t, this.viewport.from, this.viewport.to, {
      span(s, o) {
        r.push({ from: s, to: o });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (r.length != this.visibleRanges.length)
      i = 12;
    else
      for (let s = 0; s < r.length && !(i & 8); s++) {
        let o = this.visibleRanges[s], l = r[s];
        (o.from != l.from || o.to != l.to) && (i |= 4, e && e.mapPos(o.from, -1) == l.from && e.mapPos(o.to, 1) == l.to || (i |= 8));
      }
    return this.visibleRanges = r, i;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || eh(this.heightMap.lineAt(e, Vt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t) => t.top <= e && t.bottom >= e) || eh(this.heightMap.lineAt(this.scaler.fromDOM(e), Vt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return eh(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class e0 {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function yz(n, e, t) {
  let r = [], i = n, s = 0;
  return ut.spans(t, n, e, {
    span() {
    },
    point(o, l) {
      o > i && (r.push({ from: i, to: o }), s += o - i), i = l;
    }
  }, 20), i < e && (r.push({ from: i, to: e }), s += e - i), { total: s, ranges: r };
}
function t0({ total: n, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(n * t);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i], l = o - s;
    if (r <= l)
      return s + r;
    r -= l;
  }
}
function n0(n, e) {
  let t = 0;
  for (let { from: r, to: i } of n.ranges) {
    if (e <= i) {
      t += e - r;
      break;
    }
    t += i - r;
  }
  return t / n.total;
}
function bz(n, e) {
  for (let t of n)
    if (e(t))
      return t;
}
const rw = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
class b3 {
  constructor(e, t, r) {
    let i = 0, s = 0, o = 0;
    this.viewports = r.map(({ from: l, to: a }) => {
      let c = t.lineAt(l, Vt.ByPos, e, 0, 0).top, u = t.lineAt(a, Vt.ByPos, e, 0, 0).bottom;
      return i += u - c, { from: l, to: a, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (t.height - i);
    for (let l of this.viewports)
      l.domTop = o + (l.top - s) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return i + (e - r) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      r = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return r + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      r = s.bottom, i = s.domBottom;
    }
  }
  eq(e) {
    return e instanceof b3 ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((t, r) => t.from == e.viewports[r].from && t.to == e.viewports[r].to) : !1;
  }
}
function eh(n, e) {
  if (e.scale == 1)
    return n;
  let t = e.toDOM(n.top), r = e.toDOM(n.bottom);
  return new as(n.from, n.length, t, r - t, Array.isArray(n._content) ? n._content.map((i) => eh(i, e)) : n._content);
}
const r0 = /* @__PURE__ */ xe.define({ combine: (n) => n.join(" ") }), ny = /* @__PURE__ */ xe.define({ combine: (n) => n.indexOf(!0) > -1 }), ry = /* @__PURE__ */ al.newName(), KC = /* @__PURE__ */ al.newName(), GC = /* @__PURE__ */ al.newName(), YC = { "&light": "." + KC, "&dark": "." + GC };
function iy(n, e, t) {
  return new al(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return n;
        if (!t || !t[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return t[i];
      }) : n + " " + r;
    }
  });
}
const vz = /* @__PURE__ */ iy("." + ry, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, YC), wz = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Pg = we.ie && we.ie_version <= 11;
let xz = class {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new nB(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let r of t)
        this.queue.push(r);
      (we.ie && we.ie_version <= 11 || we.ios && e.composing) && t.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && we.android && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(we.chrome && we.chrome_version < 126) && (this.editContext = new Sz(e), e.state.facet(Js) && (e.contentDOM.editContext = this.editContext.editContext)), Pg && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, r) => t != e[r]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(Js) ? r.root.activeElement != this.dom : !G0(this.dom, i))
      return;
    let s = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (we.ie && we.ie_version <= 11 || we.android && we.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && zh(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = Cf(e.root);
    if (!t)
      return !1;
    let r = we.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && kz(this.view, t) || t;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let i = G0(this.dom, r);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && iB(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = t)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, wz), Pg && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Pg && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && yc(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, r = -1, i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (i = !0), t == -1 ? { from: t, to: r } = o : (t = Math.min(o.from, t), r = Math.max(o.to, r)));
    }
    return { from: t, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: t, typeOver: r } = this.processRecords(), i = this.selectionChanged && G0(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new FB(this.view, e, t, r);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = BC(this.view, t);
    return this.view.state == r && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let r = iw(t, e.previousSibling || e.target.previousSibling, -1), i = iw(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? t.posAfter(r) : t.posAtStart,
        to: i ? t.posBefore(i) : t.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Js) != e.state.facet(Js) && (e.view.contentDOM.editContext = e.state.facet(Js) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, t, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
};
function iw(n, e, t) {
  for (; e; ) {
    let r = Et.get(e);
    if (r && r.parent == n)
      return r;
    let i = e.parentNode;
    e = i != n.dom ? i : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function sw(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.docView.domAtPos(n.state.selection.main.anchor);
  return zh(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s };
}
function kz(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return sw(n, i);
  }
  let t = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.contentDOM.addEventListener("beforeinput", r, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", r, !0), t ? sw(n, t) : null;
}
class Sz {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let t = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (r) => {
      let i = e.state.selection.main, { anchor: s, head: o } = i, l = this.toEditorPos(r.updateRangeStart), a = this.toEditorPos(r.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: r.updateRangeStart, editorBase: l, drifted: !1 });
      let c = { from: l, to: a, insert: ft.of(r.text.split(`
`)) };
      if (c.from == this.from && s < this.from ? c.from = s : c.to == this.to && s > this.to && (c.to = s), c.from == c.to && !c.insert.length) {
        let u = G.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
        u.main.eq(i) || e.dispatch({ selection: u, userEvent: "select" });
        return;
      }
      if ((we.mac || we.android) && c.from == o - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (c = { from: l, to: a, insert: ft.of([r.text.replace(".", " ")]) }), this.pendingContextChange = c, !e.state.readOnly) {
        let u = this.to - this.from + (c.to - c.from + c.insert.length);
        g3(e, c, G.single(this.toEditorPos(r.selectionStart, u), this.toEditorPos(r.selectionEnd, u)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
    }, this.handlers.characterboundsupdate = (r) => {
      let i = [], s = null;
      for (let o = this.toEditorPos(r.rangeStart), l = this.toEditorPos(r.rangeEnd); o < l; o++) {
        let a = e.coordsForChar(o);
        s = a && new DOMRect(a.left, a.top, a.right - a.left, a.bottom - a.top) || s || new DOMRect(), i.push(s);
      }
      t.updateCharacterBounds(r.rangeStart, i);
    }, this.handlers.textformatupdate = (r) => {
      let i = [];
      for (let s of r.getTextFormats()) {
        let o = s.underlineStyle, l = s.underlineThickness;
        if (o != "None" && l != "None") {
          let a = this.toEditorPos(s.rangeStart), c = this.toEditorPos(s.rangeEnd);
          if (a < c) {
            let u = `text-decoration: underline ${o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${l == "Thin" ? 1 : 2}px`;
            i.push(He.mark({ attributes: { style: u } }).range(a, c));
          }
        }
      }
      e.dispatch({ effects: EC.of(He.set(i)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: r } = this.composing;
        this.composing = null, r && this.reset(e.state);
      }
    };
    for (let r in this.handlers)
      t.addEventListener(r, this.handlers[r]);
    this.measureReq = { read: (r) => {
      this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
      let i = Cf(r.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let t = 0, r = !1, i = this.pendingContextChange;
    return e.changes.iterChanges((s, o, l, a, c) => {
      if (r)
        return;
      let u = c.length - (o - s);
      if (i && o >= i.to)
        if (i.from == s && i.to == o && i.insert.eq(c)) {
          i = this.pendingContextChange = null, t += u, this.to += u;
          return;
        } else
          i = null, this.revertPending(e.state);
      if (s += t, o += t, o <= this.from)
        this.from += u, this.to += u;
      else if (s < this.to) {
        if (s < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
          r = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(s), this.toContextPos(o), c.toString()), this.to += u;
      }
      t += u;
    }), i && !r && this.revertPending(e.state), !r;
  }
  update(e) {
    let t = this.pendingContextChange, r = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || t) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: t } = e.selection.main;
    this.from = Math.max(
      0,
      t - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      t + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let t = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.from + t.insert.length), e.doc.sliceString(t.from, t.to));
  }
  setSelection(e) {
    let { main: t } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))), i = this.toContextPos(t.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
  }
  rangeIsValid(e) {
    let { head: t } = e.selection.main;
    return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, t = this.to - this.from) {
    e = Math.min(e, t);
    let r = this.composing;
    return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let t = this.composing;
    return t && t.drifted ? t.contextBase + (e - t.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
let Ce = class sy {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var t;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((s) => r(s, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || rB(e.parent) || document, this.viewState = new nw(e.state || jt.create(e)), e.scrollTo && e.scrollTo.is(Xd) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(dc).map((i) => new Ig(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new xz(this), this.inputState = new WB(this), this.inputState.ensureHandlers(this.plugins), this.docView = new B6(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((t = document.fonts) === null || t === void 0) && t.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof ur ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, r = !1, i, s = this.state;
    for (let f of e) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, l = 0, a = null;
    e.some((f) => f.annotation(qC)) ? (this.inputState.notifiedFocused = o, l = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, a = WC(s, o), a || (l = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(jt.phrases) != this.state.facet(jt.phrases))
      return this.setState(s);
    i = tm.create(this, s, e), i.flags |= l;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (h && (h = h.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          h = new bc(d.empty ? d : G.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(Xd) && (h = d.value.clip(this.state));
      }
      this.viewState.update(i, h), this.bidiCache = rm.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), t = this.docView.update(i), this.state.facet(Zu) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(r0) != i.state.facet(r0) && (this.viewState.mustMeasureContent = !0), (t || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), t && this.docViewUpdate(), !i.empty)
      for (let f of this.state.facet(Z4))
        try {
          f(i);
        } catch (d) {
          Mr(this.state, d, "update listener");
        }
    (a || u) && Promise.resolve().then(() => {
      a && this.state == a.startState && this.dispatch(a), u && !BC(this, u) && c.force && yc(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new nw(e), this.plugins = e.facet(dc).map((r) => new Ig(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new B6(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(dc), r = e.state.facet(dc);
    if (t != r) {
      let i = [];
      for (let s of r) {
        let o = t.indexOf(s);
        if (o < 0)
          i.push(new Ig(s));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, i.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    t != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let t = e.value;
      if (t && t.docViewUpdate)
        try {
          t.docViewUpdate(this);
        } catch (r) {
          Mr(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (rC(r))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(i);
            s = d.from, o = d.top;
          }
        this.updateState = 1;
        let a = this.viewState.measure(this);
        if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        a & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return Mr(this.state, p), ow;
          }
        }), h = tm.create(this, this.state, []), f = !1;
        h.flags |= a, t ? t.flags |= a : t = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), f = this.docView.update(h), f && this.docViewUpdate());
        for (let d = 0; d < c.length; d++)
          if (u[d] != ow)
            try {
              let p = c[d];
              p.write && p.write(u[d], this);
            } catch (p) {
              Mr(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                i = i + p, r.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let l of this.state.facet(Z4))
        l(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return ry + " " + (this.state.facet(ny) ? GC : KC) + " " + this.state.facet(r0);
  }
  updateAttrs() {
    let e = lw(this, IC, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Js) ? "true" : "false",
      class: "cm-content",
      style: `${we.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), lw(this, p3, t);
    let r = this.observer.ignore(() => {
      let i = K4(this.contentDOM, this.contentAttrs, t), s = K4(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, r;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(sy.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Zu);
    let e = this.state.facet(sy.cspNonce);
    al.mount(this.root, this.styleModules.concat(vz).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.plugin != e) && this.pluginMap.set(e, t = this.plugins.find((r) => r.plugin == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, r) {
    return Ng(this, e, V6(this, e, t, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return Ng(this, e, V6(this, e, t, (r) => _B(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = r[t ? r.length - 1 : 0];
    return G.cursor(s.side(t, i) + e.from, s.forward(!t, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, r = !0) {
    return PB(this, e, t, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, r) {
    return Ng(this, e, LB(this, e, t, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), _C(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, t);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[Jo.find(s, e - i.from, -1, t)];
    return t1(r, o.dir == qt.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(TC) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > Cz)
      return bC(e.length);
    let t = this.textDirectionAt(e.from), r;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t && (s.fresh || yC(s.isolates, r = L6(this, e))))
        return s.order;
    r || (r = L6(this, e));
    let i = bB(e.text, t, r);
    return this.bidiCache.push(new rm(e.from, e.to, t, r, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || we.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      tC(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return Xd.of(new bc(typeof e == "number" ? G.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return Xd.of(new bc(G.cursor(r.from), "start", "start", r.top - e, t, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return gn.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return gn.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let r = al.newName(), i = [r0.of(r), Zu.of(iy(`.${r}`, e))];
    return t && t.dark && i.push(ny.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return wl.lowest(Zu.of(iy("." + ry, e, YC)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let r = e.querySelector(".cm-content"), i = r && Et.get(r) || Et.get(e);
    return ((t = i?.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
};
Ce.styleModule = Zu;
Ce.inputHandler = CC;
Ce.clipboardInputFilter = f3;
Ce.clipboardOutputFilter = d3;
Ce.scrollHandler = OC;
Ce.focusChangeEffect = MC;
Ce.perLineTextDirection = TC;
Ce.exceptionSink = SC;
Ce.updateListener = Z4;
Ce.editable = Js;
Ce.mouseSelectionStyle = kC;
Ce.dragMovesSelection = xC;
Ce.clickAddsSelectionRange = wC;
Ce.decorations = Tf;
Ce.outerDecorations = DC;
Ce.atomicRanges = r1;
Ce.bidiIsolatedRanges = NC;
Ce.scrollMargins = RC;
Ce.darkTheme = ny;
Ce.cspNonce = /* @__PURE__ */ xe.define({ combine: (n) => n.length ? n[0] : "" });
Ce.contentAttributes = p3;
Ce.editorAttributes = IC;
Ce.lineWrapping = /* @__PURE__ */ Ce.contentAttributes.of({ class: "cm-lineWrapping" });
Ce.announce = /* @__PURE__ */ Xe.define();
const Cz = 4096, ow = {};
class rm {
  constructor(e, t, r, i, s, o) {
    this.from = e, this.to = t, this.dir = r, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh))
      return e;
    let r = [], i = e.length ? e[e.length - 1].dir : qt.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i && !t.touchesRange(o.from, o.to) && r.push(new rm(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function lw(n, e, t) {
  for (let r = n.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let s = r[i], o = typeof s == "function" ? s(n) : s;
    o && U4(o, t);
  }
  return t;
}
const Mz = we.mac ? "mac" : we.windows ? "win" : we.linux ? "linux" : "key";
function Tz(n, e) {
  const t = n.split(/-(?!$)/);
  let r = t[t.length - 1];
  r == "Space" && (r = " ");
  let i, s, o, l;
  for (let a = 0; a < t.length - 1; ++a) {
    const c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      l = !0;
    else if (/^a(lt)?$/i.test(c))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? l = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (r = "Alt-" + r), s && (r = "Ctrl-" + r), l && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function i0(n, e, t) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t !== !1 && e.shiftKey && (n = "Shift-" + n), n;
}
const Az = /* @__PURE__ */ wl.default(/* @__PURE__ */ Ce.domEventHandlers({
  keydown(n, e) {
    return XC(JC(e.state), n, e, "editor");
  }
})), tu = /* @__PURE__ */ xe.define({ enables: Az }), aw = /* @__PURE__ */ new WeakMap();
function JC(n) {
  let e = n.facet(tu), t = aw.get(e);
  return t || aw.set(e, t = Iz(e.reduce((r, i) => r.concat(i), []))), t;
}
function Oz(n, e, t) {
  return XC(JC(n.state), e, n, t);
}
let Wo = null;
const Ez = 4e3;
function Iz(n, e = Mz) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (o, l) => {
    let a = r[o];
    if (a == null)
      r[o] = l;
    else if (a != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, l, a, c, u) => {
    var h, f;
    let d = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), p = l.split(/ (?!$)/).map((b) => Tz(b, e));
    for (let b = 1; b < p.length; b++) {
      let w = p.slice(0, b).join(" ");
      i(w, !0), d[w] || (d[w] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(k) => {
          let C = Wo = { view: k, prefix: w, scope: o };
          return setTimeout(() => {
            Wo == C && (Wo = null);
          }, Ez), !0;
        }]
      });
    }
    let m = p.join(" ");
    i(m, !1);
    let g = d[m] || (d[m] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (h = d._any) === null || h === void 0 ? void 0 : h.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    a && g.run.push(a), c && (g.preventDefault = !0), u && (g.stopPropagation = !0);
  };
  for (let o of n) {
    let l = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of l) {
        let u = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: h } = o;
        for (let f in u)
          u[f].run.push((d) => h(d, oy));
      }
    let a = o[e] || o.key;
    if (a)
      for (let c of l)
        s(c, a, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + a, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
let oy = null;
function XC(n, e, t, r) {
  oy = e;
  let i = ZS(e), s = kr(i, 0), o = ls(s) == i.length && i != " ", l = "", a = !1, c = !1, u = !1;
  Wo && Wo.view == t && Wo.scope == r && (l = Wo.prefix + " ", FC.indexOf(e.keyCode) < 0 && (c = !0, Wo = null));
  let h = /* @__PURE__ */ new Set(), f = (g) => {
    if (g) {
      for (let b of g.run)
        if (!h.has(b) && (h.add(b), b(t)))
          return g.stopPropagation && (u = !0), !0;
      g.preventDefault && (g.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, d = n[r], p, m;
  return d && (f(d[l + i0(i, e, !o)]) ? a = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(we.windows && e.ctrlKey && e.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(we.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (p = ao[e.keyCode]) && p != i ? (f(d[l + i0(p, e, !0)]) || e.shiftKey && (m = Sf[e.keyCode]) != i && m != p && f(d[l + i0(m, e, !1)])) && (a = !0) : o && e.shiftKey && f(d[l + i0(i, e, !0)]) && (a = !0), !a && f(d._any) && (a = !0)), c && (a = !0), a && u && e.stopPropagation(), oy = null, a;
}
class ad {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, r, i, s) {
    this.className = e, this.left = t, this.top = r, this.width = i, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let s = ZC(e);
      return [new ad(t, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return Dz(e, t, r);
  }
}
function ZC(n) {
  let e = n.scrollDOM.getBoundingClientRect();
  return { left: (n.textDirection == qt.LTR ? e.left : e.right - n.scrollDOM.clientWidth * n.scaleX) - n.scrollDOM.scrollLeft * n.scaleX, top: e.top - n.scrollDOM.scrollTop * n.scaleY };
}
function cw(n, e, t, r) {
  let i = n.coordsAtPos(e, t * 2);
  if (!i)
    return r;
  let s = n.dom.getBoundingClientRect(), o = (i.top + i.bottom) / 2, l = n.posAtCoords({ x: s.left + 1, y: o }), a = n.posAtCoords({ x: s.right - 1, y: o });
  return l == null || a == null ? r : { from: Math.max(r.from, Math.min(l, a)), to: Math.min(r.to, Math.max(l, a)) };
}
function Dz(n, e, t) {
  if (t.to <= n.viewport.from || t.from >= n.viewport.to)
    return [];
  let r = Math.max(t.from, n.viewport.from), i = Math.min(t.to, n.viewport.to), s = n.textDirection == qt.LTR, o = n.contentDOM, l = o.getBoundingClientRect(), a = ZC(n), c = o.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = l.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), f = l.right - (u ? parseInt(u.paddingRight) : 0), d = ey(n, r, 1), p = ey(n, i, -1), m = d.type == hr.Text ? d : null, g = p.type == hr.Text ? p : null;
  if (m && (n.lineWrapping || d.widgetLineBreaks) && (m = cw(n, r, 1, m)), g && (n.lineWrapping || p.widgetLineBreaks) && (g = cw(n, i, -1, g)), m && g && m.from == g.from && m.to == g.to)
    return w(k(t.from, t.to, m));
  {
    let M = m ? k(t.from, null, m) : C(d, !1), T = g ? k(null, t.to, g) : C(p, !0), N = [];
    return (m || d).to < (g || p).from - (m && g ? 1 : 0) || d.widgetLineBreaks > 1 && M.bottom + n.defaultLineHeight / 2 < T.top ? N.push(b(h, M.bottom, f, T.top)) : M.bottom < T.top && n.elementAtHeight((M.bottom + T.top) / 2).type == hr.Text && (M.bottom = T.top = (M.bottom + T.top) / 2), w(M).concat(N).concat(w(T));
  }
  function b(M, T, N, B) {
    return new ad(e, M - a.left, T - a.top, N - M, B - T);
  }
  function w({ top: M, bottom: T, horizontal: N }) {
    let B = [];
    for (let $ = 0; $ < N.length; $ += 2)
      B.push(b(N[$], M, N[$ + 1], T));
    return B;
  }
  function k(M, T, N) {
    let B = 1e9, $ = -1e9, R = [];
    function V(ie, he, Se, ge, ye) {
      let ze = n.coordsAtPos(ie, ie == N.to ? -2 : 2), I = n.coordsAtPos(Se, Se == N.from ? 2 : -2);
      !ze || !I || (B = Math.min(ze.top, I.top, B), $ = Math.max(ze.bottom, I.bottom, $), ye == qt.LTR ? R.push(s && he ? h : ze.left, s && ge ? f : I.right) : R.push(!s && ge ? h : I.left, !s && he ? f : ze.right));
    }
    let z = M ?? N.from, ue = T ?? N.to;
    for (let ie of n.visibleRanges)
      if (ie.to > z && ie.from < ue)
        for (let he = Math.max(ie.from, z), Se = Math.min(ie.to, ue); ; ) {
          let ge = n.state.doc.lineAt(he);
          for (let ye of n.bidiSpans(ge)) {
            let ze = ye.from + ge.from, I = ye.to + ge.from;
            if (ze >= Se)
              break;
            I > he && V(Math.max(ze, he), M == null && ze <= z, Math.min(I, Se), T == null && I >= ue, ye.dir);
          }
          if (he = ge.to + 1, he >= Se)
            break;
        }
    return R.length == 0 && V(z, M == null, ue, T == null, n.textDirection), { top: B, bottom: $, horizontal: R };
  }
  function C(M, T) {
    let N = l.top + (T ? M.top : M.bottom);
    return { top: N, bottom: N, horizontal: [] };
  }
}
function Nz(n, e) {
  return n.constructor == e.constructor && n.eq(e);
}
class Rz {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Z0) != e.state.facet(Z0) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, r = e.facet(Z0);
    for (; t < r.length && r[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, r) => !Nz(t, this.drawn[r]))) {
      let t = this.dom.firstChild, r = 0;
      for (let i of e)
        i.update && t && i.constructor && this.drawn[r].constructor && i.update(t, this.drawn[r]) ? (t = t.nextSibling, r++) : this.dom.insertBefore(i.draw(), t);
      for (; t; ) {
        let i = t.nextSibling;
        t.remove(), t = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Z0 = /* @__PURE__ */ xe.define();
function QC(n) {
  return [
    gn.define((e) => new Rz(e, n)),
    Z0.of(n)
  ];
}
const Af = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function eM(n = {}) {
  return [
    Af.of(n),
    Pz,
    _z,
    Lz,
    AC.of(!0)
  ];
}
function tM(n) {
  return n.startState.facet(Af) != n.state.facet(Af);
}
const Pz = /* @__PURE__ */ QC({
  above: !0,
  markers(n) {
    let { state: e } = n, t = e.facet(Af), r = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty || t.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = i.empty ? i : G.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let a of ad.forRange(n, o, l))
          r.push(a);
      }
    }
    return r;
  },
  update(n, e) {
    n.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = tM(n);
    return t && uw(n.state, e), n.docChanged || n.selectionSet || t;
  },
  mount(n, e) {
    uw(e.state, n);
  },
  class: "cm-cursorLayer"
});
function uw(n, e) {
  e.style.animationDuration = n.facet(Af).cursorBlinkRate + "ms";
}
const _z = /* @__PURE__ */ QC({
  above: !1,
  markers(n) {
    return n.state.selection.ranges.map((e) => e.empty ? [] : ad.forRange(n, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(n, e) {
    return n.docChanged || n.selectionSet || n.viewportChanged || tM(n);
  },
  class: "cm-selectionLayer"
}), Lz = /* @__PURE__ */ wl.highest(/* @__PURE__ */ Ce.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), nM = /* @__PURE__ */ Xe.define({
  map(n, e) {
    return n == null ? null : e.mapPos(n);
  }
}), th = /* @__PURE__ */ On.define({
  create() {
    return null;
  },
  update(n, e) {
    return n != null && (n = e.changes.mapPos(n)), e.effects.reduce((t, r) => r.is(nM) ? r.value : t, n);
  }
}), Bz = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var e;
    let t = n.state.field(th);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(th) != t || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, e = n.state.field(th), t = e != null && n.coordsAtPos(e);
    if (!t)
      return null;
    let r = n.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - r.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: t.top - r.top + n.scrollDOM.scrollTop * n.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      n ? (this.cursor.style.left = n.left / e + "px", this.cursor.style.top = n.top / t + "px", this.cursor.style.height = n.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(th) != n && this.view.dispatch({ effects: nM.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function zz() {
  return [th, Bz];
}
function hw(n, e, t, r, i) {
  e.lastIndex = 0;
  for (let s = n.iterRange(t, r), o = t, l; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; l = e.exec(s.value); )
        i(o + l.index, l);
}
function Fz(n, e) {
  let t = n.visibleRanges;
  if (t.length == 1 && t[0].from == n.viewport.from && t[0].to == n.viewport.to)
    return t;
  let r = [];
  for (let { from: i, to: s } of t)
    i = Math.max(n.state.doc.lineAt(i).from, i - e), s = Math.min(n.state.doc.lineAt(s).to, s + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = s : r.push({ from: i, to: s });
  return r;
}
class Hz {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: r, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, i)
      this.addMatch = (l, a, c, u) => i(u, c, c + l[0].length, l, a);
    else if (typeof r == "function")
      this.addMatch = (l, a, c, u) => {
        let h = r(l, a, c);
        h && u(c, c + l[0].length, h);
      };
    else if (r)
      this.addMatch = (l, a, c, u) => u(c, c + l[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new lo(), r = t.add.bind(t);
    for (let { from: i, to: s } of Fz(e, this.maxLength))
      hw(e.state.doc, this.regexp, i, s, (o, l) => this.addMatch(l, e, o, r));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let r = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, o, l, a) => {
      a >= e.view.viewport.from && l <= e.view.viewport.to && (r = Math.min(l, r), i = Math.max(a, i));
    }), e.viewportMoved || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, t.map(e.changes), r, i) : t;
  }
  updateRange(e, t, r, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, r), l = Math.min(s.to, i);
      if (l >= o) {
        let a = e.state.doc.lineAt(o), c = a.to < l ? e.state.doc.lineAt(l) : a, u = Math.max(s.from, a.from), h = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > a.from; o--)
            if (this.boundary.test(a.text[o - 1 - a.from])) {
              u = o;
              break;
            }
          for (; l < c.to; l++)
            if (this.boundary.test(c.text[l - c.from])) {
              h = l;
              break;
            }
        }
        let f = [], d, p = (m, g, b) => f.push(b.range(m, g));
        if (a == c)
          for (this.regexp.lastIndex = u - a.from; (d = this.regexp.exec(a.text)) && d.index < h - a.from; )
            this.addMatch(d, e, d.index + a.from, p);
        else
          hw(e.state.doc, this.regexp, u, h, (m, g) => this.addMatch(g, e, m, p));
        t = t.update({ filterFrom: u, filterTo: h, filter: (m, g) => m < u || g > h, add: f });
      }
    }
    return t;
  }
}
const ly = /x/.unicode != null ? "gu" : "g", $z = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, ly), Vz = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let _g = null;
function qz() {
  var n;
  if (_g == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    _g = ((n = e.tabSize) !== null && n !== void 0 ? n : e.MozTabSize) != null;
  }
  return _g || !1;
}
const Q0 = /* @__PURE__ */ xe.define({
  combine(n) {
    let e = Ts(n, {
      render: null,
      specialChars: $z,
      addSpecialChars: null
    });
    return (e.replaceTabs = !qz()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, ly)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, ly)), e;
  }
});
function Wz(n = {}) {
  return [Q0.of(n), jz()];
}
let fw = null;
function jz() {
  return fw || (fw = gn.fromClass(class {
    constructor(n) {
      this.view = n, this.decorations = He.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(n.state.facet(Q0)), this.decorations = this.decorator.createDeco(n);
    }
    makeDecorator(n) {
      return new Hz({
        regexp: n.specialChars,
        decoration: (e, t, r) => {
          let { doc: i } = t.state, s = kr(e[0], 0);
          if (s == 9) {
            let o = i.lineAt(r), l = t.state.tabSize, a = eu(o.text, l, r - o.from);
            return He.replace({
              widget: new Yz((l - a % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = He.replace({ widget: new Gz(n, s) }));
        },
        boundary: n.replaceTabs ? void 0 : /[^]/
      });
    }
    update(n) {
      let e = n.state.facet(Q0);
      n.startState.facet(Q0) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(n.view)) : this.decorations = this.decorator.updateDeco(n, this.decorations);
    }
  }, {
    decorations: (n) => n.decorations
  }));
}
const Uz = "•";
function Kz(n) {
  return n >= 32 ? Uz : n == 10 ? "␤" : String.fromCharCode(9216 + n);
}
class Gz extends wo {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = Kz(this.code), r = e.state.phrase("Control character") + " " + (Vz[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, t);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = t, s.title = r, s.setAttribute("aria-label", r), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class Yz extends wo {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function Jz() {
  return Zz;
}
const Xz = /* @__PURE__ */ He.line({ class: "cm-activeLine" }), Zz = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.docChanged || n.selectionSet) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = -1, t = [];
    for (let r of n.state.selection.ranges) {
      let i = n.lineBlockAt(r.head);
      i.from > e && (t.push(Xz.range(i.from)), e = i.from);
    }
    return He.set(t);
  }
}, {
  decorations: (n) => n.decorations
}), ay = 2e3;
function Qz(n, e, t) {
  let r = Math.min(e.line, t.line), i = Math.max(e.line, t.line), s = [];
  if (e.off > ay || t.off > ay || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), l = Math.max(e.off, t.off);
    for (let a = r; a <= i; a++) {
      let c = n.doc.line(a);
      c.length <= l && s.push(G.range(c.from + o, c.to + l));
    }
  } else {
    let o = Math.min(e.col, t.col), l = Math.max(e.col, t.col);
    for (let a = r; a <= i; a++) {
      let c = n.doc.line(a), u = F4(c.text, o, n.tabSize, !0);
      if (u < 0)
        s.push(G.cursor(c.to));
      else {
        let h = F4(c.text, l, n.tabSize);
        s.push(G.range(c.from + u, c.from + h));
      }
    }
  }
  return s;
}
function eF(n, e) {
  let t = n.coordsAtPos(n.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / n.defaultCharacterWidth)) : -1;
}
function dw(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = n.state.doc.lineAt(t), i = t - r.from, s = i > ay ? -1 : i == r.length ? eF(n, e.clientX) : eu(r.text, n.state.tabSize, t - r.from);
  return { line: r.number, col: s, off: i };
}
function tF(n, e) {
  let t = dw(n, e), r = n.state.selection;
  return t ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(t.line).from), o = i.state.doc.lineAt(s);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, r = r.map(i.changes);
      }
    },
    get(i, s, o) {
      let l = dw(n, i);
      if (!l)
        return r;
      let a = Qz(n.state, t, l);
      return a.length ? o ? G.create(a.concat(r.ranges)) : G.create(a) : r;
    }
  } : null;
}
function nF(n) {
  let e = ((t) => t.altKey && t.button == 0);
  return Ce.mouseSelectionStyle.of((t, r) => e(r) ? tF(t, r) : null);
}
const rF = {
  Alt: [18, (n) => !!n.altKey],
  Control: [17, (n) => !!n.ctrlKey],
  Shift: [16, (n) => !!n.shiftKey],
  Meta: [91, (n) => !!n.metaKey]
}, iF = { style: "cursor: crosshair" };
function sF(n = {}) {
  let [e, t] = rF[n.key || "Alt"], r = gn.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || t(i));
      },
      keyup(i) {
        (i.keyCode == e || !t(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(t(i));
      }
    }
  });
  return [
    r,
    Ce.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(r)) === null || s === void 0) && s.isDown ? iF : null;
    })
  ];
}
const _u = "-10000px";
class rM {
  constructor(e, t, r, i) {
    this.facet = t, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = r(o, s));
  }
  update(e, t) {
    var r;
    let i = e.state.facet(this.facet), s = i.filter((a) => a);
    if (i === this.input) {
      for (let a of this.tooltipViews)
        a.update && a.update(e);
      return !1;
    }
    let o = [], l = t ? [] : null;
    for (let a = 0; a < s.length; a++) {
      let c = s[a], u = -1;
      if (c) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let f = this.tooltips[h];
          f && f.create == c.create && (u = h);
        }
        if (u < 0)
          o[a] = this.createTooltipView(c, a ? o[a - 1] : null), l && (l[a] = !!c.above);
        else {
          let h = o[a] = this.tooltipViews[u];
          l && (l[a] = t[u]), h.update && h.update(e);
        }
      }
    }
    for (let a of this.tooltipViews)
      o.indexOf(a) < 0 && (this.removeTooltipView(a), (r = a.destroy) === null || r === void 0 || r.call(a));
    return t && (l.forEach((a, c) => t[c] = a), t.length = l.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function oF(n) {
  let e = n.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const Lg = /* @__PURE__ */ xe.define({
  combine: (n) => {
    var e, t, r;
    return {
      position: we.ios ? "absolute" : ((e = n.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = n.find((i) => i.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((r = n.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || oF
    };
  }
}), pw = /* @__PURE__ */ new WeakMap(), v3 = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = n.state.facet(Lg);
    this.position = e.position, this.parent = e.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new rM(n, w3, (t, r) => this.createTooltip(t, r), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(n, this.above);
    e && this.observeIntersection();
    let t = e || n.geometryChanged, r = n.state.facet(Lg);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      t = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      t = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(n, e) {
    let t = n.create(this.view), r = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), n.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", t.dom.appendChild(i);
    }
    return t.dom.style.position = this.position, t.dom.style.top = _u, t.dom.style.left = "0px", this.container.insertBefore(t.dom, r), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var n, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (n = r.destroy) === null || n === void 0 || n.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = 1, e = 1, t = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: s } = this.manager.tooltipViews[0];
      if (we.gecko)
        t = s.offsetParent != this.container.ownerDocument.body;
      else if (s.style.top == _u && s.style.left == "0px") {
        let o = s.getBoundingClientRect();
        t = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (t || this.position == "absolute")
      if (this.parent) {
        let s = this.parent.getBoundingClientRect();
        s.width && s.height && (n = s.width / this.parent.offsetWidth, e = s.height / this.parent.offsetHeight);
      } else
        ({ scaleX: n, scaleY: e } = this.view.viewState);
    let r = this.view.scrollDOM.getBoundingClientRect(), i = m3(this.view);
    return {
      visible: {
        left: r.left + i.left,
        top: r.top + i.top,
        right: r.right - i.right,
        bottom: r.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((s, o) => {
        let l = this.manager.tooltipViews[o];
        return l.getCoords ? l.getCoords(s.pos) : this.view.coordsAtPos(s.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: s }) => s.getBoundingClientRect()),
      space: this.view.state.facet(Lg).tooltipSpace(this.view),
      scaleX: n,
      scaleY: e,
      makeAbsolute: t
    };
  }
  writeMeasure(n) {
    var e;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { visible: t, space: r, scaleX: i, scaleY: s } = n, o = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let a = this.manager.tooltips[l], c = this.manager.tooltipViews[l], { dom: u } = c, h = n.pos[l], f = n.size[l];
      if (!h || a.clip !== !1 && (h.bottom <= Math.max(t.top, r.top) || h.top >= Math.min(t.bottom, r.bottom) || h.right < Math.max(t.left, r.left) - 0.1 || h.left > Math.min(t.right, r.right) + 0.1)) {
        u.style.top = _u;
        continue;
      }
      let d = a.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = d ? 7 : 0, m = f.right - f.left, g = (e = pw.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top, b = c.offset || aF, w = this.view.textDirection == qt.LTR, k = f.width > r.right - r.left ? w ? r.left : r.right - f.width : w ? Math.max(r.left, Math.min(h.left - (d ? 14 : 0) + b.x, r.right - m)) : Math.min(Math.max(r.left, h.left - m + (d ? 14 : 0) - b.x), r.right - m), C = this.above[l];
      !a.strictSide && (C ? h.top - g - p - b.y < r.top : h.bottom + g + p + b.y > r.bottom) && C == r.bottom - h.bottom > h.top - r.top && (C = this.above[l] = !C);
      let M = (C ? h.top - r.top : r.bottom - h.bottom) - p;
      if (M < g && c.resize !== !1) {
        if (M < this.view.defaultLineHeight) {
          u.style.top = _u;
          continue;
        }
        pw.set(c, g), u.style.height = (g = M) / s + "px";
      } else u.style.height && (u.style.height = "");
      let T = C ? h.top - g - p - b.y : h.bottom + p + b.y, N = k + m;
      if (c.overlap !== !0)
        for (let B of o)
          B.left < N && B.right > k && B.top < T + g && B.bottom > T && (T = C ? B.top - g - 2 - p : B.bottom + p + 2);
      if (this.position == "absolute" ? (u.style.top = (T - n.parent.top) / s + "px", mw(u, (k - n.parent.left) / i)) : (u.style.top = T / s + "px", mw(u, k / i)), d) {
        let B = h.left + (w ? b.x : -b.x) - (k + 14 - 7);
        d.style.left = B / i + "px";
      }
      c.overlap !== !0 && o.push({ left: k, top: T, right: N, bottom: T + g }), u.classList.toggle("cm-tooltip-above", C), u.classList.toggle("cm-tooltip-below", !C), c.positioned && c.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = _u;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function mw(n, e) {
  let t = parseInt(n.style.left, 10);
  (isNaN(t) || Math.abs(e - t) > 1) && (n.style.left = e + "px");
}
const lF = /* @__PURE__ */ Ce.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), aF = { x: 0, y: 0 }, w3 = /* @__PURE__ */ xe.define({
  enables: [v3, lF]
}), im = /* @__PURE__ */ xe.define({
  combine: (n) => n.reduce((e, t) => e.concat(t), [])
});
class s1 {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new s1(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new rM(e, im, (t, r) => this.createHostedView(t, r), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (t === void 0)
          t = i;
        else if (t !== i)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const cF = /* @__PURE__ */ w3.compute([im], (n) => {
  let e = n.facet(im);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var r;
      return (r = t.end) !== null && r !== void 0 ? r : t.pos;
    })),
    create: s1.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class uF {
  constructor(e, t, r, i, s) {
    this.view = e, this.source = t, this.field = r, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, r = e.docView.nearest(t.target);
    if (!r)
      return;
    let i, s = 1;
    if (r instanceof Yo)
      i = r.posAtStart;
    else {
      if (i = e.posAtCoords(t), i == null)
        return;
      let l = e.coordsAtPos(i);
      if (!l || t.y < l.top || t.y > l.bottom || t.x < l.left - e.defaultCharacterWidth || t.x > l.right + e.defaultCharacterWidth)
        return;
      let a = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), c = a && a.dir == qt.RTL ? -1 : 1;
      s = t.x < l.left ? -c : c;
    }
    let o = this.source(e, i, s);
    if (o?.then) {
      let l = this.pending = { pos: i };
      o.then((a) => {
        this.pending == l && (this.pending = null, a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) }));
      }, (a) => Mr(e.state, a, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(v3), t = e ? e.manager.tooltips.findIndex((r) => r.create == s1.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: s } = this;
    if (i.length && s && !hF(s.dom, e) || this.pending) {
      let { pos: o } = i[0] || this.pending, l = (r = (t = i[0]) === null || t === void 0 ? void 0 : t.end) !== null && r !== void 0 ? r : o;
      (o == l ? this.view.posAtCoords(this.lastMove) != o : !fF(this.view, o, l, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (r) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const s0 = 4;
function hF(n, e) {
  let { left: t, right: r, top: i, bottom: s } = n.getBoundingClientRect(), o;
  if (o = n.querySelector(".cm-tooltip-arrow")) {
    let l = o.getBoundingClientRect();
    i = Math.min(l.top, i), s = Math.max(l.bottom, s);
  }
  return e.clientX >= t - s0 && e.clientX <= r + s0 && e.clientY >= i - s0 && e.clientY <= s + s0;
}
function fF(n, e, t, r, i, s) {
  let o = n.scrollDOM.getBoundingClientRect(), l = n.documentTop + n.documentPadding.top + n.contentHeight;
  if (o.left > r || o.right < r || o.top > i || Math.min(o.bottom, l) < i)
    return !1;
  let a = n.posAtCoords({ x: r, y: i }, !1);
  return a >= e && a <= t;
}
function dF(n, e = {}) {
  let t = Xe.define(), r = On.define({
    create() {
      return [];
    },
    update(i, s) {
      if (i.length && (e.hideOnChange && (s.docChanged || s.selection) ? i = [] : e.hideOn && (i = i.filter((o) => !e.hideOn(s, o))), s.docChanged)) {
        let o = [];
        for (let l of i) {
          let a = s.changes.mapPos(l.pos, -1, Bn.TrackDel);
          if (a != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), l);
            c.pos = a, c.end != null && (c.end = s.changes.mapPos(c.end)), o.push(c);
          }
        }
        i = o;
      }
      for (let o of s.effects)
        o.is(t) && (i = o.value), o.is(pF) && (i = []);
      return i;
    },
    provide: (i) => im.from(i)
  });
  return {
    active: r,
    extension: [
      r,
      gn.define((i) => new uF(
        i,
        n,
        r,
        t,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      cF
    ]
  };
}
function iM(n, e) {
  let t = n.plugin(v3);
  if (!t)
    return null;
  let r = t.manager.tooltips.indexOf(e);
  return r < 0 ? null : t.manager.tooltipViews[r];
}
const pF = /* @__PURE__ */ Xe.define(), gw = /* @__PURE__ */ xe.define({
  combine(n) {
    let e, t;
    for (let r of n)
      e = e || r.topContainer, t = t || r.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Of(n, e) {
  let t = n.plugin(sM), r = t ? t.specs.indexOf(e) : -1;
  return r > -1 ? t.panels[r] : null;
}
const sM = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.input = n.state.facet(Ef), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(n));
    let e = n.state.facet(gw);
    this.top = new o0(n, !0, e.topContainer), this.bottom = new o0(n, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(n) {
    let e = n.state.facet(gw);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new o0(n.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new o0(n.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = n.state.facet(Ef);
    if (t != this.input) {
      let r = t.filter((a) => a), i = [], s = [], o = [], l = [];
      for (let a of r) {
        let c = this.specs.indexOf(a), u;
        c < 0 ? (u = a(n.view), l.push(u)) : (u = this.panels[c], u.update && u.update(n)), i.push(u), (u.top ? s : o).push(u);
      }
      this.specs = r, this.panels = i, this.top.sync(s), this.bottom.sync(o);
      for (let a of l)
        a.dom.classList.add("cm-panel"), a.mount && a.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(n);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (n) => Ce.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class o0 {
  constructor(e, t, r) {
    this.view = e, this.top = t, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = yw(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = yw(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function yw(n) {
  let e = n.nextSibling;
  return n.remove(), e;
}
const Ef = /* @__PURE__ */ xe.define({
  enables: sM
});
class uo extends ga {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
uo.prototype.elementClass = "";
uo.prototype.toDOM = void 0;
uo.prototype.mapMode = Bn.TrackBefore;
uo.prototype.startSide = uo.prototype.endSide = -1;
uo.prototype.point = !0;
const ep = /* @__PURE__ */ xe.define(), mF = /* @__PURE__ */ xe.define(), gF = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => ut.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {},
  side: "before"
}, Hh = /* @__PURE__ */ xe.define();
function yF(n) {
  return [oM(), Hh.of({ ...gF, ...n })];
}
const bw = /* @__PURE__ */ xe.define({
  combine: (n) => n.some((e) => e)
});
function oM(n) {
  return [
    bF
  ];
}
const bF = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.domAfter = null, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = n.state.facet(Hh).map((e) => new ww(n, e)), this.fixed = !n.state.facet(bw);
    for (let e of this.gutters)
      e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
    this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  getDOMAfter() {
    return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
  }
  update(n) {
    if (this.updateGutters(n)) {
      let e = this.prevViewport, t = n.view.viewport, r = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(r < (t.to - t.from) * 0.8);
    }
    if (n.geometryChanged) {
      let e = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
    }
    this.view.state.facet(bw) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let e = this.dom.nextSibling;
    n && (this.dom.remove(), this.domAfter && this.domAfter.remove());
    let t = ut.iter(this.view.state.facet(ep), this.view.viewport.from), r = [], i = this.gutters.map((s) => new vF(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(s.type)) {
        let o = !0;
        for (let l of s.type)
          if (l.type == hr.Text && o) {
            cy(t, r, l.from);
            for (let a of i)
              a.line(this.view, l, r);
            o = !1;
          } else if (l.widget)
            for (let a of i)
              a.widget(this.view, l);
      } else if (s.type == hr.Text) {
        cy(t, r, s.from);
        for (let o of i)
          o.line(this.view, s, r);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    n && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
  }
  updateGutters(n) {
    let e = n.startState.facet(Hh), t = n.state.facet(Hh), r = n.docChanged || n.heightChanged || n.viewportChanged || !ut.eq(n.startState.facet(ep), n.state.facet(ep), n.view.viewport.from, n.view.viewport.to);
    if (e == t)
      for (let i of this.gutters)
        i.update(n) && (r = !0);
    else {
      r = !0;
      let i = [];
      for (let s of t) {
        let o = e.indexOf(s);
        o < 0 ? i.push(new ww(this.view, s)) : (this.gutters[o].update(n), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        s.config.side == "after" ? this.getDOMAfter().appendChild(s.dom) : this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove(), this.domAfter && this.domAfter.remove();
  }
}, {
  provide: (n) => Ce.scrollMargins.of((e) => {
    let t = e.plugin(n);
    if (!t || t.gutters.length == 0 || !t.fixed)
      return null;
    let r = t.dom.offsetWidth * e.scaleX, i = t.domAfter ? t.domAfter.offsetWidth * e.scaleX : 0;
    return e.textDirection == qt.LTR ? { left: r, right: i } : { right: r, left: i };
  })
});
function vw(n) {
  return Array.isArray(n) ? n : [n];
}
function cy(n, e, t) {
  for (; n.value && n.from <= t; )
    n.from == t && e.push(n.value), n.next();
}
class vF {
  constructor(e, t, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = ut.iter(e.markers, t.from);
  }
  addElement(e, t, r) {
    let { gutter: i } = this, s = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == i.elements.length) {
      let l = new lM(e, o, s, r);
      i.elements.push(l), i.dom.appendChild(l.dom);
    } else
      i.elements[this.i].update(e, o, s, r);
    this.height = t.bottom, this.i++;
  }
  line(e, t, r) {
    let i = [];
    cy(this.cursor, i, t.from), r.length && (i = i.concat(r));
    let s = this.gutter.config.lineMarker(e, t, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, i);
  }
  widget(e, t) {
    let r = this.gutter.config.widgetMarker(e, t.widget, t), i = r ? [r] : null;
    for (let s of e.state.facet(mF)) {
      let o = s(e, t.widget, t);
      o && (i || (i = [])).push(o);
    }
    i && this.addElement(e, t, i);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class ww {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in t.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let a = s.getBoundingClientRect();
          o = (a.top + a.bottom) / 2;
        } else
          o = i.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[r](e, l, i) && i.preventDefault();
      });
    this.markers = vw(t.markers(e)), t.initialSpacer && (this.spacer = new lM(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = vw(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !ut.eq(this.markers, t, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class lM {
  constructor(e, t, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, r, i);
  }
  update(e, t, r, i) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), wF(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, t) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o, a = s < t.length ? t[s++] : null, c = !1;
      if (a) {
        let u = a.elementClass;
        u && (r += " " + u);
        for (let h = o; h < this.markers.length; h++)
          if (this.markers[h].compare(a)) {
            l = h, c = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(i);
          let h = i.nextSibling;
          i.remove(), i = h;
        }
      }
      if (!a)
        break;
      a.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(a.toDOM(e), i)), c && o++;
    }
    this.dom.className = r, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function wF(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].compare(e[t]))
      return !1;
  return !0;
}
const xF = /* @__PURE__ */ xe.define(), kF = /* @__PURE__ */ xe.define(), pc = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let r = Object.assign({}, e);
        for (let i in t) {
          let s = r[i], o = t[i];
          r[i] = s ? (l, a, c) => s(l, a, c) || o(l, a, c) : o;
        }
        return r;
      }
    });
  }
});
class Bg extends uo {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function zg(n, e) {
  return n.state.facet(pc).formatNumber(e, n.state);
}
const SF = /* @__PURE__ */ Hh.compute([pc], (n) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(xF);
  },
  lineMarker(e, t, r) {
    return r.some((i) => i.toDOM) ? null : new Bg(zg(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: (e, t, r) => {
    for (let i of e.state.facet(kF)) {
      let s = i(e, t, r);
      if (s)
        return s;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(pc) != e.state.facet(pc),
  initialSpacer(e) {
    return new Bg(zg(e, xw(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let r = zg(t.view, xw(t.view.state.doc.lines));
    return r == e.number ? e : new Bg(r);
  },
  domEventHandlers: n.facet(pc).domEventHandlers,
  side: "before"
}));
function CF(n = {}) {
  return [
    pc.of(n),
    oM(),
    SF
  ];
}
function xw(n) {
  let e = 9;
  for (; e < n; )
    e = e * 10 + 9;
  return e;
}
const MF = /* @__PURE__ */ new class extends uo {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), TF = /* @__PURE__ */ ep.compute(["selection"], (n) => {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.head).from;
    i > t && (t = i, e.push(MF.range(i)));
  }
  return ut.of(e);
});
function AF() {
  return TF;
}
let OF = 0;
class si {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.set = t, this.base = r, this.modified = i, this.id = OF++;
  }
  toString() {
    let { name: e } = this;
    for (let t of this.modified)
      t.name && (e = `${t.name}(${e})`);
    return e;
  }
  static define(e, t) {
    let r = typeof e == "string" ? e : "?";
    if (e instanceof si && (t = e), t?.base)
      throw new Error("Can not derive from a modified tag");
    let i = new si(r, [], null, []);
    if (i.set.push(i), t)
      for (let s of t.set)
        i.set.push(s);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let t = new sm(e);
    return (r) => r.modified.indexOf(t) > -1 ? r : sm.get(r.base || r, r.modified.concat(t).sort((i, s) => i.id - s.id));
  }
}
let EF = 0;
class sm {
  constructor(e) {
    this.name = e, this.instances = [], this.id = EF++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let r = t[0].instances.find((l) => l.base == e && IF(t, l.modified));
    if (r)
      return r;
    let i = [], s = new si(e.name, i, e, t);
    for (let l of t)
      l.instances.push(s);
    let o = DF(t);
    for (let l of e.set)
      if (!l.modified.length)
        for (let a of o)
          i.push(sm.get(l, a));
    return s;
  }
}
function IF(n, e) {
  return n.length == e.length && n.every((t, r) => t == e[r]);
}
function DF(n) {
  let e = [[]];
  for (let t = 0; t < n.length; t++)
    for (let r = 0, i = e.length; r < i; r++)
      e.push(e[r].concat(n[t]));
  return e.sort((t, r) => r.length - t.length);
}
function NF(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    Array.isArray(r) || (r = [r]);
    for (let i of t.split(" "))
      if (i) {
        let s = [], o = 2, l = i;
        for (let h = 0; ; ) {
          if (l == "..." && h > 0 && h + 3 == i.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), h += f[0].length, h == i.length)
            break;
          let d = i[h++];
          if (h == i.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + i);
          l = i.slice(h);
        }
        let a = s.length - 1, c = s[a];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let u = new om(r, o, a > 0 ? s.slice(0, a) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return aM.add(e);
}
const aM = new st();
class om {
  constructor(e, t, r, i) {
    this.tags = e, this.mode = t, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
om.empty = new om([], 2, null);
function cM(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let s of n)
    if (!Array.isArray(s.tag))
      t[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        t[o.id] = s.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let l of s)
        for (let a of l.set) {
          let c = t[a.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function RF(n, e) {
  let t = null;
  for (let r of n) {
    let i = r.style(e);
    i && (t = t ? t + " " + i : i);
  }
  return t;
}
function PF(n, e, t, r = 0, i = n.length) {
  let s = new _F(r, Array.isArray(e) ? e : [e], t);
  s.highlightRange(n.cursor(), r, i, "", s.highlighters), s.flush(i);
}
class _F {
  constructor(e, t, r) {
    this.at = e, this.highlighters = t, this.span = r, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, r, i, s) {
    let { type: o, from: l, to: a } = e;
    if (l >= r || a <= t)
      return;
    o.isTop && (s = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let c = i, u = LF(e) || om.empty, h = RF(s, u.tags);
    if (h && (c && (c += " "), c += h, u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(t, l), c), u.opaque)
      return;
    let f = e.tree && e.tree.prop(st.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + l, 1), p = this.highlighters.filter((g) => !g.scope || g.scope(f.tree.type)), m = e.firstChild();
      for (let g = 0, b = l; ; g++) {
        let w = g < f.overlay.length ? f.overlay[g] : null, k = w ? w.from + l : a, C = Math.max(t, b), M = Math.min(r, k);
        if (C < M && m)
          for (; e.from < M && (this.highlightRange(e, C, M, i, s), this.startSpan(Math.min(M, e.to), c), !(e.to >= k || !e.nextSibling())); )
            ;
        if (!w || k > r)
          break;
        b = w.to + l, b > t && (this.highlightRange(d.cursor(), Math.max(t, w.from + l), Math.min(r, b), "", p), this.startSpan(Math.min(r, b), c));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      f && (i = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, t, r, i, s), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function LF(n) {
  let e = n.type.prop(aM);
  for (; e && e.context && !n.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const me = si.define, l0 = me(), Bo = me(), kw = me(Bo), Sw = me(Bo), zo = me(), a0 = me(zo), Fg = me(zo), Zi = me(), Dl = me(Zi), Yi = me(), Ji = me(), uy = me(), Lu = me(uy), c0 = me(), U = {
  /**
  A comment.
  */
  comment: l0,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: me(l0),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: me(l0),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: me(l0),
  /**
  Any kind of identifier.
  */
  name: Bo,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: me(Bo),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: kw,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: me(kw),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Sw,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: me(Sw),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: me(Bo),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: me(Bo),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: me(Bo),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: me(Bo),
  /**
  A literal value.
  */
  literal: zo,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: a0,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: me(a0),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: me(a0),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: me(a0),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Fg,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: me(Fg),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: me(Fg),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: me(zo),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: me(zo),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: me(zo),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: me(zo),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: me(zo),
  /**
  A language keyword.
  */
  keyword: Yi,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: me(Yi),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: me(Yi),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: me(Yi),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: me(Yi),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: me(Yi),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: me(Yi),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: me(Yi),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: me(Yi),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: me(Yi),
  /**
  An operator.
  */
  operator: Ji,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: me(Ji),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: me(Ji),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: me(Ji),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: me(Ji),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: me(Ji),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: me(Ji),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: me(Ji),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: me(Ji),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: me(Ji),
  /**
  Program or markup punctuation.
  */
  punctuation: uy,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: me(uy),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Lu,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: me(Lu),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: me(Lu),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: me(Lu),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: me(Lu),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Zi,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Dl,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: me(Dl),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: me(Dl),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: me(Dl),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: me(Dl),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: me(Dl),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: me(Dl),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: me(Zi),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: me(Zi),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: me(Zi),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: me(Zi),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: me(Zi),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: me(Zi),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: me(Zi),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: me(Zi),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: me(),
  /**
  Deleted text.
  */
  deleted: me(),
  /**
  Changed text.
  */
  changed: me(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: me(),
  /**
  Metadata or meta-instruction.
  */
  meta: c0,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: me(c0),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: me(c0),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: me(c0),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: si.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: si.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: si.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: si.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: si.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: si.defineModifier("special")
};
for (let n in U) {
  let e = U[n];
  e instanceof si && (e.name = n);
}
cM([
  { tag: U.link, class: "tok-link" },
  { tag: U.heading, class: "tok-heading" },
  { tag: U.emphasis, class: "tok-emphasis" },
  { tag: U.strong, class: "tok-strong" },
  { tag: U.keyword, class: "tok-keyword" },
  { tag: U.atom, class: "tok-atom" },
  { tag: U.bool, class: "tok-bool" },
  { tag: U.url, class: "tok-url" },
  { tag: U.labelName, class: "tok-labelName" },
  { tag: U.inserted, class: "tok-inserted" },
  { tag: U.deleted, class: "tok-deleted" },
  { tag: U.literal, class: "tok-literal" },
  { tag: U.string, class: "tok-string" },
  { tag: U.number, class: "tok-number" },
  { tag: [U.regexp, U.escape, U.special(U.string)], class: "tok-string2" },
  { tag: U.variableName, class: "tok-variableName" },
  { tag: U.local(U.variableName), class: "tok-variableName tok-local" },
  { tag: U.definition(U.variableName), class: "tok-variableName tok-definition" },
  { tag: U.special(U.variableName), class: "tok-variableName2" },
  { tag: U.definition(U.propertyName), class: "tok-propertyName tok-definition" },
  { tag: U.typeName, class: "tok-typeName" },
  { tag: U.namespace, class: "tok-namespace" },
  { tag: U.className, class: "tok-className" },
  { tag: U.macroName, class: "tok-macroName" },
  { tag: U.propertyName, class: "tok-propertyName" },
  { tag: U.operator, class: "tok-operator" },
  { tag: U.comment, class: "tok-comment" },
  { tag: U.meta, class: "tok-meta" },
  { tag: U.invalid, class: "tok-invalid" },
  { tag: U.punctuation, class: "tok-punctuation" }
]);
var Hg;
const Xl = /* @__PURE__ */ new st();
function uM(n) {
  return xe.define({
    combine: n ? (e) => e.concat(n) : void 0
  });
}
const BF = /* @__PURE__ */ new st();
class ci {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], i = "") {
    this.data = e, this.name = i, jt.prototype.hasOwnProperty("tree") || Object.defineProperty(jt.prototype, "tree", { get() {
      return Fn(this);
    } }), this.parser = t, this.extension = [
      ul.of(this),
      jt.languageData.of((s, o, l) => {
        let a = Cw(s, o, l), c = a.type.prop(Xl);
        if (!c)
          return [];
        let u = s.facet(c), h = a.type.prop(BF);
        if (h) {
          let f = a.resolve(o - a.from, l);
          for (let d of h)
            if (d.test(f, s)) {
              let p = s.facet(d.facet);
              return d.type == "replace" ? p : p.concat(u);
            }
        }
        return u;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return Cw(e, t, r).type.prop(Xl) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(ul);
    if (t?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], i = (s, o) => {
      if (s.prop(Xl) == this.data) {
        r.push({ from: o, to: o + s.length });
        return;
      }
      let l = s.prop(st.mounted);
      if (l) {
        if (l.tree.prop(Xl) == this.data) {
          if (l.overlay)
            for (let a of l.overlay)
              r.push({ from: a.from + o, to: a.to + o });
          else
            r.push({ from: o, to: o + s.length });
          return;
        } else if (l.overlay) {
          let a = r.length;
          if (i(l.tree, l.overlay[0].from + o), r.length > a)
            return;
        }
      }
      for (let a = 0; a < s.children.length; a++) {
        let c = s.children[a];
        c instanceof Bt && i(c, s.positions[a] + o);
      }
    };
    return i(Fn(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
ci.setState = /* @__PURE__ */ Xe.define();
function Cw(n, e, t) {
  let r = n.facet(ul), i = Fn(n).topNode;
  if (!r || r.allowsNesting)
    for (let s = i; s; s = s.enter(e, t, Zt.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
class hy extends ci {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = uM(e.languageData);
    return new hy(t, e.parser.configure({
      props: [Xl.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new hy(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Fn(n) {
  let e = n.field(ci.state, !1);
  return e ? e.tree : Bt.empty;
}
class zF {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let Bu = null, fy = class dy {
  constructor(e, t, r = [], i, s, o, l, a) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = l, this.scheduleOn = a, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new dy(e, t, [], Bt.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new zF(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != Bt.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(to.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(to.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = Bu;
    Bu = this;
    try {
      return e();
    } finally {
      Bu = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = Mw(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let a = [];
      if (e.iterChangedRanges((c, u, h, f) => a.push({ fromA: c, toA: u, fromB: h, toB: f })), r = to.applyChanges(r, a), i = Bt.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
          u < h && l.push({ from: u, to: h });
        }
      }
    }
    return new dy(this.parser, t, r, i, s, o, l, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: s } = this.skipped[r];
      i < e.to && s > e.from && (this.fragments = Mw(this.fragments, i, s), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends DS {
      createParse(t, r, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let a = Bu;
            if (a) {
              for (let c of i)
                a.tempSkipped.push(c);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new Bt(Qr.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Bu;
  }
};
function Mw(n, e, t) {
  return to.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class Lc {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new Lc(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = fy.create(e.facet(ul).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new Lc(r);
  }
}
ci.state = /* @__PURE__ */ On.define({
  create: Lc.init,
  update(n, e) {
    for (let t of e.effects)
      if (t.is(ci.setState))
        return t.value;
    return e.startState.facet(ul) != e.state.facet(ul) ? Lc.init(e.state) : n.apply(e);
  }
});
let hM = (n) => {
  let e = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (hM = (n) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const $g = typeof navigator < "u" && (!((Hg = navigator.scheduling) === null || Hg === void 0) && Hg.isInputPending) ? () => navigator.scheduling.isInputPending() : null, FF = /* @__PURE__ */ gn.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(ci.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(ci.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = hM(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, s = r.field(ci.state);
    if (s.tree == s.context.tree && s.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !$g ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = s.context.treeLen < i && r.doc.length > i + 1e3, a = s.context.work(() => $g && $g() || Date.now() > o, i + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (a || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: ci.setState.of(new Lc(s.context)) })), this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Mr(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), ul = /* @__PURE__ */ xe.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    ci.state,
    FF,
    Ce.contentAttributes.compute([n], (e) => {
      let t = e.facet(n);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class HF {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
class q {
  constructor(e, t, r, i, s, o = void 0) {
    this.name = e, this.alias = t, this.extensions = r, this.filename = i, this.loadFunc = s, this.support = o, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: t, support: r } = e;
    if (!t) {
      if (!r)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      t = () => Promise.resolve(r);
    }
    return new q(e.name, (e.alias || []).concat(e.name).map((i) => i.toLowerCase()), e.extensions || [], e.filename, t, r);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, t) {
    for (let i of e)
      if (i.filename && i.filename.test(t))
        return i;
    let r = /\.([^.]+)$/.exec(t);
    if (r) {
      for (let i of e)
        if (i.extensions.indexOf(r[1]) > -1)
          return i;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, t, r = !0) {
    t = t.toLowerCase();
    for (let i of e)
      if (i.alias.some((s) => s == t))
        return i;
    if (r)
      for (let i of e)
        for (let s of i.alias) {
          let o = t.indexOf(s);
          if (o > -1 && (s.length > 2 || !/\w/.test(t[o - 1]) && !/\w/.test(t[o + s.length])))
            return i;
        }
    return null;
  }
}
const $F = /* @__PURE__ */ xe.define(), o1 = /* @__PURE__ */ xe.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let e = n[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return e;
  }
});
function wa(n) {
  let e = n.facet(o1);
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
}
function If(n, e) {
  let t = "", r = n.tabSize, i = n.facet(o1)[0];
  if (i == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    t += i;
  return t;
}
function x3(n, e) {
  n instanceof jt && (n = new l1(n));
  for (let r of n.state.facet($F)) {
    let i = r(n, e);
    if (i !== void 0)
      return i;
  }
  let t = Fn(n.state);
  return t.length >= e ? VF(n, t, e) : null;
}
class l1 {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = wa(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= r.from && i <= r.to ? s && i == e ? { text: "", from: e } : (t < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, t);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), s = this.countColumn(r, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return eu(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const fM = /* @__PURE__ */ new st();
function VF(n, e, t) {
  let r = e.resolveStack(t), i = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
  if (i != r.node) {
    let s = [];
    for (let o = i; o && !(o.from < r.node.from || o.to > r.node.to || o.from == r.node.from && o.type == r.node.type); o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      r = { node: s[o], next: r };
  }
  return dM(r, n, t);
}
function dM(n, e, t) {
  for (let r = n; r; r = r.next) {
    let i = WF(r.node);
    if (i)
      return i(k3.create(e, t, r));
  }
  return 0;
}
function qF(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function WF(n) {
  let e = n.type.prop(fM);
  if (e)
    return e;
  let t = n.firstChild, r;
  if (t && (r = t.type.prop(st.closedBy))) {
    let i = n.lastChild, s = i && r.indexOf(i.name) > -1;
    return (o) => pM(o, !0, 1, void 0, s && !qF(o) ? i.from : void 0);
  }
  return n.parent == null ? jF : null;
}
function jF() {
  return 0;
}
class k3 extends l1 {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new k3(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (UF(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return dM(this.context.next, this.base, this.pos);
  }
}
function UF(n, e) {
  for (let t = e; t; t = t.parent)
    if (n == t)
      return !0;
  return !1;
}
function KF(n) {
  let e = n.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let i = n.options.simulateBreak, s = n.state.doc.lineAt(t.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let l = t.to; ; ) {
    let a = e.childAfter(l);
    if (!a || a == r)
      return null;
    if (!a.type.isSkipped) {
      if (a.from >= o)
        return null;
      let c = /^ */.exec(s.text.slice(t.to - s.from))[0].length;
      return { from: t.from, to: t.to + c };
    }
    l = a.to;
  }
}
function zue({ closing: n, align: e = !0, units: t = 1 }) {
  return (r) => pM(r, e, t, n);
}
function pM(n, e, t, r, i) {
  let s = n.textAfter, o = s.match(/^\s*/)[0].length, l = r && s.slice(o, o + r.length) == r || i == n.pos + o, a = e ? KF(n) : null;
  return a ? l ? n.column(a.from) : n.column(a.to) : n.baseIndent + (l ? 0 : n.unit * t);
}
const Fue = (n) => n.baseIndent;
function Hue({ except: n, units: e = 1 } = {}) {
  return (t) => {
    let r = n && n.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const GF = 200;
function YF() {
  return jt.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let e = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!e.length)
      return n;
    let t = n.newDoc, { head: r } = n.newSelection.main, i = t.lineAt(r);
    if (r > i.from + GF)
      return n;
    let s = t.sliceString(i.from, r);
    if (!e.some((c) => c.test(s)))
      return n;
    let { state: o } = n, l = -1, a = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == l)
        continue;
      l = u.from;
      let h = x3(o, u.from);
      if (h == null)
        continue;
      let f = /^\s*/.exec(u.text)[0], d = If(o, h);
      f != d && a.push({ from: u.from, to: u.from + f.length, insert: d });
    }
    return a.length ? [n, { changes: a, sequential: !0 }] : n;
  });
}
const JF = /* @__PURE__ */ xe.define(), XF = /* @__PURE__ */ new st();
function $ue(n) {
  let e = n.firstChild, t = n.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? n.to : t.from } : null;
}
function ZF(n, e, t) {
  let r = Fn(n);
  if (r.length < t)
    return null;
  let i = r.resolveStack(t, 1), s = null;
  for (let o = i; o; o = o.next) {
    let l = o.node;
    if (l.to <= t || l.from > t)
      continue;
    if (s && l.from < e)
      break;
    let a = l.type.prop(XF);
    if (a && (l.to < r.length - 50 || r.length == n.doc.length || !QF(l))) {
      let c = a(l, n);
      c && c.from <= t && c.from >= e && c.to > t && (s = c);
    }
  }
  return s;
}
function QF(n) {
  let e = n.lastChild;
  return e && e.to == n.to && e.type.isError;
}
function lm(n, e, t) {
  for (let r of n.facet(JF)) {
    let i = r(n, e, t);
    if (i)
      return i;
  }
  return ZF(n, e, t);
}
function mM(n, e) {
  let t = e.mapPos(n.from, 1), r = e.mapPos(n.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const a1 = /* @__PURE__ */ Xe.define({ map: mM }), cd = /* @__PURE__ */ Xe.define({ map: mM });
function gM(n) {
  let e = [];
  for (let { head: t } of n.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(n.lineBlockAt(t));
  return e;
}
const xa = /* @__PURE__ */ On.define({
  create() {
    return He.none;
  },
  update(n, e) {
    e.isUserEvent("delete") && e.changes.iterChangedRanges((t, r) => n = Tw(n, t, r)), n = n.map(e.changes);
    for (let t of e.effects)
      if (t.is(a1) && !eH(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(vM), i = r ? He.replace({ widget: new lH(r(e.state, t.value)) }) : Aw;
        n = n.update({ add: [i.range(t.value.from, t.value.to)] });
      } else t.is(cd) && (n = n.update({
        filter: (r, i) => t.value.from != r || t.value.to != i,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    return e.selection && (n = Tw(n, e.selection.main.head)), n;
  },
  provide: (n) => Ce.decorations.from(n),
  toJSON(n, e) {
    let t = [];
    return n.between(0, e.doc.length, (r, i) => {
      t.push(r, i);
    }), t;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < n.length; ) {
      let r = n[t++], i = n[t++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Aw.range(r, i));
    }
    return He.set(e, !0);
  }
});
function Tw(n, e, t = e) {
  let r = !1;
  return n.between(e, t, (i, s) => {
    i < t && s > e && (r = !0);
  }), r ? n.update({
    filterFrom: e,
    filterTo: t,
    filter: (i, s) => i >= t || s <= e
  }) : n;
}
function am(n, e, t) {
  var r;
  let i = null;
  return (r = n.field(xa, !1)) === null || r === void 0 || r.between(e, t, (s, o) => {
    (!i || i.from > s) && (i = { from: s, to: o });
  }), i;
}
function eH(n, e, t) {
  let r = !1;
  return n.between(e, e, (i, s) => {
    i == e && s == t && (r = !0);
  }), r;
}
function yM(n, e) {
  return n.field(xa, !1) ? e : e.concat(Xe.appendConfig.of(wM()));
}
const tH = (n) => {
  for (let e of gM(n)) {
    let t = lm(n.state, e.from, e.to);
    if (t)
      return n.dispatch({ effects: yM(n.state, [a1.of(t), bM(n, t)]) }), !0;
  }
  return !1;
}, nH = (n) => {
  if (!n.state.field(xa, !1))
    return !1;
  let e = [];
  for (let t of gM(n)) {
    let r = am(n.state, t.from, t.to);
    r && e.push(cd.of(r), bM(n, r, !1));
  }
  return e.length && n.dispatch({ effects: e }), e.length > 0;
};
function bM(n, e, t = !0) {
  let r = n.state.doc.lineAt(e.from).number, i = n.state.doc.lineAt(e.to).number;
  return Ce.announce.of(`${n.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${n.state.phrase("to")} ${i}.`);
}
const rH = (n) => {
  let { state: e } = n, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = n.lineBlockAt(r), s = lm(e, i.from, i.to);
    s && t.push(a1.of(s)), r = (s ? n.lineBlockAt(s.to) : i).to + 1;
  }
  return t.length && n.dispatch({ effects: yM(n.state, t) }), !!t.length;
}, iH = (n) => {
  let e = n.state.field(xa, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, n.state.doc.length, (r, i) => {
    t.push(cd.of({ from: r, to: i }));
  }), n.dispatch({ effects: t }), !0;
}, sH = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: tH },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: nH },
  { key: "Ctrl-Alt-[", run: rH },
  { key: "Ctrl-Alt-]", run: iH }
], oH = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, vM = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, oH);
  }
});
function wM(n) {
  return [xa, uH];
}
function xM(n, e) {
  let { state: t } = n, r = t.facet(vM), i = (o) => {
    let l = n.lineBlockAt(n.posAtDOM(o.target)), a = am(n.state, l.from, l.to);
    a && n.dispatch({ effects: cd.of(a) }), o.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(n, i, e);
  let s = document.createElement("span");
  return s.textContent = r.placeholderText, s.setAttribute("aria-label", t.phrase("folded code")), s.title = t.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
}
const Aw = /* @__PURE__ */ He.replace({ widget: /* @__PURE__ */ new class extends wo {
  toDOM(n) {
    return xM(n, null);
  }
}() });
class lH extends wo {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return xM(e, this.value);
  }
}
const aH = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Vg extends uo {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function cH(n = {}) {
  let e = { ...aH, ...n }, t = new Vg(e, !0), r = new Vg(e, !1), i = gn.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(ul) != o.state.facet(ul) || o.startState.field(xa, !1) != o.state.field(xa, !1) || Fn(o.startState) != Fn(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let l = new lo();
      for (let a of o.viewportLineBlocks) {
        let c = am(o.state, a.from, a.to) ? r : lm(o.state, a.from, a.to) ? t : null;
        c && l.add(a.from, a.from, c);
      }
      return l.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    i,
    yF({
      class: "cm-foldGutter",
      markers(o) {
        var l;
        return ((l = o.plugin(i)) === null || l === void 0 ? void 0 : l.markers) || ut.empty;
      },
      initialSpacer() {
        return new Vg(e, !1);
      },
      domEventHandlers: {
        ...s,
        click: (o, l, a) => {
          if (s.click && s.click(o, l, a))
            return !0;
          let c = am(o.state, l.from, l.to);
          if (c)
            return o.dispatch({ effects: cd.of(c) }), !0;
          let u = lm(o.state, l.from, l.to);
          return u ? (o.dispatch({ effects: a1.of(u) }), !0) : !1;
        }
      }
    }),
    wM()
  ];
}
const uH = /* @__PURE__ */ Ce.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class ud {
  constructor(e, t) {
    this.specs = e;
    let r;
    function i(l) {
      let a = al.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + a] = l, a;
    }
    const s = typeof t.all == "string" ? t.all : t.all ? i(t.all) : void 0, o = t.scope;
    this.scope = o instanceof ci ? (l) => l.prop(Xl) == o.data : o ? (l) => l == o : void 0, this.style = cM(e.map((l) => ({
      tag: l.tag,
      class: l.class || i(Object.assign({}, l, { tag: null }))
    })), {
      all: s
    }).style, this.module = r ? new al(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new ud(e, t || {});
  }
}
const py = /* @__PURE__ */ xe.define(), kM = /* @__PURE__ */ xe.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function qg(n) {
  let e = n.facet(py);
  return e.length ? e : n.facet(kM);
}
function SM(n, e) {
  let t = [fH], r;
  return n instanceof ud && (n.module && t.push(Ce.styleModule.of(n.module)), r = n.themeType), e?.fallback ? t.push(kM.of(n)) : r ? t.push(py.computeN([Ce.darkTheme], (i) => i.facet(Ce.darkTheme) == (r == "dark") ? [n] : [])) : t.push(py.of(n)), t;
}
class hH {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Fn(e.state), this.decorations = this.buildDeco(e, qg(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = Fn(e.state), r = qg(e.state), i = r != qg(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    t.length < s.to && !i && t.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (t != this.tree || e.viewportChanged || i) && (this.tree = t, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = s.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return He.none;
    let r = new lo();
    for (let { from: i, to: s } of e.visibleRanges)
      PF(this.tree, t, (o, l, a) => {
        r.add(o, l, this.markCache[a] || (this.markCache[a] = He.mark({ class: a })));
      }, i, s);
    return r.finish();
  }
}
const fH = /* @__PURE__ */ wl.high(/* @__PURE__ */ gn.fromClass(hH, {
  decorations: (n) => n.decorations
})), dH = /* @__PURE__ */ ud.define([
  {
    tag: U.meta,
    color: "#404740"
  },
  {
    tag: U.link,
    textDecoration: "underline"
  },
  {
    tag: U.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: U.emphasis,
    fontStyle: "italic"
  },
  {
    tag: U.strong,
    fontWeight: "bold"
  },
  {
    tag: U.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: U.keyword,
    color: "#708"
  },
  {
    tag: [U.atom, U.bool, U.url, U.contentSeparator, U.labelName],
    color: "#219"
  },
  {
    tag: [U.literal, U.inserted],
    color: "#164"
  },
  {
    tag: [U.string, U.deleted],
    color: "#a11"
  },
  {
    tag: [U.regexp, U.escape, /* @__PURE__ */ U.special(U.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ U.definition(U.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ U.local(U.variableName),
    color: "#30a"
  },
  {
    tag: [U.typeName, U.namespace],
    color: "#085"
  },
  {
    tag: U.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ U.special(U.variableName), U.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ U.definition(U.propertyName),
    color: "#00c"
  },
  {
    tag: U.comment,
    color: "#940"
  },
  {
    tag: U.invalid,
    color: "#f00"
  }
]), pH = /* @__PURE__ */ Ce.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), CM = 1e4, MM = "()[]{}", TM = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, {
      afterCursor: !0,
      brackets: MM,
      maxScanDistance: CM,
      renderMatch: yH
    });
  }
}), mH = /* @__PURE__ */ He.mark({ class: "cm-matchingBracket" }), gH = /* @__PURE__ */ He.mark({ class: "cm-nonmatchingBracket" });
function yH(n) {
  let e = [], t = n.matched ? mH : gH;
  return e.push(t.range(n.start.from, n.start.to)), n.end && e.push(t.range(n.end.from, n.end.to)), e;
}
const bH = /* @__PURE__ */ On.define({
  create() {
    return He.none;
  },
  update(n, e) {
    if (!e.docChanged && !e.selection)
      return n;
    let t = [], r = e.state.facet(TM);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = hs(e.state, i.head, -1, r) || i.head > 0 && hs(e.state, i.head - 1, 1, r) || r.afterCursor && (hs(e.state, i.head, 1, r) || i.head < e.state.doc.length && hs(e.state, i.head + 1, -1, r));
      s && (t = t.concat(r.renderMatch(s, e.state)));
    }
    return He.set(t, !0);
  },
  provide: (n) => Ce.decorations.from(n)
}), vH = [
  bH,
  pH
];
function wH(n = {}) {
  return [TM.of(n), vH];
}
const xH = /* @__PURE__ */ new st();
function my(n, e, t) {
  let r = n.prop(e < 0 ? st.openedBy : st.closedBy);
  if (r)
    return r;
  if (n.name.length == 1) {
    let i = t.indexOf(n.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [t[i + e]];
  }
  return null;
}
function gy(n) {
  let e = n.type.prop(xH);
  return e ? e(n.node) : n;
}
function hs(n, e, t, r = {}) {
  let i = r.maxScanDistance || CM, s = r.brackets || MM, o = Fn(n), l = o.resolveInner(e, t);
  for (let a = l; a; a = a.parent) {
    let c = my(a.type, t, s);
    if (c && a.from < a.to) {
      let u = gy(a);
      if (u && (t > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return kH(n, e, t, a, u, c, s);
    }
  }
  return SH(n, e, t, o, l.type, i, s);
}
function kH(n, e, t, r, i, s, o) {
  let l = r.parent, a = { from: i.from, to: i.to }, c = 0, u = l?.cursor();
  if (u && (t < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (t < 0 ? u.to <= r.from : u.from >= r.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let h = gy(u);
          return { start: a, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (my(u.type, t, o))
          c++;
        else if (my(u.type, -t, o)) {
          if (c == 0) {
            let h = gy(u);
            return {
              start: a,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? u.prevSibling() : u.nextSibling());
  return { start: a, matched: !1 };
}
function SH(n, e, t, r, i, s, o) {
  let l = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1), a = o.indexOf(l);
  if (a < 0 || a % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, u = n.doc.iterRange(e, t > 0 ? n.doc.length : 0), h = 0;
  for (let f = 0; !u.next().done && f <= s; ) {
    let d = u.value;
    t < 0 && (f += d.length);
    let p = e + f * t;
    for (let m = t > 0 ? 0 : d.length - 1, g = t > 0 ? d.length : -1; m != g; m += t) {
      let b = o.indexOf(d[m]);
      if (!(b < 0 || r.resolveInner(p + m, 1).type != i))
        if (b % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: c, end: { from: p + m, to: p + m + 1 }, matched: b >> 1 == a >> 1 };
          h--;
        }
    }
    t > 0 && (f += d.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
function Ow(n, e, t, r = 0, i = 0) {
  e == null && (e = n.search(/[^\s\u00a0]/), e == -1 && (e = n.length));
  let s = i;
  for (let o = r; o < e; o++)
    n.charCodeAt(o) == 9 ? s += t - s % t : s++;
  return s;
}
class AM {
  /**
  Create a stream.
  */
  constructor(e, t, r, i) {
    this.string = e, this.tabSize = t, this.indentUnit = r, this.overrideIndent = i, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(e) {
    let t = this.string.charAt(this.pos), r;
    if (typeof e == "string" ? r = t == e : r = t && (e instanceof RegExp ? e.test(t) : e(t)), r)
      return ++this.pos, t;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(e) {
    let t = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > t;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(e) {
    let t = this.string.indexOf(e, this.pos);
    if (t > -1)
      return this.pos = t, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(e) {
    this.pos -= e;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = Ow(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : Ow(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(e, t, r) {
    if (typeof e == "string") {
      let i = (o) => r ? o.toLowerCase() : o, s = this.string.substr(this.pos, e.length);
      return i(s) == i(e) ? (t !== !1 && (this.pos += e.length), !0) : null;
    } else {
      let i = this.string.slice(this.pos).match(e);
      return i && i.index > 0 ? null : (i && t !== !1 && (this.pos += i[0].length), i);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function CH(n) {
  return {
    name: n.name || "",
    token: n.token,
    blankLine: n.blankLine || (() => {
    }),
    startState: n.startState || (() => !0),
    copyState: n.copyState || MH,
    indent: n.indent || (() => null),
    languageData: n.languageData || {},
    tokenTable: n.tokenTable || M3,
    mergeTokens: n.mergeTokens !== !1
  };
}
function MH(n) {
  if (typeof n != "object")
    return n;
  let e = {};
  for (let t in n) {
    let r = n[t];
    e[t] = r instanceof Array ? r.slice() : r;
  }
  return e;
}
const Ew = /* @__PURE__ */ new WeakMap();
class S3 extends ci {
  constructor(e) {
    let t = uM(e.languageData), r = CH(e), i, s = new class extends DS {
      createParse(o, l, a) {
        return new AH(i, o, l, a);
      }
    }();
    super(t, s, [], e.name), this.topNode = IH(t, this), i = this, this.streamParser = r, this.stateAfter = new st({ perNode: !0 }), this.tokenTable = e.tokenTable ? new DM(r.tokenTable) : EH;
  }
  /**
  Define a stream language.
  */
  static define(e) {
    return new S3(e);
  }
  /**
  @internal
  */
  getIndent(e) {
    let t, { overrideIndentation: r } = e.options;
    r && (t = Ew.get(e.state), t != null && t < e.pos - 1e4 && (t = void 0));
    let i = C3(this, e.node.tree, e.node.from, e.node.from, t ?? e.pos), s, o;
    if (i ? (o = i.state, s = i.pos + 1) : (o = this.streamParser.startState(e.unit), s = e.node.from), e.pos - s > 1e4)
      return null;
    for (; s < e.pos; ) {
      let a = e.state.doc.lineAt(s), c = Math.min(e.pos, a.to);
      if (a.length) {
        let u = r ? r(a.from) : -1, h = new AM(a.text, e.state.tabSize, e.unit, u < 0 ? void 0 : u);
        for (; h.pos < c - a.from; )
          EM(this.streamParser.token, h, o);
      } else
        this.streamParser.blankLine(o, e.unit);
      if (c == e.pos)
        break;
      s = a.to + 1;
    }
    let l = e.lineAt(e.pos);
    return r && t == null && Ew.set(e.state, l.from), this.streamParser.indent(o, /^\s*(.*)/.exec(l.text)[1], e);
  }
  get allowsNesting() {
    return !1;
  }
}
function C3(n, e, t, r, i) {
  let s = t >= r && t + e.length <= i && e.prop(n.stateAfter);
  if (s)
    return { state: n.streamParser.copyState(s), pos: t + e.length };
  for (let o = e.children.length - 1; o >= 0; o--) {
    let l = e.children[o], a = t + e.positions[o], c = l instanceof Bt && a < i && C3(n, l, a, r, i);
    if (c)
      return c;
  }
  return null;
}
function OM(n, e, t, r, i) {
  if (i && t <= 0 && r >= e.length)
    return e;
  !i && t == 0 && e.type == n.topNode && (i = !0);
  for (let s = e.children.length - 1; s >= 0; s--) {
    let o = e.positions[s], l = e.children[s], a;
    if (o < r && l instanceof Bt) {
      if (!(a = OM(n, l, t - o, r - o, i)))
        break;
      return i ? new Bt(e.type, e.children.slice(0, s).concat(a), e.positions.slice(0, s + 1), o + a.length) : a;
    }
  }
  return null;
}
function TH(n, e, t, r, i) {
  for (let s of e) {
    let o = s.from + (s.openStart ? 25 : 0), l = s.to - (s.openEnd ? 25 : 0), a = o <= t && l > t && C3(n, s.tree, 0 - s.offset, t, l), c;
    if (a && a.pos <= r && (c = OM(n, s.tree, t + s.offset, a.pos + s.offset, !1)))
      return { state: a.state, tree: c };
  }
  return { state: n.streamParser.startState(i ? wa(i) : 4), tree: Bt.empty };
}
class AH {
  constructor(e, t, r, i) {
    this.lang = e, this.input = t, this.fragments = r, this.ranges = i, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = i[i.length - 1].to;
    let s = fy.get(), o = i[0].from, { state: l, tree: a } = TH(e, r, o, this.to, s?.state);
    this.state = l, this.parsedPos = this.chunkStart = o + a.length;
    for (let c = 0; c < a.children.length; c++)
      this.chunks.push(a.children[c]), this.chunkPos.push(a.positions[c]);
    s && this.parsedPos < s.viewport.from - 1e5 && i.some((c) => c.from <= s.viewport.from && c.to >= s.viewport.from) && (this.state = this.lang.streamParser.startState(wa(s.state)), s.skipUntilInView(this.parsedPos, s.viewport.from), this.parsedPos = s.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let e = fy.get(), t = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), r = Math.min(
      t,
      this.chunkStart + 512
      /* C.ChunkSize */
    );
    for (e && (r = Math.min(r, e.viewport.to)); this.parsedPos < r; )
      this.parseLine(e);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= t ? this.finish() : e && this.parsedPos >= e.viewport.to ? (e.skipUntilInView(this.parsedPos, t), this.finish()) : null;
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let t = this.input.chunk(e);
    if (this.input.lineChunks)
      t == `
` && (t = "");
    else {
      let r = t.indexOf(`
`);
      r > -1 && (t = t.slice(0, r));
    }
    return e + t.length <= this.to ? t : t.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos, t = this.lineAfter(e), r = e + t.length;
    for (let i = this.rangeIndex; ; ) {
      let s = this.ranges[i].to;
      if (s >= r || (t = t.slice(0, s - (r - t.length)), i++, i == this.ranges.length))
        break;
      let o = this.ranges[i].from, l = this.lineAfter(o);
      t += l, r = o + l.length;
    }
    return { line: t, end: r };
  }
  skipGapsTo(e, t, r) {
    for (; ; ) {
      let i = this.ranges[this.rangeIndex].to, s = e + t;
      if (r > 0 ? i > s : i >= s)
        break;
      let o = this.ranges[++this.rangeIndex].from;
      t += o - i;
    }
    return t;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(e, t, r, i) {
    let s = 4;
    if (this.ranges.length > 1) {
      i = this.skipGapsTo(t, i, 1), t += i;
      let l = this.chunk.length;
      i = this.skipGapsTo(r, i, -1), r += i, s += this.chunk.length - l;
    }
    let o = this.chunk.length - 4;
    return this.lang.streamParser.mergeTokens && s == 4 && o >= 0 && this.chunk[o] == e && this.chunk[o + 2] == t ? this.chunk[o + 2] = r : this.chunk.push(e, t, r, s), i;
  }
  parseLine(e) {
    let { line: t, end: r } = this.nextLine(), i = 0, { streamParser: s } = this.lang, o = new AM(t, e ? e.state.tabSize : 4, e ? wa(e.state) : 2);
    if (o.eol())
      s.blankLine(this.state, o.indentUnit);
    else
      for (; !o.eol(); ) {
        let l = EM(s.token, o, this.state);
        if (l && (i = this.emitToken(this.lang.tokenTable.resolve(l), this.parsedPos + o.start, this.parsedPos + o.pos, i)), o.start > 1e4)
          break;
      }
    this.parsedPos = r, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = Bt.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: OH,
      topID: 0,
      maxBufferLength: 512,
      reused: this.chunkReused
    });
    e = new Bt(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(e), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new Bt(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}
function EM(n, e, t) {
  e.start = e.pos;
  for (let r = 0; r < 10; r++) {
    let i = n(e, t);
    if (e.pos > e.start)
      return i;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const M3 = /* @__PURE__ */ Object.create(null), Df = [Qr.none], OH = /* @__PURE__ */ new n3(Df), Iw = [], Dw = /* @__PURE__ */ Object.create(null), IM = /* @__PURE__ */ Object.create(null);
for (let [n, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  IM[n] = /* @__PURE__ */ NM(M3, e);
class DM {
  constructor(e) {
    this.extra = e, this.table = Object.assign(/* @__PURE__ */ Object.create(null), IM);
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = NM(this.extra, e)) : 0;
  }
}
const EH = /* @__PURE__ */ new DM(M3);
function Wg(n, e) {
  Iw.indexOf(n) > -1 || (Iw.push(n), console.warn(e));
}
function NM(n, e) {
  let t = [];
  for (let l of e.split(" ")) {
    let a = [];
    for (let c of l.split(".")) {
      let u = n[c] || U[c];
      u ? typeof u == "function" ? a.length ? a = a.map(u) : Wg(c, `Modifier ${c} used at start of tag`) : a.length ? Wg(c, `Tag ${c} used as modifier`) : a = Array.isArray(u) ? u : [u] : Wg(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of a)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + t.map((l) => l.id), s = Dw[i];
  if (s)
    return s.id;
  let o = Dw[i] = Qr.define({
    id: Df.length,
    name: r,
    props: [NF({ [r]: t })]
  });
  return Df.push(o), o.id;
}
function IH(n, e) {
  let t = Qr.define({ id: Df.length, name: "Document", props: [
    Xl.add(() => n),
    fM.add(() => (r) => e.getIndent(r))
  ], top: !0 });
  return Df.push(t), t;
}
qt.RTL, qt.LTR;
function Z(n) {
  return new HF(S3.define(n));
}
function Oo(n) {
  return import("./index-n5yCJgo5.js").then((e) => e.sql({ dialect: e[n] }));
}
const DH = [
  // New-style language modes
  /* @__PURE__ */ q.of({
    name: "C",
    extensions: ["c", "h", "ino"],
    load() {
      return import("./index-D4p5Gz6x.js").then((n) => n.cpp());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "C++",
    alias: ["cpp"],
    extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
    load() {
      return import("./index-D4p5Gz6x.js").then((n) => n.cpp());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CQL",
    alias: ["cassandra"],
    extensions: ["cql"],
    load() {
      return Oo("Cassandra");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CSS",
    extensions: ["css"],
    load() {
      return import("./index-CpxyQDPH.js").then((n) => n.css());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Go",
    extensions: ["go"],
    load() {
      return import("./index-DgN-JUY8.js").then((n) => n.go());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "HTML",
    alias: ["xhtml"],
    extensions: ["html", "htm", "handlebars", "hbs"],
    load() {
      return import("./index-O1vNNJCI.js").then((n) => n.html());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Java",
    extensions: ["java"],
    load() {
      return import("./index-DoM7vw4n.js").then((n) => n.java());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JavaScript",
    alias: ["ecmascript", "js", "node"],
    extensions: ["js", "mjs", "cjs"],
    load() {
      return import("./index-BDkY6Rzi.js").then((n) => n.javascript());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JSON",
    alias: ["json5"],
    extensions: ["json", "map"],
    load() {
      return import("./index-Bpg3PtKH.js").then((n) => n.json());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JSX",
    extensions: ["jsx"],
    load() {
      return import("./index-BDkY6Rzi.js").then((n) => n.javascript({ jsx: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "LESS",
    extensions: ["less"],
    load() {
      return import("./index-BscP3z_B.js").then((n) => n.less());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Liquid",
    extensions: ["liquid"],
    load() {
      return import("./index-9-FHfn6X.js").then((n) => n.liquid());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MariaDB SQL",
    load() {
      return Oo("MariaSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Markdown",
    extensions: ["md", "markdown", "mkd"],
    load() {
      return import("./index-DACyOtXp.js").then((n) => n.markdown());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MS SQL",
    load() {
      return Oo("MSSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MySQL",
    load() {
      return Oo("MySQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PHP",
    extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
    load() {
      return import("./index-BT6vzFf3.js").then((n) => n.php());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PLSQL",
    extensions: ["pls"],
    load() {
      return Oo("PLSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PostgreSQL",
    load() {
      return Oo("PostgreSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Python",
    extensions: ["BUILD", "bzl", "py", "pyw"],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return import("./index-BSd7AA_N.js").then((n) => n.python());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Rust",
    extensions: ["rs"],
    load() {
      return import("./index-p_ETS20u.js").then((n) => n.rust());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Sass",
    extensions: ["sass"],
    load() {
      return import("./index-CJAnhX0U.js").then((n) => n.sass({ indented: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SCSS",
    extensions: ["scss"],
    load() {
      return import("./index-CJAnhX0U.js").then((n) => n.sass());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SQL",
    extensions: ["sql"],
    load() {
      return Oo("StandardSQL");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SQLite",
    load() {
      return Oo("SQLite");
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TSX",
    extensions: ["tsx"],
    load() {
      return import("./index-BDkY6Rzi.js").then((n) => n.javascript({ jsx: !0, typescript: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TypeScript",
    alias: ["ts"],
    extensions: ["ts", "mts", "cts"],
    load() {
      return import("./index-BDkY6Rzi.js").then((n) => n.javascript({ typescript: !0 }));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "WebAssembly",
    extensions: ["wat", "wast"],
    load() {
      return import("./index-lLPMjgdv.js").then((n) => n.wast());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "XML",
    alias: ["rss", "wsdl", "xsd"],
    extensions: ["xml", "xsl", "xsd", "svg"],
    load() {
      return import("./index-BUoEZxIk.js").then((n) => n.xml());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "YAML",
    alias: ["yml"],
    extensions: ["yaml", "yml"],
    load() {
      return import("./index-u9Rd7WtH.js").then((n) => n.yaml());
    }
  }),
  // Legacy modes ported from CodeMirror 5
  /* @__PURE__ */ q.of({
    name: "APL",
    extensions: ["dyalog", "apl"],
    load() {
      return import("./apl-B2DGVGxc.js").then((n) => Z(n.apl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PGP",
    alias: ["asciiarmor"],
    extensions: ["asc", "pgp", "sig"],
    load() {
      return import("./asciiarmor-2LVJmxlE.js").then((n) => Z(n.asciiArmor));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ASN.1",
    extensions: ["asn", "asn1"],
    load() {
      return import("./asn1-jKiBa2Ya.js").then((n) => Z(n.asn1({})));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Asterisk",
    filename: /^extensions\.conf$/i,
    load() {
      return import("./asterisk-DS281yxp.js").then((n) => Z(n.asterisk));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Brainfuck",
    extensions: ["b", "bf"],
    load() {
      return import("./brainfuck-C_p9pTT8.js").then((n) => Z(n.brainfuck));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Cobol",
    extensions: ["cob", "cpy"],
    load() {
      return import("./cobol-BlTKFDRj.js").then((n) => Z(n.cobol));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "C#",
    alias: ["csharp", "cs"],
    extensions: ["cs"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.csharp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Clojure",
    extensions: ["clj", "cljc", "cljx"],
    load() {
      return import("./clojure-CCKyeQKf.js").then((n) => Z(n.clojure));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ClojureScript",
    extensions: ["cljs"],
    load() {
      return import("./clojure-CCKyeQKf.js").then((n) => Z(n.clojure));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Closure Stylesheets (GSS)",
    extensions: ["gss"],
    load() {
      return import("./css-BkF-NPzE.js").then((n) => Z(n.gss));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CMake",
    extensions: ["cmake", "cmake.in"],
    filename: /^CMakeLists\.txt$/,
    load() {
      return import("./cmake-CuaCgAKt.js").then((n) => Z(n.cmake));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "CoffeeScript",
    alias: ["coffee", "coffee-script"],
    extensions: ["coffee"],
    load() {
      return import("./coffeescript-BVCvwO8I.js").then((n) => Z(n.coffeeScript));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Common Lisp",
    alias: ["lisp"],
    extensions: ["cl", "lisp", "el"],
    load() {
      return import("./commonlisp-D_kxz07b.js").then((n) => Z(n.commonLisp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Cypher",
    extensions: ["cyp", "cypher"],
    load() {
      return import("./cypher-BMq4Fwjl.js").then((n) => Z(n.cypher));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Cython",
    extensions: ["pyx", "pxd", "pxi"],
    load() {
      return import("./python-BkR3uSy8.js").then((n) => Z(n.cython));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Crystal",
    extensions: ["cr"],
    load() {
      return import("./crystal-D309uH6_.js").then((n) => Z(n.crystal));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "D",
    extensions: ["d"],
    load() {
      return import("./d-BZcgY6La.js").then((n) => Z(n.d));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Dart",
    extensions: ["dart"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.dart));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "diff",
    extensions: ["diff", "patch"],
    load() {
      return import("./diff-Cg9d_RX2.js").then((n) => Z(n.diff));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Dockerfile",
    filename: /^Dockerfile$/,
    load() {
      return import("./dockerfile-DIy8NleC.js").then((n) => Z(n.dockerFile));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "DTD",
    extensions: ["dtd"],
    load() {
      return import("./dtd-CtLokQ-U.js").then((n) => Z(n.dtd));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Dylan",
    extensions: ["dylan", "dyl", "intr"],
    load() {
      return import("./dylan-QYeExnWK.js").then((n) => Z(n.dylan));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "EBNF",
    load() {
      return import("./ebnf-DUPDuY4r.js").then((n) => Z(n.ebnf));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ECL",
    extensions: ["ecl"],
    load() {
      return import("./ecl-CiXN-g_D.js").then((n) => Z(n.ecl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "edn",
    extensions: ["edn"],
    load() {
      return import("./clojure-CCKyeQKf.js").then((n) => Z(n.clojure));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Eiffel",
    extensions: ["e"],
    load() {
      return import("./eiffel-yQhjl4T1.js").then((n) => Z(n.eiffel));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Elm",
    extensions: ["elm"],
    load() {
      return import("./elm-CNT9vbN0.js").then((n) => Z(n.elm));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Erlang",
    extensions: ["erl"],
    load() {
      return import("./erlang-CFOYdy9e.js").then((n) => Z(n.erlang));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Esper",
    load() {
      return import("./sql-CfG5lQ3l.js").then((n) => Z(n.esper));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Factor",
    extensions: ["factor"],
    load() {
      return import("./factor-DDOC7X6P.js").then((n) => Z(n.factor));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "FCL",
    load() {
      return import("./fcl-CPC2WYrI.js").then((n) => Z(n.fcl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Forth",
    extensions: ["forth", "fth", "4th"],
    load() {
      return import("./forth-BmxRyE9S.js").then((n) => Z(n.forth));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Fortran",
    extensions: ["f", "for", "f77", "f90", "f95"],
    load() {
      return import("./fortran-9bvPyrOW.js").then((n) => Z(n.fortran));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "F#",
    alias: ["fsharp"],
    extensions: ["fs"],
    load() {
      return import("./mllike-BSnXJBGA.js").then((n) => Z(n.fSharp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Gas",
    extensions: ["s"],
    load() {
      return import("./gas-cpmYfFX2.js").then((n) => Z(n.gas));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Gherkin",
    extensions: ["feature"],
    load() {
      return import("./gherkin-CJuwpceU.js").then((n) => Z(n.gherkin));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Groovy",
    extensions: ["groovy", "gradle"],
    filename: /^Jenkinsfile$/,
    load() {
      return import("./groovy-DZeT_VM-.js").then((n) => Z(n.groovy));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Haskell",
    extensions: ["hs"],
    load() {
      return import("./haskell-CxiO_7JL.js").then((n) => Z(n.haskell));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Haxe",
    extensions: ["hx"],
    load() {
      return import("./haxe-70NVW1pR.js").then((n) => Z(n.haxe));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "HXML",
    extensions: ["hxml"],
    load() {
      return import("./haxe-70NVW1pR.js").then((n) => Z(n.hxml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "HTTP",
    load() {
      return import("./http-D9LttvKF.js").then((n) => Z(n.http));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "IDL",
    extensions: ["pro"],
    load() {
      return import("./idl-B6TRFYjl.js").then((n) => Z(n.idl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "JSON-LD",
    alias: ["jsonld"],
    extensions: ["jsonld"],
    load() {
      return import("./javascript-DOuB9oqA.js").then((n) => Z(n.jsonld));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Jinja2",
    extensions: ["j2", "jinja", "jinja2"],
    load() {
      return import("./jinja2-DnB6dQmV.js").then((n) => Z(n.jinja2));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Julia",
    extensions: ["jl"],
    load() {
      return import("./julia-DpvXAuO6.js").then((n) => Z(n.julia));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Kotlin",
    extensions: ["kt", "kts"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.kotlin));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "LiveScript",
    alias: ["ls"],
    extensions: ["ls"],
    load() {
      return import("./livescript-CanGTf8u.js").then((n) => Z(n.liveScript));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Lua",
    extensions: ["lua"],
    load() {
      return import("./lua-XplVlWi_.js").then((n) => Z(n.lua));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "mIRC",
    extensions: ["mrc"],
    load() {
      return import("./mirc-CFBPAOaF.js").then((n) => Z(n.mirc));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Mathematica",
    extensions: ["m", "nb", "wl", "wls"],
    load() {
      return import("./mathematica-jaRHnSxC.js").then((n) => Z(n.mathematica));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Modelica",
    extensions: ["mo"],
    load() {
      return import("./modelica-vUgVs--1.js").then((n) => Z(n.modelica));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MUMPS",
    extensions: ["mps"],
    load() {
      return import("./mumps-CQoS1kWX.js").then((n) => Z(n.mumps));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Mbox",
    extensions: ["mbox"],
    load() {
      return import("./mbox-BctzC1hL.js").then((n) => Z(n.mbox));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Nginx",
    filename: /nginx.*\.conf$/i,
    load() {
      return import("./nginx-zDPm3Z74.js").then((n) => Z(n.nginx));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "NSIS",
    extensions: ["nsh", "nsi"],
    load() {
      return import("./nsis-fePjrhq7.js").then((n) => Z(n.nsis));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "NTriples",
    extensions: ["nt", "nq"],
    load() {
      return import("./ntriples-CsNjv2QF.js").then((n) => Z(n.ntriples));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Objective-C",
    alias: ["objective-c", "objc"],
    extensions: ["m"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.objectiveC));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Objective-C++",
    alias: ["objective-c++", "objc++"],
    extensions: ["mm"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.objectiveCpp));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "OCaml",
    extensions: ["ml", "mli", "mll", "mly"],
    load() {
      return import("./mllike-BSnXJBGA.js").then((n) => Z(n.oCaml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Octave",
    extensions: ["m"],
    load() {
      return import("./octave-C8PmmSRH.js").then((n) => Z(n.octave));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Oz",
    extensions: ["oz"],
    load() {
      return import("./oz-Ce8aN8oE.js").then((n) => Z(n.oz));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Pascal",
    extensions: ["p", "pas"],
    load() {
      return import("./pascal-De0D6mP7.js").then((n) => Z(n.pascal));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Perl",
    extensions: ["pl", "pm"],
    load() {
      return import("./perl-B4bSCe1C.js").then((n) => Z(n.perl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Pig",
    extensions: ["pig"],
    load() {
      return import("./pig-D24Z8EXi.js").then((n) => Z(n.pig));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "PowerShell",
    extensions: ["ps1", "psd1", "psm1"],
    load() {
      return import("./powershell-DkYVfTzP.js").then((n) => Z(n.powerShell));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Properties files",
    alias: ["ini", "properties"],
    extensions: ["properties", "ini", "in"],
    load() {
      return import("./properties-Dn9wna3M.js").then((n) => Z(n.properties));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "ProtoBuf",
    extensions: ["proto"],
    load() {
      return import("./protobuf-BPIjwpzm.js").then((n) => Z(n.protobuf));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Pug",
    alias: ["jade"],
    extensions: ["pug", "jade"],
    load() {
      return import("./pug-TGXr6c5j.js").then((n) => Z(n.pug));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Puppet",
    extensions: ["pp"],
    load() {
      return import("./puppet-nyd4dhjf.js").then((n) => Z(n.puppet));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Q",
    extensions: ["q"],
    load() {
      return import("./q-DXjKs-tC.js").then((n) => Z(n.q));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "R",
    alias: ["rscript"],
    extensions: ["r", "R"],
    load() {
      return import("./r-LKEuhEGI.js").then((n) => Z(n.r));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "RPM Changes",
    load() {
      return import("./rpm-IznJm2Xc.js").then((n) => Z(n.rpmChanges));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "RPM Spec",
    extensions: ["spec"],
    load() {
      return import("./rpm-IznJm2Xc.js").then((n) => Z(n.rpmSpec));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Ruby",
    alias: ["jruby", "macruby", "rake", "rb", "rbx"],
    extensions: ["rb"],
    filename: /^(Gemfile|Rakefile)$/,
    load() {
      return import("./ruby-CcYfvIk6.js").then((n) => Z(n.ruby));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SAS",
    extensions: ["sas"],
    load() {
      return import("./sas-7E8yHoCW.js").then((n) => Z(n.sas));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Scala",
    extensions: ["scala"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.scala));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Scheme",
    extensions: ["scm", "ss"],
    load() {
      return import("./scheme-DjibxsNh.js").then((n) => Z(n.scheme));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Shell",
    alias: ["bash", "sh", "zsh"],
    extensions: ["sh", "ksh", "bash"],
    filename: /^PKGBUILD$/,
    load() {
      return import("./shell-C0C2sNA_.js").then((n) => Z(n.shell));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Sieve",
    extensions: ["siv", "sieve"],
    load() {
      return import("./sieve-Bwz7vjP5.js").then((n) => Z(n.sieve));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Smalltalk",
    extensions: ["st"],
    load() {
      return import("./smalltalk-Bhddl2pB.js").then((n) => Z(n.smalltalk));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Solr",
    load() {
      return import("./solr-BNlsLglM.js").then((n) => Z(n.solr));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SML",
    extensions: ["sml", "sig", "fun", "smackspec"],
    load() {
      return import("./mllike-BSnXJBGA.js").then((n) => Z(n.sml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SPARQL",
    alias: ["sparul"],
    extensions: ["rq", "sparql"],
    load() {
      return import("./sparql-FarWu_Gb.js").then((n) => Z(n.sparql));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Spreadsheet",
    alias: ["excel", "formula"],
    load() {
      return import("./spreadsheet-C-cy4P5N.js").then((n) => Z(n.spreadsheet));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Squirrel",
    extensions: ["nut"],
    load() {
      return import("./clike-DGTaUp48.js").then((n) => Z(n.squirrel));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Stylus",
    extensions: ["styl"],
    load() {
      return import("./stylus-CAdqWld3.js").then((n) => Z(n.stylus));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Swift",
    extensions: ["swift"],
    load() {
      return import("./swift-DSxqR9R6.js").then((n) => Z(n.swift));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "sTeX",
    load() {
      return import("./stex-Du4h4KAU.js").then((n) => Z(n.stex));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "LaTeX",
    alias: ["tex"],
    extensions: ["text", "ltx", "tex"],
    load() {
      return import("./stex-Du4h4KAU.js").then((n) => Z(n.stex));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "SystemVerilog",
    extensions: ["v", "sv", "svh"],
    load() {
      return import("./verilog-CiS1jyi5.js").then((n) => Z(n.verilog));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Tcl",
    extensions: ["tcl"],
    load() {
      return import("./tcl-xfoLljhY.js").then((n) => Z(n.tcl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Textile",
    extensions: ["textile"],
    load() {
      return import("./textile-D1AWE-pc.js").then((n) => Z(n.textile));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TiddlyWiki",
    load() {
      return import("./tiddlywiki-5wqsXtSk.js").then((n) => Z(n.tiddlyWiki));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Tiki wiki",
    load() {
      return import("./tiki-__Kn3CeS.js").then((n) => Z(n.tiki));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TOML",
    extensions: ["toml"],
    load() {
      return import("./toml-BHiuTcfn.js").then((n) => Z(n.toml));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Troff",
    extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    load() {
      return import("./troff-D2UO-fKf.js").then((n) => Z(n.troff));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TTCN",
    extensions: ["ttcn", "ttcn3", "ttcnpp"],
    load() {
      return import("./ttcn-Bsa4sfRm.js").then((n) => Z(n.ttcn));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "TTCN_CFG",
    extensions: ["cfg"],
    load() {
      return import("./ttcn-cfg-Bac_acMi.js").then((n) => Z(n.ttcnCfg));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Turtle",
    extensions: ["ttl"],
    load() {
      return import("./turtle-xwJUxoPV.js").then((n) => Z(n.turtle));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Web IDL",
    extensions: ["webidl"],
    load() {
      return import("./webidl-CjfDENEo.js").then((n) => Z(n.webIDL));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "VB.NET",
    extensions: ["vb"],
    load() {
      return import("./vb-c2kQGd6-.js").then((n) => Z(n.vb));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "VBScript",
    extensions: ["vbs"],
    load() {
      return import("./vbscript-1f_Dhg5H.js").then((n) => Z(n.vbScript));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Velocity",
    extensions: ["vtl"],
    load() {
      return import("./velocity-DJd0pTTC.js").then((n) => Z(n.velocity));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Verilog",
    extensions: ["v"],
    load() {
      return import("./verilog-CiS1jyi5.js").then((n) => Z(n.verilog));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "VHDL",
    extensions: ["vhd", "vhdl"],
    load() {
      return import("./vhdl-T9HkrbI2.js").then((n) => Z(n.vhdl));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "XQuery",
    extensions: ["xy", "xquery"],
    load() {
      return import("./xquery-Ct6lEb4B.js").then((n) => Z(n.xQuery));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Yacas",
    extensions: ["ys"],
    load() {
      return import("./yacas-C0absKBh.js").then((n) => Z(n.yacas));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Z80",
    extensions: ["z80"],
    load() {
      return import("./z80-Pki2zAjW.js").then((n) => Z(n.z80));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MscGen",
    extensions: ["mscgen", "mscin", "msc"],
    load() {
      return import("./mscgen-Cpl0NYLN.js").then((n) => Z(n.mscgen));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Xù",
    extensions: ["xu"],
    load() {
      return import("./mscgen-Cpl0NYLN.js").then((n) => Z(n.xu));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "MsGenny",
    extensions: ["msgenny"],
    load() {
      return import("./mscgen-Cpl0NYLN.js").then((n) => Z(n.msgenny));
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Vue",
    extensions: ["vue"],
    load() {
      return import("./index-CPMUx1av.js").then((n) => n.vue());
    }
  }),
  /* @__PURE__ */ q.of({
    name: "Angular Template",
    load() {
      return import("./index-DXbWmv7R.js").then((n) => n.angular());
    }
  })
], NH = "#e5c07b", Nw = "#e06c75", RH = "#56b6c2", PH = "#ffffff", tp = "#abb2bf", yy = "#7d8799", _H = "#61afef", LH = "#98c379", Rw = "#d19a66", BH = "#c678dd", zH = "#21252b", Pw = "#2c313a", _w = "#282c34", jg = "#353a42", FH = "#3E4451", Lw = "#528bff", HH = /* @__PURE__ */ Ce.theme({
  "&": {
    color: tp,
    backgroundColor: _w
  },
  ".cm-content": {
    caretColor: Lw
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: Lw },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: FH },
  ".cm-panels": { backgroundColor: zH, color: tp },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: _w,
    color: yy,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: Pw
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: jg
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: jg,
    borderBottomColor: jg
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: Pw,
      color: tp
    }
  }
}, { dark: !0 }), $H = /* @__PURE__ */ ud.define([
  {
    tag: U.keyword,
    color: BH
  },
  {
    tag: [U.name, U.deleted, U.character, U.propertyName, U.macroName],
    color: Nw
  },
  {
    tag: [/* @__PURE__ */ U.function(U.variableName), U.labelName],
    color: _H
  },
  {
    tag: [U.color, /* @__PURE__ */ U.constant(U.name), /* @__PURE__ */ U.standard(U.name)],
    color: Rw
  },
  {
    tag: [/* @__PURE__ */ U.definition(U.name), U.separator],
    color: tp
  },
  {
    tag: [U.typeName, U.className, U.number, U.changed, U.annotation, U.modifier, U.self, U.namespace],
    color: NH
  },
  {
    tag: [U.operator, U.operatorKeyword, U.url, U.escape, U.regexp, U.link, /* @__PURE__ */ U.special(U.string)],
    color: RH
  },
  {
    tag: [U.meta, U.comment],
    color: yy
  },
  {
    tag: U.strong,
    fontWeight: "bold"
  },
  {
    tag: U.emphasis,
    fontStyle: "italic"
  },
  {
    tag: U.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: U.link,
    color: yy,
    textDecoration: "underline"
  },
  {
    tag: U.heading,
    fontWeight: "bold",
    color: Nw
  },
  {
    tag: [U.atom, U.bool, /* @__PURE__ */ U.special(U.variableName)],
    color: Rw
  },
  {
    tag: [U.processingInstruction, U.string, U.inserted],
    color: LH
  },
  {
    tag: U.invalid,
    color: PH
  }
]), VH = [HH, /* @__PURE__ */ SM($H)];
function Nn(n) {
  this.content = n;
}
Nn.prototype = {
  constructor: Nn,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(n, e, t) {
    var r = t && t != n ? this.remove(t) : this, i = r.find(n), s = r.content.slice();
    return i == -1 ? s.push(t || n, e) : (s[i + 1] = e, t && (s[i] = t)), new Nn(s);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(n) {
    var e = this.find(n);
    if (e == -1) return this;
    var t = this.content.slice();
    return t.splice(e, 2), new Nn(t);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(n, e) {
    return new Nn([n, e].concat(this.remove(n).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new Nn(t);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(n, e, t) {
    var r = this.remove(e), i = r.content.slice(), s = r.find(n);
    return i.splice(s == -1 ? i.length : s, 0, e, t), new Nn(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(n) {
    return n = Nn.from(n), n.size ? new Nn(n.content.concat(this.subtract(n).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(n) {
    return n = Nn.from(n), n.size ? new Nn(this.subtract(n).content.concat(n.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(n) {
    var e = this;
    n = Nn.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Nn.from = function(n) {
  if (n instanceof Nn) return n;
  var e = [];
  if (n) for (var t in n) e.push(t, n[t]);
  return new Nn(e);
};
function RM(n, e, t) {
  for (let r = 0; ; r++) {
    if (r == n.childCount || r == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let i = n.child(r), s = e.child(r);
    if (i == s) {
      t += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return t;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        t++;
      return t;
    }
    if (i.content.size || s.content.size) {
      let o = RM(i.content, s.content, t + 1);
      if (o != null)
        return o;
    }
    t += i.nodeSize;
  }
}
function PM(n, e, t, r) {
  for (let i = n.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: t, b: r };
    let o = n.child(--i), l = e.child(--s), a = o.nodeSize;
    if (o == l) {
      t -= a, r -= a;
      continue;
    }
    if (!o.sameMarkup(l))
      return { a: t, b: r };
    if (o.isText && o.text != l.text) {
      let c = 0, u = Math.min(o.text.length, l.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == l.text[l.text.length - c - 1]; )
        c++, t--, r--;
      return { a: t, b: r };
    }
    if (o.content.size || l.content.size) {
      let c = PM(o.content, l.content, t - 1, r - 1);
      if (c)
        return c;
    }
    t -= a, r -= a;
  }
}
let ce = class rr {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, r, i = 0, s) {
    for (let o = 0, l = 0; l < t; o++) {
      let a = this.content[o], c = l + a.nodeSize;
      if (c > e && r(a, i + l, s || null, o) !== !1 && a.content.size) {
        let u = l + 1;
        a.nodesBetween(Math.max(0, e - u), Math.min(a.content.size, t - u), r, i + u);
      }
      l = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, t, (l, a) => {
      let c = l.isText ? l.text.slice(Math.max(e, a) - a, t - a) : l.isLeaf ? i ? typeof i == "function" ? i(l) : i : l.type.spec.leafText ? l.type.spec.leafText(l) : "" : "";
      l.isBlock && (l.isLeaf && c || l.isTextblock) && r && (o ? o = !1 : s += r), s += c;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new rr(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let r = [], i = 0;
    if (t > e)
      for (let s = 0, o = 0; o < t; s++) {
        let l = this.content[s], a = o + l.nodeSize;
        a > e && ((o < e || a > t) && (l.isText ? l = l.cut(Math.max(0, e - o), Math.min(l.text.length, t - o)) : l = l.cut(Math.max(0, e - o - 1), Math.min(l.content.size, t - o - 1))), r.push(l), i += l.nodeSize), o = a;
      }
    return new rr(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? rr.empty : e == 0 && t == this.content.length ? this : new rr(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let r = this.content[e];
    if (r == t)
      return this;
    let i = this.content.slice(), s = this.size + t.nodeSize - r.nodeSize;
    return i[e] = t, new rr(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new rr([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new rr(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, r = 0; t < this.content.length; t++) {
      let i = this.content[t];
      e(i, r, t), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return RM(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, r = e.size) {
    return PM(this, e, t, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return u0(0, e);
    if (e == this.size)
      return u0(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let t = 0, r = 0; ; t++) {
      let i = this.child(t), s = r + i.nodeSize;
      if (s >= e)
        return s == e ? u0(t + 1, s) : u0(t, r);
      r = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return rr.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new rr(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return rr.empty;
    let t, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (t || (t = e.slice(0, i)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
    }
    return new rr(t || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return rr.empty;
    if (e instanceof rr)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new rr([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
ce.empty = new ce([], 0);
const Ug = { index: 0, offset: 0 };
function u0(n, e) {
  return Ug.index = n, Ug.offset = e, Ug;
}
function cm(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let r = 0; r < n.length; r++)
      if (!cm(n[r], e[r]))
        return !1;
  } else {
    for (let r in n)
      if (!(r in e) || !cm(n[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in n))
        return !1;
  }
  return !0;
}
class nt {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        t || (t = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !r && s.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(s);
      }
    }
    return t || (t = e.slice()), r || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && cm(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[t.type];
    if (!r)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    let i = r.create(t.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(t[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return nt.none;
    if (e instanceof nt)
      return [e];
    let t = e.slice();
    return t.sort((r, i) => r.type.rank - i.type.rank), t;
  }
}
nt.none = [];
class um extends Error {
}
let ve = class Qa {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, r) {
    this.content = e, this.openStart = t, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let r = LM(this.content, e + this.openStart, t);
    return r && new Qa(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new Qa(_M(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return Qa.empty;
    let r = t.openStart || 0, i = t.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Qa(ce.fromJSON(e, t.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new Qa(e, r, i);
  }
};
ve.empty = new ve(ce.empty, 0, 0);
function _M(n, e, t) {
  let { index: r, offset: i } = n.findIndex(e), s = n.maybeChild(r), { index: o, offset: l } = n.findIndex(t);
  if (i == e || s.isText) {
    if (l != t && !n.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(r, s.copy(_M(s.content, e - i - 1, t - i - 1)));
}
function LM(n, e, t, r) {
  let { index: i, offset: s } = n.findIndex(e), o = n.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, t) ? null : n.cut(0, e).append(t).append(n.cut(e));
  let l = LM(o.content, e - s - 1, t, o);
  return l && n.replaceChild(i, o.copy(l));
}
function qH(n, e, t) {
  if (t.openStart > n.depth)
    throw new um("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new um("Inconsistent open depths");
  return BM(n, e, t, 0);
}
function BM(n, e, t, r) {
  let i = n.index(r), s = n.node(r);
  if (i == e.index(r) && r < n.depth - t.openStart) {
    let o = BM(n, e, t, r + 1);
    return s.copy(s.content.replaceChild(i, o));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) {
      let o = n.parent, l = o.content;
      return sa(o, l.cut(0, n.parentOffset).append(t.content).append(l.cut(e.parentOffset)));
    } else {
      let { start: o, end: l } = WH(t, n);
      return sa(s, FM(n, o, l, e, r));
    }
  else return sa(s, hm(n, e, r));
}
function zM(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new um("Cannot join " + e.type.name + " onto " + n.type.name);
}
function by(n, e, t) {
  let r = n.node(t);
  return zM(r, e.node(t)), r;
}
function ia(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function $h(n, e, t, r) {
  let i = (e || n).node(t), s = 0, o = e ? e.index(t) : i.childCount;
  n && (s = n.index(t), n.depth > t ? s++ : n.textOffset && (ia(n.nodeAfter, r), s++));
  for (let l = s; l < o; l++)
    ia(i.child(l), r);
  e && e.depth == t && e.textOffset && ia(e.nodeBefore, r);
}
function sa(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function FM(n, e, t, r, i) {
  let s = n.depth > i && by(n, e, i + 1), o = r.depth > i && by(t, r, i + 1), l = [];
  return $h(null, n, i, l), s && o && e.index(i) == t.index(i) ? (zM(s, o), ia(sa(s, FM(n, e, t, r, i + 1)), l)) : (s && ia(sa(s, hm(n, e, i + 1)), l), $h(e, t, i, l), o && ia(sa(o, hm(t, r, i + 1)), l)), $h(r, null, i, l), new ce(l);
}
function hm(n, e, t) {
  let r = [];
  if ($h(null, n, t, r), n.depth > t) {
    let i = by(n, e, t + 1);
    ia(sa(i, hm(n, e, t + 1)), r);
  }
  return $h(e, null, t, r), new ce(r);
}
function WH(n, e) {
  let t = e.depth - n.openStart, i = e.node(t).copy(n.content);
  for (let s = t - 1; s >= 0; s--)
    i = e.node(s).copy(ce.from(i));
  return {
    start: i.resolveNoCache(n.openStart + t),
    end: i.resolveNoCache(i.content.size - n.openEnd - t)
  };
}
class Nf {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(t);
    return r ? e.child(t).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += r.child(s).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return nt.none;
    if (this.textOffset)
      return e.child(t).marks;
    let r = e.maybeChild(t - 1), i = e.maybeChild(t);
    if (!r) {
      let l = r;
      r = i, i = l;
    }
    let s = r.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let r = t.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!t || t(this.node(r))))
        return new HM(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let r = [], i = 0, s = t;
    for (let o = e; ; ) {
      let { index: l, offset: a } = o.content.findIndex(s), c = s - a;
      if (r.push(o, l, i + a), !c || (o = o.child(l), o.isText))
        break;
      s = c - 1, i += a + 1;
    }
    return new Nf(t, r, s);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    let r = Bw.get(e);
    if (r)
      for (let s = 0; s < r.elts.length; s++) {
        let o = r.elts[s];
        if (o.pos == t)
          return o;
      }
    else
      Bw.set(e, r = new jH());
    let i = r.elts[r.i] = Nf.resolve(e, t);
    return r.i = (r.i + 1) % UH, i;
  }
}
class jH {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const UH = 12, Bw = /* @__PURE__ */ new WeakMap();
class HM {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const KH = /* @__PURE__ */ Object.create(null);
let ro = class vy {
  /**
  @internal
  */
  constructor(e, t, r, i = nt.none) {
    this.type = e, this.attrs = t, this.marks = i, this.content = r || ce.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, r, i = 0) {
    this.content.nodesBetween(e, t, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, t, r, i) {
    return this.content.textBetween(e, t, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, r) {
    return this.type == e && cm(this.attrs, t || e.defaultAttrs || KH) && nt.sameSet(this.marks, r || nt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new vy(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new vy(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, r = !1) {
    if (e == t)
      return ve.empty;
    let i = this.resolve(e), s = this.resolve(t), o = r ? 0 : i.sharedDepth(t), l = i.start(o), c = i.node(o).content.cut(i.pos - l, s.pos - l);
    return new ve(c, i.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, r) {
    return qH(this.resolve(e), this.resolve(t), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: r, offset: i } = t.content.findIndex(e);
      if (t = t.maybeChild(r), !t)
        return null;
      if (i == e || t.isText)
        return t;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(t), index: t, offset: r };
    let i = this.content.child(t - 1);
    return { node: i, index: t - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Nf.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Nf.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, r) {
    let i = !1;
    return t > e && this.nodesBetween(e, t, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), $M(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, r = ce.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s), l = o && o.matchFragment(this.content, t);
    if (!l || !l.validEnd)
      return !1;
    for (let a = i; a < s; a++)
      if (!this.type.allowsMarks(r.child(a).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, t);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = nt.none;
    for (let t = 0; t < this.marks.length; t++) {
      let r = this.marks[t];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!nt.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, r);
    }
    let i = ce.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, i, r);
    return s.type.checkAttrs(s.attrs), s;
  }
};
ro.prototype.text = void 0;
let GH = class wy extends ro {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    if (super(e, t, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : $M(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new wy(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new wy(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
};
function $M(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class ka {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let r = new YH(e, t);
    if (r.next == null)
      return ka.empty;
    let i = VM(r);
    r.next && r.err("Unexpected trailing text");
    let s = n$(t$(i));
    return r$(s, r), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, r = e.childCount) {
    let i = this;
    for (let s = t; i && s < r; s++)
      i = i.matchType(e.child(s).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[t].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, r = 0) {
    let i = [this];
    function s(o, l) {
      let a = o.matchFragment(e, r);
      if (a && (!t || a.validEnd))
        return ce.from(l.map((c) => c.createAndFill()));
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: h } = o.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h);
          let f = s(h, l.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), s = i.match;
      if (s.matchType(e)) {
        let o = [];
        for (let l = i; l.type; l = l.via)
          o.push(l.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: l, next: a } = s.next[o];
        !l.isLeaf && !l.hasRequiredAttrs() && !(l.name in t) && (!i.type || a.validEnd) && (r.push({ match: l.contentMatch, type: l, via: i }), t[l.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && t(r.next[i].next);
    }
    return t(this), e.map((r, i) => {
      let s = i + (r.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < r.next.length; o++)
        s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
      return s;
    }).join(`
`);
  }
}
ka.empty = new ka(!0);
class YH {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function VM(n) {
  let e = [];
  do
    e.push(JH(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function JH(n) {
  let e = [];
  do
    e.push(XH(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function XH(n) {
  let e = e$(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = ZH(n, e);
    else
      break;
  return e;
}
function zw(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function ZH(n, e) {
  let t = zw(n), r = t;
  return n.eat(",") && (n.next != "}" ? r = zw(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e };
}
function QH(n, e) {
  let t = n.nodeTypes, r = t[e];
  if (r)
    return [r];
  let i = [];
  for (let s in t) {
    let o = t[s];
    o.isInGroup(e) && i.push(o);
  }
  return i.length == 0 && n.err("No node type or group '" + e + "' found"), i;
}
function e$(n) {
  if (n.eat("(")) {
    let e = VM(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = QH(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function t$(n) {
  let e = [[]];
  return i(s(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function r(o, l, a) {
    let c = { term: a, to: l };
    return e[o].push(c), c;
  }
  function i(o, l) {
    o.forEach((a) => a.to = l);
  }
  function s(o, l) {
    if (o.type == "choice")
      return o.exprs.reduce((a, c) => a.concat(s(c, l)), []);
    if (o.type == "seq")
      for (let a = 0; ; a++) {
        let c = s(o.exprs[a], l);
        if (a == o.exprs.length - 1)
          return c;
        i(c, l = t());
      }
    else if (o.type == "star") {
      let a = t();
      return r(l, a), i(s(o.expr, a), a), [r(a)];
    } else if (o.type == "plus") {
      let a = t();
      return i(s(o.expr, l), a), i(s(o.expr, a), a), [r(a)];
    } else {
      if (o.type == "opt")
        return [r(l)].concat(s(o.expr, l));
      if (o.type == "range") {
        let a = l;
        for (let c = 0; c < o.min; c++) {
          let u = t();
          i(s(o.expr, a), u), a = u;
        }
        if (o.max == -1)
          i(s(o.expr, a), a);
        else
          for (let c = o.min; c < o.max; c++) {
            let u = t();
            r(a, u), i(s(o.expr, a), u), a = u;
          }
        return [r(a)];
      } else {
        if (o.type == "name")
          return [r(l, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function qM(n, e) {
  return e - n;
}
function Fw(n, e) {
  let t = [];
  return r(e), t.sort(qM);
  function r(i) {
    let s = n[i];
    if (s.length == 1 && !s[0].term)
      return r(s[0].to);
    t.push(i);
    for (let o = 0; o < s.length; o++) {
      let { term: l, to: a } = s[o];
      !l && t.indexOf(a) == -1 && r(a);
    }
  }
}
function n$(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(Fw(n, 0));
  function t(r) {
    let i = [];
    r.forEach((o) => {
      n[o].forEach(({ term: l, to: a }) => {
        if (!l)
          return;
        let c;
        for (let u = 0; u < i.length; u++)
          i[u][0] == l && (c = i[u][1]);
        Fw(n, a).forEach((u) => {
          c || i.push([l, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let s = e[r.join(",")] = new ka(r.indexOf(n.length - 1) > -1);
    for (let o = 0; o < i.length; o++) {
      let l = i[o][1].sort(qM);
      s.next.push({ type: i[o][0], next: e[l.join(",")] || t(l) });
    }
    return s;
  }
}
function r$(n, e) {
  for (let t = 0, r = [n]; t < r.length; t++) {
    let i = r[t], s = !i.validEnd, o = [];
    for (let l = 0; l < i.next.length; l++) {
      let { type: a, next: c } = i.next[l];
      o.push(a.name), s && !(a.isText || a.hasRequiredAttrs()) && (s = !1), r.indexOf(c) == -1 && r.push(c);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function WM(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    if (!r.hasDefault)
      return null;
    e[t] = r.default;
  }
  return e;
}
function jM(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in n) {
    let i = e && e[r];
    if (i === void 0) {
      let s = n[r];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    t[r] = i;
  }
  return t;
}
function UM(n, e, t, r) {
  for (let i in e)
    if (!(i in n))
      throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`);
  for (let i in n) {
    let s = n[i];
    s.validate && s.validate(e[i]);
  }
}
function KM(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      t[r] = new s$(n, r, e[r]);
  return t;
}
let fm = class GM {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = KM(e, r.attrs), this.defaultAttrs = WM(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ka.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : jM(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new ro(this, this.computeAttrs(e), ce.from(t), nt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, r) {
    return t = ce.from(t), this.checkContent(t), new ro(this, this.computeAttrs(e), t, nt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, r) {
    if (e = this.computeAttrs(e), t = ce.from(t), t.size) {
      let o = this.contentMatch.fillBefore(t);
      if (!o)
        return null;
      t = o.append(t);
    }
    let i = this.contentMatch.matchFragment(t), s = i && i.fillBefore(ce.empty, !0);
    return s ? new ro(this, e, t.append(s), nt.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    UM(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
    return t ? t.length ? t : nt.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => r[s] = new GM(s, t, o));
    let i = t.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function i$(n, e, t) {
  let r = t.split("|");
  return (i) => {
    let s = i === null ? "null" : typeof i;
    if (r.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n}, got ${s}`);
  };
}
class s$ {
  constructor(e, t, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? i$(e, t, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class c1 {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = KM(e, i.attrs), this.excluded = null;
    let s = WM(this.attrs);
    this.instance = s ? new nt(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new nt(this, jM(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, o) => r[s] = new c1(s, i++, t, o)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    UM(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class YM {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let i in e)
      t[i] = e[i];
    t.nodes = Nn.from(e.nodes), t.marks = Nn.from(e.marks || {}), this.nodes = fm.compile(this.spec.nodes, this), this.marks = c1.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let s = this.nodes[i], o = s.spec.content || "", l = s.spec.marks;
      if (s.contentMatch = r[o] || (r[o] = ka.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!s.isInline || !s.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = s;
      }
      s.markSet = l == "_" ? null : l ? Hw(this, l.split(" ")) : l == "" || !s.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let s = this.marks[i], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : Hw(this, o.split(" "));
    }
    this.nodeFromJSON = (i) => ro.fromJSON(this, i), this.markFromJSON = (i) => nt.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof fm) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let r = this.nodes.text;
    return new GH(r, r.defaultAttrs, e, nt.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function Hw(n, e) {
  let t = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], s = n.marks[i], o = s;
    if (s)
      t.push(s);
    else
      for (let l in n.marks) {
        let a = n.marks[l];
        (i == "_" || a.spec.group && a.spec.group.split(" ").indexOf(i) > -1) && t.push(o = a);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return t;
}
function o$(n) {
  return n.tag != null;
}
function l$(n) {
  return n.style != null;
}
class Sa {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    t.forEach((i) => {
      if (o$(i))
        this.tags.push(i);
      else if (l$(i)) {
        let s = /[^=]*/.exec(i.style)[0];
        r.indexOf(s) < 0 && r.push(s), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let s = e.nodes[i.node];
      return s.contentMatch.matchType(s);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let r = new Vw(this, t, !1);
    return r.addAll(e, nt.none, t.from, t.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let r = new Vw(this, t, !0);
    return r.addAll(e, nt.none, t.from, t.to), ve.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (u$(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], l = o.style;
      if (!(l.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      l.length > e.length && (l.charCodeAt(e.length) != 61 || l.slice(e.length + 1) != t))) {
        if (o.getAttrs) {
          let a = o.getAttrs(t);
          if (a === !1)
            continue;
          o.attrs = a || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function r(i) {
      let s = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < t.length; o++) {
        let l = t[o];
        if ((l.priority == null ? 50 : l.priority) < s)
          break;
      }
      t.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = qw(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = qw(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Sa(e, Sa.schemaRules(e)));
  }
}
const JM = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, a$ = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, XM = { ol: !0, ul: !0 }, Rf = 1, xy = 2, Vh = 4;
function $w(n, e, t) {
  return e != null ? (e ? Rf : 0) | (e === "full" ? xy : 0) : n && n.whitespace == "pre" ? Rf | xy : t & ~Vh;
}
class h0 {
  constructor(e, t, r, i, s, o) {
    this.type = e, this.attrs = t, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = nt.none, this.match = s || (o & Vh ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore(ce.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Rf)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let t = ce.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore(ce.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !JM.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class Vw {
  constructor(e, t, r) {
    this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = t.topNode, s, o = $w(null, t.preserveWhitespace, 0) | (r ? Vh : 0);
    i ? s = new h0(i.type, i.attrs, nt.none, !0, t.topMatch || i.type.contentMatch, o) : r ? s = new h0(null, null, nt.none, !0, null, o) : s = new h0(e.schema.topNodeType, null, nt.none, !0, null, o), this.nodes = [s], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, t) {
    e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
  }
  addTextNode(e, t) {
    let r = e.nodeValue, i = this.top, s = i.options & xy ? "full" : this.localPreserveWS || (i.options & Rf) > 0;
    if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (s)
        s !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let o = i.content[i.content.length - 1], l = e.previousSibling;
        (!o || l && l.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), t, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t, r) {
    let i = this.localPreserveWS, s = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let o = e.nodeName.toLowerCase(), l;
    XM.hasOwnProperty(o) && this.parser.normalizeLists && c$(e);
    let a = this.options.ruleFromNode && this.options.ruleFromNode(e) || (l = this.parser.matchTag(e, this, r));
    e: if (a ? a.ignore : a$.hasOwnProperty(o))
      this.findInside(e), this.ignoreFallback(e, t);
    else if (!a || a.skip || a.closeParent) {
      a && a.closeParent ? this.open = Math.max(0, this.open - 1) : a && a.skip.nodeType && (e = a.skip);
      let c, u = this.needsBlock;
      if (JM.hasOwnProperty(o))
        s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), c = !0, s.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, t);
        break e;
      }
      let h = a && a.skip ? t : this.readStyles(e, t);
      h && this.addAll(e, h), c && this.sync(s), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, t);
      c && this.addElementByRule(e, a, c, a.consuming === !1 ? l : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
  }
  // Called for ignored nodes
  ignoreFallback(e, t) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, t) {
    let r = e.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let s = this.parser.matchedStyles[i], o = r.getPropertyValue(s);
        if (o)
          for (let l = void 0; ; ) {
            let a = this.parser.matchStyle(s, o, this, l);
            if (!a)
              break;
            if (a.ignore)
              return null;
            if (a.clearMark ? t = t.filter((c) => !a.clearMark(c)) : t = t.concat(this.parser.schema.marks[a.mark].create(a.attrs)), a.consuming === !1)
              l = a;
            else
              break;
          }
      }
    return t;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, r, i) {
    let s, o;
    if (t.node)
      if (o = this.parser.schema.nodes[t.node], o.isLeaf)
        this.insertNode(o.create(t.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let a = this.enter(o, t.attrs || null, r, t.preserveWhitespace);
        a && (s = !0, r = a);
      }
    else {
      let a = this.parser.schema.marks[t.mark];
      r = r.concat(a.create(t.attrs));
    }
    let l = this.top;
    if (o && o.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, r, i);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((a) => this.insertNode(a, r, !1));
    else {
      let a = e;
      typeof t.contentElement == "string" ? a = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? a = t.contentElement(e) : t.contentElement && (a = t.contentElement), this.findAround(e, a, !0), this.addAll(a, r), this.findAround(e, a, !1);
    }
    s && this.sync(l) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, r, i) {
    let s = r || 0;
    for (let o = r ? e.childNodes[r] : e.firstChild, l = i == null ? null : e.childNodes[i]; o != l; o = o.nextSibling, ++s)
      this.findAtPoint(e, s), this.addDOM(o, t);
    this.findAtPoint(e, s);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, t, r) {
    let i, s;
    for (let o = this.open, l = 0; o >= 0; o--) {
      let a = this.nodes[o], c = a.findWrapping(e);
      if (c && (!i || i.length > c.length + l) && (i = c, s = a, !c.length))
        break;
      if (a.solid) {
        if (r)
          break;
        l += 2;
      }
    }
    if (!i)
      return null;
    this.sync(s);
    for (let o = 0; o < i.length; o++)
      t = this.enterInner(i[o], null, t, !1);
    return t;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, t, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let s = this.textblockFromContext();
      s && (t = this.enterInner(s, null, t));
    }
    let i = this.findPlace(e, t, r);
    if (i) {
      this.closeExtra();
      let s = this.top;
      s.match && (s.match = s.match.matchType(e.type));
      let o = nt.none;
      for (let l of i.concat(e.marks))
        (s.type ? s.type.allowsMarkType(l.type) : Ww(l.type, e.type)) && (o = l.addToSet(o));
      return s.content.push(e.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, r, i) {
    let s = this.findPlace(e.create(t), r, !1);
    return s && (s = this.enterInner(e, t, r, !0, i)), s;
  }
  // Open a node of the given type
  enterInner(e, t, r, i = !1, s) {
    this.closeExtra();
    let o = this.top;
    o.match = o.match && o.match.matchType(e);
    let l = $w(e, s, o.options);
    o.options & Vh && o.content.length == 0 && (l |= Vh);
    let a = nt.none;
    return r = r.filter((c) => (o.type ? o.type.allowsMarkType(c.type) : Ww(c.type, e)) ? (a = c.addToSet(a), !1) : !0), this.nodes.push(new h0(e, t, a, i, null, l)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--) {
      if (this.nodes[t] == e)
        return this.open = t, !0;
      this.localPreserveWS && (this.nodes[t].options |= Rf);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let r = this.nodes[t].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, r) {
    if (e != t && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (l, a) => {
      for (; l >= 0; l--) {
        let c = t[l];
        if (c == "") {
          if (l == t.length - 1 || l == 0)
            continue;
          for (; a >= s; a--)
            if (o(l - 1, a))
              return !0;
          return !1;
        } else {
          let u = a > 0 || a == 0 && i ? this.nodes[a].type : r && a >= s ? r.node(a - s).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          a--;
        }
      }
      return !0;
    };
    return o(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let t in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[t];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function c$(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && XM.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
  }
}
function u$(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function qw(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function Ww(n, e) {
  let t = e.schema.nodes;
  for (let r in t) {
    let i = t[r];
    if (!i.allowsMarkType(n))
      continue;
    let s = [], o = (l) => {
      s.push(l);
      for (let a = 0; a < l.edgeCount; a++) {
        let { type: c, next: u } = l.edge(a);
        if (c == e || s.indexOf(u) < 0 && o(u))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
class Pa {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, r) {
    r || (r = Kg(t).createDocumentFragment());
    let i = r, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let l = 0, a = 0;
        for (; l < s.length && a < o.marks.length; ) {
          let c = o.marks[a];
          if (!this.marks[c.type.name]) {
            a++;
            continue;
          }
          if (!c.eq(s[l][0]) || c.type.spec.spanning === !1)
            break;
          l++, a++;
        }
        for (; l < s.length; )
          i = s.pop()[1];
        for (; a < o.marks.length; ) {
          let c = o.marks[a++], u = this.serializeMark(c, o.isInline, t);
          u && (s.push([c, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, t));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: r, contentDOM: i } = np(Kg(t), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let r = this.serializeNodeInner(e, t);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, t);
      s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, t, r = {}) {
    let i = this.marks[e.type.name];
    return i && np(Kg(r), i(e, t), null, e.attrs);
  }
  static renderSpec(e, t, r = null, i) {
    return np(e, t, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Pa(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = jw(e.nodes);
    return t.text || (t.text = (r) => r.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return jw(e.marks);
  }
}
function jw(n) {
  let e = {};
  for (let t in n) {
    let r = n[t].spec.toDOM;
    r && (e[t] = r);
  }
  return e;
}
function Kg(n) {
  return n.document || window.document;
}
const Uw = /* @__PURE__ */ new WeakMap();
function h$(n) {
  let e = Uw.get(n);
  return e === void 0 && Uw.set(n, e = f$(n)), e;
}
function f$(n) {
  let e = null;
  function t(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let i = 0; i < r.length; i++)
            t(r[i]);
      else
        for (let i in r)
          t(r[i]);
  }
  return t(n), e;
}
function np(n, e, t, r) {
  if (typeof e == "string")
    return { dom: n.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], s;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (s = h$(r)) && s.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let o = i.indexOf(" ");
  o > 0 && (t = i.slice(0, o), i = i.slice(o + 1));
  let l, a = t ? n.createElementNS(t, i) : n.createElement(i), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let h in c)
      if (c[h] != null) {
        let f = h.indexOf(" ");
        f > 0 ? a.setAttributeNS(h.slice(0, f), h.slice(f + 1), c[h]) : h == "style" && a.style ? a.style.cssText = c[h] : a.setAttribute(h, c[h]);
      }
  }
  for (let h = u; h < e.length; h++) {
    let f = e[h];
    if (f === 0) {
      if (h < e.length - 1 || h > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: a, contentDOM: a };
    } else {
      let { dom: d, contentDOM: p } = np(n, f, t, r);
      if (a.appendChild(d), p) {
        if (l)
          throw new RangeError("Multiple content holes");
        l = p;
      }
    }
  }
  return { dom: a, contentDOM: l };
}
const ZM = 65535, QM = Math.pow(2, 16);
function d$(n, e) {
  return n + e * QM;
}
function Kw(n) {
  return n & ZM;
}
function p$(n) {
  return (n - (n & ZM)) / QM;
}
const eT = 1, tT = 2, rp = 4, nT = 8;
class ky {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.delInfo = t, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & nT) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (eT | rp)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (tT | rp)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & rp) > 0;
  }
}
class Ur {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && Ur.empty)
      return Ur.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, r = Kw(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + t + p$(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let a = this.ranges[l] - (this.inverted ? i : 0);
      if (a > e)
        break;
      let c = this.ranges[l + s], u = this.ranges[l + o], h = a + c;
      if (e <= h) {
        let f = c ? e == a ? -1 : e == h ? 1 : t : t, d = a + i + (f < 0 ? 0 : u);
        if (r)
          return d;
        let p = e == (t < 0 ? a : h) ? null : d$(l / 3, e - a), m = e == a ? tT : e == h ? eT : rp;
        return (t < 0 ? e != a : e != h) && (m |= nT), new ky(d, m, p);
      }
      i += u - c;
    }
    return r ? e + i : new ky(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let r = 0, i = Kw(t), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let a = this.ranges[l] - (this.inverted ? r : 0);
      if (a > e)
        break;
      let c = this.ranges[l + s], u = a + c;
      if (e <= u && l == i * 3)
        return !0;
      r += this.ranges[l + o] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], l = o - (this.inverted ? s : 0), a = o + (this.inverted ? 0 : s), c = this.ranges[i + t], u = this.ranges[i + r];
      e(l, l + c, a, a + u), s += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Ur(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Ur.empty : new Ur(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Ur.empty = new Ur([]);
class Pf {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, t, r = 0, i = e ? e.length : 0) {
    this.mirror = t, this.from = r, this.to = i, this._maps = e || [], this.ownData = !(e || t);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new Pf(this._maps, this.mirror, e, t);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, r = this._maps.length; t < e._maps.length; t++) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t], i != null && i < t ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, r = this._maps.length + e._maps.length; t >= 0; t--) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t].invert(), i != null && i > t ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new Pf();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this._maps[s], l = o.mapResult(e, t);
      if (l.recover != null) {
        let a = this.getMirror(s);
        if (a != null && a > s && a < this.to) {
          s = a, e = this._maps[a].recover(l.recover);
          continue;
        }
      }
      i |= l.delInfo, e = l.pos;
    }
    return r ? e : new ky(e, i, null);
  }
}
const Gg = /* @__PURE__ */ Object.create(null);
class Zn {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Ur.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = Gg[t.stepType];
    if (!r)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in Gg)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Gg[e] = t, t.prototype.jsonID = e, t;
  }
}
class pn {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new pn(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new pn(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, r, i) {
    try {
      return pn.ok(e.replace(t, r, i));
    } catch (s) {
      if (s instanceof um)
        return pn.fail(s.message);
      throw s;
    }
  }
}
function T3(n, e, t) {
  let r = [];
  for (let i = 0; i < n.childCount; i++) {
    let s = n.child(i);
    s.content.size && (s = s.copy(T3(s.content, e, s))), s.isInline && (s = e(s, t, i)), r.push(s);
  }
  return ce.fromArray(r);
}
class Zs extends Zn {
  /**
  Create a mark step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new ve(T3(t.content, (o, l) => !o.isAtom || !l.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), t.openStart, t.openEnd);
    return pn.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new fs(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Zs(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Zs && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Zs(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Zs(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("addMark", Zs);
class fs extends Zn {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = new ve(T3(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd);
    return pn.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Zs(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new fs(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof fs && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new fs(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new fs(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("removeMark", fs);
class Xo extends Zn {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return pn.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return pn.fromReplace(e, this.pos, this.pos + 1, new ve(ce.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let r = this.mark.addToSet(t.marks);
      if (r.length == t.marks.length) {
        for (let i = 0; i < t.marks.length; i++)
          if (!t.marks[i].isInSet(r))
            return new Xo(this.pos, t.marks[i]);
        return new Xo(this.pos, this.mark);
      }
    }
    return new Ca(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Xo(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Xo(t.pos, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("addNodeMark", Xo);
class Ca extends Zn {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return pn.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return pn.fromReplace(e, this.pos, this.pos + 1, new ve(ce.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new Xo(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Ca(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Ca(t.pos, e.markFromJSON(t.mark));
  }
}
Zn.jsonID("removeNodeMark", Ca);
class Cn extends Zn {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, r, i = !1) {
    super(), this.from = e, this.to = t, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && Sy(e, this.from, this.to) ? pn.fail("Structure replace would overwrite content") : pn.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Ur([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new Cn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deletedAcross && r.deletedAcross ? null : new Cn(t.pos, Math.max(t.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof Cn) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? ve.empty : new ve(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new Cn(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? ve.empty : new ve(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new Cn(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Cn(t.from, t.to, ve.fromJSON(e, t.slice), !!t.structure);
  }
}
Zn.jsonID("replace", Cn);
class Yn extends Zn {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, r, i, s, o, l = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = l;
  }
  apply(e) {
    if (this.structure && (Sy(e, this.from, this.gapFrom) || Sy(e, this.gapTo, this.to)))
      return pn.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return pn.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, t.content);
    return r ? pn.fromReplace(e, this.from, this.to, r) : pn.fail("Content does not fit in gap");
  }
  getMap() {
    return new Ur([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new Yn(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return t.deletedAcross && r.deletedAcross || i < t.pos || s > r.pos ? null : new Yn(t.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Yn(t.from, t.to, t.gapFrom, t.gapTo, ve.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
Zn.jsonID("replaceAround", Yn);
function Sy(n, e, t) {
  let r = n.resolve(e), i = t - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function m$(n, e, t, r) {
  let i = [], s = [], o, l;
  n.doc.nodesBetween(e, t, (a, c, u) => {
    if (!a.isInline)
      return;
    let h = a.marks;
    if (!r.isInSet(h) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), d = Math.min(c + a.nodeSize, t), p = r.addToSet(h);
      for (let m = 0; m < h.length; m++)
        h[m].isInSet(p) || (o && o.to == f && o.mark.eq(h[m]) ? o.to = d : i.push(o = new fs(f, d, h[m])));
      l && l.to == f ? l.to = d : s.push(l = new Zs(f, d, r));
    }
  }), i.forEach((a) => n.step(a)), s.forEach((a) => n.step(a));
}
function g$(n, e, t, r) {
  let i = [], s = 0;
  n.doc.nodesBetween(e, t, (o, l) => {
    if (!o.isInline)
      return;
    s++;
    let a = null;
    if (r instanceof c1) {
      let c = o.marks, u;
      for (; u = r.isInSet(c); )
        (a || (a = [])).push(u), c = u.removeFromSet(c);
    } else r ? r.isInSet(o.marks) && (a = [r]) : a = o.marks;
    if (a && a.length) {
      let c = Math.min(l + o.nodeSize, t);
      for (let u = 0; u < a.length; u++) {
        let h = a[u], f;
        for (let d = 0; d < i.length; d++) {
          let p = i[d];
          p.step == s - 1 && h.eq(i[d].style) && (f = p);
        }
        f ? (f.to = c, f.step = s) : i.push({ style: h, from: Math.max(l, e), to: c, step: s });
      }
    }
  }), i.forEach((o) => n.step(new fs(o.from, o.to, o.style)));
}
function A3(n, e, t, r = t.contentMatch, i = !0) {
  let s = n.doc.nodeAt(e), o = [], l = e + 1;
  for (let a = 0; a < s.childCount; a++) {
    let c = s.child(a), u = l + c.nodeSize, h = r.matchType(c.type);
    if (!h)
      o.push(new Cn(l, u, ve.empty));
    else {
      r = h;
      for (let f = 0; f < c.marks.length; f++)
        t.allowsMarkType(c.marks[f].type) || n.step(new fs(l, u, c.marks[f]));
      if (i && c.isText && t.whitespace != "pre") {
        let f, d = /\r?\n|\r/g, p;
        for (; f = d.exec(c.text); )
          p || (p = new ve(ce.from(t.schema.text(" ", t.allowedMarks(c.marks))), 0, 0)), o.push(new Cn(l + f.index, l + f.index + f[0].length, p));
      }
    }
    l = u;
  }
  if (!r.validEnd) {
    let a = r.fillBefore(ce.empty, !0);
    n.replace(l, l, new ve(a, 0, 0));
  }
  for (let a = o.length - 1; a >= 0; a--)
    n.step(o[a]);
}
function y$(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function u1(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let r = n.depth; ; --r) {
    let i = n.$from.node(r), s = n.$from.index(r), o = n.$to.indexAfter(r);
    if (r < n.depth && i.canReplace(s, o, t))
      return r;
    if (r == 0 || i.type.spec.isolating || !y$(i, s, o))
      break;
  }
  return null;
}
function b$(n, e, t) {
  let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), l = i.after(s + 1), a = o, c = l, u = ce.empty, h = 0;
  for (let p = s, m = !1; p > t; p--)
    m || r.index(p) > 0 ? (m = !0, u = ce.from(r.node(p).copy(u)), h++) : a--;
  let f = ce.empty, d = 0;
  for (let p = s, m = !1; p > t; p--)
    m || i.after(p + 1) < i.end(p) ? (m = !0, f = ce.from(i.node(p).copy(f)), d++) : c++;
  n.step(new Yn(a, c, o, l, new ve(u.append(f), h, d), u.size - h, !0));
}
function O3(n, e, t = null, r = n) {
  let i = v$(n, e), s = i && w$(r, e);
  return s ? i.map(Gw).concat({ type: e, attrs: t }).concat(s.map(Gw)) : null;
}
function Gw(n) {
  return { type: n, attrs: null };
}
function v$(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.contentMatchAt(r).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return t.canReplaceWith(r, i, o) ? s : null;
}
function w$(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.child(r), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let a = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let c = r; a && c < i; c++)
    a = a.matchType(t.child(c).type);
  return !a || !a.validEnd ? null : o;
}
function x$(n, e, t) {
  let r = ce.empty;
  for (let o = t.length - 1; o >= 0; o--) {
    if (r.size) {
      let l = t[o].type.contentMatch.matchFragment(r);
      if (!l || !l.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = ce.from(t[o].type.create(t[o].attrs, r));
  }
  let i = e.start, s = e.end;
  n.step(new Yn(i, s, i, s, new ve(r, 0, 0), t.length, !0));
}
function k$(n, e, t, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = n.steps.length;
  n.doc.nodesBetween(e, t, (o, l) => {
    let a = typeof i == "function" ? i(o) : i;
    if (o.isTextblock && !o.hasMarkup(r, a) && S$(n.doc, n.mapping.slice(s).map(l), r)) {
      let c = null;
      if (r.schema.linebreakReplacement) {
        let d = r.whitespace == "pre", p = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        d && !p ? c = !1 : !d && p && (c = !0);
      }
      c === !1 && iT(n, o, l, s), A3(n, n.mapping.slice(s).map(l, 1), r, void 0, c === null);
      let u = n.mapping.slice(s), h = u.map(l, 1), f = u.map(l + o.nodeSize, 1);
      return n.step(new Yn(h, f, h + 1, f - 1, new ve(ce.from(r.create(a, null, o.marks)), 0, 0), 1, !0)), c === !0 && rT(n, o, l, s), !1;
    }
  });
}
function rT(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.isText) {
      let o, l = /\r?\n|\r/g;
      for (; o = l.exec(i.text); ) {
        let a = n.mapping.slice(r).map(t + 1 + s + o.index);
        n.replaceWith(a, a + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function iT(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = n.mapping.slice(r).map(t + 1 + s);
      n.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function S$(n, e, t) {
  let r = n.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, t);
}
function C$(n, e, t, r, i) {
  let s = n.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  t || (t = s.type);
  let o = t.create(r, null, i || s.marks);
  if (s.isLeaf)
    return n.replaceWith(e, e + s.nodeSize, o);
  if (!t.validContent(s.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new Yn(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new ve(ce.from(o), 0, 0), 1, !0));
}
function qh(n, e, t = 1, r) {
  let i = n.resolve(e), s = i.depth - t, o = r && r[r.length - 1] || i.parent;
  if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let c = i.depth - 1, u = t - 2; c > s; c--, u--) {
    let h = i.node(c), f = i.index(c);
    if (h.type.spec.isolating)
      return !1;
    let d = h.content.cutByIndex(f, h.childCount), p = r && r[u + 1];
    p && (d = d.replaceChild(0, p.type.create(p.attrs)));
    let m = r && r[u] || h;
    if (!h.canReplace(f + 1, h.childCount) || !m.type.validContent(d))
      return !1;
  }
  let l = i.indexAfter(s), a = r && r[0];
  return i.node(s).canReplaceWith(l, l, a ? a.type : i.node(s + 1).type);
}
function M$(n, e, t = 1, r) {
  let i = n.doc.resolve(e), s = ce.empty, o = ce.empty;
  for (let l = i.depth, a = i.depth - t, c = t - 1; l > a; l--, c--) {
    s = ce.from(i.node(l).copy(s));
    let u = r && r[c];
    o = ce.from(u ? u.type.create(u.attrs, o) : i.node(l).copy(o));
  }
  n.step(new Cn(e, e, new ve(s.append(o), t, t), !0));
}
function h1(n, e) {
  let t = n.resolve(e), r = t.index();
  return A$(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
}
function T$(n, e) {
  e.content.size || n.type.compatibleContent(e.type);
  let t = n.contentMatchAt(n.childCount), { linebreakReplacement: r } = n.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let s = e.child(i), o = s.type == r ? n.type.schema.nodes.text : s.type;
    if (t = t.matchType(o), !t || !n.type.allowsMarks(s.marks))
      return !1;
  }
  return t.validEnd;
}
function A$(n, e) {
  return !!(n && e && !n.isLeaf && T$(n, e));
}
function O$(n, e, t) {
  let r = null, { linebreakReplacement: i } = n.doc.type.schema, s = n.doc.resolve(e - t), o = s.node().type;
  if (i && o.inlineContent) {
    let u = o.whitespace == "pre", h = !!o.contentMatch.matchType(i);
    u && !h ? r = !1 : !u && h && (r = !0);
  }
  let l = n.steps.length;
  if (r === !1) {
    let u = n.doc.resolve(e + t);
    iT(n, u.node(), u.before(), l);
  }
  o.inlineContent && A3(n, e + t - 1, o, s.node().contentMatchAt(s.index()), r == null);
  let a = n.mapping.slice(l), c = a.map(e - t);
  if (n.step(new Cn(c, a.map(e + t, -1), ve.empty, !0)), r === !0) {
    let u = n.doc.resolve(c);
    rT(n, u.node(), u.before(), n.steps.length);
  }
  return n;
}
function E$(n, e, t) {
  let r = n.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), t))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.before(i + 1);
      if (s > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.after(i + 1);
      if (s < r.node(i).childCount)
        return null;
    }
  return null;
}
function sT(n, e, t) {
  let r = n.resolve(e);
  if (!t.content.size)
    return e;
  let i = t.content;
  for (let s = 0; s < t.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let l = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, a = r.index(o) + (l > 0 ? 1 : 0), c = r.node(o), u = !1;
      if (s == 1)
        u = c.canReplace(a, a, i);
      else {
        let h = c.contentMatchAt(a).findWrapping(i.firstChild.type);
        u = h && c.canReplaceWith(a, a, h[0]);
      }
      if (u)
        return l == 0 ? r.pos : l < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function f1(n, e, t = e, r = ve.empty) {
  if (e == t && !r.size)
    return null;
  let i = n.resolve(e), s = n.resolve(t);
  return oT(i, s, r) ? new Cn(e, t, r) : new I$(i, s, r).fit();
}
function oT(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class I$ {
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = ce.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = ce.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, o = r.depth, l = i.depth;
    for (; o && l && s.childCount == 1; )
      s = s.firstChild.content, o--, l--;
    let a = new ve(s, o, l);
    return e > -1 ? new Yn(r.pos, e, this.$to.pos, this.$to.end(), a, t) : a.size || r.pos != this.$to.pos ? new Cn(r.pos, i.pos, a) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = t.firstChild;
      if (t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      t = s.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = Yg(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let l = this.depth; l >= 0; l--) {
          let { type: a, match: c } = this.frontier[l], u, h = null;
          if (t == 1 && (o ? c.matchType(o.type) || (h = c.fillBefore(ce.from(o), !1)) : s && a.compatibleContent(s.type)))
            return { sliceDepth: r, frontierDepth: l, parent: s, inject: h };
          if (t == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: l, parent: s, wrap: u };
          if (s && c.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = Yg(e, t);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new ve(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = Yg(e, t);
    if (i.childCount <= 1 && t > 0) {
      let s = e.size - t <= t + i.size;
      this.unplaced = new ve(nh(e, t - 1, 1), t - 1, s ? t - 1 : r);
    } else
      this.unplaced = new ve(nh(e, t, 1), t, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: s }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (s)
      for (let m = 0; m < s.length; m++)
        this.openFrontierNode(s[m]);
    let o = this.unplaced, l = r ? r.content : o.content, a = o.openStart - e, c = 0, u = [], { match: h, type: f } = this.frontier[t];
    if (i) {
      for (let m = 0; m < i.childCount; m++)
        u.push(i.child(m));
      h = h.matchFragment(i);
    }
    let d = l.size + e - (o.content.size - o.openEnd);
    for (; c < l.childCount; ) {
      let m = l.child(c), g = h.matchType(m.type);
      if (!g)
        break;
      c++, (c > 1 || a == 0 || m.content.size) && (h = g, u.push(lT(m.mark(f.allowedMarks(m.marks)), c == 1 ? a : 0, c == l.childCount ? d : -1)));
    }
    let p = c == l.childCount;
    p || (d = -1), this.placed = rh(this.placed, t, ce.from(u)), this.frontier[t].match = h, p && d < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let m = 0, g = l; m < d; m++) {
      let b = g.lastChild;
      this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), g = b.content;
    }
    this.unplaced = p ? e == 0 ? ve.empty : new ve(nh(o.content, e - 1, 1), e - 1, d < 0 ? o.openEnd : e - 1) : new ve(nh(o.content, e, c), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !Jg(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
      let { match: r, type: i } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = Jg(e, t, i, r, s);
      if (o) {
        for (let l = t - 1; l >= 0; l--) {
          let { match: a, type: c } = this.frontier[l], u = Jg(e, l, c, a, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: t, fit: o, move: s ? e.doc.resolve(e.after(t + 1)) : e };
      }
    }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = rh(this.placed, t.depth, t.fit)), e = t.move;
    for (let r = t.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, t = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = rh(this.placed, this.depth, ce.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(ce.empty, !0);
    t.childCount && (this.placed = rh(this.placed, this.frontier.length, t));
  }
}
function nh(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(nh(n.firstChild.content, e - 1, t)));
}
function rh(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(rh(n.lastChild.content, e - 1, t)));
}
function Yg(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function lT(n, e, t) {
  if (e <= 0)
    return n;
  let r = n.content;
  return e > 1 && (r = r.replaceChild(0, lT(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(ce.empty, !0)))), n.copy(r);
}
function Jg(n, e, t, r, i) {
  let s = n.node(e), o = i ? n.indexAfter(e) : n.index(e);
  if (o == s.childCount && !t.compatibleContent(s.type))
    return null;
  let l = r.fillBefore(s.content, !0, o);
  return l && !D$(t, s.content, o) ? l : null;
}
function D$(n, e, t) {
  for (let r = t; r < e.childCount; r++)
    if (!n.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function N$(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function R$(n, e, t, r) {
  if (!r.size)
    return n.deleteRange(e, t);
  let i = n.doc.resolve(e), s = n.doc.resolve(t);
  if (oT(i, s, r))
    return n.step(new Cn(e, t, r));
  let o = cT(i, n.doc.resolve(t));
  o[o.length - 1] == 0 && o.pop();
  let l = -(i.depth + 1);
  o.unshift(l);
  for (let f = i.depth, d = i.pos - 1; f > 0; f--, d--) {
    let p = i.node(f).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    o.indexOf(f) > -1 ? l = f : i.before(f) == d && o.splice(1, 0, -f);
  }
  let a = o.indexOf(l), c = [], u = r.openStart;
  for (let f = r.content, d = 0; ; d++) {
    let p = f.firstChild;
    if (c.push(p), d == r.openStart)
      break;
    f = p.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let d = c[f], p = N$(d.type);
    if (p && !d.sameMarkup(i.node(Math.abs(l) - 1)))
      u = f;
    else if (p || !d.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let d = (f + u + 1) % (r.openStart + 1), p = c[d];
    if (p)
      for (let m = 0; m < o.length; m++) {
        let g = o[(m + a) % o.length], b = !0;
        g < 0 && (b = !1, g = -g);
        let w = i.node(g - 1), k = i.index(g - 1);
        if (w.canReplaceWith(k, k, p.type, p.marks))
          return n.replace(i.before(g), b ? s.after(g) : t, new ve(aT(r.content, 0, r.openStart, d), d, r.openEnd));
      }
  }
  let h = n.steps.length;
  for (let f = o.length - 1; f >= 0 && (n.replace(e, t, r), !(n.steps.length > h)); f--) {
    let d = o[f];
    d < 0 || (e = i.before(d), t = s.after(d));
  }
}
function aT(n, e, t, r, i) {
  if (e < t) {
    let s = n.firstChild;
    n = n.replaceChild(0, s.copy(aT(s.content, e + 1, t, r, s)));
  }
  if (e > r) {
    let s = i.contentMatchAt(0), o = s.fillBefore(n).append(n);
    n = o.append(s.matchFragment(o).fillBefore(ce.empty, !0));
  }
  return n;
}
function P$(n, e, t, r) {
  if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let i = E$(n.doc, e, r.type);
    i != null && (e = t = i);
  }
  n.replaceRange(e, t, new ve(ce.from(r), 0, 0));
}
function _$(n, e, t) {
  let r = n.doc.resolve(e), i = n.doc.resolve(t), s = cT(r, i);
  for (let o = 0; o < s.length; o++) {
    let l = s[o], a = o == s.length - 1;
    if (a && l == 0 || r.node(l).type.contentMatch.validEnd)
      return n.delete(r.start(l), i.end(l));
    if (l > 0 && (a || r.node(l - 1).canReplace(r.index(l - 1), i.indexAfter(l - 1))))
      return n.delete(r.before(l), i.after(l));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && t > r.end(o) && i.end(o) - t != i.depth - o && r.start(o - 1) == i.start(o - 1) && r.node(o - 1).canReplace(r.index(o - 1), i.index(o - 1)))
      return n.delete(r.before(o), t);
  n.delete(e, t);
}
function cT(n, e) {
  let t = [], r = Math.min(n.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let s = n.start(i);
    if (s < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && t.push(i);
  }
  return t;
}
class vc extends Zn {
  /**
  Construct an attribute step.
  */
  constructor(e, t, r) {
    super(), this.pos = e, this.attr = t, this.value = r;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return pn.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in t.attrs)
      r[s] = t.attrs[s];
    r[this.attr] = this.value;
    let i = t.type.create(r, null, t.marks);
    return pn.fromReplace(e, this.pos, this.pos + 1, new ve(ce.from(i), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return Ur.empty;
  }
  invert(e) {
    return new vc(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new vc(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new vc(t.pos, t.attr, t.value);
  }
}
Zn.jsonID("attr", vc);
class _f extends Zn {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      t[i] = e.attrs[i];
    t[this.attr] = this.value;
    let r = e.type.create(t, e.content, e.marks);
    return pn.ok(r);
  }
  getMap() {
    return Ur.empty;
  }
  invert(e) {
    return new _f(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _f(t.attr, t.value);
  }
}
Zn.jsonID("docAttr", _f);
let Bc = class extends Error {
};
Bc = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
Bc.prototype = Object.create(Error.prototype);
Bc.prototype.constructor = Bc;
Bc.prototype.name = "TransformError";
class uT {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Pf();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new Bc(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, r = ve.empty) {
    let i = f1(this.doc, e, t, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, r) {
    return this.replace(e, t, new ve(ce.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, ve.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, r) {
    return R$(this, e, t, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, r) {
    return P$(this, e, t, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return _$(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return b$(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return O$(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return x$(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, r, i = null) {
    return k$(this, e, t, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, r = null, i) {
    return C$(this, e, t, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, r) {
    return this.step(new vc(e, t, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new _f(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new Xo(e, t)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (t instanceof nt)
      t.isInSet(r.marks) && this.step(new Ca(e, t));
    else {
      let i = r.marks, s, o = [];
      for (; s = t.isInSet(i); )
        o.push(new Ca(e, s)), i = s.removeFromSet(i);
      for (let l = o.length - 1; l >= 0; l--)
        this.step(o[l]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, t = 1, r) {
    return M$(this, e, t, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, r) {
    return m$(this, e, t, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, r) {
    return g$(this, e, t, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, r) {
    return A3(this, e, t, r), this;
  }
}
const Xg = /* @__PURE__ */ Object.create(null);
class Ge {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, r) {
    this.$anchor = e, this.$head = t, this.ranges = r || [new hT(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = ve.empty) {
    let r = t.content.lastChild, i = null;
    for (let l = 0; l < t.openEnd; l++)
      i = r, r = r.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let l = 0; l < o.length; l++) {
      let { $from: a, $to: c } = o[l], u = e.mapping.slice(s);
      e.replaceRange(u.map(a.pos), u.map(c.pos), l ? ve.empty : t), l == 0 && Xw(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let r = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: l } = i[s], a = e.mapping.slice(r), c = a.map(o.pos), u = a.map(l.pos);
      s ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, t), Xw(e, r, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, r = !1) {
    let i = e.parent.inlineContent ? new Ee(e) : ec(e.node(0), e.parent, e.pos, e.index(), t, r);
    if (i)
      return i;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = t < 0 ? ec(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, r) : ec(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, r);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new Or(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return ec(e, e, 0, 0, 1) || new Or(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return ec(e, e, e.content.size, e.childCount, -1) || new Or(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = Xg[t.type];
    if (!r)
      throw new RangeError(`No selection type ${t.type} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in Xg)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Xg[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Ee.between(this.$anchor, this.$head).getBookmark();
  }
}
Ge.prototype.visible = !0;
class hT {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let Yw = !1;
function Jw(n) {
  !Yw && !n.parent.inlineContent && (Yw = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class Ee extends Ge {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    Jw(e), Jw(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    if (!r.parent.inlineContent)
      return Ge.near(r);
    let i = e.resolve(t.map(this.anchor));
    return new Ee(i.parent.inlineContent ? i : r, r);
  }
  replace(e, t = ve.empty) {
    if (super.replace(e, t), t == ve.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof Ee && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new d1(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Ee(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, r = t) {
    let i = e.resolve(t);
    return new this(i, r == t ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, r) {
    let i = e.pos - t.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let s = Ge.findFrom(t, r, !0) || Ge.findFrom(t, -r, !0);
      if (s)
        t = s.$head;
      else
        return Ge.near(t, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = t : (e = (Ge.findFrom(e, -r, !0) || Ge.findFrom(e, r, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new Ee(e, t);
  }
}
Ge.jsonID("text", Ee);
class d1 {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new d1(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Ee.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class $e extends Ge {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, r), this.node = t;
  }
  map(e, t) {
    let { deleted: r, pos: i } = t.mapResult(this.anchor), s = e.resolve(i);
    return r ? Ge.near(s) : new $e(s);
  }
  content() {
    return new ve(ce.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof $e && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new E3(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new $e(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new $e(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
$e.prototype.visible = !1;
Ge.jsonID("node", $e);
class E3 {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: r } = e.mapResult(this.anchor);
    return t ? new d1(r, r) : new E3(r);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), r = t.nodeAfter;
    return r && $e.isSelectable(r) ? new $e(t) : Ge.near(t);
  }
}
class Or extends Ge {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = ve.empty) {
    if (t == ve.empty) {
      e.delete(0, e.doc.content.size);
      let r = Ge.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Or(e);
  }
  map(e) {
    return new Or(e);
  }
  eq(e) {
    return e instanceof Or;
  }
  getBookmark() {
    return L$;
  }
}
Ge.jsonID("all", Or);
const L$ = {
  map() {
    return this;
  },
  resolve(n) {
    return new Or(n);
  }
};
function ec(n, e, t, r, i, s = !1) {
  if (e.inlineContent)
    return Ee.create(n, t);
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let l = e.child(o);
    if (l.isAtom) {
      if (!s && $e.isSelectable(l))
        return $e.create(n, t - (i < 0 ? l.nodeSize : 0));
    } else {
      let a = ec(n, l, t + i, i < 0 ? l.childCount : 0, i, s);
      if (a)
        return a;
    }
    t += l.nodeSize * i;
  }
  return null;
}
function Xw(n, e, t) {
  let r = n.steps.length - 1;
  if (r < e)
    return;
  let i = n.steps[r];
  if (!(i instanceof Cn || i instanceof Yn))
    return;
  let s = n.mapping.maps[r], o;
  s.forEach((l, a, c, u) => {
    o == null && (o = u);
  }), n.setSelection(Ge.near(n.doc.resolve(o), t));
}
const Zw = 1, f0 = 2, Qw = 4;
class B$ extends uT {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Zw) & ~f0, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & Zw) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= f0, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return nt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & f0) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~f0, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let r = this.selection;
    return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || nt.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, r) {
    let i = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = t), r = r ?? t, !e)
        return this.deleteRange(t, r);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(t);
        s = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(t, r, i.text(e, s)), this.selection.empty || this.setSelection(Ge.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= Qw, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & Qw) > 0;
  }
}
function ex(n, e) {
  return !e || !n ? n : n.bind(e);
}
class ih {
  constructor(e, t, r) {
    this.name = e, this.init = ex(t.init, r), this.apply = ex(t.apply, r);
  }
}
const z$ = [
  new ih("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new ih("selection", {
    init(n, e) {
      return n.selection || Ge.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new ih("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, r) {
      return r.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new ih("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
class Zg {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = z$.slice(), t && t.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new ih(r.key, r.spec.state, r));
    });
  }
}
class Zl {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != t) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let l = this.config.plugins[o];
        if (l.spec.appendTransaction) {
          let a = i ? i[o].n : 0, c = i ? i[o].state : this, u = a < t.length && l.spec.appendTransaction.call(l, a ? t.slice(a) : t, c, r);
          if (u && r.filterTransaction(u, o)) {
            if (u.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < o ? { state: r, n: t.length } : { state: this, n: 0 });
            }
            t.push(u), r = r.applyInner(u), s = !0;
          }
          i && (i[o] = { state: r, n: t.length });
        }
      }
      if (!s)
        return { state: r, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new Zl(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let s = r[i];
      t[s.name] = s.apply(e, this[s.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new B$(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new Zg(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Zl(t);
    for (let i = 0; i < t.fields.length; i++)
      r[t.fields[i].name] = t.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new Zg(this.schema, e.plugins), r = t.fields, i = new Zl(t);
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name;
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], s = i.spec.state;
        s && s.toJSON && (t[r] = s.toJSON.call(i, this[i.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, r) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new Zg(e.schema, e.plugins), s = new Zl(i);
    return i.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = ro.fromJSON(e.schema, t.doc);
      else if (o.name == "selection")
        s.selection = Ge.fromJSON(s.doc, t.selection);
      else if (o.name == "storedMarks")
        t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let l in r) {
            let a = r[l], c = a.spec.state;
            if (a.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(t, l)) {
              s[o.name] = c.fromJSON.call(a, e, t[l], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
}
function fT(n, e, t) {
  for (let r in n) {
    let i = n[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = fT(i, e, {})), t[r] = i;
  }
  return t;
}
class Ut {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && fT(e.props, this, this.props), this.key = e.key ? e.key.key : dT("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Qg = /* @__PURE__ */ Object.create(null);
function dT(n) {
  return n in Qg ? n + "$" + ++Qg[n] : (Qg[n] = 0, n + "$");
}
class en {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = dT(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
class Ir {
  /**
  Create an input rule. The rule applies when the user typed
  something and the text directly in front of the cursor matches
  `match`, which should end with `$`.
  
  The `handler` can be a string, in which case the matched text, or
  the first matched group in the regexp, is replaced by that
  string.
  
  Or a it can be a function, which will be called with the match
  array produced by
  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  as well as the start and end of the matched range, and which can
  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
  rule's effect, or null to indicate the input was not handled.
  */
  constructor(e, t, r = {}) {
    this.match = e, this.match = e, this.handler = typeof t == "string" ? F$(t) : t, this.undoable = r.undoable !== !1, this.inCode = r.inCode || !1, this.inCodeMark = r.inCodeMark !== !1;
  }
}
function F$(n) {
  return function(e, t, r, i) {
    let s = n;
    if (t[1]) {
      let o = t[0].lastIndexOf(t[1]);
      s += t[0].slice(o + t[1].length), r += o;
      let l = r - i;
      l > 0 && (s = t[0].slice(o - l, o) + s, r = i);
    }
    return e.tr.insertText(s, r, i);
  };
}
const H$ = (n, e) => {
  let t = n.plugins;
  for (let r = 0; r < t.length; r++) {
    let i = t[r], s;
    if (i.spec.isInputRules && (s = i.getState(n))) {
      if (e) {
        let o = n.tr, l = s.transform;
        for (let a = l.steps.length - 1; a >= 0; a--)
          o.step(l.steps[a].invert(l.docs[a]));
        if (s.text) {
          let a = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, n.schema.text(s.text, a));
        } else
          o.delete(s.from, s.to);
        e(o);
      }
      return !0;
    }
  }
  return !1;
};
new Ir(/--$/, "—", { inCodeMark: !1 });
new Ir(/\.\.\.$/, "…", { inCodeMark: !1 });
new Ir(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“", { inCodeMark: !1 });
new Ir(/"$/, "”", { inCodeMark: !1 });
new Ir(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘", { inCodeMark: !1 });
new Ir(/'$/, "’", { inCodeMark: !1 });
function I3(n, e, t = null, r) {
  return new Ir(n, (i, s, o, l) => {
    let a = t instanceof Function ? t(s) : t, c = i.tr.delete(o, l), u = c.doc.resolve(o), h = u.blockRange(), f = h && O3(h, e, a);
    if (!f)
      return null;
    c.wrap(h, f);
    let d = c.doc.resolve(o - 1).nodeBefore;
    return d && d.type == e && h1(c.doc, o - 1) && (!r || r(s, d)) && c.join(o - 1), c;
  });
}
function D3(n, e, t = null) {
  return new Ir(n, (r, i, s, o) => {
    let l = r.doc.resolve(s), a = t instanceof Function ? t(i) : t;
    return l.node(-1).canReplaceWith(l.index(-1), l.indexAfter(-1), e) ? r.tr.delete(s, o).setBlockType(s, s, e, a) : null;
  });
}
var Dr = /* @__PURE__ */ ((n) => (n.docTypeError = "docTypeError", n.contextNotFound = "contextNotFound", n.timerNotFound = "timerNotFound", n.ctxCallOutOfScope = "ctxCallOutOfScope", n.createNodeInParserFail = "createNodeInParserFail", n.stackOverFlow = "stackOverFlow", n.parserMatchError = "parserMatchError", n.serializerMatchError = "serializerMatchError", n.getAtomFromSchemaFail = "getAtomFromSchemaFail", n.expectDomTypeError = "expectDomTypeError", n.callCommandBeforeEditorView = "callCommandBeforeEditorView", n.missingRootElement = "missingRootElement", n.missingNodeInSchema = "missingNodeInSchema", n.missingMarkInSchema = "missingMarkInSchema", n.ctxNotBind = "ctxNotBind", n.missingYjsDoc = "missingYjsDoc", n))(Dr || {});
class ei extends Error {
  constructor(e, t) {
    super(t), this.name = "MilkdownError", this.code = e;
  }
}
const $$ = (n, e) => typeof e == "function" ? "[Function]" : e, p1 = (n) => JSON.stringify(n, $$);
function V$(n) {
  return new ei(
    Dr.docTypeError,
    `Doc type error, unsupported type: ${p1(n)}`
  );
}
function q$(n) {
  return new ei(
    Dr.contextNotFound,
    `Context "${n}" not found, do you forget to inject it?`
  );
}
function W$(n) {
  return new ei(
    Dr.timerNotFound,
    `Timer "${n}" not found, do you forget to record it?`
  );
}
function m1() {
  return new ei(
    Dr.ctxCallOutOfScope,
    "Should not call a context out of the plugin."
  );
}
function j$(n, e, t) {
  const i = `Cannot create node for ${"name" in n ? n.name : n}`, s = (u) => {
    if (u == null) return "null";
    if (Array.isArray(u))
      return `[${u.map(s).join(", ")}]`;
    if (typeof u == "object")
      return "toJSON" in u && typeof u.toJSON == "function" ? JSON.stringify(u.toJSON()) : "spec" in u ? JSON.stringify(u.spec) : JSON.stringify(u);
    if (typeof u == "string" || typeof u == "number" || typeof u == "boolean")
      return JSON.stringify(u);
    if (typeof u == "function")
      return `[Function: ${u.name || "anonymous"}]`;
    try {
      return String(u);
    } catch {
      return "[Unserializable]";
    }
  }, o = ["[Description]", i], l = ["[Attributes]", e], a = [
    "[Content]",
    (t ?? []).map((u) => u ? typeof u == "object" && "type" in u ? `${u}` : s(u) : "null")
  ], c = [o, l, a].reduce(
    (u, [h, f]) => {
      const d = `${h}: ${s(f)}.`;
      return u.concat(d);
    },
    []
  );
  return new ei(
    Dr.createNodeInParserFail,
    c.join(`
`)
  );
}
function pT() {
  return new ei(
    Dr.stackOverFlow,
    "Stack over flow, cannot pop on an empty stack."
  );
}
function U$(n) {
  return new ei(
    Dr.parserMatchError,
    `Cannot match target parser for node: ${p1(n)}.`
  );
}
function K$(n) {
  return new ei(
    Dr.serializerMatchError,
    `Cannot match target serializer for node: ${p1(n)}.`
  );
}
function G$(n, e) {
  return new ei(
    Dr.getAtomFromSchemaFail,
    `Cannot get ${n}: ${e} from schema.`
  );
}
function Vi(n) {
  return new ei(
    Dr.expectDomTypeError,
    `Expect to be a dom, but get: ${p1(n)}.`
  );
}
function e2() {
  return new ei(
    Dr.callCommandBeforeEditorView,
    "You're trying to call a command before editor view initialized, make sure to get commandManager from ctx after editor view has been initialized"
  );
}
function Y$(n) {
  return new ei(
    Dr.missingNodeInSchema,
    `Missing node in schema, milkdown cannot find "${n}" in schema.`
  );
}
function J$(n) {
  return new ei(
    Dr.missingMarkInSchema,
    `Missing mark in schema, milkdown cannot find "${n}" in schema.`
  );
}
const hl = typeof navigator < "u" ? navigator : null, tx = typeof document < "u" ? document : null, xl = hl && hl.userAgent || "", Cy = /Edge\/(\d+)/.exec(xl), mT = /MSIE \d/.exec(xl), My = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(xl), g1 = !!(mT || My || Cy), X$ = mT ? document.documentMode : My ? +My[1] : Cy ? +Cy[1] : 0, gT = !g1 && /gecko\/(\d+)/i.test(xl), Z$ = gT && +(/Firefox\/(\d+)/.exec(xl) || [0, 0])[1], Ty = !g1 && /Chrome\/(\d+)/.exec(xl), Q$ = !!Ty, eV = Ty ? +Ty[1] : 0, yT = !g1 && !!hl && /Apple Computer/.test(hl.vendor), bT = yT && (/Mobile\/\w+/.test(xl) || !!hl && hl.maxTouchPoints > 2), tV = bT || (hl ? /Mac/.test(hl.platform) : !1), nV = /Android \d/.test(xl), vT = !!tx && "webkitFontSmoothing" in tx.documentElement.style, rV = vT ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
var d0 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  android: nV,
  chrome: Q$,
  chrome_version: eV,
  gecko: gT,
  gecko_version: Z$,
  ie: g1,
  ie_version: X$,
  ios: bT,
  mac: tV,
  safari: yT,
  webkit: vT,
  webkit_version: rV
});
function t2(n, e, t, r, i, s) {
  if (n.composing) return !1;
  const o = n.state, l = o.doc.resolve(e);
  if (l.parent.type.spec.code) return !1;
  const a = l.parent.textBetween(
    Math.max(0, l.parentOffset - 500),
    l.parentOffset,
    void 0,
    "￼"
  ) + r;
  for (let c of i) {
    const u = c, h = u.match.exec(a), f = h && h[0] && u.handler(o, h, e - (h[0].length - r.length), t);
    if (f)
      return u.undoable !== !1 && f.setMeta(s, { transform: f, from: e, to: t, text: r }), n.dispatch(f), !0;
  }
  return !1;
}
const iV = new en("MILKDOWN_CUSTOM_INPUTRULES");
function sV({ rules: n }) {
  const e = new Ut({
    key: iV,
    isInputRules: !0,
    state: {
      init() {
        return null;
      },
      apply(t, r) {
        const i = t.getMeta(this);
        return i || (t.selectionSet || t.docChanged ? null : r);
      }
    },
    props: {
      handleTextInput(t, r, i, s) {
        return t2(t, r, i, s, n, e);
      },
      handleDOMEvents: {
        compositionend: (t) => (setTimeout(() => {
          const { $cursor: r } = t.state.selection;
          r && t2(t, r.pos, r.pos, "", n, e);
        }), !1)
      },
      handleKeyDown(t, r) {
        if (r.key !== "Enter") return !1;
        const { $cursor: i } = t.state.selection;
        return i ? t2(t, i.pos, i.pos, `
`, n, e) : !1;
      }
    }
  });
  return e;
}
function hd(n, e, t = {}) {
  return new Ir(n, (r, i, s, o) => {
    var l, a, c, u;
    const { tr: h } = r, f = i.length;
    let d = i[f - 1], p = i[0], m = [], g = o;
    const b = {
      group: d,
      fullMatch: p,
      start: s,
      end: o
    }, w = (l = t.updateCaptured) == null ? void 0 : l.call(t, b);
    if (Object.assign(b, w), { group: d, fullMatch: p, start: s, end: o } = b, p === null || d?.trim() === "") return null;
    if (d) {
      const k = p.search(/\S/), C = s + p.indexOf(d), M = C + d.length;
      m = (a = h.storedMarks) != null ? a : [], M < o && h.delete(M, o), C > s && h.delete(s + k, C), g = s + k + d.length;
      const T = (c = t.getAttr) == null ? void 0 : c.call(t, i);
      h.addMark(s, g, e.create(T)), h.setStoredMarks(m), (u = t.beforeDispatch) == null || u.call(t, { match: i, start: s, end: o, tr: h });
    }
    return h;
  });
}
function oV(n, e, t = {}) {
  return new Ir(n, (r, i, s, o) => {
    var l, a, c;
    const { tr: u } = r;
    let h = i[1], f = i[0];
    const d = {
      group: h,
      fullMatch: f,
      start: s,
      end: o
    }, p = (l = t.updateCaptured) == null ? void 0 : l.call(t, d);
    if (Object.assign(d, p), { group: h, fullMatch: f, start: s, end: o } = d, f === null || !h || h.trim() === "") return null;
    const m = (a = t.getAttr) == null ? void 0 : a.call(t, i), g = e.createAndFill(m);
    return g && (u.replaceRangeWith(
      e.isBlock ? u.doc.resolve(s).before() : s,
      o,
      g
    ), (c = t.beforeDispatch) == null || c.call(t, {
      match: [f, h ?? ""],
      start: s,
      end: o,
      tr: u
    })), u;
  });
}
var lV = Object.defineProperty, aV = Object.defineProperties, cV = Object.getOwnPropertyDescriptors, nx = Object.getOwnPropertySymbols, uV = Object.prototype.hasOwnProperty, hV = Object.prototype.propertyIsEnumerable, rx = (n, e, t) => e in n ? lV(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, fV = (n, e) => {
  for (var t in e || (e = {}))
    uV.call(e, t) && rx(n, t, e[t]);
  if (nx)
    for (var t of nx(e))
      hV.call(e, t) && rx(n, t, e[t]);
  return n;
}, dV = (n, e) => aV(n, cV(e));
function ix(n = 0, e = 0, t = 0) {
  return Math.min(Math.max(n, e), t);
}
function y1(n, e, t) {
  const i = n.state.doc.content.size, s = ix(e, 0, i), o = ix(t, 0, i), l = n.coordsAtPos(s), a = n.coordsAtPos(o, -1), c = Math.min(l.top, a.top), u = Math.max(l.bottom, a.bottom), h = Math.min(l.left, a.left), f = Math.max(l.right, a.right), d = f - h, p = u - c, b = {
    top: c,
    bottom: u,
    left: h,
    right: f,
    width: d,
    height: p,
    x: h,
    y: c
  };
  return dV(fV({}, b), {
    toJSON: () => b
  });
}
function wT(n) {
  return Object.assign(Object.create(n), n).setTime(Date.now());
}
function pV(n, e) {
  return Array.isArray(n) && n.includes(e.type) || e.type === n;
}
function mV(n) {
  if (n.content.childCount === 1) {
    const e = n.content.firstChild;
    if (e?.type.name === "text" && e.marks.length === 0) return e;
    if (e?.type.name === "paragraph" && e.childCount === 1) {
      const t = e.firstChild;
      if (t?.type.name === "text" && t.marks.length === 0) return t;
    }
  }
  return !1;
}
function ys(n) {
  return (e) => {
    for (let t = e.depth; t > 0; t -= 1) {
      const r = e.node(t);
      if (n(r)) {
        const i = e.before(t), s = e.after(t);
        return {
          from: i,
          to: s,
          node: r
        };
      }
    }
  };
}
function gV(n, e) {
  return ys((t) => t.type === e)(n);
}
function yV(n, e) {
  const t = e.nodes[n];
  if (!t) throw G$("node", n);
  return t;
}
function N3(n) {
  return (e) => {
    for (let t = e.depth; t > 0; t--) {
      const r = e.node(t);
      if (n(r))
        return {
          pos: t > 0 ? e.before(t) : 0,
          start: e.start(t),
          depth: t,
          node: r
        };
    }
  };
}
function bV(n) {
  return (e) => N3(n)(e.$from);
}
function vV(n, e) {
  if (!(n instanceof $e)) return;
  const { node: t, $from: r } = n;
  if (pV(e, t))
    return {
      node: t,
      pos: r.pos,
      start: r.start(r.depth),
      depth: r.depth
    };
}
const xT = (n, e) => {
  const { selection: t, doc: r } = n;
  if (t instanceof $e)
    return {
      hasNode: t.node.type === e,
      pos: t.from,
      target: t.node
    };
  const { from: i, to: s } = t;
  let o = !1, l = -1, a = null;
  return r.nodesBetween(i, s, (c, u) => a ? !1 : c.type === e ? (o = !0, l = u, a = c, !1) : !0), {
    hasNode: o,
    pos: l,
    target: a
  };
};
class kT {
  constructor() {
    this.sliceMap = /* @__PURE__ */ new Map(), this.get = (e) => {
      const t = typeof e == "string" ? [...this.sliceMap.values()].find((r) => r.type.name === e) : this.sliceMap.get(e.id);
      if (!t) {
        const r = typeof e == "string" ? e : e.name;
        throw q$(r);
      }
      return t;
    }, this.remove = (e) => {
      const t = typeof e == "string" ? [...this.sliceMap.values()].find((r) => r.type.name === e) : this.sliceMap.get(e.id);
      t && this.sliceMap.delete(t.type.id);
    }, this.has = (e) => typeof e == "string" ? [...this.sliceMap.values()].some((t) => t.type.name === e) : this.sliceMap.has(e.id);
  }
}
class wV {
  /// @internal
  constructor(e, t, r) {
    this.#t = [], this.#r = () => {
      this.#t.forEach((i) => i(this.#e));
    }, this.set = (i) => {
      this.#e = i, this.#r();
    }, this.get = () => this.#e, this.update = (i) => {
      this.#e = i(this.#e), this.#r();
    }, this.type = r, this.#e = t, e.set(r.id, this);
  }
  #t;
  /// @internal
  #e;
  #r;
  /// Add a watcher for changes in the slice.
  /// Returns a function to remove the watcher.
  on(e) {
    return this.#t.push(e), () => {
      this.#t = this.#t.filter((t) => t !== e);
    };
  }
  /// Add a one-time watcher for changes in the slice.
  /// The watcher will be removed after it is called.
  /// Returns a function to remove the watcher.
  once(e) {
    const t = this.on((r) => {
      e(r), t();
    });
    return t;
  }
  /// Remove a watcher.
  off(e) {
    this.#t = this.#t.filter((t) => t !== e);
  }
  /// Remove all watchers.
  offAll() {
    this.#t = [];
  }
}
class xV {
  /// Create a slice type with a default value and a name.
  /// The name should be unique in the container.
  constructor(e, t) {
    this.id = Symbol(`Context-${t}`), this.name = t, this._defaultValue = e, this._typeInfo = () => {
      throw m1();
    };
  }
  /// Create a slice with a container.
  /// You can also pass a value to override the default value.
  create(e, t = this._defaultValue) {
    return new wV(e, t, this);
  }
}
const at = (n, e) => new xV(n, e);
class kV {
  /// Create an inspector with container, clock and metadata.
  constructor(e, t, r) {
    this.#n = /* @__PURE__ */ new Set(), this.#a = /* @__PURE__ */ new Set(), this.#i = /* @__PURE__ */ new Map(), this.#s = /* @__PURE__ */ new Map(), this.read = () => ({
      metadata: this.#t,
      injectedSlices: [...this.#n].map((i) => ({
        name: typeof i == "string" ? i : i.name,
        value: this.#o(i)
      })),
      consumedSlices: [...this.#a].map((i) => ({
        name: typeof i == "string" ? i : i.name,
        value: this.#o(i)
      })),
      recordedTimers: [...this.#i].map(
        ([i, { duration: s }]) => ({
          name: i.name,
          duration: s,
          status: this.#l(i)
        })
      ),
      waitTimers: [...this.#s].map(([i, { duration: s }]) => ({
        name: i.name,
        duration: s,
        status: this.#l(i)
      }))
    }), this.onRecord = (i) => {
      this.#i.set(i, { start: Date.now(), duration: 0 });
    }, this.onClear = (i) => {
      this.#i.delete(i);
    }, this.onDone = (i) => {
      const s = this.#i.get(i);
      s && (s.duration = Date.now() - s.start);
    }, this.onWait = (i, s) => {
      const o = Date.now();
      s.finally(() => {
        this.#s.set(i, { duration: Date.now() - o });
      }).catch(console.error);
    }, this.onInject = (i) => {
      this.#n.add(i);
    }, this.onRemove = (i) => {
      this.#n.delete(i);
    }, this.onUse = (i) => {
      this.#a.add(i);
    }, this.#o = (i) => this.#e.get(i).get(), this.#l = (i) => this.#r.get(i).status, this.#e = e, this.#r = t, this.#t = r;
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  #n;
  #a;
  #i;
  #s;
  #o;
  #l;
}
class R3 {
  /// Create a ctx object with container and clock.
  constructor(e, t, r) {
    this.produce = (i) => i && Object.keys(i).length ? new R3(this.#t, this.#e, { ...i }) : this, this.inject = (i, s) => {
      const o = i.create(this.#t.sliceMap);
      return s != null && o.set(s), this.#n?.onInject(i), this;
    }, this.remove = (i) => (this.#t.remove(i), this.#n?.onRemove(i), this), this.record = (i) => (i.create(this.#e.store), this.#n?.onRecord(i), this), this.clearTimer = (i) => (this.#e.remove(i), this.#n?.onClear(i), this), this.isInjected = (i) => this.#t.has(i), this.isRecorded = (i) => this.#e.has(i), this.use = (i) => (this.#n?.onUse(i), this.#t.get(i)), this.get = (i) => this.use(i).get(), this.set = (i, s) => this.use(i).set(s), this.update = (i, s) => this.use(i).update(s), this.timer = (i) => this.#e.get(i), this.done = (i) => {
      this.timer(i).done(), this.#n?.onDone(i);
    }, this.wait = (i) => {
      const s = this.timer(i).start();
      return this.#n?.onWait(i, s), s;
    }, this.waitTimers = async (i) => {
      await Promise.all(this.get(i).map((s) => this.wait(s)));
    }, this.#t = e, this.#e = t, this.#r = r, r && (this.#n = new kV(e, t, r));
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  /// @internal
  #n;
  /// Get metadata of the ctx.
  get meta() {
    return this.#r;
  }
  /// Get the inspector of the ctx.
  get inspector() {
    return this.#n;
  }
}
class SV {
  constructor() {
    this.store = /* @__PURE__ */ new Map(), this.get = (e) => {
      const t = this.store.get(e.id);
      if (!t) throw W$(e.name);
      return t;
    }, this.remove = (e) => {
      this.store.delete(e.id);
    }, this.has = (e) => this.store.has(e.id);
  }
}
class CV {
  /// @internal
  constructor(e, t) {
    this.#t = null, this.#e = null, this.#n = "pending", this.start = () => (this.#t ??= new Promise((r, i) => {
      this.#e = (s) => {
        s instanceof CustomEvent && s.detail.id === this.#r && (this.#n = "resolved", this.#a(), s.stopImmediatePropagation(), r());
      }, this.#i(() => {
        this.#n === "pending" && (this.#n = "rejected"), this.#a(), i(new Error(`Timing ${this.type.name} timeout.`));
      }), this.#n = "pending", addEventListener(this.type.name, this.#e);
    }), this.#t), this.done = () => {
      const r = new CustomEvent(this.type.name, {
        detail: { id: this.#r }
      });
      dispatchEvent(r);
    }, this.#a = () => {
      this.#e && removeEventListener(this.type.name, this.#e);
    }, this.#i = (r) => {
      setTimeout(() => {
        r();
      }, this.type.timeout);
    }, this.#r = Symbol(t.name), this.type = t, e.set(t.id, this);
  }
  #t;
  #e;
  /// @internal
  #r;
  #n;
  /// The status of the timer.
  /// Can be `pending`, `resolved` or `rejected`.
  get status() {
    return this.#n;
  }
  #a;
  #i;
}
class MV {
  /// Create a timer type with a name and a timeout.
  /// The name should be unique in the clock.
  constructor(e, t = 3e3) {
    this.create = (r) => new CV(r, this), this.id = Symbol(`Timer-${e}`), this.name = e, this.timeout = t;
  }
}
const xo = (n, e = 3e3) => new MV(n, e), TV = {};
function P3(n, e) {
  const t = TV, r = typeof t.includeImageAlt == "boolean" ? t.includeImageAlt : !0, i = typeof t.includeHtml == "boolean" ? t.includeHtml : !0;
  return ST(n, r, i);
}
function ST(n, e, t) {
  if (AV(n)) {
    if ("value" in n)
      return n.type === "html" && !t ? "" : n.value;
    if (e && "alt" in n && n.alt)
      return n.alt;
    if ("children" in n)
      return sx(n.children, e, t);
  }
  return Array.isArray(n) ? sx(n, e, t) : "";
}
function sx(n, e, t) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; )
    r[i] = ST(n[i], e, t);
  return r.join("");
}
function AV(n) {
  return !!(n && typeof n == "object");
}
const ox = document.createElement("i");
function _3(n) {
  const e = "&" + n + ";";
  ox.innerHTML = e;
  const t = ox.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    t.charCodeAt(t.length - 1) === 59 && n !== "semi" || t === e ? !1 : t
  );
}
function Jr(n, e, t, r) {
  const i = n.length;
  let s = 0, o;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, t = t > 0 ? t : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(e, t), n.splice(...o);
  else
    for (t && n.splice(e, t); s < r.length; )
      o = r.slice(s, s + 1e4), o.unshift(e, 0), n.splice(...o), s += 1e4, e += 1e4;
}
function oi(n, e) {
  return n.length > 0 ? (Jr(n, n.length, 0, e), n) : e;
}
const lx = {}.hasOwnProperty;
function CT(n) {
  const e = {};
  let t = -1;
  for (; ++t < n.length; )
    OV(e, n[t]);
  return e;
}
function OV(n, e) {
  let t;
  for (t in e) {
    const i = (lx.call(n, t) ? n[t] : void 0) || (n[t] = {}), s = e[t];
    let o;
    if (s)
      for (o in s) {
        lx.call(i, o) || (i[o] = []);
        const l = s[o];
        EV(
          // @ts-expect-error Looks like a list.
          i[o],
          Array.isArray(l) ? l : l ? [l] : []
        );
      }
  }
}
function EV(n, e) {
  let t = -1;
  const r = [];
  for (; ++t < e.length; )
    (e[t].add === "after" ? n : r).push(e[t]);
  Jr(n, 0, 0, r);
}
function MT(n, e) {
  const t = Number.parseInt(n, e);
  return (
    // C0 except for HT, LF, FF, CR, space.
    t < 9 || t === 11 || t > 13 && t < 32 || // Control character (DEL) of C0, and C1 controls.
    t > 126 && t < 160 || // Lone high surrogates and low surrogates.
    t > 55295 && t < 57344 || // Noncharacters.
    t > 64975 && t < 65008 || /* eslint-disable no-bitwise */
    (t & 65535) === 65535 || (t & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    t > 1114111 ? "�" : String.fromCodePoint(t)
  );
}
function Ni(n) {
  return n.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const lr = kl(/[A-Za-z]/), Tr = kl(/[\dA-Za-z]/), IV = kl(/[#-'*+\--9=?A-Z^-~]/);
function dm(n) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    n !== null && (n < 32 || n === 127)
  );
}
const Ay = kl(/\d/), DV = kl(/[\dA-Fa-f]/), NV = kl(/[!-/:-@[-`{-~]/);
function Ne(n) {
  return n !== null && n < -2;
}
function It(n) {
  return n !== null && (n < 0 || n === 32);
}
function lt(n) {
  return n === -2 || n === -1 || n === 32;
}
const b1 = kl(new RegExp("\\p{P}|\\p{S}", "u")), Ma = kl(/\s/);
function kl(n) {
  return e;
  function e(t) {
    return t !== null && t > -1 && n.test(String.fromCharCode(t));
  }
}
function it(n, e, t, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return o;
  function o(a) {
    return lt(a) ? (n.enter(t), l(a)) : e(a);
  }
  function l(a) {
    return lt(a) && s++ < i ? (n.consume(a), l) : (n.exit(t), e(a));
  }
}
const RV = {
  tokenize: PV
};
function PV(n) {
  const e = n.attempt(this.parser.constructs.contentInitial, r, i);
  let t;
  return e;
  function r(l) {
    if (l === null) {
      n.consume(l);
      return;
    }
    return n.enter("lineEnding"), n.consume(l), n.exit("lineEnding"), it(n, e, "linePrefix");
  }
  function i(l) {
    return n.enter("paragraph"), s(l);
  }
  function s(l) {
    const a = n.enter("chunkText", {
      contentType: "text",
      previous: t
    });
    return t && (t.next = a), t = a, o(l);
  }
  function o(l) {
    if (l === null) {
      n.exit("chunkText"), n.exit("paragraph"), n.consume(l);
      return;
    }
    return Ne(l) ? (n.consume(l), n.exit("chunkText"), s) : (n.consume(l), o);
  }
}
const _V = {
  tokenize: LV
}, ax = {
  tokenize: BV
};
function LV(n) {
  const e = this, t = [];
  let r = 0, i, s, o;
  return l;
  function l(k) {
    if (r < t.length) {
      const C = t[r];
      return e.containerState = C[1], n.attempt(C[0].continuation, a, c)(k);
    }
    return c(k);
  }
  function a(k) {
    if (r++, e.containerState._closeFlow) {
      e.containerState._closeFlow = void 0, i && w();
      const C = e.events.length;
      let M = C, T;
      for (; M--; )
        if (e.events[M][0] === "exit" && e.events[M][1].type === "chunkFlow") {
          T = e.events[M][1].end;
          break;
        }
      b(r);
      let N = C;
      for (; N < e.events.length; )
        e.events[N][1].end = {
          ...T
        }, N++;
      return Jr(e.events, M + 1, 0, e.events.slice(C)), e.events.length = N, c(k);
    }
    return l(k);
  }
  function c(k) {
    if (r === t.length) {
      if (!i)
        return f(k);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return p(k);
      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return e.containerState = {}, n.check(ax, u, h)(k);
  }
  function u(k) {
    return i && w(), b(r), f(k);
  }
  function h(k) {
    return e.parser.lazy[e.now().line] = r !== t.length, o = e.now().offset, p(k);
  }
  function f(k) {
    return e.containerState = {}, n.attempt(ax, d, p)(k);
  }
  function d(k) {
    return r++, t.push([e.currentConstruct, e.containerState]), f(k);
  }
  function p(k) {
    if (k === null) {
      i && w(), b(0), n.consume(k);
      return;
    }
    return i = i || e.parser.flow(e.now()), n.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: s
    }), m(k);
  }
  function m(k) {
    if (k === null) {
      g(n.exit("chunkFlow"), !0), b(0), n.consume(k);
      return;
    }
    return Ne(k) ? (n.consume(k), g(n.exit("chunkFlow")), r = 0, e.interrupt = void 0, l) : (n.consume(k), m);
  }
  function g(k, C) {
    const M = e.sliceStream(k);
    if (C && M.push(null), k.previous = s, s && (s.next = k), s = k, i.defineSkip(k.start), i.write(M), e.parser.lazy[k.start.line]) {
      let T = i.events.length;
      for (; T--; )
        if (
          // The token starts before the line ending…
          i.events[T][1].start.offset < o && // …and either is not ended yet…
          (!i.events[T][1].end || // …or ends after it.
          i.events[T][1].end.offset > o)
        )
          return;
      const N = e.events.length;
      let B = N, $, R;
      for (; B--; )
        if (e.events[B][0] === "exit" && e.events[B][1].type === "chunkFlow") {
          if ($) {
            R = e.events[B][1].end;
            break;
          }
          $ = !0;
        }
      for (b(r), T = N; T < e.events.length; )
        e.events[T][1].end = {
          ...R
        }, T++;
      Jr(e.events, B + 1, 0, e.events.slice(N)), e.events.length = T;
    }
  }
  function b(k) {
    let C = t.length;
    for (; C-- > k; ) {
      const M = t[C];
      e.containerState = M[1], M[0].exit.call(e, n);
    }
    t.length = k;
  }
  function w() {
    i.write([null]), s = void 0, i = void 0, e.containerState._closeFlow = void 0;
  }
}
function BV(n, e, t) {
  return it(n, n.attempt(this.parser.constructs.document, e, t), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function zc(n) {
  if (n === null || It(n) || Ma(n))
    return 1;
  if (b1(n))
    return 2;
}
function v1(n, e, t) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; ) {
    const s = n[i].resolveAll;
    s && !r.includes(s) && (e = s(e, t), r.push(s));
  }
  return e;
}
const Oy = {
  name: "attention",
  resolveAll: zV,
  tokenize: FV
};
function zV(n, e) {
  let t = -1, r, i, s, o, l, a, c, u;
  for (; ++t < n.length; )
    if (n[t][0] === "enter" && n[t][1].type === "attentionSequence" && n[t][1]._close) {
      for (r = t; r--; )
        if (n[r][0] === "exit" && n[r][1].type === "attentionSequence" && n[r][1]._open && // If the markers are the same:
        e.sliceSerialize(n[r][1]).charCodeAt(0) === e.sliceSerialize(n[t][1]).charCodeAt(0)) {
          if ((n[r][1]._close || n[t][1]._open) && (n[t][1].end.offset - n[t][1].start.offset) % 3 && !((n[r][1].end.offset - n[r][1].start.offset + n[t][1].end.offset - n[t][1].start.offset) % 3))
            continue;
          a = n[r][1].end.offset - n[r][1].start.offset > 1 && n[t][1].end.offset - n[t][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...n[r][1].end
          }, f = {
            ...n[t][1].start
          };
          cx(h, -a), cx(f, a), o = {
            type: a > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...n[r][1].end
            }
          }, l = {
            type: a > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...n[t][1].start
            },
            end: f
          }, s = {
            type: a > 1 ? "strongText" : "emphasisText",
            start: {
              ...n[r][1].end
            },
            end: {
              ...n[t][1].start
            }
          }, i = {
            type: a > 1 ? "strong" : "emphasis",
            start: {
              ...o.start
            },
            end: {
              ...l.end
            }
          }, n[r][1].end = {
            ...o.start
          }, n[t][1].start = {
            ...l.end
          }, c = [], n[r][1].end.offset - n[r][1].start.offset && (c = oi(c, [["enter", n[r][1], e], ["exit", n[r][1], e]])), c = oi(c, [["enter", i, e], ["enter", o, e], ["exit", o, e], ["enter", s, e]]), c = oi(c, v1(e.parser.constructs.insideSpan.null, n.slice(r + 1, t), e)), c = oi(c, [["exit", s, e], ["enter", l, e], ["exit", l, e], ["exit", i, e]]), n[t][1].end.offset - n[t][1].start.offset ? (u = 2, c = oi(c, [["enter", n[t][1], e], ["exit", n[t][1], e]])) : u = 0, Jr(n, r - 1, t - r + 3, c), t = r + c.length - u - 2;
          break;
        }
    }
  for (t = -1; ++t < n.length; )
    n[t][1].type === "attentionSequence" && (n[t][1].type = "data");
  return n;
}
function FV(n, e) {
  const t = this.parser.constructs.attentionMarkers.null, r = this.previous, i = zc(r);
  let s;
  return o;
  function o(a) {
    return s = a, n.enter("attentionSequence"), l(a);
  }
  function l(a) {
    if (a === s)
      return n.consume(a), l;
    const c = n.exit("attentionSequence"), u = zc(a), h = !u || u === 2 && i || t.includes(a), f = !i || i === 2 && u || t.includes(r);
    return c._open = !!(s === 42 ? h : h && (i || !f)), c._close = !!(s === 42 ? f : f && (u || !h)), e(a);
  }
}
function cx(n, e) {
  n.column += e, n.offset += e, n._bufferIndex += e;
}
const HV = {
  name: "autolink",
  tokenize: $V
};
function $V(n, e, t) {
  let r = 0;
  return i;
  function i(d) {
    return n.enter("autolink"), n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.enter("autolinkProtocol"), s;
  }
  function s(d) {
    return lr(d) ? (n.consume(d), o) : d === 64 ? t(d) : c(d);
  }
  function o(d) {
    return d === 43 || d === 45 || d === 46 || Tr(d) ? (r = 1, l(d)) : c(d);
  }
  function l(d) {
    return d === 58 ? (n.consume(d), r = 0, a) : (d === 43 || d === 45 || d === 46 || Tr(d)) && r++ < 32 ? (n.consume(d), l) : (r = 0, c(d));
  }
  function a(d) {
    return d === 62 ? (n.exit("autolinkProtocol"), n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.exit("autolink"), e) : d === null || d === 32 || d === 60 || dm(d) ? t(d) : (n.consume(d), a);
  }
  function c(d) {
    return d === 64 ? (n.consume(d), u) : IV(d) ? (n.consume(d), c) : t(d);
  }
  function u(d) {
    return Tr(d) ? h(d) : t(d);
  }
  function h(d) {
    return d === 46 ? (n.consume(d), r = 0, u) : d === 62 ? (n.exit("autolinkProtocol").type = "autolinkEmail", n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.exit("autolink"), e) : f(d);
  }
  function f(d) {
    if ((d === 45 || Tr(d)) && r++ < 63) {
      const p = d === 45 ? f : h;
      return n.consume(d), p;
    }
    return t(d);
  }
}
const fd = {
  partial: !0,
  tokenize: VV
};
function VV(n, e, t) {
  return r;
  function r(s) {
    return lt(s) ? it(n, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || Ne(s) ? e(s) : t(s);
  }
}
const TT = {
  continuation: {
    tokenize: WV
  },
  exit: jV,
  name: "blockQuote",
  tokenize: qV
};
function qV(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const l = r.containerState;
      return l.open || (n.enter("blockQuote", {
        _container: !0
      }), l.open = !0), n.enter("blockQuotePrefix"), n.enter("blockQuoteMarker"), n.consume(o), n.exit("blockQuoteMarker"), s;
    }
    return t(o);
  }
  function s(o) {
    return lt(o) ? (n.enter("blockQuotePrefixWhitespace"), n.consume(o), n.exit("blockQuotePrefixWhitespace"), n.exit("blockQuotePrefix"), e) : (n.exit("blockQuotePrefix"), e(o));
  }
}
function WV(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return lt(o) ? it(n, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : s(o);
  }
  function s(o) {
    return n.attempt(TT, e, t)(o);
  }
}
function jV(n) {
  n.exit("blockQuote");
}
const AT = {
  name: "characterEscape",
  tokenize: UV
};
function UV(n, e, t) {
  return r;
  function r(s) {
    return n.enter("characterEscape"), n.enter("escapeMarker"), n.consume(s), n.exit("escapeMarker"), i;
  }
  function i(s) {
    return NV(s) ? (n.enter("characterEscapeValue"), n.consume(s), n.exit("characterEscapeValue"), n.exit("characterEscape"), e) : t(s);
  }
}
const OT = {
  name: "characterReference",
  tokenize: KV
};
function KV(n, e, t) {
  const r = this;
  let i = 0, s, o;
  return l;
  function l(h) {
    return n.enter("characterReference"), n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), a;
  }
  function a(h) {
    return h === 35 ? (n.enter("characterReferenceMarkerNumeric"), n.consume(h), n.exit("characterReferenceMarkerNumeric"), c) : (n.enter("characterReferenceValue"), s = 31, o = Tr, u(h));
  }
  function c(h) {
    return h === 88 || h === 120 ? (n.enter("characterReferenceMarkerHexadecimal"), n.consume(h), n.exit("characterReferenceMarkerHexadecimal"), n.enter("characterReferenceValue"), s = 6, o = DV, u) : (n.enter("characterReferenceValue"), s = 7, o = Ay, u(h));
  }
  function u(h) {
    if (h === 59 && i) {
      const f = n.exit("characterReferenceValue");
      return o === Tr && !_3(r.sliceSerialize(f)) ? t(h) : (n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), n.exit("characterReference"), e);
    }
    return o(h) && i++ < s ? (n.consume(h), u) : t(h);
  }
}
const ux = {
  partial: !0,
  tokenize: YV
}, hx = {
  concrete: !0,
  name: "codeFenced",
  tokenize: GV
};
function GV(n, e, t) {
  const r = this, i = {
    partial: !0,
    tokenize: M
  };
  let s = 0, o = 0, l;
  return a;
  function a(T) {
    return c(T);
  }
  function c(T) {
    const N = r.events[r.events.length - 1];
    return s = N && N[1].type === "linePrefix" ? N[2].sliceSerialize(N[1], !0).length : 0, l = T, n.enter("codeFenced"), n.enter("codeFencedFence"), n.enter("codeFencedFenceSequence"), u(T);
  }
  function u(T) {
    return T === l ? (o++, n.consume(T), u) : o < 3 ? t(T) : (n.exit("codeFencedFenceSequence"), lt(T) ? it(n, h, "whitespace")(T) : h(T));
  }
  function h(T) {
    return T === null || Ne(T) ? (n.exit("codeFencedFence"), r.interrupt ? e(T) : n.check(ux, m, C)(T)) : (n.enter("codeFencedFenceInfo"), n.enter("chunkString", {
      contentType: "string"
    }), f(T));
  }
  function f(T) {
    return T === null || Ne(T) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), h(T)) : lt(T) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), it(n, d, "whitespace")(T)) : T === 96 && T === l ? t(T) : (n.consume(T), f);
  }
  function d(T) {
    return T === null || Ne(T) ? h(T) : (n.enter("codeFencedFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), p(T));
  }
  function p(T) {
    return T === null || Ne(T) ? (n.exit("chunkString"), n.exit("codeFencedFenceMeta"), h(T)) : T === 96 && T === l ? t(T) : (n.consume(T), p);
  }
  function m(T) {
    return n.attempt(i, C, g)(T);
  }
  function g(T) {
    return n.enter("lineEnding"), n.consume(T), n.exit("lineEnding"), b;
  }
  function b(T) {
    return s > 0 && lt(T) ? it(n, w, "linePrefix", s + 1)(T) : w(T);
  }
  function w(T) {
    return T === null || Ne(T) ? n.check(ux, m, C)(T) : (n.enter("codeFlowValue"), k(T));
  }
  function k(T) {
    return T === null || Ne(T) ? (n.exit("codeFlowValue"), w(T)) : (n.consume(T), k);
  }
  function C(T) {
    return n.exit("codeFenced"), e(T);
  }
  function M(T, N, B) {
    let $ = 0;
    return R;
    function R(he) {
      return T.enter("lineEnding"), T.consume(he), T.exit("lineEnding"), V;
    }
    function V(he) {
      return T.enter("codeFencedFence"), lt(he) ? it(T, z, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(he) : z(he);
    }
    function z(he) {
      return he === l ? (T.enter("codeFencedFenceSequence"), ue(he)) : B(he);
    }
    function ue(he) {
      return he === l ? ($++, T.consume(he), ue) : $ >= o ? (T.exit("codeFencedFenceSequence"), lt(he) ? it(T, ie, "whitespace")(he) : ie(he)) : B(he);
    }
    function ie(he) {
      return he === null || Ne(he) ? (T.exit("codeFencedFence"), N(he)) : B(he);
    }
  }
}
function YV(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? t(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
const n2 = {
  name: "codeIndented",
  tokenize: XV
}, JV = {
  partial: !0,
  tokenize: ZV
};
function XV(n, e, t) {
  const r = this;
  return i;
  function i(c) {
    return n.enter("codeIndented"), it(n, s, "linePrefix", 5)(c);
  }
  function s(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : t(c);
  }
  function o(c) {
    return c === null ? a(c) : Ne(c) ? n.attempt(JV, o, a)(c) : (n.enter("codeFlowValue"), l(c));
  }
  function l(c) {
    return c === null || Ne(c) ? (n.exit("codeFlowValue"), o(c)) : (n.consume(c), l);
  }
  function a(c) {
    return n.exit("codeIndented"), e(c);
  }
}
function ZV(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? t(o) : Ne(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), i) : it(n, s, "linePrefix", 5)(o);
  }
  function s(o) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? e(o) : Ne(o) ? i(o) : t(o);
  }
}
const QV = {
  name: "codeText",
  previous: tq,
  resolve: eq,
  tokenize: nq
};
function eq(n) {
  let e = n.length - 4, t = 3, r, i;
  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {
    for (r = t; ++r < e; )
      if (n[r][1].type === "codeTextData") {
        n[t][1].type = "codeTextPadding", n[e][1].type = "codeTextPadding", t += 2, e -= 2;
        break;
      }
  }
  for (r = t - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "codeTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function tq(n) {
  return n !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function nq(n, e, t) {
  let r = 0, i, s;
  return o;
  function o(h) {
    return n.enter("codeText"), n.enter("codeTextSequence"), l(h);
  }
  function l(h) {
    return h === 96 ? (n.consume(h), r++, l) : (n.exit("codeTextSequence"), a(h));
  }
  function a(h) {
    return h === null ? t(h) : h === 32 ? (n.enter("space"), n.consume(h), n.exit("space"), a) : h === 96 ? (s = n.enter("codeTextSequence"), i = 0, u(h)) : Ne(h) ? (n.enter("lineEnding"), n.consume(h), n.exit("lineEnding"), a) : (n.enter("codeTextData"), c(h));
  }
  function c(h) {
    return h === null || h === 32 || h === 96 || Ne(h) ? (n.exit("codeTextData"), a(h)) : (n.consume(h), c);
  }
  function u(h) {
    return h === 96 ? (n.consume(h), i++, u) : i === r ? (n.exit("codeTextSequence"), n.exit("codeText"), e(h)) : (s.type = "codeTextData", c(h));
  }
}
class rq {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(e) {
    this.left = e ? [...e] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(e) {
    if (e < 0 || e >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(e, t) {
    const r = t ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(e, r) : e > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(e, t, r) {
    const i = t || 0;
    this.setCursor(Math.trunc(e));
    const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && zu(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(e) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(e) {
    this.setCursor(Number.POSITIVE_INFINITY), zu(this.left, e);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(e) {
    this.setCursor(0), this.right.push(e);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(e) {
    this.setCursor(0), zu(this.right, e.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(e) {
    if (!(e === this.left.length || e > this.left.length && this.right.length === 0 || e < 0 && this.left.length === 0))
      if (e < this.left.length) {
        const t = this.left.splice(e, Number.POSITIVE_INFINITY);
        zu(this.right, t.reverse());
      } else {
        const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
        zu(this.left, t.reverse());
      }
  }
}
function zu(n, e) {
  let t = 0;
  if (e.length < 1e4)
    n.push(...e);
  else
    for (; t < e.length; )
      n.push(...e.slice(t, t + 1e4)), t += 1e4;
}
function ET(n) {
  const e = {};
  let t = -1, r, i, s, o, l, a, c;
  const u = new rq(n);
  for (; ++t < u.length; ) {
    for (; t in e; )
      t = e[t];
    if (r = u.get(t), t && r[1].type === "chunkFlow" && u.get(t - 1)[1].type === "listItemPrefix" && (a = r[1]._tokenizer.events, s = 0, s < a.length && a[s][1].type === "lineEndingBlank" && (s += 2), s < a.length && a[s][1].type === "content"))
      for (; ++s < a.length && a[s][1].type !== "content"; )
        a[s][1].type === "chunkText" && (a[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(e, iq(u, t)), t = e[t], c = !0);
    else if (r[1]._container) {
      for (s = t, i = void 0; s--; )
        if (o = u.get(s), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank")
          o[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = s);
        else if (!(o[1].type === "linePrefix" || o[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...u.get(i)[1].start
      }, l = u.slice(i, t), l.unshift(r), u.splice(i, t - i + 1, l));
    }
  }
  return Jr(n, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function iq(n, e) {
  const t = n.get(e)[1], r = n.get(e)[2];
  let i = e - 1;
  const s = [];
  let o = t._tokenizer;
  o || (o = r.parser[t.contentType](t.start), t._contentTypeTextTrailing && (o._contentTypeTextTrailing = !0));
  const l = o.events, a = [], c = {};
  let u, h, f = -1, d = t, p = 0, m = 0;
  const g = [m];
  for (; d; ) {
    for (; n.get(++i)[1] !== d; )
      ;
    s.push(i), d._tokenizer || (u = r.sliceStream(d), d.next || u.push(null), h && o.defineSkip(d.start), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = d, d = d.next;
  }
  for (d = t; ++f < l.length; )
    // Find a void token that includes a break.
    l[f][0] === "exit" && l[f - 1][0] === "enter" && l[f][1].type === l[f - 1][1].type && l[f][1].start.line !== l[f][1].end.line && (m = f + 1, g.push(m), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (o.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : g.pop(), f = g.length; f--; ) {
    const b = l.slice(g[f], g[f + 1]), w = s.pop();
    a.push([w, w + b.length - 1]), n.splice(w, 2, b);
  }
  for (a.reverse(), f = -1; ++f < a.length; )
    c[p + a[f][0]] = p + a[f][1], p += a[f][1] - a[f][0] - 1;
  return c;
}
const sq = {
  resolve: lq,
  tokenize: aq
}, oq = {
  partial: !0,
  tokenize: cq
};
function lq(n) {
  return ET(n), n;
}
function aq(n, e) {
  let t;
  return r;
  function r(l) {
    return n.enter("content"), t = n.enter("chunkContent", {
      contentType: "content"
    }), i(l);
  }
  function i(l) {
    return l === null ? s(l) : Ne(l) ? n.check(oq, o, s)(l) : (n.consume(l), i);
  }
  function s(l) {
    return n.exit("chunkContent"), n.exit("content"), e(l);
  }
  function o(l) {
    return n.consume(l), n.exit("chunkContent"), t.next = n.enter("chunkContent", {
      contentType: "content",
      previous: t
    }), t = t.next, i;
  }
}
function cq(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return n.exit("chunkContent"), n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), it(n, s, "linePrefix");
  }
  function s(o) {
    if (o === null || Ne(o))
      return t(o);
    const l = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? e(o) : n.interrupt(r.parser.constructs.flow, t, e)(o);
  }
}
function IT(n, e, t, r, i, s, o, l, a) {
  const c = a || Number.POSITIVE_INFINITY;
  let u = 0;
  return h;
  function h(b) {
    return b === 60 ? (n.enter(r), n.enter(i), n.enter(s), n.consume(b), n.exit(s), f) : b === null || b === 32 || b === 41 || dm(b) ? t(b) : (n.enter(r), n.enter(o), n.enter(l), n.enter("chunkString", {
      contentType: "string"
    }), m(b));
  }
  function f(b) {
    return b === 62 ? (n.enter(s), n.consume(b), n.exit(s), n.exit(i), n.exit(r), e) : (n.enter(l), n.enter("chunkString", {
      contentType: "string"
    }), d(b));
  }
  function d(b) {
    return b === 62 ? (n.exit("chunkString"), n.exit(l), f(b)) : b === null || b === 60 || Ne(b) ? t(b) : (n.consume(b), b === 92 ? p : d);
  }
  function p(b) {
    return b === 60 || b === 62 || b === 92 ? (n.consume(b), d) : d(b);
  }
  function m(b) {
    return !u && (b === null || b === 41 || It(b)) ? (n.exit("chunkString"), n.exit(l), n.exit(o), n.exit(r), e(b)) : u < c && b === 40 ? (n.consume(b), u++, m) : b === 41 ? (n.consume(b), u--, m) : b === null || b === 32 || b === 40 || dm(b) ? t(b) : (n.consume(b), b === 92 ? g : m);
  }
  function g(b) {
    return b === 40 || b === 41 || b === 92 ? (n.consume(b), m) : m(b);
  }
}
function DT(n, e, t, r, i, s) {
  const o = this;
  let l = 0, a;
  return c;
  function c(d) {
    return n.enter(r), n.enter(i), n.consume(d), n.exit(i), n.enter(s), u;
  }
  function u(d) {
    return l > 999 || d === null || d === 91 || d === 93 && !a || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !l && "_hiddenFootnoteSupport" in o.parser.constructs ? t(d) : d === 93 ? (n.exit(s), n.enter(i), n.consume(d), n.exit(i), n.exit(r), e) : Ne(d) ? (n.enter("lineEnding"), n.consume(d), n.exit("lineEnding"), u) : (n.enter("chunkString", {
      contentType: "string"
    }), h(d));
  }
  function h(d) {
    return d === null || d === 91 || d === 93 || Ne(d) || l++ > 999 ? (n.exit("chunkString"), u(d)) : (n.consume(d), a || (a = !lt(d)), d === 92 ? f : h);
  }
  function f(d) {
    return d === 91 || d === 92 || d === 93 ? (n.consume(d), l++, h) : h(d);
  }
}
function NT(n, e, t, r, i, s) {
  let o;
  return l;
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? (n.enter(r), n.enter(i), n.consume(f), n.exit(i), o = f === 40 ? 41 : f, a) : t(f);
  }
  function a(f) {
    return f === o ? (n.enter(i), n.consume(f), n.exit(i), n.exit(r), e) : (n.enter(s), c(f));
  }
  function c(f) {
    return f === o ? (n.exit(s), a(o)) : f === null ? t(f) : Ne(f) ? (n.enter("lineEnding"), n.consume(f), n.exit("lineEnding"), it(n, c, "linePrefix")) : (n.enter("chunkString", {
      contentType: "string"
    }), u(f));
  }
  function u(f) {
    return f === o || f === null || Ne(f) ? (n.exit("chunkString"), c(f)) : (n.consume(f), f === 92 ? h : u);
  }
  function h(f) {
    return f === o || f === 92 ? (n.consume(f), u) : u(f);
  }
}
function Wh(n, e) {
  let t;
  return r;
  function r(i) {
    return Ne(i) ? (n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), t = !0, r) : lt(i) ? it(n, r, t ? "linePrefix" : "lineSuffix")(i) : e(i);
  }
}
const uq = {
  name: "definition",
  tokenize: fq
}, hq = {
  partial: !0,
  tokenize: dq
};
function fq(n, e, t) {
  const r = this;
  let i;
  return s;
  function s(d) {
    return n.enter("definition"), o(d);
  }
  function o(d) {
    return DT.call(
      r,
      n,
      l,
      // Note: we don’t need to reset the way `markdown-rs` does.
      t,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function l(d) {
    return i = Ni(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), d === 58 ? (n.enter("definitionMarker"), n.consume(d), n.exit("definitionMarker"), a) : t(d);
  }
  function a(d) {
    return It(d) ? Wh(n, c)(d) : c(d);
  }
  function c(d) {
    return IT(
      n,
      u,
      // Note: we don’t need to reset the way `markdown-rs` does.
      t,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function u(d) {
    return n.attempt(hq, h, h)(d);
  }
  function h(d) {
    return lt(d) ? it(n, f, "whitespace")(d) : f(d);
  }
  function f(d) {
    return d === null || Ne(d) ? (n.exit("definition"), r.parser.defined.push(i), e(d)) : t(d);
  }
}
function dq(n, e, t) {
  return r;
  function r(l) {
    return It(l) ? Wh(n, i)(l) : t(l);
  }
  function i(l) {
    return NT(n, s, t, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(l);
  }
  function s(l) {
    return lt(l) ? it(n, o, "whitespace")(l) : o(l);
  }
  function o(l) {
    return l === null || Ne(l) ? e(l) : t(l);
  }
}
const pq = {
  name: "hardBreakEscape",
  tokenize: mq
};
function mq(n, e, t) {
  return r;
  function r(s) {
    return n.enter("hardBreakEscape"), n.consume(s), i;
  }
  function i(s) {
    return Ne(s) ? (n.exit("hardBreakEscape"), e(s)) : t(s);
  }
}
const gq = {
  name: "headingAtx",
  resolve: yq,
  tokenize: bq
};
function yq(n, e) {
  let t = n.length - 2, r = 3, i, s;
  return n[r][1].type === "whitespace" && (r += 2), t - 2 > r && n[t][1].type === "whitespace" && (t -= 2), n[t][1].type === "atxHeadingSequence" && (r === t - 1 || t - 4 > r && n[t - 2][1].type === "whitespace") && (t -= r + 1 === t ? 2 : 4), t > r && (i = {
    type: "atxHeadingText",
    start: n[r][1].start,
    end: n[t][1].end
  }, s = {
    type: "chunkText",
    start: n[r][1].start,
    end: n[t][1].end,
    contentType: "text"
  }, Jr(n, r, t - r + 1, [["enter", i, e], ["enter", s, e], ["exit", s, e], ["exit", i, e]])), n;
}
function bq(n, e, t) {
  let r = 0;
  return i;
  function i(u) {
    return n.enter("atxHeading"), s(u);
  }
  function s(u) {
    return n.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (n.consume(u), o) : u === null || It(u) ? (n.exit("atxHeadingSequence"), l(u)) : t(u);
  }
  function l(u) {
    return u === 35 ? (n.enter("atxHeadingSequence"), a(u)) : u === null || Ne(u) ? (n.exit("atxHeading"), e(u)) : lt(u) ? it(n, l, "whitespace")(u) : (n.enter("atxHeadingText"), c(u));
  }
  function a(u) {
    return u === 35 ? (n.consume(u), a) : (n.exit("atxHeadingSequence"), l(u));
  }
  function c(u) {
    return u === null || u === 35 || It(u) ? (n.exit("atxHeadingText"), l(u)) : (n.consume(u), c);
  }
}
const vq = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], fx = ["pre", "script", "style", "textarea"], wq = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: Sq,
  tokenize: Cq
}, xq = {
  partial: !0,
  tokenize: Tq
}, kq = {
  partial: !0,
  tokenize: Mq
};
function Sq(n) {
  let e = n.length;
  for (; e-- && !(n[e][0] === "enter" && n[e][1].type === "htmlFlow"); )
    ;
  return e > 1 && n[e - 2][1].type === "linePrefix" && (n[e][1].start = n[e - 2][1].start, n[e + 1][1].start = n[e - 2][1].start, n.splice(e - 2, 2)), n;
}
function Cq(n, e, t) {
  const r = this;
  let i, s, o, l, a;
  return c;
  function c(O) {
    return u(O);
  }
  function u(O) {
    return n.enter("htmlFlow"), n.enter("htmlFlowData"), n.consume(O), h;
  }
  function h(O) {
    return O === 33 ? (n.consume(O), f) : O === 47 ? (n.consume(O), s = !0, m) : O === 63 ? (n.consume(O), i = 3, r.interrupt ? e : I) : lr(O) ? (n.consume(O), o = String.fromCharCode(O), g) : t(O);
  }
  function f(O) {
    return O === 45 ? (n.consume(O), i = 2, d) : O === 91 ? (n.consume(O), i = 5, l = 0, p) : lr(O) ? (n.consume(O), i = 4, r.interrupt ? e : I) : t(O);
  }
  function d(O) {
    return O === 45 ? (n.consume(O), r.interrupt ? e : I) : t(O);
  }
  function p(O) {
    const dt = "CDATA[";
    return O === dt.charCodeAt(l++) ? (n.consume(O), l === dt.length ? r.interrupt ? e : z : p) : t(O);
  }
  function m(O) {
    return lr(O) ? (n.consume(O), o = String.fromCharCode(O), g) : t(O);
  }
  function g(O) {
    if (O === null || O === 47 || O === 62 || It(O)) {
      const dt = O === 47, Ue = o.toLowerCase();
      return !dt && !s && fx.includes(Ue) ? (i = 1, r.interrupt ? e(O) : z(O)) : vq.includes(o.toLowerCase()) ? (i = 6, dt ? (n.consume(O), b) : r.interrupt ? e(O) : z(O)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? t(O) : s ? w(O) : k(O));
    }
    return O === 45 || Tr(O) ? (n.consume(O), o += String.fromCharCode(O), g) : t(O);
  }
  function b(O) {
    return O === 62 ? (n.consume(O), r.interrupt ? e : z) : t(O);
  }
  function w(O) {
    return lt(O) ? (n.consume(O), w) : R(O);
  }
  function k(O) {
    return O === 47 ? (n.consume(O), R) : O === 58 || O === 95 || lr(O) ? (n.consume(O), C) : lt(O) ? (n.consume(O), k) : R(O);
  }
  function C(O) {
    return O === 45 || O === 46 || O === 58 || O === 95 || Tr(O) ? (n.consume(O), C) : M(O);
  }
  function M(O) {
    return O === 61 ? (n.consume(O), T) : lt(O) ? (n.consume(O), M) : k(O);
  }
  function T(O) {
    return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? t(O) : O === 34 || O === 39 ? (n.consume(O), a = O, N) : lt(O) ? (n.consume(O), T) : B(O);
  }
  function N(O) {
    return O === a ? (n.consume(O), a = null, $) : O === null || Ne(O) ? t(O) : (n.consume(O), N);
  }
  function B(O) {
    return O === null || O === 34 || O === 39 || O === 47 || O === 60 || O === 61 || O === 62 || O === 96 || It(O) ? M(O) : (n.consume(O), B);
  }
  function $(O) {
    return O === 47 || O === 62 || lt(O) ? k(O) : t(O);
  }
  function R(O) {
    return O === 62 ? (n.consume(O), V) : t(O);
  }
  function V(O) {
    return O === null || Ne(O) ? z(O) : lt(O) ? (n.consume(O), V) : t(O);
  }
  function z(O) {
    return O === 45 && i === 2 ? (n.consume(O), Se) : O === 60 && i === 1 ? (n.consume(O), ge) : O === 62 && i === 4 ? (n.consume(O), Ie) : O === 63 && i === 3 ? (n.consume(O), I) : O === 93 && i === 5 ? (n.consume(O), ze) : Ne(O) && (i === 6 || i === 7) ? (n.exit("htmlFlowData"), n.check(xq, Ve, ue)(O)) : O === null || Ne(O) ? (n.exit("htmlFlowData"), ue(O)) : (n.consume(O), z);
  }
  function ue(O) {
    return n.check(kq, ie, Ve)(O);
  }
  function ie(O) {
    return n.enter("lineEnding"), n.consume(O), n.exit("lineEnding"), he;
  }
  function he(O) {
    return O === null || Ne(O) ? ue(O) : (n.enter("htmlFlowData"), z(O));
  }
  function Se(O) {
    return O === 45 ? (n.consume(O), I) : z(O);
  }
  function ge(O) {
    return O === 47 ? (n.consume(O), o = "", ye) : z(O);
  }
  function ye(O) {
    if (O === 62) {
      const dt = o.toLowerCase();
      return fx.includes(dt) ? (n.consume(O), Ie) : z(O);
    }
    return lr(O) && o.length < 8 ? (n.consume(O), o += String.fromCharCode(O), ye) : z(O);
  }
  function ze(O) {
    return O === 93 ? (n.consume(O), I) : z(O);
  }
  function I(O) {
    return O === 62 ? (n.consume(O), Ie) : O === 45 && i === 2 ? (n.consume(O), I) : z(O);
  }
  function Ie(O) {
    return O === null || Ne(O) ? (n.exit("htmlFlowData"), Ve(O)) : (n.consume(O), Ie);
  }
  function Ve(O) {
    return n.exit("htmlFlow"), e(O);
  }
}
function Mq(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return Ne(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s) : t(o);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
function Tq(n, e, t) {
  return r;
  function r(i) {
    return n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), n.attempt(fd, e, t);
  }
}
const Aq = {
  name: "htmlText",
  tokenize: Oq
};
function Oq(n, e, t) {
  const r = this;
  let i, s, o;
  return l;
  function l(I) {
    return n.enter("htmlText"), n.enter("htmlTextData"), n.consume(I), a;
  }
  function a(I) {
    return I === 33 ? (n.consume(I), c) : I === 47 ? (n.consume(I), M) : I === 63 ? (n.consume(I), k) : lr(I) ? (n.consume(I), B) : t(I);
  }
  function c(I) {
    return I === 45 ? (n.consume(I), u) : I === 91 ? (n.consume(I), s = 0, p) : lr(I) ? (n.consume(I), w) : t(I);
  }
  function u(I) {
    return I === 45 ? (n.consume(I), d) : t(I);
  }
  function h(I) {
    return I === null ? t(I) : I === 45 ? (n.consume(I), f) : Ne(I) ? (o = h, ge(I)) : (n.consume(I), h);
  }
  function f(I) {
    return I === 45 ? (n.consume(I), d) : h(I);
  }
  function d(I) {
    return I === 62 ? Se(I) : I === 45 ? f(I) : h(I);
  }
  function p(I) {
    const Ie = "CDATA[";
    return I === Ie.charCodeAt(s++) ? (n.consume(I), s === Ie.length ? m : p) : t(I);
  }
  function m(I) {
    return I === null ? t(I) : I === 93 ? (n.consume(I), g) : Ne(I) ? (o = m, ge(I)) : (n.consume(I), m);
  }
  function g(I) {
    return I === 93 ? (n.consume(I), b) : m(I);
  }
  function b(I) {
    return I === 62 ? Se(I) : I === 93 ? (n.consume(I), b) : m(I);
  }
  function w(I) {
    return I === null || I === 62 ? Se(I) : Ne(I) ? (o = w, ge(I)) : (n.consume(I), w);
  }
  function k(I) {
    return I === null ? t(I) : I === 63 ? (n.consume(I), C) : Ne(I) ? (o = k, ge(I)) : (n.consume(I), k);
  }
  function C(I) {
    return I === 62 ? Se(I) : k(I);
  }
  function M(I) {
    return lr(I) ? (n.consume(I), T) : t(I);
  }
  function T(I) {
    return I === 45 || Tr(I) ? (n.consume(I), T) : N(I);
  }
  function N(I) {
    return Ne(I) ? (o = N, ge(I)) : lt(I) ? (n.consume(I), N) : Se(I);
  }
  function B(I) {
    return I === 45 || Tr(I) ? (n.consume(I), B) : I === 47 || I === 62 || It(I) ? $(I) : t(I);
  }
  function $(I) {
    return I === 47 ? (n.consume(I), Se) : I === 58 || I === 95 || lr(I) ? (n.consume(I), R) : Ne(I) ? (o = $, ge(I)) : lt(I) ? (n.consume(I), $) : Se(I);
  }
  function R(I) {
    return I === 45 || I === 46 || I === 58 || I === 95 || Tr(I) ? (n.consume(I), R) : V(I);
  }
  function V(I) {
    return I === 61 ? (n.consume(I), z) : Ne(I) ? (o = V, ge(I)) : lt(I) ? (n.consume(I), V) : $(I);
  }
  function z(I) {
    return I === null || I === 60 || I === 61 || I === 62 || I === 96 ? t(I) : I === 34 || I === 39 ? (n.consume(I), i = I, ue) : Ne(I) ? (o = z, ge(I)) : lt(I) ? (n.consume(I), z) : (n.consume(I), ie);
  }
  function ue(I) {
    return I === i ? (n.consume(I), i = void 0, he) : I === null ? t(I) : Ne(I) ? (o = ue, ge(I)) : (n.consume(I), ue);
  }
  function ie(I) {
    return I === null || I === 34 || I === 39 || I === 60 || I === 61 || I === 96 ? t(I) : I === 47 || I === 62 || It(I) ? $(I) : (n.consume(I), ie);
  }
  function he(I) {
    return I === 47 || I === 62 || It(I) ? $(I) : t(I);
  }
  function Se(I) {
    return I === 62 ? (n.consume(I), n.exit("htmlTextData"), n.exit("htmlText"), e) : t(I);
  }
  function ge(I) {
    return n.exit("htmlTextData"), n.enter("lineEnding"), n.consume(I), n.exit("lineEnding"), ye;
  }
  function ye(I) {
    return lt(I) ? it(n, ze, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(I) : ze(I);
  }
  function ze(I) {
    return n.enter("htmlTextData"), o(I);
  }
}
const L3 = {
  name: "labelEnd",
  resolveAll: Nq,
  resolveTo: Rq,
  tokenize: Pq
}, Eq = {
  tokenize: _q
}, Iq = {
  tokenize: Lq
}, Dq = {
  tokenize: Bq
};
function Nq(n) {
  let e = -1;
  const t = [];
  for (; ++e < n.length; ) {
    const r = n[e][1];
    if (t.push(n[e]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", e += i;
    }
  }
  return n.length !== t.length && Jr(n, 0, n.length, t), n;
}
function Rq(n, e) {
  let t = n.length, r = 0, i, s, o, l;
  for (; t--; )
    if (i = n[t][1], s) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      n[t][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (n[t][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = t, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (o = t);
  const a = {
    type: n[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...n[s][1].start
    },
    end: {
      ...n[n.length - 1][1].end
    }
  }, c = {
    type: "label",
    start: {
      ...n[s][1].start
    },
    end: {
      ...n[o][1].end
    }
  }, u = {
    type: "labelText",
    start: {
      ...n[s + r + 2][1].end
    },
    end: {
      ...n[o - 2][1].start
    }
  };
  return l = [["enter", a, e], ["enter", c, e]], l = oi(l, n.slice(s + 1, s + r + 3)), l = oi(l, [["enter", u, e]]), l = oi(l, v1(e.parser.constructs.insideSpan.null, n.slice(s + r + 4, o - 3), e)), l = oi(l, [["exit", u, e], n[o - 2], n[o - 1], ["exit", c, e]]), l = oi(l, n.slice(o + 1)), l = oi(l, [["exit", a, e]]), Jr(n, s, n.length, l), n;
}
function Pq(n, e, t) {
  const r = this;
  let i = r.events.length, s, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return l;
  function l(f) {
    return s ? s._inactive ? h(f) : (o = r.parser.defined.includes(Ni(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), n.enter("labelEnd"), n.enter("labelMarker"), n.consume(f), n.exit("labelMarker"), n.exit("labelEnd"), a) : t(f);
  }
  function a(f) {
    return f === 40 ? n.attempt(Eq, u, o ? u : h)(f) : f === 91 ? n.attempt(Iq, u, o ? c : h)(f) : o ? u(f) : h(f);
  }
  function c(f) {
    return n.attempt(Dq, u, h)(f);
  }
  function u(f) {
    return e(f);
  }
  function h(f) {
    return s._balanced = !0, t(f);
  }
}
function _q(n, e, t) {
  return r;
  function r(h) {
    return n.enter("resource"), n.enter("resourceMarker"), n.consume(h), n.exit("resourceMarker"), i;
  }
  function i(h) {
    return It(h) ? Wh(n, s)(h) : s(h);
  }
  function s(h) {
    return h === 41 ? u(h) : IT(n, o, l, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function o(h) {
    return It(h) ? Wh(n, a)(h) : u(h);
  }
  function l(h) {
    return t(h);
  }
  function a(h) {
    return h === 34 || h === 39 || h === 40 ? NT(n, c, t, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : u(h);
  }
  function c(h) {
    return It(h) ? Wh(n, u)(h) : u(h);
  }
  function u(h) {
    return h === 41 ? (n.enter("resourceMarker"), n.consume(h), n.exit("resourceMarker"), n.exit("resource"), e) : t(h);
  }
}
function Lq(n, e, t) {
  const r = this;
  return i;
  function i(l) {
    return DT.call(r, n, s, o, "reference", "referenceMarker", "referenceString")(l);
  }
  function s(l) {
    return r.parser.defined.includes(Ni(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(l) : t(l);
  }
  function o(l) {
    return t(l);
  }
}
function Bq(n, e, t) {
  return r;
  function r(s) {
    return n.enter("reference"), n.enter("referenceMarker"), n.consume(s), n.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (n.enter("referenceMarker"), n.consume(s), n.exit("referenceMarker"), n.exit("reference"), e) : t(s);
  }
}
const zq = {
  name: "labelStartImage",
  resolveAll: L3.resolveAll,
  tokenize: Fq
};
function Fq(n, e, t) {
  const r = this;
  return i;
  function i(l) {
    return n.enter("labelImage"), n.enter("labelImageMarker"), n.consume(l), n.exit("labelImageMarker"), s;
  }
  function s(l) {
    return l === 91 ? (n.enter("labelMarker"), n.consume(l), n.exit("labelMarker"), n.exit("labelImage"), o) : t(l);
  }
  function o(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(l) : e(l);
  }
}
const Hq = {
  name: "labelStartLink",
  resolveAll: L3.resolveAll,
  tokenize: $q
};
function $q(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return n.enter("labelLink"), n.enter("labelMarker"), n.consume(o), n.exit("labelMarker"), n.exit("labelLink"), s;
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(o) : e(o);
  }
}
const r2 = {
  name: "lineEnding",
  tokenize: Vq
};
function Vq(n, e) {
  return t;
  function t(r) {
    return n.enter("lineEnding"), n.consume(r), n.exit("lineEnding"), it(n, e, "linePrefix");
  }
}
const ip = {
  name: "thematicBreak",
  tokenize: qq
};
function qq(n, e, t) {
  let r = 0, i;
  return s;
  function s(c) {
    return n.enter("thematicBreak"), o(c);
  }
  function o(c) {
    return i = c, l(c);
  }
  function l(c) {
    return c === i ? (n.enter("thematicBreakSequence"), a(c)) : r >= 3 && (c === null || Ne(c)) ? (n.exit("thematicBreak"), e(c)) : t(c);
  }
  function a(c) {
    return c === i ? (n.consume(c), r++, a) : (n.exit("thematicBreakSequence"), lt(c) ? it(n, l, "whitespace")(c) : l(c));
  }
}
const vr = {
  continuation: {
    tokenize: Kq
  },
  exit: Yq,
  name: "list",
  tokenize: Uq
}, Wq = {
  partial: !0,
  tokenize: Jq
}, jq = {
  partial: !0,
  tokenize: Gq
};
function Uq(n, e, t) {
  const r = this, i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return l;
  function l(d) {
    const p = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (p === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : Ay(d)) {
      if (r.containerState.type || (r.containerState.type = p, n.enter(p, {
        _container: !0
      })), p === "listUnordered")
        return n.enter("listItemPrefix"), d === 42 || d === 45 ? n.check(ip, t, c)(d) : c(d);
      if (!r.interrupt || d === 49)
        return n.enter("listItemPrefix"), n.enter("listItemValue"), a(d);
    }
    return t(d);
  }
  function a(d) {
    return Ay(d) && ++o < 10 ? (n.consume(d), a) : (!r.interrupt || o < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (n.exit("listItemValue"), c(d)) : t(d);
  }
  function c(d) {
    return n.enter("listItemMarker"), n.consume(d), n.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, n.check(
      fd,
      // Can’t be empty when interrupting.
      r.interrupt ? t : u,
      n.attempt(Wq, f, h)
    );
  }
  function u(d) {
    return r.containerState.initialBlankLine = !0, s++, f(d);
  }
  function h(d) {
    return lt(d) ? (n.enter("listItemPrefixWhitespace"), n.consume(d), n.exit("listItemPrefixWhitespace"), f) : t(d);
  }
  function f(d) {
    return r.containerState.size = s + r.sliceSerialize(n.exit("listItemPrefix"), !0).length, e(d);
  }
}
function Kq(n, e, t) {
  const r = this;
  return r.containerState._closeFlow = void 0, n.check(fd, i, s);
  function i(l) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, it(n, e, "listItemIndent", r.containerState.size + 1)(l);
  }
  function s(l) {
    return r.containerState.furtherBlankLines || !lt(l) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(l)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, n.attempt(jq, e, o)(l));
  }
  function o(l) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, it(n, n.attempt(vr, e, t), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l);
  }
}
function Gq(n, e, t) {
  const r = this;
  return it(n, i, "listItemIndent", r.containerState.size + 1);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(s) : t(s);
  }
}
function Yq(n) {
  n.exit(this.containerState.type);
}
function Jq(n, e, t) {
  const r = this;
  return it(n, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return !lt(s) && o && o[1].type === "listItemPrefixWhitespace" ? e(s) : t(s);
  }
}
const dx = {
  name: "setextUnderline",
  resolveTo: Xq,
  tokenize: Zq
};
function Xq(n, e) {
  let t = n.length, r, i, s;
  for (; t--; )
    if (n[t][0] === "enter") {
      if (n[t][1].type === "content") {
        r = t;
        break;
      }
      n[t][1].type === "paragraph" && (i = t);
    } else
      n[t][1].type === "content" && n.splice(t, 1), !s && n[t][1].type === "definition" && (s = t);
  const o = {
    type: "setextHeading",
    start: {
      ...n[r][1].start
    },
    end: {
      ...n[n.length - 1][1].end
    }
  };
  return n[i][1].type = "setextHeadingText", s ? (n.splice(i, 0, ["enter", o, e]), n.splice(s + 1, 0, ["exit", n[r][1], e]), n[r][1].end = {
    ...n[s][1].end
  }) : n[r][1] = o, n.push(["exit", o, e]), n;
}
function Zq(n, e, t) {
  const r = this;
  let i;
  return s;
  function s(c) {
    let u = r.events.length, h;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        h = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (n.enter("setextHeadingLine"), i = c, o(c)) : t(c);
  }
  function o(c) {
    return n.enter("setextHeadingLineSequence"), l(c);
  }
  function l(c) {
    return c === i ? (n.consume(c), l) : (n.exit("setextHeadingLineSequence"), lt(c) ? it(n, a, "lineSuffix")(c) : a(c));
  }
  function a(c) {
    return c === null || Ne(c) ? (n.exit("setextHeadingLine"), e(c)) : t(c);
  }
}
const Qq = {
  tokenize: eW
};
function eW(n) {
  const e = this, t = n.attempt(
    // Try to parse a blank line.
    fd,
    r,
    // Try to parse initial flow (essentially, only code).
    n.attempt(this.parser.constructs.flowInitial, i, it(n, n.attempt(this.parser.constructs.flow, i, n.attempt(sq, i)), "linePrefix"))
  );
  return t;
  function r(s) {
    if (s === null) {
      n.consume(s);
      return;
    }
    return n.enter("lineEndingBlank"), n.consume(s), n.exit("lineEndingBlank"), e.currentConstruct = void 0, t;
  }
  function i(s) {
    if (s === null) {
      n.consume(s);
      return;
    }
    return n.enter("lineEnding"), n.consume(s), n.exit("lineEnding"), e.currentConstruct = void 0, t;
  }
}
const tW = {
  resolveAll: PT()
}, nW = RT("string"), rW = RT("text");
function RT(n) {
  return {
    resolveAll: PT(n === "text" ? iW : void 0),
    tokenize: e
  };
  function e(t) {
    const r = this, i = this.parser.constructs[n], s = t.attempt(i, o, l);
    return o;
    function o(u) {
      return c(u) ? s(u) : l(u);
    }
    function l(u) {
      if (u === null) {
        t.consume(u);
        return;
      }
      return t.enter("data"), t.consume(u), a;
    }
    function a(u) {
      return c(u) ? (t.exit("data"), s(u)) : (t.consume(u), a);
    }
    function c(u) {
      if (u === null)
        return !0;
      const h = i[u];
      let f = -1;
      if (h)
        for (; ++f < h.length; ) {
          const d = h[f];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function PT(n) {
  return e;
  function e(t, r) {
    let i = -1, s;
    for (; ++i <= t.length; )
      s === void 0 ? t[i] && t[i][1].type === "data" && (s = i, i++) : (!t[i] || t[i][1].type !== "data") && (i !== s + 2 && (t[s][1].end = t[i - 1][1].end, t.splice(s + 2, i - s - 2), i = s + 2), s = void 0);
    return n ? n(t, r) : t;
  }
}
function iW(n, e) {
  let t = 0;
  for (; ++t <= n.length; )
    if ((t === n.length || n[t][1].type === "lineEnding") && n[t - 1][1].type === "data") {
      const r = n[t - 1][1], i = e.sliceStream(r);
      let s = i.length, o = -1, l = 0, a;
      for (; s--; ) {
        const c = i[s];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; )
            l++, o--;
          if (o) break;
          o = -1;
        } else if (c === -2)
          a = !0, l++;
        else if (c !== -1) {
          s++;
          break;
        }
      }
      if (e._contentTypeTextTrailing && t === n.length && (l = 0), l) {
        const c = {
          type: t === n.length || a || l < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? o : r.start._bufferIndex + o,
            _index: r.start._index + s,
            line: r.end.line,
            column: r.end.column - l,
            offset: r.end.offset - l
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...c.start
        }, r.start.offset === r.end.offset ? Object.assign(r, c) : (n.splice(t, 0, ["enter", c, e], ["exit", c, e]), t += 2);
      }
      t++;
    }
  return n;
}
const sW = {
  42: vr,
  43: vr,
  45: vr,
  48: vr,
  49: vr,
  50: vr,
  51: vr,
  52: vr,
  53: vr,
  54: vr,
  55: vr,
  56: vr,
  57: vr,
  62: TT
}, oW = {
  91: uq
}, lW = {
  [-2]: n2,
  [-1]: n2,
  32: n2
}, aW = {
  35: gq,
  42: ip,
  45: [dx, ip],
  60: wq,
  61: dx,
  95: ip,
  96: hx,
  126: hx
}, cW = {
  38: OT,
  92: AT
}, uW = {
  [-5]: r2,
  [-4]: r2,
  [-3]: r2,
  33: zq,
  38: OT,
  42: Oy,
  60: [HV, Aq],
  91: Hq,
  92: [pq, AT],
  93: L3,
  95: Oy,
  96: QV
}, hW = {
  null: [Oy, tW]
}, fW = {
  null: [42, 95]
}, dW = {
  null: []
}, pW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: fW,
  contentInitial: oW,
  disable: dW,
  document: sW,
  flow: aW,
  flowInitial: lW,
  insideSpan: hW,
  string: cW,
  text: uW
}, Symbol.toStringTag, { value: "Module" }));
function mW(n, e, t) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: t && t.line || 1,
    column: t && t.column || 1,
    offset: t && t.offset || 0
  };
  const i = {}, s = [];
  let o = [], l = [];
  const a = {
    attempt: N(M),
    check: N(T),
    consume: w,
    enter: k,
    exit: C,
    interrupt: N(T, {
      interrupt: !0
    })
  }, c = {
    code: null,
    containerState: {},
    defineSkip: m,
    events: [],
    now: p,
    parser: n,
    previous: null,
    sliceSerialize: f,
    sliceStream: d,
    write: h
  };
  let u = e.tokenize.call(c, a);
  return e.resolveAll && s.push(e), c;
  function h(V) {
    return o = oi(o, V), g(), o[o.length - 1] !== null ? [] : (B(e, 0), c.events = v1(s, c.events, c), c.events);
  }
  function f(V, z) {
    return yW(d(V), z);
  }
  function d(V) {
    return gW(o, V);
  }
  function p() {
    const {
      _bufferIndex: V,
      _index: z,
      line: ue,
      column: ie,
      offset: he
    } = r;
    return {
      _bufferIndex: V,
      _index: z,
      line: ue,
      column: ie,
      offset: he
    };
  }
  function m(V) {
    i[V.line] = V.column, R();
  }
  function g() {
    let V;
    for (; r._index < o.length; ) {
      const z = o[r._index];
      if (typeof z == "string")
        for (V = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === V && r._bufferIndex < z.length; )
          b(z.charCodeAt(r._bufferIndex));
      else
        b(z);
    }
  }
  function b(V) {
    u = u(V);
  }
  function w(V) {
    Ne(V) ? (r.line++, r.column = 1, r.offset += V === -3 ? 2 : 1, R()) : V !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = V;
  }
  function k(V, z) {
    const ue = z || {};
    return ue.type = V, ue.start = p(), c.events.push(["enter", ue, c]), l.push(ue), ue;
  }
  function C(V) {
    const z = l.pop();
    return z.end = p(), c.events.push(["exit", z, c]), z;
  }
  function M(V, z) {
    B(V, z.from);
  }
  function T(V, z) {
    z.restore();
  }
  function N(V, z) {
    return ue;
    function ue(ie, he, Se) {
      let ge, ye, ze, I;
      return Array.isArray(ie) ? (
        /* c8 ignore next 1 */
        Ve(ie)
      ) : "tokenize" in ie ? (
        // Looks like a construct.
        Ve([
          /** @type {Construct} */
          ie
        ])
      ) : Ie(ie);
      function Ie(et) {
        return Ct;
        function Ct(Ft) {
          const sn = Ft !== null && et[Ft], Gt = Ft !== null && et.null, _r = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(sn) ? sn : sn ? [sn] : [],
            ...Array.isArray(Gt) ? Gt : Gt ? [Gt] : []
          ];
          return Ve(_r)(Ft);
        }
      }
      function Ve(et) {
        return ge = et, ye = 0, et.length === 0 ? Se : O(et[ye]);
      }
      function O(et) {
        return Ct;
        function Ct(Ft) {
          return I = $(), ze = et, et.partial || (c.currentConstruct = et), et.name && c.parser.constructs.disable.null.includes(et.name) ? Ue() : et.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            z ? Object.assign(Object.create(c), z) : c,
            a,
            dt,
            Ue
          )(Ft);
        }
      }
      function dt(et) {
        return V(ze, I), he;
      }
      function Ue(et) {
        return I.restore(), ++ye < ge.length ? O(ge[ye]) : Se;
      }
    }
  }
  function B(V, z) {
    V.resolveAll && !s.includes(V) && s.push(V), V.resolve && Jr(c.events, z, c.events.length - z, V.resolve(c.events.slice(z), c)), V.resolveTo && (c.events = V.resolveTo(c.events, c));
  }
  function $() {
    const V = p(), z = c.previous, ue = c.currentConstruct, ie = c.events.length, he = Array.from(l);
    return {
      from: ie,
      restore: Se
    };
    function Se() {
      r = V, c.previous = z, c.currentConstruct = ue, c.events.length = ie, l = he, R();
    }
  }
  function R() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function gW(n, e) {
  const t = e.start._index, r = e.start._bufferIndex, i = e.end._index, s = e.end._bufferIndex;
  let o;
  if (t === i)
    o = [n[t].slice(r, s)];
  else {
    if (o = n.slice(t, i), r > -1) {
      const l = o[0];
      typeof l == "string" ? o[0] = l.slice(r) : o.shift();
    }
    s > 0 && o.push(n[i].slice(0, s));
  }
  return o;
}
function yW(n, e) {
  let t = -1;
  const r = [];
  let i;
  for (; ++t < n.length; ) {
    const s = n[t];
    let o;
    if (typeof s == "string")
      o = s;
    else switch (s) {
      case -5: {
        o = "\r";
        break;
      }
      case -4: {
        o = `
`;
        break;
      }
      case -3: {
        o = `\r
`;
        break;
      }
      case -2: {
        o = e ? " " : "	";
        break;
      }
      case -1: {
        if (!e && i) continue;
        o = " ";
        break;
      }
      default:
        o = String.fromCharCode(s);
    }
    i = s === -2, r.push(o);
  }
  return r.join("");
}
function bW(n) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      CT([pW, ...(n || {}).extensions || []])
    ),
    content: i(RV),
    defined: [],
    document: i(_V),
    flow: i(Qq),
    lazy: {},
    string: i(nW),
    text: i(rW)
  };
  return r;
  function i(s) {
    return o;
    function o(l) {
      return mW(r, s, l);
    }
  }
}
function vW(n) {
  for (; !ET(n); )
    ;
  return n;
}
const px = /[\0\t\n\r]/g;
function wW() {
  let n = 1, e = "", t = !0, r;
  return i;
  function i(s, o, l) {
    const a = [];
    let c, u, h, f, d;
    for (s = e + (typeof s == "string" ? s.toString() : new TextDecoder(o || void 0).decode(s)), h = 0, e = "", t && (s.charCodeAt(0) === 65279 && h++, t = void 0); h < s.length; ) {
      if (px.lastIndex = h, c = px.exec(s), f = c && c.index !== void 0 ? c.index : s.length, d = s.charCodeAt(f), !c) {
        e = s.slice(h);
        break;
      }
      if (d === 10 && h === f && r)
        a.push(-3), r = void 0;
      else
        switch (r && (a.push(-5), r = void 0), h < f && (a.push(s.slice(h, f)), n += f - h), d) {
          case 0: {
            a.push(65533), n++;
            break;
          }
          case 9: {
            for (u = Math.ceil(n / 4) * 4, a.push(-2); n++ < u; ) a.push(-1);
            break;
          }
          case 10: {
            a.push(-4), n = 1;
            break;
          }
          default:
            r = !0, n = 1;
        }
      h = f + 1;
    }
    return l && (r && a.push(-5), e && a.push(e), a.push(null)), a;
  }
}
const xW = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function _T(n) {
  return n.replace(xW, kW);
}
function kW(n, e, t) {
  if (e)
    return e;
  if (t.charCodeAt(0) === 35) {
    const i = t.charCodeAt(1), s = i === 120 || i === 88;
    return MT(t.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return _3(t) || n;
}
function jh(n) {
  return !n || typeof n != "object" ? "" : "position" in n || "type" in n ? mx(n.position) : "start" in n || "end" in n ? mx(n) : "line" in n || "column" in n ? Ey(n) : "";
}
function Ey(n) {
  return gx(n && n.line) + ":" + gx(n && n.column);
}
function mx(n) {
  return Ey(n && n.start) + "-" + Ey(n && n.end);
}
function gx(n) {
  return n && typeof n == "number" ? n : 1;
}
const LT = {}.hasOwnProperty;
function SW(n, e, t) {
  return typeof e != "string" && (t = e, e = void 0), CW(t)(vW(bW(t).document().write(wW()(n, e, !0))));
}
function CW(n) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(re),
      autolinkProtocol: $,
      autolinkEmail: $,
      atxHeading: s(Q),
      blockQuote: s(Gt),
      characterEscape: $,
      characterReference: $,
      codeFenced: s(_r),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: s(_r, o),
      codeText: s(E, o),
      codeTextData: $,
      data: $,
      codeFlowValue: $,
      definition: s(P),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: s(W),
      hardBreakEscape: s(J),
      hardBreakTrailing: s(J),
      htmlFlow: s(Y, o),
      htmlFlowData: $,
      htmlText: s(Y, o),
      htmlTextData: $,
      image: s(ae),
      label: o,
      link: s(re),
      listItem: s(te),
      listItemValue: f,
      listOrdered: s(oe, h),
      listUnordered: s(oe),
      paragraph: s(De),
      reference: O,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: s(Q),
      strong: s(de),
      thematicBreak: s(Pe)
    },
    exit: {
      atxHeading: a(),
      atxHeadingSequence: M,
      autolink: a(),
      autolinkEmail: sn,
      autolinkProtocol: Ft,
      blockQuote: a(),
      characterEscapeValue: R,
      characterReferenceMarkerHexadecimal: Ue,
      characterReferenceMarkerNumeric: Ue,
      characterReferenceValue: et,
      characterReference: Ct,
      codeFenced: a(g),
      codeFencedFence: m,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: p,
      codeFlowValue: R,
      codeIndented: a(b),
      codeText: a(he),
      codeTextData: R,
      data: R,
      definition: a(),
      definitionDestinationString: C,
      definitionLabelString: w,
      definitionTitleString: k,
      emphasis: a(),
      hardBreakEscape: a(z),
      hardBreakTrailing: a(z),
      htmlFlow: a(ue),
      htmlFlowData: R,
      htmlText: a(ie),
      htmlTextData: R,
      image: a(ge),
      label: ze,
      labelText: ye,
      lineEnding: V,
      link: a(Se),
      listItem: a(),
      listOrdered: a(),
      listUnordered: a(),
      paragraph: a(),
      referenceString: dt,
      resourceDestinationString: I,
      resourceTitleString: Ie,
      resource: Ve,
      setextHeading: a(B),
      setextHeadingLineSequence: N,
      setextHeadingText: T,
      strong: a(),
      thematicBreak: a()
    }
  };
  BT(e, (n || {}).mdastExtensions || []);
  const t = {};
  return r;
  function r(F) {
    let X = {
      type: "root",
      children: []
    };
    const pe = {
      stack: [X],
      tokenStack: [],
      config: e,
      enter: l,
      exit: c,
      buffer: o,
      resume: u,
      data: t
    }, _e = [];
    let je = -1;
    for (; ++je < F.length; )
      if (F[je][1].type === "listOrdered" || F[je][1].type === "listUnordered")
        if (F[je][0] === "enter")
          _e.push(je);
        else {
          const xt = _e.pop();
          je = i(F, xt, je);
        }
    for (je = -1; ++je < F.length; ) {
      const xt = e[F[je][0]];
      LT.call(xt, F[je][1].type) && xt[F[je][1].type].call(Object.assign({
        sliceSerialize: F[je][2].sliceSerialize
      }, pe), F[je][1]);
    }
    if (pe.tokenStack.length > 0) {
      const xt = pe.tokenStack[pe.tokenStack.length - 1];
      (xt[1] || yx).call(pe, void 0, xt[0]);
    }
    for (X.position = {
      start: Eo(F.length > 0 ? F[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Eo(F.length > 0 ? F[F.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, je = -1; ++je < e.transforms.length; )
      X = e.transforms[je](X) || X;
    return X;
  }
  function i(F, X, pe) {
    let _e = X - 1, je = -1, xt = !1, Rt, Yt, on, wt;
    for (; ++_e <= pe; ) {
      const pt = F[_e];
      switch (pt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          pt[0] === "enter" ? je++ : je--, wt = void 0;
          break;
        }
        case "lineEndingBlank": {
          pt[0] === "enter" && (Rt && !wt && !je && !on && (on = _e), wt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          wt = void 0;
      }
      if (!je && pt[0] === "enter" && pt[1].type === "listItemPrefix" || je === -1 && pt[0] === "exit" && (pt[1].type === "listUnordered" || pt[1].type === "listOrdered")) {
        if (Rt) {
          let Vn = _e;
          for (Yt = void 0; Vn--; ) {
            const En = F[Vn];
            if (En[1].type === "lineEnding" || En[1].type === "lineEndingBlank") {
              if (En[0] === "exit") continue;
              Yt && (F[Yt][1].type = "lineEndingBlank", xt = !0), En[1].type = "lineEnding", Yt = Vn;
            } else if (!(En[1].type === "linePrefix" || En[1].type === "blockQuotePrefix" || En[1].type === "blockQuotePrefixWhitespace" || En[1].type === "blockQuoteMarker" || En[1].type === "listItemIndent")) break;
          }
          on && (!Yt || on < Yt) && (Rt._spread = !0), Rt.end = Object.assign({}, Yt ? F[Yt][1].start : pt[1].end), F.splice(Yt || _e, 0, ["exit", Rt, pt[2]]), _e++, pe++;
        }
        if (pt[1].type === "listItemPrefix") {
          const Vn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, pt[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          Rt = Vn, F.splice(_e, 0, ["enter", Vn, pt[2]]), _e++, pe++, on = void 0, wt = !0;
        }
      }
    }
    return F[X][1]._spread = xt, pe;
  }
  function s(F, X) {
    return pe;
    function pe(_e) {
      l.call(this, F(_e), _e), X && X.call(this, _e);
    }
  }
  function o() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function l(F, X, pe) {
    this.stack[this.stack.length - 1].children.push(F), this.stack.push(F), this.tokenStack.push([X, pe || void 0]), F.position = {
      start: Eo(X.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function a(F) {
    return X;
    function X(pe) {
      F && F.call(this, pe), c.call(this, pe);
    }
  }
  function c(F, X) {
    const pe = this.stack.pop(), _e = this.tokenStack.pop();
    if (_e)
      _e[0].type !== F.type && (X ? X.call(this, F, _e[0]) : (_e[1] || yx).call(this, F, _e[0]));
    else throw new Error("Cannot close `" + F.type + "` (" + jh({
      start: F.start,
      end: F.end
    }) + "): it’s not open");
    pe.position.end = Eo(F.end);
  }
  function u() {
    return P3(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f(F) {
    if (this.data.expectingFirstListItemValue) {
      const X = this.stack[this.stack.length - 2];
      X.start = Number.parseInt(this.sliceSerialize(F), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.lang = F;
  }
  function p() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.meta = F;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function g() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function b() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F.replace(/(\r?\n|\r)$/g, "");
  }
  function w(F) {
    const X = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.label = X, pe.identifier = Ni(this.sliceSerialize(F)).toLowerCase();
  }
  function k() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.title = F;
  }
  function C() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.url = F;
  }
  function M(F) {
    const X = this.stack[this.stack.length - 1];
    if (!X.depth) {
      const pe = this.sliceSerialize(F).length;
      X.depth = pe;
    }
  }
  function T() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function N(F) {
    const X = this.stack[this.stack.length - 1];
    X.depth = this.sliceSerialize(F).codePointAt(0) === 61 ? 1 : 2;
  }
  function B() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function $(F) {
    const pe = this.stack[this.stack.length - 1].children;
    let _e = pe[pe.length - 1];
    (!_e || _e.type !== "text") && (_e = Te(), _e.position = {
      start: Eo(F.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, pe.push(_e)), this.stack.push(_e);
  }
  function R(F) {
    const X = this.stack.pop();
    X.value += this.sliceSerialize(F), X.position.end = Eo(F.end);
  }
  function V(F) {
    const X = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const pe = X.children[X.children.length - 1];
      pe.position.end = Eo(F.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(X.type) && ($.call(this, F), R.call(this, F));
  }
  function z() {
    this.data.atHardBreak = !0;
  }
  function ue() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F;
  }
  function ie() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F;
  }
  function he() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.value = F;
  }
  function Se() {
    const F = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const X = this.data.referenceType || "shortcut";
      F.type += "Reference", F.referenceType = X, delete F.url, delete F.title;
    } else
      delete F.identifier, delete F.label;
    this.data.referenceType = void 0;
  }
  function ge() {
    const F = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const X = this.data.referenceType || "shortcut";
      F.type += "Reference", F.referenceType = X, delete F.url, delete F.title;
    } else
      delete F.identifier, delete F.label;
    this.data.referenceType = void 0;
  }
  function ye(F) {
    const X = this.sliceSerialize(F), pe = this.stack[this.stack.length - 2];
    pe.label = _T(X), pe.identifier = Ni(X).toLowerCase();
  }
  function ze() {
    const F = this.stack[this.stack.length - 1], X = this.resume(), pe = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, pe.type === "link") {
      const _e = F.children;
      pe.children = _e;
    } else
      pe.alt = X;
  }
  function I() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.url = F;
  }
  function Ie() {
    const F = this.resume(), X = this.stack[this.stack.length - 1];
    X.title = F;
  }
  function Ve() {
    this.data.inReference = void 0;
  }
  function O() {
    this.data.referenceType = "collapsed";
  }
  function dt(F) {
    const X = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.label = X, pe.identifier = Ni(this.sliceSerialize(F)).toLowerCase(), this.data.referenceType = "full";
  }
  function Ue(F) {
    this.data.characterReferenceType = F.type;
  }
  function et(F) {
    const X = this.sliceSerialize(F), pe = this.data.characterReferenceType;
    let _e;
    pe ? (_e = MT(X, pe === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : _e = _3(X);
    const je = this.stack[this.stack.length - 1];
    je.value += _e;
  }
  function Ct(F) {
    const X = this.stack.pop();
    X.position.end = Eo(F.end);
  }
  function Ft(F) {
    R.call(this, F);
    const X = this.stack[this.stack.length - 1];
    X.url = this.sliceSerialize(F);
  }
  function sn(F) {
    R.call(this, F);
    const X = this.stack[this.stack.length - 1];
    X.url = "mailto:" + this.sliceSerialize(F);
  }
  function Gt() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function _r() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function E() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function P() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function W() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Q() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function J() {
    return {
      type: "break"
    };
  }
  function Y() {
    return {
      type: "html",
      value: ""
    };
  }
  function ae() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function re() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function oe(F) {
    return {
      type: "list",
      ordered: F.type === "listOrdered",
      start: null,
      spread: F._spread,
      children: []
    };
  }
  function te(F) {
    return {
      type: "listItem",
      spread: F._spread,
      checked: null,
      children: []
    };
  }
  function De() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function de() {
    return {
      type: "strong",
      children: []
    };
  }
  function Te() {
    return {
      type: "text",
      value: ""
    };
  }
  function Pe() {
    return {
      type: "thematicBreak"
    };
  }
}
function Eo(n) {
  return {
    line: n.line,
    column: n.column,
    offset: n.offset
  };
}
function BT(n, e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const r = e[t];
    Array.isArray(r) ? BT(n, r) : MW(n, r);
  }
}
function MW(n, e) {
  let t;
  for (t in e)
    if (LT.call(e, t))
      switch (t) {
        case "canContainEols": {
          const r = e[t];
          r && n[t].push(...r);
          break;
        }
        case "transforms": {
          const r = e[t];
          r && n[t].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = e[t];
          r && Object.assign(n[t], r);
          break;
        }
      }
}
function yx(n, e) {
  throw n ? new Error("Cannot close `" + n.type + "` (" + jh({
    start: n.start,
    end: n.end
  }) + "): a different token (`" + e.type + "`, " + jh({
    start: e.start,
    end: e.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + jh({
    start: e.start,
    end: e.end
  }) + ") is still open");
}
function Iy(n) {
  const e = this;
  e.parser = t;
  function t(r) {
    return SW(r, {
      ...e.data("settings"),
      ...n,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("micromarkExtensions") || [],
      mdastExtensions: e.data("fromMarkdownExtensions") || []
    });
  }
}
const bx = {}.hasOwnProperty;
function TW(n, e) {
  const t = e || {};
  function r(i, ...s) {
    let o = r.invalid;
    const l = r.handlers;
    if (i && bx.call(i, n)) {
      const a = String(i[n]);
      o = bx.call(l, a) ? l[a] : r.unknown;
    }
    if (o)
      return o.call(this, i, ...s);
  }
  return r.handlers = t.handlers || {}, r.invalid = t.invalid, r.unknown = t.unknown, r;
}
const AW = {}.hasOwnProperty;
function zT(n, e) {
  let t = -1, r;
  if (e.extensions)
    for (; ++t < e.extensions.length; )
      zT(n, e.extensions[t]);
  for (r in e)
    if (AW.call(e, r))
      switch (r) {
        case "extensions":
          break;
        /* c8 ignore next 4 */
        case "unsafe": {
          vx(n[r], e[r]);
          break;
        }
        case "join": {
          vx(n[r], e[r]);
          break;
        }
        case "handlers": {
          OW(n[r], e[r]);
          break;
        }
        default:
          n.options[r] = e[r];
      }
  return n;
}
function vx(n, e) {
  e && n.push(...e);
}
function OW(n, e) {
  e && Object.assign(n, e);
}
function EW(n, e, t, r) {
  const i = t.enter("blockquote"), s = t.createTracker(r);
  s.move("> "), s.shift(2);
  const o = t.indentLines(
    t.containerFlow(n, s.current()),
    IW
  );
  return i(), o;
}
function IW(n, e, t) {
  return ">" + (t ? "" : " ") + n;
}
function FT(n, e) {
  return wx(n, e.inConstruct, !0) && !wx(n, e.notInConstruct, !1);
}
function wx(n, e, t) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return t;
  let r = -1;
  for (; ++r < e.length; )
    if (n.includes(e[r]))
      return !0;
  return !1;
}
function xx(n, e, t, r) {
  let i = -1;
  for (; ++i < t.unsafe.length; )
    if (t.unsafe[i].character === `
` && FT(t.stack, t.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function HT(n, e) {
  const t = String(n);
  let r = t.indexOf(e), i = r, s = 0, o = 0;
  if (typeof e != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++s > o && (o = s) : s = 1, i = r + e.length, r = t.indexOf(e, i);
  return o;
}
function Dy(n, e) {
  return !!(e.options.fences === !1 && n.value && // If there’s no info…
  !n.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(n.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(n.value));
}
function DW(n) {
  const e = n.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function NW(n, e, t, r) {
  const i = DW(t), s = n.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (Dy(n, t)) {
    const h = t.enter("codeIndented"), f = t.indentLines(s, RW);
    return h(), f;
  }
  const l = t.createTracker(r), a = i.repeat(Math.max(HT(s, i) + 1, 3)), c = t.enter("codeFenced");
  let u = l.move(a);
  if (n.lang) {
    const h = t.enter(`codeFencedLang${o}`);
    u += l.move(
      t.safe(n.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...l.current()
      })
    ), h();
  }
  if (n.lang && n.meta) {
    const h = t.enter(`codeFencedMeta${o}`);
    u += l.move(" "), u += l.move(
      t.safe(n.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...l.current()
      })
    ), h();
  }
  return u += l.move(`
`), s && (u += l.move(s + `
`)), u += l.move(a), c(), u;
}
function RW(n, e, t) {
  return (t ? "" : "    ") + n;
}
function B3(n) {
  const e = n.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function PW(n, e, t, r) {
  const i = B3(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.enter("definition");
  let l = t.enter("label");
  const a = t.createTracker(r);
  let c = a.move("[");
  return c += a.move(
    t.safe(t.associationId(n), {
      before: c,
      after: "]",
      ...a.current()
    })
  ), c += a.move("]: "), l(), // If there’s no url, or…
  !n.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (l = t.enter("destinationLiteral"), c += a.move("<"), c += a.move(
    t.safe(n.url, { before: c, after: ">", ...a.current() })
  ), c += a.move(">")) : (l = t.enter("destinationRaw"), c += a.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : `
`,
      ...a.current()
    })
  )), l(), n.title && (l = t.enter(`title${s}`), c += a.move(" " + i), c += a.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...a.current()
    })
  ), c += a.move(i), l()), o(), c;
}
function _W(n) {
  const e = n.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function fl(n) {
  return "&#x" + n.toString(16).toUpperCase() + ";";
}
function pm(n, e, t) {
  const r = zc(n), i = zc(e);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    t === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
$T.peek = LW;
function $T(n, e, t, r) {
  const i = _W(t), s = t.enter("emphasis"), o = t.createTracker(r), l = o.move(i);
  let a = o.move(
    t.containerPhrasing(n, {
      after: i,
      before: l,
      ...o.current()
    })
  );
  const c = a.charCodeAt(0), u = pm(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (a = fl(c) + a.slice(1));
  const h = a.charCodeAt(a.length - 1), f = pm(r.after.charCodeAt(0), h, i);
  f.inside && (a = a.slice(0, -1) + fl(h));
  const d = o.move(i);
  return s(), t.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, l + a + d;
}
function LW(n, e, t) {
  return t.options.emphasis || "*";
}
const w1 = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(n) {
    if (n == null)
      return HW;
    if (typeof n == "function")
      return x1(n);
    if (typeof n == "object")
      return Array.isArray(n) ? BW(n) : zW(n);
    if (typeof n == "string")
      return FW(n);
    throw new Error("Expected function, string, or object as test");
  })
);
function BW(n) {
  const e = [];
  let t = -1;
  for (; ++t < n.length; )
    e[t] = w1(n[t]);
  return x1(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function zW(n) {
  const e = (
    /** @type {Record<string, unknown>} */
    n
  );
  return x1(t);
  function t(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in n)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function FW(n) {
  return x1(e);
  function e(t) {
    return t && t.type === n;
  }
}
function x1(n) {
  return e;
  function e(t, r, i) {
    return !!($W(t) && n.call(
      this,
      t,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function HW() {
  return !0;
}
function $W(n) {
  return n !== null && typeof n == "object" && "type" in n;
}
const VT = [], VW = !0, Ny = !1, Ry = "skip";
function z3(n, e, t, r) {
  let i;
  typeof e == "function" && typeof t != "function" ? (r = t, t = e) : i = e;
  const s = w1(i), o = r ? -1 : 1;
  l(n, void 0, [])();
  function l(a, c, u) {
    const h = (
      /** @type {Record<string, unknown>} */
      a && typeof a == "object" ? a : {}
    );
    if (typeof h.type == "string") {
      const d = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(f, "name", {
        value: "node (" + (a.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return f;
    function f() {
      let d = VT, p, m, g;
      if ((!e || s(a, c, u[u.length - 1] || void 0)) && (d = qW(t(a, u)), d[0] === Ny))
        return d;
      if ("children" in a && a.children) {
        const b = (
          /** @type {UnistParent} */
          a
        );
        if (b.children && d[0] !== Ry)
          for (m = (r ? b.children.length : -1) + o, g = u.concat(b); m > -1 && m < b.children.length; ) {
            const w = b.children[m];
            if (p = l(w, m, g)(), p[0] === Ny)
              return p;
            m = typeof p[1] == "number" ? p[1] : m + o;
          }
      }
      return d;
    }
  }
}
function qW(n) {
  return Array.isArray(n) ? n : typeof n == "number" ? [VW, n] : n == null ? VT : [n];
}
function Sl(n, e, t, r) {
  let i, s, o;
  typeof e == "function" && typeof t != "function" ? (s = void 0, o = e, i = t) : (s = e, o = t, i = r), z3(n, s, l, i);
  function l(a, c) {
    const u = c[c.length - 1], h = u ? u.children.indexOf(a) : void 0;
    return o(a, h, u);
  }
}
function qT(n, e) {
  let t = !1;
  return Sl(n, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return t = !0, Ny;
  }), !!((!n.depth || n.depth < 3) && P3(n) && (e.options.setext || t));
}
function WW(n, e, t, r) {
  const i = Math.max(Math.min(6, n.depth || 1), 1), s = t.createTracker(r);
  if (qT(n, t)) {
    const u = t.enter("headingSetext"), h = t.enter("phrasing"), f = t.containerPhrasing(n, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return h(), u(), f + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), l = t.enter("headingAtx"), a = t.enter("phrasing");
  s.move(o + " ");
  let c = t.containerPhrasing(n, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(c) && (c = fl(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, t.options.closeAtx && (c += " " + o), a(), l(), c;
}
WT.peek = jW;
function WT(n) {
  return n.value || "";
}
function jW() {
  return "<";
}
jT.peek = UW;
function jT(n, e, t, r) {
  const i = B3(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.enter("image");
  let l = t.enter("label");
  const a = t.createTracker(r);
  let c = a.move("![");
  return c += a.move(
    t.safe(n.alt, { before: c, after: "]", ...a.current() })
  ), c += a.move("]("), l(), // If there’s no url but there is a title…
  !n.url && n.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (l = t.enter("destinationLiteral"), c += a.move("<"), c += a.move(
    t.safe(n.url, { before: c, after: ">", ...a.current() })
  ), c += a.move(">")) : (l = t.enter("destinationRaw"), c += a.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : ")",
      ...a.current()
    })
  )), l(), n.title && (l = t.enter(`title${s}`), c += a.move(" " + i), c += a.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...a.current()
    })
  ), c += a.move(i), l()), c += a.move(")"), o(), c;
}
function UW() {
  return "!";
}
UT.peek = KW;
function UT(n, e, t, r) {
  const i = n.referenceType, s = t.enter("imageReference");
  let o = t.enter("label");
  const l = t.createTracker(r);
  let a = l.move("![");
  const c = t.safe(n.alt, {
    before: a,
    after: "]",
    ...l.current()
  });
  a += l.move(c + "]["), o();
  const u = t.stack;
  t.stack = [], o = t.enter("reference");
  const h = t.safe(t.associationId(n), {
    before: a,
    after: "]",
    ...l.current()
  });
  return o(), t.stack = u, s(), i === "full" || !c || c !== h ? a += l.move(h + "]") : i === "shortcut" ? a = a.slice(0, -1) : a += l.move("]"), a;
}
function KW() {
  return "!";
}
KT.peek = GW;
function KT(n, e, t) {
  let r = n.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < t.unsafe.length; ) {
    const o = t.unsafe[s], l = t.compilePattern(o);
    let a;
    if (o.atBreak)
      for (; a = l.exec(r); ) {
        let c = a.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(a.index + 1);
      }
  }
  return i + r + i;
}
function GW() {
  return "`";
}
function GT(n, e) {
  const t = P3(n);
  return !!(!e.options.resourceLink && // If there’s a url…
  n.url && // And there’s a no title…
  !n.title && // And the content of `node` is a single text node…
  n.children && n.children.length === 1 && n.children[0].type === "text" && // And if the url is the same as the content…
  (t === n.url || "mailto:" + t === n.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(n.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(n.url));
}
YT.peek = YW;
function YT(n, e, t, r) {
  const i = B3(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.createTracker(r);
  let l, a;
  if (GT(n, t)) {
    const u = t.stack;
    t.stack = [], l = t.enter("autolink");
    let h = o.move("<");
    return h += o.move(
      t.containerPhrasing(n, {
        before: h,
        after: ">",
        ...o.current()
      })
    ), h += o.move(">"), l(), t.stack = u, h;
  }
  l = t.enter("link"), a = t.enter("label");
  let c = o.move("[");
  return c += o.move(
    t.containerPhrasing(n, {
      before: c,
      after: "](",
      ...o.current()
    })
  ), c += o.move("]("), a(), // If there’s no url but there is a title…
  !n.url && n.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (a = t.enter("destinationLiteral"), c += o.move("<"), c += o.move(
    t.safe(n.url, { before: c, after: ">", ...o.current() })
  ), c += o.move(">")) : (a = t.enter("destinationRaw"), c += o.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : ")",
      ...o.current()
    })
  )), a(), n.title && (a = t.enter(`title${s}`), c += o.move(" " + i), c += o.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...o.current()
    })
  ), c += o.move(i), a()), c += o.move(")"), l(), c;
}
function YW(n, e, t) {
  return GT(n, t) ? "<" : "[";
}
JT.peek = JW;
function JT(n, e, t, r) {
  const i = n.referenceType, s = t.enter("linkReference");
  let o = t.enter("label");
  const l = t.createTracker(r);
  let a = l.move("[");
  const c = t.containerPhrasing(n, {
    before: a,
    after: "]",
    ...l.current()
  });
  a += l.move(c + "]["), o();
  const u = t.stack;
  t.stack = [], o = t.enter("reference");
  const h = t.safe(t.associationId(n), {
    before: a,
    after: "]",
    ...l.current()
  });
  return o(), t.stack = u, s(), i === "full" || !c || c !== h ? a += l.move(h + "]") : i === "shortcut" ? a = a.slice(0, -1) : a += l.move("]"), a;
}
function JW() {
  return "[";
}
function F3(n) {
  const e = n.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function XW(n) {
  const e = F3(n), t = n.options.bulletOther;
  if (!t)
    return e === "*" ? "-" : "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (t === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + t + "`) to be different"
    );
  return t;
}
function ZW(n) {
  const e = n.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function XT(n) {
  const e = n.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function QW(n, e, t, r) {
  const i = t.enter("list"), s = t.bulletCurrent;
  let o = n.ordered ? ZW(t) : F3(t);
  const l = n.ordered ? o === "." ? ")" : "." : XW(t);
  let a = e && t.bulletLastUsed ? o === t.bulletLastUsed : !1;
  if (!n.ordered) {
    const u = n.children ? n.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      t.stack[t.stack.length - 1] === "list" && t.stack[t.stack.length - 2] === "listItem" && t.stack[t.stack.length - 3] === "list" && t.stack[t.stack.length - 4] === "listItem" && // That are each the first child.
      t.indexStack[t.indexStack.length - 1] === 0 && t.indexStack[t.indexStack.length - 2] === 0 && t.indexStack[t.indexStack.length - 3] === 0 && (a = !0), XT(t) === o && u
    ) {
      let h = -1;
      for (; ++h < n.children.length; ) {
        const f = n.children[h];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          a = !0;
          break;
        }
      }
    }
  }
  a && (o = l), t.bulletCurrent = o;
  const c = t.containerFlow(n, r);
  return t.bulletLastUsed = o, t.bulletCurrent = s, i(), c;
}
function ej(n) {
  const e = n.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function tj(n, e, t, r) {
  const i = ej(t);
  let s = t.bulletCurrent || F3(t);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (t.options.incrementListMarker === !1 ? 0 : e.children.indexOf(n)) + s);
  let o = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || n.spread)) && (o = Math.ceil(o / 4) * 4);
  const l = t.createTracker(r);
  l.move(s + " ".repeat(o - s.length)), l.shift(o);
  const a = t.enter("listItem"), c = t.indentLines(
    t.containerFlow(n, l.current()),
    u
  );
  return a(), c;
  function u(h, f, d) {
    return f ? (d ? "" : " ".repeat(o)) + h : (d ? s : s + " ".repeat(o - s.length)) + h;
  }
}
function nj(n, e, t, r) {
  const i = t.enter("paragraph"), s = t.enter("phrasing"), o = t.containerPhrasing(n, r);
  return s(), i(), o;
}
const rj = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  w1([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function ij(n, e, t, r) {
  return (n.children.some(function(o) {
    return rj(o);
  }) ? t.containerPhrasing : t.containerFlow).call(t, n, r);
}
function sj(n) {
  const e = n.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
ZT.peek = oj;
function ZT(n, e, t, r) {
  const i = sj(t), s = t.enter("strong"), o = t.createTracker(r), l = o.move(i + i);
  let a = o.move(
    t.containerPhrasing(n, {
      after: i,
      before: l,
      ...o.current()
    })
  );
  const c = a.charCodeAt(0), u = pm(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (a = fl(c) + a.slice(1));
  const h = a.charCodeAt(a.length - 1), f = pm(r.after.charCodeAt(0), h, i);
  f.inside && (a = a.slice(0, -1) + fl(h));
  const d = o.move(i + i);
  return s(), t.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, l + a + d;
}
function oj(n, e, t) {
  return t.options.strong || "*";
}
function lj(n, e, t, r) {
  return t.safe(n.value, r);
}
function aj(n) {
  const e = n.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function cj(n, e, t) {
  const r = (XT(t) + (t.options.ruleSpaces ? " " : "")).repeat(aj(t));
  return t.options.ruleSpaces ? r.slice(0, -1) : r;
}
const H3 = {
  blockquote: EW,
  break: xx,
  code: NW,
  definition: PW,
  emphasis: $T,
  hardBreak: xx,
  heading: WW,
  html: WT,
  image: jT,
  imageReference: UT,
  inlineCode: KT,
  link: YT,
  linkReference: JT,
  list: QW,
  listItem: tj,
  paragraph: nj,
  root: ij,
  strong: ZT,
  text: lj,
  thematicBreak: cj
}, uj = [hj];
function hj(n, e, t, r) {
  if (e.type === "code" && Dy(e, r) && (n.type === "list" || n.type === e.type && Dy(n, r)))
    return !1;
  if ("spread" in t && typeof t.spread == "boolean")
    return n.type === "paragraph" && // Two paragraphs.
    (n.type === e.type || e.type === "definition" || // Paragraph followed by a setext heading.
    e.type === "heading" && qT(e, r)) ? void 0 : t.spread ? 1 : 0;
}
const Nl = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
], fj = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: `
`,
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: Nl
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: !0, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)` },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: Nl
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: !0, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: !0, character: "*", after: `(?:[ 	\r
*])` },
  { character: "*", inConstruct: "phrasing", notInConstruct: Nl },
  // A plus sign could start a list item.
  { atBreak: !0, character: "+", after: `(?:[ 	\r
])` },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: !0, character: "-", after: `(?:[ 	\r
-])` },
  // A dot could start a list item.
  { atBreak: !0, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)` },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: Nl
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: !0, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: !0, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: !0, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: Nl },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: !0, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: Nl },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: !0, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: Nl },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: !0, character: "~" }
];
function dj(n) {
  return n.label || !n.identifier ? n.label || "" : _T(n.identifier);
}
function pj(n) {
  if (!n._compiled) {
    const e = (n.atBreak ? "[\\r\\n][\\t ]*" : "") + (n.before ? "(?:" + n.before + ")" : "");
    n._compiled = new RegExp(
      (e ? "(" + e + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(n.character) ? "\\" : "") + n.character + (n.after ? "(?:" + n.after + ")" : ""),
      "g"
    );
  }
  return n._compiled;
}
function mj(n, e, t) {
  const r = e.indexStack, i = n.children || [], s = [];
  let o = -1, l = t.before, a;
  r.push(-1);
  let c = e.createTracker(t);
  for (; ++o < i.length; ) {
    const u = i[o];
    let h;
    if (r[r.length - 1] = o, o + 1 < i.length) {
      let p = e.handle.handlers[i[o + 1].type];
      p && p.peek && (p = p.peek), h = p ? p(i[o + 1], n, e, {
        before: "",
        after: "",
        ...c.current()
      }).charAt(0) : "";
    } else
      h = t.after;
    s.length > 0 && (l === "\r" || l === `
`) && u.type === "html" && (s[s.length - 1] = s[s.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), l = " ", c = e.createTracker(t), c.move(s.join("")));
    let f = e.handle(u, n, e, {
      ...c.current(),
      after: h,
      before: l
    });
    a && a === f.slice(0, 1) && (f = fl(a.charCodeAt(0)) + f.slice(1));
    const d = e.attentionEncodeSurroundingInfo;
    e.attentionEncodeSurroundingInfo = void 0, a = void 0, d && (s.length > 0 && d.before && l === s[s.length - 1].slice(-1) && (s[s.length - 1] = s[s.length - 1].slice(0, -1) + fl(l.charCodeAt(0))), d.after && (a = h)), c.move(f), s.push(f), l = f.slice(-1);
  }
  return r.pop(), s.join("");
}
function gj(n, e, t) {
  const r = e.indexStack, i = n.children || [], s = e.createTracker(t), o = [];
  let l = -1;
  for (r.push(-1); ++l < i.length; ) {
    const a = i[l];
    r[r.length - 1] = l, o.push(
      s.move(
        e.handle(a, n, e, {
          before: `
`,
          after: `
`,
          ...s.current()
        })
      )
    ), a.type !== "list" && (e.bulletLastUsed = void 0), l < i.length - 1 && o.push(
      s.move(yj(a, i[l + 1], n, e))
    );
  }
  return r.pop(), o.join("");
}
function yj(n, e, t, r) {
  let i = r.join.length;
  for (; i--; ) {
    const s = r.join[i](n, e, t, r);
    if (s === !0 || s === 1)
      break;
    if (typeof s == "number")
      return `
`.repeat(1 + s);
    if (s === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const bj = /\r?\n|\r/g;
function vj(n, e) {
  const t = [];
  let r = 0, i = 0, s;
  for (; s = bj.exec(n); )
    o(n.slice(r, s.index)), t.push(s[0]), r = s.index + s[0].length, i++;
  return o(n.slice(r)), t.join("");
  function o(l) {
    t.push(e(l, i, !l));
  }
}
function wj(n, e, t) {
  const r = (t.before || "") + (e || "") + (t.after || ""), i = [], s = [], o = {};
  let l = -1;
  for (; ++l < n.unsafe.length; ) {
    const u = n.unsafe[l];
    if (!FT(n.stack, u))
      continue;
    const h = n.compilePattern(u);
    let f;
    for (; f = h.exec(r); ) {
      const d = "before" in u || !!u.atBreak, p = "after" in u, m = f.index + (d ? f[1].length : 0);
      i.includes(m) ? (o[m].before && !d && (o[m].before = !1), o[m].after && !p && (o[m].after = !1)) : (i.push(m), o[m] = { before: d, after: p });
    }
  }
  i.sort(xj);
  let a = t.before ? t.before.length : 0;
  const c = r.length - (t.after ? t.after.length : 0);
  for (l = -1; ++l < i.length; ) {
    const u = i[l];
    u < a || u >= c || u + 1 < c && i[l + 1] === u + 1 && o[u].after && !o[u + 1].before && !o[u + 1].after || i[l - 1] === u - 1 && o[u].before && !o[u - 1].before && !o[u - 1].after || (a !== u && s.push(kx(r.slice(a, u), "\\")), a = u, /[!-/:-@[-`{-~]/.test(r.charAt(u)) && (!t.encode || !t.encode.includes(r.charAt(u))) ? s.push("\\") : (s.push(fl(r.charCodeAt(u))), a++));
  }
  return s.push(kx(r.slice(a, c), t.after)), s.join("");
}
function xj(n, e) {
  return n - e;
}
function kx(n, e) {
  const t = /\\(?=[!-/:-@[-`{-~])/g, r = [], i = [], s = n + e;
  let o = -1, l = 0, a;
  for (; a = t.exec(s); )
    r.push(a.index);
  for (; ++o < r.length; )
    l !== r[o] && i.push(n.slice(l, r[o])), i.push("\\"), l = r[o];
  return i.push(n.slice(l)), i.join("");
}
function kj(n) {
  const e = n || {}, t = e.now || {};
  let r = e.lineShift || 0, i = t.line || 1, s = t.column || 1;
  return { move: a, current: o, shift: l };
  function o() {
    return { now: { line: i, column: s }, lineShift: r };
  }
  function l(c) {
    r += c;
  }
  function a(c) {
    const u = c || "", h = u.split(/\r?\n|\r/g), f = h[h.length - 1];
    return i += h.length - 1, s = h.length === 1 ? s + f.length : 1 + f.length + r, u;
  }
}
function Sj(n, e) {
  const t = e || {}, r = {
    associationId: dj,
    containerPhrasing: Aj,
    containerFlow: Oj,
    createTracker: kj,
    compilePattern: pj,
    enter: s,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...H3 },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines: vj,
    indexStack: [],
    join: [...uj],
    options: {},
    safe: Ej,
    stack: [],
    unsafe: [...fj]
  };
  zT(r, t), r.options.tightDefinitions && r.join.push(Tj), r.handle = TW("type", {
    invalid: Cj,
    unknown: Mj,
    handlers: r.handlers
  });
  let i = r.handle(n, void 0, r, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  return i && i.charCodeAt(i.length - 1) !== 10 && i.charCodeAt(i.length - 1) !== 13 && (i += `
`), i;
  function s(o) {
    return r.stack.push(o), l;
    function l() {
      r.stack.pop();
    }
  }
}
function Cj(n) {
  throw new Error("Cannot handle value `" + n + "`, expected node");
}
function Mj(n) {
  const e = (
    /** @type {Nodes} */
    n
  );
  throw new Error("Cannot handle unknown node `" + e.type + "`");
}
function Tj(n, e) {
  if (n.type === "definition" && n.type === e.type)
    return 0;
}
function Aj(n, e) {
  return mj(n, this, e);
}
function Oj(n, e) {
  return gj(n, this, e);
}
function Ej(n, e) {
  return wj(this, n, e);
}
function Py(n) {
  const e = this;
  e.compiler = t;
  function t(r) {
    return Sj(r, {
      ...e.data("settings"),
      ...n,
      // Note: this option is not in the readme.
      // The goal is for it to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("toMarkdownExtensions") || []
    });
  }
}
function Sx(n) {
  if (n)
    throw n;
}
function Ij(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var i2, Cx;
function Dj() {
  if (Cx) return i2;
  Cx = 1;
  var n = Object.prototype.hasOwnProperty, e = Object.prototype.toString, t = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : e.call(c) === "[object Array]";
  }, s = function(c) {
    if (!c || e.call(c) !== "[object Object]")
      return !1;
    var u = n.call(c, "constructor"), h = c.constructor && c.constructor.prototype && n.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !u && !h)
      return !1;
    var f;
    for (f in c)
      ;
    return typeof f > "u" || n.call(c, f);
  }, o = function(c, u) {
    t && u.name === "__proto__" ? t(c, u.name, {
      enumerable: !0,
      configurable: !0,
      value: u.newValue,
      writable: !0
    }) : c[u.name] = u.newValue;
  }, l = function(c, u) {
    if (u === "__proto__")
      if (n.call(c, u)) {
        if (r)
          return r(c, u).value;
      } else return;
    return c[u];
  };
  return i2 = function a() {
    var c, u, h, f, d, p, m = arguments[0], g = 1, b = arguments.length, w = !1;
    for (typeof m == "boolean" && (w = m, m = arguments[1] || {}, g = 2), (m == null || typeof m != "object" && typeof m != "function") && (m = {}); g < b; ++g)
      if (c = arguments[g], c != null)
        for (u in c)
          h = l(m, u), f = l(c, u), m !== f && (w && f && (s(f) || (d = i(f))) ? (d ? (d = !1, p = h && i(h) ? h : []) : p = h && s(h) ? h : {}, o(m, { name: u, newValue: a(w, p, f) })) : typeof f < "u" && o(m, { name: u, newValue: f }));
    return m;
  }, i2;
}
var Nj = Dj();
const s2 = /* @__PURE__ */ Ij(Nj);
function _y(n) {
  if (typeof n != "object" || n === null)
    return !1;
  const e = Object.getPrototypeOf(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}
function Rj() {
  const n = [], e = { run: t, use: r };
  return e;
  function t(...i) {
    let s = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    l(null, ...i);
    function l(a, ...c) {
      const u = n[++s];
      let h = -1;
      if (a) {
        o(a);
        return;
      }
      for (; ++h < i.length; )
        (c[h] === null || c[h] === void 0) && (c[h] = i[h]);
      i = c, u ? Pj(u, l)(...c) : o(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return n.push(i), e;
  }
}
function Pj(n, e) {
  let t;
  return r;
  function r(...o) {
    const l = n.length > o.length;
    let a;
    l && o.push(i);
    try {
      a = n.apply(this, o);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (l && t)
        throw u;
      return i(u);
    }
    l || (a && a.then && typeof a.then == "function" ? a.then(s, i) : a instanceof Error ? i(a) : s(a));
  }
  function i(o, ...l) {
    t || (t = !0, e(o, ...l));
  }
  function s(o) {
    i(null, o);
  }
}
class Nr extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(e, t, r) {
    super(), typeof t == "string" && (r = t, t = void 0);
    let i = "", s = {}, o = !1;
    if (t && ("line" in t && "column" in t ? s = { place: t } : "start" in t && "end" in t ? s = { place: t } : "type" in t ? s = {
      ancestors: [t],
      place: t.position
    } : s = { ...t }), typeof e == "string" ? i = e : !s.cause && e && (o = !0, i = e.message, s.cause = e), !s.ruleId && !s.source && typeof r == "string") {
      const a = r.indexOf(":");
      a === -1 ? s.ruleId = r : (s.source = r.slice(0, a), s.ruleId = r.slice(a + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const a = s.ancestors[s.ancestors.length - 1];
      a && (s.place = a.position);
    }
    const l = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = l ? l.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = l ? l.line : void 0, this.name = jh(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = o && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
Nr.prototype.file = "";
Nr.prototype.name = "";
Nr.prototype.reason = "";
Nr.prototype.message = "";
Nr.prototype.stack = "";
Nr.prototype.column = void 0;
Nr.prototype.line = void 0;
Nr.prototype.ancestors = void 0;
Nr.prototype.cause = void 0;
Nr.prototype.fatal = void 0;
Nr.prototype.place = void 0;
Nr.prototype.ruleId = void 0;
Nr.prototype.source = void 0;
const ts = { basename: _j, dirname: Lj, extname: Bj, join: zj, sep: "/" };
function _j(n, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  dd(n);
  let t = 0, r = -1, i = n.length, s;
  if (e === void 0 || e.length === 0 || e.length > n.length) {
    for (; i--; )
      if (n.codePointAt(i) === 47) {
        if (s) {
          t = i + 1;
          break;
        }
      } else r < 0 && (s = !0, r = i + 1);
    return r < 0 ? "" : n.slice(t, r);
  }
  if (e === n)
    return "";
  let o = -1, l = e.length - 1;
  for (; i--; )
    if (n.codePointAt(i) === 47) {
      if (s) {
        t = i + 1;
        break;
      }
    } else
      o < 0 && (s = !0, o = i + 1), l > -1 && (n.codePointAt(i) === e.codePointAt(l--) ? l < 0 && (r = i) : (l = -1, r = o));
  return t === r ? r = o : r < 0 && (r = n.length), n.slice(t, r);
}
function Lj(n) {
  if (dd(n), n.length === 0)
    return ".";
  let e = -1, t = n.length, r;
  for (; --t; )
    if (n.codePointAt(t) === 47) {
      if (r) {
        e = t;
        break;
      }
    } else r || (r = !0);
  return e < 0 ? n.codePointAt(0) === 47 ? "/" : "." : e === 1 && n.codePointAt(0) === 47 ? "//" : n.slice(0, e);
}
function Bj(n) {
  dd(n);
  let e = n.length, t = -1, r = 0, i = -1, s = 0, o;
  for (; e--; ) {
    const l = n.codePointAt(e);
    if (l === 47) {
      if (o) {
        r = e + 1;
        break;
      }
      continue;
    }
    t < 0 && (o = !0, t = e + 1), l === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1);
  }
  return i < 0 || t < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && i === t - 1 && i === r + 1 ? "" : n.slice(i, t);
}
function zj(...n) {
  let e = -1, t;
  for (; ++e < n.length; )
    dd(n[e]), n[e] && (t = t === void 0 ? n[e] : t + "/" + n[e]);
  return t === void 0 ? "." : Fj(t);
}
function Fj(n) {
  dd(n);
  const e = n.codePointAt(0) === 47;
  let t = Hj(n, !e);
  return t.length === 0 && !e && (t = "."), t.length > 0 && n.codePointAt(n.length - 1) === 47 && (t += "/"), e ? "/" + t : t;
}
function Hj(n, e) {
  let t = "", r = 0, i = -1, s = 0, o = -1, l, a;
  for (; ++o <= n.length; ) {
    if (o < n.length)
      l = n.codePointAt(o);
    else {
      if (l === 47)
        break;
      l = 47;
    }
    if (l === 47) {
      if (!(i === o - 1 || s === 1)) if (i !== o - 1 && s === 2) {
        if (t.length < 2 || r !== 2 || t.codePointAt(t.length - 1) !== 46 || t.codePointAt(t.length - 2) !== 46) {
          if (t.length > 2) {
            if (a = t.lastIndexOf("/"), a !== t.length - 1) {
              a < 0 ? (t = "", r = 0) : (t = t.slice(0, a), r = t.length - 1 - t.lastIndexOf("/")), i = o, s = 0;
              continue;
            }
          } else if (t.length > 0) {
            t = "", r = 0, i = o, s = 0;
            continue;
          }
        }
        e && (t = t.length > 0 ? t + "/.." : "..", r = 2);
      } else
        t.length > 0 ? t += "/" + n.slice(i + 1, o) : t = n.slice(i + 1, o), r = o - i - 1;
      i = o, s = 0;
    } else l === 46 && s > -1 ? s++ : s = -1;
  }
  return t;
}
function dd(n) {
  if (typeof n != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(n)
    );
}
const $j = { cwd: Vj };
function Vj() {
  return "/";
}
function Ly(n) {
  return !!(n !== null && typeof n == "object" && "href" in n && n.href && "protocol" in n && n.protocol && // @ts-expect-error: indexing is fine.
  n.auth === void 0);
}
function qj(n) {
  if (typeof n == "string")
    n = new URL(n);
  else if (!Ly(n)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + n + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (n.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return Wj(n);
}
function Wj(n) {
  if (n.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = n.pathname;
  let t = -1;
  for (; ++t < e.length; )
    if (e.codePointAt(t) === 37 && e.codePointAt(t + 1) === 50) {
      const r = e.codePointAt(t + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(e);
}
const o2 = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class jj {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let t;
    e ? Ly(e) ? t = { path: e } : typeof e == "string" || Uj(e) ? t = { value: e } : t = e : t = {}, this.cwd = "cwd" in t ? "" : $j.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < o2.length; ) {
      const s = o2[r];
      s in t && t[s] !== void 0 && t[s] !== null && (this[s] = s === "history" ? [...t[s]] : t[s]);
    }
    let i;
    for (i in t)
      o2.includes(i) || (this[i] = t[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? ts.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(e) {
    a2(e, "basename"), l2(e, "basename"), this.path = ts.join(this.dirname || "", e);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? ts.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(e) {
    Mx(this.basename, "dirname"), this.path = ts.join(e || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? ts.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(e) {
    if (l2(e, "extname"), Mx(this.dirname, "extname"), e) {
      if (e.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = ts.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(e) {
    Ly(e) && (e = qj(e)), a2(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? ts.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(e) {
    a2(e, "stem"), l2(e, "stem"), this.path = ts.join(this.dirname || "", e + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, t, r) {
    const i = this.message(e, t, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, t, r) {
    const i = this.message(e, t, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, t, r) {
    const i = new Nr(
      // @ts-expect-error: the overloads are fine.
      e,
      t,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value);
  }
}
function l2(n, e) {
  if (n && n.includes(ts.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + ts.sep + "`"
    );
}
function a2(n, e) {
  if (!n)
    throw new Error("`" + e + "` cannot be empty");
}
function Mx(n, e) {
  if (!n)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function Uj(n) {
  return !!(n && typeof n == "object" && "byteLength" in n && "byteOffset" in n);
}
const Kj = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(n) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[n], s = function() {
      return i.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, r), s;
  })
), Gj = {}.hasOwnProperty;
class $3 extends Kj {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Rj();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const e = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new $3()
    );
    let t = -1;
    for (; ++t < this.attachers.length; ) {
      const r = this.attachers[t];
      e.use(...r);
    }
    return e.data(s2(!0, {}, this.namespace)), e;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(e, t) {
    return typeof e == "string" ? arguments.length === 2 ? (h2("data", this.frozen), this.namespace[e] = t, this) : Gj.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (h2("data", this.frozen), this.namespace = e, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const e = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [t, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = t.call(e, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(e) {
    this.freeze();
    const t = p0(e), r = this.parser || this.Parser;
    return c2("parse", r), r(String(t), t);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(e, t) {
    const r = this;
    return this.freeze(), c2("process", this.parser || this.Parser), u2("process", this.compiler || this.Compiler), t ? i(void 0, t) : new Promise(i);
    function i(s, o) {
      const l = p0(e), a = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(l)
      );
      r.run(a, l, function(u, h, f) {
        if (u || !h || !f)
          return c(u);
        const d = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), p = r.stringify(d, f);
        Jj(p) ? f.value = p : f.result = p, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          f
        );
      });
      function c(u, h) {
        u || !h ? o(u) : s ? s(h) : t(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(e) {
    let t = !1, r;
    return this.freeze(), c2("processSync", this.parser || this.Parser), u2("processSync", this.compiler || this.Compiler), this.process(e, i), Ax("processSync", "process", t), r;
    function i(s, o) {
      t = !0, Sx(s), r = o;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(e, t, r) {
    Tx(e), this.freeze();
    const i = this.transformers;
    return !r && typeof t == "function" && (r = t, t = void 0), r ? s(void 0, r) : new Promise(s);
    function s(o, l) {
      const a = p0(t);
      i.run(e, a, c);
      function c(u, h, f) {
        const d = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || e
        );
        u ? l(u) : o ? o(d) : r(void 0, d, f);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(e, t) {
    let r = !1, i;
    return this.run(e, t, s), Ax("runSync", "run", r), i;
    function s(o, l) {
      Sx(o), i = l, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(e, t) {
    this.freeze();
    const r = p0(t), i = this.compiler || this.Compiler;
    return u2("stringify", i), Tx(e), i(e, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(e, ...t) {
    const r = this.attachers, i = this.namespace;
    if (h2("use", this.frozen), e != null) if (typeof e == "function")
      a(e, t);
    else if (typeof e == "object")
      Array.isArray(e) ? l(e) : o(e);
    else
      throw new TypeError("Expected usable value, not `" + e + "`");
    return this;
    function s(c) {
      if (typeof c == "function")
        a(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          a(u, h);
        } else
          o(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function o(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      l(c.plugins), c.settings && (i.settings = s2(!0, i.settings, c.settings));
    }
    function l(c) {
      let u = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++u < c.length; ) {
          const h = c[u];
          s(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function a(c, u) {
      let h = -1, f = -1;
      for (; ++h < r.length; )
        if (r[h][0] === c) {
          f = h;
          break;
        }
      if (f === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [d, ...p] = u;
        const m = r[f][1];
        _y(m) && _y(d) && (d = s2(!0, m, d)), r[f] = [c, d, ...p];
      }
    }
  }
}
const By = new $3().freeze();
function c2(n, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + n + "` without `parser`");
}
function u2(n, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + n + "` without `compiler`");
}
function h2(n, e) {
  if (e)
    throw new Error(
      "Cannot call `" + n + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Tx(n) {
  if (!_y(n) || typeof n.type != "string")
    throw new TypeError("Expected node, got `" + n + "`");
}
function Ax(n, e, t) {
  if (!t)
    throw new Error(
      "`" + n + "` finished async. Use `" + e + "` instead"
    );
}
function p0(n) {
  return Yj(n) ? n : new jj(n);
}
function Yj(n) {
  return !!(n && typeof n == "object" && "message" in n && "messages" in n);
}
function Jj(n) {
  return typeof n == "string" || Xj(n);
}
function Xj(n) {
  return !!(n && typeof n == "object" && "byteLength" in n && "byteOffset" in n);
}
var QT = (n) => {
  throw TypeError(n);
}, eA = (n, e, t) => e.has(n) || QT("Cannot " + t), rt = (n, e, t) => (eA(n, e, "read from private field"), t ? t.call(n) : e.get(n)), fn = (n, e, t) => e.has(n) ? QT("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), $t = (n, e, t, r) => (eA(n, e, "write to private field"), e.set(n, t), t), Qi, sh, sp, op, lp, oh, lh, $s, ah, ap, cp, ch, up, uh, hp, fp, tc, Vl, dp, hh;
class tA {
}
class nA {
  constructor() {
    this.elements = [], this.size = () => this.elements.length, this.top = () => this.elements.at(-1), this.push = (e) => {
      this.top()?.push(e);
    }, this.open = (e) => {
      this.elements.push(e);
    }, this.close = () => {
      const e = this.elements.pop();
      if (!e) throw pT();
      return e;
    };
  }
}
class V3 extends tA {
  constructor(e, t, r) {
    super(), this.type = e, this.content = t, this.attrs = r;
  }
  push(e, ...t) {
    this.content.push(e, ...t);
  }
  pop() {
    return this.content.pop();
  }
  static create(e, t, r) {
    return new V3(e, t, r);
  }
}
const zy = class extends nA {
  /// @internal
  constructor(e) {
    super(), fn(this, Qi), fn(this, sh), fn(this, sp), fn(this, op), fn(this, lp), fn(this, oh), fn(this, lh), $t(this, Qi, nt.none), $t(this, sh, (t) => t.isText), $t(this, sp, (t, r) => {
      if (rt(this, sh).call(this, t) && rt(this, sh).call(this, r) && nt.sameSet(t.marks, r.marks))
        return this.schema.text(t.text + r.text, t.marks);
    }), $t(this, op, (t) => {
      const r = Object.values({
        ...this.schema.nodes,
        ...this.schema.marks
      }).find((i) => i.spec.parseMarkdown.match(t));
      if (!r) throw U$(t);
      return r;
    }), $t(this, lp, (t) => {
      const r = rt(this, op).call(this, t);
      r.spec.parseMarkdown.runner(this, t, r);
    }), this.injectRoot = (t, r, i) => (this.openNode(r, i), this.next(t.children), this), this.openNode = (t, r) => (this.open(V3.create(t, [], r)), this), $t(this, oh, () => {
      $t(this, Qi, nt.none);
      const t = this.close();
      return rt(this, lh).call(this, t.type, t.attrs, t.content);
    }), this.closeNode = () => {
      try {
        rt(this, oh).call(this);
      } catch (t) {
        console.error(t);
      }
      return this;
    }, $t(this, lh, (t, r, i) => {
      const s = t.createAndFill(r, i, rt(this, Qi));
      if (!s) throw j$(t, r, i);
      return this.push(s), s;
    }), this.addNode = (t, r, i) => {
      try {
        rt(this, lh).call(this, t, r, i);
      } catch (s) {
        console.error(s);
      }
      return this;
    }, this.openMark = (t, r) => {
      const i = t.create(r);
      return $t(this, Qi, i.addToSet(rt(this, Qi))), this;
    }, this.closeMark = (t) => ($t(this, Qi, t.removeFromSet(rt(this, Qi))), this), this.addText = (t) => {
      try {
        const r = this.top();
        if (!r) throw pT();
        const i = r.pop(), s = this.schema.text(t, rt(this, Qi));
        if (!i)
          return r.push(s), this;
        const o = rt(this, sp).call(this, i, s);
        return o ? (r.push(o), this) : (r.push(i, s), this);
      } catch (r) {
        return console.error(r), this;
      }
    }, this.build = () => {
      let t;
      do
        t = rt(this, oh).call(this);
      while (this.size());
      return t;
    }, this.next = (t = []) => ([t].flat().forEach((r) => rt(this, lp).call(this, r)), this), this.toDoc = () => this.build(), this.run = (t, r) => {
      const i = t.runSync(
        t.parse(r),
        r
      );
      return this.next(i), this;
    }, this.schema = e;
  }
};
Qi = /* @__PURE__ */ new WeakMap();
sh = /* @__PURE__ */ new WeakMap();
sp = /* @__PURE__ */ new WeakMap();
op = /* @__PURE__ */ new WeakMap();
lp = /* @__PURE__ */ new WeakMap();
oh = /* @__PURE__ */ new WeakMap();
lh = /* @__PURE__ */ new WeakMap();
zy.create = (n, e) => {
  const t = new zy(n);
  return (r) => (t.run(e, r), t.toDoc());
};
let Zj = zy;
const Fy = class extends tA {
  constructor(e, t, r, i = {}) {
    super(), this.type = e, this.children = t, this.value = r, this.props = i, this.push = (s, ...o) => {
      this.children || (this.children = []), this.children.push(s, ...o);
    }, this.pop = () => this.children?.pop();
  }
};
Fy.create = (n, e, t, r = {}) => new Fy(n, e, t, r);
let Ox = Fy;
const Qj = (n) => Object.prototype.hasOwnProperty.call(n, "size"), Hy = class extends nA {
  /// @internal
  constructor(e) {
    super(), fn(this, $s), fn(this, ah), fn(this, ap), fn(this, cp), fn(this, ch), fn(this, up), fn(this, uh), fn(this, hp), fn(this, fp), fn(this, tc), fn(this, Vl), fn(this, dp), fn(this, hh), $t(this, $s, nt.none), $t(this, ah, (t) => {
      const r = Object.values({
        ...this.schema.nodes,
        ...this.schema.marks
      }).find((i) => i.spec.toMarkdown.match(t));
      if (!r) throw K$(t.type);
      return r;
    }), $t(this, ap, (t) => rt(this, ah).call(this, t).spec.toMarkdown.runner(this, t)), $t(this, cp, (t, r) => rt(this, ah).call(this, t).spec.toMarkdown.runner(this, t, r)), $t(this, ch, (t) => {
      const { marks: r } = t, i = (l) => l.type.spec.priority ?? 50;
      [...r].sort((l, a) => i(l) - i(a)).every((l) => !rt(this, cp).call(this, l, t)) && rt(this, ap).call(this, t), r.forEach((l) => rt(this, hh).call(this, l));
    }), $t(this, up, (t, r) => {
      if (t.type === r || t.children?.length !== 1) return t;
      const i = (a) => {
        if (a.type === r) return a;
        if (a.children?.length !== 1) return null;
        const [c] = a.children;
        return c ? i(c) : null;
      }, s = i(t);
      if (!s) return t;
      const o = s.children ? [...s.children] : void 0, l = { ...t, children: o };
      return l.children = o, s.children = [l], s;
    }), $t(this, uh, (t) => {
      const { children: r } = t;
      return r && (t.children = r.reduce((i, s, o) => {
        if (o === 0) return [s];
        const l = i.at(-1);
        if (l && l.isMark && s.isMark) {
          s = rt(this, up).call(this, s, l.type);
          const { children: a, ...c } = s, { children: u, ...h } = l;
          if (s.type === l.type && a && u && JSON.stringify(c) === JSON.stringify(h)) {
            const f = {
              ...h,
              children: [...u, ...a]
            };
            return i.slice(0, -1).concat(rt(this, uh).call(this, f));
          }
        }
        return i.concat(s);
      }, [])), t;
    }), $t(this, hp, (t) => {
      const r = {
        ...t.props,
        type: t.type
      };
      return t.children && (r.children = t.children), t.value && (r.value = t.value), r;
    }), this.openNode = (t, r, i) => (this.open(Ox.create(t, void 0, r, i)), this), $t(this, fp, (t, r) => {
      let i = "", s = "";
      const o = t.children;
      let l = -1, a = -1;
      const c = (h) => {
        h && h.forEach((f, d) => {
          f.type === "text" && f.value && (l < 0 && (l = d), a = d);
        });
      };
      if (o) {
        c(o);
        const h = o?.[a], f = o?.[l];
        if (h && h.value.endsWith(" ")) {
          const d = h.value, p = d.trimEnd();
          s = d.slice(p.length), h.value = p;
        }
        if (f && f.value.startsWith(" ")) {
          const d = f.value, p = d.trimStart();
          i = d.slice(0, d.length - p.length), f.value = p;
        }
      }
      i.length && rt(this, Vl).call(this, "text", void 0, i);
      const u = r();
      return s.length && rt(this, Vl).call(this, "text", void 0, s), u;
    }), $t(this, tc, (t = !1) => {
      const r = this.close(), i = () => rt(this, Vl).call(this, r.type, r.children, r.value, r.props);
      return t ? rt(this, fp).call(this, r, i) : i();
    }), this.closeNode = () => (rt(this, tc).call(this), this), $t(this, Vl, (t, r, i, s) => {
      const o = Ox.create(t, r, i, s), l = rt(this, uh).call(this, rt(this, hp).call(this, o));
      return this.push(l), l;
    }), this.addNode = (t, r, i, s) => (rt(this, Vl).call(this, t, r, i, s), this), $t(this, dp, (t, r, i, s) => t.isInSet(rt(this, $s)) ? this : ($t(this, $s, t.addToSet(rt(this, $s))), this.openNode(r, i, { ...s, isMark: !0 }))), $t(this, hh, (t) => {
      t.isInSet(rt(this, $s)) && ($t(this, $s, t.type.removeFromSet(rt(this, $s))), rt(this, tc).call(this, !0));
    }), this.withMark = (t, r, i, s) => (rt(this, dp).call(this, t, r, i, s), this), this.closeMark = (t) => (rt(this, hh).call(this, t), this), this.build = () => {
      let t = null;
      do
        t = rt(this, tc).call(this);
      while (this.size());
      return t;
    }, this.next = (t) => Qj(t) ? (t.forEach((r) => {
      rt(this, ch).call(this, r);
    }), this) : (rt(this, ch).call(this, t), this), this.toString = (t) => t.stringify(this.build()), this.run = (t) => (this.next(t), this), this.schema = e;
  }
};
$s = /* @__PURE__ */ new WeakMap();
ah = /* @__PURE__ */ new WeakMap();
ap = /* @__PURE__ */ new WeakMap();
cp = /* @__PURE__ */ new WeakMap();
ch = /* @__PURE__ */ new WeakMap();
up = /* @__PURE__ */ new WeakMap();
uh = /* @__PURE__ */ new WeakMap();
hp = /* @__PURE__ */ new WeakMap();
fp = /* @__PURE__ */ new WeakMap();
tc = /* @__PURE__ */ new WeakMap();
Vl = /* @__PURE__ */ new WeakMap();
dp = /* @__PURE__ */ new WeakMap();
hh = /* @__PURE__ */ new WeakMap();
Hy.create = (n, e) => {
  const t = new Hy(n);
  return (r) => (t.run(r), t.toString(e));
};
let eU = Hy;
const q3 = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function rA(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const iA = (n, e, t) => {
  let r = rA(n, t);
  if (!r)
    return !1;
  let i = W3(r);
  if (!i) {
    let o = r.blockRange(), l = o && u1(o);
    return l == null ? !1 : (e && e(n.tr.lift(o, l).scrollIntoView()), !0);
  }
  let s = i.nodeBefore;
  if (aA(n, i, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (Fc(s, "end") || $e.isSelectable(s)))
    for (let o = r.depth; ; o--) {
      let l = f1(n.doc, r.before(o), r.after(o), ve.empty);
      if (l && l.slice.size < l.to - l.from) {
        if (e) {
          let a = n.tr.step(l);
          a.setSelection(Fc(s, "end") ? Ge.findFrom(a.doc.resolve(a.mapping.map(i.pos, -1)), -1) : $e.create(a.doc, i.pos - s.nodeSize)), e(a.scrollIntoView());
        }
        return !0;
      }
      if (o == 1 || r.node(o - 1).childCount > 1)
        break;
    }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, tU = (n, e, t) => {
  let r = rA(n, t);
  if (!r)
    return !1;
  let i = W3(r);
  return i ? nU(n, i, e) : !1;
};
function nU(n, e, t) {
  let r = e.nodeBefore, i = r, s = e.pos - 1;
  for (; !i.isTextblock; s--) {
    if (i.type.spec.isolating)
      return !1;
    let u = i.lastChild;
    if (!u)
      return !1;
    i = u;
  }
  let o = e.nodeAfter, l = o, a = e.pos + 1;
  for (; !l.isTextblock; a++) {
    if (l.type.spec.isolating)
      return !1;
    let u = l.firstChild;
    if (!u)
      return !1;
    l = u;
  }
  let c = f1(n.doc, s, a, ve.empty);
  if (!c || c.from != s || c instanceof Cn && c.slice.size >= a - s)
    return !1;
  if (t) {
    let u = n.tr.step(c);
    u.setSelection(Ee.create(u.doc, s)), t(u.scrollIntoView());
  }
  return !0;
}
function Fc(n, e, t = !1) {
  for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (t && r.childCount != 1)
      return !1;
  }
  return !1;
}
const sA = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0)
      return !1;
    s = W3(r);
  }
  let o = s && s.nodeBefore;
  return !o || !$e.isSelectable(o) ? !1 : (e && e(n.tr.setSelection($e.create(n.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function W3(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function rU(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const iU = (n, e, t) => {
  let r = rU(n, t);
  if (!r)
    return !1;
  let i = oA(r);
  if (!i)
    return !1;
  let s = i.nodeAfter;
  if (aA(n, i, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (Fc(s, "start") || $e.isSelectable(s))) {
    let o = f1(n.doc, r.before(), r.after(), ve.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let l = n.tr.step(o);
        l.setSelection(Fc(s, "start") ? Ge.findFrom(l.doc.resolve(l.mapping.map(i.pos)), 1) : $e.create(l.doc, l.mapping.map(i.pos))), e(l.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, sU = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size)
      return !1;
    s = oA(r);
  }
  let o = s && s.nodeAfter;
  return !o || !$e.isSelectable(o) ? !1 : (e && e(n.tr.setSelection($e.create(n.doc, s.pos)).scrollIntoView()), !0);
};
function oA(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const oU = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function j3(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const lA = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(r))
    return !1;
  let i = t.node(-1), s = t.indexAfter(-1), o = j3(i.contentMatchAt(s));
  if (!o || !i.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let l = t.after(), a = n.tr.replaceWith(l, l, o.createAndFill());
    a.setSelection(Ge.near(a.doc.resolve(l), 1)), e(a.scrollIntoView());
  }
  return !0;
}, lU = (n, e) => {
  let t = n.selection, { $from: r, $to: i } = t;
  if (t instanceof Or || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let s = j3(i.parent.contentMatchAt(i.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, l = n.tr.insert(o, s.createAndFill());
    l.setSelection(Ee.create(l.doc, o + 1)), e(l.scrollIntoView());
  }
  return !0;
}, aU = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let s = t.before();
    if (qh(n.doc, s))
      return e && e(n.tr.split(s).scrollIntoView()), !0;
  }
  let r = t.blockRange(), i = r && u1(r);
  return i == null ? !1 : (e && e(n.tr.lift(r, i).scrollIntoView()), !0);
};
function cU(n) {
  return (e, t) => {
    let { $from: r, $to: i } = e.selection;
    if (e.selection instanceof $e && e.selection.node.isBlock)
      return !r.parentOffset || !qh(e.doc, r.pos) ? !1 : (t && t(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let s = [], o, l, a = !1, c = !1;
    for (let d = r.depth; ; d--)
      if (r.node(d).isBlock) {
        a = r.end(d) == r.pos + (r.depth - d), c = r.start(d) == r.pos - (r.depth - d), l = j3(r.node(d - 1).contentMatchAt(r.indexAfter(d - 1))), s.unshift(a && l ? { type: l } : null), o = d;
        break;
      } else {
        if (d == 1)
          return !1;
        s.unshift(null);
      }
    let u = e.tr;
    (e.selection instanceof Ee || e.selection instanceof Or) && u.deleteSelection();
    let h = u.mapping.map(r.pos), f = qh(u.doc, h, s.length, s);
    if (f || (s[0] = l ? { type: l } : null, f = qh(u.doc, h, s.length, s)), !f)
      return !1;
    if (u.split(h, s.length, s), !a && c && r.node(o).type != l) {
      let d = u.mapping.map(r.before(o)), p = u.doc.resolve(d);
      l && r.node(o - 1).canReplaceWith(p.index(), p.index() + 1, l) && u.setNodeMarkup(u.mapping.map(r.before(o)), l);
    }
    return t && t(u.scrollIntoView()), !0;
  };
}
const uU = cU(), hU = (n, e) => (e && e(n.tr.setSelection(new Or(n.doc))), !0);
function fU(n, e, t) {
  let r = e.nodeBefore, i = e.nodeAfter, s = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || h1(n.doc, e.pos)) ? !1 : (t && t(n.tr.join(e.pos).scrollIntoView()), !0);
}
function aA(n, e, t, r) {
  let i = e.nodeBefore, s = e.nodeAfter, o, l, a = i.type.spec.isolating || s.type.spec.isolating;
  if (!a && fU(n, e, t))
    return !0;
  let c = !a && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (o = (l = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && l.matchType(o[0] || s.type).validEnd) {
    if (t) {
      let d = e.pos + s.nodeSize, p = ce.empty;
      for (let b = o.length - 1; b >= 0; b--)
        p = ce.from(o[b].create(null, p));
      p = ce.from(i.copy(p));
      let m = n.tr.step(new Yn(e.pos - 1, d, e.pos, d, new ve(p, 1, 0), o.length, !0)), g = m.doc.resolve(d + 2 * o.length);
      g.nodeAfter && g.nodeAfter.type == i.type && h1(m.doc, g.pos) && m.join(g.pos), t(m.scrollIntoView());
    }
    return !0;
  }
  let u = s.type.spec.isolating || r > 0 && a ? null : Ge.findFrom(e, 1), h = u && u.$from.blockRange(u.$to), f = h && u1(h);
  if (f != null && f >= e.depth)
    return t && t(n.tr.lift(h, f).scrollIntoView()), !0;
  if (c && Fc(s, "start", !0) && Fc(i, "end")) {
    let d = i, p = [];
    for (; p.push(d), !d.isTextblock; )
      d = d.lastChild;
    let m = s, g = 1;
    for (; !m.isTextblock; m = m.firstChild)
      g++;
    if (d.canReplace(d.childCount, d.childCount, m.content)) {
      if (t) {
        let b = ce.empty;
        for (let k = p.length - 1; k >= 0; k--)
          b = ce.from(p[k].copy(b));
        let w = n.tr.step(new Yn(e.pos - p.length, e.pos + s.nodeSize, e.pos + g, e.pos + s.nodeSize - g, new ve(b, p.length, 0), 0, !0));
        t(w.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function cA(n) {
  return function(e, t) {
    let r = e.selection, i = n < 0 ? r.$from : r.$to, s = i.depth;
    for (; i.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return i.node(s).isTextblock ? (t && t(e.tr.setSelection(Ee.create(e.doc, n < 0 ? i.start(s) : i.end(s)))), !0) : !1;
  };
}
const dU = cA(-1), pU = cA(1);
function U3(n, e = null) {
  return function(t, r) {
    let { $from: i, $to: s } = t.selection, o = i.blockRange(s), l = o && O3(o, n, e);
    return l ? (r && r(t.tr.wrap(o, l).scrollIntoView()), !0) : !1;
  };
}
function Lf(n, e = null) {
  return function(t, r) {
    let i = !1;
    for (let s = 0; s < t.selection.ranges.length && !i; s++) {
      let { $from: { pos: o }, $to: { pos: l } } = t.selection.ranges[s];
      t.doc.nodesBetween(o, l, (a, c) => {
        if (i)
          return !1;
        if (!(!a.isTextblock || a.hasMarkup(n, e)))
          if (a.type == n)
            i = !0;
          else {
            let u = t.doc.resolve(c), h = u.index();
            i = u.parent.canReplaceWith(h, h + 1, n);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let s = t.tr;
      for (let o = 0; o < t.selection.ranges.length; o++) {
        let { $from: { pos: l }, $to: { pos: a } } = t.selection.ranges[o];
        s.setBlockType(l, a, n, e);
      }
      r(s.scrollIntoView());
    }
    return !0;
  };
}
function mU(n, e, t, r) {
  for (let i = 0; i < e.length; i++) {
    let { $from: s, $to: o } = e[i], l = s.depth == 0 ? n.inlineContent && n.type.allowsMarkType(t) : !1;
    if (n.nodesBetween(s.pos, o.pos, (a, c) => {
      if (l)
        return !1;
      l = a.inlineContent && a.type.allowsMarkType(t);
    }), l)
      return !0;
  }
  return !1;
}
function k1(n, e = null, t) {
  return function(r, i) {
    let { empty: s, $cursor: o, ranges: l } = r.selection;
    if (s && !o || !mU(r.doc, l, n))
      return !1;
    if (i)
      if (o)
        n.isInSet(r.storedMarks || o.marks()) ? i(r.tr.removeStoredMark(n)) : i(r.tr.addStoredMark(n.create(e)));
      else {
        let a, c = r.tr;
        a = !l.some((u) => r.doc.rangeHasMark(u.$from.pos, u.$to.pos, n));
        for (let u = 0; u < l.length; u++) {
          let { $from: h, $to: f } = l[u];
          if (!a)
            c.removeMark(h.pos, f.pos, n);
          else {
            let d = h.pos, p = f.pos, m = h.nodeAfter, g = f.nodeBefore, b = m && m.isText ? /^\s*/.exec(m.text)[0].length : 0, w = g && g.isText ? /\s*$/.exec(g.text)[0].length : 0;
            d + b < p && (d += b, p -= w), c.addMark(d, p, n.create(e));
          }
        }
        i(c.scrollIntoView());
      }
    return !0;
  };
}
function nu(...n) {
  return function(e, t, r) {
    for (let i = 0; i < n.length; i++)
      if (n[i](e, t, r))
        return !0;
    return !1;
  };
}
let f2 = nu(q3, iA, sA), Ex = nu(q3, iU, sU);
const Gs = {
  Enter: nu(oU, lU, aU, uU),
  "Mod-Enter": lA,
  Backspace: f2,
  "Mod-Backspace": f2,
  "Shift-Backspace": f2,
  Delete: Ex,
  "Mod-Delete": Ex,
  "Mod-a": hU
}, uA = {
  "Ctrl-h": Gs.Backspace,
  "Alt-Backspace": Gs["Mod-Backspace"],
  "Ctrl-d": Gs.Delete,
  "Ctrl-Alt-Backspace": Gs["Mod-Delete"],
  "Alt-Delete": Gs["Mod-Delete"],
  "Alt-d": Gs["Mod-Delete"],
  "Ctrl-a": dU,
  "Ctrl-e": pU
};
for (let n in Gs)
  uA[n] = Gs[n];
const gU = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform ? os.platform() == "darwin" : !1, yU = gU ? uA : Gs, bU = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), vU = typeof navigator < "u" && /Win/.test(navigator.platform);
function wU(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let r, i, s, o;
  for (let l = 0; l < e.length - 1; l++) {
    let a = e[l];
    if (/^(cmd|meta|m)$/i.test(a))
      o = !0;
    else if (/^a(lt)?$/i.test(a))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(a))
      i = !0;
    else if (/^s(hift)?$/i.test(a))
      s = !0;
    else if (/^mod$/i.test(a))
      bU ? o = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + a);
  }
  return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Meta-" + t), s && (t = "Shift-" + t), t;
}
function xU(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[wU(t)] = n[t];
  return e;
}
function d2(n, e, t = !0) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
}
function hA(n) {
  return new Ut({ props: { handleKeyDown: K3(n) } });
}
function K3(n) {
  let e = xU(n);
  return function(t, r) {
    let i = ZS(r), s, o = e[d2(i, r)];
    if (o && o(t.state, t.dispatch, t))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let l = e[d2(i, r, !1)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(vU && r.ctrlKey && r.altKey) && (s = ao[r.keyCode]) && s != i) {
        let l = e[d2(s, r)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const _n = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, Hc = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let $y = null;
const Us = function(n, e, t) {
  let r = $y || ($y = document.createRange());
  return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r;
}, kU = function() {
  $y = null;
}, Ta = function(n, e, t, r) {
  return t && (Ix(n, e, t, r, -1) || Ix(n, e, t, r, 1));
}, SU = /^(img|br|input|textarea|hr)$/i;
function Ix(n, e, t, r, i) {
  for (var s; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : li(n))) {
      let o = n.parentNode;
      if (!o || o.nodeType != 1 || pd(n) || SU.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = _n(n) + (i < 0 ? 0 : 1), n = o;
    } else if (n.nodeType == 1) {
      let o = n.childNodes[e + (i < 0 ? -1 : 0)];
      if (o.nodeType == 1 && o.contentEditable == "false")
        if (!((s = o.pmViewDesc) === null || s === void 0) && s.ignoreForSelection)
          e += i;
        else
          return !1;
      else
        n = o, e = i < 0 ? li(n) : 0;
    } else
      return !1;
  }
}
function li(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function CU(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e - 1], e = li(n);
    } else if (n.parentNode && !pd(n))
      e = _n(n), n = n.parentNode;
    else
      return null;
  }
}
function MU(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e < n.nodeValue.length)
      return n;
    if (n.nodeType == 1 && e < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e], e = 0;
    } else if (n.parentNode && !pd(n))
      e = _n(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
function TU(n, e, t) {
  for (let r = e == 0, i = e == li(n); r || i; ) {
    if (n == t)
      return !0;
    let s = _n(n);
    if (n = n.parentNode, !n)
      return !1;
    r = r && s == 0, i = i && s == li(n);
  }
}
function pd(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const S1 = function(n) {
  return n.focusNode && Ta(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function Yl(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function AU(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function OU(n, e, t) {
  if (n.caretPositionFromPoint)
    try {
      let r = n.caretPositionFromPoint(e, t);
      if (r)
        return { node: r.offsetNode, offset: Math.min(li(r.offsetNode), r.offset) };
    } catch {
    }
  if (n.caretRangeFromPoint) {
    let r = n.caretRangeFromPoint(e, t);
    if (r)
      return { node: r.startContainer, offset: Math.min(li(r.startContainer), r.startOffset) };
  }
}
const xs = typeof navigator < "u" ? navigator : null, Dx = typeof document < "u" ? document : null, Cl = xs && xs.userAgent || "", Vy = /Edge\/(\d+)/.exec(Cl), fA = /MSIE \d/.exec(Cl), qy = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Cl), Er = !!(fA || qy || Vy), nl = fA ? document.documentMode : qy ? +qy[1] : Vy ? +Vy[1] : 0, pi = !Er && /gecko\/(\d+)/i.test(Cl);
pi && +(/Firefox\/(\d+)/.exec(Cl) || [0, 0])[1];
const Wy = !Er && /Chrome\/(\d+)/.exec(Cl), Kn = !!Wy, dA = Wy ? +Wy[1] : 0, dr = !Er && !!xs && /Apple Computer/.test(xs.vendor), $c = dr && (/Mobile\/\w+/.test(Cl) || !!xs && xs.maxTouchPoints > 2), ii = $c || (xs ? /Mac/.test(xs.platform) : !1), EU = xs ? /Win/.test(xs.platform) : !1, Qs = /Android \d/.test(Cl), md = !!Dx && "webkitFontSmoothing" in Dx.documentElement.style, IU = md ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function DU(n) {
  let e = n.defaultView && n.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function Bs(n, e) {
  return typeof n == "number" ? n : n[e];
}
function NU(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * r
  };
}
function Nx(n, e, t) {
  let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, s = n.dom.ownerDocument;
  for (let o = t || n.dom; o; ) {
    if (o.nodeType != 1) {
      o = Hc(o);
      continue;
    }
    let l = o, a = l == s.body, c = a ? DU(s) : NU(l), u = 0, h = 0;
    if (e.top < c.top + Bs(r, "top") ? h = -(c.top - e.top + Bs(i, "top")) : e.bottom > c.bottom - Bs(r, "bottom") && (h = e.bottom - e.top > c.bottom - c.top ? e.top + Bs(i, "top") - c.top : e.bottom - c.bottom + Bs(i, "bottom")), e.left < c.left + Bs(r, "left") ? u = -(c.left - e.left + Bs(i, "left")) : e.right > c.right - Bs(r, "right") && (u = e.right - c.right + Bs(i, "right")), u || h)
      if (a)
        s.defaultView.scrollBy(u, h);
      else {
        let d = l.scrollLeft, p = l.scrollTop;
        h && (l.scrollTop += h), u && (l.scrollLeft += u);
        let m = l.scrollLeft - d, g = l.scrollTop - p;
        e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g };
      }
    let f = a ? "fixed" : getComputedStyle(o).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    o = f == "absolute" ? o.offsetParent : Hc(o);
  }
}
function RU(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i;
  for (let s = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let l = n.root.elementFromPoint(s, o);
    if (!l || l == n.dom || !n.dom.contains(l))
      continue;
    let a = l.getBoundingClientRect();
    if (a.top >= t - 20) {
      r = l, i = a.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: pA(n.dom) };
}
function pA(n) {
  let e = [], t = n.ownerDocument;
  for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = Hc(r))
    ;
  return e;
}
function PU({ refDOM: n, refTop: e, stack: t }) {
  let r = n ? n.getBoundingClientRect().top : 0;
  mA(t, r == 0 ? 0 : r - e);
}
function mA(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: r, top: i, left: s } = n[t];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s);
  }
}
let Ga = null;
function _U(n) {
  if (n.setActive)
    return n.setActive();
  if (Ga)
    return n.focus(Ga);
  let e = pA(n);
  n.focus(Ga == null ? {
    get preventScroll() {
      return Ga = { preventScroll: !0 }, !0;
    }
  } : void 0), Ga || (Ga = !1, mA(e, 0));
}
function gA(n, e) {
  let t, r = 2e8, i, s = 0, o = e.top, l = e.top, a, c;
  for (let u = n.firstChild, h = 0; u; u = u.nextSibling, h++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = Us(u).getClientRects();
    else
      continue;
    for (let d = 0; d < f.length; d++) {
      let p = f[d];
      if (p.top <= o && p.bottom >= l) {
        o = Math.max(p.bottom, o), l = Math.min(p.top, l);
        let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
        if (m < r) {
          t = u, r = m, i = m && t.nodeType == 3 ? {
            left: p.right < e.left ? p.right : p.left,
            top: e.top
          } : e, u.nodeType == 1 && m && (s = h + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
          continue;
        }
      } else p.top > e.top && !a && p.left <= e.left && p.right >= e.left && (a = u, c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top });
      !t && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (s = h + 1);
    }
  }
  return !t && a && (t = a, i = c, r = 0), t && t.nodeType == 3 ? LU(t, i) : !t || r && t.nodeType == 1 ? { node: n, offset: s } : gA(t, i);
}
function LU(n, e) {
  let t = n.nodeValue.length, r = document.createRange();
  for (let i = 0; i < t; i++) {
    r.setEnd(n, i + 1), r.setStart(n, i);
    let s = Ro(r, 1);
    if (s.top != s.bottom && G3(e, s))
      return { node: n, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function G3(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function BU(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function zU(n, e, t) {
  let { node: r, offset: i } = gA(e, t), s = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect();
    s = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(r, i, s);
}
function FU(n, e, t, r) {
  let i = -1;
  for (let s = e, o = !1; s != n.dom; ) {
    let l = n.docView.nearestDesc(s, !0), a;
    if (!l)
      return null;
    if (l.dom.nodeType == 1 && (l.node.isBlock && l.parent || !l.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((a = l.dom.getBoundingClientRect()).width || a.height) && (l.node.isBlock && l.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(l.dom.nodeName) && (!o && a.left > r.left || a.top > r.top ? i = l.posBefore : (!o && a.right < r.left || a.bottom < r.top) && (i = l.posAfter), o = !0), !l.contentDOM && i < 0 && !l.node.isText))
      return (l.node.isBlock ? r.top < (a.top + a.bottom) / 2 : r.left < (a.left + a.right) / 2) ? l.posBefore : l.posAfter;
    s = l.dom.parentNode;
  }
  return i > -1 ? i : n.docView.posFromDOM(e, t, -1);
}
function yA(n, e, t) {
  let r = n.childNodes.length;
  if (r && t.top < t.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = i; ; ) {
      let o = n.childNodes[s];
      if (o.nodeType == 1) {
        let l = o.getClientRects();
        for (let a = 0; a < l.length; a++) {
          let c = l[a];
          if (G3(e, c))
            return yA(o, e, c);
        }
      }
      if ((s = (s + 1) % r) == i)
        break;
    }
  return n;
}
function HU(n, e) {
  let t = n.dom.ownerDocument, r, i = 0, s = OU(t, e.left, e.top);
  s && ({ node: r, offset: i } = s);
  let o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), l;
  if (!o || !n.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = n.dom.getBoundingClientRect();
    if (!G3(e, c) || (o = yA(n.dom, e, c), !o))
      return null;
  }
  if (dr)
    for (let c = o; r && c; c = Hc(c))
      c.draggable && (r = void 0);
  if (o = BU(o, e), r) {
    if (pi && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let u = r.childNodes[i], h;
      u.nodeName == "IMG" && (h = u.getBoundingClientRect()).right <= e.left && h.bottom > e.top && i++;
    }
    let c;
    md && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--, r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? l = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (l = FU(n, r, i, e));
  }
  l == null && (l = zU(n, o, e));
  let a = n.docView.nearestDesc(o, !0);
  return { pos: l, inside: a ? a.posAtStart - a.border : -1 };
}
function Rx(n) {
  return n.top < n.bottom || n.left < n.right;
}
function Ro(n, e) {
  let t = n.getClientRects();
  if (t.length) {
    let r = t[e < 0 ? 0 : t.length - 1];
    if (Rx(r))
      return r;
  }
  return Array.prototype.find.call(t, Rx) || n.getBoundingClientRect();
}
const $U = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function bA(n, e, t) {
  let { node: r, offset: i, atom: s } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = md || pi;
  if (r.nodeType == 3)
    if (o && ($U.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) {
      let a = Ro(Us(r, i, i), t);
      if (pi && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let c = Ro(Us(r, i - 1, i - 1), -1);
        if (c.top == a.top) {
          let u = Ro(Us(r, i, i + 1), -1);
          if (u.top != a.top)
            return Fu(u, u.left < c.left);
        }
      }
      return a;
    } else {
      let a = i, c = i, u = t < 0 ? 1 : -1;
      return t < 0 && !i ? (c++, u = -1) : t >= 0 && i == r.nodeValue.length ? (a--, u = 1) : t < 0 ? a-- : c++, Fu(Ro(Us(r, a, c), u), u < 0);
    }
  if (!n.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (t < 0 || i == li(r))) {
      let a = r.childNodes[i - 1];
      if (a.nodeType == 1)
        return p2(a.getBoundingClientRect(), !1);
    }
    if (s == null && i < li(r)) {
      let a = r.childNodes[i];
      if (a.nodeType == 1)
        return p2(a.getBoundingClientRect(), !0);
    }
    return p2(r.getBoundingClientRect(), t >= 0);
  }
  if (s == null && i && (t < 0 || i == li(r))) {
    let a = r.childNodes[i - 1], c = a.nodeType == 3 ? Us(a, li(a) - (o ? 0 : 1)) : a.nodeType == 1 && (a.nodeName != "BR" || !a.nextSibling) ? a : null;
    if (c)
      return Fu(Ro(c, 1), !1);
  }
  if (s == null && i < li(r)) {
    let a = r.childNodes[i];
    for (; a.pmViewDesc && a.pmViewDesc.ignoreForCoords; )
      a = a.nextSibling;
    let c = a ? a.nodeType == 3 ? Us(a, 0, o ? 0 : 1) : a.nodeType == 1 ? a : null : null;
    if (c)
      return Fu(Ro(c, -1), !0);
  }
  return Fu(Ro(r.nodeType == 3 ? Us(r) : r, -t), t >= 0);
}
function Fu(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function p2(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function vA(n, e, t) {
  let r = n.state, i = n.root.activeElement;
  r != e && n.updateState(e), i != n.dom && n.focus();
  try {
    return t();
  } finally {
    r != e && n.updateState(r), i != n.dom && i && i.focus();
  }
}
function VU(n, e, t) {
  let r = e.selection, i = t == "up" ? r.$from : r.$to;
  return vA(n, e, () => {
    let { node: s } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let l = n.docView.nearestDesc(s, !0);
      if (!l)
        break;
      if (l.node.isBlock) {
        s = l.contentDOM || l.dom;
        break;
      }
      s = l.dom.parentNode;
    }
    let o = bA(n, i.pos, 1);
    for (let l = s.firstChild; l; l = l.nextSibling) {
      let a;
      if (l.nodeType == 1)
        a = l.getClientRects();
      else if (l.nodeType == 3)
        a = Us(l, 0, l.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < a.length; c++) {
        let u = a[c];
        if (u.bottom > u.top + 1 && (t == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const qU = /[\u0590-\u08ac]/;
function WU(n, e, t) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, s = !i, o = i == r.parent.content.size, l = n.domSelection();
  return l ? !qU.test(r.parent.textContent) || !l.modify ? t == "left" || t == "backward" ? s : o : vA(n, e, () => {
    let { focusNode: a, focusOffset: c, anchorNode: u, anchorOffset: h } = n.domSelectionRange(), f = l.caretBidiLevel;
    l.modify("move", t, "character");
    let d = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: p, focusOffset: m } = n.domSelectionRange(), g = p && !d.contains(p.nodeType == 1 ? p : p.parentNode) || a == p && c == m;
    try {
      l.collapse(u, h), a && (a != u || c != h) && l.extend && l.extend(a, c);
    } catch {
    }
    return f != null && (l.caretBidiLevel = f), g;
  }) : r.pos == r.start() || r.pos == r.end();
}
let Px = null, _x = null, Lx = !1;
function jU(n, e, t) {
  return Px == e && _x == t ? Lx : (Px = e, _x = t, Lx = t == "up" || t == "down" ? VU(n, e, t) : WU(n, e, t));
}
const mi = 0, Bx = 1, Ql = 2, ks = 3;
class gd {
  constructor(e, t, r, i) {
    this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = mi, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, r = this.posAtStart; ; t++) {
      let i = this.children[t];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = t > _n(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (i == null && t == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i), o;
      if (s && (!t || s.node))
        if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          r = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let r = t; r; r = r.parent)
      if (r == this)
        return t;
  }
  posFromDOM(e, t, r) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i);
      if (s)
        return s.localPosFromDOM(e, t, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, r = 0; t < this.children.length; t++) {
      let i = this.children[t], s = r + i.size;
      if (r == e && s != r) {
        for (; !i.border && i.children.length; )
          for (let o = 0; o < i.children.length; o++) {
            let l = i.children[o];
            if (l.size) {
              i = l;
              break;
            }
          }
        return i;
      }
      if (e < s)
        return i.descAt(e - r - i.border);
      r = s;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r], l = s + o.size;
      if (l > e || o instanceof xA) {
        i = e - s;
        break;
      }
      s = l;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, t);
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof wA && s.side >= 0; r--)
      ;
    if (t <= 0) {
      let s, o = !0;
      for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = !1)
        ;
      return s && t && o && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : { node: this.contentDOM, offset: s ? _n(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, t) : { node: this.contentDOM, offset: s ? _n(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, s = -1;
    for (let o = r, l = 0; ; l++) {
      let a = this.children[l], c = o + a.size;
      if (i == -1 && e <= c) {
        let u = o + a.border;
        if (e >= u && t <= c - a.border && a.node && a.contentDOM && this.contentDOM.contains(a.contentDOM))
          return a.parseRange(e, t, u);
        e = o;
        for (let h = l; h > 0; h--) {
          let f = this.children[h - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            i = _n(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (c > t || l == this.children.length - 1)) {
        t = c;
        for (let u = l + 1; u < this.children.length; u++) {
          let h = this.children[u];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            s = _n(h.dom);
            break;
          }
          t += h.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = c;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: r } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || r == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, r, i = !1) {
    let s = Math.min(e, t), o = Math.max(e, t);
    for (let d = 0, p = 0; d < this.children.length; d++) {
      let m = this.children[d], g = p + m.size;
      if (s > p && o < g)
        return m.setSelection(e - p - m.border, t - p - m.border, r, i);
      p = g;
    }
    let l = this.domFromPos(e, e ? -1 : 1), a = t == e ? l : this.domFromPos(t, t ? -1 : 1), c = r.root.getSelection(), u = r.domSelectionRange(), h = !1;
    if ((pi || dr) && e == t) {
      let { node: d, offset: p } = l;
      if (d.nodeType == 3) {
        if (h = !!(p && d.nodeValue[p - 1] == `
`), h && p == d.nodeValue.length)
          for (let m = d, g; m; m = m.parentNode) {
            if (g = m.nextSibling) {
              g.nodeName == "BR" && (l = a = { node: g.parentNode, offset: _n(g) + 1 });
              break;
            }
            let b = m.pmViewDesc;
            if (b && b.node && b.node.isBlock)
              break;
          }
      } else {
        let m = d.childNodes[p - 1];
        h = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (pi && u.focusNode && u.focusNode != a.node && u.focusNode.nodeType == 1) {
      let d = u.focusNode.childNodes[u.focusOffset];
      d && d.contentEditable == "false" && (i = !0);
    }
    if (!(i || h && dr) && Ta(l.node, l.offset, u.anchorNode, u.anchorOffset) && Ta(a.node, a.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == t) && !(h && pi)) {
      c.collapse(l.node, l.offset);
      try {
        e != t && c.extend(a.node, a.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > t) {
        let p = l;
        l = a, a = p;
      }
      let d = document.createRange();
      d.setEnd(a.node, a.offset), d.setStart(l.node, l.offset), c.removeAllRanges(), c.addRange(d);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i], o = r + s.size;
      if (r == o ? e <= o && t >= r : e < o && t > r) {
        let l = r + s.border, a = o - s.border;
        if (e >= l && t <= a) {
          this.dirty = e == r || t == o ? Ql : Bx, e == l && t == a && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = ks : s.markDirty(e - l, t - l);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? Ql : ks;
      }
      r = o;
    }
    this.dirty = Ql;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let r = e == 1 ? Ql : Bx;
      t.dirty < r && (t.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class wA extends gd {
  constructor(e, t, r, i) {
    let s, o = t.type.toDOM;
    if (typeof o == "function" && (o = o(r, () => {
      if (!s)
        return i;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !t.type.spec.raw) {
      if (o.nodeType != 1) {
        let l = document.createElement("span");
        l.appendChild(o), o = l;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = t, this.widget = t, s = this;
  }
  matchesWidget(e) {
    return this.dirty == mi && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class UU extends gd {
  constructor(e, t, r, i) {
    super(e, [], t, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Aa extends gd {
  constructor(e, t, r, i, s) {
    super(e, [], r, i), this.mark = t, this.spec = s;
  }
  static create(e, t, r, i) {
    let s = i.nodeViews[t.type.name], o = s && s(t, i, r);
    return (!o || !o.dom) && (o = Pa.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new Aa(e, t, o.dom, o.contentDOM || o.dom, o);
  }
  parseRule() {
    return this.dirty & ks || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != ks && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != mi) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = mi;
    }
  }
  slice(e, t, r) {
    let i = Aa.create(this.parent, this.mark, !0, r), s = this.children, o = this.size;
    t < o && (s = Uy(s, t, o, r)), e > 0 && (s = Uy(s, 0, e, r));
    for (let l = 0; l < s.length; l++)
      s[l].parent = i;
    return i.children = s, i;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class rl extends gd {
  constructor(e, t, r, i, s, o, l, a, c) {
    super(e, [], s, o), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = l;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, r, i, s, o) {
    let l = s.nodeViews[t.type.name], a, c = l && l(t, s, () => {
      if (!a)
        return o;
      if (a.parent)
        return a.parent.posBeforeChild(a);
    }, r, i), u = c && c.dom, h = c && c.contentDOM;
    if (t.isText) {
      if (!u)
        u = document.createTextNode(t.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: h } = Pa.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
    !h && !t.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), t.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = CA(u, r, t), c ? a = new KU(e, t, r, i, u, h || null, f, c, s, o + 1) : t.isText ? new C1(e, t, r, i, u, f, s) : new rl(e, t, r, i, u, h || null, f, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let r = this.children[t];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => ce.empty);
    }
    return e;
  }
  matchesNode(e, t, r) {
    return this.dirty == mi && e.eq(this.node) && mm(t, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let r = this.node.inlineContent, i = t, s = e.composing ? this.localCompositionInfo(e, t) : null, o = s && s.pos > -1 ? s : null, l = s && s.pos < 0, a = new YU(this, o && o.node, e);
    ZU(this.node, this.innerDeco, (c, u, h) => {
      c.spec.marks ? a.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !h && a.syncToMarks(u == this.node.childCount ? nt.none : this.node.child(u).marks, r, e), a.placeWidget(c, e, i);
    }, (c, u, h, f) => {
      a.syncToMarks(c.marks, r, e);
      let d;
      a.findNodeMatch(c, u, h, f) || l && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (d = a.findIndexWithChild(s.node)) > -1 && a.updateNodeAt(c, u, h, d, e) || a.updateNextNode(c, u, h, e, f, i) || a.addNode(c, u, h, e, i), i += c.nodeSize;
    }), a.syncToMarks([], r, e), this.node.isTextblock && a.addTextblockHacks(), a.destroyRest(), (a.changed || this.dirty == Ql) && (o && this.protectLocalComposition(e, o), kA(this.contentDOM, this.children, e), $c && QU(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof Ee) || r < t || i > t + this.node.content.size)
      return null;
    let s = e.input.compositionNode;
    if (!s || !this.dom.contains(s.parentNode))
      return null;
    if (this.node.inlineContent) {
      let o = s.nodeValue, l = eK(this.node.content, o, r - t, i - t);
      return l < 0 ? null : { node: s, pos: l, text: o };
    } else
      return { node: s, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: r, text: i }) {
    if (this.getDesc(t))
      return;
    let s = t;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new UU(this, s, t, i);
    e.input.compositionNodes.push(o), this.children = Uy(this.children, r, r + i.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, r, i) {
    return this.dirty == ks || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, i), !0);
  }
  updateInner(e, t, r, i) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = mi;
  }
  updateOuterDeco(e) {
    if (mm(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = SA(this.dom, this.nodeDOM, jy(this.outerDeco, this.node, t), jy(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function zx(n, e, t, r, i) {
  CA(r, e, n);
  let s = new rl(void 0, n, e, t, r, r, r, i, 0);
  return s.contentDOM && s.updateChildren(i, 0), s;
}
class C1 extends rl {
  constructor(e, t, r, i, s, o, l) {
    super(e, t, r, i, s, null, o, l, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, r, i) {
    return this.dirty == ks || this.dirty != mi && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != mi || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = mi, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, r) {
    let i = this.node.cut(e, t), s = document.createTextNode(i.text);
    return new C1(this.parent, i, this.outerDeco, this.innerDeco, s, s, r);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = ks);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class xA extends gd {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == mi && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class KU extends rl {
  constructor(e, t, r, i, s, o, l, a, c, u) {
    super(e, t, r, i, s, o, l, c, u), this.spec = a;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, r, i) {
    if (this.dirty == ks)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let s = this.spec.update(e, t, r);
      return s && this.updateInner(e, t, r, i), s;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, t, r.root) : super.setSelection(e, t, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function kA(n, e, t) {
  let r = n.firstChild, i = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], l = o.dom;
    if (l.parentNode == n) {
      for (; l != r; )
        r = Fx(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, n.insertBefore(l, r);
    if (o instanceof Aa) {
      let a = r ? r.previousSibling : n.lastChild;
      kA(o.contentDOM, o.children, t), r = a ? a.nextSibling : n.firstChild;
    }
  }
  for (; r; )
    r = Fx(r), i = !0;
  i && t.trackWrites == n && (t.trackWrites = null);
}
const Uh = function(n) {
  n && (this.nodeName = n);
};
Uh.prototype = /* @__PURE__ */ Object.create(null);
const ea = [new Uh()];
function jy(n, e, t) {
  if (n.length == 0)
    return ea;
  let r = t ? ea[0] : new Uh(), i = [r];
  for (let s = 0; s < n.length; s++) {
    let o = n[s].type.attrs;
    if (o) {
      o.nodeName && i.push(r = new Uh(o.nodeName));
      for (let l in o) {
        let a = o[l];
        a != null && (t && i.length == 1 && i.push(r = new Uh(e.isInline ? "span" : "div")), l == "class" ? r.class = (r.class ? r.class + " " : "") + a : l == "style" ? r.style = (r.style ? r.style + ";" : "") + a : l != "nodeName" && (r[l] = a));
      }
    }
  }
  return i;
}
function SA(n, e, t, r) {
  if (t == ea && r == ea)
    return e;
  let i = e;
  for (let s = 0; s < r.length; s++) {
    let o = r[s], l = t[s];
    if (s) {
      let a;
      l && l.nodeName == o.nodeName && i != n && (a = i.parentNode) && a.nodeName.toLowerCase() == o.nodeName || (a = document.createElement(o.nodeName), a.pmIsDeco = !0, a.appendChild(i), l = ea[0]), i = a;
    }
    GU(i, l || ea[0], o);
  }
  return i;
}
function GU(n, e, t) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r);
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]);
  if (e.class != t.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && n.classList.remove(r[s]);
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && n.classList.add(i[s]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        n.style.removeProperty(i[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function CA(n, e, t) {
  return SA(n, n, ea, jy(e, t, n.nodeType != 1));
}
function mm(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function Fx(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class YU {
  constructor(e, t, r) {
    this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = JU(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let r = e; r < t; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, r) {
    let i = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = mi, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let l = -1;
      for (let a = this.index; a < Math.min(this.index + 3, this.top.children.length); a++) {
        let c = this.top.children[a];
        if (c.matchesMark(e[s]) && !this.isLocked(c.dom)) {
          l = a;
          break;
        }
      }
      if (l > -1)
        l > this.index && (this.changed = !0, this.destroyBetween(this.index, l)), this.top = this.top.children[this.index];
      else {
        let a = Aa.create(this.top, e[s], t, r);
        this.top.children.splice(this.index, 0, a), this.top = a, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, r, i) {
    let s = -1, o;
    if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, r))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let l = this.index, a = Math.min(this.top.children.length, l + 5); l < a; l++) {
        let c = this.top.children[l];
        if (c.matchesNode(e, t, r) && !this.preMatch.matched.has(c)) {
          s = l;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, t, r, i, s) {
    let o = this.top.children[i];
    return o.dirty == ks && o.dom == o.contentDOM && (o.dirty = Ql), o.update(e, t, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, r, i, s, o) {
    for (let l = this.index; l < this.top.children.length; l++) {
      let a = this.top.children[l];
      if (a instanceof rl) {
        let c = this.preMatch.matched.get(a);
        if (c != null && c != s)
          return !1;
        let u = a.dom, h, f = this.isLocked(u) && !(e.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == e.text && a.dirty != ks && mm(t, a.outerDeco));
        if (!f && a.update(e, t, r, i))
          return this.destroyBetween(this.index, l), a.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (h = this.recreateWrapper(a, e, t, r, i, o)))
          return this.destroyBetween(this.index, l), this.top.children[this.index] = h, h.contentDOM && (h.dirty = Ql, h.updateChildren(i, o + 1), h.dirty = mi), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, r, i, s, o) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !mm(r, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let l = rl.create(this.top, t, r, i, s, o);
    if (l.contentDOM) {
      l.children = e.children, e.children = [];
      for (let a of l.children)
        a.parent = l;
    }
    return e.destroy(), l;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, r, i, s) {
    let o = rl.create(this.top, e, t, r, i, s);
    o.contentDOM && o.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0;
  }
  placeWidget(e, t, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new wA(this.top, e, t, r);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof Aa; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof C1) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((dr || Kn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new xA(this.top, [], r, null);
      t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function JU(n, e) {
  let t = e, r = t.children.length, i = n.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e: for (; i > 0; ) {
    let l;
    for (; ; )
      if (r) {
        let c = t.children[r - 1];
        if (c instanceof Aa)
          t = c, r = c.children.length;
        else {
          l = c, r--;
          break;
        }
      } else {
        if (t == e)
          break e;
        r = t.parent.children.indexOf(t), t = t.parent;
      }
    let a = l.node;
    if (a) {
      if (a != n.child(i - 1))
        break;
      --i, s.set(l, i), o.push(l);
    }
  }
  return { index: i, matched: s, matches: o.reverse() };
}
function XU(n, e) {
  return n.type.side - e.type.side;
}
function ZU(n, e, t, r) {
  let i = e.locals(n), s = 0;
  if (i.length == 0) {
    for (let c = 0; c < n.childCount; c++) {
      let u = n.child(c);
      r(u, i, e.forChild(s, u), c), s += u.nodeSize;
    }
    return;
  }
  let o = 0, l = [], a = null;
  for (let c = 0; ; ) {
    let u, h;
    for (; o < i.length && i[o].to == s; ) {
      let g = i[o++];
      g.widget && (u ? (h || (h = [u])).push(g) : u = g);
    }
    if (u)
      if (h) {
        h.sort(XU);
        for (let g = 0; g < h.length; g++)
          t(h[g], c, !!a);
      } else
        t(u, c, !!a);
    let f, d;
    if (a)
      d = -1, f = a, a = null;
    else if (c < n.childCount)
      d = c, f = n.child(c++);
    else
      break;
    for (let g = 0; g < l.length; g++)
      l[g].to <= s && l.splice(g--, 1);
    for (; o < i.length && i[o].from <= s && i[o].to > s; )
      l.push(i[o++]);
    let p = s + f.nodeSize;
    if (f.isText) {
      let g = p;
      o < i.length && i[o].from < g && (g = i[o].from);
      for (let b = 0; b < l.length; b++)
        l[b].to < g && (g = l[b].to);
      g < p && (a = f.cut(g - s), f = f.cut(0, g - s), p = g, d = -1);
    } else
      for (; o < i.length && i[o].to < p; )
        o++;
    let m = f.isInline && !f.isLeaf ? l.filter((g) => !g.inline) : l.slice();
    r(f, m, e.forChild(s, f), d), s = p;
  }
}
function QU(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function eK(n, e, t, r) {
  for (let i = 0, s = 0; i < n.childCount && s <= r; ) {
    let o = n.child(i++), l = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let a = o.text;
    for (; i < n.childCount; ) {
      let c = n.child(i++);
      if (s += c.nodeSize, !c.isText)
        break;
      a += c.text;
    }
    if (s >= t) {
      if (s >= r && a.slice(r - e.length - l, r - l) == e)
        return r - e.length;
      let c = l < r ? a.lastIndexOf(e, r - l - 1) : -1;
      if (c >= 0 && c + e.length + l >= t)
        return l + c;
      if (t == r && a.length >= r + e.length - l && a.slice(r - l, r - l + e.length) == e)
        return r;
    }
  }
  return -1;
}
function Uy(n, e, t, r, i) {
  let s = [];
  for (let o = 0, l = 0; o < n.length; o++) {
    let a = n[o], c = l, u = l += a.size;
    c >= t || u <= e ? s.push(a) : (c < e && s.push(a.slice(0, e - c, r)), i && (s.push(i), i = void 0), u > t && s.push(a.slice(t - c, a.size, r)));
  }
  return s;
}
function Y3(n, e = null) {
  let t = n.domSelectionRange(), r = n.state.doc;
  if (!t.focusNode)
    return null;
  let i = n.docView.nearestDesc(t.focusNode), s = i && i.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (o < 0)
    return null;
  let l = r.resolve(o), a, c;
  if (S1(t)) {
    for (a = o; i && !i.node; )
      i = i.parent;
    let h = i.node;
    if (i && h.isAtom && $e.isSelectable(h) && i.parent && !(h.isInline && TU(t.focusNode, t.focusOffset, i.dom))) {
      let f = i.posBefore;
      c = new $e(o == f ? l : r.resolve(f));
    }
  } else {
    if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
      let h = o, f = o;
      for (let d = 0; d < t.rangeCount; d++) {
        let p = t.getRangeAt(d);
        h = Math.min(h, n.docView.posFromDOM(p.startContainer, p.startOffset, 1)), f = Math.max(f, n.docView.posFromDOM(p.endContainer, p.endOffset, -1));
      }
      if (h < 0)
        return null;
      [a, o] = f == n.state.selection.anchor ? [f, h] : [h, f], l = r.resolve(o);
    } else
      a = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (a < 0)
      return null;
  }
  let u = r.resolve(a);
  if (!c) {
    let h = e == "pointer" || n.state.selection.head < l.pos && !s ? 1 : -1;
    c = J3(n, u, l, h);
  }
  return c;
}
function MA(n) {
  return n.editable ? n.hasFocus() : AA(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function io(n, e = !1) {
  let t = n.state.selection;
  if (TA(n, t), !!MA(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && Kn) {
      let r = n.domSelectionRange(), i = n.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && Ta(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      nK(n);
    else {
      let { anchor: r, head: i } = t, s, o;
      Hx && !(t instanceof Ee) && (t.$from.parent.inlineContent || (s = $x(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = $x(n, t.to))), n.docView.setSelection(r, i, n, e), Hx && (s && Vx(s), o && Vx(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && tK(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const Hx = dr || Kn && dA < 63;
function $x(n, e) {
  let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, s = r ? t.childNodes[r - 1] : null;
  if (dr && i && i.contentEditable == "false")
    return m2(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return m2(i);
    if (s)
      return m2(s);
  }
}
function m2(n) {
  return n.contentEditable = "true", dr && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function Vx(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function tK(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!MA(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function nK(n) {
  let e = n.domSelection();
  if (!e)
    return;
  let t = n.cursorWrapper.dom, r = t.nodeName == "IMG";
  r ? e.collapse(t.parentNode, _n(t) + 1) : e.collapse(t, 0), !r && !n.state.selection.visible && Er && nl <= 11 && (t.disabled = !0, t.disabled = !1);
}
function TA(n, e) {
  if (e instanceof $e) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (qx(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    qx(n);
}
function qx(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function J3(n, e, t, r) {
  return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || Ee.between(e, t, r);
}
function Wx(n) {
  return n.editable && !n.hasFocus() ? !1 : AA(n);
}
function AA(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function rK(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return Ta(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function Ky(n, e) {
  let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), s = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && Ge.findFrom(s, e);
}
function Fo(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function jx(n, e, t) {
  let r = n.state.selection;
  if (r instanceof Ee)
    if (t.indexOf("s") > -1) {
      let { $head: i } = r, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let o = n.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return Fo(n, new Ee(r.$anchor, o));
    } else if (r.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = Ky(n.state, e);
        return i && i instanceof $e ? Fo(n, i) : !1;
      } else if (!(ii && t.indexOf("m") > -1)) {
        let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
        if (!s || s.isText)
          return !1;
        let l = e < 0 ? i.pos - s.nodeSize : i.pos;
        return s.isAtom || (o = n.docView.descAt(l)) && !o.contentDOM ? $e.isSelectable(s) ? Fo(n, new $e(e < 0 ? n.state.doc.resolve(i.pos - s.nodeSize) : i)) : md ? Fo(n, new Ee(n.state.doc.resolve(e < 0 ? l : l + s.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof $e && r.node.isInline)
      return Fo(n, new Ee(e > 0 ? r.$to : r.$from));
    {
      let i = Ky(n.state, e);
      return i ? Fo(n, i) : !1;
    }
  }
}
function gm(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function Kh(n, e) {
  let t = n.pmViewDesc;
  return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
}
function Ya(n, e) {
  return e < 0 ? iK(n) : sK(n);
}
function iK(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i, s, o = !1;
  for (pi && t.nodeType == 1 && r < gm(t) && Kh(t.childNodes[r], -1) && (o = !0); ; )
    if (r > 0) {
      if (t.nodeType != 1)
        break;
      {
        let l = t.childNodes[r - 1];
        if (Kh(l, -1))
          i = t, s = --r;
        else if (l.nodeType == 3)
          t = l, r = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (OA(t))
        break;
      {
        let l = t.previousSibling;
        for (; l && Kh(l, -1); )
          i = t.parentNode, s = _n(l), l = l.previousSibling;
        if (l)
          t = l, r = gm(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = 0;
        }
      }
    }
  o ? Gy(n, t, r) : i && Gy(n, i, s);
}
function sK(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i = gm(t), s, o;
  for (; ; )
    if (r < i) {
      if (t.nodeType != 1)
        break;
      let l = t.childNodes[r];
      if (Kh(l, 1))
        s = t, o = ++r;
      else
        break;
    } else {
      if (OA(t))
        break;
      {
        let l = t.nextSibling;
        for (; l && Kh(l, 1); )
          s = l.parentNode, o = _n(l) + 1, l = l.nextSibling;
        if (l)
          t = l, r = 0, i = gm(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = i = 0;
        }
      }
    }
  s && Gy(n, s, o);
}
function OA(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function oK(n, e) {
  for (; n && e == n.childNodes.length && !pd(n); )
    e = _n(n) + 1, n = n.parentNode;
  for (; n && e < n.childNodes.length; ) {
    let t = n.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = 0;
  }
}
function lK(n, e) {
  for (; n && !e && !pd(n); )
    e = _n(n), n = n.parentNode;
  for (; n && e; ) {
    let t = n.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = n.childNodes.length;
  }
}
function Gy(n, e, t) {
  if (e.nodeType != 3) {
    let s, o;
    (o = oK(e, t)) ? (e = o, t = 0) : (s = lK(e, t)) && (e = s, t = s.nodeValue.length);
  }
  let r = n.domSelection();
  if (!r)
    return;
  if (S1(r)) {
    let s = document.createRange();
    s.setEnd(e, t), s.setStart(e, t), r.removeAllRanges(), r.addRange(s);
  } else r.extend && r.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: i } = n;
  setTimeout(() => {
    n.state == i && io(n);
  }, 50);
}
function Ux(n, e) {
  let t = n.state.doc.resolve(e);
  if (!(Kn || EU) && t.parent.inlineContent) {
    let i = n.coordsAtPos(e);
    if (e > t.start()) {
      let s = n.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left < i.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let s = n.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
}
function Kx(n, e, t) {
  let r = n.state.selection;
  if (r instanceof Ee && !r.empty || t.indexOf("s") > -1 || ii && t.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = r;
  if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Ky(n.state, e);
    if (o && o instanceof $e)
      return Fo(n, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s, l = r instanceof Or ? Ge.near(o, e) : Ge.findFrom(o, e);
    return l ? Fo(n, l) : !1;
  }
  return !1;
}
function Gx(n, e) {
  if (!(n.state.selection instanceof Ee))
    return !0;
  let { $head: t, $anchor: r, empty: i } = n.state.selection;
  if (!t.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (s && !s.isText) {
    let o = n.state.tr;
    return e < 0 ? o.delete(t.pos - s.nodeSize, t.pos) : o.delete(t.pos, t.pos + s.nodeSize), n.dispatch(o), !0;
  }
  return !1;
}
function Yx(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function aK(n) {
  if (!dr || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    Yx(n, r, "true"), setTimeout(() => Yx(n, r, "false"), 20);
  }
  return !1;
}
function cK(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function uK(n, e) {
  let t = e.keyCode, r = cK(e);
  if (t == 8 || ii && t == 72 && r == "c")
    return Gx(n, -1) || Ya(n, -1);
  if (t == 46 && !e.shiftKey || ii && t == 68 && r == "c")
    return Gx(n, 1) || Ya(n, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || ii && t == 66 && r == "c") {
    let i = t == 37 ? Ux(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return jx(n, i, r) || Ya(n, i);
  } else if (t == 39 || ii && t == 70 && r == "c") {
    let i = t == 39 ? Ux(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return jx(n, i, r) || Ya(n, i);
  } else {
    if (t == 38 || ii && t == 80 && r == "c")
      return Kx(n, -1, r) || Ya(n, -1);
    if (t == 40 || ii && t == 78 && r == "c")
      return aK(n) || Kx(n, 1, r) || Ya(n, 1);
    if (r == (ii ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function X3(n, e) {
  n.someProp("transformCopied", (d) => {
    e = d(e, n);
  });
  let t = [], { content: r, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--;
    let d = r.firstChild;
    t.push(d.type.name, d.attrs != d.type.defaultAttrs ? d.attrs : null), r = d.content;
  }
  let o = n.someProp("clipboardSerializer") || Pa.fromSchema(n.state.schema), l = PA(), a = l.createElement("div");
  a.appendChild(o.serializeFragment(r, { document: l }));
  let c = a.firstChild, u, h = 0;
  for (; c && c.nodeType == 1 && (u = RA[c.nodeName.toLowerCase()]); ) {
    for (let d = u.length - 1; d >= 0; d--) {
      let p = l.createElement(u[d]);
      for (; a.firstChild; )
        p.appendChild(a.firstChild);
      a.appendChild(p), h++;
    }
    c = a.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${s}${h ? ` -${h}` : ""} ${JSON.stringify(t)}`);
  let f = n.someProp("clipboardTextSerializer", (d) => d(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: a, text: f, slice: e };
}
function EA(n, e, t, r, i) {
  let s = i.parent.type.spec.code, o, l;
  if (!t && !e)
    return null;
  let a = !!e && (r || s || !t);
  if (a) {
    if (n.someProp("transformPastedText", (f) => {
      e = f(e, s || r, n);
    }), s)
      return l = new ve(ce.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0), n.someProp("transformPasted", (f) => {
        l = f(l, n, !0);
      }), l;
    let h = n.someProp("clipboardTextParser", (f) => f(e, i, r, n));
    if (h)
      l = h;
    else {
      let f = i.marks(), { schema: d } = n.state, p = Pa.fromSchema(d);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
        let g = o.appendChild(document.createElement("p"));
        m && g.appendChild(p.serializeNode(d.text(m, f)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (h) => {
      t = h(t, n);
    }), o = pK(t), md && mK(o);
  let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let h = +u[3]; h > 0; h--) {
      let f = o.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      o = f;
    }
  if (l || (l = (n.someProp("clipboardParser") || n.someProp("domParser") || Sa.fromSchema(n.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(a || u),
    context: i,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !hK.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    l = gK(Jx(l, +u[1], +u[2]), u[4]);
  else if (l = ve.maxOpen(fK(l.content, i), !0), l.openStart || l.openEnd) {
    let h = 0, f = 0;
    for (let d = l.content.firstChild; h < l.openStart && !d.type.spec.isolating; h++, d = d.firstChild)
      ;
    for (let d = l.content.lastChild; f < l.openEnd && !d.type.spec.isolating; f++, d = d.lastChild)
      ;
    l = Jx(l, h, f);
  }
  return n.someProp("transformPasted", (h) => {
    l = h(l, n, a);
  }), l;
}
const hK = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function fK(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let i = e.node(t).contentMatchAt(e.index(t)), s, o = [];
    if (n.forEach((l) => {
      if (!o)
        return;
      let a = i.findWrapping(l.type), c;
      if (!a)
        return o = null;
      if (c = o.length && s.length && DA(a, s, l, o[o.length - 1], 0))
        o[o.length - 1] = c;
      else {
        o.length && (o[o.length - 1] = NA(o[o.length - 1], s.length));
        let u = IA(l, a);
        o.push(u), i = i.matchType(u.type), s = a;
      }
    }), o)
      return ce.from(o);
  }
  return n;
}
function IA(n, e, t = 0) {
  for (let r = e.length - 1; r >= t; r--)
    n = e[r].create(null, ce.from(n));
  return n;
}
function DA(n, e, t, r, i) {
  if (i < n.length && i < e.length && n[i] == e[i]) {
    let s = DA(n, e, t, r.lastChild, i + 1);
    if (s)
      return r.copy(r.content.replaceChild(r.childCount - 1, s));
    if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1]))
      return r.copy(r.content.append(ce.from(IA(t, n, i + 1))));
  }
}
function NA(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, NA(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(ce.empty, !0);
  return n.copy(t.append(r));
}
function Yy(n, e, t, r, i, s) {
  let o = e < 0 ? n.firstChild : n.lastChild, l = o.content;
  return n.childCount > 1 && (s = 0), i < r - 1 && (l = Yy(l, e, t, r, i + 1, s)), i >= t && (l = e < 0 ? o.contentMatchAt(0).fillBefore(l, s <= i).append(l) : l.append(o.contentMatchAt(o.childCount).fillBefore(ce.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(l));
}
function Jx(n, e, t) {
  return e < n.openStart && (n = new ve(Yy(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new ve(Yy(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const RA = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Xx = null;
function PA() {
  return Xx || (Xx = document.implementation.createHTMLDocument("title"));
}
let g2 = null;
function dK(n) {
  let e = window.trustedTypes;
  return e ? (g2 || (g2 = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), g2.createHTML(n)) : n;
}
function pK(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = PA().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i;
  if ((i = r && RA[r[1].toLowerCase()]) && (n = i.map((s) => "<" + s + ">").join("") + n + i.map((s) => "</" + s + ">").reverse().join("")), t.innerHTML = dK(n), i)
    for (let s = 0; s < i.length; s++)
      t = t.querySelector(i[s]) || t;
  return t;
}
function mK(n) {
  let e = n.querySelectorAll(Kn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r);
  }
}
function gK(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: i, openStart: s, openEnd: o } = n;
  for (let l = r.length - 2; l >= 0; l -= 2) {
    let a = t.nodes[r[l]];
    if (!a || a.hasRequiredAttrs())
      break;
    i = ce.from(a.create(r[l + 1], i)), s++, o++;
  }
  return new ve(i, s, o);
}
const pr = {}, mr = {}, yK = { touchstart: !0, touchmove: !0 };
class bK {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function vK(n) {
  for (let e in pr) {
    let t = pr[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (r) => {
      xK(n, r) && !Z3(n, r) && (n.editable || !(r.type in mr)) && t(n, r);
    }, yK[e] ? { passive: !0 } : void 0);
  }
  dr && n.dom.addEventListener("input", () => null), Jy(n);
}
function Zo(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function wK(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function Jy(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (r) => Z3(n, r));
  });
}
function Z3(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let r = t[e.type];
    return r ? r(n, e) || e.defaultPrevented : !1;
  });
}
function xK(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function kK(n, e) {
  !Z3(n, e) && pr[e.type] && (n.editable || !(e.type in mr)) && pr[e.type](n, e);
}
mr.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !LA(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(Qs && Kn && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), $c && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let r = Date.now();
      n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", (i) => i(n, Yl(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else n.someProp("handleKeyDown", (r) => r(n, t)) || uK(n, t) ? t.preventDefault() : Zo(n, "key");
};
mr.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
mr.keypress = (n, e) => {
  let t = e;
  if (LA(n, t) || !t.charCode || t.ctrlKey && !t.altKey || ii && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (i) => i(n, t))) {
    t.preventDefault();
    return;
  }
  let r = n.state.selection;
  if (!(r instanceof Ee) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(t.charCode), s = () => n.state.tr.insertText(i).scrollIntoView();
    !/[\r\n]/.test(i) && !n.someProp("handleTextInput", (o) => o(n, r.$from.pos, r.$to.pos, i, s)) && n.dispatch(s()), t.preventDefault();
  }
};
function M1(n) {
  return { left: n.clientX, top: n.clientY };
}
function SK(n, e) {
  let t = e.x - n.clientX, r = e.y - n.clientY;
  return t * t + r * r < 100;
}
function Q3(n, e, t, r, i) {
  if (r == -1)
    return !1;
  let s = n.state.doc.resolve(r);
  for (let o = s.depth + 1; o > 0; o--)
    if (n.someProp(e, (l) => o > s.depth ? l(n, t, s.nodeAfter, s.before(o), i, !0) : l(n, t, s.node(o), s.before(o), i, !1)))
      return !0;
  return !1;
}
function wc(n, e, t) {
  if (n.focused || n.focus(), n.state.selection.eq(e))
    return;
  let r = n.state.tr.setSelection(e);
  r.setMeta("pointer", !0), n.dispatch(r);
}
function CK(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), r = t.nodeAfter;
  return r && r.isAtom && $e.isSelectable(r) ? (wc(n, new $e(t)), !0) : !1;
}
function MK(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, r, i;
  t instanceof $e && (r = t.node);
  let s = n.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let l = o > s.depth ? s.nodeAfter : s.node(o);
    if ($e.isSelectable(l)) {
      r && t.$from.depth > 0 && o >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i = s.before(t.$from.depth) : i = s.before(o);
      break;
    }
  }
  return i != null ? (wc(n, $e.create(n.state.doc, i)), !0) : !1;
}
function TK(n, e, t, r, i) {
  return Q3(n, "handleClickOn", e, t, r) || n.someProp("handleClick", (s) => s(n, e, r)) || (i ? MK(n, t) : CK(n, t));
}
function AK(n, e, t, r) {
  return Q3(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", (i) => i(n, e, r));
}
function OK(n, e, t, r) {
  return Q3(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", (i) => i(n, e, r)) || EK(n, t, r);
}
function EK(n, e, t) {
  if (t.button != 0)
    return !1;
  let r = n.state.doc;
  if (e == -1)
    return r.inlineContent ? (wc(n, Ee.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s), l = i.before(s);
    if (o.inlineContent)
      wc(n, Ee.create(r, l + 1, l + 1 + o.content.size));
    else if ($e.isSelectable(o))
      wc(n, $e.create(r, l));
    else
      continue;
    return !0;
  }
}
function eb(n) {
  return ym(n);
}
const _A = ii ? "metaKey" : "ctrlKey";
pr.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let r = eb(n), i = Date.now(), s = "singleClick";
  i - n.input.lastClick.time < 500 && SK(t, n.input.lastClick) && !t[_A] && n.input.lastClick.button == t.button && (n.input.lastClick.type == "singleClick" ? s = "doubleClick" : n.input.lastClick.type == "doubleClick" && (s = "tripleClick")), n.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: s, button: t.button };
  let o = n.posAtCoords(M1(t));
  o && (s == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new IK(n, o, t, !!r)) : (s == "doubleClick" ? AK : OK)(n, o.pos, o.inside, t) ? t.preventDefault() : Zo(n, "pointer"));
};
class IK {
  constructor(e, t, r, i) {
    this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[_A], this.allowDefault = r.shiftKey;
    let s, o;
    if (t.inside > -1)
      s = e.state.doc.nodeAt(t.inside), o = t.inside;
    else {
      let u = e.state.doc.resolve(t.pos);
      s = u.parent, o = u.depth ? u.before() : 0;
    }
    const l = i ? null : r.target, a = l ? e.docView.nearestDesc(l, !0) : null;
    this.target = a && a.dom.nodeType == 1 ? a.dom : null;
    let { selection: c } = e.state;
    (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof $e && c.from <= o && c.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && pi && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Zo(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => io(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(M1(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Zo(this.view, "pointer") : TK(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    dr && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Kn && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (wc(this.view, Ge.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : Zo(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Zo(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
pr.touchstart = (n) => {
  n.input.lastTouch = Date.now(), eb(n), Zo(n, "pointer");
};
pr.touchmove = (n) => {
  n.input.lastTouch = Date.now(), Zo(n, "pointer");
};
pr.contextmenu = (n) => eb(n);
function LA(n, e) {
  return n.composing ? !0 : dr && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const DK = Qs ? 5e3 : -1;
mr.compositionstart = mr.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$to;
    if (e.selection instanceof Ee && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), ym(n, !0), n.markCursor = null;
    else if (ym(n, !e.selection.empty), pi && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let r = n.domSelectionRange();
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          let l = n.domSelection();
          l && l.collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, s = -1;
      }
    }
    n.input.composing = !0;
  }
  BA(n, DK);
};
mr.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, BA(n, 20));
};
function BA(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => ym(n), e));
}
function zA(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = RK()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function NK(n) {
  let e = n.domSelectionRange();
  if (!e.focusNode)
    return null;
  let t = CU(e.focusNode, e.focusOffset), r = MU(e.focusNode, e.focusOffset);
  if (t && r && t != r) {
    let i = r.pmViewDesc, s = n.domObserver.lastChangedTextNode;
    if (t == s || r == s)
      return s;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (n.input.compositionNode == r) {
      let o = t.pmViewDesc;
      if (!(!o || !o.isText(t.nodeValue)))
        return r;
    }
  }
  return t || r;
}
function RK() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function ym(n, e = !1) {
  if (!(Qs && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), zA(n), e || n.docView && n.docView.dirty) {
      let t = Y3(n), r = n.state.selection;
      return t && !t.eq(r) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function PK(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const Bf = Er && nl < 15 || $c && IU < 604;
pr.copy = mr.cut = (n, e) => {
  let t = e, r = n.state.selection, i = t.type == "cut";
  if (r.empty)
    return;
  let s = Bf ? null : t.clipboardData, o = r.content(), { dom: l, text: a } = X3(n, o);
  s ? (t.preventDefault(), s.clearData(), s.setData("text/html", l.innerHTML), s.setData("text/plain", a)) : PK(n, l), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function _K(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function LK(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = n.input.shiftKey && n.input.lastKeyCode != 45;
  setTimeout(() => {
    n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? zf(n, r.value, null, i, e) : zf(n, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function zf(n, e, t, r, i) {
  let s = EA(n, e, t, r, n.state.selection.$from);
  if (n.someProp("handlePaste", (a) => a(n, i, s || ve.empty)))
    return !0;
  if (!s)
    return !1;
  let o = _K(s), l = o ? n.state.tr.replaceSelectionWith(o, r) : n.state.tr.replaceSelection(s);
  return n.dispatch(l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function FA(n) {
  let e = n.getData("text/plain") || n.getData("Text");
  if (e)
    return e;
  let t = n.getData("text/uri-list");
  return t ? t.replace(/\r?\n/g, " ") : "";
}
mr.paste = (n, e) => {
  let t = e;
  if (n.composing && !Qs)
    return;
  let r = Bf ? null : t.clipboardData, i = n.input.shiftKey && n.input.lastKeyCode != 45;
  r && zf(n, FA(r), r.getData("text/html"), i, t) ? t.preventDefault() : LK(n, t);
};
class HA {
  constructor(e, t, r) {
    this.slice = e, this.move = t, this.node = r;
  }
}
const BK = ii ? "altKey" : "ctrlKey";
function $A(n, e) {
  let t = n.someProp("dragCopies", (r) => !r(e));
  return t ?? !e[BK];
}
pr.dragstart = (n, e) => {
  let t = e, r = n.input.mouseDown;
  if (r && r.done(), !t.dataTransfer)
    return;
  let i = n.state.selection, s = i.empty ? null : n.posAtCoords(M1(t)), o;
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof $e ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      o = $e.create(n.state.doc, r.mightDrag.pos);
    else if (t.target && t.target.nodeType == 1) {
      let h = n.docView.nearestDesc(t.target, !0);
      h && h.node.type.spec.draggable && h != n.docView && (o = $e.create(n.state.doc, h.posBefore));
    }
  }
  let l = (o || n.state.selection).content(), { dom: a, text: c, slice: u } = X3(n, l);
  (!t.dataTransfer.files.length || !Kn || dA > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Bf ? "Text" : "text/html", a.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Bf || t.dataTransfer.setData("text/plain", c), n.dragging = new HA(u, $A(n, t), o);
};
pr.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
mr.dragover = mr.dragenter = (n, e) => e.preventDefault();
mr.drop = (n, e) => {
  let t = e, r = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let i = n.posAtCoords(M1(t));
  if (!i)
    return;
  let s = n.state.doc.resolve(i.pos), o = r && r.slice;
  o ? n.someProp("transformPasted", (p) => {
    o = p(o, n, !1);
  }) : o = EA(n, FA(t.dataTransfer), Bf ? null : t.dataTransfer.getData("text/html"), !1, s);
  let l = !!(r && $A(n, t));
  if (n.someProp("handleDrop", (p) => p(n, t, o || ve.empty, l))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let a = o ? sT(n.state.doc, s.pos, o) : s.pos;
  a == null && (a = s.pos);
  let c = n.state.tr;
  if (l) {
    let { node: p } = r;
    p ? p.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(a), h = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = c.doc;
  if (h ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(f))
    return;
  let d = c.doc.resolve(u);
  if (h && $e.isSelectable(o.content.firstChild) && d.nodeAfter && d.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new $e(d));
  else {
    let p = c.mapping.map(a);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((m, g, b, w) => p = w), c.setSelection(J3(n, d, c.doc.resolve(p)));
  }
  n.focus(), n.dispatch(c.setMeta("uiEvent", "drop"));
};
pr.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && io(n);
  }, 20));
};
pr.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
pr.beforeinput = (n, e) => {
  if (Kn && Qs && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: r } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (s) => s(n, Yl(8, "Backspace")))))
        return;
      let { $cursor: i } = n.state.selection;
      i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in mr)
  pr[n] = mr[n];
function Ff(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
class bm {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || oa, this.side = this.spec.side || 0;
  }
  map(e, t, r, i) {
    let { pos: s, deleted: o } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new mn(s - r, s - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof bm && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Ff(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class il {
  constructor(e, t) {
    this.attrs = e, this.spec = t || oa;
  }
  map(e, t, r, i) {
    let s = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return s >= o ? null : new mn(s, o, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof il && Ff(this.attrs, e.attrs) && Ff(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof il;
  }
  destroy() {
  }
}
class tb {
  constructor(e, t) {
    this.attrs = e, this.spec = t || oa;
  }
  map(e, t, r, i) {
    let s = e.mapResult(t.from + i, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(t.to + i, -1);
    return o.deleted || o.pos <= s.pos ? null : new mn(s.pos - r, o.pos - r, this);
  }
  valid(e, t) {
    let { index: r, offset: i } = e.content.findIndex(t.from), s;
    return i == t.from && !(s = e.child(r)).isText && i + s.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof tb && Ff(this.attrs, e.attrs) && Ff(this.spec, e.spec);
  }
  destroy() {
  }
}
class mn {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.type = r;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new mn(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, r) {
    return this.type.map(e, this, t, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, r) {
    return new mn(e, e, new bm(t, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, r, i) {
    return new mn(e, t, new il(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, r, i) {
    return new mn(e, t, new tb(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof il;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof bm;
  }
}
const nc = [], oa = {};
class Ot {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : nc, this.children = t.length ? t : nc;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? vm(t, e, 0, oa) : qn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, r) {
    let i = [];
    return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i;
  }
  findInner(e, t, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let l = this.local[o];
      l.from <= t && l.to >= e && (!s || s(l.spec)) && r.push(l.copy(l.from + i, l.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < t && this.children[o + 1] > e) {
        let l = this.children[o] + 1;
        this.children[o + 2].findInner(e - l, t - l, r, i + l, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, r) {
    return this == qn || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || oa);
  }
  /**
  @internal
  */
  mapInner(e, t, r, i, s) {
    let o;
    for (let l = 0; l < this.local.length; l++) {
      let a = this.local[l].map(e, r, i);
      a && a.type.valid(t, a) ? (o || (o = [])).push(a) : s.onRemove && s.onRemove(this.local[l].spec);
    }
    return this.children.length ? zK(this.children, o || [], e, t, r, i, s) : o ? new Ot(o.sort(la), nc) : qn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == qn ? Ot.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, r) {
    let i, s = 0;
    e.forEach((l, a) => {
      let c = a + r, u;
      if (u = qA(t, l, c)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < a; )
          s += 3;
        i[s] == a ? i[s + 2] = i[s + 2].addInner(l, u, c + 1) : i.splice(s, 0, a, a + l.nodeSize, vm(u, l, c + 1, oa)), s += 3;
      }
    });
    let o = VA(s ? WA(t) : t, -r);
    for (let l = 0; l < o.length; l++)
      o[l].type.valid(e, o[l]) || o.splice(l--, 1);
    return new Ot(o.length ? this.local.concat(o).sort(la) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == qn ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let r = this.children, i = this.local;
    for (let s = 0; s < r.length; s += 3) {
      let o, l = r[s] + t, a = r[s + 1] + t;
      for (let u = 0, h; u < e.length; u++)
        (h = e[u]) && h.from > l && h.to < a && (e[u] = null, (o || (o = [])).push(h));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[s + 2].removeInner(o, l + 1);
      c != qn ? r[s + 2] = c : (r.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let l = 0; l < i.length; l++)
            i[l].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(l--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new Ot(i, r) : qn;
  }
  forChild(e, t) {
    if (this == qn)
      return this;
    if (t.isLeaf)
      return Ot.empty;
    let r, i;
    for (let l = 0; l < this.children.length; l += 3)
      if (this.children[l] >= e) {
        this.children[l] == e && (r = this.children[l + 2]);
        break;
      }
    let s = e + 1, o = s + t.content.size;
    for (let l = 0; l < this.local.length; l++) {
      let a = this.local[l];
      if (a.from < o && a.to > s && a.type instanceof il) {
        let c = Math.max(s, a.from) - s, u = Math.min(o, a.to) - s;
        c < u && (i || (i = [])).push(a.copy(c, u));
      }
    }
    if (i) {
      let l = new Ot(i.sort(la), nc);
      return r ? new jo([l, r]) : l;
    }
    return r || qn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Ot) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return nb(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == qn)
      return nc;
    if (e.inlineContent || !this.local.some(il.is))
      return this.local;
    let t = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof il || t.push(this.local[r]);
    return t;
  }
  forEachSet(e) {
    e(this);
  }
}
Ot.empty = new Ot([], []);
Ot.removeOverlap = nb;
const qn = Ot.empty;
class jo {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const r = this.members.map((i) => i.map(e, t, oa));
    return jo.from(r);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return Ot.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, t);
      s != qn && (s instanceof jo ? r = r.concat(s.members) : r.push(s));
    }
    return jo.from(r);
  }
  eq(e) {
    if (!(e instanceof jo) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!t)
          t = s;
        else {
          r && (t = t.slice(), r = !1);
          for (let o = 0; o < s.length; o++)
            t.push(s[o]);
        }
    }
    return t ? nb(r ? t : t.sort(la)) : nc;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return qn;
      case 1:
        return e[0];
      default:
        return new jo(e.every((t) => t instanceof Ot) ? e : e.reduce((t, r) => t.concat(r instanceof Ot ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let t = 0; t < this.members.length; t++)
      this.members[t].forEachSet(e);
  }
}
function zK(n, e, t, r, i, s, o) {
  let l = n.slice();
  for (let c = 0, u = s; c < t.maps.length; c++) {
    let h = 0;
    t.maps[c].forEach((f, d, p, m) => {
      let g = m - p - (d - f);
      for (let b = 0; b < l.length; b += 3) {
        let w = l[b + 1];
        if (w < 0 || f > w + u - h)
          continue;
        let k = l[b] + u - h;
        d >= k ? l[b + 1] = f <= k ? -2 : -1 : f >= u && g && (l[b] += g, l[b + 1] += g);
      }
      h += g;
    }), u = t.maps[c].map(u, -1);
  }
  let a = !1;
  for (let c = 0; c < l.length; c += 3)
    if (l[c + 1] < 0) {
      if (l[c + 1] == -2) {
        a = !0, l[c + 1] = -1;
        continue;
      }
      let u = t.map(n[c] + s), h = u - i;
      if (h < 0 || h >= r.content.size) {
        a = !0;
        continue;
      }
      let f = t.map(n[c + 1] + s, -1), d = f - i, { index: p, offset: m } = r.content.findIndex(h), g = r.maybeChild(p);
      if (g && m == h && m + g.nodeSize == d) {
        let b = l[c + 2].mapInner(t, g, u + 1, n[c] + s + 1, o);
        b != qn ? (l[c] = h, l[c + 1] = d, l[c + 2] = b) : (l[c + 1] = -2, a = !0);
      } else
        a = !0;
    }
  if (a) {
    let c = FK(l, n, e, t, i, s, o), u = vm(c, r, 0, o);
    e = u.local;
    for (let h = 0; h < l.length; h += 3)
      l[h + 1] < 0 && (l.splice(h, 3), h -= 3);
    for (let h = 0, f = 0; h < u.children.length; h += 3) {
      let d = u.children[h];
      for (; f < l.length && l[f] < d; )
        f += 3;
      l.splice(f, 0, u.children[h], u.children[h + 1], u.children[h + 2]);
    }
  }
  return new Ot(e.sort(la), l);
}
function VA(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let r = 0; r < n.length; r++) {
    let i = n[r];
    t.push(new mn(i.from + e, i.to + e, i.type));
  }
  return t;
}
function FK(n, e, t, r, i, s, o) {
  function l(a, c) {
    for (let u = 0; u < a.local.length; u++) {
      let h = a.local[u].map(r, i, c);
      h ? t.push(h) : o.onRemove && o.onRemove(a.local[u].spec);
    }
    for (let u = 0; u < a.children.length; u += 3)
      l(a.children[u + 2], a.children[u] + c + 1);
  }
  for (let a = 0; a < n.length; a += 3)
    n[a + 1] == -1 && l(n[a + 2], e[a] + s + 1);
  return t;
}
function qA(n, e, t) {
  if (e.isLeaf)
    return null;
  let r = t + e.nodeSize, i = null;
  for (let s = 0, o; s < n.length; s++)
    (o = n[s]) && o.from > t && o.to < r && ((i || (i = [])).push(o), n[s] = null);
  return i;
}
function WA(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function vm(n, e, t, r) {
  let i = [], s = !1;
  e.forEach((l, a) => {
    let c = qA(n, l, a + t);
    if (c) {
      s = !0;
      let u = vm(c, l, t + a + 1, r);
      u != qn && i.push(a, a + l.nodeSize, u);
    }
  });
  let o = VA(s ? WA(n) : n, -t).sort(la);
  for (let l = 0; l < o.length; l++)
    o[l].type.valid(e, o[l]) || (r.onRemove && r.onRemove(o[l].spec), o.splice(l--, 1));
  return o.length || i.length ? new Ot(o, i) : qn;
}
function la(n, e) {
  return n.from - e.from || n.to - e.to;
}
function nb(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let r = e[t];
    if (r.from != r.to)
      for (let i = t + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == n && (e = n.slice()), e[i] = s.copy(s.from, r.to), Zx(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, s.from), Zx(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function Zx(n, e, t) {
  for (; e < n.length && la(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function y2(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let r = t(n.state);
    r && r != qn && e.push(r);
  }), n.cursorWrapper && e.push(Ot.create(n.state.doc, [n.cursorWrapper.deco])), jo.from(e);
}
const HK = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, $K = Er && nl <= 11;
class VK {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class qK {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new VK(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      Er && nl <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), $K && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, HK)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (Wx(this.view)) {
      if (this.suppressingSelectionUpdates)
        return io(this.view);
      if (Er && nl <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Ta(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), r;
    for (let s = e.focusNode; s; s = Hc(s))
      t.add(s);
    for (let s = e.anchorNode; s; s = Hc(s))
      if (t.has(s)) {
        r = s;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && Wx(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, l = !1, a = [];
    if (e.editable)
      for (let u = 0; u < t.length; u++) {
        let h = this.registerMutation(t[u], a);
        h && (s = s < 0 ? h.from : Math.min(h.from, s), o = o < 0 ? h.to : Math.max(h.to, o), h.typeOver && (l = !0));
      }
    if (pi && a.length) {
      let u = a.filter((h) => h.nodeName == "BR");
      if (u.length == 2) {
        let [h, f] = u;
        h.parentNode && h.parentNode.parentNode == f.parentNode ? f.remove() : h.remove();
      } else {
        let { focusNode: h } = this.currentSelection;
        for (let f of u) {
          let d = f.parentNode;
          d && d.nodeName == "LI" && (!h || UK(e, h) != d) && f.remove();
        }
      }
    }
    let c = null;
    s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && S1(r) && (c = Y3(e)) && c.eq(Ge.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, io(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), WK(e)), this.handleDOMChange(s, o, l, a), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || io(e), this.currentSelection.set(r));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let h = e.addedNodes[u];
        t.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, s = e.nextSibling;
      if (Er && nl <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: h, nextSibling: f } = e.addedNodes[u];
          (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (s = f);
        }
      let o = i && i.parentNode == e.target ? _n(i) + 1 : 0, l = r.localPosFromDOM(e.target, o, -1), a = s && s.parentNode == e.target ? _n(s) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, a, 1);
      return { from: l, to: c };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let Qx = /* @__PURE__ */ new WeakMap(), e8 = !1;
function WK(n) {
  if (!Qx.has(n) && (Qx.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = pi, e8)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), e8 = !0;
  }
}
function t8(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.domAtPos(n.state.selection.anchor);
  return Ta(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s };
}
function jK(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return t8(n, i);
  }
  let t;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", r, !0), t ? t8(n, t) : null;
}
function UK(n, e) {
  for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) {
    let r = n.docView.nearestDesc(t, !0);
    if (r && r.node.isBlock)
      return t;
  }
  return null;
}
function KK(n, e, t) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: l } = n.docView.parseRange(e, t), a = n.domSelectionRange(), c, u = a.anchorNode;
  if (u && n.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: a.anchorOffset }], S1(a) || c.push({ node: a.focusNode, offset: a.focusOffset })), Kn && n.input.lastKeyCode === 8)
    for (let g = s; g > i; g--) {
      let b = r.childNodes[g - 1], w = b.pmViewDesc;
      if (b.nodeName == "BR" && !w) {
        s = g;
        break;
      }
      if (!w || w.size)
        break;
    }
  let h = n.state.doc, f = n.someProp("domParser") || Sa.fromSchema(n.state.schema), d = h.resolve(o), p = null, m = f.parse(r, {
    topNode: d.parent,
    topMatch: d.parent.contentMatchAt(d.index()),
    topOpen: !0,
    from: i,
    to: s,
    preserveWhitespace: d.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: GK,
    context: d
  });
  if (c && c[0].pos != null) {
    let g = c[0].pos, b = c[1] && c[1].pos;
    b == null && (b = g), p = { anchor: g + o, head: b + o };
  }
  return { doc: m, sel: p, from: o, to: l };
}
function GK(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (dr && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || dr && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const YK = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function JK(n, e, t, r, i) {
  let s = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
  if (n.input.compositionPendingChanges = 0, e < 0) {
    let B = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, $ = Y3(n, B);
    if ($ && !n.state.selection.eq($)) {
      if (Kn && Qs && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (V) => V(n, Yl(13, "Enter"))))
        return;
      let R = n.state.tr.setSelection($);
      B == "pointer" ? R.setMeta("pointer", !0) : B == "key" && R.scrollIntoView(), s && R.setMeta("composition", s), n.dispatch(R);
    }
    return;
  }
  let o = n.state.doc.resolve(e), l = o.sharedDepth(t);
  e = o.before(l + 1), t = n.state.doc.resolve(t).after(l + 1);
  let a = n.state.selection, c = KK(n, e, t), u = n.state.doc, h = u.slice(c.from, c.to), f, d;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (f = n.state.selection.to, d = "end") : (f = n.state.selection.from, d = "start"), n.input.lastKeyCode = null;
  let p = QK(h.content, c.doc.content, c.from, f, d);
  if (p && n.input.domChangeCount++, ($c && n.input.lastIOSEnter > Date.now() - 225 || Qs) && i.some((B) => B.nodeType == 1 && !YK.test(B.nodeName)) && (!p || p.endA >= p.endB) && n.someProp("handleKeyDown", (B) => B(n, Yl(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!p)
    if (r && a instanceof Ee && !a.empty && a.$head.sameParent(a.$anchor) && !n.composing && !(c.sel && c.sel.anchor != c.sel.head))
      p = { start: a.from, endA: a.to, endB: a.to };
    else {
      if (c.sel) {
        let B = n8(n, n.state.doc, c.sel);
        if (B && !B.eq(n.state.selection)) {
          let $ = n.state.tr.setSelection(B);
          s && $.setMeta("composition", s), n.dispatch($);
        }
      }
      return;
    }
  n.state.selection.from < n.state.selection.to && p.start == p.endB && n.state.selection instanceof Ee && (p.start > n.state.selection.from && p.start <= n.state.selection.from + 2 && n.state.selection.from >= c.from ? p.start = n.state.selection.from : p.endA < n.state.selection.to && p.endA >= n.state.selection.to - 2 && n.state.selection.to <= c.to && (p.endB += n.state.selection.to - p.endA, p.endA = n.state.selection.to)), Er && nl <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > c.from && c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == "  " && (p.start--, p.endA--, p.endB--);
  let m = c.doc.resolveNoCache(p.start - c.from), g = c.doc.resolveNoCache(p.endB - c.from), b = u.resolve(p.start), w = m.sameParent(g) && m.parent.inlineContent && b.end() >= p.endA, k;
  if (($c && n.input.lastIOSEnter > Date.now() - 225 && (!w || i.some((B) => B.nodeName == "DIV" || B.nodeName == "P")) || !w && m.pos < c.doc.content.size && (!m.sameParent(g) || !m.parent.inlineContent) && !/\S/.test(c.doc.textBetween(m.pos, g.pos, "", "")) && (k = Ge.findFrom(c.doc.resolve(m.pos + 1), 1, !0)) && k.head > m.pos) && n.someProp("handleKeyDown", (B) => B(n, Yl(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > p.start && ZK(u, p.start, p.endA, m, g) && n.someProp("handleKeyDown", (B) => B(n, Yl(8, "Backspace")))) {
    Qs && Kn && n.domObserver.suppressSelectionUpdates();
    return;
  }
  Kn && p.endB == p.start && (n.input.lastChromeDelete = Date.now()), Qs && !w && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == p.endA && (p.endB -= 2, g = c.doc.resolveNoCache(p.endB - c.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(B) {
      return B(n, Yl(13, "Enter"));
    });
  }, 20));
  let C = p.start, M = p.endA, T = (B) => {
    let $ = B || n.state.tr.replace(C, M, c.doc.slice(p.start - c.from, p.endB - c.from));
    if (c.sel) {
      let R = n8(n, $.doc, c.sel);
      R && !(Kn && n.composing && R.empty && (p.start != p.endB || n.input.lastChromeDelete < Date.now() - 100) && (R.head == C || R.head == $.mapping.map(M) - 1) || Er && R.empty && R.head == C) && $.setSelection(R);
    }
    return s && $.setMeta("composition", s), $.scrollIntoView();
  }, N;
  if (w) {
    if (m.pos == g.pos) {
      Er && nl <= 11 && m.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => io(n), 20));
      let B = T(n.state.tr.delete(C, M)), $ = u.resolve(p.start).marksAcross(u.resolve(p.endA));
      $ && B.ensureMarks($), n.dispatch(B);
    } else if (
      // Adding or removing a mark
      p.endA == p.endB && (N = XK(m.parent.content.cut(m.parentOffset, g.parentOffset), b.parent.content.cut(b.parentOffset, p.endA - b.start())))
    ) {
      let B = T(n.state.tr);
      N.type == "add" ? B.addMark(C, M, N.mark) : B.removeMark(C, M, N.mark), n.dispatch(B);
    } else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let B = m.parent.textBetween(m.parentOffset, g.parentOffset), $ = () => T(n.state.tr.insertText(B, C, M));
      n.someProp("handleTextInput", (R) => R(n, C, M, B, $)) || n.dispatch($());
    }
  } else
    n.dispatch(T());
}
function n8(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : J3(n, e.resolve(t.anchor), e.resolve(t.head));
}
function XK(n, e) {
  let t = n.firstChild.marks, r = e.firstChild.marks, i = t, s = r, o, l, a;
  for (let u = 0; u < r.length; u++)
    i = r[u].removeFromSet(i);
  for (let u = 0; u < t.length; u++)
    s = t[u].removeFromSet(s);
  if (i.length == 1 && s.length == 0)
    l = i[0], o = "add", a = (u) => u.mark(l.addToSet(u.marks));
  else if (i.length == 0 && s.length == 1)
    l = s[0], o = "remove", a = (u) => u.mark(l.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(a(e.child(u)));
  if (ce.from(c).eq(n))
    return { mark: l, type: o };
}
function ZK(n, e, t, r, i) {
  if (
    // The content must have shrunk
    t - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    b2(r, !0, !1) < i.pos
  )
    return !1;
  let s = n.resolve(e);
  if (!r.parent.isTextblock) {
    let l = s.nodeAfter;
    return l != null && t == e + l.nodeSize;
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = n.resolve(b2(s, !0, !0));
  return !o.parent.isTextblock || o.pos > t || b2(o, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
}
function b2(n, e, t) {
  let r = n.depth, i = e ? n.end() : n.pos;
  for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount); )
    r--, i++, e = !1;
  if (t) {
    let s = n.node(r).maybeChild(n.indexAfter(r));
    for (; s && !s.isLeaf; )
      s = s.firstChild, i++;
  }
  return i;
}
function QK(n, e, t, r, i) {
  let s = n.findDiffStart(e, t);
  if (s == null)
    return null;
  let { a: o, b: l } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (i == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    r -= o + a - s;
  }
  if (o < s && n.size < e.size) {
    let a = r <= s && r >= o ? s - r : 0;
    s -= a, s && s < e.size && r8(e.textBetween(s - 1, s + 1)) && (s += a ? 1 : -1), l = s + (l - o), o = s;
  } else if (l < s) {
    let a = r <= s && r >= l ? s - r : 0;
    s -= a, s && s < n.size && r8(n.textBetween(s - 1, s + 1)) && (s += a ? 1 : -1), o = s + (o - l), l = s;
  }
  return { start: s, endA: o, endB: l };
}
function r8(n) {
  if (n.length != 2)
    return !1;
  let e = n.charCodeAt(0), t = n.charCodeAt(1);
  return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
}
class rb {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new bK(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(a8), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = o8(this), s8(this), this.nodeViews = l8(this), this.docView = zx(this.state.doc, i8(this), y2(this), this.dom, this), this.domObserver = new qK(this, (r, i, s, o) => JK(this, r, i, s, o)), this.domObserver.start(), vK(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Jy(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(a8), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let r in this._props)
      t[r] = this._props[r];
    t.state = this.state;
    for (let r in e)
      t[r] = e[r];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    var r;
    let i = this.state, s = !1, o = !1;
    e.storedMarks && this.composing && (zA(this), o = !0), this.state = e;
    let l = i.plugins != e.plugins || this._props.plugins != t.plugins;
    if (l || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let d = l8(this);
      tG(d, this.nodeViews) && (this.nodeViews = d, s = !0);
    }
    (l || t.handleDOMEvents != this._props.handleDOMEvents) && Jy(this), this.editable = o8(this), s8(this);
    let a = y2(this), c = i8(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", h = s || !this.docView.matchesNode(e.doc, c, a);
    (h || !e.selection.eq(i.selection)) && (o = !0);
    let f = u == "preserve" && o && this.dom.style.overflowAnchor == null && RU(this);
    if (o) {
      this.domObserver.stop();
      let d = h && (Er || Kn) && !this.composing && !i.selection.empty && !e.selection.empty && eG(i.selection, e.selection);
      if (h) {
        let p = Kn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = NK(this)), (s || !this.docView.update(e.doc, c, a, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = zx(e.doc, c, a, this.dom, this)), p && !this.trackWrites && (d = !0);
      }
      d || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && rK(this)) ? io(this, d) : (TA(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && PU(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof $e) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && Nx(this, t.getBoundingClientRect(), e);
      } else
        Nx(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let r = this.directPlugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let r = this.state.plugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, t) {
    let r = e.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let s = r.from + (this.state.doc.content.size - t.doc.content.size);
      (s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s);
    }
    this.dragging = new HA(e.slice, e.move, i < 0 ? void 0 : $e.create(this.state.doc, i));
  }
  someProp(e, t) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = t ? t(r) : r))
      return i;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let l = this.directPlugins[o].props[e];
      if (l != null && (i = t ? t(l) : l))
        return i;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let l = s[o].props[e];
        if (l != null && (i = t ? t(l) : l))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Er) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && _U(this.dom), io(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return HU(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return bA(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, r = -1) {
    let i = this.docView.posFromDOM(e, t, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return jU(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return zf(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return zf(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return X3(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (wK(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], y2(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, kU());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return kK(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? dr && this.root.nodeType === 11 && AU(this.dom.ownerDocument) == this.dom && jK(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
rb.prototype.dispatch = function(n) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, n) : this.updateState(this.state.apply(n));
};
function i8(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let r in t)
        r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
  }), e.translate || (e.translate = "no"), [mn.node(0, n.state.doc.content.size, e)];
}
function s8(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: mn.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function o8(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function eG(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function l8(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function tG(n, e) {
  let t = 0, r = 0;
  for (let i in n) {
    if (n[i] != e[i])
      return !0;
    t++;
  }
  for (let i in e)
    r++;
  return t != r;
}
function a8(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
function Ml(n, e) {
  return n.meta = {
    package: "@milkdown/core",
    group: "System",
    ...e
  }, n;
}
const jA = {
  text: (n, e, t, r) => {
    const i = n.value;
    return /^[^*_\\]*\s+$/.test(i) ? i : t.safe(i, { ...r, encode: [] });
  },
  strong: (n, e, t, r) => {
    const i = n.marker || t.options.strong || "*", s = t.enter("strong"), o = t.createTracker(r);
    let l = o.move(i + i);
    return l += o.move(
      t.containerPhrasing(n, {
        before: l,
        after: i,
        ...o.current()
      })
    ), l += o.move(i + i), s(), l;
  },
  emphasis: (n, e, t, r) => {
    const i = n.marker || t.options.emphasis || "*", s = t.enter("emphasis"), o = t.createTracker(r);
    let l = o.move(i);
    return l += o.move(
      t.containerPhrasing(n, {
        before: l,
        after: i,
        ...o.current()
      })
    ), l += o.move(i), s(), l;
  }
}, Lt = at({}, "editorView"), fh = at({}, "editorState"), v2 = at([], "initTimer"), Xy = at({}, "editor"), Hf = at([], "inputRules"), dl = at([], "prosePlugins"), $f = at(
  [],
  "remarkPlugins"
), Vf = at([], "nodeView"), qf = at([], "markView"), aa = at(
  By().use(Iy).use(Py),
  "remark"
), Gh = at(
  {
    handlers: jA,
    encode: []
  },
  "remarkStringifyOptions"
), pp = xo("ConfigReady");
function nG(n) {
  const e = (t) => (t.record(pp), async () => (await n(t), t.done(pp), () => {
    t.clearTimer(pp);
  }));
  return Ml(e, {
    displayName: "Config"
  }), e;
}
const ca = xo("InitReady");
function rG(n) {
  const e = (t) => (t.inject(Xy, n).inject(dl, []).inject($f, []).inject(Hf, []).inject(Vf, []).inject(qf, []).inject(Gh, {
    handlers: jA,
    encode: []
  }).inject(aa, By().use(Iy).use(Py)).inject(v2, [pp]).record(ca), async () => {
    await t.waitTimers(v2);
    const r = t.get(Gh);
    return t.set(
      aa,
      By().use(Iy).use(Py, r)
    ), t.done(ca), () => {
      t.remove(Xy).remove(dl).remove($f).remove(Hf).remove(Vf).remove(qf).remove(Gh).remove(aa).remove(v2).clearTimer(ca);
    };
  });
  return Ml(e, {
    displayName: "Init"
  }), e;
}
const gi = xo("SchemaReady"), w2 = at([], "schemaTimer"), bs = at({}, "schema"), Yh = at([], "nodes"), Jh = at([], "marks");
function c8(n) {
  return {
    ...n,
    parseDOM: n.parseDOM?.map((e) => ({ priority: n.priority, ...e }))
  };
}
const UA = (n) => (n.inject(bs, {}).inject(Yh, []).inject(Jh, []).inject(w2, [ca]).record(gi), async () => {
  await n.waitTimers(w2);
  const e = n.get(aa), r = n.get($f).reduce(
    (l, a) => l.use(a.plugin, a.options),
    e
  );
  n.set(aa, r);
  const i = Object.fromEntries(
    n.get(Yh).map(([l, a]) => [l, c8(a)])
  ), s = Object.fromEntries(
    n.get(Jh).map(([l, a]) => [l, c8(a)])
  ), o = new YM({ nodes: i, marks: s });
  return n.set(bs, o), n.done(gi), () => {
    n.remove(bs).remove(Yh).remove(Jh).remove(w2).clearTimer(gi);
  };
});
Ml(UA, {
  displayName: "Schema"
});
class KA {
  constructor() {
    this.#t = new kT(), this.#e = null, this.setCtx = (e) => {
      this.#e = e;
    }, this.chain = () => {
      if (this.#e == null) throw e2();
      const e = this.#e, t = [], r = this.get.bind(this), i = {
        run: () => {
          const o = nu(...t), l = e.get(Lt);
          return o(l.state, l.dispatch, l);
        },
        inline: (o) => (t.push(o), i),
        pipe: s.bind(this)
      };
      function s(o, l) {
        const a = r(o);
        return t.push(a(l)), i;
      }
      return i;
    };
  }
  #t;
  #e;
  get ctx() {
    return this.#e;
  }
  /// Register a command into the manager.
  create(e, t) {
    const r = e.create(this.#t.sliceMap);
    return r.set(t), r;
  }
  get(e) {
    return this.#t.get(e).get();
  }
  remove(e) {
    return this.#t.remove(e);
  }
  call(e, t) {
    if (this.#e == null) throw e2();
    const i = this.get(e)(t), s = this.#e.get(Lt);
    return i(s.state, s.dispatch, s);
  }
  /// Call an inline command.
  inline(e) {
    if (this.#e == null) throw e2();
    const t = this.#e.get(Lt);
    return e(t.state, t.dispatch, t);
  }
}
function iG(n = "cmdKey") {
  return at((() => () => !1), n);
}
const Me = at(new KA(), "commands"), x2 = at([gi], "commandsTimer"), Xh = xo("CommandsReady"), GA = (n) => {
  const e = new KA();
  return e.setCtx(n), n.inject(Me, e).inject(x2, [gi]).record(Xh), async () => (await n.waitTimers(x2), n.done(Xh), () => {
    n.remove(Me).remove(x2).clearTimer(Xh);
  });
};
Ml(GA, {
  displayName: "Commands"
});
function sG(n) {
  const e = nu(
    H$,
    q3,
    tU,
    sA
  );
  return n.Backspace = e, n;
}
class YA {
  constructor() {
    this.#t = null, this.#e = [], this.setCtx = (e) => {
      this.#t = e;
    }, this.add = (e) => (this.#e.push(e), () => {
      this.#e = this.#e.filter((t) => t !== e);
    }), this.addObjectKeymap = (e) => {
      const t = [];
      return Object.entries(e).forEach(([r, i]) => {
        if (typeof i == "function") {
          const s = {
            key: r,
            onRun: () => i
          };
          this.#e.push(s), t.push(() => {
            this.#e = this.#e.filter((o) => o !== s);
          });
        } else
          this.#e.push(i), t.push(() => {
            this.#e = this.#e.filter((s) => s !== i);
          });
      }), () => {
        t.forEach((r) => r());
      };
    }, this.addBaseKeymap = () => {
      const e = sG(yU);
      return this.addObjectKeymap(e);
    }, this.build = () => {
      const e = {};
      return this.#e.forEach((r) => {
        e[r.key] = [...e[r.key] || [], r];
      }), Object.fromEntries(
        Object.entries(e).map(([r, i]) => {
          const s = i.sort(
            (l, a) => (a.priority ?? 50) - (l.priority ?? 50)
          );
          return [r, (l, a, c) => {
            const u = this.#t;
            if (u == null) throw m1();
            const h = s.map((d) => d.onRun(u));
            return nu(...h)(l, a, c);
          }];
        })
      );
    };
  }
  #t;
  #e;
  get ctx() {
    return this.#t;
  }
}
const wm = at(new YA(), "keymap"), k2 = at([gi], "keymapTimer"), Zh = xo("KeymapReady"), oG = (n) => {
  const e = new YA();
  return e.setCtx(n), n.inject(wm, e).inject(k2, [gi]).record(Zh), async () => (await n.waitTimers(k2), n.done(Zh), () => {
    n.remove(wm).remove(k2).clearTimer(Zh);
  });
}, mp = xo("ParserReady"), JA = (() => {
  throw m1();
}), Qh = at(JA, "parser"), S2 = at([], "parserTimer"), XA = (n) => (n.inject(Qh, JA).inject(S2, [gi]).record(mp), async () => {
  await n.waitTimers(S2);
  const e = n.get(aa), t = n.get(bs);
  return n.set(Qh, Zj.create(t, e)), n.done(mp), () => {
    n.remove(Qh).remove(S2).clearTimer(mp);
  };
});
Ml(XA, {
  displayName: "Parser"
});
const ef = xo("SerializerReady"), C2 = at(
  [],
  "serializerTimer"
), ZA = (() => {
  throw m1();
}), xc = at(
  ZA,
  "serializer"
), QA = (n) => (n.inject(xc, ZA).inject(C2, [gi]).record(ef), async () => {
  await n.waitTimers(C2);
  const e = n.get(aa), t = n.get(bs);
  return n.set(xc, eU.create(t, e)), n.done(ef), () => {
    n.remove(xc).remove(C2).clearTimer(ef);
  };
});
Ml(QA, {
  displayName: "Serializer"
});
const gp = at("", "defaultValue"), M2 = at(
  (n) => n,
  "stateOptions"
), T2 = at(
  [],
  "editorStateTimer"
), yp = xo("EditorStateReady");
function lG(n, e, t) {
  if (typeof n == "string") return e(n);
  if (n.type === "html")
    return Sa.fromSchema(t).parse(n.dom);
  if (n.type === "json")
    return ro.fromJSON(t, n.value);
  throw V$(n);
}
const aG = new en("MILKDOWN_STATE_TRACKER"), eO = (n) => (n.inject(gp, "").inject(fh, {}).inject(M2, (e) => e).inject(T2, [
  mp,
  ef,
  Xh,
  Zh
]).record(yp), async () => {
  await n.waitTimers(T2);
  const e = n.get(bs), t = n.get(Qh), r = n.get(Hf), i = n.get(M2), s = n.get(dl), o = n.get(gp), l = lG(o, t, e), a = n.get(wm), c = a.addBaseKeymap(), u = [
    ...s,
    new Ut({
      key: aG,
      state: {
        init: () => {
        },
        apply: (d, p, m, g) => {
          n.set(fh, g);
        }
      }
    }),
    sV({ rules: r }),
    hA(a.build())
  ];
  n.set(dl, u);
  const h = i({
    schema: e,
    doc: l,
    plugins: u
  }), f = Zl.create(h);
  return n.set(fh, f), n.done(yp), () => {
    c(), n.remove(gp).remove(fh).remove(M2).remove(T2).clearTimer(yp);
  };
});
Ml(eO, {
  displayName: "EditorState"
});
const bp = xo("EditorViewReady"), A2 = at(
  [],
  "editorViewTimer"
), tf = at(
  {},
  "editorViewOptions"
), vp = at(null, "root"), Zy = at(null, "rootDOM"), Qy = at(
  {},
  "rootAttrs"
);
function cG(n, e) {
  const t = document.createElement("div");
  t.className = "milkdown", n.appendChild(t), e.set(Zy, t);
  const r = e.get(Qy);
  return Object.entries(r).forEach(
    ([i, s]) => t.setAttribute(i, s)
  ), t;
}
function uG(n) {
  n.classList.add("editor"), n.setAttribute("role", "textbox");
}
const hG = new en("MILKDOWN_VIEW_CLEAR"), tO = (n) => (n.inject(vp, document.body).inject(Lt, {}).inject(tf, {}).inject(Zy, null).inject(Qy, {}).inject(A2, [yp]).record(bp), async () => {
  await n.wait(ca);
  const e = n.get(vp) || document.body, t = typeof e == "string" ? document.querySelector(e) : e;
  n.update(dl, (a) => [
    new Ut({
      key: hG,
      view: (c) => {
        const u = t ? cG(t, n) : void 0;
        return (() => {
          if (u && t) {
            const f = c.dom;
            t.replaceChild(u, f), u.appendChild(f);
          }
        })(), {
          destroy: () => {
            u?.parentNode && u?.parentNode.replaceChild(c.dom, u), u?.remove();
          }
        };
      }
    }),
    ...a
  ]), await n.waitTimers(A2);
  const r = n.get(fh), i = n.get(tf), s = Object.fromEntries(n.get(Vf)), o = Object.fromEntries(n.get(qf)), l = new rb(t, {
    state: r,
    nodeViews: s,
    markViews: o,
    ...i
  });
  return uG(l.dom), n.set(Lt, l), n.done(bp), () => {
    l?.destroy(), n.remove(vp).remove(Lt).remove(tf).remove(Zy).remove(Qy).remove(A2).clearTimer(bp);
  };
});
Ml(tO, {
  displayName: "EditorView"
});
var xm = /* @__PURE__ */ ((n) => (n.Idle = "Idle", n.OnCreate = "OnCreate", n.Created = "Created", n.OnDestroy = "OnDestroy", n.Destroyed = "Destroyed", n))(xm || {});
class ib {
  constructor() {
    this.#t = !1, this.#e = "Idle", this.#r = [], this.#n = () => {
    }, this.#a = new kT(), this.#i = new SV(), this.#s = /* @__PURE__ */ new Map(), this.#o = /* @__PURE__ */ new Map(), this.#l = new R3(this.#a, this.#i), this.#c = () => {
      const e = nG(async (r) => {
        await Promise.all(this.#r.map((i) => i(r)));
      }), t = [
        UA,
        XA,
        QA,
        GA,
        oG,
        eO,
        tO,
        rG(this),
        e
      ];
      this.#u(t, this.#o);
    }, this.#u = (e, t) => {
      e.forEach((r) => {
        const i = this.#l.produce(
          this.#t ? r.meta : void 0
        ), s = r(i);
        t.set(r, { ctx: i, handler: s, cleanup: void 0 });
      });
    }, this.#h = (e, t = !1) => Promise.all(
      [e].flat().map((r) => {
        const s = this.#s.get(r)?.cleanup;
        return t ? this.#s.delete(r) : this.#s.set(r, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        }), typeof s == "function" ? s() : s;
      })
    ), this.#d = async () => {
      await Promise.all(
        [...this.#o.entries()].map(([e, { cleanup: t }]) => typeof t == "function" ? t() : t)
      ), this.#o.clear();
    }, this.#f = (e) => {
      this.#e = e, this.#n(e);
    }, this.#p = (e) => [...e.entries()].map(async ([t, r]) => {
      const { ctx: i, handler: s } = r;
      if (!s) return;
      const o = await s();
      e.set(t, { ctx: i, handler: s, cleanup: o });
    }), this.enableInspector = (e = !0) => (this.#t = e, this), this.onStatusChange = (e) => (this.#n = e, this), this.config = (e) => (this.#r.push(e), this), this.removeConfig = (e) => (this.#r = this.#r.filter((t) => t !== e), this), this.use = (e) => {
      const t = [e].flat();
      return t.flat().forEach((r) => {
        this.#s.set(r, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        });
      }), this.#e === "Created" && this.#u(t, this.#s), this;
    }, this.remove = async (e) => this.#e === "OnCreate" ? (console.warn(
      "[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code."
    ), new Promise((t) => {
      setTimeout(() => {
        t(this.remove(e));
      }, 50);
    })) : (await this.#h([e].flat(), !0), this), this.create = async () => this.#e === "OnCreate" ? this : (this.#e === "Created" && await this.destroy(), this.#f(
      "OnCreate"
      /* OnCreate */
    ), this.#c(), this.#u([...this.#s.keys()], this.#s), await Promise.all(
      [
        this.#p(this.#o),
        this.#p(this.#s)
      ].flat()
    ), this.#f(
      "Created"
      /* Created */
    ), this), this.destroy = async (e = !1) => this.#e === "Destroyed" || this.#e === "OnDestroy" ? this : this.#e === "OnCreate" ? new Promise((t) => {
      setTimeout(() => {
        t(this.destroy(e));
      }, 50);
    }) : (e && (this.#r = []), this.#f(
      "OnDestroy"
      /* OnDestroy */
    ), await this.#h([...this.#s.keys()], e), await this.#d(), this.#f(
      "Destroyed"
      /* Destroyed */
    ), this), this.action = (e) => e(this.#l), this.inspect = () => this.#t ? [...this.#o.values(), ...this.#s.values()].map(({ ctx: e }) => e?.inspector?.read()).filter((e) => !!e) : (console.warn(
      "[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first."
    ), []);
  }
  /// Create a new editor instance.
  static make() {
    return new ib();
  }
  #t;
  #e;
  #r;
  #n;
  #a;
  #i;
  #s;
  #o;
  #l;
  #c;
  #u;
  #h;
  #d;
  #f;
  #p;
  /// Get the ctx of the editor.
  get ctx() {
    return this.#l;
  }
  /// Get the status of the editor.
  get status() {
    return this.#e;
  }
}
function Ye(n, e) {
  const t = iG(n), r = (i) => async () => {
    r.key = t, await i.wait(Xh);
    const s = e(i);
    return i.get(Me).create(t, s), r.run = (o) => i.get(Me).call(n, o), () => {
      i.get(Me).remove(t);
    };
  };
  return r;
}
function Qn(n) {
  const e = (t) => async () => {
    await t.wait(gi);
    const r = n(t);
    return t.update(Hf, (i) => [...i, r]), e.inputRule = r, () => {
      t.update(Hf, (i) => i.filter((s) => s !== r));
    };
  };
  return e;
}
function fG(n, e) {
  const t = (r) => async () => {
    const i = e(r);
    return r.update(Jh, (s) => [
      ...s.filter((o) => o[0] !== n),
      [n, i]
    ]), t.id = n, t.schema = i, () => {
      r.update(Jh, (s) => s.filter(([o]) => o !== n));
    };
  };
  return t.type = (r) => {
    const i = r.get(bs).marks[n];
    if (!i) throw J$(n);
    return i;
  }, t;
}
function sb(n, e) {
  const t = (r) => async () => {
    const i = e(r);
    return r.update(Yh, (s) => [
      ...s.filter((o) => o[0] !== n),
      [n, i]
    ]), t.id = n, t.schema = i, () => {
      r.update(Yh, (s) => s.filter(([o]) => o !== n));
    };
  };
  return t.type = (r) => {
    const i = r.get(bs).nodes[n];
    if (!i) throw Y$(n);
    return i;
  }, t;
}
function kn(n) {
  let e;
  const t = (r) => async () => (await r.wait(gi), e = n(r), r.update(dl, (i) => [...i, e]), () => {
    r.update(dl, (i) => i.filter((s) => s !== e));
  });
  return t.plugin = () => e, t.key = () => e.spec.key, t;
}
function nO(n) {
  const e = (t) => async () => {
    await t.wait(Zh);
    const r = t.get(wm), i = n(t), s = r.addObjectKeymap(i);
    return e.keymap = i, () => {
      s();
    };
  };
  return e;
}
function yd(n, e) {
  const t = (r) => async () => {
    await r.wait(gi);
    const i = e(r);
    return n.type(r) instanceof fm ? r.update(Vf, (s) => [
      ...s,
      [n.id, i]
    ]) : r.update(qf, (s) => [
      ...s,
      [n.id, i]
    ]), t.view = i, t.type = n, () => {
      n.type(r) instanceof fm ? r.update(Vf, (s) => s.filter((o) => o[0] !== n.id)) : r.update(qf, (s) => s.filter((o) => o[0] !== n.id));
    };
  };
  return t;
}
function St(n, e) {
  const t = at(n, e), r = (i) => (i.inject(t), () => () => {
    i.remove(t);
  });
  return r.key = t, r;
}
function hn(n, e) {
  const t = St(e, n), r = sb(n, (s) => s.get(t.key)(s)), i = [t, r];
  return i.id = r.id, i.node = r, i.type = (s) => r.type(s), i.ctx = t, i.key = t.key, i.extendSchema = (s) => {
    const o = s(e);
    return hn(n, o);
  }, i;
}
function ru(n, e) {
  const t = St(e, n), r = fG(n, (s) => s.get(t.key)(s)), i = [t, r];
  return i.id = r.id, i.mark = r, i.type = (s) => r.type(s), i.ctx = t, i.key = t.key, i.extendSchema = (s) => {
    const o = s(e);
    return ru(n, o);
  }, i;
}
function Rr(n, e) {
  const t = Object.fromEntries(
    Object.entries(e).map(
      ([o, { shortcuts: l, priority: a }]) => [o, { shortcuts: l, priority: a }]
    )
  ), r = St(t, `${n}Keymap`), i = nO((o) => {
    const l = o.get(r.key), a = Object.entries(e).flatMap(
      ([c, { command: u }]) => {
        const h = l[c], f = [h.shortcuts].flat(), d = h.priority;
        return f.map(
          (p) => [
            p,
            {
              key: p,
              onRun: u,
              priority: d
            }
          ]
        );
      }
    );
    return Object.fromEntries(a);
  }), s = [r, i];
  return s.ctx = r, s.shortcuts = i, s.key = r.key, s.keymap = i.keymap, s;
}
const qi = (n, e = () => ({})) => St(e, `${n}Attr`), bd = (n, e = () => ({})) => St(e, `${n}Attr`);
function As(n, e, t) {
  const r = St({}, n), i = (o) => async () => {
    await o.wait(ca);
    const a = {
      plugin: e(o),
      options: o.get(r.key)
    };
    return o.update($f, (c) => [...c, a]), () => {
      o.update($f, (c) => c.filter((u) => u !== a));
    };
  }, s = [r, i];
  return s.id = n, s.plugin = i, s.options = r, s;
}
function dG(n) {
  return (e) => {
    const t = e.get(Lt);
    return e.get(bs), e.get(xc)(t.state.doc);
  };
}
const e5 = Math.min, kc = Math.max, km = Math.round, vs = (n) => ({
  x: n,
  y: n
}), pG = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, mG = {
  start: "end",
  end: "start"
};
function u8(n, e, t) {
  return kc(n, e5(e, t));
}
function T1(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function Oa(n) {
  return n.split("-")[0];
}
function A1(n) {
  return n.split("-")[1];
}
function rO(n) {
  return n === "x" ? "y" : "x";
}
function iO(n) {
  return n === "y" ? "height" : "width";
}
const gG = /* @__PURE__ */ new Set(["top", "bottom"]);
function Qo(n) {
  return gG.has(Oa(n)) ? "y" : "x";
}
function sO(n) {
  return rO(Qo(n));
}
function yG(n, e, t) {
  t === void 0 && (t = !1);
  const r = A1(n), i = sO(n), s = iO(i);
  let o = i === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (o = Sm(o)), [o, Sm(o)];
}
function bG(n) {
  const e = Sm(n);
  return [t5(n), e, t5(e)];
}
function t5(n) {
  return n.replace(/start|end/g, (e) => mG[e]);
}
const h8 = ["left", "right"], f8 = ["right", "left"], vG = ["top", "bottom"], wG = ["bottom", "top"];
function xG(n, e, t) {
  switch (n) {
    case "top":
    case "bottom":
      return t ? e ? f8 : h8 : e ? h8 : f8;
    case "left":
    case "right":
      return e ? vG : wG;
    default:
      return [];
  }
}
function kG(n, e, t, r) {
  const i = A1(n);
  let s = xG(Oa(n), t === "start", r);
  return i && (s = s.map((o) => o + "-" + i), e && (s = s.concat(s.map(t5)))), s;
}
function Sm(n) {
  return n.replace(/left|right|bottom|top/g, (e) => pG[e]);
}
function SG(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function CG(n) {
  return typeof n != "number" ? SG(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function Cm(n) {
  const {
    x: e,
    y: t,
    width: r,
    height: i
  } = n;
  return {
    width: r,
    height: i,
    top: t,
    left: e,
    right: e + r,
    bottom: t + i,
    x: e,
    y: t
  };
}
function d8(n, e, t) {
  let {
    reference: r,
    floating: i
  } = n;
  const s = Qo(e), o = sO(e), l = iO(o), a = Oa(e), c = s === "y", u = r.x + r.width / 2 - i.width / 2, h = r.y + r.height / 2 - i.height / 2, f = r[l] / 2 - i[l] / 2;
  let d;
  switch (a) {
    case "top":
      d = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      d = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      d = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      d = {
        x: r.x - i.width,
        y: h
      };
      break;
    default:
      d = {
        x: r.x,
        y: r.y
      };
  }
  switch (A1(e)) {
    case "start":
      d[o] -= f * (t && c ? -1 : 1);
      break;
    case "end":
      d[o] += f * (t && c ? -1 : 1);
      break;
  }
  return d;
}
const MG = async (n, e, t) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: o
  } = t, l = s.filter(Boolean), a = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let c = await o.getElementRects({
    reference: n,
    floating: e,
    strategy: i
  }), {
    x: u,
    y: h
  } = d8(c, r, a), f = r, d = {}, p = 0;
  for (let m = 0; m < l.length; m++) {
    const {
      name: g,
      fn: b
    } = l[m], {
      x: w,
      y: k,
      data: C,
      reset: M
    } = await b({
      x: u,
      y: h,
      initialPlacement: r,
      placement: f,
      strategy: i,
      middlewareData: d,
      rects: c,
      platform: o,
      elements: {
        reference: n,
        floating: e
      }
    });
    u = w ?? u, h = k ?? h, d = {
      ...d,
      [g]: {
        ...d[g],
        ...C
      }
    }, M && p <= 50 && (p++, typeof M == "object" && (M.placement && (f = M.placement), M.rects && (c = M.rects === !0 ? await o.getElementRects({
      reference: n,
      floating: e,
      strategy: i
    }) : M.rects), {
      x: u,
      y: h
    } = d8(c, f, a)), m = -1);
  }
  return {
    x: u,
    y: h,
    placement: f,
    strategy: i,
    middlewareData: d
  };
};
async function oO(n, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: o,
    elements: l,
    strategy: a
  } = n, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: h = "floating",
    altBoundary: f = !1,
    padding: d = 0
  } = T1(e, n), p = CG(d), g = l[f ? h === "floating" ? "reference" : "floating" : h], b = Cm(await s.getClippingRect({
    element: (t = await (s.isElement == null ? void 0 : s.isElement(g))) == null || t ? g : g.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(l.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: a
  })), w = h === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l.floating)), C = await (s.isElement == null ? void 0 : s.isElement(k)) ? await (s.getScale == null ? void 0 : s.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, M = Cm(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: w,
    offsetParent: k,
    strategy: a
  }) : w);
  return {
    top: (b.top - M.top + p.top) / C.y,
    bottom: (M.bottom - b.bottom + p.bottom) / C.y,
    left: (b.left - M.left + p.left) / C.x,
    right: (M.right - b.right + p.right) / C.x
  };
}
const TG = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: i,
        middlewareData: s,
        rects: o,
        initialPlacement: l,
        platform: a,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: h = !0,
        fallbackPlacements: f,
        fallbackStrategy: d = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: m = !0,
        ...g
      } = T1(n, e);
      if ((t = s.arrow) != null && t.alignmentOffset)
        return {};
      const b = Oa(i), w = Qo(l), k = Oa(l) === l, C = await (a.isRTL == null ? void 0 : a.isRTL(c.floating)), M = f || (k || !m ? [Sm(l)] : bG(l)), T = p !== "none";
      !f && T && M.push(...kG(l, m, p, C));
      const N = [l, ...M], B = await oO(e, g), $ = [];
      let R = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (u && $.push(B[b]), h) {
        const ie = yG(i, o, C);
        $.push(B[ie[0]], B[ie[1]]);
      }
      if (R = [...R, {
        placement: i,
        overflows: $
      }], !$.every((ie) => ie <= 0)) {
        var V, z;
        const ie = (((V = s.flip) == null ? void 0 : V.index) || 0) + 1, he = N[ie];
        if (he && (!(h === "alignment" ? w !== Qo(he) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        R.every((ye) => Qo(ye.placement) === w ? ye.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ie,
              overflows: R
            },
            reset: {
              placement: he
            }
          };
        let Se = (z = R.filter((ge) => ge.overflows[0] <= 0).sort((ge, ye) => ge.overflows[1] - ye.overflows[1])[0]) == null ? void 0 : z.placement;
        if (!Se)
          switch (d) {
            case "bestFit": {
              var ue;
              const ge = (ue = R.filter((ye) => {
                if (T) {
                  const ze = Qo(ye.placement);
                  return ze === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ze === "y";
                }
                return !0;
              }).map((ye) => [ye.placement, ye.overflows.filter((ze) => ze > 0).reduce((ze, I) => ze + I, 0)]).sort((ye, ze) => ye[1] - ze[1])[0]) == null ? void 0 : ue[0];
              ge && (Se = ge);
              break;
            }
            case "initialPlacement":
              Se = l;
              break;
          }
        if (i !== Se)
          return {
            reset: {
              placement: Se
            }
          };
      }
      return {};
    }
  };
}, AG = /* @__PURE__ */ new Set(["left", "top"]);
async function OG(n, e) {
  const {
    placement: t,
    platform: r,
    elements: i
  } = n, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = Oa(t), l = A1(t), a = Qo(t) === "y", c = AG.has(o) ? -1 : 1, u = s && a ? -1 : 1, h = T1(e, n);
  let {
    mainAxis: f,
    crossAxis: d,
    alignmentAxis: p
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return l && typeof p == "number" && (d = l === "end" ? p * -1 : p), a ? {
    x: d * u,
    y: f * c
  } : {
    x: f * c,
    y: d * u
  };
}
const EG = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      var t, r;
      const {
        x: i,
        y: s,
        placement: o,
        middlewareData: l
      } = e, a = await OG(e, n);
      return o === ((t = l.offset) == null ? void 0 : t.placement) && (r = l.arrow) != null && r.alignmentOffset ? {} : {
        x: i + a.x,
        y: s + a.y,
        data: {
          ...a,
          placement: o
        }
      };
    }
  };
}, IG = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r,
        placement: i
      } = e, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: l = {
          fn: (g) => {
            let {
              x: b,
              y: w
            } = g;
            return {
              x: b,
              y: w
            };
          }
        },
        ...a
      } = T1(n, e), c = {
        x: t,
        y: r
      }, u = await oO(e, a), h = Qo(Oa(i)), f = rO(h);
      let d = c[f], p = c[h];
      if (s) {
        const g = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", w = d + u[g], k = d - u[b];
        d = u8(w, d, k);
      }
      if (o) {
        const g = h === "y" ? "top" : "left", b = h === "y" ? "bottom" : "right", w = p + u[g], k = p - u[b];
        p = u8(w, p, k);
      }
      const m = l.fn({
        ...e,
        [f]: d,
        [h]: p
      });
      return {
        ...m,
        data: {
          x: m.x - t,
          y: m.y - r,
          enabled: {
            [f]: s,
            [h]: o
          }
        }
      };
    }
  };
};
function O1() {
  return typeof window < "u";
}
function iu(n) {
  return lO(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Xr(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function ko(n) {
  var e;
  return (e = (lO(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function lO(n) {
  return O1() ? n instanceof Node || n instanceof Xr(n).Node : !1;
}
function Fi(n) {
  return O1() ? n instanceof Element || n instanceof Xr(n).Element : !1;
}
function Ss(n) {
  return O1() ? n instanceof HTMLElement || n instanceof Xr(n).HTMLElement : !1;
}
function p8(n) {
  return !O1() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Xr(n).ShadowRoot;
}
const DG = /* @__PURE__ */ new Set(["inline", "contents"]);
function vd(n) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: r,
    display: i
  } = Hi(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !DG.has(i);
}
const NG = /* @__PURE__ */ new Set(["table", "td", "th"]);
function RG(n) {
  return NG.has(iu(n));
}
const PG = [":popover-open", ":modal"];
function E1(n) {
  return PG.some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
const _G = ["transform", "translate", "scale", "rotate", "perspective"], LG = ["transform", "translate", "scale", "rotate", "perspective", "filter"], BG = ["paint", "layout", "strict", "content"];
function ob(n) {
  const e = lb(), t = Fi(n) ? Hi(n) : n;
  return _G.some((r) => t[r] ? t[r] !== "none" : !1) || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || LG.some((r) => (t.willChange || "").includes(r)) || BG.some((r) => (t.contain || "").includes(r));
}
function zG(n) {
  let e = pl(n);
  for (; Ss(e) && !Vc(e); ) {
    if (ob(e))
      return e;
    if (E1(e))
      return null;
    e = pl(e);
  }
  return null;
}
function lb() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const FG = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Vc(n) {
  return FG.has(iu(n));
}
function Hi(n) {
  return Xr(n).getComputedStyle(n);
}
function I1(n) {
  return Fi(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function pl(n) {
  if (iu(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    p8(n) && n.host || // Fallback.
    ko(n)
  );
  return p8(e) ? e.host : e;
}
function aO(n) {
  const e = pl(n);
  return Vc(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : Ss(e) && vd(e) ? e : aO(e);
}
function cO(n, e, t) {
  var r;
  e === void 0 && (e = []);
  const i = aO(n), s = i === ((r = n.ownerDocument) == null ? void 0 : r.body), o = Xr(i);
  return s ? (n5(o), e.concat(o, o.visualViewport || [], vd(i) ? i : [], [])) : e.concat(i, cO(i, []));
}
function n5(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function uO(n) {
  const e = Hi(n);
  let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = Ss(n), s = i ? n.offsetWidth : t, o = i ? n.offsetHeight : r, l = km(t) !== s || km(r) !== o;
  return l && (t = s, r = o), {
    width: t,
    height: r,
    $: l
  };
}
function hO(n) {
  return Fi(n) ? n : n.contextElement;
}
function Sc(n) {
  const e = hO(n);
  if (!Ss(e))
    return vs(1);
  const t = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = uO(e);
  let o = (s ? km(t.width) : t.width) / r, l = (s ? km(t.height) : t.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: o,
    y: l
  };
}
const HG = /* @__PURE__ */ vs(0);
function fO(n) {
  const e = Xr(n);
  return !lb() || !e.visualViewport ? HG : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function $G(n, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== Xr(n) ? !1 : e;
}
function Wf(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const i = n.getBoundingClientRect(), s = hO(n);
  let o = vs(1);
  e && (r ? Fi(r) && (o = Sc(r)) : o = Sc(n));
  const l = $G(s, t, r) ? fO(s) : vs(0);
  let a = (i.left + l.x) / o.x, c = (i.top + l.y) / o.y, u = i.width / o.x, h = i.height / o.y;
  if (s) {
    const f = Xr(s), d = r && Fi(r) ? Xr(r) : r;
    let p = f, m = n5(p);
    for (; m && r && d !== p; ) {
      const g = Sc(m), b = m.getBoundingClientRect(), w = Hi(m), k = b.left + (m.clientLeft + parseFloat(w.paddingLeft)) * g.x, C = b.top + (m.clientTop + parseFloat(w.paddingTop)) * g.y;
      a *= g.x, c *= g.y, u *= g.x, h *= g.y, a += k, c += C, p = Xr(m), m = n5(p);
    }
  }
  return Cm({
    width: u,
    height: h,
    x: a,
    y: c
  });
}
function D1(n, e) {
  const t = I1(n).scrollLeft;
  return e ? e.left + t : Wf(ko(n)).left + t;
}
function dO(n, e) {
  const t = n.getBoundingClientRect(), r = t.left + e.scrollLeft - D1(n, t), i = t.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function VG(n) {
  let {
    elements: e,
    rect: t,
    offsetParent: r,
    strategy: i
  } = n;
  const s = i === "fixed", o = ko(r), l = e ? E1(e.floating) : !1;
  if (r === o || l && s)
    return t;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = vs(1);
  const u = vs(0), h = Ss(r);
  if ((h || !h && !s) && ((iu(r) !== "body" || vd(o)) && (a = I1(r)), Ss(r))) {
    const d = Wf(r);
    c = Sc(r), u.x = d.x + r.clientLeft, u.y = d.y + r.clientTop;
  }
  const f = o && !h && !s ? dO(o, a) : vs(0);
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - a.scrollLeft * c.x + u.x + f.x,
    y: t.y * c.y - a.scrollTop * c.y + u.y + f.y
  };
}
function qG(n) {
  return Array.from(n.getClientRects());
}
function WG(n) {
  const e = ko(n), t = I1(n), r = n.ownerDocument.body, i = kc(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = kc(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -t.scrollLeft + D1(n);
  const l = -t.scrollTop;
  return Hi(r).direction === "rtl" && (o += kc(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: o,
    y: l
  };
}
const m8 = 25;
function jG(n, e) {
  const t = Xr(n), r = ko(n), i = t.visualViewport;
  let s = r.clientWidth, o = r.clientHeight, l = 0, a = 0;
  if (i) {
    s = i.width, o = i.height;
    const u = lb();
    (!u || u && e === "fixed") && (l = i.offsetLeft, a = i.offsetTop);
  }
  const c = D1(r);
  if (c <= 0) {
    const u = r.ownerDocument, h = u.body, f = getComputedStyle(h), d = u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, p = Math.abs(r.clientWidth - h.clientWidth - d);
    p <= m8 && (s -= p);
  } else c <= m8 && (s += c);
  return {
    width: s,
    height: o,
    x: l,
    y: a
  };
}
const UG = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function KG(n, e) {
  const t = Wf(n, !0, e === "fixed"), r = t.top + n.clientTop, i = t.left + n.clientLeft, s = Ss(n) ? Sc(n) : vs(1), o = n.clientWidth * s.x, l = n.clientHeight * s.y, a = i * s.x, c = r * s.y;
  return {
    width: o,
    height: l,
    x: a,
    y: c
  };
}
function g8(n, e, t) {
  let r;
  if (e === "viewport")
    r = jG(n, t);
  else if (e === "document")
    r = WG(ko(n));
  else if (Fi(e))
    r = KG(e, t);
  else {
    const i = fO(n);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return Cm(r);
}
function pO(n, e) {
  const t = pl(n);
  return t === e || !Fi(t) || Vc(t) ? !1 : Hi(t).position === "fixed" || pO(t, e);
}
function GG(n, e) {
  const t = e.get(n);
  if (t)
    return t;
  let r = cO(n, []).filter((l) => Fi(l) && iu(l) !== "body"), i = null;
  const s = Hi(n).position === "fixed";
  let o = s ? pl(n) : n;
  for (; Fi(o) && !Vc(o); ) {
    const l = Hi(o), a = ob(o);
    !a && l.position === "fixed" && (i = null), (s ? !a && !i : !a && l.position === "static" && !!i && UG.has(i.position) || vd(o) && !a && pO(n, o)) ? r = r.filter((u) => u !== o) : i = l, o = pl(o);
  }
  return e.set(n, r), r;
}
function YG(n) {
  let {
    element: e,
    boundary: t,
    rootBoundary: r,
    strategy: i
  } = n;
  const o = [...t === "clippingAncestors" ? E1(e) ? [] : GG(e, this._c) : [].concat(t), r], l = o[0], a = o.reduce((c, u) => {
    const h = g8(e, u, i);
    return c.top = kc(h.top, c.top), c.right = e5(h.right, c.right), c.bottom = e5(h.bottom, c.bottom), c.left = kc(h.left, c.left), c;
  }, g8(e, l, i));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function JG(n) {
  const {
    width: e,
    height: t
  } = uO(n);
  return {
    width: e,
    height: t
  };
}
function XG(n, e, t) {
  const r = Ss(e), i = ko(e), s = t === "fixed", o = Wf(n, !0, s, e);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = vs(0);
  function c() {
    a.x = D1(i);
  }
  if (r || !r && !s)
    if ((iu(e) !== "body" || vd(i)) && (l = I1(e)), r) {
      const d = Wf(e, !0, s, e);
      a.x = d.x + e.clientLeft, a.y = d.y + e.clientTop;
    } else i && c();
  s && !r && i && c();
  const u = i && !r && !s ? dO(i, l) : vs(0), h = o.left + l.scrollLeft - a.x - u.x, f = o.top + l.scrollTop - a.y - u.y;
  return {
    x: h,
    y: f,
    width: o.width,
    height: o.height
  };
}
function O2(n) {
  return Hi(n).position === "static";
}
function y8(n, e) {
  if (!Ss(n) || Hi(n).position === "fixed")
    return null;
  if (e)
    return e(n);
  let t = n.offsetParent;
  return ko(n) === t && (t = t.ownerDocument.body), t;
}
function mO(n, e) {
  const t = Xr(n);
  if (E1(n))
    return t;
  if (!Ss(n)) {
    let i = pl(n);
    for (; i && !Vc(i); ) {
      if (Fi(i) && !O2(i))
        return i;
      i = pl(i);
    }
    return t;
  }
  let r = y8(n, e);
  for (; r && RG(r) && O2(r); )
    r = y8(r, e);
  return r && Vc(r) && O2(r) && !ob(r) ? t : r || zG(n) || t;
}
const ZG = async function(n) {
  const e = this.getOffsetParent || mO, t = this.getDimensions, r = await t(n.floating);
  return {
    reference: XG(n.reference, await e(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function QG(n) {
  return Hi(n).direction === "rtl";
}
const eY = {
  convertOffsetParentRelativeRectToViewportRelativeRect: VG,
  getDocumentElement: ko,
  getClippingRect: YG,
  getOffsetParent: mO,
  getElementRects: ZG,
  getClientRects: qG,
  getDimensions: JG,
  getScale: Sc,
  isElement: Fi,
  isRTL: QG
}, ml = EG, b8 = IG, Mm = TG, $i = (n, e, t) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: eY,
    ...t
  }, s = {
    ...i.platform,
    _c: r
  };
  return MG(n, e, {
    ...i,
    platform: s
  });
};
function wd(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-block",
      ...e
    }
  }), n;
}
const tY = (n) => !ys((t) => t.type.name === "table")(n), N1 = St(
  { filterNodes: tY },
  "blockConfig"
);
wd(N1, {
  displayName: "Ctx<blockConfig>"
});
function nY(n, e, t) {
  if (!n.dom.parentElement) return null;
  try {
    const i = n.posAtCoords({
      left: e.x,
      top: e.y
    })?.inside;
    if (i == null || i < 0) return null;
    let s = n.state.doc.resolve(i), o = n.state.doc.nodeAt(i), l = n.nodeDOM(i);
    const a = (u) => {
      const h = s.depth >= 1 && s.index(s.depth) === 0;
      if (!(u || h)) return;
      const d = s.before(s.depth);
      o = n.state.doc.nodeAt(d), l = n.nodeDOM(d), s = n.state.doc.resolve(d), t(s, o) || a(!0);
    }, c = t(s, o);
    return a(!c), !l || !o ? null : { node: o, $pos: s, el: l };
  } catch {
    return null;
  }
}
const v8 = d0.ie && d0.ie_version < 15 || d0.ios && d0.webkit_version < 604, w8 = 20;
class rY {
  constructor() {
    this.#e = () => {
      if (!this.#n) return null;
      const e = this.#n, t = this.#o;
      if (t && $e.isSelectable(e.node)) {
        const r = $e.create(
          t.state.doc,
          e.$pos.pos
        );
        return t.dispatch(t.state.tr.setSelection(r)), t.focus(), this.#r = r, r;
      }
      return null;
    }, this.#r = null, this.#n = null, this.#a = void 0, this.#i = !1, this.#c = () => {
      this.#l?.({ type: "hide" }), this.#n = null;
    }, this.#u = (e) => {
      this.#n = e, this.#l?.({ type: "show", active: e });
    }, this.bind = (e, t) => {
      this.#t = e, this.#l = t;
    }, this.addEvent = (e) => {
      e.addEventListener("mousedown", this.#h), e.addEventListener("mouseup", this.#d), e.addEventListener("dragstart", this.#f);
    }, this.removeEvent = (e) => {
      e.removeEventListener("mousedown", this.#h), e.removeEventListener("mouseup", this.#d), e.removeEventListener("dragstart", this.#f);
    }, this.unBind = () => {
      this.#l = void 0;
    }, this.#h = () => {
      this.#a = this.#n?.el.getBoundingClientRect(), this.#e();
    }, this.#d = () => {
      if (!this.#i) {
        requestAnimationFrame(() => {
          this.#a && this.#o?.focus();
        });
        return;
      }
      this.#i = !1, this.#r = null;
    }, this.#f = (e) => {
      this.#i = !0;
      const t = this.#o;
      if (!t) return;
      t.dom.dataset.dragging = "true";
      const r = this.#r;
      if (e.dataTransfer && r) {
        const i = r.content();
        e.dataTransfer.effectAllowed = "copyMove";
        const { dom: s, text: o } = t.serializeForClipboard(i);
        e.dataTransfer.clearData(), e.dataTransfer.setData(
          v8 ? "Text" : "text/html",
          s.innerHTML
        ), v8 || e.dataTransfer.setData("text/plain", o);
        const l = this.#n?.el;
        l && e.dataTransfer.setDragImage(l, 0, 0), t.dragging = {
          slice: i,
          move: !0
        };
      }
    }, this.keydownCallback = (e) => (this.#c(), this.#i = !1, e.dom.dataset.dragging = "false", !1), this.#p = e1((e, t) => {
      if (!e.editable) return;
      const r = e.dom.getBoundingClientRect(), i = r.left + r.width / 2;
      if (!(e.root.elementFromPoint(i, t.clientY) instanceof Element)) {
        this.#c();
        return;
      }
      const o = this.#s;
      if (!o) return;
      const l = nY(
        e,
        { x: i, y: t.clientY },
        o
      );
      if (!l) {
        this.#c();
        return;
      }
      this.#u(l);
    }, 200), this.mousemoveCallback = (e, t) => (e.composing || !e.editable || this.#p(e, t), !1), this.dragoverCallback = (e, t) => {
      if (this.#i) {
        const r = this.#o?.dom.parentElement;
        if (!r) return !1;
        const i = r.scrollHeight > r.clientHeight, s = r.getBoundingClientRect();
        if (i) {
          if (r.scrollTop > 0 && Math.abs(t.y - s.y) < w8) {
            const a = r.scrollTop > 10 ? r.scrollTop - 10 : 0;
            return r.scrollTop = a, !1;
          }
          const o = Math.round(e.dom.getBoundingClientRect().height);
          if (Math.round(r.scrollTop + s.height) < o && Math.abs(t.y - (s.height + s.y)) < w8) {
            const a = r.scrollTop + 10;
            return r.scrollTop = a, !1;
          }
        }
      }
      return !1;
    }, this.dragenterCallback = (e) => {
      e.dragging && (this.#i = !0, e.dom.dataset.dragging = "true");
    }, this.dragleaveCallback = (e, t) => {
      const r = t.clientX, i = t.clientY;
      (r < 0 || i < 0 || r > window.innerWidth || i > window.innerHeight) && (this.#n = null, this.#m(e));
    }, this.dropCallback = (e) => (this.#m(e), !1), this.dragendCallback = (e) => {
      this.#m(e);
    }, this.#m = (e) => {
      this.#i = !1, e.dom.dataset.dragging = "false";
    };
  }
  /// @internal
  #t;
  #e;
  #r;
  #n;
  #a;
  #i;
  /// @internal
  get #s() {
    try {
      return this.#t?.get(N1.key).filterNodes;
    } catch {
      return;
    }
  }
  /// @internal
  get #o() {
    return this.#t?.get(Lt);
  }
  /// @internal
  #l;
  #c;
  #u;
  #h;
  #d;
  #f;
  #p;
  #m;
}
const ab = St(() => new rY(), "blockService"), R1 = St(
  {},
  "blockServiceInstance"
);
wd(ab, {
  displayName: "Ctx<blockService>"
});
wd(R1, {
  displayName: "Ctx<blockServiceInstance>"
});
const P1 = St({}, "blockSpec");
wd(P1, {
  displayName: "Ctx<blockSpec>"
});
const cb = kn((n) => {
  const e = new en("MILKDOWN_BLOCK"), r = n.get(ab.key)();
  n.set(R1.key, r);
  const i = n.get(P1.key);
  return new Ut({
    key: e,
    ...i,
    props: {
      ...i.props,
      handleDOMEvents: {
        drop: (s) => r.dropCallback(s),
        pointermove: (s, o) => r.mousemoveCallback(s, o),
        keydown: (s) => r.keydownCallback(s),
        dragover: (s, o) => r.dragoverCallback(s, o),
        dragleave: (s, o) => r.dragleaveCallback(s, o),
        dragenter: (s) => r.dragenterCallback(s),
        dragend: (s) => r.dragendCallback(s)
      }
    }
  });
});
wd(cb, {
  displayName: "Prose<block>"
});
class iY {
  constructor(e) {
    this.#n = null, this.#i = !1, this.update = () => {
      requestAnimationFrame(() => {
        if (!this.#i)
          try {
            this.#h(), this.#i = !0;
          } catch {
          }
      });
    }, this.destroy = () => {
      this.#r?.unBind(), this.#r?.removeEvent(this.#t), this.#t.remove();
    }, this.show = (t) => {
      const r = t.el, i = this.#e.get(Lt).dom, s = {
        ctx: this.#e,
        active: t,
        editorDom: i,
        blockDom: this.#t
      }, o = {
        contextElement: r,
        getBoundingClientRect: () => this.#c ? this.#c(s) : r.getBoundingClientRect()
      }, l = [Mm()];
      if (this.#l) {
        const a = this.#l(s), c = ml(a);
        l.push(c);
      }
      $i(o, this.#t, {
        placement: this.#u ? this.#u(s) : "left",
        middleware: [...l, ...this.#s],
        ...this.#o
      }).then(({ x: a, y: c }) => {
        Object.assign(this.#t.style, {
          left: `${a}px`,
          top: `${c}px`
        }), this.#t.dataset.show = "true";
      }).catch(console.error);
    }, this.hide = () => {
      this.#t.dataset.show = "false";
    }, this.#e = e.ctx, this.#t = e.content, this.#l = e.getOffset, this.#c = e.getPosition, this.#u = e.getPlacement, this.#s = e.middleware ?? [], this.#o = e.floatingUIOptions ?? {}, this.#a = e.root, this.hide();
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  #n;
  /// @internal
  #a;
  #i;
  /// @internal
  #s;
  /// @internal
  #o;
  /// @internal
  #l;
  /// @internal
  #c;
  /// @internal
  #u;
  /// The context of current active node.
  get active() {
    return this.#n;
  }
  /// @internal
  #h() {
    const e = this.#e.get(Lt);
    (this.#a ?? e.dom.parentElement ?? document.body).appendChild(this.#t);
    const r = this.#e.get(R1.key);
    r.bind(this.#e, (i) => {
      i.type === "hide" ? (this.hide(), this.#n = null) : i.type === "show" && (this.show(i.active), this.#n = i.active);
    }), this.#r = r, this.#r.addEvent(this.#t), this.#t.draggable = !0;
  }
}
const _1 = [
  P1,
  N1,
  ab,
  R1,
  cb
];
_1.key = P1.key;
_1.pluginKey = cb.key;
function sY(n, e) {
  return function(t, r) {
    let { $from: i, $to: s, node: o } = t.selection;
    if (o && o.isBlock || i.depth < 2 || !i.sameParent(s))
      return !1;
    let l = i.node(-1);
    if (l.type != n)
      return !1;
    if (i.parent.content.size == 0 && i.node(-1).childCount == i.indexAfter(-1)) {
      if (i.depth == 3 || i.node(-3).type != n || i.index(-2) != i.node(-2).childCount - 1)
        return !1;
      if (r) {
        let h = ce.empty, f = i.index(-1) ? 1 : i.index(-2) ? 2 : 3;
        for (let b = i.depth - f; b >= i.depth - 3; b--)
          h = ce.from(i.node(b).copy(h));
        let d = i.indexAfter(-1) < i.node(-2).childCount ? 1 : i.indexAfter(-2) < i.node(-3).childCount ? 2 : 3;
        h = h.append(ce.from(n.createAndFill()));
        let p = i.before(i.depth - (f - 1)), m = t.tr.replace(p, i.after(-d), new ve(h, 4 - f, 0)), g = -1;
        m.doc.nodesBetween(p, m.doc.content.size, (b, w) => {
          if (g > -1)
            return !1;
          b.isTextblock && b.content.size == 0 && (g = w + 1);
        }), g > -1 && m.setSelection(Ge.near(m.doc.resolve(g))), r(m.scrollIntoView());
      }
      return !0;
    }
    let a = s.pos == i.end() ? l.contentMatchAt(0).defaultType : null, c = t.tr.delete(i.pos, s.pos), u = a ? [null, { type: a }] : void 0;
    return qh(c.doc, i.pos, 2, u) ? (r && r(c.split(i.pos, 2, u).scrollIntoView()), !0) : !1;
  };
}
function oY(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == n);
    return s ? t ? r.node(s.depth - 1).type == n ? lY(e, t, n, s) : aY(e, t, s) : !0 : !1;
  };
}
function lY(n, e, t, r) {
  let i = n.tr, s = r.end, o = r.$to.end(r.depth);
  s < o && (i.step(new Yn(s - 1, o, s, o, new ve(ce.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new HM(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
  const l = u1(r);
  if (l == null)
    return !1;
  i.lift(r, l);
  let a = i.doc.resolve(i.mapping.map(s, -1) - 1);
  return h1(i.doc, a.pos) && a.nodeBefore.type == a.nodeAfter.type && i.join(a.pos), e(i.scrollIntoView()), !0;
}
function aY(n, e, t) {
  let r = n.tr, i = t.parent;
  for (let d = t.end, p = t.endIndex - 1, m = t.startIndex; p > m; p--)
    d -= i.child(p).nodeSize, r.delete(d - 1, d + 1);
  let s = r.doc.resolve(t.start), o = s.nodeAfter;
  if (r.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize)
    return !1;
  let l = t.startIndex == 0, a = t.endIndex == i.childCount, c = s.node(-1), u = s.index(-1);
  if (!c.canReplace(u + (l ? 0 : 1), u + 1, o.content.append(a ? ce.empty : ce.from(i))))
    return !1;
  let h = s.pos, f = h + o.nodeSize;
  return r.step(new Yn(h - (l ? 1 : 0), f + (a ? 1 : 0), h + 1, f - 1, new ve((l ? ce.empty : ce.from(i.copy(ce.empty))).append(a ? ce.empty : ce.from(i.copy(ce.empty))), l ? 0 : 1, a ? 0 : 1), l ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function cY(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (c) => c.childCount > 0 && c.firstChild.type == n);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let l = s.parent, a = l.child(o - 1);
    if (a.type != n)
      return !1;
    if (t) {
      let c = a.lastChild && a.lastChild.type == l.type, u = ce.from(c ? n.create() : null), h = new ve(ce.from(n.create(null, ce.from(l.type.create(null, u)))), c ? 3 : 1, 0), f = s.start, d = s.end;
      t(e.tr.step(new Yn(f - (c ? 3 : 1), d, f, d, h, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function uY(n) {
  const e = /* @__PURE__ */ new Map();
  if (!n || !n.type)
    throw new Error("mdast-util-definitions expected node");
  return Sl(n, "definition", function(r) {
    const i = x8(r.identifier);
    i && !e.get(i) && e.set(i, r);
  }), t;
  function t(r) {
    const i = x8(r);
    return e.get(i);
  }
}
function x8(n) {
  return String(n || "").toUpperCase();
}
function hY() {
  return function(n) {
    const e = uY(n);
    Sl(n, function(t, r, i) {
      if (t.type === "definition" && i !== void 0 && typeof r == "number")
        return i.children.splice(r, 1), [Ry, r];
      if (t.type === "imageReference" || t.type === "linkReference") {
        const s = e(t.identifier);
        if (s && i && typeof r == "number")
          return i.children[r] = t.type === "imageReference" ? { type: "image", url: s.url, title: s.title, alt: t.alt } : {
            type: "link",
            url: s.url,
            title: s.title,
            children: t.children
          }, [Ry, r];
      }
    });
  };
}
function gO(n, e) {
  if (!(e.childCount >= 1 && e.lastChild?.type.name === "hardbreak")) {
    n.next(e.content);
    return;
  }
  const r = [];
  e.content.forEach((i, s, o) => {
    o !== e.childCount - 1 && r.push(i);
  }), n.next(ce.fromArray(r));
}
function K(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/preset-commonmark",
      ...e
    }
  }), n;
}
const ub = bd("emphasis");
K(ub, {
  displayName: "Attr<emphasis>",
  group: "Emphasis"
});
const _a = ru("emphasis", (n) => ({
  attrs: {
    marker: {
      default: n.get(Gh).emphasis || "*",
      validate: "string"
    }
  },
  parseDOM: [
    { tag: "i" },
    { tag: "em" },
    { style: "font-style", getAttrs: (e) => e === "italic" }
  ],
  toDOM: (e) => ["em", n.get(ub.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "emphasis",
    runner: (e, t, r) => {
      e.openMark(r, { marker: t.marker }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "emphasis",
    runner: (e, t) => {
      e.withMark(t, "emphasis", void 0, {
        marker: t.attrs.marker
      });
    }
  }
}));
K(_a.mark, {
  displayName: "MarkSchema<emphasis>",
  group: "Emphasis"
});
K(_a.ctx, {
  displayName: "MarkSchemaCtx<emphasis>",
  group: "Emphasis"
});
const L1 = Ye("ToggleEmphasis", (n) => () => k1(_a.type(n)));
K(L1, {
  displayName: "Command<toggleEmphasisCommand>",
  group: "Emphasis"
});
const yO = Qn((n) => hd(/(?:^|[^*])\*([^*]+)\*$/, _a.type(n), {
  getAttr: () => ({
    marker: "*"
  }),
  updateCaptured: ({ fullMatch: e, start: t }) => e.startsWith("*") ? {} : { fullMatch: e.slice(1), start: t + 1 }
}));
K(yO, {
  displayName: "InputRule<emphasis>|Star",
  group: "Emphasis"
});
const bO = Qn((n) => hd(/\b_(?![_\s])(.*?[^_\s])_\b/, _a.type(n), {
  getAttr: () => ({
    marker: "_"
  }),
  updateCaptured: ({ fullMatch: e, start: t }) => e.startsWith("_") ? {} : { fullMatch: e.slice(1), start: t + 1 }
}));
K(bO, {
  displayName: "InputRule<emphasis>|Underscore",
  group: "Emphasis"
});
const hb = Rr("emphasisKeymap", {
  ToggleEmphasis: {
    shortcuts: "Mod-i",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(L1.key);
    }
  }
});
K(hb.ctx, {
  displayName: "KeymapCtx<emphasis>",
  group: "Emphasis"
});
K(hb.shortcuts, {
  displayName: "Keymap<emphasis>",
  group: "Emphasis"
});
const fb = bd("strong");
K(fb, {
  displayName: "Attr<strong>",
  group: "Strong"
});
const su = ru("strong", (n) => ({
  attrs: {
    marker: {
      default: n.get(Gh).strong || "*",
      validate: "string"
    }
  },
  parseDOM: [
    // This works around a Google Docs misbehavior where
    // pasted content will be inexplicably wrapped in `<b>`
    // tags with a font-weight normal.
    {
      tag: "b",
      getAttrs: (e) => e.style.fontWeight != "normal" && null
    },
    { tag: "strong" },
    { style: "font-style", getAttrs: (e) => e === "bold" },
    { style: "font-weight=400", clearMark: (e) => e.type.name == "strong" },
    {
      style: "font-weight",
      getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
    }
  ],
  toDOM: (e) => ["strong", n.get(fb.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "strong",
    runner: (e, t, r) => {
      e.openMark(r, { marker: t.marker }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strong",
    runner: (e, t) => {
      e.withMark(t, "strong", void 0, {
        marker: t.attrs.marker
      });
    }
  }
}));
K(su.mark, {
  displayName: "MarkSchema<strong>",
  group: "Strong"
});
K(su.ctx, {
  displayName: "MarkSchemaCtx<strong>",
  group: "Strong"
});
const B1 = Ye("ToggleStrong", (n) => () => k1(su.type(n)));
K(B1, {
  displayName: "Command<toggleStrongCommand>",
  group: "Strong"
});
const vO = Qn((n) => hd(
  new RegExp("(?<![\\w:/])(?:\\*\\*|__)([^*_]+?)(?:\\*\\*|__)(?![\\w/])$"),
  su.type(n),
  {
    getAttr: (e) => ({
      marker: e[0].startsWith("*") ? "*" : "_"
    })
  }
));
K(vO, {
  displayName: "InputRule<strong>",
  group: "Strong"
});
const db = Rr("strongKeymap", {
  ToggleBold: {
    shortcuts: ["Mod-b"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(B1.key);
    }
  }
});
K(db.ctx, {
  displayName: "KeymapCtx<strong>",
  group: "Strong"
});
K(db.shortcuts, {
  displayName: "Keymap<strong>",
  group: "Strong"
});
const pb = bd("inlineCode");
K(pb, {
  displayName: "Attr<inlineCode>",
  group: "InlineCode"
});
const eo = ru("inlineCode", (n) => ({
  priority: 100,
  code: !0,
  parseDOM: [{ tag: "code" }],
  toDOM: (e) => ["code", n.get(pb.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "inlineCode",
    runner: (e, t, r) => {
      e.openMark(r), e.addText(t.value), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "inlineCode",
    runner: (e, t, r) => {
      e.withMark(t, "inlineCode", r.text || "");
    }
  }
}));
K(eo.mark, {
  displayName: "MarkSchema<inlineCode>",
  group: "InlineCode"
});
K(eo.ctx, {
  displayName: "MarkSchemaCtx<inlineCode>",
  group: "InlineCode"
});
const z1 = Ye(
  "ToggleInlineCode",
  (n) => () => (e, t) => {
    const { selection: r, tr: i } = e;
    if (r.empty) return !1;
    const { from: s, to: o } = r;
    return e.doc.rangeHasMark(s, o, eo.type(n)) ? (t?.(i.removeMark(s, o, eo.type(n))), !0) : (Object.keys(e.schema.marks).filter(
      (c) => c !== eo.type.name
    ).map((c) => e.schema.marks[c]).forEach((c) => {
      i.removeMark(s, o, c);
    }), t?.(i.addMark(s, o, eo.type(n).create())), !0);
  }
);
K(z1, {
  displayName: "Command<toggleInlineCodeCommand>",
  group: "InlineCode"
});
const wO = Qn((n) => hd(/(?:`)([^`]+)(?:`)$/, eo.type(n)));
K(wO, {
  displayName: "InputRule<inlineCodeInputRule>",
  group: "InlineCode"
});
const mb = Rr("inlineCodeKeymap", {
  ToggleInlineCode: {
    shortcuts: "Mod-e",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(z1.key);
    }
  }
});
K(mb.ctx, {
  displayName: "KeymapCtx<inlineCode>",
  group: "InlineCode"
});
K(mb.shortcuts, {
  displayName: "Keymap<inlineCode>",
  group: "InlineCode"
});
const gb = bd("link");
K(gb, {
  displayName: "Attr<link>",
  group: "Link"
});
const Ri = ru("link", (n) => ({
  attrs: {
    href: { validate: "string" },
    title: { default: null, validate: "string|null" }
  },
  parseDOM: [
    {
      tag: "a[href]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return {
          href: e.getAttribute("href"),
          title: e.getAttribute("title")
        };
      }
    }
  ],
  toDOM: (e) => ["a", { ...n.get(gb.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: (e) => e.type === "link",
    runner: (e, t, r) => {
      const i = t.url, s = t.title;
      e.openMark(r, { href: i, title: s }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "link",
    runner: (e, t) => {
      e.withMark(t, "link", void 0, {
        title: t.attrs.title,
        url: t.attrs.href
      });
    }
  }
}));
K(Ri.mark, {
  displayName: "MarkSchema<link>",
  group: "Link"
});
const xO = Ye(
  "ToggleLink",
  (n) => (e = {}) => k1(Ri.type(n), e)
);
K(xO, {
  displayName: "Command<toggleLinkCommand>",
  group: "Link"
});
const kO = Ye(
  "UpdateLink",
  (n) => (e = {}) => (t, r) => {
    if (!r) return !1;
    let i, s = -1;
    const { selection: o } = t, { from: l, to: a } = o;
    if (t.doc.nodesBetween(l, l === a ? a + 1 : a, (p, m) => {
      if (Ri.type(n).isInSet(p.marks))
        return i = p, s = m, !1;
    }), !i) return !1;
    const c = i.marks.find(({ type: p }) => p === Ri.type(n));
    if (!c) return !1;
    const u = s, h = s + i.nodeSize, { tr: f } = t, d = Ri.type(n).create({ ...c.attrs, ...e });
    return d ? (r(
      f.removeMark(u, h, c).addMark(u, h, d).setSelection(new Ee(f.selection.$anchor)).scrollIntoView()
    ), !0) : !1;
  }
);
K(kO, {
  displayName: "Command<updateLinkCommand>",
  group: "Link"
});
const SO = sb("doc", () => ({
  content: "block+",
  parseMarkdown: {
    match: ({ type: n }) => n === "root",
    runner: (n, e, t) => {
      n.injectRoot(e, t);
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "doc",
    runner: (n, e) => {
      n.openNode("root"), n.next(e.content);
    }
  }
}));
K(SO, {
  displayName: "NodeSchema<doc>",
  group: "Doc"
});
function fY(n) {
  return z3(
    n,
    (e) => e.type === "html" && ["<br />", "<br>", "<br >", "<br/>"].includes(
      e.value?.trim()
    ),
    (e, t) => {
      if (!t.length) return;
      const r = t[t.length - 1];
      if (!r) return;
      const i = r.children.indexOf(e);
      i !== -1 && r.children.splice(i, 1);
    },
    !0
  );
}
const F1 = As(
  "remark-preserve-empty-line",
  () => () => fY
);
K(F1.plugin, {
  displayName: "Remark<remarkPreserveEmptyLine>",
  group: "Remark"
});
K(F1.options, {
  displayName: "RemarkConfig<remarkPreserveEmptyLine>",
  group: "Remark"
});
const yb = qi("paragraph");
K(yb, {
  displayName: "Attr<paragraph>",
  group: "Paragraph"
});
const Os = hn("paragraph", (n) => ({
  content: "inline*",
  group: "block",
  parseDOM: [{ tag: "p" }],
  toDOM: (e) => ["p", n.get(yb.key)(e), 0],
  parseMarkdown: {
    match: (e) => e.type === "paragraph",
    runner: (e, t, r) => {
      e.openNode(r), t.children ? e.next(t.children) : e.addText(t.value || ""), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "paragraph",
    runner: (e, t) => {
      const i = n.get(Lt).state?.doc.lastChild;
      e.openNode("paragraph"), (!t.content || t.content.size === 0) && t !== i && dY(n) ? e.addNode("html", void 0, "<br />") : gO(e, t), e.closeNode();
    }
  }
}));
function dY(n) {
  let e = !1;
  try {
    n.get(F1.id), e = !0;
  } catch {
    e = !1;
  }
  return e;
}
K(Os.node, {
  displayName: "NodeSchema<paragraph>",
  group: "Paragraph"
});
K(Os.ctx, {
  displayName: "NodeSchemaCtx<paragraph>",
  group: "Paragraph"
});
const bb = Ye(
  "TurnIntoText",
  (n) => () => Lf(Os.type(n))
);
K(bb, {
  displayName: "Command<turnIntoTextCommand>",
  group: "Paragraph"
});
const vb = Rr("paragraphKeymap", {
  TurnIntoText: {
    shortcuts: "Mod-Alt-0",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(bb.key);
    }
  }
});
K(vb.ctx, {
  displayName: "KeymapCtx<paragraph>",
  group: "Paragraph"
});
K(vb.shortcuts, {
  displayName: "Keymap<paragraph>",
  group: "Paragraph"
});
const pY = Array(6).fill(0).map((n, e) => e + 1);
function mY(n) {
  return n.textContent.toLowerCase().trim().replace(/\s+/g, "-");
}
const H1 = St(
  mY,
  "headingIdGenerator"
);
K(H1, {
  displayName: "Ctx<HeadingIdGenerator>",
  group: "Heading"
});
const wb = qi("heading");
K(wb, {
  displayName: "Attr<heading>",
  group: "Heading"
});
const jr = hn("heading", (n) => {
  const e = n.get(H1.key);
  return {
    content: "inline*",
    group: "block",
    defining: !0,
    attrs: {
      id: {
        default: "",
        validate: "string"
      },
      level: {
        default: 1,
        validate: "number"
      }
    },
    parseDOM: pY.map((t) => ({
      tag: `h${t}`,
      getAttrs: (r) => {
        if (!(r instanceof HTMLElement)) throw Vi(r);
        return { level: t, id: r.id };
      }
    })),
    toDOM: (t) => [
      `h${t.attrs.level}`,
      {
        ...n.get(wb.key)(t),
        id: t.attrs.id || e(t)
      },
      0
    ],
    parseMarkdown: {
      match: ({ type: t }) => t === "heading",
      runner: (t, r, i) => {
        const s = r.depth;
        t.openNode(i, { level: s }), t.next(r.children), t.closeNode();
      }
    },
    toMarkdown: {
      match: (t) => t.type.name === "heading",
      runner: (t, r) => {
        t.openNode("heading", void 0, { depth: r.attrs.level }), gO(t, r), t.closeNode();
      }
    }
  };
});
K(jr.node, {
  displayName: "NodeSchema<heading>",
  group: "Heading"
});
K(jr.ctx, {
  displayName: "NodeSchemaCtx<heading>",
  group: "Heading"
});
const CO = Qn((n) => D3(
  /^(?<hashes>#+)\s$/,
  jr.type(n),
  (e) => {
    const t = e.groups?.hashes?.length || 0, r = n.get(Lt), { $from: i } = r.state.selection, s = i.node();
    if (s.type.name === "heading") {
      let o = Number(s.attrs.level) + Number(t);
      return o > 6 && (o = 6), { level: o };
    }
    return { level: t };
  }
));
K(CO, {
  displayName: "InputRule<wrapInHeadingInputRule>",
  group: "Heading"
});
const Ho = Ye("WrapInHeading", (n) => (e) => (e ??= 1, e < 1 ? Lf(Os.type(n)) : Lf(jr.type(n), { level: e })));
K(Ho, {
  displayName: "Command<wrapInHeadingCommand>",
  group: "Heading"
});
const xb = Ye(
  "DowngradeHeading",
  (n) => () => (e, t, r) => {
    const { $from: i } = e.selection, s = i.node();
    if (s.type !== jr.type(n) || !e.selection.empty || i.parentOffset !== 0)
      return !1;
    const o = s.attrs.level - 1;
    return o ? (t?.(
      e.tr.setNodeMarkup(e.selection.$from.before(), void 0, {
        ...s.attrs,
        level: o
      })
    ), !0) : Lf(Os.type(n))(e, t, r);
  }
);
K(xb, {
  displayName: "Command<downgradeHeadingCommand>",
  group: "Heading"
});
const kb = Rr("headingKeymap", {
  TurnIntoH1: {
    shortcuts: "Mod-Alt-1",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 1);
    }
  },
  TurnIntoH2: {
    shortcuts: "Mod-Alt-2",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 2);
    }
  },
  TurnIntoH3: {
    shortcuts: "Mod-Alt-3",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 3);
    }
  },
  TurnIntoH4: {
    shortcuts: "Mod-Alt-4",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 4);
    }
  },
  TurnIntoH5: {
    shortcuts: "Mod-Alt-5",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 5);
    }
  },
  TurnIntoH6: {
    shortcuts: "Mod-Alt-6",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ho.key, 6);
    }
  },
  DowngradeHeading: {
    shortcuts: ["Delete", "Backspace"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(xb.key);
    }
  }
});
K(kb.ctx, {
  displayName: "KeymapCtx<heading>",
  group: "Heading"
});
K(kb.shortcuts, {
  displayName: "Keymap<heading>",
  group: "Heading"
});
const Sb = qi("blockquote");
K(Sb, {
  displayName: "Attr<blockquote>",
  group: "Blockquote"
});
const ou = hn(
  "blockquote",
  (n) => ({
    content: "block+",
    group: "block",
    defining: !0,
    parseDOM: [{ tag: "blockquote" }],
    toDOM: (e) => ["blockquote", n.get(Sb.key)(e), 0],
    parseMarkdown: {
      match: ({ type: e }) => e === "blockquote",
      runner: (e, t, r) => {
        e.openNode(r).next(t.children).closeNode();
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === "blockquote",
      runner: (e, t) => {
        e.openNode("blockquote").next(t.content).closeNode();
      }
    }
  })
);
K(ou.node, {
  displayName: "NodeSchema<blockquote>",
  group: "Blockquote"
});
K(ou.ctx, {
  displayName: "NodeSchemaCtx<blockquote>",
  group: "Blockquote"
});
const MO = Qn(
  (n) => I3(/^\s*>\s$/, ou.type(n))
);
K(MO, {
  displayName: "InputRule<wrapInBlockquoteInputRule>",
  group: "Blockquote"
});
const Cb = Ye(
  "WrapInBlockquote",
  (n) => () => U3(ou.type(n))
);
K(Cb, {
  displayName: "Command<wrapInBlockquoteCommand>",
  group: "Blockquote"
});
const Mb = Rr("blockquoteKeymap", {
  WrapInBlockquote: {
    shortcuts: "Mod-Shift-b",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Cb.key);
    }
  }
});
K(Mb.ctx, {
  displayName: "KeymapCtx<blockquote>",
  group: "Blockquote"
});
K(Mb.shortcuts, {
  displayName: "Keymap<blockquote>",
  group: "Blockquote"
});
const Tb = qi("codeBlock", () => ({
  pre: {},
  code: {}
}));
K(Tb, {
  displayName: "Attr<codeBlock>",
  group: "CodeBlock"
});
const Cs = hn("code_block", (n) => ({
  content: "text*",
  group: "block",
  marks: "",
  defining: !0,
  code: !0,
  attrs: {
    language: {
      default: "",
      validate: "string"
    }
  },
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return { language: e.dataset.language };
      }
    }
  ],
  toDOM: (e) => {
    const t = n.get(Tb.key)(e), r = e.attrs.language, i = r && r.length > 0 ? { "data-language": r } : void 0;
    return [
      "pre",
      {
        ...t.pre,
        ...i
      },
      ["code", t.code, 0]
    ];
  },
  parseMarkdown: {
    match: ({ type: e }) => e === "code",
    runner: (e, t, r) => {
      const i = t.lang ?? "", s = t.value;
      e.openNode(r, { language: i }), s && e.addText(s), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "code_block",
    runner: (e, t) => {
      e.addNode("code", void 0, t.content.firstChild?.text || "", {
        lang: t.attrs.language
      });
    }
  }
}));
K(Cs.node, {
  displayName: "NodeSchema<codeBlock>",
  group: "CodeBlock"
});
K(Cs.ctx, {
  displayName: "NodeSchemaCtx<codeBlock>",
  group: "CodeBlock"
});
const TO = Qn(
  (n) => D3(
    /^```(?<language>[a-z]*)?[\s\n]$/,
    Cs.type(n),
    (e) => ({
      language: e.groups?.language ?? ""
    })
  )
);
K(TO, {
  displayName: "InputRule<createCodeBlockInputRule>",
  group: "CodeBlock"
});
const Ab = Ye(
  "CreateCodeBlock",
  (n) => (e = "") => Lf(Cs.type(n), { language: e })
);
K(Ab, {
  displayName: "Command<createCodeBlockCommand>",
  group: "CodeBlock"
});
const gY = Ye(
  "UpdateCodeBlockLanguage",
  () => ({ pos: n, language: e } = {
    pos: -1,
    language: ""
  }) => (t, r) => n >= 0 ? (r?.(t.tr.setNodeAttribute(n, "language", e)), !0) : !1
);
K(gY, {
  displayName: "Command<updateCodeBlockLanguageCommand>",
  group: "CodeBlock"
});
const Ob = Rr("codeBlockKeymap", {
  CreateCodeBlock: {
    shortcuts: "Mod-Alt-c",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ab.key);
    }
  }
});
K(Ob.ctx, {
  displayName: "KeymapCtx<codeBlock>",
  group: "CodeBlock"
});
K(Ob.shortcuts, {
  displayName: "Keymap<codeBlock>",
  group: "CodeBlock"
});
const Eb = qi("image");
K(Eb, {
  displayName: "Attr<image>",
  group: "Image"
});
const La = hn("image", (n) => ({
  inline: !0,
  group: "inline",
  selectable: !0,
  draggable: !0,
  marks: "",
  atom: !0,
  defining: !0,
  isolating: !0,
  attrs: {
    src: { default: "", validate: "string" },
    alt: { default: "", validate: "string" },
    title: { default: "", validate: "string" }
  },
  parseDOM: [
    {
      tag: "img[src]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return {
          src: e.getAttribute("src") || "",
          alt: e.getAttribute("alt") || "",
          title: e.getAttribute("title") || e.getAttribute("alt") || ""
        };
      }
    }
  ],
  toDOM: (e) => ["img", { ...n.get(Eb.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: ({ type: e }) => e === "image",
    runner: (e, t, r) => {
      const i = t.url, s = t.alt, o = t.title;
      e.addNode(r, {
        src: i,
        alt: s,
        title: o
      });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "image",
    runner: (e, t) => {
      e.addNode("image", void 0, void 0, {
        title: t.attrs.title,
        url: t.attrs.src,
        alt: t.attrs.alt
      });
    }
  }
}));
K(La.node, {
  displayName: "NodeSchema<image>",
  group: "Image"
});
K(La.ctx, {
  displayName: "NodeSchemaCtx<image>",
  group: "Image"
});
const AO = Ye(
  "InsertImage",
  (n) => (e = {}) => (t, r) => {
    if (!r) return !0;
    const { src: i = "", alt: s = "", title: o = "" } = e, l = La.type(n).create({ src: i, alt: s, title: o });
    return l && r(t.tr.replaceSelectionWith(l).scrollIntoView()), !0;
  }
);
K(AO, {
  displayName: "Command<insertImageCommand>",
  group: "Image"
});
const OO = Ye(
  "UpdateImage",
  (n) => (e = {}) => (t, r) => {
    const i = vV(
      t.selection,
      La.type(n)
    );
    if (!i) return !1;
    const { node: s, pos: o } = i, l = { ...s.attrs }, { src: a, alt: c, title: u } = e;
    return a !== void 0 && (l.src = a), c !== void 0 && (l.alt = c), u !== void 0 && (l.title = u), r?.(
      t.tr.setNodeMarkup(o, void 0, l).scrollIntoView()
    ), !0;
  }
);
K(OO, {
  displayName: "Command<updateImageCommand>",
  group: "Image"
});
const yY = Qn(
  (n) => new Ir(
    /!\[(?<alt>.*?)]\((?<filename>.*?)\s*(?="|\))"?(?<title>[^"]+)?"?\)/,
    (e, t, r, i) => {
      const [s, o, l = "", a] = t;
      return s ? e.tr.replaceWith(
        r,
        i,
        La.type(n).create({ src: l, alt: o, title: a })
      ) : null;
    }
  )
);
K(yY, {
  displayName: "InputRule<insertImageInputRule>",
  group: "Image"
});
const Tm = qi("hardbreak", (n) => ({
  "data-type": "hardbreak",
  "data-is-inline": n.attrs.isInline
}));
K(Tm, {
  displayName: "Attr<hardbreak>",
  group: "Hardbreak"
});
const ua = hn("hardbreak", (n) => ({
  inline: !0,
  group: "inline",
  attrs: {
    isInline: {
      default: !1,
      validate: "boolean"
    }
  },
  selectable: !1,
  parseDOM: [
    { tag: "br" },
    {
      tag: 'span[data-type="hardbreak"]',
      getAttrs: () => ({ isInline: !0 })
    }
  ],
  toDOM: (e) => e.attrs.isInline ? ["span", n.get(Tm.key)(e), " "] : ["br", n.get(Tm.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "break",
    runner: (e, t, r) => {
      e.addNode(r, {
        isInline: !!t.data?.isInline
      });
    }
  },
  leafText: () => `
`,
  toMarkdown: {
    match: (e) => e.type.name === "hardbreak",
    runner: (e, t) => {
      t.attrs.isInline ? e.addNode("text", void 0, `
`) : e.addNode("break");
    }
  }
}));
K(ua.node, {
  displayName: "NodeSchema<hardbreak>",
  group: "Hardbreak"
});
K(ua.ctx, {
  displayName: "NodeSchemaCtx<hardbreak>",
  group: "Hardbreak"
});
const Ib = Ye(
  "InsertHardbreak",
  (n) => () => (e, t) => {
    const { selection: r, tr: i } = e;
    if (!(r instanceof Ee)) return !1;
    if (r.empty) {
      const s = r.$from.node();
      if (s.childCount > 0 && s.lastChild?.type.name === "hardbreak")
        return t?.(
          i.replaceRangeWith(
            r.to - 1,
            r.to,
            e.schema.node("paragraph")
          ).setSelection(Ge.near(i.doc.resolve(r.to))).scrollIntoView()
        ), !0;
    }
    return t?.(
      i.setMeta("hardbreak", !0).replaceSelectionWith(ua.type(n).create()).scrollIntoView()
    ), !0;
  }
);
K(Ib, {
  displayName: "Command<insertHardbreakCommand>",
  group: "Hardbreak"
});
const Db = Rr("hardbreakKeymap", {
  InsertHardbreak: {
    shortcuts: "Shift-Enter",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Ib.key);
    }
  }
});
K(Db.ctx, {
  displayName: "KeymapCtx<hardbreak>",
  group: "Hardbreak"
});
K(Db.shortcuts, {
  displayName: "Keymap<hardbreak>",
  group: "Hardbreak"
});
const Nb = qi("hr");
K(Nb, {
  displayName: "Attr<hr>",
  group: "Hr"
});
const lu = hn("hr", (n) => ({
  group: "block",
  parseDOM: [{ tag: "hr" }],
  toDOM: (e) => ["hr", n.get(Nb.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "thematicBreak",
    runner: (e, t, r) => {
      e.addNode(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "hr",
    runner: (e) => {
      e.addNode("thematicBreak");
    }
  }
}));
K(lu.node, {
  displayName: "NodeSchema<hr>",
  group: "Hr"
});
K(lu.ctx, {
  displayName: "NodeSchemaCtx<hr>",
  group: "Hr"
});
const EO = Qn(
  (n) => new Ir(/^(?:---|___\s|\*\*\*\s)$/, (e, t, r, i) => {
    const { tr: s } = e;
    return t[0] && s.replaceWith(r - 1, i, lu.type(n).create()), s;
  })
);
K(EO, {
  displayName: "InputRule<insertHrInputRule>",
  group: "Hr"
});
const IO = Ye(
  "InsertHr",
  (n) => () => (e, t) => {
    if (!t) return !0;
    const r = Os.node.type(n).create(), { tr: i, selection: s } = e, { from: o } = s, l = lu.type(n).create();
    if (!l) return !0;
    const a = i.replaceSelectionWith(l).insert(o, r), c = Ge.findFrom(a.doc.resolve(o), 1, !0);
    return c && t(a.setSelection(c).scrollIntoView()), !0;
  }
);
K(IO, {
  displayName: "Command<insertHrCommand>",
  group: "Hr"
});
const Rb = qi("bulletList");
K(Rb, {
  displayName: "Attr<bulletList>",
  group: "BulletList"
});
const Ba = hn("bullet_list", (n) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    spread: {
      default: !1,
      validate: "boolean"
    }
  },
  parseDOM: [
    {
      tag: "ul",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return {
          spread: e.dataset.spread === "true"
        };
      }
    }
  ],
  toDOM: (e) => [
    "ul",
    {
      ...n.get(Rb.key)(e),
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: t }) => e === "list" && !t,
    runner: (e, t, r) => {
      const i = t.spread != null ? `${t.spread}` : "false";
      e.openNode(r, { spread: i }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "bullet_list",
    runner: (e, t) => {
      e.openNode("list", void 0, {
        ordered: !1,
        spread: t.attrs.spread
      }).next(t.content).closeNode();
    }
  }
}));
K(Ba.node, {
  displayName: "NodeSchema<bulletList>",
  group: "BulletList"
});
K(Ba.ctx, {
  displayName: "NodeSchemaCtx<bulletList>",
  group: "BulletList"
});
const DO = Qn(
  (n) => I3(/^\s*([-+*])\s$/, Ba.type(n))
);
K(DO, {
  displayName: "InputRule<wrapInBulletListInputRule>",
  group: "BulletList"
});
const Pb = Ye(
  "WrapInBulletList",
  (n) => () => U3(Ba.type(n))
);
K(Pb, {
  displayName: "Command<wrapInBulletListCommand>",
  group: "BulletList"
});
const _b = Rr("bulletListKeymap", {
  WrapInBulletList: {
    shortcuts: "Mod-Alt-8",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Pb.key);
    }
  }
});
K(_b.ctx, {
  displayName: "KeymapCtx<bulletListKeymap>",
  group: "BulletList"
});
K(_b.shortcuts, {
  displayName: "Keymap<bulletListKeymap>",
  group: "BulletList"
});
const Lb = qi("orderedList");
K(Lb, {
  displayName: "Attr<orderedList>",
  group: "OrderedList"
});
const za = hn("ordered_list", (n) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    order: {
      default: 1,
      validate: "number"
    },
    spread: {
      default: !1,
      validate: "boolean"
    }
  },
  parseDOM: [
    {
      tag: "ol",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return {
          spread: e.dataset.spread,
          order: e.hasAttribute("start") ? Number(e.getAttribute("start")) : 1
        };
      }
    }
  ],
  toDOM: (e) => [
    "ol",
    {
      ...n.get(Lb.key)(e),
      ...e.attrs.order === 1 ? {} : e.attrs.order,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: t }) => e === "list" && !!t,
    runner: (e, t, r) => {
      const i = t.spread != null ? `${t.spread}` : "true";
      e.openNode(r, { spread: i }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "ordered_list",
    runner: (e, t) => {
      e.openNode("list", void 0, {
        ordered: !0,
        start: 1,
        spread: t.attrs.spread === "true"
      }), e.next(t.content), e.closeNode();
    }
  }
}));
K(za.node, {
  displayName: "NodeSchema<orderedList>",
  group: "OrderedList"
});
K(za.ctx, {
  displayName: "NodeSchemaCtx<orderedList>",
  group: "OrderedList"
});
const NO = Qn(
  (n) => I3(
    /^\s*(\d+)\.\s$/,
    za.type(n),
    (e) => ({ order: Number(e[1]) }),
    (e, t) => t.childCount + t.attrs.order === Number(e[1])
  )
);
K(NO, {
  displayName: "InputRule<wrapInOrderedListInputRule>",
  group: "OrderedList"
});
const Bb = Ye(
  "WrapInOrderedList",
  (n) => () => U3(za.type(n))
);
K(Bb, {
  displayName: "Command<wrapInOrderedListCommand>",
  group: "OrderedList"
});
const zb = Rr("orderedListKeymap", {
  WrapInOrderedList: {
    shortcuts: "Mod-Alt-7",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Bb.key);
    }
  }
});
K(zb.ctx, {
  displayName: "KeymapCtx<orderedList>",
  group: "OrderedList"
});
K(zb.shortcuts, {
  displayName: "Keymap<orderedList>",
  group: "OrderedList"
});
const Fb = qi("listItem");
K(Fb, {
  displayName: "Attr<listItem>",
  group: "ListItem"
});
const Wi = hn("list_item", (n) => ({
  group: "listItem",
  content: "paragraph block*",
  attrs: {
    label: {
      default: "•",
      validate: "string"
    },
    listType: {
      default: "bullet",
      validate: "string"
    },
    spread: {
      default: !0,
      validate: "boolean"
    }
  },
  defining: !0,
  parseDOM: [
    {
      tag: "li",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Vi(e);
        return {
          label: e.dataset.label,
          listType: e.dataset.listType,
          spread: e.dataset.spread === "true"
        };
      }
    }
  ],
  toDOM: (e) => [
    "li",
    {
      ...n.get(Fb.key)(e),
      "data-label": e.attrs.label,
      "data-list-type": e.attrs.listType,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "listItem",
    runner: (e, t, r) => {
      const i = t.label != null ? `${t.label}.` : "•", s = t.label != null ? "ordered" : "bullet", o = t.spread != null ? `${t.spread}` : "true";
      e.openNode(r, { label: i, listType: s, spread: o }), e.next(t.children), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "list_item",
    runner: (e, t) => {
      e.openNode("listItem", void 0, {
        spread: t.attrs.spread
      }), e.next(t.content), e.closeNode();
    }
  }
}));
K(Wi.node, {
  displayName: "NodeSchema<listItem>",
  group: "ListItem"
});
K(Wi.ctx, {
  displayName: "NodeSchemaCtx<listItem>",
  group: "ListItem"
});
const Hb = Ye(
  "SinkListItem",
  (n) => () => cY(Wi.type(n))
);
K(Hb, {
  displayName: "Command<sinkListItemCommand>",
  group: "ListItem"
});
const $b = Ye(
  "LiftListItem",
  (n) => () => oY(Wi.type(n))
);
K($b, {
  displayName: "Command<liftListItemCommand>",
  group: "ListItem"
});
const Vb = Ye(
  "SplitListItem",
  (n) => () => sY(Wi.type(n))
);
K(Vb, {
  displayName: "Command<splitListItemCommand>",
  group: "ListItem"
});
function bY(n) {
  return (e, t, r) => {
    const { selection: i } = e;
    if (!(i instanceof Ee)) return !1;
    const { empty: s, $from: o } = i;
    return !s || o.parentOffset !== 0 || o.node(-1).type !== Wi.type(n) ? !1 : iA(e, t, r);
  };
}
const qb = Ye(
  "LiftFirstListItem",
  (n) => () => bY(n)
);
K(qb, {
  displayName: "Command<liftFirstListItemCommand>",
  group: "ListItem"
});
const Wb = Rr("listItemKeymap", {
  NextListItem: {
    shortcuts: "Enter",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Vb.key);
    }
  },
  SinkListItem: {
    shortcuts: ["Tab", "Mod-]"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Hb.key);
    }
  },
  LiftListItem: {
    shortcuts: ["Shift-Tab", "Mod-["],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call($b.key);
    }
  },
  LiftFirstListItem: {
    shortcuts: ["Backspace", "Delete"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(qb.key);
    }
  }
});
K(Wb.ctx, {
  displayName: "KeymapCtx<listItem>",
  group: "ListItem"
});
K(Wb.shortcuts, {
  displayName: "Keymap<listItem>",
  group: "ListItem"
});
const RO = sb("text", () => ({
  group: "inline",
  parseMarkdown: {
    match: ({ type: n }) => n === "text",
    runner: (n, e) => {
      n.addText(e.value);
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "text",
    runner: (n, e) => {
      n.addNode("text", void 0, e.text);
    }
  }
}));
K(RO, {
  displayName: "NodeSchema<text>",
  group: "Text"
});
const jb = qi("html");
K(jb, {
  displayName: "Attr<html>",
  group: "Html"
});
const Ub = hn("html", (n) => ({
  atom: !0,
  group: "inline",
  inline: !0,
  attrs: {
    value: {
      default: "",
      validate: "string"
    }
  },
  toDOM: (e) => {
    const t = document.createElement("span"), r = {
      ...n.get(jb.key)(e),
      "data-value": e.attrs.value,
      "data-type": "html"
    };
    return t.textContent = e.attrs.value, ["span", r, e.attrs.value];
  },
  parseDOM: [
    {
      tag: 'span[data-type="html"]',
      getAttrs: (e) => ({
        value: e.dataset.value ?? ""
      })
    }
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "html",
    runner: (e, t, r) => {
      e.addNode(r, { value: t.value });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "html",
    runner: (e, t) => {
      e.addNode("html", void 0, t.attrs.value);
    }
  }
}));
K(Ub.node, {
  displayName: "NodeSchema<html>",
  group: "Html"
});
K(Ub.ctx, {
  displayName: "NodeSchemaCtx<html>",
  group: "Html"
});
const vY = [
  SO,
  yb,
  Os,
  H1,
  wb,
  jr,
  Tm,
  ua,
  Sb,
  ou,
  Tb,
  Cs,
  Nb,
  lu,
  Eb,
  La,
  Rb,
  Ba,
  Lb,
  za,
  Fb,
  Wi,
  ub,
  _a,
  fb,
  su,
  pb,
  eo,
  gb,
  Ri,
  jb,
  Ub,
  RO
].flat(), wY = [
  MO,
  DO,
  NO,
  TO,
  EO,
  CO
].flat(), xY = [
  yO,
  bO,
  wO,
  vO
], rc = Ye(
  "IsMarkSelected",
  () => (n) => (e) => {
    if (!n) return !1;
    const { doc: t, selection: r } = e;
    return t.rangeHasMark(r.from, r.to, n);
  }
), PO = Ye(
  "IsNoteSelected",
  () => (n) => (e) => n ? xT(e, n).hasNode : !1
), Dn = Ye(
  "ClearTextInCurrentBlock",
  () => () => (n, e) => {
    let t = n.tr;
    const { $from: r, $to: i } = t.selection, { pos: s } = r, { pos: o } = i, l = s - r.node().content.size;
    return l < 0 ? !1 : (t = t.deleteRange(l, o), e?.(t), !0);
  }
), Vs = Ye(
  "SetBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    const s = e.tr, { from: o, to: l } = s.selection;
    try {
      s.setBlockType(o, l, r, i);
    } catch {
      return !1;
    }
    return t?.(s), !0;
  }
), dh = Ye(
  "WrapInBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    let s = e.tr;
    try {
      const { $from: o, $to: l } = s.selection, a = o.blockRange(l), c = a && O3(a, r, i);
      if (!c) return !1;
      s = s.wrap(a, c);
    } catch {
      return !1;
    }
    return t?.(s), !0;
  }
), ph = Ye(
  "AddBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    const s = e.tr;
    try {
      const o = r instanceof ro ? r : r.createAndFill(i);
      if (!o) return !1;
      s.replaceSelectionWith(o);
    } catch {
      return !1;
    }
    return t?.(s), !0;
  }
), _O = Ye(
  "SelectTextNearPos",
  () => (n) => (e, t) => {
    const { pos: r } = n ?? {};
    if (r == null) return !1;
    const i = (o, l, a) => Math.min(Math.max(o, l), a), s = e.tr;
    try {
      const o = e.doc.resolve(i(r, 0, e.doc.content.size));
      s.setSelection(Ee.near(o));
    } catch {
      return !1;
    }
    return t?.(s.scrollIntoView()), !0;
  }
), kY = [
  bb,
  Cb,
  Ho,
  xb,
  Ab,
  Ib,
  IO,
  AO,
  OO,
  Bb,
  Pb,
  Hb,
  Vb,
  $b,
  qb,
  L1,
  z1,
  B1,
  xO,
  kO,
  rc,
  PO,
  Dn,
  Vs,
  dh,
  ph,
  _O
], SY = [
  Mb,
  Ob,
  Db,
  kb,
  Wb,
  zb,
  _b,
  vb,
  hb,
  mb,
  db
].flat(), Kb = As(
  "remarkAddOrderInList",
  () => () => (n) => {
    Sl(n, "list", (e) => {
      if (e.ordered) {
        const t = e.start ?? 1;
        e.children.forEach((r, i) => {
          r.label = i + t;
        });
      }
    });
  }
);
K(Kb.plugin, {
  displayName: "Remark<remarkAddOrderInListPlugin>",
  group: "Remark"
});
K(Kb.options, {
  displayName: "RemarkConfig<remarkAddOrderInListPlugin>",
  group: "Remark"
});
const Gb = As(
  "remarkLineBreak",
  () => () => (n) => {
    const e = /[\t ]*(?:\r?\n|\r)/g;
    Sl(
      n,
      "text",
      (t, r, i) => {
        if (!t.value || typeof t.value != "string") return;
        const s = [];
        let o = 0;
        e.lastIndex = 0;
        let l = e.exec(t.value);
        for (; l; ) {
          const c = l.index;
          o !== c && s.push({
            type: "text",
            value: t.value.slice(o, c)
          }), s.push({ type: "break", data: { isInline: !0 } }), o = c + l[0].length, l = e.exec(t.value);
        }
        if (s.length > 0 && i && typeof r == "number")
          return o < t.value.length && s.push({ type: "text", value: t.value.slice(o) }), i.children.splice(r, 1, ...s), r + s.length;
      }
    );
  }
);
K(Gb.plugin, {
  displayName: "Remark<remarkLineBreak>",
  group: "Remark"
});
K(Gb.options, {
  displayName: "RemarkConfig<remarkLineBreak>",
  group: "Remark"
});
const Yb = As(
  "remarkInlineLink",
  () => hY
);
K(Yb.plugin, {
  displayName: "Remark<remarkInlineLinkPlugin>",
  group: "Remark"
});
K(Yb.options, {
  displayName: "RemarkConfig<remarkInlineLinkPlugin>",
  group: "Remark"
});
const CY = (n) => !!n.children, MY = (n) => n.type === "html";
function TY(n, e) {
  return t(n, 0, null)[0];
  function t(r, i, s) {
    if (CY(r)) {
      const o = [];
      for (let l = 0, a = r.children.length; l < a; l++) {
        const c = r.children[l];
        if (c) {
          const u = t(c, l, r);
          if (u)
            for (let h = 0, f = u.length; h < f; h++) {
              const d = u[h];
              d && o.push(d);
            }
        }
      }
      r.children = o;
    }
    return e(r, i, s);
  }
}
const AY = ["root", "blockquote", "listItem"], Jb = As(
  "remarkHTMLTransformer",
  () => () => (n) => {
    TY(n, (e, t, r) => MY(e) ? (r && AY.includes(r.type) && (e.children = [{ ...e }], delete e.value, e.type = "paragraph"), [e]) : [e]);
  }
);
K(Jb.plugin, {
  displayName: "Remark<remarkHtmlTransformer>",
  group: "Remark"
});
K(Jb.options, {
  displayName: "RemarkConfig<remarkHtmlTransformer>",
  group: "Remark"
});
const Xb = As(
  "remarkMarker",
  () => () => (n, e) => {
    const t = (r) => e.value.charAt(r.position.start.offset);
    Sl(
      n,
      (r) => ["strong", "emphasis"].includes(r.type),
      (r) => {
        r.marker = t(r);
      }
    );
  }
);
K(Xb.plugin, {
  displayName: "Remark<remarkMarker>",
  group: "Remark"
});
K(Xb.options, {
  displayName: "RemarkConfig<remarkMarker>",
  group: "Remark"
});
const LO = kn(() => {
  let n = !1;
  const e = new en(
    "MILKDOWN_INLINE_NODES_CURSOR"
  ), t = new Ut({
    key: e,
    state: {
      init() {
        return !1;
      },
      apply(r) {
        if (!r.selection.empty) return !1;
        const i = r.selection.$from, s = i.nodeBefore, o = i.nodeAfter;
        return !!(s && o && s.isInline && !s.isText && o.isInline && !o.isText);
      }
    },
    props: {
      handleDOMEvents: {
        compositionend: (r, i) => n ? (n = !1, requestAnimationFrame(() => {
          if (t.getState(r.state)) {
            const o = r.state.selection.from;
            i.preventDefault(), r.dispatch(r.state.tr.insertText(i.data || "", o));
          }
        }), !0) : !1,
        compositionstart: (r) => (t.getState(r.state) && (n = !0), !1),
        beforeinput: (r, i) => {
          if (t.getState(r.state) && i instanceof InputEvent && i.data && !n) {
            const o = r.state.selection.from;
            return i.preventDefault(), r.dispatch(r.state.tr.insertText(i.data || "", o)), !0;
          }
          return !1;
        }
      },
      decorations(r) {
        if (t.getState(r)) {
          const o = r.selection.$from.pos, l = document.createElement("span"), a = mn.widget(o, l, {
            side: -1
          }), c = document.createElement("span"), u = mn.widget(o, c);
          return setTimeout(() => {
            l.contentEditable = "true", c.contentEditable = "true";
          }), Ot.create(r.doc, [a, u]);
        }
        return Ot.empty;
      }
    }
  });
  return t;
});
K(LO, {
  displayName: "Prose<inlineNodesCursorPlugin>",
  group: "Prose"
});
const BO = kn((n) => new Ut({
  key: new en("MILKDOWN_HARDBREAK_MARKS"),
  appendTransaction: (e, t, r) => {
    if (!e.length) return;
    const [i] = e;
    if (!i) return;
    const [s] = i.steps;
    if (i.getMeta("hardbreak")) {
      if (!(s instanceof Cn)) return;
      const { from: a } = s;
      return r.tr.setNodeMarkup(
        a,
        ua.type(n),
        void 0,
        []
      );
    }
    if (s instanceof Zs) {
      let a = r.tr;
      const { from: c, to: u } = s;
      return r.doc.nodesBetween(c, u, (h, f) => {
        h.type === ua.type(n) && (a = a.setNodeMarkup(
          f,
          ua.type(n),
          void 0,
          []
        ));
      }), a;
    }
  }
}));
K(BO, {
  displayName: "Prose<hardbreakClearMarkPlugin>",
  group: "Prose"
});
const Zb = St(
  ["table", "code_block"],
  "hardbreakFilterNodes"
);
K(Zb, {
  displayName: "Ctx<hardbreakFilterNodes>",
  group: "Prose"
});
const zO = kn((n) => {
  const e = n.get(Zb.key);
  return new Ut({
    key: new en("MILKDOWN_HARDBREAK_FILTER"),
    filterTransaction: (t, r) => {
      const i = t.getMeta("hardbreak"), [s] = t.steps;
      if (i && s) {
        const { from: o } = s, l = r.doc.resolve(o);
        let a = l.depth, c = !0;
        for (; a > 0; )
          e.includes(l.node(a).type.name) && (c = !1), a--;
        return c;
      }
      return !0;
    }
  });
});
K(zO, {
  displayName: "Prose<hardbreakFilterPlugin>",
  group: "Prose"
});
const FO = kn((n) => {
  const e = new en("MILKDOWN_HEADING_ID"), t = (r) => {
    if (r.composing) return;
    const i = n.get(H1.key), s = r.state.tr.setMeta("addToHistory", !1);
    let o = !1;
    const l = {};
    r.state.doc.descendants((a, c) => {
      if (a.type === jr.type(n)) {
        if (a.textContent.trim().length === 0) return;
        const u = a.attrs;
        let h = i(a);
        l[h] ? (l[h] += 1, h += `-#${l[h]}`) : l[h] = 1, u.id !== h && (o = !0, s.setMeta(e, !0).setNodeMarkup(c, void 0, {
          ...u,
          id: h
        }));
      }
    }), o && r.dispatch(s);
  };
  return new Ut({
    key: e,
    view: (r) => (t(r), {
      update: (i, s) => {
        i.state.doc.eq(s.doc) || t(i);
      }
    })
  });
});
K(FO, {
  displayName: "Prose<syncHeadingIdPlugin>",
  group: "Prose"
});
const HO = kn((n) => {
  const e = (t, r, i) => {
    if (!i.selection || t.some(
      (h) => h.getMeta("addToHistory") === !1 || !h.isGeneric
    ))
      return null;
    const s = za.type(n), o = Ba.type(n), l = Wi.type(n), a = (h, f) => {
      let d = !1;
      const p = `${f + 1}.`;
      return h.label !== p && (h.label = p, d = !0), d;
    };
    let c = i.tr, u = !1;
    return i.doc.descendants(
      (h, f, d, p) => {
        if (h.type === o) {
          const m = h.maybeChild(0);
          m?.type === l && m.attrs.listType === "ordered" && (u = !0, c.setNodeMarkup(f, s, { spread: "true" }), h.descendants(
            (g, b, w, k) => {
              if (g.type === l) {
                const C = { ...g.attrs };
                a(C, k) && (c = c.setNodeMarkup(b, void 0, C));
              }
              return !1;
            }
          ));
        } else if (h.type === l && d?.type === s) {
          const m = { ...h.attrs };
          let g = !1;
          m.listType !== "ordered" && (m.listType = "ordered", g = !0), d?.maybeChild(0) && (g = a(m, p)), g && (c = c.setNodeMarkup(f, void 0, m), u = !0);
        }
      }
    ), u ? c.setMeta("addToHistory", !1) : null;
  };
  return new Ut({
    key: new en("MILKDOWN_KEEP_LIST_ORDER"),
    appendTransaction: e
  });
});
K(HO, {
  displayName: "Prose<syncListOrderPlugin>",
  group: "Prose"
});
const OY = [
  BO,
  Zb,
  zO,
  LO,
  Kb,
  Yb,
  Gb,
  Jb,
  Xb,
  F1,
  FO,
  HO
].flat(), EY = [
  vY,
  wY,
  xY,
  kY,
  SY,
  OY
].flat();
/**
* @vue/shared v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Qb(n) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const t of n.split(",")) e[t] = 1;
  return (t) => t in e;
}
const _t = {}, nf = [], Pi = () => {
}, IY = () => !1, $1 = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // uppercase letter
(n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97), ev = (n) => n.startsWith("onUpdate:"), Xn = Object.assign, tv = (n, e) => {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}, DY = Object.prototype.hasOwnProperty, bt = (n, e) => DY.call(n, e), Ze = Array.isArray, rf = (n) => V1(n) === "[object Map]", NY = (n) => V1(n) === "[object Set]", tt = (n) => typeof n == "function", An = (n) => typeof n == "string", au = (n) => typeof n == "symbol", un = (n) => n !== null && typeof n == "object", $O = (n) => (un(n) || tt(n)) && tt(n.then) && tt(n.catch), RY = Object.prototype.toString, V1 = (n) => RY.call(n), PY = (n) => V1(n).slice(8, -1), _Y = (n) => V1(n) === "[object Object]", nv = (n) => An(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n, sf = /* @__PURE__ */ Qb(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), q1 = (n) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = n(t));
}, LY = /-(\w)/g, gl = q1(
  (n) => n.replace(LY, (e, t) => t ? t.toUpperCase() : "")
), BY = /\B([A-Z])/g, Fa = q1(
  (n) => n.replace(BY, "-$1").toLowerCase()
), VO = q1((n) => n.charAt(0).toUpperCase() + n.slice(1)), E2 = q1(
  (n) => n ? `on${VO(n)}` : ""
), sl = (n, e) => !Object.is(n, e), I2 = (n, ...e) => {
  for (let t = 0; t < n.length; t++)
    n[t](...e);
}, jf = (n, e, t, r = !1) => {
  Object.defineProperty(n, e, {
    configurable: !0,
    enumerable: !1,
    writable: r,
    value: t
  });
}, zY = (n) => {
  const e = parseFloat(n);
  return isNaN(e) ? n : e;
};
let k8;
const ha = () => k8 || (k8 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function rv(n) {
  if (Ze(n)) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
      const r = n[t], i = An(r) ? VY(r) : rv(r);
      if (i)
        for (const s in i)
          e[s] = i[s];
    }
    return e;
  } else if (An(n) || un(n))
    return n;
}
const FY = /;(?![^(]*\))/g, HY = /:([^]+)/, $Y = /\/\*[^]*?\*\//g;
function VY(n) {
  const e = {};
  return n.replace($Y, "").split(FY).forEach((t) => {
    if (t) {
      const r = t.split(HY);
      r.length > 1 && (e[r[0].trim()] = r[1].trim());
    }
  }), e;
}
function iv(n) {
  let e = "";
  if (An(n))
    e = n;
  else if (Ze(n))
    for (let t = 0; t < n.length; t++) {
      const r = iv(n[t]);
      r && (e += r + " ");
    }
  else if (un(n))
    for (const t in n)
      n[t] && (e += t + " ");
  return e.trim();
}
const qY = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", WY = /* @__PURE__ */ Qb(qY);
function qO(n) {
  return !!n || n === "";
}
/**
* @vue/reactivity v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let wr;
class jY {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = wr, !e && wr && (this.index = (wr.scopes || (wr.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, t;
      if (this.scopes)
        for (e = 0, t = this.scopes.length; e < t; e++)
          this.scopes[e].pause();
      for (e = 0, t = this.effects.length; e < t; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, t;
      if (this.scopes)
        for (e = 0, t = this.scopes.length; e < t; e++)
          this.scopes[e].resume();
      for (e = 0, t = this.effects.length; e < t; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const t = wr;
      try {
        return wr = this, e();
      } finally {
        wr = t;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = wr, wr = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (wr = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let t, r;
      for (t = 0, r = this.effects.length; t < r; t++)
        this.effects[t].stop();
      for (this.effects.length = 0, t = 0, r = this.cleanups.length; t < r; t++)
        this.cleanups[t]();
      if (this.cleanups.length = 0, this.scopes) {
        for (t = 0, r = this.scopes.length; t < r; t++)
          this.scopes[t].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function UY() {
  return wr;
}
let Pt;
const D2 = /* @__PURE__ */ new WeakSet();
class WO {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, wr && wr.active && wr.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, D2.has(this) && (D2.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || UO(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, S8(this), KO(this);
    const e = Pt, t = _i;
    Pt = this, _i = !0;
    try {
      return this.fn();
    } finally {
      GO(this), Pt = e, _i = t, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        lv(e);
      this.deps = this.depsTail = void 0, S8(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? D2.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    r5(this) && this.run();
  }
  get dirty() {
    return r5(this);
  }
}
let jO = 0, of, lf;
function UO(n, e = !1) {
  if (n.flags |= 8, e) {
    n.next = lf, lf = n;
    return;
  }
  n.next = of, of = n;
}
function sv() {
  jO++;
}
function ov() {
  if (--jO > 0)
    return;
  if (lf) {
    let e = lf;
    for (lf = void 0; e; ) {
      const t = e.next;
      e.next = void 0, e.flags &= -9, e = t;
    }
  }
  let n;
  for (; of; ) {
    let e = of;
    for (of = void 0; e; ) {
      const t = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (r) {
          n || (n = r);
        }
      e = t;
    }
  }
  if (n) throw n;
}
function KO(n) {
  for (let e = n.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function GO(n) {
  let e, t = n.depsTail, r = t;
  for (; r; ) {
    const i = r.prevDep;
    r.version === -1 ? (r === t && (t = i), lv(r), KY(r)) : e = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = i;
  }
  n.deps = e, n.depsTail = t;
}
function r5(n) {
  for (let e = n.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (YO(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!n._dirty;
}
function YO(n) {
  if (n.flags & 4 && !(n.flags & 16) || (n.flags &= -17, n.globalVersion === Uf) || (n.globalVersion = Uf, !n.isSSR && n.flags & 128 && (!n.deps && !n._dirty || !r5(n))))
    return;
  n.flags |= 2;
  const e = n.dep, t = Pt, r = _i;
  Pt = n, _i = !0;
  try {
    KO(n);
    const i = n.fn(n._value);
    (e.version === 0 || sl(i, n._value)) && (n.flags |= 128, n._value = i, e.version++);
  } catch (i) {
    throw e.version++, i;
  } finally {
    Pt = t, _i = r, GO(n), n.flags &= -3;
  }
}
function lv(n, e = !1) {
  const { dep: t, prevSub: r, nextSub: i } = n;
  if (r && (r.nextSub = i, n.prevSub = void 0), i && (i.prevSub = r, n.nextSub = void 0), t.subs === n && (t.subs = r, !r && t.computed)) {
    t.computed.flags &= -5;
    for (let s = t.computed.deps; s; s = s.nextDep)
      lv(s, !0);
  }
  !e && !--t.sc && t.map && t.map.delete(t.key);
}
function KY(n) {
  const { prevDep: e, nextDep: t } = n;
  e && (e.nextDep = t, n.prevDep = void 0), t && (t.prevDep = e, n.nextDep = void 0);
}
let _i = !0;
const JO = [];
function ho() {
  JO.push(_i), _i = !1;
}
function fo() {
  const n = JO.pop();
  _i = n === void 0 ? !0 : n;
}
function S8(n) {
  const { cleanup: e } = n;
  if (n.cleanup = void 0, e) {
    const t = Pt;
    Pt = void 0;
    try {
      e();
    } finally {
      Pt = t;
    }
  }
}
let Uf = 0;
class GY {
  constructor(e, t) {
    this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class av {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(e) {
    if (!Pt || !_i || Pt === this.computed)
      return;
    let t = this.activeLink;
    if (t === void 0 || t.sub !== Pt)
      t = this.activeLink = new GY(Pt, this), Pt.deps ? (t.prevDep = Pt.depsTail, Pt.depsTail.nextDep = t, Pt.depsTail = t) : Pt.deps = Pt.depsTail = t, XO(t);
    else if (t.version === -1 && (t.version = this.version, t.nextDep)) {
      const r = t.nextDep;
      r.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = r), t.prevDep = Pt.depsTail, t.nextDep = void 0, Pt.depsTail.nextDep = t, Pt.depsTail = t, Pt.deps === t && (Pt.deps = r);
    }
    return t;
  }
  trigger(e) {
    this.version++, Uf++, this.notify(e);
  }
  notify(e) {
    sv();
    try {
      for (let t = this.subs; t; t = t.prevSub)
        t.sub.notify() && t.sub.dep.notify();
    } finally {
      ov();
    }
  }
}
function XO(n) {
  if (n.dep.sc++, n.sub.flags & 4) {
    const e = n.dep.computed;
    if (e && !n.dep.subs) {
      e.flags |= 20;
      for (let r = e.deps; r; r = r.nextDep)
        XO(r);
    }
    const t = n.dep.subs;
    t !== n && (n.prevSub = t, t && (t.nextSub = n)), n.dep.subs = n;
  }
}
const i5 = /* @__PURE__ */ new WeakMap(), fa = Symbol(
  ""
), s5 = Symbol(
  ""
), Kf = Symbol(
  ""
);
function jn(n, e, t) {
  if (_i && Pt) {
    let r = i5.get(n);
    r || i5.set(n, r = /* @__PURE__ */ new Map());
    let i = r.get(t);
    i || (r.set(t, i = new av()), i.map = r, i.key = t), i.track();
  }
}
function Xs(n, e, t, r, i, s) {
  const o = i5.get(n);
  if (!o) {
    Uf++;
    return;
  }
  const l = (a) => {
    a && a.trigger();
  };
  if (sv(), e === "clear")
    o.forEach(l);
  else {
    const a = Ze(n), c = a && nv(t);
    if (a && t === "length") {
      const u = Number(r);
      o.forEach((h, f) => {
        (f === "length" || f === Kf || !au(f) && f >= u) && l(h);
      });
    } else
      switch ((t !== void 0 || o.has(void 0)) && l(o.get(t)), c && l(o.get(Kf)), e) {
        case "add":
          a ? c && l(o.get("length")) : (l(o.get(fa)), rf(n) && l(o.get(s5)));
          break;
        case "delete":
          a || (l(o.get(fa)), rf(n) && l(o.get(s5)));
          break;
        case "set":
          rf(n) && l(o.get(fa));
          break;
      }
  }
  ov();
}
function Ja(n) {
  const e = yt(n);
  return e === n ? e : (jn(e, "iterate", Kf), Li(n) ? e : e.map(sr));
}
function cv(n) {
  return jn(n = yt(n), "iterate", Kf), n;
}
const YY = {
  __proto__: null,
  [Symbol.iterator]() {
    return N2(this, Symbol.iterator, sr);
  },
  concat(...n) {
    return Ja(this).concat(
      ...n.map((e) => Ze(e) ? Ja(e) : e)
    );
  },
  entries() {
    return N2(this, "entries", (n) => (n[1] = sr(n[1]), n));
  },
  every(n, e) {
    return zs(this, "every", n, e, void 0, arguments);
  },
  filter(n, e) {
    return zs(this, "filter", n, e, (t) => t.map(sr), arguments);
  },
  find(n, e) {
    return zs(this, "find", n, e, sr, arguments);
  },
  findIndex(n, e) {
    return zs(this, "findIndex", n, e, void 0, arguments);
  },
  findLast(n, e) {
    return zs(this, "findLast", n, e, sr, arguments);
  },
  findLastIndex(n, e) {
    return zs(this, "findLastIndex", n, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(n, e) {
    return zs(this, "forEach", n, e, void 0, arguments);
  },
  includes(...n) {
    return R2(this, "includes", n);
  },
  indexOf(...n) {
    return R2(this, "indexOf", n);
  },
  join(n) {
    return Ja(this).join(n);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...n) {
    return R2(this, "lastIndexOf", n);
  },
  map(n, e) {
    return zs(this, "map", n, e, void 0, arguments);
  },
  pop() {
    return Hu(this, "pop");
  },
  push(...n) {
    return Hu(this, "push", n);
  },
  reduce(n, ...e) {
    return C8(this, "reduce", n, e);
  },
  reduceRight(n, ...e) {
    return C8(this, "reduceRight", n, e);
  },
  shift() {
    return Hu(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(n, e) {
    return zs(this, "some", n, e, void 0, arguments);
  },
  splice(...n) {
    return Hu(this, "splice", n);
  },
  toReversed() {
    return Ja(this).toReversed();
  },
  toSorted(n) {
    return Ja(this).toSorted(n);
  },
  toSpliced(...n) {
    return Ja(this).toSpliced(...n);
  },
  unshift(...n) {
    return Hu(this, "unshift", n);
  },
  values() {
    return N2(this, "values", sr);
  }
};
function N2(n, e, t) {
  const r = cv(n), i = r[e]();
  return r !== n && !Li(n) && (i._next = i.next, i.next = () => {
    const s = i._next();
    return s.value && (s.value = t(s.value)), s;
  }), i;
}
const JY = Array.prototype;
function zs(n, e, t, r, i, s) {
  const o = cv(n), l = o !== n && !Li(n), a = o[e];
  if (a !== JY[e]) {
    const h = a.apply(n, s);
    return l ? sr(h) : h;
  }
  let c = t;
  o !== n && (l ? c = function(h, f) {
    return t.call(this, sr(h), f, n);
  } : t.length > 2 && (c = function(h, f) {
    return t.call(this, h, f, n);
  }));
  const u = a.call(o, c, r);
  return l && i ? i(u) : u;
}
function C8(n, e, t, r) {
  const i = cv(n);
  let s = t;
  return i !== n && (Li(n) ? t.length > 3 && (s = function(o, l, a) {
    return t.call(this, o, l, a, n);
  }) : s = function(o, l, a) {
    return t.call(this, o, sr(l), a, n);
  }), i[e](s, ...r);
}
function R2(n, e, t) {
  const r = yt(n);
  jn(r, "iterate", Kf);
  const i = r[e](...t);
  return (i === -1 || i === !1) && dv(t[0]) ? (t[0] = yt(t[0]), r[e](...t)) : i;
}
function Hu(n, e, t = []) {
  ho(), sv();
  const r = yt(n)[e].apply(n, t);
  return ov(), fo(), r;
}
const XY = /* @__PURE__ */ Qb("__proto__,__v_isRef,__isVue"), ZO = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((n) => n !== "arguments" && n !== "caller").map((n) => Symbol[n]).filter(au)
);
function ZY(n) {
  au(n) || (n = String(n));
  const e = yt(this);
  return jn(e, "has", n), e.hasOwnProperty(n);
}
class QO {
  constructor(e = !1, t = !1) {
    this._isReadonly = e, this._isShallow = t;
  }
  get(e, t, r) {
    if (t === "__v_skip") return e.__v_skip;
    const i = this._isReadonly, s = this._isShallow;
    if (t === "__v_isReactive")
      return !i;
    if (t === "__v_isReadonly")
      return i;
    if (t === "__v_isShallow")
      return s;
    if (t === "__v_raw")
      return r === (i ? s ? aJ : rE : s ? nE : tE).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(r) ? e : void 0;
    const o = Ze(e);
    if (!i) {
      let a;
      if (o && (a = YY[t]))
        return a;
      if (t === "hasOwnProperty")
        return ZY;
    }
    const l = Reflect.get(
      e,
      t,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Jn(e) ? e : r
    );
    return (au(t) ? ZO.has(t) : XY(t)) || (i || jn(e, "get", t), s) ? l : Jn(l) ? o && nv(t) ? l : l.value : un(l) ? i ? iE(l) : hv(l) : l;
  }
}
class eE extends QO {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, t, r, i) {
    let s = e[t];
    if (!this._isShallow) {
      const a = Ea(s);
      if (!Li(r) && !Ea(r) && (s = yt(s), r = yt(r)), !Ze(e) && Jn(s) && !Jn(r))
        return a ? !1 : (s.value = r, !0);
    }
    const o = Ze(e) && nv(t) ? Number(t) < e.length : bt(e, t), l = Reflect.set(
      e,
      t,
      r,
      Jn(e) ? e : i
    );
    return e === yt(i) && (o ? sl(r, s) && Xs(e, "set", t, r) : Xs(e, "add", t, r)), l;
  }
  deleteProperty(e, t) {
    const r = bt(e, t);
    e[t];
    const i = Reflect.deleteProperty(e, t);
    return i && r && Xs(e, "delete", t, void 0), i;
  }
  has(e, t) {
    const r = Reflect.has(e, t);
    return (!au(t) || !ZO.has(t)) && jn(e, "has", t), r;
  }
  ownKeys(e) {
    return jn(
      e,
      "iterate",
      Ze(e) ? "length" : fa
    ), Reflect.ownKeys(e);
  }
}
class QY extends QO {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, t) {
    return !0;
  }
  deleteProperty(e, t) {
    return !0;
  }
}
const eJ = /* @__PURE__ */ new eE(), tJ = /* @__PURE__ */ new QY(), nJ = /* @__PURE__ */ new eE(!0);
const o5 = (n) => n, m0 = (n) => Reflect.getPrototypeOf(n);
function rJ(n, e, t) {
  return function(...r) {
    const i = this.__v_raw, s = yt(i), o = rf(s), l = n === "entries" || n === Symbol.iterator && o, a = n === "keys" && o, c = i[n](...r), u = t ? o5 : e ? l5 : sr;
    return !e && jn(
      s,
      "iterate",
      a ? s5 : fa
    ), {
      // iterator protocol
      next() {
        const { value: h, done: f } = c.next();
        return f ? { value: h, done: f } : {
          value: l ? [u(h[0]), u(h[1])] : u(h),
          done: f
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function g0(n) {
  return function(...e) {
    return n === "delete" ? !1 : n === "clear" ? void 0 : this;
  };
}
function iJ(n, e) {
  const t = {
    get(i) {
      const s = this.__v_raw, o = yt(s), l = yt(i);
      n || (sl(i, l) && jn(o, "get", i), jn(o, "get", l));
      const { has: a } = m0(o), c = e ? o5 : n ? l5 : sr;
      if (a.call(o, i))
        return c(s.get(i));
      if (a.call(o, l))
        return c(s.get(l));
      s !== o && s.get(i);
    },
    get size() {
      const i = this.__v_raw;
      return !n && jn(yt(i), "iterate", fa), Reflect.get(i, "size", i);
    },
    has(i) {
      const s = this.__v_raw, o = yt(s), l = yt(i);
      return n || (sl(i, l) && jn(o, "has", i), jn(o, "has", l)), i === l ? s.has(i) : s.has(i) || s.has(l);
    },
    forEach(i, s) {
      const o = this, l = o.__v_raw, a = yt(l), c = e ? o5 : n ? l5 : sr;
      return !n && jn(a, "iterate", fa), l.forEach((u, h) => i.call(s, c(u), c(h), o));
    }
  };
  return Xn(
    t,
    n ? {
      add: g0("add"),
      set: g0("set"),
      delete: g0("delete"),
      clear: g0("clear")
    } : {
      add(i) {
        !e && !Li(i) && !Ea(i) && (i = yt(i));
        const s = yt(this);
        return m0(s).has.call(s, i) || (s.add(i), Xs(s, "add", i, i)), this;
      },
      set(i, s) {
        !e && !Li(s) && !Ea(s) && (s = yt(s));
        const o = yt(this), { has: l, get: a } = m0(o);
        let c = l.call(o, i);
        c || (i = yt(i), c = l.call(o, i));
        const u = a.call(o, i);
        return o.set(i, s), c ? sl(s, u) && Xs(o, "set", i, s) : Xs(o, "add", i, s), this;
      },
      delete(i) {
        const s = yt(this), { has: o, get: l } = m0(s);
        let a = o.call(s, i);
        a || (i = yt(i), a = o.call(s, i)), l && l.call(s, i);
        const c = s.delete(i);
        return a && Xs(s, "delete", i, void 0), c;
      },
      clear() {
        const i = yt(this), s = i.size !== 0, o = i.clear();
        return s && Xs(
          i,
          "clear",
          void 0,
          void 0
        ), o;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((i) => {
    t[i] = rJ(i, n, e);
  }), t;
}
function uv(n, e) {
  const t = iJ(n, e);
  return (r, i, s) => i === "__v_isReactive" ? !n : i === "__v_isReadonly" ? n : i === "__v_raw" ? r : Reflect.get(
    bt(t, i) && i in r ? t : r,
    i,
    s
  );
}
const sJ = {
  get: /* @__PURE__ */ uv(!1, !1)
}, oJ = {
  get: /* @__PURE__ */ uv(!1, !0)
}, lJ = {
  get: /* @__PURE__ */ uv(!0, !1)
};
const tE = /* @__PURE__ */ new WeakMap(), nE = /* @__PURE__ */ new WeakMap(), rE = /* @__PURE__ */ new WeakMap(), aJ = /* @__PURE__ */ new WeakMap();
function cJ(n) {
  switch (n) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function uJ(n) {
  return n.__v_skip || !Object.isExtensible(n) ? 0 : cJ(PY(n));
}
function hv(n) {
  return Ea(n) ? n : fv(
    n,
    !1,
    eJ,
    sJ,
    tE
  );
}
function hJ(n) {
  return fv(
    n,
    !1,
    nJ,
    oJ,
    nE
  );
}
function iE(n) {
  return fv(
    n,
    !0,
    tJ,
    lJ,
    rE
  );
}
function fv(n, e, t, r, i) {
  if (!un(n) || n.__v_raw && !(e && n.__v_isReactive))
    return n;
  const s = uJ(n);
  if (s === 0)
    return n;
  const o = i.get(n);
  if (o)
    return o;
  const l = new Proxy(
    n,
    s === 2 ? r : t
  );
  return i.set(n, l), l;
}
function af(n) {
  return Ea(n) ? af(n.__v_raw) : !!(n && n.__v_isReactive);
}
function Ea(n) {
  return !!(n && n.__v_isReadonly);
}
function Li(n) {
  return !!(n && n.__v_isShallow);
}
function dv(n) {
  return n ? !!n.__v_raw : !1;
}
function yt(n) {
  const e = n && n.__v_raw;
  return e ? yt(e) : n;
}
function fJ(n) {
  return !bt(n, "__v_skip") && Object.isExtensible(n) && jf(n, "__v_skip", !0), n;
}
const sr = (n) => un(n) ? hv(n) : n, l5 = (n) => un(n) ? iE(n) : n;
function Jn(n) {
  return n ? n.__v_isRef === !0 : !1;
}
function Ae(n) {
  return sE(n, !1);
}
function Am(n) {
  return sE(n, !0);
}
function sE(n, e) {
  return Jn(n) ? n : new dJ(n, e);
}
class dJ {
  constructor(e, t) {
    this.dep = new av(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : yt(e), this._value = t ? e : sr(e), this.__v_isShallow = t;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    const t = this._rawValue, r = this.__v_isShallow || Li(e) || Ea(e);
    e = r ? e : yt(e), sl(e, t) && (this._rawValue = e, this._value = r ? e : sr(e), this.dep.trigger());
  }
}
function pJ(n) {
  return Jn(n) ? n.value : n;
}
const mJ = {
  get: (n, e, t) => e === "__v_raw" ? n : pJ(Reflect.get(n, e, t)),
  set: (n, e, t, r) => {
    const i = n[e];
    return Jn(i) && !Jn(t) ? (i.value = t, !0) : Reflect.set(n, e, t, r);
  }
};
function oE(n) {
  return af(n) ? n : new Proxy(n, mJ);
}
class gJ {
  constructor(e, t, r) {
    this.fn = e, this.setter = t, this._value = void 0, this.dep = new av(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Uf - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !t, this.isSSR = r;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Pt !== this)
      return UO(this, !0), !0;
  }
  get value() {
    const e = this.dep.track();
    return YO(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
function yJ(n, e, t = !1) {
  let r, i;
  return tt(n) ? r = n : (r = n.get, i = n.set), new gJ(r, i, t);
}
const y0 = {}, Om = /* @__PURE__ */ new WeakMap();
let ql;
function bJ(n, e = !1, t = ql) {
  if (t) {
    let r = Om.get(t);
    r || Om.set(t, r = []), r.push(n);
  }
}
function vJ(n, e, t = _t) {
  const { immediate: r, deep: i, once: s, scheduler: o, augmentJob: l, call: a } = t, c = (C) => i ? C : Li(C) || i === !1 || i === 0 ? Uo(C, 1) : Uo(C);
  let u, h, f, d, p = !1, m = !1;
  if (Jn(n) ? (h = () => n.value, p = Li(n)) : af(n) ? (h = () => c(n), p = !0) : Ze(n) ? (m = !0, p = n.some((C) => af(C) || Li(C)), h = () => n.map((C) => {
    if (Jn(C))
      return C.value;
    if (af(C))
      return c(C);
    if (tt(C))
      return a ? a(C, 2) : C();
  })) : tt(n) ? e ? h = a ? () => a(n, 2) : n : h = () => {
    if (f) {
      ho();
      try {
        f();
      } finally {
        fo();
      }
    }
    const C = ql;
    ql = u;
    try {
      return a ? a(n, 3, [d]) : n(d);
    } finally {
      ql = C;
    }
  } : h = Pi, e && i) {
    const C = h, M = i === !0 ? 1 / 0 : i;
    h = () => Uo(C(), M);
  }
  const g = UY(), b = () => {
    u.stop(), g && g.active && tv(g.effects, u);
  };
  if (s && e) {
    const C = e;
    e = (...M) => {
      C(...M), b();
    };
  }
  let w = m ? new Array(n.length).fill(y0) : y0;
  const k = (C) => {
    if (!(!(u.flags & 1) || !u.dirty && !C))
      if (e) {
        const M = u.run();
        if (i || p || (m ? M.some((T, N) => sl(T, w[N])) : sl(M, w))) {
          f && f();
          const T = ql;
          ql = u;
          try {
            const N = [
              M,
              // pass undefined as the old value when it's changed for the first time
              w === y0 ? void 0 : m && w[0] === y0 ? [] : w,
              d
            ];
            w = M, a ? a(e, 3, N) : (
              // @ts-expect-error
              e(...N)
            );
          } finally {
            ql = T;
          }
        }
      } else
        u.run();
  };
  return l && l(k), u = new WO(h), u.scheduler = o ? () => o(k, !1) : k, d = (C) => bJ(C, !1, u), f = u.onStop = () => {
    const C = Om.get(u);
    if (C) {
      if (a)
        a(C, 4);
      else
        for (const M of C) M();
      Om.delete(u);
    }
  }, e ? r ? k(!0) : w = u.run() : o ? o(k.bind(null, !0), !0) : u.run(), b.pause = u.pause.bind(u), b.resume = u.resume.bind(u), b.stop = b, b;
}
function Uo(n, e = 1 / 0, t) {
  if (e <= 0 || !un(n) || n.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(n)))
    return n;
  if (t.add(n), e--, Jn(n))
    Uo(n.value, e, t);
  else if (Ze(n))
    for (let r = 0; r < n.length; r++)
      Uo(n[r], e, t);
  else if (NY(n) || rf(n))
    n.forEach((r) => {
      Uo(r, e, t);
    });
  else if (_Y(n)) {
    for (const r in n)
      Uo(n[r], e, t);
    for (const r of Object.getOwnPropertySymbols(n))
      Object.prototype.propertyIsEnumerable.call(n, r) && Uo(n[r], e, t);
  }
  return n;
}
/**
* @vue/runtime-core v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function xd(n, e, t, r) {
  try {
    return r ? n(...r) : n();
  } catch (i) {
    W1(i, e, t);
  }
}
function Ms(n, e, t, r) {
  if (tt(n)) {
    const i = xd(n, e, t, r);
    return i && $O(i) && i.catch((s) => {
      W1(s, e, t);
    }), i;
  }
  if (Ze(n)) {
    const i = [];
    for (let s = 0; s < n.length; s++)
      i.push(Ms(n[s], e, t, r));
    return i;
  }
}
function W1(n, e, t, r = !0) {
  const i = e ? e.vnode : null, { errorHandler: s, throwUnhandledErrorInProduction: o } = e && e.appContext.config || _t;
  if (e) {
    let l = e.parent;
    const a = e.proxy, c = `https://vuejs.org/error-reference/#runtime-${t}`;
    for (; l; ) {
      const u = l.ec;
      if (u) {
        for (let h = 0; h < u.length; h++)
          if (u[h](n, a, c) === !1)
            return;
      }
      l = l.parent;
    }
    if (s) {
      ho(), xd(s, null, 10, [
        n,
        a,
        c
      ]), fo();
      return;
    }
  }
  wJ(n, t, i, r, o);
}
function wJ(n, e, t, r = !0, i = !1) {
  if (i)
    throw n;
  console.error(n);
}
const or = [];
let ns = -1;
const Cc = [];
let $o = null, ic = 0;
const lE = /* @__PURE__ */ Promise.resolve();
let Em = null;
function xJ(n) {
  const e = Em || lE;
  return n ? e.then(this ? n.bind(this) : n) : e;
}
function kJ(n) {
  let e = ns + 1, t = or.length;
  for (; e < t; ) {
    const r = e + t >>> 1, i = or[r], s = Gf(i);
    s < n || s === n && i.flags & 2 ? e = r + 1 : t = r;
  }
  return e;
}
function pv(n) {
  if (!(n.flags & 1)) {
    const e = Gf(n), t = or[or.length - 1];
    !t || // fast path when the job id is larger than the tail
    !(n.flags & 2) && e >= Gf(t) ? or.push(n) : or.splice(kJ(e), 0, n), n.flags |= 1, aE();
  }
}
function aE() {
  Em || (Em = lE.then(uE));
}
function SJ(n) {
  Ze(n) ? Cc.push(...n) : $o && n.id === -1 ? $o.splice(ic + 1, 0, n) : n.flags & 1 || (Cc.push(n), n.flags |= 1), aE();
}
function M8(n, e, t = ns + 1) {
  for (; t < or.length; t++) {
    const r = or[t];
    if (r && r.flags & 2) {
      if (n && r.id !== n.uid)
        continue;
      or.splice(t, 1), t--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2);
    }
  }
}
function cE(n) {
  if (Cc.length) {
    const e = [...new Set(Cc)].sort(
      (t, r) => Gf(t) - Gf(r)
    );
    if (Cc.length = 0, $o) {
      $o.push(...e);
      return;
    }
    for ($o = e, ic = 0; ic < $o.length; ic++) {
      const t = $o[ic];
      t.flags & 4 && (t.flags &= -2), t.flags & 8 || t(), t.flags &= -2;
    }
    $o = null, ic = 0;
  }
}
const Gf = (n) => n.id == null ? n.flags & 2 ? -1 : 1 / 0 : n.id;
function uE(n) {
  try {
    for (ns = 0; ns < or.length; ns++) {
      const e = or[ns];
      e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), xd(
        e,
        e.i,
        e.i ? 15 : 14
      ), e.flags & 4 || (e.flags &= -2));
    }
  } finally {
    for (; ns < or.length; ns++) {
      const e = or[ns];
      e && (e.flags &= -2);
    }
    ns = -1, or.length = 0, cE(), Em = null, (or.length || Cc.length) && uE();
  }
}
let cs, mh = [], a5 = !1;
function j1(n, ...e) {
  cs ? cs.emit(n, ...e) : a5 || mh.push({ event: n, args: e });
}
function hE(n, e) {
  var t, r;
  cs = n, cs ? (cs.enabled = !0, mh.forEach(({ event: i, args: s }) => cs.emit(i, ...s)), mh = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((r = (t = window.navigator) == null ? void 0 : t.userAgent) != null && r.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {
    hE(s, e);
  }), setTimeout(() => {
    cs || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, a5 = !0, mh = []);
  }, 3e3)) : (a5 = !0, mh = []);
}
function CJ(n, e) {
  j1("app:init", n, e, {
    Fragment: Ln,
    Text: Cd,
    Comment: Ia,
    Static: xp
  });
}
function MJ(n) {
  j1("app:unmount", n);
}
const TJ = /* @__PURE__ */ mv(
  "component:added"
  /* COMPONENT_ADDED */
), fE = /* @__PURE__ */ mv(
  "component:updated"
  /* COMPONENT_UPDATED */
), AJ = /* @__PURE__ */ mv(
  "component:removed"
  /* COMPONENT_REMOVED */
), OJ = (n) => {
  cs && typeof cs.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !cs.cleanupBuffer(n) && AJ(n);
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function mv(n) {
  return (e) => {
    j1(
      n,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
function EJ(n, e, t) {
  j1(
    "component:emit",
    n.appContext.app,
    n,
    e,
    t
  );
}
let ds = null, dE = null;
function Im(n) {
  const e = ds;
  return ds = n, dE = n && n.type.__scopeId || null, e;
}
function IJ(n, e = ds, t) {
  if (!e || n._n)
    return n;
  const r = (...i) => {
    r._d && P8(-1);
    const s = Im(e);
    let o;
    try {
      o = n(...i);
    } finally {
      Im(s), r._d && P8(1);
    }
    return __VUE_PROD_DEVTOOLS__ && fE(e), o;
  };
  return r._n = !0, r._c = !0, r._d = !0, r;
}
function Rl(n, e, t, r) {
  const i = n.dirs, s = e && e.dirs;
  for (let o = 0; o < i.length; o++) {
    const l = i[o];
    s && (l.oldValue = s[o].value);
    let a = l.dir[r];
    a && (ho(), Ms(a, t, 8, [
      n.el,
      l,
      n,
      e
    ]), fo());
  }
}
const DJ = Symbol("_vte"), NJ = (n) => n.__isTeleport;
function gv(n, e) {
  n.shapeFlag & 6 && n.component ? (n.transition = e, gv(n.component.subTree, e)) : n.shapeFlag & 128 ? (n.ssContent.transition = e.clone(n.ssContent), n.ssFallback.transition = e.clone(n.ssFallback)) : n.transition = e;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function $n(n, e) {
  return tt(n) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Xn({ name: n.name }, e, { setup: n })
  ) : n;
}
function pE(n) {
  n.ids = [n.ids[0] + n.ids[2]++ + "-", 0, 0];
}
function cf(n, e, t, r, i = !1) {
  if (Ze(n)) {
    n.forEach(
      (p, m) => cf(
        p,
        e && (Ze(e) ? e[m] : e),
        t,
        r,
        i
      )
    );
    return;
  }
  if (uf(r) && !i) {
    r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && cf(n, e, t, r.component.subTree);
    return;
  }
  const s = r.shapeFlag & 4 ? kv(r.component) : r.el, o = i ? null : s, { i: l, r: a } = n, c = e && e.r, u = l.refs === _t ? l.refs = {} : l.refs, h = l.setupState, f = yt(h), d = h === _t ? () => !1 : (p) => bt(f, p);
  if (c != null && c !== a && (An(c) ? (u[c] = null, d(c) && (h[c] = null)) : Jn(c) && (c.value = null)), tt(a))
    xd(a, l, 12, [o, u]);
  else {
    const p = An(a), m = Jn(a);
    if (p || m) {
      const g = () => {
        if (n.f) {
          const b = p ? d(a) ? h[a] : u[a] : a.value;
          i ? Ze(b) && tv(b, s) : Ze(b) ? b.includes(s) || b.push(s) : p ? (u[a] = [s], d(a) && (h[a] = u[a])) : (a.value = [s], n.k && (u[n.k] = a.value));
        } else p ? (u[a] = o, d(a) && (h[a] = o)) : m && (a.value = o, n.k && (u[n.k] = o));
      };
      o ? (g.id = -1, Vr(g, t)) : g();
    }
  }
}
ha().requestIdleCallback;
ha().cancelIdleCallback;
const uf = (n) => !!n.type.__asyncLoader, mE = (n) => n.type.__isKeepAlive;
function RJ(n, e) {
  gE(n, "a", e);
}
function PJ(n, e) {
  gE(n, "da", e);
}
function gE(n, e, t = ar) {
  const r = n.__wdc || (n.__wdc = () => {
    let i = t;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return n();
  });
  if (U1(e, r, t), t) {
    let i = t.parent;
    for (; i && i.parent; )
      mE(i.parent.vnode) && _J(r, e, t, i), i = i.parent;
  }
}
function _J(n, e, t, r) {
  const i = U1(
    e,
    n,
    r,
    !0
    /* prepend */
  );
  Sd(() => {
    tv(r[e], i);
  }, t);
}
function U1(n, e, t = ar, r = !1) {
  if (t) {
    const i = t[n] || (t[n] = []), s = e.__weh || (e.__weh = (...o) => {
      ho();
      const l = Md(t), a = Ms(e, t, n, o);
      return l(), fo(), a;
    });
    return r ? i.unshift(s) : i.push(s), s;
  }
}
const So = (n) => (e, t = ar) => {
  (!Yf || n === "sp") && U1(n, (...r) => e(...r), t);
}, LJ = So("bm"), kd = So("m"), BJ = So(
  "bu"
), zJ = So("u"), FJ = So(
  "bum"
), Sd = So("um"), HJ = So(
  "sp"
), $J = So("rtg"), VJ = So("rtc");
function qJ(n, e = ar) {
  U1("ec", n, e);
}
const WJ = Symbol.for("v-ndc"), c5 = (n) => n ? PE(n) ? kv(n) : c5(n.parent) : null, hf = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Xn(/* @__PURE__ */ Object.create(null), {
    $: (n) => n,
    $el: (n) => n.vnode.el,
    $data: (n) => n.data,
    $props: (n) => n.props,
    $attrs: (n) => n.attrs,
    $slots: (n) => n.slots,
    $refs: (n) => n.refs,
    $parent: (n) => c5(n.parent),
    $root: (n) => c5(n.root),
    $host: (n) => n.ce,
    $emit: (n) => n.emit,
    $options: (n) => __VUE_OPTIONS_API__ ? bE(n) : n.type,
    $forceUpdate: (n) => n.f || (n.f = () => {
      pv(n.update);
    }),
    $nextTick: (n) => n.n || (n.n = xJ.bind(n.proxy)),
    $watch: (n) => __VUE_OPTIONS_API__ ? dX.bind(n) : Pi
  })
), P2 = (n, e) => n !== _t && !n.__isScriptSetup && bt(n, e), jJ = {
  get({ _: n }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: t, setupState: r, data: i, props: s, accessCache: o, type: l, appContext: a } = n;
    let c;
    if (e[0] !== "$") {
      const d = o[e];
      if (d !== void 0)
        switch (d) {
          case 1:
            return r[e];
          case 2:
            return i[e];
          case 4:
            return t[e];
          case 3:
            return s[e];
        }
      else {
        if (P2(r, e))
          return o[e] = 1, r[e];
        if (i !== _t && bt(i, e))
          return o[e] = 2, i[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (c = n.propsOptions[0]) && bt(c, e)
        )
          return o[e] = 3, s[e];
        if (t !== _t && bt(t, e))
          return o[e] = 4, t[e];
        (!__VUE_OPTIONS_API__ || u5) && (o[e] = 0);
      }
    }
    const u = hf[e];
    let h, f;
    if (u)
      return e === "$attrs" && jn(n.attrs, "get", ""), u(n);
    if (
      // css module (injected by vue-loader)
      (h = l.__cssModules) && (h = h[e])
    )
      return h;
    if (t !== _t && bt(t, e))
      return o[e] = 4, t[e];
    if (
      // global properties
      f = a.config.globalProperties, bt(f, e)
    )
      return f[e];
  },
  set({ _: n }, e, t) {
    const { data: r, setupState: i, ctx: s } = n;
    return P2(i, e) ? (i[e] = t, !0) : r !== _t && bt(r, e) ? (r[e] = t, !0) : bt(n.props, e) || e[0] === "$" && e.slice(1) in n ? !1 : (s[e] = t, !0);
  },
  has({
    _: { data: n, setupState: e, accessCache: t, ctx: r, appContext: i, propsOptions: s }
  }, o) {
    let l;
    return !!t[o] || n !== _t && bt(n, o) || P2(e, o) || (l = s[0]) && bt(l, o) || bt(r, o) || bt(hf, o) || bt(i.config.globalProperties, o);
  },
  defineProperty(n, e, t) {
    return t.get != null ? n._.accessCache[e] = 0 : bt(t, "value") && this.set(n, e, t.value, null), Reflect.defineProperty(n, e, t);
  }
};
function T8(n) {
  return Ze(n) ? n.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : n;
}
let u5 = !0;
function UJ(n) {
  const e = bE(n), t = n.proxy, r = n.ctx;
  u5 = !1, e.beforeCreate && A8(e.beforeCreate, n, "bc");
  const {
    // state
    data: i,
    computed: s,
    methods: o,
    watch: l,
    provide: a,
    inject: c,
    // lifecycle
    created: u,
    beforeMount: h,
    mounted: f,
    beforeUpdate: d,
    updated: p,
    activated: m,
    deactivated: g,
    beforeDestroy: b,
    beforeUnmount: w,
    destroyed: k,
    unmounted: C,
    render: M,
    renderTracked: T,
    renderTriggered: N,
    errorCaptured: B,
    serverPrefetch: $,
    // public API
    expose: R,
    inheritAttrs: V,
    // assets
    components: z,
    directives: ue,
    filters: ie
  } = e;
  if (c && KJ(c, r, null), o)
    for (const ge in o) {
      const ye = o[ge];
      tt(ye) && (r[ge] = ye.bind(t));
    }
  if (i) {
    const ge = i.call(t, t);
    un(ge) && (n.data = hv(ge));
  }
  if (u5 = !0, s)
    for (const ge in s) {
      const ye = s[ge], ze = tt(ye) ? ye.bind(t, t) : tt(ye.get) ? ye.get.bind(t, t) : Pi, I = !tt(ye) && tt(ye.set) ? ye.set.bind(t) : Pi, Ie = Da({
        get: ze,
        set: I
      });
      Object.defineProperty(r, ge, {
        enumerable: !0,
        configurable: !0,
        get: () => Ie.value,
        set: (Ve) => Ie.value = Ve
      });
    }
  if (l)
    for (const ge in l)
      yE(l[ge], r, t, ge);
  if (a) {
    const ge = tt(a) ? a.call(t) : a;
    Reflect.ownKeys(ge).forEach((ye) => {
      QJ(ye, ge[ye]);
    });
  }
  u && A8(u, n, "c");
  function Se(ge, ye) {
    Ze(ye) ? ye.forEach((ze) => ge(ze.bind(t))) : ye && ge(ye.bind(t));
  }
  if (Se(LJ, h), Se(kd, f), Se(BJ, d), Se(zJ, p), Se(RJ, m), Se(PJ, g), Se(qJ, B), Se(VJ, T), Se($J, N), Se(FJ, w), Se(Sd, C), Se(HJ, $), Ze(R))
    if (R.length) {
      const ge = n.exposed || (n.exposed = {});
      R.forEach((ye) => {
        Object.defineProperty(ge, ye, {
          get: () => t[ye],
          set: (ze) => t[ye] = ze,
          enumerable: !0
        });
      });
    } else n.exposed || (n.exposed = {});
  M && n.render === Pi && (n.render = M), V != null && (n.inheritAttrs = V), z && (n.components = z), ue && (n.directives = ue), $ && pE(n);
}
function KJ(n, e, t = Pi) {
  Ze(n) && (n = h5(n));
  for (const r in n) {
    const i = n[r];
    let s;
    un(i) ? "default" in i ? s = wp(
      i.from || r,
      i.default,
      !0
    ) : s = wp(i.from || r) : s = wp(i), Jn(s) ? Object.defineProperty(e, r, {
      enumerable: !0,
      configurable: !0,
      get: () => s.value,
      set: (o) => s.value = o
    }) : e[r] = s;
  }
}
function A8(n, e, t) {
  Ms(
    Ze(n) ? n.map((r) => r.bind(e.proxy)) : n.bind(e.proxy),
    e,
    t
  );
}
function yE(n, e, t, r) {
  let i = r.includes(".") ? IE(t, r) : () => t[r];
  if (An(n)) {
    const s = e[n];
    tt(s) && Tc(i, s);
  } else if (tt(n))
    Tc(i, n.bind(t));
  else if (un(n))
    if (Ze(n))
      n.forEach((s) => yE(s, e, t, r));
    else {
      const s = tt(n.handler) ? n.handler.bind(t) : e[n.handler];
      tt(s) && Tc(i, s, n);
    }
}
function bE(n) {
  const e = n.type, { mixins: t, extends: r } = e, {
    mixins: i,
    optionsCache: s,
    config: { optionMergeStrategies: o }
  } = n.appContext, l = s.get(e);
  let a;
  return l ? a = l : !i.length && !t && !r ? a = e : (a = {}, i.length && i.forEach(
    (c) => Dm(a, c, o, !0)
  ), Dm(a, e, o)), un(e) && s.set(e, a), a;
}
function Dm(n, e, t, r = !1) {
  const { mixins: i, extends: s } = e;
  s && Dm(n, s, t, !0), i && i.forEach(
    (o) => Dm(n, o, t, !0)
  );
  for (const o in e)
    if (!(r && o === "expose")) {
      const l = GJ[o] || t && t[o];
      n[o] = l ? l(n[o], e[o]) : e[o];
    }
  return n;
}
const GJ = {
  data: O8,
  props: E8,
  emits: E8,
  // objects
  methods: gh,
  computed: gh,
  // lifecycle
  beforeCreate: ir,
  created: ir,
  beforeMount: ir,
  mounted: ir,
  beforeUpdate: ir,
  updated: ir,
  beforeDestroy: ir,
  beforeUnmount: ir,
  destroyed: ir,
  unmounted: ir,
  activated: ir,
  deactivated: ir,
  errorCaptured: ir,
  serverPrefetch: ir,
  // assets
  components: gh,
  directives: gh,
  // watch
  watch: JJ,
  // provide / inject
  provide: O8,
  inject: YJ
};
function O8(n, e) {
  return e ? n ? function() {
    return Xn(
      tt(n) ? n.call(this, this) : n,
      tt(e) ? e.call(this, this) : e
    );
  } : e : n;
}
function YJ(n, e) {
  return gh(h5(n), h5(e));
}
function h5(n) {
  if (Ze(n)) {
    const e = {};
    for (let t = 0; t < n.length; t++)
      e[n[t]] = n[t];
    return e;
  }
  return n;
}
function ir(n, e) {
  return n ? [...new Set([].concat(n, e))] : e;
}
function gh(n, e) {
  return n ? Xn(/* @__PURE__ */ Object.create(null), n, e) : e;
}
function E8(n, e) {
  return n ? Ze(n) && Ze(e) ? [.../* @__PURE__ */ new Set([...n, ...e])] : Xn(
    /* @__PURE__ */ Object.create(null),
    T8(n),
    T8(e ?? {})
  ) : e;
}
function JJ(n, e) {
  if (!n) return e;
  if (!e) return n;
  const t = Xn(/* @__PURE__ */ Object.create(null), n);
  for (const r in e)
    t[r] = ir(n[r], e[r]);
  return t;
}
function vE() {
  return {
    app: null,
    config: {
      isNativeTag: IY,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let XJ = 0;
function ZJ(n, e) {
  return function(r, i = null) {
    tt(r) || (r = Xn({}, r)), i != null && !un(i) && (i = null);
    const s = vE(), o = /* @__PURE__ */ new WeakSet(), l = [];
    let a = !1;
    const c = s.app = {
      _uid: XJ++,
      _component: r,
      _props: i,
      _container: null,
      _context: s,
      _instance: null,
      version: B8,
      get config() {
        return s.config;
      },
      set config(u) {
      },
      use(u, ...h) {
        return o.has(u) || (u && tt(u.install) ? (o.add(u), u.install(c, ...h)) : tt(u) && (o.add(u), u(c, ...h))), c;
      },
      mixin(u) {
        return __VUE_OPTIONS_API__ && (s.mixins.includes(u) || s.mixins.push(u)), c;
      },
      component(u, h) {
        return h ? (s.components[u] = h, c) : s.components[u];
      },
      directive(u, h) {
        return h ? (s.directives[u] = h, c) : s.directives[u];
      },
      mount(u, h, f) {
        if (!a) {
          const d = c._ceVNode || Di(r, i);
          return d.appContext = s, f === !0 ? f = "svg" : f === !1 && (f = void 0), n(d, u, f), a = !0, c._container = u, u.__vue_app__ = c, __VUE_PROD_DEVTOOLS__ && (c._instance = d.component, CJ(c, B8)), kv(d.component);
        }
      },
      onUnmount(u) {
        l.push(u);
      },
      unmount() {
        a && (Ms(
          l,
          c._instance,
          16
        ), n(null, c._container), __VUE_PROD_DEVTOOLS__ && (c._instance = null, MJ(c)), delete c._container.__vue_app__);
      },
      provide(u, h) {
        return s.provides[u] = h, c;
      },
      runWithContext(u) {
        const h = Mc;
        Mc = c;
        try {
          return u();
        } finally {
          Mc = h;
        }
      }
    };
    return c;
  };
}
let Mc = null;
function QJ(n, e) {
  if (ar) {
    let t = ar.provides;
    const r = ar.parent && ar.parent.provides;
    r === t && (t = ar.provides = Object.create(r)), t[n] = e;
  }
}
function wp(n, e, t = !1) {
  const r = EX();
  if (r || Mc) {
    let i = Mc ? Mc._context.provides : r ? r.parent == null || r.ce ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
    if (i && n in i)
      return i[n];
    if (arguments.length > 1)
      return t && tt(e) ? e.call(r && r.proxy) : e;
  }
}
const wE = {}, xE = () => Object.create(wE), kE = (n) => Object.getPrototypeOf(n) === wE;
function eX(n, e, t, r = !1) {
  const i = {}, s = xE();
  n.propsDefaults = /* @__PURE__ */ Object.create(null), SE(n, e, i, s);
  for (const o in n.propsOptions[0])
    o in i || (i[o] = void 0);
  t ? n.props = r ? i : hJ(i) : n.type.props ? n.props = i : n.props = s, n.attrs = s;
}
function tX(n, e, t, r) {
  const {
    props: i,
    attrs: s,
    vnode: { patchFlag: o }
  } = n, l = yt(i), [a] = n.propsOptions;
  let c = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (r || o > 0) && !(o & 16)
  ) {
    if (o & 8) {
      const u = n.vnode.dynamicProps;
      for (let h = 0; h < u.length; h++) {
        let f = u[h];
        if (K1(n.emitsOptions, f))
          continue;
        const d = e[f];
        if (a)
          if (bt(s, f))
            d !== s[f] && (s[f] = d, c = !0);
          else {
            const p = gl(f);
            i[p] = f5(
              a,
              l,
              p,
              d,
              n,
              !1
            );
          }
        else
          d !== s[f] && (s[f] = d, c = !0);
      }
    }
  } else {
    SE(n, e, i, s) && (c = !0);
    let u;
    for (const h in l)
      (!e || // for camelCase
      !bt(e, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((u = Fa(h)) === h || !bt(e, u))) && (a ? t && // for camelCase
      (t[h] !== void 0 || // for kebab-case
      t[u] !== void 0) && (i[h] = f5(
        a,
        l,
        h,
        void 0,
        n,
        !0
      )) : delete i[h]);
    if (s !== l)
      for (const h in s)
        (!e || !bt(e, h)) && (delete s[h], c = !0);
  }
  c && Xs(n.attrs, "set", "");
}
function SE(n, e, t, r) {
  const [i, s] = n.propsOptions;
  let o = !1, l;
  if (e)
    for (let a in e) {
      if (sf(a))
        continue;
      const c = e[a];
      let u;
      i && bt(i, u = gl(a)) ? !s || !s.includes(u) ? t[u] = c : (l || (l = {}))[u] = c : K1(n.emitsOptions, a) || (!(a in r) || c !== r[a]) && (r[a] = c, o = !0);
    }
  if (s) {
    const a = yt(t), c = l || _t;
    for (let u = 0; u < s.length; u++) {
      const h = s[u];
      t[h] = f5(
        i,
        a,
        h,
        c[h],
        n,
        !bt(c, h)
      );
    }
  }
  return o;
}
function f5(n, e, t, r, i, s) {
  const o = n[t];
  if (o != null) {
    const l = bt(o, "default");
    if (l && r === void 0) {
      const a = o.default;
      if (o.type !== Function && !o.skipFactory && tt(a)) {
        const { propsDefaults: c } = i;
        if (t in c)
          r = c[t];
        else {
          const u = Md(i);
          r = c[t] = a.call(
            null,
            e
          ), u();
        }
      } else
        r = a;
      i.ce && i.ce._setProp(t, r);
    }
    o[
      0
      /* shouldCast */
    ] && (s && !l ? r = !1 : o[
      1
      /* shouldCastTrue */
    ] && (r === "" || r === Fa(t)) && (r = !0));
  }
  return r;
}
const nX = /* @__PURE__ */ new WeakMap();
function CE(n, e, t = !1) {
  const r = __VUE_OPTIONS_API__ && t ? nX : e.propsCache, i = r.get(n);
  if (i)
    return i;
  const s = n.props, o = {}, l = [];
  let a = !1;
  if (__VUE_OPTIONS_API__ && !tt(n)) {
    const u = (h) => {
      a = !0;
      const [f, d] = CE(h, e, !0);
      Xn(o, f), d && l.push(...d);
    };
    !t && e.mixins.length && e.mixins.forEach(u), n.extends && u(n.extends), n.mixins && n.mixins.forEach(u);
  }
  if (!s && !a)
    return un(n) && r.set(n, nf), nf;
  if (Ze(s))
    for (let u = 0; u < s.length; u++) {
      const h = gl(s[u]);
      I8(h) && (o[h] = _t);
    }
  else if (s)
    for (const u in s) {
      const h = gl(u);
      if (I8(h)) {
        const f = s[u], d = o[h] = Ze(f) || tt(f) ? { type: f } : Xn({}, f), p = d.type;
        let m = !1, g = !0;
        if (Ze(p))
          for (let b = 0; b < p.length; ++b) {
            const w = p[b], k = tt(w) && w.name;
            if (k === "Boolean") {
              m = !0;
              break;
            } else k === "String" && (g = !1);
          }
        else
          m = tt(p) && p.name === "Boolean";
        d[
          0
          /* shouldCast */
        ] = m, d[
          1
          /* shouldCastTrue */
        ] = g, (m || bt(d, "default")) && l.push(h);
      }
    }
  const c = [o, l];
  return un(n) && r.set(n, c), c;
}
function I8(n) {
  return n[0] !== "$" && !sf(n);
}
const yv = (n) => n === "_" || n === "__" || n === "_ctx" || n === "$stable", bv = (n) => Ze(n) ? n.map(is) : [is(n)], rX = (n, e, t) => {
  if (e._n)
    return e;
  const r = IJ((...i) => bv(e(...i)), t);
  return r._c = !1, r;
}, ME = (n, e, t) => {
  const r = n._ctx;
  for (const i in n) {
    if (yv(i)) continue;
    const s = n[i];
    if (tt(s))
      e[i] = rX(i, s, r);
    else if (s != null) {
      const o = bv(s);
      e[i] = () => o;
    }
  }
}, TE = (n, e) => {
  const t = bv(e);
  n.slots.default = () => t;
}, AE = (n, e, t) => {
  for (const r in e)
    (t || !yv(r)) && (n[r] = e[r]);
}, iX = (n, e, t) => {
  const r = n.slots = xE();
  if (n.vnode.shapeFlag & 32) {
    const i = e.__;
    i && jf(r, "__", i, !0);
    const s = e._;
    s ? (AE(r, e, t), t && jf(r, "_", s, !0)) : ME(e, r);
  } else e && TE(n, e);
}, sX = (n, e, t) => {
  const { vnode: r, slots: i } = n;
  let s = !0, o = _t;
  if (r.shapeFlag & 32) {
    const l = e._;
    l ? t && l === 1 ? s = !1 : AE(i, e, t) : (s = !e.$stable, ME(e, i)), o = e;
  } else e && (TE(n, e), o = { default: 1 });
  if (s)
    for (const l in i)
      !yv(l) && o[l] == null && delete i[l];
};
function oX() {
  typeof __VUE_OPTIONS_API__ != "boolean" && (ha().__VUE_OPTIONS_API__ = !0), typeof __VUE_PROD_DEVTOOLS__ != "boolean" && (ha().__VUE_PROD_DEVTOOLS__ = !1), typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" && (ha().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1);
}
const Vr = wX;
function lX(n) {
  return aX(n);
}
function aX(n, e) {
  oX();
  const t = ha();
  t.__VUE__ = !0, __VUE_PROD_DEVTOOLS__ && hE(t.__VUE_DEVTOOLS_GLOBAL_HOOK__, t);
  const {
    insert: r,
    remove: i,
    patchProp: s,
    createElement: o,
    createText: l,
    createComment: a,
    setText: c,
    setElementText: u,
    parentNode: h,
    nextSibling: f,
    setScopeId: d = Pi,
    insertStaticContent: p
  } = n, m = (E, P, W, Q = null, J = null, Y = null, ae = void 0, re = null, oe = !!P.dynamicChildren) => {
    if (E === P)
      return;
    E && !$u(E, P) && (Q = Ct(E), Ve(E, J, Y, !0), E = null), P.patchFlag === -2 && (oe = !1, P.dynamicChildren = null);
    const { type: te, ref: De, shapeFlag: de } = P;
    switch (te) {
      case Cd:
        g(E, P, W, Q);
        break;
      case Ia:
        b(E, P, W, Q);
        break;
      case xp:
        E == null && w(P, W, Q, ae);
        break;
      case Ln:
        z(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        );
        break;
      default:
        de & 1 ? M(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        ) : de & 6 ? ue(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        ) : (de & 64 || de & 128) && te.process(
          E,
          P,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe,
          Gt
        );
    }
    De != null && J ? cf(De, E && E.ref, Y, P || E, !P) : De == null && E && E.ref != null && cf(E.ref, null, Y, E, !0);
  }, g = (E, P, W, Q) => {
    if (E == null)
      r(
        P.el = l(P.children),
        W,
        Q
      );
    else {
      const J = P.el = E.el;
      P.children !== E.children && c(J, P.children);
    }
  }, b = (E, P, W, Q) => {
    E == null ? r(
      P.el = a(P.children || ""),
      W,
      Q
    ) : P.el = E.el;
  }, w = (E, P, W, Q) => {
    [E.el, E.anchor] = p(
      E.children,
      P,
      W,
      Q,
      E.el,
      E.anchor
    );
  }, k = ({ el: E, anchor: P }, W, Q) => {
    let J;
    for (; E && E !== P; )
      J = f(E), r(E, W, Q), E = J;
    r(P, W, Q);
  }, C = ({ el: E, anchor: P }) => {
    let W;
    for (; E && E !== P; )
      W = f(E), i(E), E = W;
    i(P);
  }, M = (E, P, W, Q, J, Y, ae, re, oe) => {
    P.type === "svg" ? ae = "svg" : P.type === "math" && (ae = "mathml"), E == null ? T(
      P,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe
    ) : $(
      E,
      P,
      J,
      Y,
      ae,
      re,
      oe
    );
  }, T = (E, P, W, Q, J, Y, ae, re) => {
    let oe, te;
    const { props: De, shapeFlag: de, transition: Te, dirs: Pe } = E;
    if (oe = E.el = o(
      E.type,
      Y,
      De && De.is,
      De
    ), de & 8 ? u(oe, E.children) : de & 16 && B(
      E.children,
      oe,
      null,
      Q,
      J,
      _2(E, Y),
      ae,
      re
    ), Pe && Rl(E, null, Q, "created"), N(oe, E, E.scopeId, ae, Q), De) {
      for (const X in De)
        X !== "value" && !sf(X) && s(oe, X, null, De[X], Y, Q);
      "value" in De && s(oe, "value", null, De.value, Y), (te = De.onVnodeBeforeMount) && Xi(te, Q, E);
    }
    __VUE_PROD_DEVTOOLS__ && (jf(oe, "__vnode", E, !0), jf(oe, "__vueParentComponent", Q, !0)), Pe && Rl(E, null, Q, "beforeMount");
    const F = cX(J, Te);
    F && Te.beforeEnter(oe), r(oe, P, W), ((te = De && De.onVnodeMounted) || F || Pe) && Vr(() => {
      te && Xi(te, Q, E), F && Te.enter(oe), Pe && Rl(E, null, Q, "mounted");
    }, J);
  }, N = (E, P, W, Q, J) => {
    if (W && d(E, W), Q)
      for (let Y = 0; Y < Q.length; Y++)
        d(E, Q[Y]);
    if (J) {
      let Y = J.subTree;
      if (P === Y || NE(Y.type) && (Y.ssContent === P || Y.ssFallback === P)) {
        const ae = J.vnode;
        N(
          E,
          ae,
          ae.scopeId,
          ae.slotScopeIds,
          J.parent
        );
      }
    }
  }, B = (E, P, W, Q, J, Y, ae, re, oe = 0) => {
    for (let te = oe; te < E.length; te++) {
      const De = E[te] = re ? Vo(E[te]) : is(E[te]);
      m(
        null,
        De,
        P,
        W,
        Q,
        J,
        Y,
        ae,
        re
      );
    }
  }, $ = (E, P, W, Q, J, Y, ae) => {
    const re = P.el = E.el;
    __VUE_PROD_DEVTOOLS__ && (re.__vnode = P);
    let { patchFlag: oe, dynamicChildren: te, dirs: De } = P;
    oe |= E.patchFlag & 16;
    const de = E.props || _t, Te = P.props || _t;
    let Pe;
    if (W && Pl(W, !1), (Pe = Te.onVnodeBeforeUpdate) && Xi(Pe, W, P, E), De && Rl(P, E, W, "beforeUpdate"), W && Pl(W, !0), (de.innerHTML && Te.innerHTML == null || de.textContent && Te.textContent == null) && u(re, ""), te ? R(
      E.dynamicChildren,
      te,
      re,
      W,
      Q,
      _2(P, J),
      Y
    ) : ae || ye(
      E,
      P,
      re,
      null,
      W,
      Q,
      _2(P, J),
      Y,
      !1
    ), oe > 0) {
      if (oe & 16)
        V(re, de, Te, W, J);
      else if (oe & 2 && de.class !== Te.class && s(re, "class", null, Te.class, J), oe & 4 && s(re, "style", de.style, Te.style, J), oe & 8) {
        const F = P.dynamicProps;
        for (let X = 0; X < F.length; X++) {
          const pe = F[X], _e = de[pe], je = Te[pe];
          (je !== _e || pe === "value") && s(re, pe, _e, je, J, W);
        }
      }
      oe & 1 && E.children !== P.children && u(re, P.children);
    } else !ae && te == null && V(re, de, Te, W, J);
    ((Pe = Te.onVnodeUpdated) || De) && Vr(() => {
      Pe && Xi(Pe, W, P, E), De && Rl(P, E, W, "updated");
    }, Q);
  }, R = (E, P, W, Q, J, Y, ae) => {
    for (let re = 0; re < P.length; re++) {
      const oe = E[re], te = P[re], De = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oe.type === Ln || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !$u(oe, te) || // - In the case of a component, it could contain anything.
        oe.shapeFlag & 198) ? h(oe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          W
        )
      );
      m(
        oe,
        te,
        De,
        null,
        Q,
        J,
        Y,
        ae,
        !0
      );
    }
  }, V = (E, P, W, Q, J) => {
    if (P !== W) {
      if (P !== _t)
        for (const Y in P)
          !sf(Y) && !(Y in W) && s(
            E,
            Y,
            P[Y],
            null,
            J,
            Q
          );
      for (const Y in W) {
        if (sf(Y)) continue;
        const ae = W[Y], re = P[Y];
        ae !== re && Y !== "value" && s(E, Y, re, ae, J, Q);
      }
      "value" in W && s(E, "value", P.value, W.value, J);
    }
  }, z = (E, P, W, Q, J, Y, ae, re, oe) => {
    const te = P.el = E ? E.el : l(""), De = P.anchor = E ? E.anchor : l("");
    let { patchFlag: de, dynamicChildren: Te, slotScopeIds: Pe } = P;
    Pe && (re = re ? re.concat(Pe) : Pe), E == null ? (r(te, W, Q), r(De, W, Q), B(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      P.children || [],
      W,
      De,
      J,
      Y,
      ae,
      re,
      oe
    )) : de > 0 && de & 64 && Te && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    E.dynamicChildren ? (R(
      E.dynamicChildren,
      Te,
      W,
      J,
      Y,
      ae,
      re
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (P.key != null || J && P === J.subTree) && OE(
      E,
      P,
      !0
      /* shallow */
    )) : ye(
      E,
      P,
      W,
      De,
      J,
      Y,
      ae,
      re,
      oe
    );
  }, ue = (E, P, W, Q, J, Y, ae, re, oe) => {
    P.slotScopeIds = re, E == null ? P.shapeFlag & 512 ? J.ctx.activate(
      P,
      W,
      Q,
      ae,
      oe
    ) : ie(
      P,
      W,
      Q,
      J,
      Y,
      ae,
      oe
    ) : he(E, P, oe);
  }, ie = (E, P, W, Q, J, Y, ae) => {
    const re = E.component = OX(
      E,
      Q,
      J
    );
    if (mE(E) && (re.ctx.renderer = Gt), IX(re, !1, ae), re.asyncDep) {
      if (J && J.registerDep(re, Se, ae), !E.el) {
        const oe = re.subTree = Di(Ia);
        b(null, oe, P, W), E.placeholder = oe.el;
      }
    } else
      Se(
        re,
        E,
        P,
        W,
        J,
        Y,
        ae
      );
  }, he = (E, P, W) => {
    const Q = P.component = E.component;
    if (bX(E, P, W))
      if (Q.asyncDep && !Q.asyncResolved) {
        ge(Q, P, W);
        return;
      } else
        Q.next = P, Q.update();
    else
      P.el = E.el, Q.vnode = P;
  }, Se = (E, P, W, Q, J, Y, ae) => {
    const re = () => {
      if (E.isMounted) {
        let { next: de, bu: Te, u: Pe, parent: F, vnode: X } = E;
        {
          const Rt = EE(E);
          if (Rt) {
            de && (de.el = X.el, ge(E, de, ae)), Rt.asyncDep.then(() => {
              E.isUnmounted || re();
            });
            return;
          }
        }
        let pe = de, _e;
        Pl(E, !1), de ? (de.el = X.el, ge(E, de, ae)) : de = X, Te && I2(Te), (_e = de.props && de.props.onVnodeBeforeUpdate) && Xi(_e, F, de, X), Pl(E, !0);
        const je = N8(E), xt = E.subTree;
        E.subTree = je, m(
          xt,
          je,
          // parent may have changed if it's in a teleport
          h(xt.el),
          // anchor may have changed if it's in a fragment
          Ct(xt),
          E,
          J,
          Y
        ), de.el = je.el, pe === null && vX(E, je.el), Pe && Vr(Pe, J), (_e = de.props && de.props.onVnodeUpdated) && Vr(
          () => Xi(_e, F, de, X),
          J
        ), __VUE_PROD_DEVTOOLS__ && fE(E);
      } else {
        let de;
        const { el: Te, props: Pe } = P, { bm: F, m: X, parent: pe, root: _e, type: je } = E, xt = uf(P);
        Pl(E, !1), F && I2(F), !xt && (de = Pe && Pe.onVnodeBeforeMount) && Xi(de, pe, P), Pl(E, !0);
        {
          _e.ce && // @ts-expect-error _def is private
          _e.ce._def.shadowRoot !== !1 && _e.ce._injectChildStyle(je);
          const Rt = E.subTree = N8(E);
          m(
            null,
            Rt,
            W,
            Q,
            E,
            J,
            Y
          ), P.el = Rt.el;
        }
        if (X && Vr(X, J), !xt && (de = Pe && Pe.onVnodeMounted)) {
          const Rt = P;
          Vr(
            () => Xi(de, pe, Rt),
            J
          );
        }
        (P.shapeFlag & 256 || pe && uf(pe.vnode) && pe.vnode.shapeFlag & 256) && E.a && Vr(E.a, J), E.isMounted = !0, __VUE_PROD_DEVTOOLS__ && TJ(E), P = W = Q = null;
      }
    };
    E.scope.on();
    const oe = E.effect = new WO(re);
    E.scope.off();
    const te = E.update = oe.run.bind(oe), De = E.job = oe.runIfDirty.bind(oe);
    De.i = E, De.id = E.uid, oe.scheduler = () => pv(De), Pl(E, !0), te();
  }, ge = (E, P, W) => {
    P.component = E;
    const Q = E.vnode.props;
    E.vnode = P, E.next = null, tX(E, P.props, Q, W), sX(E, P.children, W), ho(), M8(E), fo();
  }, ye = (E, P, W, Q, J, Y, ae, re, oe = !1) => {
    const te = E && E.children, De = E ? E.shapeFlag : 0, de = P.children, { patchFlag: Te, shapeFlag: Pe } = P;
    if (Te > 0) {
      if (Te & 128) {
        I(
          te,
          de,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        );
        return;
      } else if (Te & 256) {
        ze(
          te,
          de,
          W,
          Q,
          J,
          Y,
          ae,
          re,
          oe
        );
        return;
      }
    }
    Pe & 8 ? (De & 16 && et(te, J, Y), de !== te && u(W, de)) : De & 16 ? Pe & 16 ? I(
      te,
      de,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe
    ) : et(te, J, Y, !0) : (De & 8 && u(W, ""), Pe & 16 && B(
      de,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe
    ));
  }, ze = (E, P, W, Q, J, Y, ae, re, oe) => {
    E = E || nf, P = P || nf;
    const te = E.length, De = P.length, de = Math.min(te, De);
    let Te;
    for (Te = 0; Te < de; Te++) {
      const Pe = P[Te] = oe ? Vo(P[Te]) : is(P[Te]);
      m(
        E[Te],
        Pe,
        W,
        null,
        J,
        Y,
        ae,
        re,
        oe
      );
    }
    te > De ? et(
      E,
      J,
      Y,
      !0,
      !1,
      de
    ) : B(
      P,
      W,
      Q,
      J,
      Y,
      ae,
      re,
      oe,
      de
    );
  }, I = (E, P, W, Q, J, Y, ae, re, oe) => {
    let te = 0;
    const De = P.length;
    let de = E.length - 1, Te = De - 1;
    for (; te <= de && te <= Te; ) {
      const Pe = E[te], F = P[te] = oe ? Vo(P[te]) : is(P[te]);
      if ($u(Pe, F))
        m(
          Pe,
          F,
          W,
          null,
          J,
          Y,
          ae,
          re,
          oe
        );
      else
        break;
      te++;
    }
    for (; te <= de && te <= Te; ) {
      const Pe = E[de], F = P[Te] = oe ? Vo(P[Te]) : is(P[Te]);
      if ($u(Pe, F))
        m(
          Pe,
          F,
          W,
          null,
          J,
          Y,
          ae,
          re,
          oe
        );
      else
        break;
      de--, Te--;
    }
    if (te > de) {
      if (te <= Te) {
        const Pe = Te + 1, F = Pe < De ? P[Pe].el : Q;
        for (; te <= Te; )
          m(
            null,
            P[te] = oe ? Vo(P[te]) : is(P[te]),
            W,
            F,
            J,
            Y,
            ae,
            re,
            oe
          ), te++;
      }
    } else if (te > Te)
      for (; te <= de; )
        Ve(E[te], J, Y, !0), te++;
    else {
      const Pe = te, F = te, X = /* @__PURE__ */ new Map();
      for (te = F; te <= Te; te++) {
        const wt = P[te] = oe ? Vo(P[te]) : is(P[te]);
        wt.key != null && X.set(wt.key, te);
      }
      let pe, _e = 0;
      const je = Te - F + 1;
      let xt = !1, Rt = 0;
      const Yt = new Array(je);
      for (te = 0; te < je; te++) Yt[te] = 0;
      for (te = Pe; te <= de; te++) {
        const wt = E[te];
        if (_e >= je) {
          Ve(wt, J, Y, !0);
          continue;
        }
        let pt;
        if (wt.key != null)
          pt = X.get(wt.key);
        else
          for (pe = F; pe <= Te; pe++)
            if (Yt[pe - F] === 0 && $u(wt, P[pe])) {
              pt = pe;
              break;
            }
        pt === void 0 ? Ve(wt, J, Y, !0) : (Yt[pt - F] = te + 1, pt >= Rt ? Rt = pt : xt = !0, m(
          wt,
          P[pt],
          W,
          null,
          J,
          Y,
          ae,
          re,
          oe
        ), _e++);
      }
      const on = xt ? uX(Yt) : nf;
      for (pe = on.length - 1, te = je - 1; te >= 0; te--) {
        const wt = F + te, pt = P[wt], Vn = P[wt + 1], En = wt + 1 < De ? (
          // #13559, fallback to el placeholder for unresolved async component
          Vn.el || Vn.placeholder
        ) : Q;
        Yt[te] === 0 ? m(
          null,
          pt,
          W,
          En,
          J,
          Y,
          ae,
          re,
          oe
        ) : xt && (pe < 0 || te !== on[pe] ? Ie(pt, W, En, 2) : pe--);
      }
    }
  }, Ie = (E, P, W, Q, J = null) => {
    const { el: Y, type: ae, transition: re, children: oe, shapeFlag: te } = E;
    if (te & 6) {
      Ie(E.component.subTree, P, W, Q);
      return;
    }
    if (te & 128) {
      E.suspense.move(P, W, Q);
      return;
    }
    if (te & 64) {
      ae.move(E, P, W, Gt);
      return;
    }
    if (ae === Ln) {
      r(Y, P, W);
      for (let de = 0; de < oe.length; de++)
        Ie(oe[de], P, W, Q);
      r(E.anchor, P, W);
      return;
    }
    if (ae === xp) {
      k(E, P, W);
      return;
    }
    if (Q !== 2 && te & 1 && re)
      if (Q === 0)
        re.beforeEnter(Y), r(Y, P, W), Vr(() => re.enter(Y), J);
      else {
        const { leave: de, delayLeave: Te, afterLeave: Pe } = re, F = () => {
          E.ctx.isUnmounted ? i(Y) : r(Y, P, W);
        }, X = () => {
          de(Y, () => {
            F(), Pe && Pe();
          });
        };
        Te ? Te(Y, F, X) : X();
      }
    else
      r(Y, P, W);
  }, Ve = (E, P, W, Q = !1, J = !1) => {
    const {
      type: Y,
      props: ae,
      ref: re,
      children: oe,
      dynamicChildren: te,
      shapeFlag: De,
      patchFlag: de,
      dirs: Te,
      cacheIndex: Pe
    } = E;
    if (de === -2 && (J = !1), re != null && (ho(), cf(re, null, W, E, !0), fo()), Pe != null && (P.renderCache[Pe] = void 0), De & 256) {
      P.ctx.deactivate(E);
      return;
    }
    const F = De & 1 && Te, X = !uf(E);
    let pe;
    if (X && (pe = ae && ae.onVnodeBeforeUnmount) && Xi(pe, P, E), De & 6)
      Ue(E.component, W, Q);
    else {
      if (De & 128) {
        E.suspense.unmount(W, Q);
        return;
      }
      F && Rl(E, null, P, "beforeUnmount"), De & 64 ? E.type.remove(
        E,
        P,
        W,
        Gt,
        Q
      ) : te && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !te.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (Y !== Ln || de > 0 && de & 64) ? et(
        te,
        P,
        W,
        !1,
        !0
      ) : (Y === Ln && de & 384 || !J && De & 16) && et(oe, P, W), Q && O(E);
    }
    (X && (pe = ae && ae.onVnodeUnmounted) || F) && Vr(() => {
      pe && Xi(pe, P, E), F && Rl(E, null, P, "unmounted");
    }, W);
  }, O = (E) => {
    const { type: P, el: W, anchor: Q, transition: J } = E;
    if (P === Ln) {
      dt(W, Q);
      return;
    }
    if (P === xp) {
      C(E);
      return;
    }
    const Y = () => {
      i(W), J && !J.persisted && J.afterLeave && J.afterLeave();
    };
    if (E.shapeFlag & 1 && J && !J.persisted) {
      const { leave: ae, delayLeave: re } = J, oe = () => ae(W, Y);
      re ? re(E.el, Y, oe) : oe();
    } else
      Y();
  }, dt = (E, P) => {
    let W;
    for (; E !== P; )
      W = f(E), i(E), E = W;
    i(P);
  }, Ue = (E, P, W) => {
    const {
      bum: Q,
      scope: J,
      job: Y,
      subTree: ae,
      um: re,
      m: oe,
      a: te,
      parent: De,
      slots: { __: de }
    } = E;
    D8(oe), D8(te), Q && I2(Q), De && Ze(de) && de.forEach((Te) => {
      De.renderCache[Te] = void 0;
    }), J.stop(), Y && (Y.flags |= 8, Ve(ae, E, P, W)), re && Vr(re, P), Vr(() => {
      E.isUnmounted = !0;
    }, P), P && P.pendingBranch && !P.isUnmounted && E.asyncDep && !E.asyncResolved && E.suspenseId === P.pendingId && (P.deps--, P.deps === 0 && P.resolve()), __VUE_PROD_DEVTOOLS__ && OJ(E);
  }, et = (E, P, W, Q = !1, J = !1, Y = 0) => {
    for (let ae = Y; ae < E.length; ae++)
      Ve(E[ae], P, W, Q, J);
  }, Ct = (E) => {
    if (E.shapeFlag & 6)
      return Ct(E.component.subTree);
    if (E.shapeFlag & 128)
      return E.suspense.next();
    const P = f(E.anchor || E.el), W = P && P[DJ];
    return W ? f(W) : P;
  };
  let Ft = !1;
  const sn = (E, P, W) => {
    E == null ? P._vnode && Ve(P._vnode, null, null, !0) : m(
      P._vnode || null,
      E,
      P,
      null,
      null,
      null,
      W
    ), P._vnode = E, Ft || (Ft = !0, M8(), cE(), Ft = !1);
  }, Gt = {
    p: m,
    um: Ve,
    m: Ie,
    r: O,
    mt: ie,
    mc: B,
    pc: ye,
    pbc: R,
    n: Ct,
    o: n
  };
  return {
    render: sn,
    hydrate: void 0,
    createApp: ZJ(sn)
  };
}
function _2({ type: n, props: e }, t) {
  return t === "svg" && n === "foreignObject" || t === "mathml" && n === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t;
}
function Pl({ effect: n, job: e }, t) {
  t ? (n.flags |= 32, e.flags |= 4) : (n.flags &= -33, e.flags &= -5);
}
function cX(n, e) {
  return (!n || n && !n.pendingBranch) && e && !e.persisted;
}
function OE(n, e, t = !1) {
  const r = n.children, i = e.children;
  if (Ze(r) && Ze(i))
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      let l = i[s];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = i[s] = Vo(i[s]), l.el = o.el), !t && l.patchFlag !== -2 && OE(o, l)), l.type === Cd && (l.el = o.el), l.type === Ia && !l.el && (l.el = o.el);
    }
}
function uX(n) {
  const e = n.slice(), t = [0];
  let r, i, s, o, l;
  const a = n.length;
  for (r = 0; r < a; r++) {
    const c = n[r];
    if (c !== 0) {
      if (i = t[t.length - 1], n[i] < c) {
        e[r] = i, t.push(r);
        continue;
      }
      for (s = 0, o = t.length - 1; s < o; )
        l = s + o >> 1, n[t[l]] < c ? s = l + 1 : o = l;
      c < n[t[s]] && (s > 0 && (e[r] = t[s - 1]), t[s] = r);
    }
  }
  for (s = t.length, o = t[s - 1]; s-- > 0; )
    t[s] = o, o = e[o];
  return t;
}
function EE(n) {
  const e = n.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : EE(e);
}
function D8(n) {
  if (n)
    for (let e = 0; e < n.length; e++)
      n[e].flags |= 8;
}
const hX = Symbol.for("v-scx"), fX = () => wp(hX);
function cu(n, e) {
  return vv(n, null, e);
}
function Tc(n, e, t) {
  return vv(n, e, t);
}
function vv(n, e, t = _t) {
  const { immediate: r, deep: i, flush: s, once: o } = t, l = Xn({}, t), a = e && r || !e && s !== "post";
  let c;
  if (Yf) {
    if (s === "sync") {
      const d = fX();
      c = d.__watcherHandles || (d.__watcherHandles = []);
    } else if (!a) {
      const d = () => {
      };
      return d.stop = Pi, d.resume = Pi, d.pause = Pi, d;
    }
  }
  const u = ar;
  l.call = (d, p, m) => Ms(d, u, p, m);
  let h = !1;
  s === "post" ? l.scheduler = (d) => {
    Vr(d, u && u.suspense);
  } : s !== "sync" && (h = !0, l.scheduler = (d, p) => {
    p ? d() : pv(d);
  }), l.augmentJob = (d) => {
    e && (d.flags |= 4), h && (d.flags |= 2, u && (d.id = u.uid, d.i = u));
  };
  const f = vJ(n, e, l);
  return Yf && (c ? c.push(f) : a && f()), f;
}
function dX(n, e, t) {
  const r = this.proxy, i = An(n) ? n.includes(".") ? IE(r, n) : () => r[n] : n.bind(r, r);
  let s;
  tt(e) ? s = e : (s = e.handler, t = e);
  const o = Md(this), l = vv(i, s.bind(r), t);
  return o(), l;
}
function IE(n, e) {
  const t = e.split(".");
  return () => {
    let r = n;
    for (let i = 0; i < t.length && r; i++)
      r = r[t[i]];
    return r;
  };
}
const pX = (n, e) => e === "modelValue" || e === "model-value" ? n.modelModifiers : n[`${e}Modifiers`] || n[`${gl(e)}Modifiers`] || n[`${Fa(e)}Modifiers`];
function mX(n, e, ...t) {
  if (n.isUnmounted) return;
  const r = n.vnode.props || _t;
  let i = t;
  const s = e.startsWith("update:"), o = s && pX(r, e.slice(7));
  o && (o.trim && (i = t.map((u) => An(u) ? u.trim() : u)), o.number && (i = t.map(zY))), __VUE_PROD_DEVTOOLS__ && EJ(n, e, i);
  let l, a = r[l = E2(e)] || // also try camelCase event handler (#2249)
  r[l = E2(gl(e))];
  !a && s && (a = r[l = E2(Fa(e))]), a && Ms(
    a,
    n,
    6,
    i
  );
  const c = r[l + "Once"];
  if (c) {
    if (!n.emitted)
      n.emitted = {};
    else if (n.emitted[l])
      return;
    n.emitted[l] = !0, Ms(
      c,
      n,
      6,
      i
    );
  }
}
function DE(n, e, t = !1) {
  const r = e.emitsCache, i = r.get(n);
  if (i !== void 0)
    return i;
  const s = n.emits;
  let o = {}, l = !1;
  if (__VUE_OPTIONS_API__ && !tt(n)) {
    const a = (c) => {
      const u = DE(c, e, !0);
      u && (l = !0, Xn(o, u));
    };
    !t && e.mixins.length && e.mixins.forEach(a), n.extends && a(n.extends), n.mixins && n.mixins.forEach(a);
  }
  return !s && !l ? (un(n) && r.set(n, null), null) : (Ze(s) ? s.forEach((a) => o[a] = null) : Xn(o, s), un(n) && r.set(n, o), o);
}
function K1(n, e) {
  return !n || !$1(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), bt(n, e[0].toLowerCase() + e.slice(1)) || bt(n, Fa(e)) || bt(n, e));
}
function N8(n) {
  const {
    type: e,
    vnode: t,
    proxy: r,
    withProxy: i,
    propsOptions: [s],
    slots: o,
    attrs: l,
    emit: a,
    render: c,
    renderCache: u,
    props: h,
    data: f,
    setupState: d,
    ctx: p,
    inheritAttrs: m
  } = n, g = Im(n);
  let b, w;
  try {
    if (t.shapeFlag & 4) {
      const C = i || r, M = C;
      b = is(
        c.call(
          M,
          C,
          u,
          h,
          d,
          f,
          p
        )
      ), w = l;
    } else {
      const C = e;
      b = is(
        C.length > 1 ? C(
          h,
          { attrs: l, slots: o, emit: a }
        ) : C(
          h,
          null
        )
      ), w = e.props ? l : gX(l);
    }
  } catch (C) {
    W1(C, n, 1), b = Di(Ia);
  }
  let k = b;
  if (w && m !== !1) {
    const C = Object.keys(w), { shapeFlag: M } = k;
    C.length && M & 7 && (s && C.some(ev) && (w = yX(
      w,
      s
    )), k = qc(k, w, !1, !0));
  }
  return t.dirs && (k = qc(k, null, !1, !0), k.dirs = k.dirs ? k.dirs.concat(t.dirs) : t.dirs), t.transition && gv(k, t.transition), b = k, Im(g), b;
}
const gX = (n) => {
  let e;
  for (const t in n)
    (t === "class" || t === "style" || $1(t)) && ((e || (e = {}))[t] = n[t]);
  return e;
}, yX = (n, e) => {
  const t = {};
  for (const r in n)
    (!ev(r) || !(r.slice(9) in e)) && (t[r] = n[r]);
  return t;
};
function bX(n, e, t) {
  const { props: r, children: i, component: s } = n, { props: o, children: l, patchFlag: a } = e, c = s.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (t && a >= 0) {
    if (a & 1024)
      return !0;
    if (a & 16)
      return r ? R8(r, o, c) : !!o;
    if (a & 8) {
      const u = e.dynamicProps;
      for (let h = 0; h < u.length; h++) {
        const f = u[h];
        if (o[f] !== r[f] && !K1(c, f))
          return !0;
      }
    }
  } else
    return (i || l) && (!l || !l.$stable) ? !0 : r === o ? !1 : r ? o ? R8(r, o, c) : !0 : !!o;
  return !1;
}
function R8(n, e, t) {
  const r = Object.keys(e);
  if (r.length !== Object.keys(n).length)
    return !0;
  for (let i = 0; i < r.length; i++) {
    const s = r[i];
    if (e[s] !== n[s] && !K1(t, s))
      return !0;
  }
  return !1;
}
function vX({ vnode: n, parent: e }, t) {
  for (; e; ) {
    const r = e.subTree;
    if (r.suspense && r.suspense.activeBranch === n && (r.el = n.el), r === n)
      (n = e.vnode).el = t, e = e.parent;
    else
      break;
  }
}
const NE = (n) => n.__isSuspense;
function wX(n, e) {
  e && e.pendingBranch ? Ze(n) ? e.effects.push(...n) : e.effects.push(n) : SJ(n);
}
const Ln = Symbol.for("v-fgt"), Cd = Symbol.for("v-txt"), Ia = Symbol.for("v-cmt"), xp = Symbol.for("v-stc");
let el = null, wv = 1;
function P8(n, e = !1) {
  wv += n, n < 0 && el && e && (el.hasOnce = !0);
}
function Nm(n) {
  return n ? n.__v_isVNode === !0 : !1;
}
function $u(n, e) {
  return n.type === e.type && n.key === e.key;
}
const RE = ({ key: n }) => n ?? null, kp = ({
  ref: n,
  ref_key: e,
  ref_for: t
}) => (typeof n == "number" && (n = "" + n), n != null ? An(n) || Jn(n) || tt(n) ? { i: ds, r: n, k: e, f: !!t } : n : null);
function xX(n, e = null, t = null, r = 0, i = null, s = n === Ln ? 0 : 1, o = !1, l = !1) {
  const a = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n,
    props: e,
    key: e && RE(e),
    ref: e && kp(e),
    scopeId: dE,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: r,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: ds
  };
  return l ? (xv(a, t), s & 128 && n.normalize(a)) : t && (a.shapeFlag |= An(t) ? 8 : 16), wv > 0 && // avoid a block node from tracking itself
  !o && // has current parent block
  el && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (a.patchFlag > 0 || s & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  a.patchFlag !== 32 && el.push(a), a;
}
const Di = kX;
function kX(n, e = null, t = null, r = 0, i = null, s = !1) {
  if ((!n || n === WJ) && (n = Ia), Nm(n)) {
    const l = qc(
      n,
      e,
      !0
      /* mergeRef: true */
    );
    return t && xv(l, t), wv > 0 && !s && el && (l.shapeFlag & 6 ? el[el.indexOf(n)] = l : el.push(l)), l.patchFlag = -2, l;
  }
  if (PX(n) && (n = n.__vccOpts), e) {
    e = SX(e);
    let { class: l, style: a } = e;
    l && !An(l) && (e.class = iv(l)), un(a) && (dv(a) && !Ze(a) && (a = Xn({}, a)), e.style = rv(a));
  }
  const o = An(n) ? 1 : NE(n) ? 128 : NJ(n) ? 64 : un(n) ? 4 : tt(n) ? 2 : 0;
  return xX(
    n,
    e,
    t,
    r,
    i,
    o,
    s,
    !0
  );
}
function SX(n) {
  return n ? dv(n) || kE(n) ? Xn({}, n) : n : null;
}
function qc(n, e, t = !1, r = !1) {
  const { props: i, ref: s, patchFlag: o, children: l, transition: a } = n, c = e ? MX(i || {}, e) : i, u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n.type,
    props: c,
    key: c && RE(c),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && s ? Ze(s) ? s.concat(kp(e)) : [s, kp(e)] : kp(e)
    ) : s,
    scopeId: n.scopeId,
    slotScopeIds: n.slotScopeIds,
    children: l,
    target: n.target,
    targetStart: n.targetStart,
    targetAnchor: n.targetAnchor,
    staticCount: n.staticCount,
    shapeFlag: n.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && n.type !== Ln ? o === -1 ? 16 : o | 16 : o,
    dynamicProps: n.dynamicProps,
    dynamicChildren: n.dynamicChildren,
    appContext: n.appContext,
    dirs: n.dirs,
    transition: a,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: n.component,
    suspense: n.suspense,
    ssContent: n.ssContent && qc(n.ssContent),
    ssFallback: n.ssFallback && qc(n.ssFallback),
    placeholder: n.placeholder,
    el: n.el,
    anchor: n.anchor,
    ctx: n.ctx,
    ce: n.ce
  };
  return a && r && gv(
    u,
    a.clone(u)
  ), u;
}
function CX(n = " ", e = 0) {
  return Di(Cd, null, n, e);
}
function is(n) {
  return n == null || typeof n == "boolean" ? Di(Ia) : Ze(n) ? Di(
    Ln,
    null,
    // #3666, avoid reference pollution when reusing vnode
    n.slice()
  ) : Nm(n) ? Vo(n) : Di(Cd, null, String(n));
}
function Vo(n) {
  return n.el === null && n.patchFlag !== -1 || n.memo ? n : qc(n);
}
function xv(n, e) {
  let t = 0;
  const { shapeFlag: r } = n;
  if (e == null)
    e = null;
  else if (Ze(e))
    t = 16;
  else if (typeof e == "object")
    if (r & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), xv(n, i()), i._c && (i._d = !0));
      return;
    } else {
      t = 32;
      const i = e._;
      !i && !kE(e) ? e._ctx = ds : i === 3 && ds && (ds.slots._ === 1 ? e._ = 1 : (e._ = 2, n.patchFlag |= 1024));
    }
  else tt(e) ? (e = { default: e, _ctx: ds }, t = 32) : (e = String(e), r & 64 ? (t = 16, e = [CX(e)]) : t = 8);
  n.children = e, n.shapeFlag |= t;
}
function MX(...n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = n[t];
    for (const i in r)
      if (i === "class")
        e.class !== r.class && (e.class = iv([e.class, r.class]));
      else if (i === "style")
        e.style = rv([e.style, r.style]);
      else if ($1(i)) {
        const s = e[i], o = r[i];
        o && s !== o && !(Ze(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o);
      } else i !== "" && (e[i] = r[i]);
  }
  return e;
}
function Xi(n, e, t, r = null) {
  Ms(n, e, 7, [
    t,
    r
  ]);
}
const TX = vE();
let AX = 0;
function OX(n, e, t) {
  const r = n.type, i = (e ? e.appContext : n.appContext) || TX, s = {
    uid: AX++,
    vnode: n,
    type: r,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new jY(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: CE(r, i),
    emitsOptions: DE(r, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: _t,
    // inheritAttrs
    inheritAttrs: r.inheritAttrs,
    // state
    ctx: _t,
    data: _t,
    props: _t,
    attrs: _t,
    slots: _t,
    refs: _t,
    setupState: _t,
    setupContext: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return s.ctx = { _: s }, s.root = e ? e.root : s, s.emit = mX.bind(null, s), n.ce && n.ce(s), s;
}
let ar = null;
const EX = () => ar || ds;
let Rm, d5;
{
  const n = ha(), e = (t, r) => {
    let i;
    return (i = n[t]) || (i = n[t] = []), i.push(r), (s) => {
      i.length > 1 ? i.forEach((o) => o(s)) : i[0](s);
    };
  };
  Rm = e(
    "__VUE_INSTANCE_SETTERS__",
    (t) => ar = t
  ), d5 = e(
    "__VUE_SSR_SETTERS__",
    (t) => Yf = t
  );
}
const Md = (n) => {
  const e = ar;
  return Rm(n), n.scope.on(), () => {
    n.scope.off(), Rm(e);
  };
}, _8 = () => {
  ar && ar.scope.off(), Rm(null);
};
function PE(n) {
  return n.vnode.shapeFlag & 4;
}
let Yf = !1;
function IX(n, e = !1, t = !1) {
  e && d5(e);
  const { props: r, children: i } = n.vnode, s = PE(n);
  eX(n, r, s, e), iX(n, i, t || e);
  const o = s ? DX(n, e) : void 0;
  return e && d5(!1), o;
}
function DX(n, e) {
  const t = n.type;
  n.accessCache = /* @__PURE__ */ Object.create(null), n.proxy = new Proxy(n.ctx, jJ);
  const { setup: r } = t;
  if (r) {
    ho();
    const i = n.setupContext = r.length > 1 ? RX(n) : null, s = Md(n), o = xd(
      r,
      n,
      0,
      [
        n.props,
        i
      ]
    ), l = $O(o);
    if (fo(), s(), (l || n.sp) && !uf(n) && pE(n), l) {
      if (o.then(_8, _8), e)
        return o.then((a) => {
          L8(n, a);
        }).catch((a) => {
          W1(a, n, 0);
        });
      n.asyncDep = o;
    } else
      L8(n, o);
  } else
    _E(n);
}
function L8(n, e, t) {
  tt(e) ? n.type.__ssrInlineRender ? n.ssrRender = e : n.render = e : un(e) && (__VUE_PROD_DEVTOOLS__ && (n.devtoolsRawSetupState = e), n.setupState = oE(e)), _E(n);
}
function _E(n, e, t) {
  const r = n.type;
  if (n.render || (n.render = r.render || Pi), __VUE_OPTIONS_API__) {
    const i = Md(n);
    ho();
    try {
      UJ(n);
    } finally {
      fo(), i();
    }
  }
}
const NX = {
  get(n, e) {
    return jn(n, "get", ""), n[e];
  }
};
function RX(n) {
  const e = (t) => {
    n.exposed = t || {};
  };
  return {
    attrs: new Proxy(n.attrs, NX),
    slots: n.slots,
    emit: n.emit,
    expose: e
  };
}
function kv(n) {
  return n.exposed ? n.exposeProxy || (n.exposeProxy = new Proxy(oE(fJ(n.exposed)), {
    get(e, t) {
      if (t in e)
        return e[t];
      if (t in hf)
        return hf[t](n);
    },
    has(e, t) {
      return t in e || t in hf;
    }
  })) : n.proxy;
}
function PX(n) {
  return tt(n) && "__vccOpts" in n;
}
const Da = (n, e) => yJ(n, e, Yf);
function j(n, e, t) {
  const r = arguments.length;
  return r === 2 ? un(e) && !Ze(e) ? Nm(e) ? Di(n, null, [e]) : Di(n, e) : Di(n, null, e) : (r > 3 ? t = Array.prototype.slice.call(arguments, 2) : r === 3 && Nm(t) && (t = [t]), Di(n, e, t));
}
const B8 = "3.5.18";
/**
* @vue/runtime-dom v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let p5;
const z8 = typeof window < "u" && window.trustedTypes;
if (z8)
  try {
    p5 = /* @__PURE__ */ z8.createPolicy("vue", {
      createHTML: (n) => n
    });
  } catch {
  }
const LE = p5 ? (n) => p5.createHTML(n) : (n) => n, _X = "http://www.w3.org/2000/svg", LX = "http://www.w3.org/1998/Math/MathML", Ks = typeof document < "u" ? document : null, F8 = Ks && /* @__PURE__ */ Ks.createElement("template"), BX = {
  insert: (n, e, t) => {
    e.insertBefore(n, t || null);
  },
  remove: (n) => {
    const e = n.parentNode;
    e && e.removeChild(n);
  },
  createElement: (n, e, t, r) => {
    const i = e === "svg" ? Ks.createElementNS(_X, n) : e === "mathml" ? Ks.createElementNS(LX, n) : t ? Ks.createElement(n, { is: t }) : Ks.createElement(n);
    return n === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple), i;
  },
  createText: (n) => Ks.createTextNode(n),
  createComment: (n) => Ks.createComment(n),
  setText: (n, e) => {
    n.nodeValue = e;
  },
  setElementText: (n, e) => {
    n.textContent = e;
  },
  parentNode: (n) => n.parentNode,
  nextSibling: (n) => n.nextSibling,
  querySelector: (n) => Ks.querySelector(n),
  setScopeId(n, e) {
    n.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(n, e, t, r, i, s) {
    const o = t ? t.previousSibling : e.lastChild;
    if (i && (i === s || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), t), !(i === s || !(i = i.nextSibling)); )
        ;
    else {
      F8.innerHTML = LE(
        r === "svg" ? `<svg>${n}</svg>` : r === "mathml" ? `<math>${n}</math>` : n
      );
      const l = F8.content;
      if (r === "svg" || r === "mathml") {
        const a = l.firstChild;
        for (; a.firstChild; )
          l.appendChild(a.firstChild);
        l.removeChild(a);
      }
      e.insertBefore(l, t);
    }
    return [
      // first
      o ? o.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
}, zX = Symbol("_vtc");
function FX(n, e, t) {
  const r = n[zX];
  r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? n.removeAttribute("class") : t ? n.setAttribute("class", e) : n.className = e;
}
const H8 = Symbol("_vod"), HX = Symbol("_vsh"), $X = Symbol(""), VX = /(^|;)\s*display\s*:/;
function qX(n, e, t) {
  const r = n.style, i = An(t);
  let s = !1;
  if (t && !i) {
    if (e)
      if (An(e))
        for (const o of e.split(";")) {
          const l = o.slice(0, o.indexOf(":")).trim();
          t[l] == null && Sp(r, l, "");
        }
      else
        for (const o in e)
          t[o] == null && Sp(r, o, "");
    for (const o in t)
      o === "display" && (s = !0), Sp(r, o, t[o]);
  } else if (i) {
    if (e !== t) {
      const o = r[$X];
      o && (t += ";" + o), r.cssText = t, s = VX.test(t);
    }
  } else e && n.removeAttribute("style");
  H8 in n && (n[H8] = s ? r.display : "", n[HX] && (r.display = "none"));
}
const $8 = /\s*!important$/;
function Sp(n, e, t) {
  if (Ze(t))
    t.forEach((r) => Sp(n, e, r));
  else if (t == null && (t = ""), e.startsWith("--"))
    n.setProperty(e, t);
  else {
    const r = WX(n, e);
    $8.test(t) ? n.setProperty(
      Fa(r),
      t.replace($8, ""),
      "important"
    ) : n[r] = t;
  }
}
const V8 = ["Webkit", "Moz", "ms"], L2 = {};
function WX(n, e) {
  const t = L2[e];
  if (t)
    return t;
  let r = gl(e);
  if (r !== "filter" && r in n)
    return L2[e] = r;
  r = VO(r);
  for (let i = 0; i < V8.length; i++) {
    const s = V8[i] + r;
    if (s in n)
      return L2[e] = s;
  }
  return e;
}
const q8 = "http://www.w3.org/1999/xlink";
function W8(n, e, t, r, i, s = WY(e)) {
  r && e.startsWith("xlink:") ? t == null ? n.removeAttributeNS(q8, e.slice(6, e.length)) : n.setAttributeNS(q8, e, t) : t == null || s && !qO(t) ? n.removeAttribute(e) : n.setAttribute(
    e,
    s ? "" : au(t) ? String(t) : t
  );
}
function j8(n, e, t, r, i) {
  if (e === "innerHTML" || e === "textContent") {
    t != null && (n[e] = e === "innerHTML" ? LE(t) : t);
    return;
  }
  const s = n.tagName;
  if (e === "value" && s !== "PROGRESS" && // custom elements may use _value internally
  !s.includes("-")) {
    const l = s === "OPTION" ? n.getAttribute("value") || "" : n.value, a = t == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      n.type === "checkbox" ? "on" : ""
    ) : String(t);
    (l !== a || !("_value" in n)) && (n.value = a), t == null && n.removeAttribute(e), n._value = t;
    return;
  }
  let o = !1;
  if (t === "" || t == null) {
    const l = typeof n[e];
    l === "boolean" ? t = qO(t) : t == null && l === "string" ? (t = "", o = !0) : l === "number" && (t = 0, o = !0);
  }
  try {
    n[e] = t;
  } catch {
  }
  o && n.removeAttribute(i || e);
}
function jX(n, e, t, r) {
  n.addEventListener(e, t, r);
}
function UX(n, e, t, r) {
  n.removeEventListener(e, t, r);
}
const U8 = Symbol("_vei");
function KX(n, e, t, r, i = null) {
  const s = n[U8] || (n[U8] = {}), o = s[e];
  if (r && o)
    o.value = r;
  else {
    const [l, a] = GX(e);
    if (r) {
      const c = s[e] = XX(
        r,
        i
      );
      jX(n, l, c, a);
    } else o && (UX(n, l, o, a), s[e] = void 0);
  }
}
const K8 = /(?:Once|Passive|Capture)$/;
function GX(n) {
  let e;
  if (K8.test(n)) {
    e = {};
    let r;
    for (; r = n.match(K8); )
      n = n.slice(0, n.length - r[0].length), e[r[0].toLowerCase()] = !0;
  }
  return [n[2] === ":" ? n.slice(3) : Fa(n.slice(2)), e];
}
let B2 = 0;
const YX = /* @__PURE__ */ Promise.resolve(), JX = () => B2 || (YX.then(() => B2 = 0), B2 = Date.now());
function XX(n, e) {
  const t = (r) => {
    if (!r._vts)
      r._vts = Date.now();
    else if (r._vts <= t.attached)
      return;
    Ms(
      ZX(r, t.value),
      e,
      5,
      [r]
    );
  };
  return t.value = n, t.attached = JX(), t;
}
function ZX(n, e) {
  if (Ze(e)) {
    const t = n.stopImmediatePropagation;
    return n.stopImmediatePropagation = () => {
      t.call(n), n._stopped = !0;
    }, e.map(
      (r) => (i) => !i._stopped && r && r(i)
    );
  } else
    return e;
}
const G8 = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // lowercase letter
n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123, QX = (n, e, t, r, i, s) => {
  const o = i === "svg";
  e === "class" ? FX(n, r, o) : e === "style" ? qX(n, t, r) : $1(e) ? ev(e) || KX(n, e, t, r, s) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : eZ(n, e, r, o)) ? (j8(n, e, r), !n.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && W8(n, e, r, o, s, e !== "value")) : /* #11081 force set props for possible async custom element */ n._isVueCE && (/[A-Z]/.test(e) || !An(r)) ? j8(n, gl(e), r, s, e) : (e === "true-value" ? n._trueValue = r : e === "false-value" && (n._falseValue = r), W8(n, e, r, o));
};
function eZ(n, e, t, r) {
  if (r)
    return !!(e === "innerHTML" || e === "textContent" || e in n && G8(e) && tt(t));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "form" || e === "list" && n.tagName === "INPUT" || e === "type" && n.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = n.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return G8(e) && An(t) ? !1 : e in n;
}
const tZ = /* @__PURE__ */ Xn({ patchProp: QX }, BX);
let Y8;
function nZ() {
  return Y8 || (Y8 = lX(tZ));
}
const ji = (...n) => {
  const e = nZ().createApp(...n), { mount: t } = e;
  return e.mount = (r) => {
    const i = iZ(r);
    if (!i) return;
    const s = e._component;
    !tt(s) && !s.render && !s.template && (s.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
    const o = t(i, !1, rZ(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o;
  }, e;
};
function rZ(n) {
  if (n instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && n instanceof MathMLElement)
    return "mathml";
}
function iZ(n) {
  return An(n) ? document.querySelector(n) : n;
}
function sZ(n) {
  const e = St(
    {},
    `${n}_SLASH_SPEC`
  ), t = kn((i) => {
    const s = i.get(e.key);
    return new Ut({
      key: new en(`${n}_SLASH`),
      ...s
    });
  }), r = [e, t];
  return r.key = e.key, r.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Ctx<slashSpec>|${n}`
  }, t.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Prose<slash>|${n}`
  }, r;
}
class oZ {
  constructor(e) {
    this.#t = !1, this.onShow = () => {
    }, this.onHide = () => {
    }, this.#c = (t, r) => {
      const { state: i, composing: s } = t, { selection: o, doc: l } = i, { ranges: a } = o, c = Math.min(...a.map((d) => d.$from.pos)), u = Math.max(...a.map((d) => d.$to.pos)), h = r && r.doc.eq(l) && r.selection.eq(o);
      if (this.#t || ((this.#n ?? t.dom.parentElement ?? document.body).appendChild(this.element), this.#t = !0), s || h) return;
      if (!this.#s(t, r)) {
        this.hide();
        return;
      }
      $i({
        getBoundingClientRect: () => y1(t, c, u)
      }, this.element, {
        placement: "bottom-start",
        middleware: [Mm(), ml(this.#l), ...this.#e],
        ...this.#r
      }).then(({ x: d, y: p }) => {
        Object.assign(this.element.style, {
          left: `${d}px`,
          top: `${p}px`
        });
      }).catch(console.error), this.show();
    }, this.update = (t, r) => {
      this.#o(t, r);
    }, this.getContent = (t, r = (i) => i.type.name === "paragraph") => {
      const { selection: i } = t.state, { empty: s, $from: o } = i, l = t.state.selection instanceof Ee;
      if (typeof document > "u") return;
      const a = this.element.contains(document.activeElement), c = !t.hasFocus() && !a, u = !t.editable, f = !bV(r)(t.state.selection);
      if (!(c || u || !s || !l || f))
        return o.parent.textBetween(
          Math.max(0, o.parentOffset - 500),
          o.parentOffset,
          void 0,
          "￼"
        );
    }, this.destroy = () => {
      this.#o.cancel();
    }, this.show = () => {
      this.element.dataset.show = "true", this.onShow();
    }, this.hide = () => {
      this.element.dataset.show = "false", this.onHide();
    }, this.element = e.content, this.#a = e.debounce ?? 200, this.#s = e.shouldShow ?? this.#u, this.#i = e.trigger ?? "/", this.#l = e.offset, this.#e = e.middleware ?? [], this.#r = e.floatingUIOptions ?? {}, this.#n = e.root, this.#o = Qm(this.#c, this.#a);
  }
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  /// @internal
  #n;
  /// @internal
  #a;
  /// @internal
  #i;
  /// @internal
  #s;
  /// @internal
  #o;
  /// The offset to get the block. Default is 0.
  #l;
  #c;
  /// @internal
  #u(e) {
    const t = this.getContent(e);
    if (!t) return !1;
    const r = t.at(-1);
    return r ? Array.isArray(this.#i) ? this.#i.includes(r) : this.#i === r : !1;
  }
}
function BE(n) {
  var e, t, r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var i = n.length;
    for (e = 0; e < i; e++) n[e] && (t = BE(n[e])) && (r && (r += " "), r += t);
  } else for (t in n) n[t] && (r && (r += " "), r += t);
  return r;
}
function Hn() {
  for (var n, e, t = 0, r = "", i = arguments.length; t < i; t++) (n = arguments[t]) && (e = BE(n)) && (r && (r += " "), r += e);
  return r;
}
/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
const {
  entries: zE,
  setPrototypeOf: J8,
  isFrozen: lZ,
  getPrototypeOf: aZ,
  getOwnPropertyDescriptor: cZ
} = Object;
let {
  freeze: gr,
  seal: vi,
  create: FE
} = Object, {
  apply: m5,
  construct: g5
} = typeof Reflect < "u" && Reflect;
gr || (gr = function(e) {
  return e;
});
vi || (vi = function(e) {
  return e;
});
m5 || (m5 = function(e, t, r) {
  return e.apply(t, r);
});
g5 || (g5 = function(e, t) {
  return new e(...t);
});
const b0 = yr(Array.prototype.forEach), uZ = yr(Array.prototype.lastIndexOf), X8 = yr(Array.prototype.pop), Vu = yr(Array.prototype.push), hZ = yr(Array.prototype.splice), Cp = yr(String.prototype.toLowerCase), z2 = yr(String.prototype.toString), Z8 = yr(String.prototype.match), qu = yr(String.prototype.replace), fZ = yr(String.prototype.indexOf), dZ = yr(String.prototype.trim), Oi = yr(Object.prototype.hasOwnProperty), tr = yr(RegExp.prototype.test), Wu = pZ(TypeError);
function yr(n) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      r[i - 1] = arguments[i];
    return m5(n, e, r);
  };
}
function pZ(n) {
  return function() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return g5(n, t);
  };
}
function ot(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Cp;
  J8 && J8(n, null);
  let r = e.length;
  for (; r--; ) {
    let i = e[r];
    if (typeof i == "string") {
      const s = t(i);
      s !== i && (lZ(e) || (e[r] = s), i = s);
    }
    n[i] = !0;
  }
  return n;
}
function mZ(n) {
  for (let e = 0; e < n.length; e++)
    Oi(n, e) || (n[e] = null);
  return n;
}
function qs(n) {
  const e = FE(null);
  for (const [t, r] of zE(n))
    Oi(n, t) && (Array.isArray(r) ? e[t] = mZ(r) : r && typeof r == "object" && r.constructor === Object ? e[t] = qs(r) : e[t] = r);
  return e;
}
function ju(n, e) {
  for (; n !== null; ) {
    const r = cZ(n, e);
    if (r) {
      if (r.get)
        return yr(r.get);
      if (typeof r.value == "function")
        return yr(r.value);
    }
    n = aZ(n);
  }
  function t() {
    return null;
  }
  return t;
}
const Q8 = gr(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), F2 = gr(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), H2 = gr(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), gZ = gr(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), $2 = gr(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), yZ = gr(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), ek = gr(["#text"]), tk = gr(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), V2 = gr(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), nk = gr(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), v0 = gr(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), bZ = vi(/\{\{[\w\W]*|[\w\W]*\}\}/gm), vZ = vi(/<%[\w\W]*|[\w\W]*%>/gm), wZ = vi(/\$\{[\w\W]*/gm), xZ = vi(/^data-[\-\w.\u00B7-\uFFFF]+$/), kZ = vi(/^aria-[\-\w]+$/), HE = vi(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), SZ = vi(/^(?:\w+script|data):/i), CZ = vi(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), $E = vi(/^html$/i), MZ = vi(/^[a-z][.\w]*(-[.\w]+)+$/i);
var rk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: kZ,
  ATTR_WHITESPACE: CZ,
  CUSTOM_ELEMENT: MZ,
  DATA_ATTR: xZ,
  DOCTYPE_NAME: $E,
  ERB_EXPR: vZ,
  IS_ALLOWED_URI: HE,
  IS_SCRIPT_OR_DATA: SZ,
  MUSTACHE_EXPR: bZ,
  TMPLIT_EXPR: wZ
});
const Uu = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, TZ = function() {
  return typeof window > "u" ? null : window;
}, AZ = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let r = null;
  const i = "data-tt-policy-suffix";
  t && t.hasAttribute(i) && (r = t.getAttribute(i));
  const s = "dompurify" + (r ? "#" + r : "");
  try {
    return e.createPolicy(s, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
}, ik = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function VE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : TZ();
  const e = (Re) => VE(Re);
  if (e.version = "3.2.6", e.removed = [], !n || !n.document || n.document.nodeType !== Uu.document || !n.Element)
    return e.isSupported = !1, e;
  let {
    document: t
  } = n;
  const r = t, i = r.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: o,
    Node: l,
    Element: a,
    NodeFilter: c,
    NamedNodeMap: u = n.NamedNodeMap || n.MozNamedAttrMap,
    HTMLFormElement: h,
    DOMParser: f,
    trustedTypes: d
  } = n, p = a.prototype, m = ju(p, "cloneNode"), g = ju(p, "remove"), b = ju(p, "nextSibling"), w = ju(p, "childNodes"), k = ju(p, "parentNode");
  if (typeof o == "function") {
    const Re = t.createElement("template");
    Re.content && Re.content.ownerDocument && (t = Re.content.ownerDocument);
  }
  let C, M = "";
  const {
    implementation: T,
    createNodeIterator: N,
    createDocumentFragment: B,
    getElementsByTagName: $
  } = t, {
    importNode: R
  } = r;
  let V = ik();
  e.isSupported = typeof zE == "function" && typeof k == "function" && T && T.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: z,
    ERB_EXPR: ue,
    TMPLIT_EXPR: ie,
    DATA_ATTR: he,
    ARIA_ATTR: Se,
    IS_SCRIPT_OR_DATA: ge,
    ATTR_WHITESPACE: ye,
    CUSTOM_ELEMENT: ze
  } = rk;
  let {
    IS_ALLOWED_URI: I
  } = rk, Ie = null;
  const Ve = ot({}, [...Q8, ...F2, ...H2, ...$2, ...ek]);
  let O = null;
  const dt = ot({}, [...tk, ...V2, ...nk, ...v0]);
  let Ue = Object.seal(FE(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), et = null, Ct = null, Ft = !0, sn = !0, Gt = !1, _r = !0, E = !1, P = !0, W = !1, Q = !1, J = !1, Y = !1, ae = !1, re = !1, oe = !0, te = !1;
  const De = "user-content-";
  let de = !0, Te = !1, Pe = {}, F = null;
  const X = ot({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let pe = null;
  const _e = ot({}, ["audio", "video", "img", "source", "image", "track"]);
  let je = null;
  const xt = ot({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Rt = "http://www.w3.org/1998/Math/MathML", Yt = "http://www.w3.org/2000/svg", on = "http://www.w3.org/1999/xhtml";
  let wt = on, pt = !1, Vn = null;
  const En = ot({}, [Rt, Yt, on], z2);
  let El = ot({}, ["mi", "mo", "mn", "ms", "mtext"]), Il = ot({}, ["annotation-xml"]);
  const Fd = ot({}, ["title", "style", "font", "a", "script"]);
  let To = null;
  const Hd = ["application/xhtml+xml", "text/html"], $d = "text/html";
  let ln = null, _s = null;
  const Vd = t.createElement("form"), bu = function(L) {
    return L instanceof RegExp || L instanceof Function;
  }, qa = function() {
    let L = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(_s && _s === L)) {
      if ((!L || typeof L != "object") && (L = {}), L = qs(L), To = // eslint-disable-next-line unicorn/prefer-includes
      Hd.indexOf(L.PARSER_MEDIA_TYPE) === -1 ? $d : L.PARSER_MEDIA_TYPE, ln = To === "application/xhtml+xml" ? z2 : Cp, Ie = Oi(L, "ALLOWED_TAGS") ? ot({}, L.ALLOWED_TAGS, ln) : Ve, O = Oi(L, "ALLOWED_ATTR") ? ot({}, L.ALLOWED_ATTR, ln) : dt, Vn = Oi(L, "ALLOWED_NAMESPACES") ? ot({}, L.ALLOWED_NAMESPACES, z2) : En, je = Oi(L, "ADD_URI_SAFE_ATTR") ? ot(qs(xt), L.ADD_URI_SAFE_ATTR, ln) : xt, pe = Oi(L, "ADD_DATA_URI_TAGS") ? ot(qs(_e), L.ADD_DATA_URI_TAGS, ln) : _e, F = Oi(L, "FORBID_CONTENTS") ? ot({}, L.FORBID_CONTENTS, ln) : X, et = Oi(L, "FORBID_TAGS") ? ot({}, L.FORBID_TAGS, ln) : qs({}), Ct = Oi(L, "FORBID_ATTR") ? ot({}, L.FORBID_ATTR, ln) : qs({}), Pe = Oi(L, "USE_PROFILES") ? L.USE_PROFILES : !1, Ft = L.ALLOW_ARIA_ATTR !== !1, sn = L.ALLOW_DATA_ATTR !== !1, Gt = L.ALLOW_UNKNOWN_PROTOCOLS || !1, _r = L.ALLOW_SELF_CLOSE_IN_ATTR !== !1, E = L.SAFE_FOR_TEMPLATES || !1, P = L.SAFE_FOR_XML !== !1, W = L.WHOLE_DOCUMENT || !1, Y = L.RETURN_DOM || !1, ae = L.RETURN_DOM_FRAGMENT || !1, re = L.RETURN_TRUSTED_TYPE || !1, J = L.FORCE_BODY || !1, oe = L.SANITIZE_DOM !== !1, te = L.SANITIZE_NAMED_PROPS || !1, de = L.KEEP_CONTENT !== !1, Te = L.IN_PLACE || !1, I = L.ALLOWED_URI_REGEXP || HE, wt = L.NAMESPACE || on, El = L.MATHML_TEXT_INTEGRATION_POINTS || El, Il = L.HTML_INTEGRATION_POINTS || Il, Ue = L.CUSTOM_ELEMENT_HANDLING || {}, L.CUSTOM_ELEMENT_HANDLING && bu(L.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ue.tagNameCheck = L.CUSTOM_ELEMENT_HANDLING.tagNameCheck), L.CUSTOM_ELEMENT_HANDLING && bu(L.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ue.attributeNameCheck = L.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), L.CUSTOM_ELEMENT_HANDLING && typeof L.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Ue.allowCustomizedBuiltInElements = L.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), E && (sn = !1), ae && (Y = !0), Pe && (Ie = ot({}, ek), O = [], Pe.html === !0 && (ot(Ie, Q8), ot(O, tk)), Pe.svg === !0 && (ot(Ie, F2), ot(O, V2), ot(O, v0)), Pe.svgFilters === !0 && (ot(Ie, H2), ot(O, V2), ot(O, v0)), Pe.mathMl === !0 && (ot(Ie, $2), ot(O, nk), ot(O, v0))), L.ADD_TAGS && (Ie === Ve && (Ie = qs(Ie)), ot(Ie, L.ADD_TAGS, ln)), L.ADD_ATTR && (O === dt && (O = qs(O)), ot(O, L.ADD_ATTR, ln)), L.ADD_URI_SAFE_ATTR && ot(je, L.ADD_URI_SAFE_ATTR, ln), L.FORBID_CONTENTS && (F === X && (F = qs(F)), ot(F, L.FORBID_CONTENTS, ln)), de && (Ie["#text"] = !0), W && ot(Ie, ["html", "head", "body"]), Ie.table && (ot(Ie, ["tbody"]), delete et.tbody), L.TRUSTED_TYPES_POLICY) {
        if (typeof L.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Wu('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof L.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Wu('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        C = L.TRUSTED_TYPES_POLICY, M = C.createHTML("");
      } else
        C === void 0 && (C = AZ(d, i)), C !== null && typeof M == "string" && (M = C.createHTML(""));
      gr && gr(L), _s = L;
    }
  }, vu = ot({}, [...F2, ...H2, ...gZ]), wu = ot({}, [...$2, ...yZ]), qd = function(L) {
    let le = k(L);
    (!le || !le.tagName) && (le = {
      namespaceURI: wt,
      tagName: "template"
    });
    const Oe = Cp(L.tagName), Mt = Cp(le.tagName);
    return Vn[L.namespaceURI] ? L.namespaceURI === Yt ? le.namespaceURI === on ? Oe === "svg" : le.namespaceURI === Rt ? Oe === "svg" && (Mt === "annotation-xml" || El[Mt]) : !!vu[Oe] : L.namespaceURI === Rt ? le.namespaceURI === on ? Oe === "math" : le.namespaceURI === Yt ? Oe === "math" && Il[Mt] : !!wu[Oe] : L.namespaceURI === on ? le.namespaceURI === Yt && !Il[Mt] || le.namespaceURI === Rt && !El[Mt] ? !1 : !wu[Oe] && (Fd[Oe] || !vu[Oe]) : !!(To === "application/xhtml+xml" && Vn[L.namespaceURI]) : !1;
  }, Lr = function(L) {
    Vu(e.removed, {
      element: L
    });
    try {
      k(L).removeChild(L);
    } catch {
      g(L);
    }
  }, Ls = function(L, le) {
    try {
      Vu(e.removed, {
        attribute: le.getAttributeNode(L),
        from: le
      });
    } catch {
      Vu(e.removed, {
        attribute: null,
        from: le
      });
    }
    if (le.removeAttribute(L), L === "is")
      if (Y || ae)
        try {
          Lr(le);
        } catch {
        }
      else
        try {
          le.setAttribute(L, "");
        } catch {
        }
  }, xu = function(L) {
    let le = null, Oe = null;
    if (J)
      L = "<remove></remove>" + L;
    else {
      const tn = Z8(L, /^[\r\n\t ]+/);
      Oe = tn && tn[0];
    }
    To === "application/xhtml+xml" && wt === on && (L = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + L + "</body></html>");
    const Mt = C ? C.createHTML(L) : L;
    if (wt === on)
      try {
        le = new f().parseFromString(Mt, To);
      } catch {
      }
    if (!le || !le.documentElement) {
      le = T.createDocument(wt, "template", null);
      try {
        le.documentElement.innerHTML = pt ? M : Mt;
      } catch {
      }
    }
    const bn = le.body || le.documentElement;
    return L && Oe && bn.insertBefore(t.createTextNode(Oe), bn.childNodes[0] || null), wt === on ? $.call(le, W ? "html" : "body")[0] : W ? le.documentElement : bn;
  }, ku = function(L) {
    return N.call(
      L.ownerDocument || L,
      L,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, Wa = function(L) {
    return L instanceof h && (typeof L.nodeName != "string" || typeof L.textContent != "string" || typeof L.removeChild != "function" || !(L.attributes instanceof u) || typeof L.removeAttribute != "function" || typeof L.setAttribute != "function" || typeof L.namespaceURI != "string" || typeof L.insertBefore != "function" || typeof L.hasChildNodes != "function");
  }, Su = function(L) {
    return typeof l == "function" && L instanceof l;
  };
  function ni(Re, L, le) {
    b0(Re, (Oe) => {
      Oe.call(e, L, le, _s);
    });
  }
  const Cu = function(L) {
    let le = null;
    if (ni(V.beforeSanitizeElements, L, null), Wa(L))
      return Lr(L), !0;
    const Oe = ln(L.nodeName);
    if (ni(V.uponSanitizeElement, L, {
      tagName: Oe,
      allowedTags: Ie
    }), P && L.hasChildNodes() && !Su(L.firstElementChild) && tr(/<[/\w!]/g, L.innerHTML) && tr(/<[/\w!]/g, L.textContent) || L.nodeType === Uu.progressingInstruction || P && L.nodeType === Uu.comment && tr(/<[/\w]/g, L.data))
      return Lr(L), !0;
    if (!Ie[Oe] || et[Oe]) {
      if (!et[Oe] && Tu(Oe) && (Ue.tagNameCheck instanceof RegExp && tr(Ue.tagNameCheck, Oe) || Ue.tagNameCheck instanceof Function && Ue.tagNameCheck(Oe)))
        return !1;
      if (de && !F[Oe]) {
        const Mt = k(L) || L.parentNode, bn = w(L) || L.childNodes;
        if (bn && Mt) {
          const tn = bn.length;
          for (let In = tn - 1; In >= 0; --In) {
            const ri = m(bn[In], !0);
            ri.__removalCount = (L.__removalCount || 0) + 1, Mt.insertBefore(ri, b(L));
          }
        }
      }
      return Lr(L), !0;
    }
    return L instanceof a && !qd(L) || (Oe === "noscript" || Oe === "noembed" || Oe === "noframes") && tr(/<\/no(script|embed|frames)/i, L.innerHTML) ? (Lr(L), !0) : (E && L.nodeType === Uu.text && (le = L.textContent, b0([z, ue, ie], (Mt) => {
      le = qu(le, Mt, " ");
    }), L.textContent !== le && (Vu(e.removed, {
      element: L.cloneNode()
    }), L.textContent = le)), ni(V.afterSanitizeElements, L, null), !1);
  }, Mu = function(L, le, Oe) {
    if (oe && (le === "id" || le === "name") && (Oe in t || Oe in Vd))
      return !1;
    if (!(sn && !Ct[le] && tr(he, le))) {
      if (!(Ft && tr(Se, le))) {
        if (!O[le] || Ct[le]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(Tu(L) && (Ue.tagNameCheck instanceof RegExp && tr(Ue.tagNameCheck, L) || Ue.tagNameCheck instanceof Function && Ue.tagNameCheck(L)) && (Ue.attributeNameCheck instanceof RegExp && tr(Ue.attributeNameCheck, le) || Ue.attributeNameCheck instanceof Function && Ue.attributeNameCheck(le)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            le === "is" && Ue.allowCustomizedBuiltInElements && (Ue.tagNameCheck instanceof RegExp && tr(Ue.tagNameCheck, Oe) || Ue.tagNameCheck instanceof Function && Ue.tagNameCheck(Oe)))
          ) return !1;
        } else if (!je[le]) {
          if (!tr(I, qu(Oe, ye, ""))) {
            if (!((le === "src" || le === "xlink:href" || le === "href") && L !== "script" && fZ(Oe, "data:") === 0 && pe[L])) {
              if (!(Gt && !tr(ge, qu(Oe, ye, "")))) {
                if (Oe)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Tu = function(L) {
    return L !== "annotation-xml" && Z8(L, ze);
  }, Au = function(L) {
    ni(V.beforeSanitizeAttributes, L, null);
    const {
      attributes: le
    } = L;
    if (!le || Wa(L))
      return;
    const Oe = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: O,
      forceKeepAttr: void 0
    };
    let Mt = le.length;
    for (; Mt--; ) {
      const bn = le[Mt], {
        name: tn,
        namespaceURI: In,
        value: ri
      } = bn, Ao = ln(tn), ja = ri;
      let vn = tn === "value" ? ja : dZ(ja);
      if (Oe.attrName = Ao, Oe.attrValue = vn, Oe.keepAttr = !0, Oe.forceKeepAttr = void 0, ni(V.uponSanitizeAttribute, L, Oe), vn = Oe.attrValue, te && (Ao === "id" || Ao === "name") && (Ls(tn, L), vn = De + vn), P && tr(/((--!?|])>)|<\/(style|title)/i, vn)) {
        Ls(tn, L);
        continue;
      }
      if (Oe.forceKeepAttr)
        continue;
      if (!Oe.keepAttr) {
        Ls(tn, L);
        continue;
      }
      if (!_r && tr(/\/>/i, vn)) {
        Ls(tn, L);
        continue;
      }
      E && b0([z, ue, ie], (Eu) => {
        vn = qu(vn, Eu, " ");
      });
      const Ou = ln(L.nodeName);
      if (!Mu(Ou, Ao, vn)) {
        Ls(tn, L);
        continue;
      }
      if (C && typeof d == "object" && typeof d.getAttributeType == "function" && !In)
        switch (d.getAttributeType(Ou, Ao)) {
          case "TrustedHTML": {
            vn = C.createHTML(vn);
            break;
          }
          case "TrustedScriptURL": {
            vn = C.createScriptURL(vn);
            break;
          }
        }
      if (vn !== ja)
        try {
          In ? L.setAttributeNS(In, tn, vn) : L.setAttribute(tn, vn), Wa(L) ? Lr(L) : X8(e.removed);
        } catch {
          Ls(tn, L);
        }
    }
    ni(V.afterSanitizeAttributes, L, null);
  }, Wd = function Re(L) {
    let le = null;
    const Oe = ku(L);
    for (ni(V.beforeSanitizeShadowDOM, L, null); le = Oe.nextNode(); )
      ni(V.uponSanitizeShadowNode, le, null), Cu(le), Au(le), le.content instanceof s && Re(le.content);
    ni(V.afterSanitizeShadowDOM, L, null);
  };
  return e.sanitize = function(Re) {
    let L = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, le = null, Oe = null, Mt = null, bn = null;
    if (pt = !Re, pt && (Re = "<!-->"), typeof Re != "string" && !Su(Re))
      if (typeof Re.toString == "function") {
        if (Re = Re.toString(), typeof Re != "string")
          throw Wu("dirty is not a string, aborting");
      } else
        throw Wu("toString is not a function");
    if (!e.isSupported)
      return Re;
    if (Q || qa(L), e.removed = [], typeof Re == "string" && (Te = !1), Te) {
      if (Re.nodeName) {
        const ri = ln(Re.nodeName);
        if (!Ie[ri] || et[ri])
          throw Wu("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Re instanceof l)
      le = xu("<!---->"), Oe = le.ownerDocument.importNode(Re, !0), Oe.nodeType === Uu.element && Oe.nodeName === "BODY" || Oe.nodeName === "HTML" ? le = Oe : le.appendChild(Oe);
    else {
      if (!Y && !E && !W && // eslint-disable-next-line unicorn/prefer-includes
      Re.indexOf("<") === -1)
        return C && re ? C.createHTML(Re) : Re;
      if (le = xu(Re), !le)
        return Y ? null : re ? M : "";
    }
    le && J && Lr(le.firstChild);
    const tn = ku(Te ? Re : le);
    for (; Mt = tn.nextNode(); )
      Cu(Mt), Au(Mt), Mt.content instanceof s && Wd(Mt.content);
    if (Te)
      return Re;
    if (Y) {
      if (ae)
        for (bn = B.call(le.ownerDocument); le.firstChild; )
          bn.appendChild(le.firstChild);
      else
        bn = le;
      return (O.shadowroot || O.shadowrootmode) && (bn = R.call(r, bn, !0)), bn;
    }
    let In = W ? le.outerHTML : le.innerHTML;
    return W && Ie["!doctype"] && le.ownerDocument && le.ownerDocument.doctype && le.ownerDocument.doctype.name && tr($E, le.ownerDocument.doctype.name) && (In = "<!DOCTYPE " + le.ownerDocument.doctype.name + `>
` + In), E && b0([z, ue, ie], (ri) => {
      In = qu(In, ri, " ");
    }), C && re ? C.createHTML(In) : In;
  }, e.setConfig = function() {
    let Re = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    qa(Re), Q = !0;
  }, e.clearConfig = function() {
    _s = null, Q = !1;
  }, e.isValidAttribute = function(Re, L, le) {
    _s || qa({});
    const Oe = ln(Re), Mt = ln(L);
    return Mu(Oe, Mt, le);
  }, e.addHook = function(Re, L) {
    typeof L == "function" && Vu(V[Re], L);
  }, e.removeHook = function(Re, L) {
    if (L !== void 0) {
      const le = uZ(V[Re], L);
      return le === -1 ? void 0 : hZ(V[Re], le, 1)[0];
    }
    return X8(V[Re]);
  }, e.removeHooks = function(Re) {
    V[Re] = [];
  }, e.removeAllHooks = function() {
    V = ik();
  }, e;
}
var Ui = VE();
function Wc({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
Wc.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
let OZ = (n) => crypto.getRandomValues(new Uint8Array(n)), EZ = (n, e, t) => {
  let r = (2 << Math.log2(n.length - 1)) - 1, i = -~(1.6 * r * e / n.length);
  return (s = e) => {
    let o = "";
    for (; ; ) {
      let l = t(i), a = i | 0;
      for (; a--; )
        if (o += n[l[a] & r] || "", o.length >= s) return o;
    }
  };
}, qE = (n, e = 21) => EZ(n, e | 0, OZ);
var IZ = Object.defineProperty, sk = Object.getOwnPropertySymbols, DZ = Object.prototype.hasOwnProperty, NZ = Object.prototype.propertyIsEnumerable, ok = (n, e, t) => e in n ? IZ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, RZ = (n, e) => {
  for (var t in e || (e = {}))
    DZ.call(e, t) && ok(n, t, e[t]);
  if (sk)
    for (var t of sk(e))
      NZ.call(e, t) && ok(n, t, e[t]);
  return n;
};
function Td(n, e) {
  return Object.assign(n, {
    meta: RZ({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const PZ = {
  imageIcon: "🌌",
  captionIcon: "💬",
  uploadButton: "Upload file",
  confirmButton: "Confirm ⏎",
  uploadPlaceholderText: "or paste the image link ...",
  captionPlaceholderText: "Image caption",
  onUpload: (n) => Promise.resolve(URL.createObjectURL(n))
}, G1 = St(
  PZ,
  "imageBlockConfigCtx"
);
Td(G1, {
  displayName: "Config<image-block>",
  group: "ImageBlock"
});
function _Z(n) {
  return Sl(
    n,
    "paragraph",
    (e, t, r) => {
      var i, s;
      if (((i = e.children) == null ? void 0 : i.length) !== 1) return;
      const o = (s = e.children) == null ? void 0 : s[0];
      if (!o || o.type !== "image") return;
      const { url: l, alt: a, title: c } = o, u = {
        type: "image-block",
        url: l,
        alt: a,
        title: c
      };
      r.children.splice(t, 1, u);
    }
  );
}
const Sv = As(
  "remark-image-block",
  () => () => _Z
);
Td(Sv.plugin, {
  displayName: "Remark<remarkImageBlock>",
  group: "ImageBlock"
});
Td(Sv.options, {
  displayName: "RemarkConfig<remarkImageBlock>",
  group: "ImageBlock"
});
var LZ = Object.defineProperty, lk = Object.getOwnPropertySymbols, BZ = Object.prototype.hasOwnProperty, zZ = Object.prototype.propertyIsEnumerable, ak = (n, e, t) => e in n ? LZ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, FZ = (n, e) => {
  for (var t in e || (e = {}))
    BZ.call(e, t) && ak(n, t, e[t]);
  if (lk)
    for (var t of lk(e))
      zZ.call(e, t) && ak(n, t, e[t]);
  return n;
};
const y5 = "image-block", Y1 = hn("image-block", () => ({
  inline: !1,
  group: "block",
  selectable: !0,
  draggable: !0,
  isolating: !0,
  marks: "",
  atom: !0,
  priority: 100,
  attrs: {
    src: { default: "", validate: "string" },
    caption: { default: "", validate: "string" },
    ratio: { default: 1, validate: "number" }
  },
  parseDOM: [
    {
      tag: `img[data-type="${y5}"]`,
      getAttrs: (n) => {
        var e;
        if (!(n instanceof HTMLElement)) throw Vi(n);
        return {
          src: n.getAttribute("src") || "",
          caption: n.getAttribute("caption") || "",
          ratio: Number((e = n.getAttribute("ratio")) != null ? e : 1)
        };
      }
    }
  ],
  toDOM: (n) => ["img", FZ({ "data-type": y5 }, n.attrs)],
  parseMarkdown: {
    match: ({ type: n }) => n === "image-block",
    runner: (n, e, t) => {
      const r = e.url, i = e.title;
      let s = Number(e.alt || 1);
      (Number.isNaN(s) || s === 0) && (s = 1), n.addNode(t, {
        src: r,
        caption: i,
        ratio: s
      });
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "image-block",
    runner: (n, e) => {
      n.openNode("paragraph"), n.addNode("image", void 0, void 0, {
        title: e.attrs.caption,
        url: e.attrs.src,
        alt: `${Number.parseFloat(e.attrs.ratio).toFixed(2)}`
      }), n.closeNode();
    }
  }
}));
Td(Y1.node, {
  displayName: "NodeSchema<image-block>",
  group: "ImageBlock"
});
function ff({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
ff.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const HZ = qE("abcdefg", 8), $Z = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setLink: {
      type: Function,
      required: !0
    },
    imageIcon: {
      type: String,
      required: !1
    },
    uploadButton: {
      type: String,
      required: !1
    },
    confirmButton: {
      type: String,
      required: !1
    },
    uploadPlaceholderText: {
      type: String,
      required: !1
    },
    onUpload: {
      type: Function,
      required: !0
    }
  },
  setup({
    readonly: n,
    src: e,
    setLink: t,
    onUpload: r,
    imageIcon: i,
    uploadButton: s,
    confirmButton: o,
    uploadPlaceholderText: l,
    className: a
  }) {
    var c, u;
    const h = Ae(!1), f = Ae(), d = Ae((c = e.value) != null ? c : ""), p = Ae(HZ()), m = Ae(((u = e.value) == null ? void 0 : u.length) !== 0), g = (C) => {
      const T = C.target.value;
      m.value = T.length !== 0, d.value = T;
    }, b = (C) => {
      var M, T;
      C.key === "Enter" && t((T = (M = f.value) == null ? void 0 : M.value) != null ? T : "");
    }, w = () => {
      var C, M;
      t((M = (C = f.value) == null ? void 0 : C.value) != null ? M : "");
    }, k = (C) => {
      var M;
      const T = (M = C.target.files) == null ? void 0 : M[0];
      T && r(T).then((N) => {
        N && (t(N), m.value = !0);
      }).catch((N) => {
        console.error("An error occurred while uploading image"), console.error(N);
      });
    };
    return () => /* @__PURE__ */ j("div", { class: Hn("image-edit", a) }, /* @__PURE__ */ j(ff, { icon: i, class: "image-icon" }), /* @__PURE__ */ j("div", { class: Hn("link-importer", h.value && "focus") }, /* @__PURE__ */ j(
      "input",
      {
        ref: f,
        draggable: "true",
        onDragstart: (C) => {
          C.preventDefault(), C.stopPropagation();
        },
        disabled: n.value,
        class: "link-input-area",
        value: d.value,
        onInput: g,
        onKeydown: b,
        onFocus: () => h.value = !0,
        onBlur: () => h.value = !1
      }
    ), !m.value && /* @__PURE__ */ j("div", { class: "placeholder" }, /* @__PURE__ */ j(
      "input",
      {
        disabled: n.value,
        class: "hidden",
        id: p.value,
        type: "file",
        accept: "image/*",
        onChange: k
      }
    ), /* @__PURE__ */ j("label", { class: "uploader", for: p.value }, /* @__PURE__ */ j(ff, { icon: s })), /* @__PURE__ */ j("span", { class: "text", onClick: () => {
      var C;
      return (C = f.value) == null ? void 0 : C.focus();
    } }, l))), d.value && /* @__PURE__ */ j("div", { class: "confirm", onClick: () => w() }, /* @__PURE__ */ j(ff, { icon: o })));
  }
}), VZ = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    caption: {
      type: Object,
      required: !0
    },
    ratio: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup({ src: n, caption: e, ratio: t, readonly: r, setAttr: i, config: s }) {
    var o;
    const l = Ae(), a = Ae(), c = Ae(!!((o = e.value) != null && o.length)), u = Ae(0), h = () => {
      var w;
      const k = l.value;
      if (!k) return;
      const C = k.closest(".milkdown-image-block");
      if (!C) return;
      const M = C.getBoundingClientRect().width;
      if (!M) return;
      const T = k.height, N = k.width, B = N < M ? T : M * (T / N), $ = (B * ((w = t.value) != null ? w : 1)).toFixed(2);
      k.dataset.origin = B.toFixed(2), k.dataset.height = $, k.style.height = `${$}px`;
    }, f = (w) => {
      w.preventDefault(), w.stopPropagation(), !r.value && (c.value = !c.value);
    }, d = (w) => {
      const C = w.target.value;
      u.value && window.clearTimeout(u.value), u.value = window.setTimeout(() => {
        i("caption", C);
      }, 1e3);
    }, p = (w) => {
      const C = w.target.value;
      u.value && (window.clearTimeout(u.value), u.value = 0), i("caption", C);
    }, m = (w) => {
      w.preventDefault();
      const k = l.value;
      if (!k) return;
      const C = k.getBoundingClientRect().top, M = w.clientY - C, T = Number(M < 100 ? 100 : M).toFixed(2);
      k.dataset.height = T, k.style.height = `${T}px`;
    }, g = () => {
      window.removeEventListener("pointermove", m), window.removeEventListener("pointerup", g);
      const w = l.value;
      if (!w) return;
      const k = Number(w.dataset.origin), C = Number(w.dataset.height), M = Number.parseFloat(
        Number(C / k).toFixed(2)
      );
      Number.isNaN(M) || i("ratio", M);
    }, b = (w) => {
      r.value || (w.preventDefault(), w.stopPropagation(), window.addEventListener("pointermove", m), window.addEventListener("pointerup", g));
    };
    return () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("div", { class: "image-wrapper" }, /* @__PURE__ */ j("div", { class: "operation" }, /* @__PURE__ */ j("div", { class: "operation-item", onPointerdown: f }, /* @__PURE__ */ j(ff, { icon: s.captionIcon }))), /* @__PURE__ */ j(
      "img",
      {
        ref: l,
        "data-type": y5,
        onLoad: h,
        src: n.value,
        alt: e.value
      }
    ), /* @__PURE__ */ j(
      "div",
      {
        ref: a,
        class: "image-resize-handle",
        onPointerdown: b
      }
    )), c.value && /* @__PURE__ */ j(
      "input",
      {
        draggable: "true",
        onDragstart: (w) => {
          w.preventDefault(), w.stopPropagation();
        },
        class: "caption-input",
        placeholder: s?.captionPlaceholderText,
        onInput: d,
        onBlur: p,
        value: e.value
      }
    ));
  }
});
var qZ = Object.defineProperty, ck = Object.getOwnPropertySymbols, WZ = Object.prototype.hasOwnProperty, jZ = Object.prototype.propertyIsEnumerable, uk = (n, e, t) => e in n ? qZ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, UZ = (n, e) => {
  for (var t in e || (e = {}))
    WZ.call(e, t) && uk(n, t, e[t]);
  if (ck)
    for (var t of ck(e))
      jZ.call(e, t) && uk(n, t, e[t]);
  return n;
};
const KZ = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    caption: {
      type: Object,
      required: !0
    },
    ratio: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { src: e } = n;
    return () => {
      var t;
      return (t = e.value) != null && t.length ? /* @__PURE__ */ j(VZ, UZ({}, n)) : /* @__PURE__ */ j(
        $Z,
        {
          src: n.src,
          selected: n.selected,
          readonly: n.readonly,
          setLink: (r) => n.setAttr("src", r),
          imageIcon: n.config.imageIcon,
          uploadButton: n.config.uploadButton,
          confirmButton: n.config.confirmButton,
          uploadPlaceholderText: n.config.uploadPlaceholderText,
          onUpload: n.config.onUpload
        }
      );
    };
  }
}), WE = yd(
  Y1.node,
  (n) => (e, t, r) => {
    const i = Ae(e.attrs.src), s = Ae(e.attrs.caption), o = Ae(e.attrs.ratio), l = Ae(!1), a = Ae(!t.editable), c = (g, b) => {
      if (!t.editable) return;
      const w = r();
      w != null && t.dispatch(
        t.state.tr.setNodeAttribute(
          w,
          g,
          g === "src" ? Ui.sanitize(b) : b
        )
      );
    }, u = n.get(G1.key), h = ji(KZ, {
      src: i,
      caption: s,
      ratio: o,
      selected: l,
      readonly: a,
      setAttr: c,
      config: u
    }), f = document.createElement("div");
    f.className = "milkdown-image-block", h.mount(f);
    const d = cu(() => {
      l.value ? f.classList.add("selected") : f.classList.remove("selected");
    }), p = u.proxyDomURL, m = (g) => {
      if (!p)
        i.value = g.attrs.src;
      else {
        const b = p(g.attrs.src);
        typeof b == "string" ? i.value = b : b.then((w) => {
          i.value = w;
        }).catch(console.error);
      }
      o.value = g.attrs.ratio, s.value = g.attrs.caption, a.value = !t.editable;
    };
    return m(e), {
      dom: f,
      update: (g) => g.type !== e.type ? !1 : (m(g), !0),
      stopEvent: (g) => g.target instanceof HTMLInputElement,
      selectNode: () => {
        l.value = !0;
      },
      deselectNode: () => {
        l.value = !1;
      },
      destroy: () => {
        d(), h.unmount(), f.remove();
      }
    };
  }
);
Td(WE, {
  displayName: "NodeView<image-block>",
  group: "ImageBlock"
});
const GZ = [
  Sv,
  Y1,
  WE,
  G1
].flat();
var b5, v5;
if (typeof WeakMap < "u") {
  let n = /* @__PURE__ */ new WeakMap();
  b5 = (e) => n.get(e), v5 = (e, t) => (n.set(e, t), t);
} else {
  const n = [];
  let t = 0;
  b5 = (r) => {
    for (let i = 0; i < n.length; i += 2)
      if (n[i] == r) return n[i + 1];
  }, v5 = (r, i) => (t == 10 && (t = 0), n[t++] = r, n[t++] = i);
}
var vt = class {
  constructor(n, e, t, r) {
    this.width = n, this.height = e, this.map = t, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(n) {
    for (let e = 0; e < this.map.length; e++) {
      const t = this.map[e];
      if (t != n) continue;
      const r = e % this.width, i = e / this.width | 0;
      let s = r + 1, o = i + 1;
      for (let l = 1; s < this.width && this.map[e + l] == t; l++)
        s++;
      for (let l = 1; o < this.height && this.map[e + this.width * l] == t; l++)
        o++;
      return { left: r, top: i, right: s, bottom: o };
    }
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(n) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == n)
        return e % this.width;
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(n, e, t) {
    const { left: r, right: i, top: s, bottom: o } = this.findCell(n);
    return e == "horiz" ? (t < 0 ? r == 0 : i == this.width) ? null : this.map[s * this.width + (t < 0 ? r - 1 : i)] : (t < 0 ? s == 0 : o == this.height) ? null : this.map[r + this.width * (t < 0 ? s - 1 : o)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(n, e) {
    const {
      left: t,
      right: r,
      top: i,
      bottom: s
    } = this.findCell(n), {
      left: o,
      right: l,
      top: a,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(t, o),
      top: Math.min(i, a),
      right: Math.max(r, l),
      bottom: Math.max(s, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(n) {
    const e = [], t = {};
    for (let r = n.top; r < n.bottom; r++)
      for (let i = n.left; i < n.right; i++) {
        const s = r * this.width + i, o = this.map[s];
        t[o] || (t[o] = !0, !(i == n.left && i && this.map[s - 1] == o || r == n.top && r && this.map[s - this.width] == o) && e.push(o));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(n, e, t) {
    for (let r = 0, i = 0; ; r++) {
      const s = i + t.child(r).nodeSize;
      if (r == n) {
        let o = e + n * this.width;
        const l = (n + 1) * this.width;
        for (; o < l && this.map[o] < i; ) o++;
        return o == l ? s - 1 : this.map[o];
      }
      i = s;
    }
  }
  // Find the table map for the given table node.
  static get(n) {
    return b5(n) || v5(n, YZ(n));
  }
};
function YZ(n) {
  if (n.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + n.type.name);
  const e = JZ(n), t = n.childCount, r = [];
  let i = 0, s = null;
  const o = [];
  for (let c = 0, u = e * t; c < u; c++) r[c] = 0;
  for (let c = 0, u = 0; c < t; c++) {
    const h = n.child(c);
    u++;
    for (let p = 0; ; p++) {
      for (; i < r.length && r[i] != 0; ) i++;
      if (p == h.childCount) break;
      const m = h.child(p), { colspan: g, rowspan: b, colwidth: w } = m.attrs;
      for (let k = 0; k < b; k++) {
        if (k + c >= t) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: b - k
          });
          break;
        }
        const C = i + k * e;
        for (let M = 0; M < g; M++) {
          r[C + M] == 0 ? r[C + M] = u : (s || (s = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: g - M
          });
          const T = w && w[M];
          if (T) {
            const N = (C + M) % e * 2, B = o[N];
            B == null || B != T && o[N + 1] == 1 ? (o[N] = T, o[N + 1] = 1) : B == T && o[N + 1]++;
          }
        }
      }
      i += g, u += m.nodeSize;
    }
    const f = (c + 1) * e;
    let d = 0;
    for (; i < f; ) r[i++] == 0 && d++;
    d && (s || (s = [])).push({ type: "missing", row: c, n: d }), u++;
  }
  (e === 0 || t === 0) && (s || (s = [])).push({ type: "zero_sized" });
  const l = new vt(e, t, r, s);
  let a = !1;
  for (let c = 0; !a && c < o.length; c += 2)
    o[c] != null && o[c + 1] < t && (a = !0);
  return a && XZ(l, o, n), l;
}
function JZ(n) {
  let e = -1, t = !1;
  for (let r = 0; r < n.childCount; r++) {
    const i = n.child(r);
    let s = 0;
    if (t)
      for (let o = 0; o < r; o++) {
        const l = n.child(o);
        for (let a = 0; a < l.childCount; a++) {
          const c = l.child(a);
          o + c.attrs.rowspan > r && (s += c.attrs.colspan);
        }
      }
    for (let o = 0; o < i.childCount; o++) {
      const l = i.child(o);
      s += l.attrs.colspan, l.attrs.rowspan > 1 && (t = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function XZ(n, e, t) {
  n.problems || (n.problems = []);
  const r = {};
  for (let i = 0; i < n.map.length; i++) {
    const s = n.map[i];
    if (r[s]) continue;
    r[s] = !0;
    const o = t.nodeAt(s);
    if (!o)
      throw new RangeError(`No cell with offset ${s} found`);
    let l = null;
    const a = o.attrs;
    for (let c = 0; c < a.colspan; c++) {
      const u = (i + c) % n.width, h = e[u * 2];
      h != null && (!a.colwidth || a.colwidth[c] != h) && ((l || (l = ZZ(a)))[c] = h);
    }
    l && n.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: l
    });
  }
}
function ZZ(n) {
  if (n.colwidth) return n.colwidth.slice();
  const e = [];
  for (let t = 0; t < n.colspan; t++) e.push(0);
  return e;
}
function hk(n, e) {
  if (typeof n == "string")
    return {};
  const t = n.getAttribute("data-colwidth"), r = t && /^\d+(,\d+)*$/.test(t) ? t.split(",").map((o) => Number(o)) : null, i = Number(n.getAttribute("colspan") || 1), s = {
    colspan: i,
    rowspan: Number(n.getAttribute("rowspan") || 1),
    colwidth: r && r.length == i ? r : null
  };
  for (const o in e) {
    const l = e[o].getFromDOM, a = l && l(n);
    a != null && (s[o] = a);
  }
  return s;
}
function fk(n, e) {
  const t = {};
  n.attrs.colspan != 1 && (t.colspan = n.attrs.colspan), n.attrs.rowspan != 1 && (t.rowspan = n.attrs.rowspan), n.attrs.colwidth && (t["data-colwidth"] = n.attrs.colwidth.join(","));
  for (const r in e) {
    const i = e[r].setDOMAttr;
    i && i(n.attrs[r], t);
  }
  return t;
}
function QZ(n) {
  if (n !== null) {
    if (!Array.isArray(n))
      throw new TypeError("colwidth must be null or an array");
    for (const e of n)
      if (typeof e != "number")
        throw new TypeError("colwidth must be null or an array of numbers");
  }
}
function eQ(n) {
  const e = n.cellAttributes || {}, t = {
    colspan: { default: 1, validate: "number" },
    rowspan: { default: 1, validate: "number" },
    colwidth: { default: null, validate: QZ }
  };
  for (const r in e)
    t[r] = {
      default: e[r].default,
      validate: e[r].validate
    };
  return {
    table: {
      content: "table_row+",
      tableRole: "table",
      isolating: !0,
      group: n.tableGroup,
      parseDOM: [{ tag: "table" }],
      toDOM() {
        return ["table", ["tbody", 0]];
      }
    },
    table_row: {
      content: "(table_cell | table_header)*",
      tableRole: "row",
      parseDOM: [{ tag: "tr" }],
      toDOM() {
        return ["tr", 0];
      }
    },
    table_cell: {
      content: n.cellContent,
      attrs: t,
      tableRole: "cell",
      isolating: !0,
      parseDOM: [
        { tag: "td", getAttrs: (r) => hk(r, e) }
      ],
      toDOM(r) {
        return ["td", fk(r, e), 0];
      }
    },
    table_header: {
      content: n.cellContent,
      attrs: t,
      tableRole: "header_cell",
      isolating: !0,
      parseDOM: [
        { tag: "th", getAttrs: (r) => hk(r, e) }
      ],
      toDOM(r) {
        return ["th", fk(r, e), 0];
      }
    }
  };
}
function wi(n) {
  let e = n.cached.tableNodeTypes;
  if (!e) {
    e = n.cached.tableNodeTypes = {};
    for (const t in n.nodes) {
      const r = n.nodes[t], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var Ko = new en("selectingCells");
function Ad(n) {
  for (let e = n.depth - 1; e > 0; e--)
    if (n.node(e).type.spec.tableRole == "row")
      return n.node(0).resolve(n.before(e + 1));
  return null;
}
function Si(n) {
  const e = n.selection.$head;
  for (let t = e.depth; t > 0; t--)
    if (e.node(t).type.spec.tableRole == "row") return !0;
  return !1;
}
function J1(n) {
  const e = n.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const t = Ad(e.$head) || tQ(e.$head);
  if (t)
    return t;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function tQ(n) {
  for (let e = n.nodeAfter, t = n.pos; e; e = e.firstChild, t++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return n.doc.resolve(t);
  }
  for (let e = n.nodeBefore, t = n.pos; e; e = e.lastChild, t--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return n.doc.resolve(t - e.nodeSize);
  }
}
function w5(n) {
  return n.parent.type.spec.tableRole == "row" && !!n.nodeAfter;
}
function nQ(n) {
  return n.node(0).resolve(n.pos + n.nodeAfter.nodeSize);
}
function Cv(n, e) {
  return n.depth == e.depth && n.pos >= e.start(-1) && n.pos <= e.end(-1);
}
function jE(n, e, t) {
  const r = n.node(-1), i = vt.get(r), s = n.start(-1), o = i.nextCell(n.pos - s, e, t);
  return o == null ? null : n.node(0).resolve(s + o);
}
function Na(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan - t };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, t), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function rQ(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan + t };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < t; i++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function iQ(n, e, t) {
  const r = wi(e.type.schema).header_cell;
  for (let i = 0; i < n.height; i++)
    if (e.nodeAt(n.map[t + i * n.width]).type != r)
      return !1;
  return !0;
}
var Dt = class Ws extends Ge {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, t = e) {
    const r = e.node(-1), i = vt.get(r), s = e.start(-1), o = i.rectBetween(
      e.pos - s,
      t.pos - s
    ), l = e.node(0), a = i.cellsInRect(o).filter((u) => u != t.pos - s);
    a.unshift(t.pos - s);
    const c = a.map((u) => {
      const h = r.nodeAt(u);
      if (!h)
        throw RangeError(`No cell with offset ${u} found`);
      const f = s + u + 1;
      return new hT(
        l.resolve(f),
        l.resolve(f + h.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = t;
  }
  map(e, t) {
    const r = e.resolve(t.map(this.$anchorCell.pos)), i = e.resolve(t.map(this.$headCell.pos));
    if (w5(r) && w5(i) && Cv(r, i)) {
      const s = this.$anchorCell.node(-1) != r.node(-1);
      return s && this.isRowSelection() ? Ws.rowSelection(r, i) : s && this.isColSelection() ? Ws.colSelection(r, i) : new Ws(r, i);
    }
    return Ee.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), t = vt.get(e), r = this.$anchorCell.start(-1), i = t.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), s = {}, o = [];
    for (let a = i.top; a < i.bottom; a++) {
      const c = [];
      for (let u = a * t.width + i.left, h = i.left; h < i.right; h++, u++) {
        const f = t.map[u];
        if (s[f]) continue;
        s[f] = !0;
        const d = t.findCell(f);
        let p = e.nodeAt(f);
        if (!p)
          throw RangeError(`No cell with offset ${f} found`);
        const m = i.left - d.left, g = d.right - i.right;
        if (m > 0 || g > 0) {
          let b = p.attrs;
          if (m > 0 && (b = Na(b, 0, m)), g > 0 && (b = Na(
            b,
            b.colspan - g,
            g
          )), d.left < i.left) {
            if (p = p.type.createAndFill(b), !p)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(b)}`
              );
          } else
            p = p.type.create(b, p.content);
        }
        if (d.top < i.top || d.bottom > i.bottom) {
          const b = {
            ...p.attrs,
            rowspan: Math.min(d.bottom, i.bottom) - Math.max(d.top, i.top)
          };
          d.top < i.top ? p = p.type.createAndFill(b) : p = p.type.create(b, p.content);
        }
        c.push(p);
      }
      o.push(e.child(a).copy(ce.from(c)));
    }
    const l = this.isColSelection() && this.isRowSelection() ? e : o;
    return new ve(ce.from(l), 1, 1);
  }
  replace(e, t = ve.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      const { $from: l, $to: a } = i[o], c = e.mapping.slice(r);
      e.replace(
        c.map(l.pos),
        c.map(a.pos),
        o ? ve.empty : t
      );
    }
    const s = Ge.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    s && e.setSelection(s);
  }
  replaceWith(e, t) {
    this.replace(e, new ve(ce.from(t), 0, 0));
  }
  forEachCell(e) {
    const t = this.$anchorCell.node(-1), r = vt.get(t), i = this.$anchorCell.start(-1), s = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let o = 0; o < s.length; o++)
      e(t.nodeAt(s[o]), i + s[o]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1);
    if (Math.min(e, t) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = t + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, t = e) {
    const r = e.node(-1), i = vt.get(r), s = e.start(-1), o = i.findCell(e.pos - s), l = i.findCell(t.pos - s), a = e.node(0);
    return o.top <= l.top ? (o.top > 0 && (e = a.resolve(s + i.map[o.left])), l.bottom < i.height && (t = a.resolve(
      s + i.map[i.width * (i.height - 1) + l.right - 1]
    ))) : (l.top > 0 && (t = a.resolve(s + i.map[l.left])), o.bottom < i.height && (e = a.resolve(
      s + i.map[i.width * (i.height - 1) + o.right - 1]
    ))), new Ws(e, t);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), t = vt.get(e), r = this.$anchorCell.start(-1), i = t.colCount(this.$anchorCell.pos - r), s = t.colCount(this.$headCell.pos - r);
    if (Math.min(i, s) > 0) return !1;
    const o = i + this.$anchorCell.nodeAfter.attrs.colspan, l = s + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(o, l) == t.width;
  }
  eq(e) {
    return e instanceof Ws && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, t = e) {
    const r = e.node(-1), i = vt.get(r), s = e.start(-1), o = i.findCell(e.pos - s), l = i.findCell(t.pos - s), a = e.node(0);
    return o.left <= l.left ? (o.left > 0 && (e = a.resolve(
      s + i.map[o.top * i.width]
    )), l.right < i.width && (t = a.resolve(
      s + i.map[i.width * (l.top + 1) - 1]
    ))) : (l.left > 0 && (t = a.resolve(s + i.map[l.top * i.width])), o.right < i.width && (e = a.resolve(
      s + i.map[i.width * (o.top + 1) - 1]
    ))), new Ws(e, t);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, t) {
    return new Ws(e.resolve(t.anchor), e.resolve(t.head));
  }
  static create(e, t, r = t) {
    return new Ws(e.resolve(t), e.resolve(r));
  }
  getBookmark() {
    return new sQ(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Dt.prototype.visible = !1;
Ge.jsonID("cell", Dt);
var sQ = class UE {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new UE(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const t = e.resolve(this.anchor), r = e.resolve(this.head);
    return t.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && r.index() < r.parent.childCount && Cv(t, r) ? new Dt(t, r) : Ge.near(r, 1);
  }
};
function oQ(n) {
  if (!(n.selection instanceof Dt)) return null;
  const e = [];
  return n.selection.forEachCell((t, r) => {
    e.push(
      mn.node(r, r + t.nodeSize, { class: "selectedCell" })
    );
  }), Ot.create(n.doc, e);
}
function lQ({ $from: n, $to: e }) {
  if (n.pos == e.pos || n.pos < e.pos - 6) return !1;
  let t = n.pos, r = e.pos, i = n.depth;
  for (; i >= 0 && !(n.after(i + 1) < n.end(i)); i--, t++)
    ;
  for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, r--)
    ;
  return t == r && /row|table/.test(n.node(i).type.spec.tableRole);
}
function aQ({ $from: n, $to: e }) {
  let t, r;
  for (let i = n.depth; i > 0; i--) {
    const s = n.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      t = s;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const s = e.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      r = s;
      break;
    }
  }
  return t !== r && e.parentOffset === 0;
}
function cQ(n, e, t) {
  const r = (e || n).selection, i = (e || n).doc;
  let s, o;
  if (r instanceof $e && (o = r.node.type.spec.tableRole)) {
    if (o == "cell" || o == "header_cell")
      s = Dt.create(i, r.from);
    else if (o == "row") {
      const l = i.resolve(r.from + 1);
      s = Dt.rowSelection(l, l);
    } else if (!t) {
      const l = vt.get(r.node), a = r.from + 1, c = a + l.map[l.width * l.height - 1];
      s = Dt.create(i, a + 1, c);
    }
  } else r instanceof Ee && lQ(r) ? s = Ee.create(i, r.from) : r instanceof Ee && aQ(r) && (s = Ee.create(i, r.$from.start(), r.$from.end()));
  return s && (e || (e = n.tr)).setSelection(s), e;
}
var uQ = new en("fix-tables");
function KE(n, e, t, r) {
  const i = n.childCount, s = e.childCount;
  e: for (let o = 0, l = 0; o < s; o++) {
    const a = e.child(o);
    for (let c = l, u = Math.min(i, o + 3); c < u; c++)
      if (n.child(c) == a) {
        l = c + 1, t += a.nodeSize;
        continue e;
      }
    r(a, t), l < i && n.child(l).sameMarkup(a) ? KE(n.child(l), a, t + 1, r) : a.nodesBetween(0, a.content.size, r, t + 1), t += a.nodeSize;
  }
}
function hQ(n, e) {
  let t;
  const r = (i, s) => {
    i.type.spec.tableRole == "table" && (t = fQ(n, i, s, t));
  };
  return e ? e.doc != n.doc && KE(e.doc, n.doc, 0, r) : n.doc.descendants(r), t;
}
function fQ(n, e, t, r) {
  const i = vt.get(e);
  if (!i.problems) return r;
  r || (r = n.tr);
  const s = [];
  for (let a = 0; a < i.height; a++) s.push(0);
  for (let a = 0; a < i.problems.length; a++) {
    const c = i.problems[a];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      const h = u.attrs;
      for (let f = 0; f < h.rowspan; f++) s[c.row + f] += c.n;
      r.setNodeMarkup(
        r.mapping.map(t + 1 + c.pos),
        null,
        Na(h, h.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      s[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const u = r.mapping.map(t);
      r.delete(u, u + e.nodeSize);
    }
  }
  let o, l;
  for (let a = 0; a < s.length; a++)
    s[a] && (o == null && (o = a), l = a);
  for (let a = 0, c = t + 1; a < i.height; a++) {
    const u = e.child(a), h = c + u.nodeSize, f = s[a];
    if (f > 0) {
      let d = "cell";
      u.firstChild && (d = u.firstChild.type.spec.tableRole);
      const p = [];
      for (let g = 0; g < f; g++) {
        const b = wi(n.schema)[d].createAndFill();
        b && p.push(b);
      }
      const m = (a == 0 || o == a - 1) && l == a ? c + 1 : h - 1;
      r.insert(r.mapping.map(m), p);
    }
    c = h;
  }
  return r.setMeta(uQ, { fixTables: !0 });
}
function Tl(n) {
  const e = n.selection, t = J1(n), r = t.node(-1), i = t.start(-1), s = vt.get(r);
  return { ...e instanceof Dt ? s.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : s.findCell(t.pos - i), tableStart: i, map: s, table: r };
}
function GE(n, { map: e, tableStart: t, table: r }, i) {
  let s = i > 0 ? -1 : 0;
  iQ(e, r, i + s) && (s = i == 0 || i == e.width ? null : 0);
  for (let o = 0; o < e.height; o++) {
    const l = o * e.width + i;
    if (i > 0 && i < e.width && e.map[l - 1] == e.map[l]) {
      const a = e.map[l], c = r.nodeAt(a);
      n.setNodeMarkup(
        n.mapping.map(t + a),
        null,
        rQ(c.attrs, i - e.colCount(a))
      ), o += c.attrs.rowspan - 1;
    } else {
      const a = s == null ? wi(r.type.schema).cell : r.nodeAt(e.map[l + s]).type, c = e.positionAt(o, i, r);
      n.insert(n.mapping.map(t + c), a.createAndFill());
    }
  }
  return n;
}
function dQ(n, e) {
  if (!Si(n)) return !1;
  if (e) {
    const t = Tl(n);
    e(GE(n.tr, t, t.left));
  }
  return !0;
}
function pQ(n, e) {
  if (!Si(n)) return !1;
  if (e) {
    const t = Tl(n);
    e(GE(n.tr, t, t.right));
  }
  return !0;
}
function mQ(n, { map: e, table: t, tableStart: r }, i) {
  const s = n.mapping.maps.length;
  for (let o = 0; o < e.height; ) {
    const l = o * e.width + i, a = e.map[l], c = t.nodeAt(a), u = c.attrs;
    if (i > 0 && e.map[l - 1] == a || i < e.width - 1 && e.map[l + 1] == a)
      n.setNodeMarkup(
        n.mapping.slice(s).map(r + a),
        null,
        Na(u, i - e.colCount(a))
      );
    else {
      const h = n.mapping.slice(s).map(r + a);
      n.delete(h, h + c.nodeSize);
    }
    o += u.rowspan;
  }
}
function gQ(n, e) {
  if (!Si(n)) return !1;
  if (e) {
    const t = Tl(n), r = n.tr;
    if (t.left == 0 && t.right == t.map.width) return !1;
    for (let i = t.right - 1; mQ(r, t, i), i != t.left; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = vt.get(s);
    }
    e(r);
  }
  return !0;
}
function yQ(n, { map: e, table: t, tableStart: r }, i) {
  let s = 0;
  for (let c = 0; c < i; c++) s += t.child(c).nodeSize;
  const o = s + t.child(i).nodeSize, l = n.mapping.maps.length;
  n.delete(s + r, o + r);
  const a = /* @__PURE__ */ new Set();
  for (let c = 0, u = i * e.width; c < e.width; c++, u++) {
    const h = e.map[u];
    if (!a.has(h)) {
      if (a.add(h), i > 0 && h == e.map[u - e.width]) {
        const f = t.nodeAt(h).attrs;
        n.setNodeMarkup(n.mapping.slice(l).map(h + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (i < e.height && h == e.map[u + e.width]) {
        const f = t.nodeAt(h), d = f.attrs, p = f.type.create(
          { ...d, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), m = e.positionAt(i + 1, c, t);
        n.insert(n.mapping.slice(l).map(r + m), p), c += d.colspan - 1;
      }
    }
  }
}
function bQ(n, e) {
  if (!Si(n)) return !1;
  if (e) {
    const t = Tl(n), r = n.tr;
    if (t.top == 0 && t.bottom == t.map.height) return !1;
    for (let i = t.bottom - 1; yQ(r, t, i), i != t.top; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = vt.get(t.table);
    }
    e(r);
  }
  return !0;
}
function vQ(n, e) {
  return function(t, r) {
    if (!Si(t)) return !1;
    const i = J1(t);
    if (i.nodeAfter.attrs[n] === e) return !1;
    if (r) {
      const s = t.tr;
      t.selection instanceof Dt ? t.selection.forEachCell((o, l) => {
        o.attrs[n] !== e && s.setNodeMarkup(l, null, {
          ...o.attrs,
          [n]: e
        });
      }) : s.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [n]: e
      }), r(s);
    }
    return !0;
  };
}
function wQ(n) {
  return function(e, t) {
    if (!Si(e)) return !1;
    if (t) {
      const r = wi(e.schema), i = Tl(e), s = e.tr, o = i.map.cellsInRect(
        n == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : n == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), l = o.map((a) => i.table.nodeAt(a));
      for (let a = 0; a < o.length; a++)
        l[a].type == r.header_cell && s.setNodeMarkup(
          i.tableStart + o[a],
          r.cell,
          l[a].attrs
        );
      if (s.steps.length == 0)
        for (let a = 0; a < o.length; a++)
          s.setNodeMarkup(
            i.tableStart + o[a],
            r.header_cell,
            l[a].attrs
          );
      t(s);
    }
    return !0;
  };
}
function dk(n, e, t) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: n == "row" ? e.map.width : 1,
    bottom: n == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const s = e.table.nodeAt(r[i]);
    if (s && s.type !== t.header_cell)
      return !1;
  }
  return !0;
}
function Mv(n, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? wQ(n) : function(t, r) {
    if (!Si(t)) return !1;
    if (r) {
      const i = wi(t.schema), s = Tl(t), o = t.tr, l = dk("row", s, i), a = dk(
        "column",
        s,
        i
      ), u = (n === "column" ? l : n === "row" ? a : !1) ? 1 : 0, h = n == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: s.map.height
      } : n == "row" ? {
        left: u,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, f = n == "column" ? a ? i.cell : i.header_cell : n == "row" ? l ? i.cell : i.header_cell : i.cell;
      s.map.cellsInRect(h).forEach((d) => {
        const p = d + s.tableStart, m = o.doc.nodeAt(p);
        m && o.setNodeMarkup(p, f, m.attrs);
      }), r(o);
    }
    return !0;
  };
}
Mv("row", {
  useDeprecatedLogic: !0
});
Mv("column", {
  useDeprecatedLogic: !0
});
Mv("cell", {
  useDeprecatedLogic: !0
});
function xQ(n, e) {
  if (e < 0) {
    const t = n.nodeBefore;
    if (t) return n.pos - t.nodeSize;
    for (let r = n.index(-1) - 1, i = n.before(); r >= 0; r--) {
      const s = n.node(-1).child(r), o = s.lastChild;
      if (o)
        return i - 1 - o.nodeSize;
      i -= s.nodeSize;
    }
  } else {
    if (n.index() < n.parent.childCount - 1)
      return n.pos + n.nodeAfter.nodeSize;
    const t = n.node(-1);
    for (let r = n.indexAfter(-1), i = n.after(); r < t.childCount; r++) {
      const s = t.child(r);
      if (s.childCount) return i + 1;
      i += s.nodeSize;
    }
  }
  return null;
}
function YE(n) {
  return function(e, t) {
    if (!Si(e)) return !1;
    const r = xQ(J1(e), n);
    if (r == null) return !1;
    if (t) {
      const i = e.doc.resolve(r);
      t(
        e.tr.setSelection(Ee.between(i, nQ(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function kQ(n, e) {
  const t = n.selection.$anchor;
  for (let r = t.depth; r > 0; r--)
    if (t.node(r).type.spec.tableRole == "table")
      return e && e(
        n.tr.delete(t.before(r), t.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function w0(n, e) {
  const t = n.selection;
  if (!(t instanceof Dt)) return !1;
  if (e) {
    const r = n.tr, i = wi(n.schema).cell.createAndFill().content;
    t.forEachCell((s, o) => {
      s.content.eq(i) || r.replace(
        r.mapping.map(o + 1),
        r.mapping.map(o + s.nodeSize - 1),
        new ve(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function SQ(n) {
  if (!n.size) return null;
  let { content: e, openStart: t, openEnd: r } = n;
  for (; e.childCount == 1 && (t > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    t--, r--, e = e.child(0).content;
  const i = e.child(0), s = i.type.spec.tableRole, o = i.type.schema, l = [];
  if (s == "row")
    for (let a = 0; a < e.childCount; a++) {
      let c = e.child(a).content;
      const u = a ? 0 : Math.max(0, t - 1), h = a < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (u || h) && (c = x5(
        wi(o).row,
        new ve(c, u, h)
      ).content), l.push(c);
    }
  else if (s == "cell" || s == "header_cell")
    l.push(
      t || r ? x5(
        wi(o).row,
        new ve(e, t, r)
      ).content : e
    );
  else
    return null;
  return CQ(o, l);
}
function CQ(n, e) {
  const t = [];
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    for (let o = s.childCount - 1; o >= 0; o--) {
      const { rowspan: l, colspan: a } = s.child(o).attrs;
      for (let c = i; c < i + l; c++)
        t[c] = (t[c] || 0) + a;
    }
  }
  let r = 0;
  for (let i = 0; i < t.length; i++) r = Math.max(r, t[i]);
  for (let i = 0; i < t.length; i++)
    if (i >= e.length && e.push(ce.empty), t[i] < r) {
      const s = wi(n).cell.createAndFill(), o = [];
      for (let l = t[i]; l < r; l++)
        o.push(s);
      e[i] = e[i].append(ce.from(o));
    }
  return { height: e.length, width: r, rows: e };
}
function x5(n, e) {
  const t = n.createAndFill();
  return new uT(t).replace(0, t.content.size, e).doc;
}
function MQ({ width: n, height: e, rows: t }, r, i) {
  if (n != r) {
    const s = [], o = [];
    for (let l = 0; l < t.length; l++) {
      const a = t[l], c = [];
      for (let u = s[l] || 0, h = 0; u < r; h++) {
        let f = a.child(h % a.childCount);
        u + f.attrs.colspan > r && (f = f.type.createChecked(
          Na(
            f.attrs,
            f.attrs.colspan,
            u + f.attrs.colspan - r
          ),
          f.content
        )), c.push(f), u += f.attrs.colspan;
        for (let d = 1; d < f.attrs.rowspan; d++)
          s[l + d] = (s[l + d] || 0) + f.attrs.colspan;
      }
      o.push(ce.from(c));
    }
    t = o, n = r;
  }
  if (e != i) {
    const s = [];
    for (let o = 0, l = 0; o < i; o++, l++) {
      const a = [], c = t[l % e];
      for (let u = 0; u < c.childCount; u++) {
        let h = c.child(u);
        o + h.attrs.rowspan > i && (h = h.type.create(
          {
            ...h.attrs,
            rowspan: Math.max(1, i - h.attrs.rowspan)
          },
          h.content
        )), a.push(h);
      }
      s.push(ce.from(a));
    }
    t = s, e = i;
  }
  return { width: n, height: e, rows: t };
}
function TQ(n, e, t, r, i, s, o) {
  const l = n.doc.type.schema, a = wi(l);
  let c, u;
  if (i > e.width)
    for (let h = 0, f = 0; h < e.height; h++) {
      const d = t.child(h);
      f += d.nodeSize;
      const p = [];
      let m;
      d.lastChild == null || d.lastChild.type == a.cell ? m = c || (c = a.cell.createAndFill()) : m = u || (u = a.header_cell.createAndFill());
      for (let g = e.width; g < i; g++) p.push(m);
      n.insert(n.mapping.slice(o).map(f - 1 + r), p);
    }
  if (s > e.height) {
    const h = [];
    for (let p = 0, m = (e.height - 1) * e.width; p < Math.max(e.width, i); p++) {
      const g = p >= e.width ? !1 : t.nodeAt(e.map[m + p]).type == a.header_cell;
      h.push(
        g ? u || (u = a.header_cell.createAndFill()) : c || (c = a.cell.createAndFill())
      );
    }
    const f = a.row.create(null, ce.from(h)), d = [];
    for (let p = e.height; p < s; p++) d.push(f);
    n.insert(n.mapping.slice(o).map(r + t.nodeSize - 2), d);
  }
  return !!(c || u);
}
function pk(n, e, t, r, i, s, o, l) {
  if (o == 0 || o == e.height) return !1;
  let a = !1;
  for (let c = i; c < s; c++) {
    const u = o * e.width + c, h = e.map[u];
    if (e.map[u - e.width] == h) {
      a = !0;
      const f = t.nodeAt(h), { top: d, left: p } = e.findCell(h);
      n.setNodeMarkup(n.mapping.slice(l).map(h + r), null, {
        ...f.attrs,
        rowspan: o - d
      }), n.insert(
        n.mapping.slice(l).map(e.positionAt(o, p, t)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: d + f.attrs.rowspan - o
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return a;
}
function mk(n, e, t, r, i, s, o, l) {
  if (o == 0 || o == e.width) return !1;
  let a = !1;
  for (let c = i; c < s; c++) {
    const u = c * e.width + o, h = e.map[u];
    if (e.map[u - 1] == h) {
      a = !0;
      const f = t.nodeAt(h), d = e.colCount(h), p = n.mapping.slice(l).map(h + r);
      n.setNodeMarkup(
        p,
        null,
        Na(
          f.attrs,
          o - d,
          f.attrs.colspan - (o - d)
        )
      ), n.insert(
        p + f.nodeSize,
        f.type.createAndFill(
          Na(f.attrs, 0, o - d)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return a;
}
function gk(n, e, t, r, i) {
  let s = t ? n.doc.nodeAt(t - 1) : n.doc;
  if (!s)
    throw new Error("No table found");
  let o = vt.get(s);
  const { top: l, left: a } = r, c = a + i.width, u = l + i.height, h = n.tr;
  let f = 0;
  function d() {
    if (s = t ? h.doc.nodeAt(t - 1) : h.doc, !s)
      throw new Error("No table found");
    o = vt.get(s), f = h.mapping.maps.length;
  }
  TQ(h, o, s, t, c, u, f) && d(), pk(h, o, s, t, a, c, l, f) && d(), pk(h, o, s, t, a, c, u, f) && d(), mk(h, o, s, t, l, u, a, f) && d(), mk(h, o, s, t, l, u, c, f) && d();
  for (let p = l; p < u; p++) {
    const m = o.positionAt(p, a, s), g = o.positionAt(p, c, s);
    h.replace(
      h.mapping.slice(f).map(m + t),
      h.mapping.slice(f).map(g + t),
      new ve(i.rows[p - l], 0, 0)
    );
  }
  d(), h.setSelection(
    new Dt(
      h.doc.resolve(t + o.positionAt(l, a, s)),
      h.doc.resolve(t + o.positionAt(u - 1, c - 1, s))
    )
  ), e(h);
}
var AQ = K3({
  ArrowLeft: x0("horiz", -1),
  ArrowRight: x0("horiz", 1),
  ArrowUp: x0("vert", -1),
  ArrowDown: x0("vert", 1),
  "Shift-ArrowLeft": k0("horiz", -1),
  "Shift-ArrowRight": k0("horiz", 1),
  "Shift-ArrowUp": k0("vert", -1),
  "Shift-ArrowDown": k0("vert", 1),
  Backspace: w0,
  "Mod-Backspace": w0,
  Delete: w0,
  "Mod-Delete": w0
});
function Mp(n, e, t) {
  return t.eq(n.selection) ? !1 : (e && e(n.tr.setSelection(t).scrollIntoView()), !0);
}
function x0(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const s = t.selection;
    if (s instanceof Dt)
      return Mp(
        t,
        r,
        Ge.near(s.$headCell, e)
      );
    if (n != "horiz" && !s.empty) return !1;
    const o = JE(i, n, e);
    if (o == null) return !1;
    if (n == "horiz")
      return Mp(
        t,
        r,
        Ge.near(t.doc.resolve(s.head + e), e)
      );
    {
      const l = t.doc.resolve(o), a = jE(l, n, e);
      let c;
      return a ? c = Ge.near(a, 1) : e < 0 ? c = Ge.near(t.doc.resolve(l.before(-1)), -1) : c = Ge.near(t.doc.resolve(l.after(-1)), 1), Mp(t, r, c);
    }
  };
}
function k0(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const s = t.selection;
    let o;
    if (s instanceof Dt)
      o = s;
    else {
      const a = JE(i, n, e);
      if (a == null) return !1;
      o = new Dt(t.doc.resolve(a));
    }
    const l = jE(o.$headCell, n, e);
    return l ? Mp(
      t,
      r,
      new Dt(o.$anchorCell, l)
    ) : !1;
  };
}
function OQ(n, e) {
  const t = n.state.doc, r = Ad(t.resolve(e));
  return r ? (n.dispatch(n.state.tr.setSelection(new Dt(r))), !0) : !1;
}
function EQ(n, e, t) {
  if (!Si(n.state)) return !1;
  let r = SQ(t);
  const i = n.state.selection;
  if (i instanceof Dt) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        ce.from(
          x5(wi(n.state.schema).cell, t)
        )
      ]
    });
    const s = i.$anchorCell.node(-1), o = i.$anchorCell.start(-1), l = vt.get(s).rectBetween(
      i.$anchorCell.pos - o,
      i.$headCell.pos - o
    );
    return r = MQ(r, l.right - l.left, l.bottom - l.top), gk(n.state, n.dispatch, o, l, r), !0;
  } else if (r) {
    const s = J1(n.state), o = s.start(-1);
    return gk(
      n.state,
      n.dispatch,
      o,
      vt.get(s.node(-1)).findCell(s.pos - o),
      r
    ), !0;
  } else
    return !1;
}
function IQ(n, e) {
  var t;
  if (e.ctrlKey || e.metaKey) return;
  const r = yk(n, e.target);
  let i;
  if (e.shiftKey && n.state.selection instanceof Dt)
    s(n.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = Ad(n.state.selection.$anchor)) != null && ((t = q2(n, e)) == null ? void 0 : t.pos) != i.pos)
    s(i, e), e.preventDefault();
  else if (!r)
    return;
  function s(a, c) {
    let u = q2(n, c);
    const h = Ko.getState(n.state) == null;
    if (!u || !Cv(a, u))
      if (h) u = a;
      else return;
    const f = new Dt(a, u);
    if (h || !n.state.selection.eq(f)) {
      const d = n.state.tr.setSelection(f);
      h && d.setMeta(Ko, a.pos), n.dispatch(d);
    }
  }
  function o() {
    n.root.removeEventListener("mouseup", o), n.root.removeEventListener("dragstart", o), n.root.removeEventListener("mousemove", l), Ko.getState(n.state) != null && n.dispatch(n.state.tr.setMeta(Ko, -1));
  }
  function l(a) {
    const c = a, u = Ko.getState(n.state);
    let h;
    if (u != null)
      h = n.state.doc.resolve(u);
    else if (yk(n, c.target) != r && (h = q2(n, e), !h))
      return o();
    h && s(h, c);
  }
  n.root.addEventListener("mouseup", o), n.root.addEventListener("dragstart", o), n.root.addEventListener("mousemove", l);
}
function JE(n, e, t) {
  if (!(n.state.selection instanceof Ee)) return null;
  const { $head: r } = n.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const s = r.node(i);
    if ((t < 0 ? r.index(i) : r.indexAfter(i)) != (t < 0 ? 0 : s.childCount)) return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const l = r.before(i), a = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
      return n.endOfTextblock(a) ? l : null;
    }
  }
  return null;
}
function yk(n, e) {
  for (; e && e != n.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function q2(n, e) {
  const t = n.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return t && t ? Ad(n.state.doc.resolve(t.pos)) : null;
}
var DQ = class {
  constructor(n, e) {
    this.node = n, this.defaultCellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${e}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), k5(n, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(n) {
    return n.type != this.node.type ? !1 : (this.node = n, k5(
      n,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(n) {
    return n.type == "attributes" && (n.target == this.table || this.colgroup.contains(n.target));
  }
};
function k5(n, e, t, r, i, s) {
  var o;
  let l = 0, a = !0, c = e.firstChild;
  const u = n.firstChild;
  if (u) {
    for (let h = 0, f = 0; h < u.childCount; h++) {
      const { colspan: d, colwidth: p } = u.child(h).attrs;
      for (let m = 0; m < d; m++, f++) {
        const g = i == f ? s : p && p[m], b = g ? g + "px" : "";
        if (l += g || r, g || (a = !1), c)
          c.style.width != b && (c.style.width = b), c = c.nextSibling;
        else {
          const w = document.createElement("col");
          w.style.width = b, e.appendChild(w);
        }
      }
    }
    for (; c; ) {
      const h = c.nextSibling;
      (o = c.parentNode) == null || o.removeChild(c), c = h;
    }
    a ? (t.style.width = l + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = l + "px");
  }
}
var Kr = new en(
  "tableColumnResizing"
);
function NQ({
  handleWidth: n = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: t = 100,
  View: r = DQ,
  lastColumnResizable: i = !0
} = {}) {
  const s = new Ut({
    key: Kr,
    state: {
      init(o, l) {
        var a, c;
        const u = (c = (a = s.spec) == null ? void 0 : a.props) == null ? void 0 : c.nodeViews, h = wi(l.schema).table.name;
        return r && u && (u[h] = (f, d) => new r(f, t, d)), new RQ(-1, !1);
      },
      apply(o, l) {
        return l.apply(o);
      }
    },
    props: {
      attributes: (o) => {
        const l = Kr.getState(o);
        return l && l.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (o, l) => {
          PQ(o, l, n, i);
        },
        mouseleave: (o) => {
          _Q(o);
        },
        mousedown: (o, l) => {
          LQ(o, l, e, t);
        }
      },
      decorations: (o) => {
        const l = Kr.getState(o);
        if (l && l.activeHandle > -1)
          return $Q(o, l.activeHandle);
      },
      nodeViews: {}
    }
  });
  return s;
}
var RQ = class Tp {
  constructor(e, t) {
    this.activeHandle = e, this.dragging = t;
  }
  apply(e) {
    const t = this, r = e.getMeta(Kr);
    if (r && r.setHandle != null)
      return new Tp(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new Tp(t.activeHandle, r.setDragging);
    if (t.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(t.activeHandle, -1);
      return w5(e.doc.resolve(i)) || (i = -1), new Tp(i, t.dragging);
    }
    return t;
  }
};
function PQ(n, e, t, r) {
  if (!n.editable) return;
  const i = Kr.getState(n.state);
  if (i && !i.dragging) {
    const s = zQ(e.target);
    let o = -1;
    if (s) {
      const { left: l, right: a } = s.getBoundingClientRect();
      e.clientX - l <= t ? o = bk(n, e, "left", t) : a - e.clientX <= t && (o = bk(n, e, "right", t));
    }
    if (o != i.activeHandle) {
      if (!r && o !== -1) {
        const l = n.state.doc.resolve(o), a = l.node(-1), c = vt.get(a), u = l.start(-1);
        if (c.colCount(l.pos - u) + l.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      XE(n, o);
    }
  }
}
function _Q(n) {
  if (!n.editable) return;
  const e = Kr.getState(n.state);
  e && e.activeHandle > -1 && !e.dragging && XE(n, -1);
}
function LQ(n, e, t, r) {
  var i;
  if (!n.editable) return !1;
  const s = (i = n.dom.ownerDocument.defaultView) != null ? i : window, o = Kr.getState(n.state);
  if (!o || o.activeHandle == -1 || o.dragging)
    return !1;
  const l = n.state.doc.nodeAt(o.activeHandle), a = BQ(n, o.activeHandle, l.attrs);
  n.dispatch(
    n.state.tr.setMeta(Kr, {
      setDragging: { startX: e.clientX, startWidth: a }
    })
  );
  function c(h) {
    s.removeEventListener("mouseup", c), s.removeEventListener("mousemove", u);
    const f = Kr.getState(n.state);
    f?.dragging && (FQ(
      n,
      f.activeHandle,
      vk(f.dragging, h, t)
    ), n.dispatch(
      n.state.tr.setMeta(Kr, { setDragging: null })
    ));
  }
  function u(h) {
    if (!h.which) return c(h);
    const f = Kr.getState(n.state);
    if (f && f.dragging) {
      const d = vk(f.dragging, h, t);
      wk(
        n,
        f.activeHandle,
        d,
        r
      );
    }
  }
  return wk(
    n,
    o.activeHandle,
    a,
    r
  ), s.addEventListener("mouseup", c), s.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function BQ(n, e, { colspan: t, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i) return i;
  const s = n.domAtPos(e);
  let l = s.node.childNodes[s.offset].offsetWidth, a = t;
  if (r)
    for (let c = 0; c < t; c++)
      r[c] && (l -= r[c], a--);
  return l / a;
}
function zQ(n) {
  for (; n && n.nodeName != "TD" && n.nodeName != "TH"; )
    n = n.classList && n.classList.contains("ProseMirror") ? null : n.parentNode;
  return n;
}
function bk(n, e, t, r) {
  const i = t == "right" ? -r : r, s = n.posAtCoords({
    left: e.clientX + i,
    top: e.clientY
  });
  if (!s) return -1;
  const { pos: o } = s, l = Ad(n.state.doc.resolve(o));
  if (!l) return -1;
  if (t == "right") return l.pos;
  const a = vt.get(l.node(-1)), c = l.start(-1), u = a.map.indexOf(l.pos - c);
  return u % a.width == 0 ? -1 : c + a.map[u - 1];
}
function vk(n, e, t) {
  const r = e.clientX - n.startX;
  return Math.max(t, n.startWidth + r);
}
function XE(n, e) {
  n.dispatch(
    n.state.tr.setMeta(Kr, { setHandle: e })
  );
}
function FQ(n, e, t) {
  const r = n.state.doc.resolve(e), i = r.node(-1), s = vt.get(i), o = r.start(-1), l = s.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1, a = n.state.tr;
  for (let c = 0; c < s.height; c++) {
    const u = c * s.width + l;
    if (c && s.map[u] == s.map[u - s.width]) continue;
    const h = s.map[u], f = i.nodeAt(h).attrs, d = f.colspan == 1 ? 0 : l - s.colCount(h);
    if (f.colwidth && f.colwidth[d] == t) continue;
    const p = f.colwidth ? f.colwidth.slice() : HQ(f.colspan);
    p[d] = t, a.setNodeMarkup(o + h, null, { ...f, colwidth: p });
  }
  a.docChanged && n.dispatch(a);
}
function wk(n, e, t, r) {
  const i = n.state.doc.resolve(e), s = i.node(-1), o = i.start(-1), l = vt.get(s).colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1;
  let a = n.domAtPos(i.start(-1)).node;
  for (; a && a.nodeName != "TABLE"; )
    a = a.parentNode;
  a && k5(
    s,
    a.firstChild,
    a,
    r,
    l,
    t
  );
}
function HQ(n) {
  return Array(n).fill(0);
}
function $Q(n, e) {
  var t;
  const r = [], i = n.doc.resolve(e), s = i.node(-1);
  if (!s)
    return Ot.empty;
  const o = vt.get(s), l = i.start(-1), a = o.colCount(i.pos - l) + i.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < o.height; c++) {
    const u = a + c * o.width;
    if ((a == o.width - 1 || o.map[u] != o.map[u + 1]) && (c == 0 || o.map[u] != o.map[u - o.width])) {
      const h = o.map[u], f = l + h + s.nodeAt(h).nodeSize - 1, d = document.createElement("div");
      d.className = "column-resize-handle", (t = Kr.getState(n)) != null && t.dragging && r.push(
        mn.node(
          l + h,
          l + h + s.nodeAt(h).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(mn.widget(f, d));
    }
  }
  return Ot.create(n.doc, r);
}
function VQ({
  allowTableNodeSelection: n = !1
} = {}) {
  return new Ut({
    key: Ko,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, t) {
        const r = e.getMeta(Ko);
        if (r != null) return r == -1 ? null : r;
        if (t == null || !e.docChanged) return t;
        const { deleted: i, pos: s } = e.mapping.mapResult(t);
        return i ? null : s;
      }
    },
    props: {
      decorations: oQ,
      handleDOMEvents: {
        mousedown: IQ
      },
      createSelectionBetween(e) {
        return Ko.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: OQ,
      handleKeyDown: AQ,
      handlePaste: EQ
    },
    appendTransaction(e, t, r) {
      return cQ(
        r,
        hQ(r, t),
        n
      );
    }
  });
}
var Pm = typeof navigator < "u" ? navigator : null, Tv = Pm && Pm.userAgent || "", qQ = /Edge\/(\d+)/.exec(Tv), WQ = /MSIE \d/.exec(Tv), jQ = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Tv), UQ = !!(WQ || jQ || qQ), KQ = !UQ && !!Pm && /Apple Computer/.test(Pm.vendor), ZE = new en("safari-ime-span"), S5 = !1, GQ = {
  key: ZE,
  props: {
    decorations: YQ,
    handleDOMEvents: {
      compositionstart: () => {
        S5 = !0;
      },
      compositionend: () => {
        S5 = !1;
      }
    }
  }
};
function YQ(n) {
  const { $from: e, $to: t, to: r } = n.selection;
  if (S5 && e.sameParent(t)) {
    const i = mn.widget(r, JQ, {
      ignoreSelection: !0,
      key: "safari-ime-span"
    });
    return Ot.create(n.doc, [i]);
  }
}
function JQ(n) {
  const e = n.dom.ownerDocument.createElement("span");
  return e.className = "ProseMirror-safari-ime-span", e;
}
var XQ = new Ut(KQ ? GQ : { key: ZE });
function xk(n, e) {
  const t = String(n);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, i = t.indexOf(e);
  for (; i !== -1; )
    r++, i = t.indexOf(e, i + e.length);
  return r;
}
function ZQ(n) {
  if (typeof n != "string")
    throw new TypeError("Expected a string");
  return n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function QQ(n, e, t) {
  const i = w1((t || {}).ignore || []), s = eee(e);
  let o = -1;
  for (; ++o < s.length; )
    z3(n, "text", l);
  function l(c, u) {
    let h = -1, f;
    for (; ++h < u.length; ) {
      const d = u[h], p = f ? f.children : void 0;
      if (i(
        d,
        p ? p.indexOf(d) : void 0,
        f
      ))
        return;
      f = d;
    }
    if (f)
      return a(c, u);
  }
  function a(c, u) {
    const h = u[u.length - 1], f = s[o][0], d = s[o][1];
    let p = 0;
    const g = h.children.indexOf(c);
    let b = !1, w = [];
    f.lastIndex = 0;
    let k = f.exec(c.value);
    for (; k; ) {
      const C = k.index, M = {
        index: k.index,
        input: k.input,
        stack: [...u, c]
      };
      let T = d(...k, M);
      if (typeof T == "string" && (T = T.length > 0 ? { type: "text", value: T } : void 0), T === !1 ? f.lastIndex = C + 1 : (p !== C && w.push({
        type: "text",
        value: c.value.slice(p, C)
      }), Array.isArray(T) ? w.push(...T) : T && w.push(T), p = C + k[0].length, b = !0), !f.global)
        break;
      k = f.exec(c.value);
    }
    return b ? (p < c.value.length && w.push({ type: "text", value: c.value.slice(p) }), h.children.splice(g, 1, ...w)) : w = [c], g + w.length;
  }
}
function eee(n) {
  const e = [];
  if (!Array.isArray(n))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const t = !n[0] || Array.isArray(n[0]) ? n : [n];
  let r = -1;
  for (; ++r < t.length; ) {
    const i = t[r];
    e.push([tee(i[0]), nee(i[1])]);
  }
  return e;
}
function tee(n) {
  return typeof n == "string" ? new RegExp(ZQ(n), "g") : n;
}
function nee(n) {
  return typeof n == "function" ? n : function() {
    return n;
  };
}
const W2 = "phrasing", j2 = ["autolink", "link", "image", "label"];
function ree() {
  return {
    transforms: [uee],
    enter: {
      literalAutolink: see,
      literalAutolinkEmail: U2,
      literalAutolinkHttp: U2,
      literalAutolinkWww: U2
    },
    exit: {
      literalAutolink: cee,
      literalAutolinkEmail: aee,
      literalAutolinkHttp: oee,
      literalAutolinkWww: lee
    }
  };
}
function iee() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: W2,
        notInConstruct: j2
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: W2,
        notInConstruct: j2
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: W2,
        notInConstruct: j2
      }
    ]
  };
}
function see(n) {
  this.enter({ type: "link", title: null, url: "", children: [] }, n);
}
function U2(n) {
  this.config.enter.autolinkProtocol.call(this, n);
}
function oee(n) {
  this.config.exit.autolinkProtocol.call(this, n);
}
function lee(n) {
  this.config.exit.data.call(this, n);
  const e = this.stack[this.stack.length - 1];
  e.type, e.url = "http://" + this.sliceSerialize(n);
}
function aee(n) {
  this.config.exit.autolinkEmail.call(this, n);
}
function cee(n) {
  this.exit(n);
}
function uee(n) {
  QQ(
    n,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, hee],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), fee]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function hee(n, e, t, r, i) {
  let s = "";
  if (!QE(i) || (/^w/i.test(e) && (t = e + t, e = "", s = "http://"), !dee(t)))
    return !1;
  const o = pee(t + r);
  if (!o[0]) return !1;
  const l = {
    type: "link",
    title: null,
    url: s + e + o[0],
    children: [{ type: "text", value: e + o[0] }]
  };
  return o[1] ? [l, { type: "text", value: o[1] }] : l;
}
function fee(n, e, t, r) {
  return (
    // Not an expected previous character.
    !QE(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(t) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + e + "@" + t,
      children: [{ type: "text", value: e + "@" + t }]
    }
  );
}
function dee(n) {
  const e = n.split(".");
  return !(e.length < 2 || e[e.length - 1] && (/_/.test(e[e.length - 1]) || !/[a-zA-Z\d]/.test(e[e.length - 1])) || e[e.length - 2] && (/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2])));
}
function pee(n) {
  const e = /[!"&'),.:;<>?\]}]+$/.exec(n);
  if (!e)
    return [n, void 0];
  n = n.slice(0, e.index);
  let t = e[0], r = t.indexOf(")");
  const i = xk(n, "(");
  let s = xk(n, ")");
  for (; r !== -1 && i > s; )
    n += t.slice(0, r + 1), t = t.slice(r + 1), r = t.indexOf(")"), s++;
  return [n, t];
}
function QE(n, e) {
  const t = n.input.charCodeAt(n.index - 1);
  return (n.index === 0 || Ma(t) || b1(t)) && // If it’s an email, the previous character should not be a slash.
  (!e || t !== 47);
}
eI.peek = See;
function mee() {
  this.buffer();
}
function gee(n) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, n);
}
function yee() {
  this.buffer();
}
function bee(n) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    n
  );
}
function vee(n) {
  const e = this.resume(), t = this.stack[this.stack.length - 1];
  t.type, t.identifier = Ni(
    this.sliceSerialize(n)
  ).toLowerCase(), t.label = e;
}
function wee(n) {
  this.exit(n);
}
function xee(n) {
  const e = this.resume(), t = this.stack[this.stack.length - 1];
  t.type, t.identifier = Ni(
    this.sliceSerialize(n)
  ).toLowerCase(), t.label = e;
}
function kee(n) {
  this.exit(n);
}
function See() {
  return "[";
}
function eI(n, e, t, r) {
  const i = t.createTracker(r);
  let s = i.move("[^");
  const o = t.enter("footnoteReference"), l = t.enter("reference");
  return s += i.move(
    t.safe(t.associationId(n), { after: "]", before: s })
  ), l(), o(), s += i.move("]"), s;
}
function Cee() {
  return {
    enter: {
      gfmFootnoteCallString: mee,
      gfmFootnoteCall: gee,
      gfmFootnoteDefinitionLabelString: yee,
      gfmFootnoteDefinition: bee
    },
    exit: {
      gfmFootnoteCallString: vee,
      gfmFootnoteCall: wee,
      gfmFootnoteDefinitionLabelString: xee,
      gfmFootnoteDefinition: kee
    }
  };
}
function Mee(n) {
  let e = !1;
  return n && n.firstLineBlank && (e = !0), {
    handlers: { footnoteDefinition: t, footnoteReference: eI },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function t(r, i, s, o) {
    const l = s.createTracker(o);
    let a = l.move("[^");
    const c = s.enter("footnoteDefinition"), u = s.enter("label");
    return a += l.move(
      s.safe(s.associationId(r), { before: a, after: "]" })
    ), u(), a += l.move("]:"), r.children && r.children.length > 0 && (l.shift(4), a += l.move(
      (e ? `
` : " ") + s.indentLines(
        s.containerFlow(r, l.current()),
        e ? tI : Tee
      )
    )), c(), a;
  }
}
function Tee(n, e, t) {
  return e === 0 ? n : tI(n, e, t);
}
function tI(n, e, t) {
  return (t ? "" : "    ") + n;
}
const Aee = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
nI.peek = Nee;
function Oee() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Iee },
    exit: { strikethrough: Dee }
  };
}
function Eee() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Aee
      }
    ],
    handlers: { delete: nI }
  };
}
function Iee(n) {
  this.enter({ type: "delete", children: [] }, n);
}
function Dee(n) {
  this.exit(n);
}
function nI(n, e, t, r) {
  const i = t.createTracker(r), s = t.enter("strikethrough");
  let o = i.move("~~");
  return o += t.containerPhrasing(n, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), s(), o;
}
function Nee() {
  return "~";
}
function Ree(n) {
  return n.length;
}
function Pee(n, e) {
  const t = e || {}, r = (t.align || []).concat(), i = t.stringLength || Ree, s = [], o = [], l = [], a = [];
  let c = 0, u = -1;
  for (; ++u < n.length; ) {
    const m = [], g = [];
    let b = -1;
    for (n[u].length > c && (c = n[u].length); ++b < n[u].length; ) {
      const w = _ee(n[u][b]);
      if (t.alignDelimiters !== !1) {
        const k = i(w);
        g[b] = k, (a[b] === void 0 || k > a[b]) && (a[b] = k);
      }
      m.push(w);
    }
    o[u] = m, l[u] = g;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < c; )
      s[h] = kk(r[h]);
  else {
    const m = kk(r);
    for (; ++h < c; )
      s[h] = m;
  }
  h = -1;
  const f = [], d = [];
  for (; ++h < c; ) {
    const m = s[h];
    let g = "", b = "";
    m === 99 ? (g = ":", b = ":") : m === 108 ? g = ":" : m === 114 && (b = ":");
    let w = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      a[h] - g.length - b.length
    );
    const k = g + "-".repeat(w) + b;
    t.alignDelimiters !== !1 && (w = g.length + w + b.length, w > a[h] && (a[h] = w), d[h] = w), f[h] = k;
  }
  o.splice(1, 0, f), l.splice(1, 0, d), u = -1;
  const p = [];
  for (; ++u < o.length; ) {
    const m = o[u], g = l[u];
    h = -1;
    const b = [];
    for (; ++h < c; ) {
      const w = m[h] || "";
      let k = "", C = "";
      if (t.alignDelimiters !== !1) {
        const M = a[h] - (g[h] || 0), T = s[h];
        T === 114 ? k = " ".repeat(M) : T === 99 ? M % 2 ? (k = " ".repeat(M / 2 + 0.5), C = " ".repeat(M / 2 - 0.5)) : (k = " ".repeat(M / 2), C = k) : C = " ".repeat(M);
      }
      t.delimiterStart !== !1 && !h && b.push("|"), t.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && w === "") && (t.delimiterStart !== !1 || h) && b.push(" "), t.alignDelimiters !== !1 && b.push(k), b.push(w), t.alignDelimiters !== !1 && b.push(C), t.padding !== !1 && b.push(" "), (t.delimiterEnd !== !1 || h !== c - 1) && b.push("|");
    }
    p.push(
      t.delimiterEnd === !1 ? b.join("").replace(/ +$/, "") : b.join("")
    );
  }
  return p.join(`
`);
}
function _ee(n) {
  return n == null ? "" : String(n);
}
function kk(n) {
  const e = typeof n == "string" ? n.codePointAt(0) : 0;
  return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0;
}
function Lee() {
  return {
    enter: {
      table: Bee,
      tableData: Sk,
      tableHeader: Sk,
      tableRow: Fee
    },
    exit: {
      codeText: Hee,
      table: zee,
      tableData: K2,
      tableHeader: K2,
      tableRow: K2
    }
  };
}
function Bee(n) {
  const e = n._align;
  this.enter(
    {
      type: "table",
      align: e.map(function(t) {
        return t === "none" ? null : t;
      }),
      children: []
    },
    n
  ), this.data.inTable = !0;
}
function zee(n) {
  this.exit(n), this.data.inTable = void 0;
}
function Fee(n) {
  this.enter({ type: "tableRow", children: [] }, n);
}
function K2(n) {
  this.exit(n);
}
function Sk(n) {
  this.enter({ type: "tableCell", children: [] }, n);
}
function Hee(n) {
  let e = this.resume();
  this.data.inTable && (e = e.replace(/\\([\\|])/g, $ee));
  const t = this.stack[this.stack.length - 1];
  t.type, t.value = e, this.exit(n);
}
function $ee(n, e) {
  return e === "|" ? e : n;
}
function Vee(n) {
  const e = n || {}, t = e.tableCellPadding, r = e.tablePipeAlign, i = e.stringLength, s = t ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: f,
      table: o,
      tableCell: a,
      tableRow: l
    }
  };
  function o(d, p, m, g) {
    return c(u(d, m, g), d.align);
  }
  function l(d, p, m, g) {
    const b = h(d, m, g), w = c([b]);
    return w.slice(0, w.indexOf(`
`));
  }
  function a(d, p, m, g) {
    const b = m.enter("tableCell"), w = m.enter("phrasing"), k = m.containerPhrasing(d, {
      ...g,
      before: s,
      after: s
    });
    return w(), b(), k;
  }
  function c(d, p) {
    return Pee(d, {
      align: p,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: t,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(d, p, m) {
    const g = d.children;
    let b = -1;
    const w = [], k = p.enter("table");
    for (; ++b < g.length; )
      w[b] = h(g[b], p, m);
    return k(), w;
  }
  function h(d, p, m) {
    const g = d.children;
    let b = -1;
    const w = [], k = p.enter("tableRow");
    for (; ++b < g.length; )
      w[b] = a(g[b], d, p, m);
    return k(), w;
  }
  function f(d, p, m) {
    let g = H3.inlineCode(d, p, m);
    return m.stack.includes("tableCell") && (g = g.replace(/\|/g, "\\$&")), g;
  }
}
function qee() {
  return {
    exit: {
      taskListCheckValueChecked: Ck,
      taskListCheckValueUnchecked: Ck,
      paragraph: jee
    }
  };
}
function Wee() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: Uee }
  };
}
function Ck(n) {
  const e = this.stack[this.stack.length - 2];
  e.type, e.checked = n.type === "taskListCheckValueChecked";
}
function jee(n) {
  const e = this.stack[this.stack.length - 2];
  if (e && e.type === "listItem" && typeof e.checked == "boolean") {
    const t = this.stack[this.stack.length - 1];
    t.type;
    const r = t.children[0];
    if (r && r.type === "text") {
      const i = e.children;
      let s = -1, o;
      for (; ++s < i.length; ) {
        const l = i[s];
        if (l.type === "paragraph") {
          o = l;
          break;
        }
      }
      o === t && (r.value = r.value.slice(1), r.value.length === 0 ? t.children.shift() : t.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, t.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(n);
}
function Uee(n, e, t, r) {
  const i = n.children[0], s = typeof n.checked == "boolean" && i && i.type === "paragraph", o = "[" + (n.checked ? "x" : " ") + "] ", l = t.createTracker(r);
  s && l.move(o);
  let a = H3.listItem(n, e, t, {
    ...r,
    ...l.current()
  });
  return s && (a = a.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), a;
  function c(u) {
    return u + o;
  }
}
function Kee() {
  return [
    ree(),
    Cee(),
    Oee(),
    Lee(),
    qee()
  ];
}
function Gee(n) {
  return {
    extensions: [
      iee(),
      Mee(n),
      Eee(),
      Vee(n),
      Wee()
    ]
  };
}
const Yee = {
  tokenize: tte,
  partial: !0
}, rI = {
  tokenize: nte,
  partial: !0
}, iI = {
  tokenize: rte,
  partial: !0
}, sI = {
  tokenize: ite,
  partial: !0
}, Jee = {
  tokenize: ste,
  partial: !0
}, oI = {
  name: "wwwAutolink",
  tokenize: Qee,
  previous: aI
}, lI = {
  name: "protocolAutolink",
  tokenize: ete,
  previous: cI
}, Co = {
  name: "emailAutolink",
  tokenize: Zee,
  previous: uI
}, Es = {};
function Xee() {
  return {
    text: Es
  };
}
let _l = 48;
for (; _l < 123; )
  Es[_l] = Co, _l++, _l === 58 ? _l = 65 : _l === 91 && (_l = 97);
Es[43] = Co;
Es[45] = Co;
Es[46] = Co;
Es[95] = Co;
Es[72] = [Co, lI];
Es[104] = [Co, lI];
Es[87] = [Co, oI];
Es[119] = [Co, oI];
function Zee(n, e, t) {
  const r = this;
  let i, s;
  return o;
  function o(h) {
    return !C5(h) || !uI.call(r, r.previous) || Av(r.events) ? t(h) : (n.enter("literalAutolink"), n.enter("literalAutolinkEmail"), l(h));
  }
  function l(h) {
    return C5(h) ? (n.consume(h), l) : h === 64 ? (n.consume(h), a) : t(h);
  }
  function a(h) {
    return h === 46 ? n.check(Jee, u, c)(h) : h === 45 || h === 95 || Tr(h) ? (s = !0, n.consume(h), a) : u(h);
  }
  function c(h) {
    return n.consume(h), i = !0, a;
  }
  function u(h) {
    return s && i && lr(r.previous) ? (n.exit("literalAutolinkEmail"), n.exit("literalAutolink"), e(h)) : t(h);
  }
}
function Qee(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o !== 87 && o !== 119 || !aI.call(r, r.previous) || Av(r.events) ? t(o) : (n.enter("literalAutolink"), n.enter("literalAutolinkWww"), n.check(Yee, n.attempt(rI, n.attempt(iI, s), t), t)(o));
  }
  function s(o) {
    return n.exit("literalAutolinkWww"), n.exit("literalAutolink"), e(o);
  }
}
function ete(n, e, t) {
  const r = this;
  let i = "", s = !1;
  return o;
  function o(h) {
    return (h === 72 || h === 104) && cI.call(r, r.previous) && !Av(r.events) ? (n.enter("literalAutolink"), n.enter("literalAutolinkHttp"), i += String.fromCodePoint(h), n.consume(h), l) : t(h);
  }
  function l(h) {
    if (lr(h) && i.length < 5)
      return i += String.fromCodePoint(h), n.consume(h), l;
    if (h === 58) {
      const f = i.toLowerCase();
      if (f === "http" || f === "https")
        return n.consume(h), a;
    }
    return t(h);
  }
  function a(h) {
    return h === 47 ? (n.consume(h), s ? c : (s = !0, a)) : t(h);
  }
  function c(h) {
    return h === null || dm(h) || It(h) || Ma(h) || b1(h) ? t(h) : n.attempt(rI, n.attempt(iI, u), t)(h);
  }
  function u(h) {
    return n.exit("literalAutolinkHttp"), n.exit("literalAutolink"), e(h);
  }
}
function tte(n, e, t) {
  let r = 0;
  return i;
  function i(o) {
    return (o === 87 || o === 119) && r < 3 ? (r++, n.consume(o), i) : o === 46 && r === 3 ? (n.consume(o), s) : t(o);
  }
  function s(o) {
    return o === null ? t(o) : e(o);
  }
}
function nte(n, e, t) {
  let r, i, s;
  return o;
  function o(c) {
    return c === 46 || c === 95 ? n.check(sI, a, l)(c) : c === null || It(c) || Ma(c) || c !== 45 && b1(c) ? a(c) : (s = !0, n.consume(c), o);
  }
  function l(c) {
    return c === 95 ? r = !0 : (i = r, r = void 0), n.consume(c), o;
  }
  function a(c) {
    return i || r || !s ? t(c) : e(c);
  }
}
function rte(n, e) {
  let t = 0, r = 0;
  return i;
  function i(o) {
    return o === 40 ? (t++, n.consume(o), i) : o === 41 && r < t ? s(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? n.check(sI, e, s)(o) : o === null || It(o) || Ma(o) ? e(o) : (n.consume(o), i);
  }
  function s(o) {
    return o === 41 && r++, n.consume(o), i;
  }
}
function ite(n, e, t) {
  return r;
  function r(l) {
    return l === 33 || l === 34 || l === 39 || l === 41 || l === 42 || l === 44 || l === 46 || l === 58 || l === 59 || l === 63 || l === 95 || l === 126 ? (n.consume(l), r) : l === 38 ? (n.consume(l), s) : l === 93 ? (n.consume(l), i) : (
      // `<` is an end.
      l === 60 || // So is whitespace.
      l === null || It(l) || Ma(l) ? e(l) : t(l)
    );
  }
  function i(l) {
    return l === null || l === 40 || l === 91 || It(l) || Ma(l) ? e(l) : r(l);
  }
  function s(l) {
    return lr(l) ? o(l) : t(l);
  }
  function o(l) {
    return l === 59 ? (n.consume(l), r) : lr(l) ? (n.consume(l), o) : t(l);
  }
}
function ste(n, e, t) {
  return r;
  function r(s) {
    return n.consume(s), i;
  }
  function i(s) {
    return Tr(s) ? t(s) : e(s);
  }
}
function aI(n) {
  return n === null || n === 40 || n === 42 || n === 95 || n === 91 || n === 93 || n === 126 || It(n);
}
function cI(n) {
  return !lr(n);
}
function uI(n) {
  return !(n === 47 || C5(n));
}
function C5(n) {
  return n === 43 || n === 45 || n === 46 || n === 95 || Tr(n);
}
function Av(n) {
  let e = n.length, t = !1;
  for (; e--; ) {
    const r = n[e][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      t = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      t = !1;
      break;
    }
  }
  return n.length > 0 && !t && (n[n.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), t;
}
const ote = {
  tokenize: pte,
  partial: !0
};
function lte() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: hte,
        continuation: {
          tokenize: fte
        },
        exit: dte
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: ute
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: ate,
        resolveTo: cte
      }
    }
  };
}
function ate(n, e, t) {
  const r = this;
  let i = r.events.length;
  const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o;
  for (; i--; ) {
    const a = r.events[i][1];
    if (a.type === "labelImage") {
      o = a;
      break;
    }
    if (a.type === "gfmFootnoteCall" || a.type === "labelLink" || a.type === "label" || a.type === "image" || a.type === "link")
      break;
  }
  return l;
  function l(a) {
    if (!o || !o._balanced)
      return t(a);
    const c = Ni(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !s.includes(c.slice(1)) ? t(a) : (n.enter("gfmFootnoteCallLabelMarker"), n.consume(a), n.exit("gfmFootnoteCallLabelMarker"), e(a));
  }
}
function cte(n, e) {
  let t = n.length;
  for (; t--; )
    if (n[t][1].type === "labelImage" && n[t][0] === "enter") {
      n[t][1];
      break;
    }
  n[t + 1][1].type = "data", n[t + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, n[t + 3][1].start),
    end: Object.assign({}, n[n.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, n[t + 3][1].end),
    end: Object.assign({}, n[t + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, n[n.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, l = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    n[t + 1],
    n[t + 2],
    ["enter", r, e],
    // The `[`
    n[t + 3],
    n[t + 4],
    // The `^`.
    ["enter", i, e],
    ["exit", i, e],
    // Everything in between.
    ["enter", s, e],
    ["enter", o, e],
    ["exit", o, e],
    ["exit", s, e],
    // The ending (`]`, properly parsed and labelled).
    n[n.length - 2],
    n[n.length - 1],
    ["exit", r, e]
  ];
  return n.splice(t, n.length - t + 1, ...l), n;
}
function ute(n, e, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s = 0, o;
  return l;
  function l(h) {
    return n.enter("gfmFootnoteCall"), n.enter("gfmFootnoteCallLabelMarker"), n.consume(h), n.exit("gfmFootnoteCallLabelMarker"), a;
  }
  function a(h) {
    return h !== 94 ? t(h) : (n.enter("gfmFootnoteCallMarker"), n.consume(h), n.exit("gfmFootnoteCallMarker"), n.enter("gfmFootnoteCallString"), n.enter("chunkString").contentType = "string", c);
  }
  function c(h) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      h === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || It(h)
    )
      return t(h);
    if (h === 93) {
      n.exit("chunkString");
      const f = n.exit("gfmFootnoteCallString");
      return i.includes(Ni(r.sliceSerialize(f))) ? (n.enter("gfmFootnoteCallLabelMarker"), n.consume(h), n.exit("gfmFootnoteCallLabelMarker"), n.exit("gfmFootnoteCall"), e) : t(h);
    }
    return It(h) || (o = !0), s++, n.consume(h), h === 92 ? u : c;
  }
  function u(h) {
    return h === 91 || h === 92 || h === 93 ? (n.consume(h), s++, c) : c(h);
  }
}
function hte(n, e, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s, o = 0, l;
  return a;
  function a(p) {
    return n.enter("gfmFootnoteDefinition")._container = !0, n.enter("gfmFootnoteDefinitionLabel"), n.enter("gfmFootnoteDefinitionLabelMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(p) {
    return p === 94 ? (n.enter("gfmFootnoteDefinitionMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionMarker"), n.enter("gfmFootnoteDefinitionLabelString"), n.enter("chunkString").contentType = "string", u) : t(p);
  }
  function u(p) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      p === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || It(p)
    )
      return t(p);
    if (p === 93) {
      n.exit("chunkString");
      const m = n.exit("gfmFootnoteDefinitionLabelString");
      return s = Ni(r.sliceSerialize(m)), n.enter("gfmFootnoteDefinitionLabelMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionLabelMarker"), n.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return It(p) || (l = !0), o++, n.consume(p), p === 92 ? h : u;
  }
  function h(p) {
    return p === 91 || p === 92 || p === 93 ? (n.consume(p), o++, u) : u(p);
  }
  function f(p) {
    return p === 58 ? (n.enter("definitionMarker"), n.consume(p), n.exit("definitionMarker"), i.includes(s) || i.push(s), it(n, d, "gfmFootnoteDefinitionWhitespace")) : t(p);
  }
  function d(p) {
    return e(p);
  }
}
function fte(n, e, t) {
  return n.check(fd, e, n.attempt(ote, e, t));
}
function dte(n) {
  n.exit("gfmFootnoteDefinition");
}
function pte(n, e, t) {
  const r = this;
  return it(n, i, "gfmFootnoteDefinitionIndent", 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? e(s) : t(s);
  }
}
function mte(n) {
  let t = (n || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: i
  };
  return t == null && (t = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, l) {
    let a = -1;
    for (; ++a < o.length; )
      if (o[a][0] === "enter" && o[a][1].type === "strikethroughSequenceTemporary" && o[a][1]._close) {
        let c = a;
        for (; c--; )
          if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && // If the sizes are the same:
          o[a][1].end.offset - o[a][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
            o[a][1].type = "strikethroughSequence", o[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, o[c][1].start),
              end: Object.assign({}, o[a][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, o[c][1].end),
              end: Object.assign({}, o[a][1].start)
            }, f = [["enter", u, l], ["enter", o[c][1], l], ["exit", o[c][1], l], ["enter", h, l]], d = l.parser.constructs.insideSpan.null;
            d && Jr(f, f.length, 0, v1(d, o.slice(c + 1, a), l)), Jr(f, f.length, 0, [["exit", h, l], ["enter", o[a][1], l], ["exit", o[a][1], l], ["exit", u, l]]), Jr(o, c - 1, a - c + 3, f), a = c + f.length - 2;
            break;
          }
      }
    for (a = -1; ++a < o.length; )
      o[a][1].type === "strikethroughSequenceTemporary" && (o[a][1].type = "data");
    return o;
  }
  function s(o, l, a) {
    const c = this.previous, u = this.events;
    let h = 0;
    return f;
    function f(p) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? a(p) : (o.enter("strikethroughSequenceTemporary"), d(p));
    }
    function d(p) {
      const m = zc(c);
      if (p === 126)
        return h > 1 ? a(p) : (o.consume(p), h++, d);
      if (h < 2 && !t) return a(p);
      const g = o.exit("strikethroughSequenceTemporary"), b = zc(p);
      return g._open = !b || b === 2 && !!m, g._close = !m || m === 2 && !!b, l(p);
    }
  }
}
class gte {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(e, t, r) {
    yte(this, e, t, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(e) {
    if (this.map.sort(function(s, o) {
      return s[0] - o[0];
    }), this.map.length === 0)
      return;
    let t = this.map.length;
    const r = [];
    for (; t > 0; )
      t -= 1, r.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), e.length = this.map[t][0];
    r.push(e.slice()), e.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const s of i)
        e.push(s);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function yte(n, e, t, r) {
  let i = 0;
  if (!(t === 0 && r.length === 0)) {
    for (; i < n.map.length; ) {
      if (n.map[i][0] === e) {
        n.map[i][1] += t, n.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    n.map.push([e, t, r]);
  }
}
function bte(n, e) {
  let t = !1;
  const r = [];
  for (; e < n.length; ) {
    const i = n[e];
    if (t) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(n[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (n[e - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (t = !0);
    e += 1;
  }
  return r;
}
function vte() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: wte,
        resolveAll: xte
      }
    }
  };
}
function wte(n, e, t) {
  const r = this;
  let i = 0, s = 0, o;
  return l;
  function l(R) {
    let V = r.events.length - 1;
    for (; V > -1; ) {
      const ie = r.events[V][1].type;
      if (ie === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      ie === "linePrefix") V--;
      else break;
    }
    const z = V > -1 ? r.events[V][1].type : null, ue = z === "tableHead" || z === "tableRow" ? T : a;
    return ue === T && r.parser.lazy[r.now().line] ? t(R) : ue(R);
  }
  function a(R) {
    return n.enter("tableHead"), n.enter("tableRow"), c(R);
  }
  function c(R) {
    return R === 124 || (o = !0, s += 1), u(R);
  }
  function u(R) {
    return R === null ? t(R) : Ne(R) ? s > 1 ? (s = 0, r.interrupt = !0, n.exit("tableRow"), n.enter("lineEnding"), n.consume(R), n.exit("lineEnding"), d) : t(R) : lt(R) ? it(n, u, "whitespace")(R) : (s += 1, o && (o = !1, i += 1), R === 124 ? (n.enter("tableCellDivider"), n.consume(R), n.exit("tableCellDivider"), o = !0, u) : (n.enter("data"), h(R)));
  }
  function h(R) {
    return R === null || R === 124 || It(R) ? (n.exit("data"), u(R)) : (n.consume(R), R === 92 ? f : h);
  }
  function f(R) {
    return R === 92 || R === 124 ? (n.consume(R), h) : h(R);
  }
  function d(R) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? t(R) : (n.enter("tableDelimiterRow"), o = !1, lt(R) ? it(n, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(R) : p(R));
  }
  function p(R) {
    return R === 45 || R === 58 ? g(R) : R === 124 ? (o = !0, n.enter("tableCellDivider"), n.consume(R), n.exit("tableCellDivider"), m) : M(R);
  }
  function m(R) {
    return lt(R) ? it(n, g, "whitespace")(R) : g(R);
  }
  function g(R) {
    return R === 58 ? (s += 1, o = !0, n.enter("tableDelimiterMarker"), n.consume(R), n.exit("tableDelimiterMarker"), b) : R === 45 ? (s += 1, b(R)) : R === null || Ne(R) ? C(R) : M(R);
  }
  function b(R) {
    return R === 45 ? (n.enter("tableDelimiterFiller"), w(R)) : M(R);
  }
  function w(R) {
    return R === 45 ? (n.consume(R), w) : R === 58 ? (o = !0, n.exit("tableDelimiterFiller"), n.enter("tableDelimiterMarker"), n.consume(R), n.exit("tableDelimiterMarker"), k) : (n.exit("tableDelimiterFiller"), k(R));
  }
  function k(R) {
    return lt(R) ? it(n, C, "whitespace")(R) : C(R);
  }
  function C(R) {
    return R === 124 ? p(R) : R === null || Ne(R) ? !o || i !== s ? M(R) : (n.exit("tableDelimiterRow"), n.exit("tableHead"), e(R)) : M(R);
  }
  function M(R) {
    return t(R);
  }
  function T(R) {
    return n.enter("tableRow"), N(R);
  }
  function N(R) {
    return R === 124 ? (n.enter("tableCellDivider"), n.consume(R), n.exit("tableCellDivider"), N) : R === null || Ne(R) ? (n.exit("tableRow"), e(R)) : lt(R) ? it(n, N, "whitespace")(R) : (n.enter("data"), B(R));
  }
  function B(R) {
    return R === null || R === 124 || It(R) ? (n.exit("data"), N(R)) : (n.consume(R), R === 92 ? $ : B);
  }
  function $(R) {
    return R === 92 || R === 124 ? (n.consume(R), B) : B(R);
  }
}
function xte(n, e) {
  let t = -1, r = !0, i = 0, s = [0, 0, 0, 0], o = [0, 0, 0, 0], l = !1, a = 0, c, u, h;
  const f = new gte();
  for (; ++t < n.length; ) {
    const d = n[t], p = d[1];
    d[0] === "enter" ? p.type === "tableHead" ? (l = !1, a !== 0 && (Mk(f, e, a, c, u), u = void 0, a = 0), c = {
      type: "table",
      start: Object.assign({}, p.start),
      // Note: correct end is set later.
      end: Object.assign({}, p.end)
    }, f.add(t, 0, [["enter", c, e]])) : p.type === "tableRow" || p.type === "tableDelimiterRow" ? (r = !0, h = void 0, s = [0, 0, 0, 0], o = [0, t + 1, 0, 0], l && (l = !1, u = {
      type: "tableBody",
      start: Object.assign({}, p.start),
      // Note: correct end is set later.
      end: Object.assign({}, p.end)
    }, f.add(t, 0, [["enter", u, e]])), i = p.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (s[1] !== 0 && (o[0] = o[1], h = S0(f, e, s, i, void 0, h), s = [0, 0, 0, 0]), o[2] = t)) : p.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (o[0] = o[1], h = S0(f, e, s, i, void 0, h)), s = o, o = [s[1], t, 0, 0])) : p.type === "tableHead" ? (l = !0, a = t) : p.type === "tableRow" || p.type === "tableDelimiterRow" ? (a = t, s[1] !== 0 ? (o[0] = o[1], h = S0(f, e, s, i, t, h)) : o[1] !== 0 && (h = S0(f, e, o, i, t, h)), i = 0) : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") && (o[3] = t);
  }
  for (a !== 0 && Mk(f, e, a, c, u), f.consume(e.events), t = -1; ++t < e.events.length; ) {
    const d = e.events[t];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = bte(e.events, t));
  }
  return n;
}
function S0(n, e, t, r, i, s) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", l = "tableContent";
  t[0] !== 0 && (s.end = Object.assign({}, sc(e.events, t[0])), n.add(t[0], 0, [["exit", s, e]]));
  const a = sc(e.events, t[1]);
  if (s = {
    type: o,
    start: Object.assign({}, a),
    // Note: correct end is set later.
    end: Object.assign({}, a)
  }, n.add(t[1], 0, [["enter", s, e]]), t[2] !== 0) {
    const c = sc(e.events, t[2]), u = sc(e.events, t[3]), h = {
      type: l,
      start: Object.assign({}, c),
      end: Object.assign({}, u)
    };
    if (n.add(t[2], 0, [["enter", h, e]]), r !== 2) {
      const f = e.events[t[2]], d = e.events[t[3]];
      if (f[1].end = Object.assign({}, d[1].end), f[1].type = "chunkText", f[1].contentType = "text", t[3] > t[2] + 1) {
        const p = t[2] + 1, m = t[3] - t[2] - 1;
        n.add(p, m, []);
      }
    }
    n.add(t[3] + 1, 0, [["exit", h, e]]);
  }
  return i !== void 0 && (s.end = Object.assign({}, sc(e.events, i)), n.add(i, 0, [["exit", s, e]]), s = void 0), s;
}
function Mk(n, e, t, r, i) {
  const s = [], o = sc(e.events, t);
  i && (i.end = Object.assign({}, o), s.push(["exit", i, e])), r.end = Object.assign({}, o), s.push(["exit", r, e]), n.add(t + 1, 0, s);
}
function sc(n, e) {
  const t = n[e], r = t[0] === "enter" ? "start" : "end";
  return t[1][r];
}
const kte = {
  name: "tasklistCheck",
  tokenize: Cte
};
function Ste() {
  return {
    text: {
      91: kte
    }
  };
}
function Cte(n, e, t) {
  const r = this;
  return i;
  function i(a) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? t(a) : (n.enter("taskListCheck"), n.enter("taskListCheckMarker"), n.consume(a), n.exit("taskListCheckMarker"), s)
    );
  }
  function s(a) {
    return It(a) ? (n.enter("taskListCheckValueUnchecked"), n.consume(a), n.exit("taskListCheckValueUnchecked"), o) : a === 88 || a === 120 ? (n.enter("taskListCheckValueChecked"), n.consume(a), n.exit("taskListCheckValueChecked"), o) : t(a);
  }
  function o(a) {
    return a === 93 ? (n.enter("taskListCheckMarker"), n.consume(a), n.exit("taskListCheckMarker"), n.exit("taskListCheck"), l) : t(a);
  }
  function l(a) {
    return Ne(a) ? e(a) : lt(a) ? n.check({
      tokenize: Mte
    }, e, t)(a) : t(a);
  }
}
function Mte(n, e, t) {
  return it(n, r, "whitespace");
  function r(i) {
    return i === null ? t(i) : e(i);
  }
}
function Tte(n) {
  return CT([
    Xee(),
    lte(),
    mte(n),
    vte(),
    Ste()
  ]);
}
const Ate = {};
function Ote(n) {
  const e = (
    /** @type {Processor<Root>} */
    this
  ), t = n || Ate, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(Tte(t)), s.push(Kee()), o.push(Gee(t));
}
function Je(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/preset-gfm",
      ...e
    }
  }), n;
}
const Ov = bd("strike_through");
Je(Ov, {
  displayName: "Attr<strikethrough>",
  group: "Strikethrough"
});
const uu = ru("strike_through", (n) => ({
  parseDOM: [
    { tag: "del" },
    {
      style: "text-decoration",
      getAttrs: (e) => e === "line-through"
    }
  ],
  toDOM: (e) => ["del", n.get(Ov.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "delete",
    runner: (e, t, r) => {
      e.openMark(r), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strike_through",
    runner: (e, t) => {
      e.withMark(t, "delete");
    }
  }
}));
Je(uu.mark, {
  displayName: "MarkSchema<strikethrough>",
  group: "Strikethrough"
});
Je(uu.ctx, {
  displayName: "MarkSchemaCtx<strikethrough>",
  group: "Strikethrough"
});
const X1 = Ye(
  "ToggleStrikeThrough",
  (n) => () => k1(uu.type(n))
);
Je(X1, {
  displayName: "Command<ToggleStrikethrough>",
  group: "Strikethrough"
});
const hI = Qn((n) => hd(
  new RegExp("(?<![\\w:/])(~{1,2})(.+?)\\1(?!\\w|\\/)"),
  uu.type(n)
));
Je(hI, {
  displayName: "InputRule<strikethrough>",
  group: "Strikethrough"
});
const Ev = Rr("strikeThroughKeymap", {
  ToggleStrikethrough: {
    shortcuts: "Mod-Alt-x",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(X1.key);
    }
  }
});
Je(Ev.ctx, {
  displayName: "KeymapCtx<strikethrough>",
  group: "Strikethrough"
});
Je(Ev.shortcuts, {
  displayName: "Keymap<strikethrough>",
  group: "Strikethrough"
});
const Od = eQ({
  tableGroup: "block",
  cellContent: "paragraph",
  cellAttributes: {
    alignment: {
      default: "left",
      getFromDOM: (n) => n.style.textAlign || "left",
      setDOMAttr: (n, e) => {
        e.style = `text-align: ${n || "left"}`;
      }
    }
  }
}), Ha = hn("table", () => ({
  ...Od.table,
  content: "table_header_row table_row+",
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "table",
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r,
        isHeader: o === 0
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table",
    runner: (n, e) => {
      const t = e.content.firstChild?.content;
      if (!t) return;
      const r = [];
      t.forEach((i) => {
        r.push(i.attrs.alignment);
      }), n.openNode("table", void 0, { align: r }), n.next(e.content), n.closeNode();
    }
  }
}));
Je(Ha.node, {
  displayName: "NodeSchema<table>",
  group: "Table"
});
Je(Ha.ctx, {
  displayName: "NodeSchemaCtx<table>",
  group: "Table"
});
const Z1 = hn("table_header_row", () => ({
  ...Od.table_row,
  disableDropCursor: !0,
  content: "(table_header)*",
  parseDOM: [{ tag: "tr[data-is-header]" }],
  toDOM() {
    return ["tr", { "data-is-header": !0 }, 0];
  },
  parseMarkdown: {
    match: (n) => !!(n.type === "tableRow" && n.isHeader),
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r[o],
        isHeader: e.isHeader
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_header_row",
    runner: (n, e) => {
      n.openNode("tableRow", void 0, { isHeader: !0 }), n.next(e.content), n.closeNode();
    }
  }
}));
Je(Z1.node, {
  displayName: "NodeSchema<tableHeaderRow>",
  group: "Table"
});
Je(Z1.ctx, {
  displayName: "NodeSchemaCtx<tableHeaderRow>",
  group: "Table"
});
const Ed = hn("table_row", () => ({
  ...Od.table_row,
  disableDropCursor: !0,
  content: "(table_cell)*",
  parseMarkdown: {
    match: (n) => n.type === "tableRow",
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r[o]
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_row",
    runner: (n, e) => {
      e.content.size !== 0 && (n.openNode("tableRow"), n.next(e.content), n.closeNode());
    }
  }
}));
Je(Ed.node, {
  displayName: "NodeSchema<tableRow>",
  group: "Table"
});
Je(Ed.ctx, {
  displayName: "NodeSchemaCtx<tableRow>",
  group: "Table"
});
const Id = hn("table_cell", () => ({
  ...Od.table_cell,
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "tableCell" && !n.isHeader,
    runner: (n, e, t) => {
      const r = e.align;
      n.openNode(t, { alignment: r }).openNode(n.schema.nodes.paragraph).next(e.children).closeNode().closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_cell",
    runner: (n, e) => {
      n.openNode("tableCell").next(e.content).closeNode();
    }
  }
}));
Je(Id.node, {
  displayName: "NodeSchema<tableCell>",
  group: "Table"
});
Je(Id.ctx, {
  displayName: "NodeSchemaCtx<tableCell>",
  group: "Table"
});
const Q1 = hn("table_header", () => ({
  ...Od.table_header,
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "tableCell" && !!n.isHeader,
    runner: (n, e, t) => {
      const r = e.align;
      n.openNode(t, { alignment: r }), n.openNode(n.schema.nodes.paragraph), n.next(e.children), n.closeNode(), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_header",
    runner: (n, e) => {
      n.openNode("tableCell"), n.next(e.content), n.closeNode();
    }
  }
}));
Je(Q1.node, {
  displayName: "NodeSchema<tableHeader>",
  group: "Table"
});
Je(Q1.ctx, {
  displayName: "NodeSchemaCtx<tableHeader>",
  group: "Table"
});
function Iv(n, e = 3, t = 3) {
  const r = Array(t).fill(0).map(() => Id.type(n).createAndFill()), i = Array(t).fill(0).map(() => Q1.type(n).createAndFill()), s = Array(e).fill(0).map(
    (o, l) => l === 0 ? Z1.type(n).create(null, i) : Ed.type(n).create(null, r)
  );
  return Ha.type(n).create(null, s);
}
function hu(n) {
  return N3(
    (e) => e.type.spec.tableRole === "table"
  )(n);
}
function oc(n, e) {
  const t = hu(e.$from);
  if (!t) return;
  const r = vt.get(t.node);
  return (Array.isArray(n) ? n : [n]).filter((s) => s >= 0 && s <= r.width - 1).flatMap((s) => r.cellsInRect({
    left: s,
    right: s + 1,
    top: 0,
    bottom: r.height
  }).map((l) => {
    const a = t.node.nodeAt(l), c = l + t.start;
    return { pos: c, start: c + 1, node: a, depth: t.depth + 2 };
  }));
}
function lc(n, e) {
  const t = hu(e.$from);
  if (!t)
    return;
  const r = vt.get(t.node);
  return (Array.isArray(n) ? n : [n]).filter((s) => s >= 0 && s <= r.height - 1).flatMap((s) => r.cellsInRect({
    left: 0,
    right: r.width,
    top: s,
    bottom: s + 1
  }).map((l) => {
    const a = t.node.nodeAt(l), c = l + t.start;
    return { pos: c, start: c + 1, node: a, depth: t.depth + 2 };
  }));
}
function fI(n) {
  return (e, t) => (r) => {
    t = t ?? r.selection.from;
    const i = r.doc.resolve(t), s = N3(
      (a) => a.type.name === "table"
    )(i), o = s ? {
      node: s.node,
      from: s.start
    } : void 0, l = n === "row";
    if (o) {
      const a = vt.get(o.node);
      if (e >= 0 && e < (l ? a.height : a.width)) {
        const c = a.positionAt(
          l ? e : a.height - 1,
          l ? a.width - 1 : e,
          o.node
        ), u = r.doc.resolve(o.from + c), h = l ? Dt.rowSelection : Dt.colSelection, f = a.positionAt(
          l ? e : 0,
          l ? 0 : e,
          o.node
        ), d = r.doc.resolve(o.from + f);
        return wT(
          r.setSelection(
            h(u, d)
          )
        );
      }
    }
    return r;
  };
}
const Ete = fI("row"), Ite = fI("col");
function dI(n, e, { map: t, tableStart: r, table: i }, s) {
  const o = Array(s).fill(0).reduce((a, c, u) => a + i.child(u).nodeSize, r), l = Array(t.width).fill(0).map((a, c) => {
    const u = i.nodeAt(t.map[c]);
    return Id.type(n).createAndFill({ alignment: u?.attrs.alignment });
  });
  return e.insert(o, Ed.type(n).create(null, l)), e;
}
function pI(n, e) {
  const t = [], r = vt.get(n);
  for (let s = 0; s < r.height; s++) {
    const o = n.child(s), l = [];
    for (let a = 0; a < r.width; a++) {
      if (!e[s][a]) continue;
      const c = r.map[s * r.width + a], u = e[s][a], f = n.nodeAt(c).type.createChecked(
        Object.assign({}, u.attrs),
        u.content,
        u.marks
      );
      l.push(f);
    }
    t.push(o.type.createChecked(o.attrs, l, o.marks));
  }
  return n.type.createChecked(
    n.attrs,
    t,
    n.marks
  );
}
function mI(n) {
  const e = vt.get(n), t = [], r = e.height, i = e.width;
  for (let s = 0; s < r; s++) {
    const o = [];
    for (let l = 0; l < i; l++) {
      let a = s * i + l, c = e.map[a];
      if (s > 0) {
        const u = a - i, h = e.map[u];
        if (c === h) {
          o.push(null);
          continue;
        }
      }
      if (l > 0) {
        const u = a - 1, h = e.map[u];
        if (c === h) {
          o.push(null);
          continue;
        }
      }
      c ? o.push(n.nodeAt(c)) : o.push(null);
    }
    t.push(o);
  }
  return t;
}
function Tk(n, e, t = e) {
  let r = e, i = t;
  for (let h = e; h >= 0; h--) {
    const f = lc(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.rowspan + h - 1;
      p >= r && (r = h), p > i && (i = p);
    });
  }
  for (let h = e; h <= i; h++) {
    const f = lc(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.rowspan + h - 1;
      d.node.attrs.rowspan > 1 && p > i && (i = p);
    });
  }
  const s = [];
  for (let h = r; h <= i; h++) {
    const f = lc(h, n.selection);
    f && f.length > 0 && s.push(h);
  }
  r = s[0], i = s[s.length - 1];
  const o = lc(r, n.selection), l = oc(0, n.selection);
  if (!o || !l)
    return;
  const a = n.doc.resolve(
    o[o.length - 1].pos
  );
  let c;
  for (let h = i; h >= r; h--) {
    const f = lc(h, n.selection);
    if (f && f.length > 0) {
      for (let d = l.length - 1; d >= 0; d--)
        if (l[d].pos === f[0].pos) {
          c = f[0];
          break;
        }
      if (c)
        break;
    }
  }
  if (!c)
    return;
  const u = n.doc.resolve(c.pos);
  return { $anchor: a, $head: u, indexes: s };
}
function gI(n, e, t, r) {
  const i = e[0] > t[0] ? -1 : 1, s = n.splice(e[0], e.length), o = s.length % 2 === 0 ? 1 : 0;
  let l;
  return l = i === -1 ? t[0] : t[t.length - 1] - o, n.splice(l, 0, ...s), n;
}
function Dte(n) {
  const { tr: e, origin: t, target: r, pos: i } = n, s = e.doc.resolve(i), o = hu(s);
  if (!o) return !1;
  const l = Tk(e, t)?.indexes, a = Tk(e, r)?.indexes;
  if (!l || !a || l.includes(r)) return !1;
  const c = Nte(
    o.node,
    l,
    a
  );
  e.replaceWith(o.pos, o.pos + o.node.nodeSize, c);
  const u = vt.get(c), h = o.start, f = r, d = u.positionAt(f, u.width - 1, c), p = e.doc.resolve(h + d), m = u.positionAt(f, 0, c), g = e.doc.resolve(h + m);
  return e.setSelection(Dt.rowSelection(p, g)), !0;
}
function Nte(n, e, t, r) {
  let i = mI(n);
  return i = gI(i, e, t), pI(n, i);
}
function Ak(n, e, t = e) {
  let r = e, i = t;
  for (let h = e; h >= 0; h--) {
    const f = oc(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.colspan + h - 1;
      p >= r && (r = h), p > i && (i = p);
    });
  }
  for (let h = e; h <= i; h++) {
    const f = oc(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.colspan + h - 1;
      d.node.attrs.colspan > 1 && p > i && (i = p);
    });
  }
  const s = [];
  for (let h = r; h <= i; h++) {
    const f = oc(h, n.selection);
    f && f.length > 0 && s.push(h);
  }
  r = s[0], i = s[s.length - 1];
  const o = oc(r, n.selection), l = lc(0, n.selection);
  if (!o || !l)
    return;
  const a = n.doc.resolve(
    o[o.length - 1].pos
  );
  let c;
  for (let h = i; h >= r; h--) {
    const f = oc(h, n.selection);
    if (f && f.length > 0) {
      for (let d = l.length - 1; d >= 0; d--)
        if (l[d].pos === f[0].pos) {
          c = f[0];
          break;
        }
      if (c)
        break;
    }
  }
  if (!c)
    return;
  const u = n.doc.resolve(c.pos);
  return { $anchor: a, $head: u, indexes: s };
}
function Ok(n) {
  return n[0].map((e, t) => n.map((r) => r[t]));
}
function Rte(n) {
  const { tr: e, origin: t, target: r, pos: i } = n, s = e.doc.resolve(i), o = hu(s);
  if (!o) return !1;
  const l = Ak(e, t)?.indexes, a = Ak(e, r)?.indexes;
  if (!l || !a || l.includes(r)) return !1;
  const c = Pte(
    o.node,
    l,
    a
  );
  e.replaceWith(o.pos, o.pos + o.node.nodeSize, c);
  const u = vt.get(c), h = o.start, f = r, d = u.positionAt(u.height - 1, f, c), p = e.doc.resolve(h + d), m = u.positionAt(0, f, c), g = e.doc.resolve(h + m);
  return e.setSelection(Dt.colSelection(p, g)), !0;
}
function Pte(n, e, t, r) {
  let i = Ok(mI(n));
  return i = gI(i, e, t), i = Ok(i), pI(n, i);
}
function _te(n) {
  const e = hu(n.$from);
  if (!e) return;
  const t = vt.get(e.node);
  return t.cellsInRect({
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  }).map((i) => {
    const s = e.node.nodeAt(i), o = i + e.start;
    return { pos: o, start: o + 1, node: s };
  });
}
function Lte(n) {
  const e = _te(n.selection);
  if (e && e[0]) {
    const t = n.doc.resolve(e[0].pos), r = e[e.length - 1];
    if (r) {
      const i = n.doc.resolve(r.pos);
      return wT(n.setSelection(new Dt(i, t)));
    }
  }
  return n;
}
const Dv = Ye(
  "GoToPrevTableCell",
  () => () => YE(-1)
);
Je(Dv, {
  displayName: "Command<goToPrevTableCellCommand>",
  group: "Table"
});
const Nv = Ye(
  "GoToNextTableCell",
  () => () => YE(1)
);
Je(Nv, {
  displayName: "Command<goToNextTableCellCommand>",
  group: "Table"
});
const Rv = Ye(
  "ExitTable",
  (n) => () => (e, t) => {
    if (!Si(e)) return !1;
    const { $head: r } = e.selection, i = gV(r, Ha.type(n));
    if (!i) return !1;
    const { to: s } = i, o = e.tr.replaceWith(
      s,
      s,
      Os.type(n).createAndFill()
    );
    return o.setSelection(Ge.near(o.doc.resolve(s), 1)).scrollIntoView(), t?.(o), !0;
  }
);
Je(Rv, {
  displayName: "Command<breakTableCommand>",
  group: "Table"
});
const yI = Ye(
  "InsertTable",
  (n) => ({ row: e, col: t } = {}) => (r, i) => {
    const { selection: s, tr: o } = r, { from: l } = s, a = Iv(n, e, t), c = o.replaceSelectionWith(a), u = Ge.findFrom(c.doc.resolve(l), 1, !0);
    return u && c.setSelection(u), i?.(c), !0;
  }
);
Je(yI, {
  displayName: "Command<insertTableCommand>",
  group: "Table"
});
const Pv = Ye(
  "MoveRow",
  () => ({ from: n, to: e, pos: t } = {}) => (r, i) => {
    const { tr: s } = r;
    return Dte({
      tr: s,
      origin: n ?? 0,
      target: e ?? 0,
      pos: t ?? r.selection.from
    }) ? (i?.(s), !0) : !1;
  }
);
Je(Pv, {
  displayName: "Command<moveRowCommand>",
  group: "Table"
});
const _v = Ye(
  "MoveCol",
  () => ({ from: n, to: e, pos: t } = {}) => (r, i) => {
    const { tr: s } = r;
    return Rte({
      tr: s,
      origin: n ?? 0,
      target: e ?? 0,
      pos: t ?? r.selection.from
    }) ? (i?.(s), !0) : !1;
  }
);
Je(_v, {
  displayName: "Command<moveColCommand>",
  group: "Table"
});
const ta = Ye(
  "SelectRow",
  () => (n = { index: 0 }) => (e, t) => {
    const { tr: r } = e;
    return !!t?.(Ete(n.index, n.pos)(r));
  }
);
Je(ta, {
  displayName: "Command<selectRowCommand>",
  group: "Table"
});
const na = Ye(
  "SelectCol",
  () => (n = { index: 0 }) => (e, t) => {
    const { tr: r } = e;
    return !!t?.(Ite(n.index, n.pos)(r));
  }
);
Je(na, {
  displayName: "Command<selectColCommand>",
  group: "Table"
});
const bI = Ye(
  "SelectTable",
  () => () => (n, e) => {
    const { tr: t } = n;
    return !!e?.(Lte(t));
  }
);
Je(bI, {
  displayName: "Command<selectTableCommand>",
  group: "Table"
});
const Lv = Ye(
  "DeleteSelectedCells",
  () => () => (n, e) => {
    const { selection: t } = n;
    if (!(t instanceof Dt)) return !1;
    const r = t.isRowSelection(), i = t.isColSelection();
    return r && i ? kQ(n, e) : i ? gQ(n, e) : bQ(n, e);
  }
);
Je(Lv, {
  displayName: "Command<deleteSelectedCellsCommand>",
  group: "Table"
});
const Bv = Ye(
  "AddColBefore",
  () => () => dQ
);
Je(Bv, {
  displayName: "Command<addColBeforeCommand>",
  group: "Table"
});
const zv = Ye(
  "AddColAfter",
  () => () => pQ
);
Je(zv, {
  displayName: "Command<addColAfterCommand>",
  group: "Table"
});
const Fv = Ye(
  "AddRowBefore",
  (n) => () => (e, t) => {
    if (!Si(e)) return !1;
    if (t) {
      const r = Tl(e);
      t(dI(n, e.tr, r, r.top));
    }
    return !0;
  }
);
Je(Fv, {
  displayName: "Command<addRowBeforeCommand>",
  group: "Table"
});
const Hv = Ye(
  "AddRowAfter",
  (n) => () => (e, t) => {
    if (!Si(e)) return !1;
    if (t) {
      const r = Tl(e);
      t(dI(n, e.tr, r, r.bottom));
    }
    return !0;
  }
);
Je(Hv, {
  displayName: "Command<addRowAfterCommand>",
  group: "Table"
});
const $v = Ye(
  "SetAlign",
  () => (n = "left") => vQ("alignment", n)
);
Je($v, {
  displayName: "Command<setAlignCommand>",
  group: "Table"
});
const vI = Qn(
  (n) => new Ir(
    /^\|(?<col>\d+)[xX](?<row>\d+)\|\s$/,
    (e, t, r, i) => {
      const s = e.doc.resolve(r);
      if (!s.node(-1).canReplaceWith(
        s.index(-1),
        s.indexAfter(-1),
        Ha.type(n)
      ))
        return null;
      const o = Math.max(Number(t.groups?.row ?? 0), 2), l = Iv(n, o, Number(t.groups?.col)), a = e.tr.replaceRangeWith(r, i, l);
      return a.setSelection(Ee.create(a.doc, r + 3)).scrollIntoView();
    }
  )
);
Je(vI, {
  displayName: "InputRule<insertTableInputRule>",
  group: "Table"
});
const Vv = Rr("tableKeymap", {
  NextCell: {
    priority: 100,
    shortcuts: ["Mod-]", "Tab"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Nv.key);
    }
  },
  PrevCell: {
    shortcuts: ["Mod-[", "Shift-Tab"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Dv.key);
    }
  },
  ExitTable: {
    shortcuts: ["Mod-Enter", "Enter"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(Rv.key);
    }
  }
});
Je(Vv.ctx, {
  displayName: "KeymapCtx<table>",
  group: "Table"
});
Je(Vv.shortcuts, {
  displayName: "Keymap<table>",
  group: "Table"
});
const G2 = "footnote_definition", Ek = "footnoteDefinition", qv = hn(
  "footnote_definition",
  () => ({
    group: "block",
    content: "block+",
    defining: !0,
    attrs: {
      label: {
        default: "",
        validate: "string"
      }
    },
    parseDOM: [
      {
        tag: `dl[data-type="${G2}"]`,
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement)) throw Vi(n);
          return {
            label: n.dataset.label
          };
        },
        contentElement: "dd"
      }
    ],
    toDOM: (n) => {
      const e = n.attrs.label;
      return [
        "dl",
        {
          // TODO: add a prosemirror plugin to sync label on change
          "data-label": e,
          "data-type": G2
        },
        ["dt", e],
        ["dd", 0]
      ];
    },
    parseMarkdown: {
      match: ({ type: n }) => n === Ek,
      runner: (n, e, t) => {
        n.openNode(t, {
          label: e.label
        }).next(e.children).closeNode();
      }
    },
    toMarkdown: {
      match: (n) => n.type.name === G2,
      runner: (n, e) => {
        n.openNode(Ek, void 0, {
          label: e.attrs.label,
          identifier: e.attrs.label
        }).next(e.content).closeNode();
      }
    }
  })
);
Je(qv.ctx, {
  displayName: "NodeSchemaCtx<footnodeDef>",
  group: "footnote"
});
Je(qv.node, {
  displayName: "NodeSchema<footnodeDef>",
  group: "footnote"
});
const Y2 = "footnote_reference", Wv = hn(
  "footnote_reference",
  () => ({
    group: "inline",
    inline: !0,
    atom: !0,
    attrs: {
      label: {
        default: "",
        validate: "string"
      }
    },
    parseDOM: [
      {
        tag: `sup[data-type="${Y2}"]`,
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement)) throw Vi(n);
          return {
            label: n.dataset.label
          };
        }
      }
    ],
    toDOM: (n) => {
      const e = n.attrs.label;
      return [
        "sup",
        {
          // TODO: add a prosemirror plugin to sync label on change
          "data-label": e,
          "data-type": Y2
        },
        e
      ];
    },
    parseMarkdown: {
      match: ({ type: n }) => n === "footnoteReference",
      runner: (n, e, t) => {
        n.addNode(t, {
          label: e.label
        });
      }
    },
    toMarkdown: {
      match: (n) => n.type.name === Y2,
      runner: (n, e) => {
        n.addNode("footnoteReference", void 0, void 0, {
          label: e.attrs.label,
          identifier: e.attrs.label
        });
      }
    }
  })
);
Je(Wv.ctx, {
  displayName: "NodeSchemaCtx<footnodeRef>",
  group: "footnote"
});
Je(Wv.node, {
  displayName: "NodeSchema<footnodeRef>",
  group: "footnote"
});
const jv = Wi.extendSchema(
  (n) => (e) => {
    const t = n(e);
    return {
      ...t,
      attrs: {
        ...t.attrs,
        checked: {
          default: null,
          validate: "boolean|null"
        }
      },
      parseDOM: [
        {
          tag: 'li[data-item-type="task"]',
          getAttrs: (r) => {
            if (!(r instanceof HTMLElement)) throw Vi(r);
            return {
              label: r.dataset.label,
              listType: r.dataset.listType,
              spread: r.dataset.spread,
              checked: r.dataset.checked ? r.dataset.checked === "true" : null
            };
          }
        },
        ...t?.parseDOM || []
      ],
      toDOM: (r) => t.toDOM && r.attrs.checked == null ? t.toDOM(r) : [
        "li",
        {
          "data-item-type": "task",
          "data-label": r.attrs.label,
          "data-list-type": r.attrs.listType,
          "data-spread": r.attrs.spread,
          "data-checked": r.attrs.checked
        },
        0
      ],
      parseMarkdown: {
        match: ({ type: r }) => r === "listItem",
        runner: (r, i, s) => {
          if (i.checked == null) {
            t.parseMarkdown.runner(r, i, s);
            return;
          }
          const o = i.label != null ? `${i.label}.` : "•", l = i.checked != null ? !!i.checked : null, a = i.label != null ? "ordered" : "bullet", c = i.spread != null ? `${i.spread}` : "true";
          r.openNode(s, { label: o, listType: a, spread: c, checked: l }), r.next(i.children), r.closeNode();
        }
      },
      toMarkdown: {
        match: (r) => r.type.name === "list_item",
        runner: (r, i) => {
          if (i.attrs.checked == null) {
            t.toMarkdown.runner(r, i);
            return;
          }
          const s = i.attrs.label, o = i.attrs.listType, l = i.attrs.spread === "true", a = i.attrs.checked;
          r.openNode("listItem", void 0, {
            label: s,
            listType: o,
            spread: l,
            checked: a
          }), r.next(i.content), r.closeNode();
        }
      }
    };
  }
);
Je(jv.node, {
  displayName: "NodeSchema<taskListItem>",
  group: "ListItem"
});
Je(jv.ctx, {
  displayName: "NodeSchemaCtx<taskListItem>",
  group: "ListItem"
});
const wI = Qn(() => new Ir(
  /^\[(?<checked>\s|x)\]\s$/,
  (n, e, t, r) => {
    const i = n.doc.resolve(t);
    let s = 0, o = i.node(s);
    for (; o && o.type.name !== "list_item"; )
      s--, o = i.node(s);
    if (!o || o.attrs.checked != null) return null;
    const l = e.groups?.checked === "x", a = i.before(s), c = n.tr;
    return c.deleteRange(t, r).setNodeMarkup(a, void 0, {
      ...o.attrs,
      checked: l
    }), c;
  }
));
Je(wI, {
  displayName: "InputRule<wrapInTaskListInputRule>",
  group: "ListItem"
});
const Bte = [
  Ev,
  Vv
].flat(), zte = [
  vI,
  wI
], Fte = [hI], xI = kn(() => XQ);
Je(xI, {
  displayName: "Prose<autoInsertSpanPlugin>",
  group: "Prose"
});
const Hte = kn(() => NQ({}));
Je(Hte, {
  displayName: "Prose<columnResizingPlugin>",
  group: "Prose"
});
const kI = kn(
  () => VQ({ allowTableNodeSelection: !0 })
);
Je(kI, {
  displayName: "Prose<tableEditingPlugin>",
  group: "Prose"
});
const Uv = As("remarkGFM", () => Ote);
Je(Uv.plugin, {
  displayName: "Remark<remarkGFMPlugin>",
  group: "Remark"
});
Je(Uv.options, {
  displayName: "RemarkConfig<remarkGFMPlugin>",
  group: "Remark"
});
const $te = new en("MILKDOWN_KEEP_TABLE_ALIGN_PLUGIN");
function Vte(n, e) {
  let t = 0;
  return e.forEach((r, i, s) => {
    r === n && (t = s);
  }), t;
}
const SI = kn(() => new Ut({
  key: $te,
  appendTransaction: (n, e, t) => {
    let r;
    const i = (s, o) => {
      if (r || (r = t.tr), s.type.name !== "table_cell") return;
      const l = t.doc.resolve(o), a = l.node(l.depth), u = l.node(l.depth - 1).firstChild;
      if (!u) return;
      const h = Vte(s, a), f = u.maybeChild(h);
      if (!f) return;
      const d = f.attrs.alignment, p = s.attrs.alignment;
      d !== p && r.setNodeMarkup(o, void 0, { ...s.attrs, alignment: d });
    };
    return e.doc !== t.doc && t.doc.descendants(i), r;
  }
}));
Je(SI, {
  displayName: "Prose<keepTableAlignPlugin>",
  group: "Prose"
});
const qte = [
  SI,
  xI,
  Uv,
  kI
].flat(), Wte = [
  jv,
  Ha,
  Z1,
  Ed,
  Q1,
  Id,
  qv,
  Wv,
  Ov,
  uu
].flat(), jte = [
  Nv,
  Dv,
  Rv,
  yI,
  Pv,
  _v,
  ta,
  na,
  bI,
  Lv,
  Fv,
  Hv,
  Bv,
  zv,
  $v,
  X1
], Ute = [
  Wte,
  zte,
  Fte,
  Bte,
  jte,
  qte
].flat(), Kte = (n) => {
  let { state: e } = n, t = e.doc.lineAt(e.selection.main.from), r = Gv(n.state, t.from);
  return r.line ? Gte(n) : r.block ? Jte(n) : !1;
};
function Kv(n, e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let i = n(e, t);
    return i ? (r(t.update(i)), !0) : !1;
  };
}
const Gte = /* @__PURE__ */ Kv(
  Qte,
  0
  /* CommentOption.Toggle */
), Yte = /* @__PURE__ */ Kv(
  CI,
  0
  /* CommentOption.Toggle */
), Jte = /* @__PURE__ */ Kv(
  (n, e) => CI(n, e, Zte(e)),
  0
  /* CommentOption.Toggle */
);
function Gv(n, e) {
  let t = n.languageDataAt("commentTokens", e, 1);
  return t.length ? t[0] : {};
}
const Ku = 50;
function Xte(n, { open: e, close: t }, r, i) {
  let s = n.sliceDoc(r - Ku, r), o = n.sliceDoc(i, i + Ku), l = /\s*$/.exec(s)[0].length, a = /^\s*/.exec(o)[0].length, c = s.length - l;
  if (s.slice(c - e.length, c) == e && o.slice(a, a + t.length) == t)
    return {
      open: { pos: r - l, margin: l && 1 },
      close: { pos: i + a, margin: a && 1 }
    };
  let u, h;
  i - r <= 2 * Ku ? u = h = n.sliceDoc(r, i) : (u = n.sliceDoc(r, r + Ku), h = n.sliceDoc(i - Ku, i));
  let f = /^\s*/.exec(u)[0].length, d = /\s*$/.exec(h)[0].length, p = h.length - d - t.length;
  return u.slice(f, f + e.length) == e && h.slice(p, p + t.length) == t ? {
    open: {
      pos: r + f + e.length,
      margin: /\s/.test(u.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: i - d - t.length,
      margin: /\s/.test(h.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function Zte(n) {
  let e = [];
  for (let t of n.selection.ranges) {
    let r = n.doc.lineAt(t.from), i = t.to <= r.to ? r : n.doc.lineAt(t.to);
    i.from > r.from && i.from == t.to && (i = t.to == r.to + 1 ? r : n.doc.lineAt(t.to - 1));
    let s = e.length - 1;
    s >= 0 && e[s].to > r.from ? e[s].to = i.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function CI(n, e, t = e.selection.ranges) {
  let r = t.map((s) => Gv(e, s.from).block);
  if (!r.every((s) => s))
    return null;
  let i = t.map((s, o) => Xte(e, r[o], s.from, s.to));
  if (n != 2 && !i.every((s) => s))
    return { changes: e.changes(t.map((s, o) => i[o] ? [] : [{ from: s.from, insert: r[o].open + " " }, { from: s.to, insert: " " + r[o].close }])) };
  if (n != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, l; o < i.length; o++)
      if (l = i[o]) {
        let a = r[o], { open: c, close: u } = l;
        s.push({ from: c.pos - a.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + a.close.length });
      }
    return { changes: s };
  }
  return null;
}
function Qte(n, e, t = e.selection.ranges) {
  let r = [], i = -1;
  for (let { from: s, to: o } of t) {
    let l = r.length, a = 1e9, c = Gv(e, s).line;
    if (c) {
      for (let u = s; u <= o; ) {
        let h = e.doc.lineAt(u);
        if (h.from > i && (s == o || o > h.from)) {
          i = h.from;
          let f = /^\s*/.exec(h.text)[0].length, d = f == h.length, p = h.text.slice(f, f + c.length) == c ? f : -1;
          f < h.text.length && f < a && (a = f), r.push({ line: h, comment: p, token: c, indent: f, empty: d, single: !1 });
        }
        u = h.to + 1;
      }
      if (a < 1e9)
        for (let u = l; u < r.length; u++)
          r[u].indent < r[u].line.text.length && (r[u].indent = a);
      r.length == l + 1 && (r[l].single = !0);
    }
  }
  if (n != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: a, indent: c, empty: u, single: h } of r)
      (h || !u) && s.push({ from: l.from + c, insert: a + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (n != 1 && r.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: l, token: a } of r)
      if (l >= 0) {
        let c = o.from + l, u = c + a.length;
        o.text[u - o.from] == " " && u++, s.push({ from: c, to: u });
      }
    return { changes: s };
  }
  return null;
}
const M5 = /* @__PURE__ */ vo.define(), ene = /* @__PURE__ */ vo.define(), tne = /* @__PURE__ */ xe.define(), MI = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (r, i) => e(r, i) || t(r, i)
    });
  }
}), TI = /* @__PURE__ */ On.define({
  create() {
    return df.empty;
  },
  update(n, e) {
    let t = e.state.facet(MI), r = e.annotation(M5);
    if (r) {
      let a = Ar.fromTransaction(e, r.selection), c = r.side, u = c == 0 ? n.undone : n.done;
      return a ? u = _m(u, u.length, t.minDepth, a) : u = EI(u, e.startState.selection), new df(c == 0 ? r.rest : u, c == 0 ? u : r.rest);
    }
    let i = e.annotation(ene);
    if ((i == "full" || i == "before") && (n = n.isolate()), e.annotation(ur.addToHistory) === !1)
      return e.changes.empty ? n : n.addMapping(e.changes.desc);
    let s = Ar.fromTransaction(e), o = e.annotation(ur.time), l = e.annotation(ur.userEvent);
    return s ? n = n.addChanges(s, o, l, t, e) : e.selection && (n = n.addSelection(e.startState.selection, o, l, t.newGroupDelay)), (i == "full" || i == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((e) => e.toJSON()), undone: n.undone.map((e) => e.toJSON()) };
  },
  fromJSON(n) {
    return new df(n.done.map(Ar.fromJSON), n.undone.map(Ar.fromJSON));
  }
});
function nne(n = {}) {
  return [
    TI,
    MI.of(n),
    Ce.domEventHandlers({
      beforeinput(e, t) {
        let r = e.inputType == "historyUndo" ? AI : e.inputType == "historyRedo" ? T5 : null;
        return r ? (e.preventDefault(), r(t)) : !1;
      }
    })
  ];
}
function eg(n, e) {
  return function({ state: t, dispatch: r }) {
    if (!e && t.readOnly)
      return !1;
    let i = t.field(TI, !1);
    if (!i)
      return !1;
    let s = i.pop(n, t, e);
    return s ? (r(s), !0) : !1;
  };
}
const AI = /* @__PURE__ */ eg(0, !1), T5 = /* @__PURE__ */ eg(1, !1), rne = /* @__PURE__ */ eg(0, !0), ine = /* @__PURE__ */ eg(1, !0);
class Ar {
  constructor(e, t, r, i, s) {
    this.changes = e, this.effects = t, this.mapped = r, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new Ar(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new Ar(e.changes && wn.fromJSON(e.changes), [], e.mapped && gs.fromJSON(e.mapped), e.startSelection && G.fromJSON(e.startSelection), e.selectionsAfter.map(G.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let r = ui;
    for (let i of e.startState.facet(tne)) {
      let s = i(e);
      s.length && (r = r.concat(s));
    }
    return !r.length && e.changes.empty ? null : new Ar(e.changes.invert(e.startState.doc), r, void 0, t || e.startState.selection, ui);
  }
  static selection(e) {
    return new Ar(void 0, ui, void 0, void 0, e);
  }
}
function _m(n, e, t, r) {
  let i = e + 1 > t + 20 ? e - t - 1 : 0, s = n.slice(i, e);
  return s.push(r), s;
}
function sne(n, e) {
  let t = [], r = !1;
  return n.iterChangedRanges((i, s) => t.push(i, s)), e.iterChangedRanges((i, s, o, l) => {
    for (let a = 0; a < t.length; ) {
      let c = t[a++], u = t[a++];
      l >= c && o <= u && (r = !0);
    }
  }), r;
}
function one(n, e) {
  return n.ranges.length == e.ranges.length && n.ranges.filter((t, r) => t.empty != e.ranges[r].empty).length === 0;
}
function OI(n, e) {
  return n.length ? e.length ? n.concat(e) : n : e;
}
const ui = [], lne = 200;
function EI(n, e) {
  if (n.length) {
    let t = n[n.length - 1], r = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - lne));
    return r.length && r[r.length - 1].eq(e) ? n : (r.push(e), _m(n, n.length - 1, 1e9, t.setSelAfter(r)));
  } else
    return [Ar.selection([e])];
}
function ane(n) {
  let e = n[n.length - 1], t = n.slice();
  return t[n.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function J2(n, e) {
  if (!n.length)
    return n;
  let t = n.length, r = ui;
  for (; t; ) {
    let i = cne(n[t - 1], e, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = n.slice(0, t);
      return s[t - 1] = i, s;
    } else
      e = i.mapped, t--, r = i.selectionsAfter;
  }
  return r.length ? [Ar.selection(r)] : ui;
}
function cne(n, e, t) {
  let r = OI(n.selectionsAfter.length ? n.selectionsAfter.map((l) => l.map(e)) : ui, t);
  if (!n.changes)
    return Ar.selection(r);
  let i = n.changes.map(e), s = e.mapDesc(n.changes, !0), o = n.mapped ? n.mapped.composeDesc(s) : s;
  return new Ar(i, Xe.mapEffects(n.effects, e), o, n.startSelection.map(s), r);
}
const une = /^(input\.type|delete)($|\.)/;
let df = class yh {
  constructor(e, t, r = 0, i = void 0) {
    this.done = e, this.undone = t, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new yh(this.done, this.undone) : this;
  }
  addChanges(e, t, r, i, s) {
    let o = this.done, l = o[o.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!r || une.test(r)) && (!l.selectionsAfter.length && t - this.prevTime < i.newGroupDelay && i.joinToEvent(s, sne(l.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? o = _m(o, o.length - 1, i.minDepth, new Ar(e.changes.compose(l.changes), OI(Xe.mapEffects(e.effects, l.changes), l.effects), l.mapped, l.startSelection, ui)) : o = _m(o, o.length, i.minDepth, e), new yh(o, ui, t, r);
  }
  addSelection(e, t, r, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : ui;
    return s.length > 0 && t - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && one(s[s.length - 1], e) ? this : new yh(EI(this.done, e), this.undone, t, r);
  }
  addMapping(e) {
    return new yh(J2(this.done, e), J2(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], o = s.selectionsAfter[0] || t.selection;
    if (r && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: M5.of({ side: e, rest: ane(i), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let l = i.length == 1 ? ui : i.slice(0, i.length - 1);
      return s.mapped && (l = J2(l, s.mapped)), t.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: M5.of({ side: e, rest: l, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
};
df.empty = /* @__PURE__ */ new df(ui, ui);
const hne = [
  { key: "Mod-z", run: AI, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: T5, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: T5, preventDefault: !0 },
  { key: "Mod-u", run: rne, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: ine, preventDefault: !0 }
];
function fu(n, e) {
  return G.create(n.ranges.map(e), n.mainIndex);
}
function Is(n, e) {
  return n.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Ki({ state: n, dispatch: e }, t) {
  let r = fu(n.selection, t);
  return r.eq(n.selection, !0) ? !1 : (e(Is(n, r)), !0);
}
function tg(n, e) {
  return G.cursor(e ? n.to : n.from);
}
function II(n, e) {
  return Ki(n, (t) => t.empty ? n.moveByChar(t, e) : tg(t, e));
}
function er(n) {
  return n.textDirectionAt(n.state.selection.main.head) == qt.LTR;
}
const DI = (n) => II(n, !er(n)), NI = (n) => II(n, er(n));
function RI(n, e) {
  return Ki(n, (t) => t.empty ? n.moveByGroup(t, e) : tg(t, e));
}
const fne = (n) => RI(n, !er(n)), dne = (n) => RI(n, er(n));
function pne(n, e, t) {
  if (e.type.prop(t))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(n.sliceDoc(e.from, e.to))) || e.firstChild;
}
function ng(n, e, t) {
  let r = Fn(n).resolveInner(e.head), i = t ? st.closedBy : st.openedBy;
  for (let a = e.head; ; ) {
    let c = t ? r.childAfter(a) : r.childBefore(a);
    if (!c)
      break;
    pne(n, c, i) ? r = c : a = t ? c.to : c.from;
  }
  let s = r.type.prop(i), o, l;
  return s && (o = t ? hs(n, r.from, 1) : hs(n, r.to, -1)) && o.matched ? l = t ? o.end.to : o.end.from : l = t ? r.to : r.from, G.cursor(l, t ? -1 : 1);
}
const mne = (n) => Ki(n, (e) => ng(n.state, e, !er(n))), gne = (n) => Ki(n, (e) => ng(n.state, e, er(n)));
function PI(n, e) {
  return Ki(n, (t) => {
    if (!t.empty)
      return tg(t, e);
    let r = n.moveVertically(t, e);
    return r.head != t.head ? r : n.moveToLineBoundary(t, e);
  });
}
const _I = (n) => PI(n, !1), LI = (n) => PI(n, !0);
function BI(n) {
  let e = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, t = 0, r = 0, i;
  if (e) {
    for (let s of n.state.facet(Ce.scrollMargins)) {
      let o = s(n);
      o?.top && (t = Math.max(o?.top, t)), o?.bottom && (r = Math.max(o?.bottom, r));
    }
    i = n.scrollDOM.clientHeight - t - r;
  } else
    i = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(n.defaultLineHeight, i - 5)
  };
}
function zI(n, e) {
  let t = BI(n), { state: r } = n, i = fu(r.selection, (o) => o.empty ? n.moveVertically(o, e, t.height) : tg(o, e));
  if (i.eq(r.selection))
    return !1;
  let s;
  if (t.selfScroll) {
    let o = n.coordsAtPos(r.selection.main.head), l = n.scrollDOM.getBoundingClientRect(), a = l.top + t.marginTop, c = l.bottom - t.marginBottom;
    o && o.top > a && o.bottom < c && (s = Ce.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - a }));
  }
  return n.dispatch(Is(r, i), { effects: s }), !0;
}
const Ik = (n) => zI(n, !1), A5 = (n) => zI(n, !0);
function Al(n, e, t) {
  let r = n.lineBlockAt(e.head), i = n.moveToLineBoundary(e, t);
  if (i.head == e.head && i.head != (t ? r.to : r.from) && (i = n.moveToLineBoundary(e, t, !1)), !t && i.head == r.from && r.length) {
    let s = /^\s*/.exec(n.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    s && e.head != r.from + s && (i = G.cursor(r.from + s));
  }
  return i;
}
const yne = (n) => Ki(n, (e) => Al(n, e, !0)), bne = (n) => Ki(n, (e) => Al(n, e, !1)), vne = (n) => Ki(n, (e) => Al(n, e, !er(n))), wne = (n) => Ki(n, (e) => Al(n, e, er(n))), xne = (n) => Ki(n, (e) => G.cursor(n.lineBlockAt(e.head).from, 1)), kne = (n) => Ki(n, (e) => G.cursor(n.lineBlockAt(e.head).to, -1));
function Sne(n, e, t) {
  let r = !1, i = fu(n.selection, (s) => {
    let o = hs(n, s.head, -1) || hs(n, s.head, 1) || s.head > 0 && hs(n, s.head - 1, 1) || s.head < n.doc.length && hs(n, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    r = !0;
    let l = o.start.from == s.head ? o.end.to : o.end.from;
    return G.cursor(l);
  });
  return r ? (e(Is(n, i)), !0) : !1;
}
const Cne = ({ state: n, dispatch: e }) => Sne(n, e);
function Ci(n, e) {
  let t = fu(n.state.selection, (r) => {
    let i = e(r);
    return G.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return t.eq(n.state.selection) ? !1 : (n.dispatch(Is(n.state, t)), !0);
}
function FI(n, e) {
  return Ci(n, (t) => n.moveByChar(t, e));
}
const HI = (n) => FI(n, !er(n)), $I = (n) => FI(n, er(n));
function VI(n, e) {
  return Ci(n, (t) => n.moveByGroup(t, e));
}
const Mne = (n) => VI(n, !er(n)), Tne = (n) => VI(n, er(n)), Ane = (n) => Ci(n, (e) => ng(n.state, e, !er(n))), One = (n) => Ci(n, (e) => ng(n.state, e, er(n)));
function qI(n, e) {
  return Ci(n, (t) => n.moveVertically(t, e));
}
const WI = (n) => qI(n, !1), jI = (n) => qI(n, !0);
function UI(n, e) {
  return Ci(n, (t) => n.moveVertically(t, e, BI(n).height));
}
const Dk = (n) => UI(n, !1), Nk = (n) => UI(n, !0), Ene = (n) => Ci(n, (e) => Al(n, e, !0)), Ine = (n) => Ci(n, (e) => Al(n, e, !1)), Dne = (n) => Ci(n, (e) => Al(n, e, !er(n))), Nne = (n) => Ci(n, (e) => Al(n, e, er(n))), Rne = (n) => Ci(n, (e) => G.cursor(n.lineBlockAt(e.head).from)), Pne = (n) => Ci(n, (e) => G.cursor(n.lineBlockAt(e.head).to)), Rk = ({ state: n, dispatch: e }) => (e(Is(n, { anchor: 0 })), !0), Pk = ({ state: n, dispatch: e }) => (e(Is(n, { anchor: n.doc.length })), !0), _k = ({ state: n, dispatch: e }) => (e(Is(n, { anchor: n.selection.main.anchor, head: 0 })), !0), Lk = ({ state: n, dispatch: e }) => (e(Is(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0), _ne = ({ state: n, dispatch: e }) => (e(n.update({ selection: { anchor: 0, head: n.doc.length }, userEvent: "select" })), !0), Lne = ({ state: n, dispatch: e }) => {
  let t = rg(n).map(({ from: r, to: i }) => G.range(r, Math.min(i + 1, n.doc.length)));
  return e(n.update({ selection: G.create(t), userEvent: "select" })), !0;
}, Bne = ({ state: n, dispatch: e }) => {
  let t = fu(n.selection, (r) => {
    let i = Fn(n), s = i.resolveStack(r.from, 1);
    if (r.empty) {
      let o = i.resolveStack(r.from, -1);
      o.node.from >= s.node.from && o.node.to <= s.node.to && (s = o);
    }
    for (let o = s; o; o = o.next) {
      let { node: l } = o;
      if ((l.from < r.from && l.to >= r.to || l.to > r.to && l.from <= r.from) && o.next)
        return G.range(l.to, l.from);
    }
    return r;
  });
  return t.eq(n.selection) ? !1 : (e(Is(n, t)), !0);
}, zne = ({ state: n, dispatch: e }) => {
  let t = n.selection, r = null;
  return t.ranges.length > 1 ? r = G.create([t.main]) : t.main.empty || (r = G.create([G.cursor(t.main.head)])), r ? (e(Is(n, r)), !0) : !1;
};
function Dd(n, e) {
  if (n.state.readOnly)
    return !1;
  let t = "delete.selection", { state: r } = n, i = r.changeByRange((s) => {
    let { from: o, to: l } = s;
    if (o == l) {
      let a = e(s);
      a < o ? (t = "delete.backward", a = C0(n, a, !1)) : a > o && (t = "delete.forward", a = C0(n, a, !0)), o = Math.min(o, a), l = Math.max(l, a);
    } else
      o = C0(n, o, !1), l = C0(n, l, !0);
    return o == l ? { range: s } : { changes: { from: o, to: l }, range: G.cursor(o, o < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (n.dispatch(r.update(i, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? Ce.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function C0(n, e, t) {
  if (n instanceof Ce)
    for (let r of n.state.facet(Ce.atomicRanges).map((i) => i(n)))
      r.between(e, e, (i, s) => {
        i < e && s > e && (e = t ? s : i);
      });
  return e;
}
const KI = (n, e, t) => Dd(n, (r) => {
  let i = r.from, { state: s } = n, o = s.doc.lineAt(i), l, a;
  if (t && !e && i > o.from && i < o.from + 200 && !/[^ \t]/.test(l = o.text.slice(0, i - o.from))) {
    if (l[l.length - 1] == "	")
      return i - 1;
    let c = eu(l, s.tabSize), u = c % wa(s) || wa(s);
    for (let h = 0; h < u && l[l.length - 1 - h] == " "; h++)
      i--;
    a = i;
  } else
    a = zn(o.text, i - o.from, e, e) + o.from, a == i && o.number != (e ? s.doc.lines : 1) ? a += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(a - o.from, i - o.from)) && (a = zn(o.text, a - o.from, !1, !1) + o.from);
  return a;
}), O5 = (n) => KI(n, !1, !0), GI = (n) => KI(n, !0, !1), YI = (n, e) => Dd(n, (t) => {
  let r = t.head, { state: i } = n, s = i.doc.lineAt(r), o = i.charCategorizer(r);
  for (let l = null; ; ) {
    if (r == (e ? s.to : s.from)) {
      r == t.head && s.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let a = zn(s.text, r - s.from, e) + s.from, c = s.text.slice(Math.min(r, a) - s.from, Math.max(r, a) - s.from), u = o(c);
    if (l != null && u != l)
      break;
    (c != " " || r != t.head) && (l = u), r = a;
  }
  return r;
}), JI = (n) => YI(n, !1), Fne = (n) => YI(n, !0), Hne = (n) => Dd(n, (e) => {
  let t = n.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), $ne = (n) => Dd(n, (e) => {
  let t = n.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), Vne = (n) => Dd(n, (e) => {
  let t = n.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), qne = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: ft.of(["", ""]) },
    range: G.cursor(r.from)
  }));
  return e(n.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, Wne = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == n.doc.length)
      return { range: r };
    let i = r.from, s = n.doc.lineAt(i), o = i == s.from ? i - 1 : zn(s.text, i - s.from, !1) + s.from, l = i == s.to ? i + 1 : zn(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: o, to: l, insert: n.doc.slice(i, l).append(n.doc.slice(o, i)) },
      range: G.cursor(l)
    };
  });
  return t.changes.empty ? !1 : (e(n.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function rg(n) {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.from), s = n.doc.lineAt(r.to);
    if (!r.empty && r.to == s.from && (s = n.doc.lineAt(r.to - 1)), t >= i.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(r);
    } else
      e.push({ from: i.from, to: s.to, ranges: [r] });
    t = s.number + 1;
  }
  return e;
}
function XI(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [], i = [];
  for (let s of rg(n)) {
    if (t ? s.to == n.doc.length : s.from == 0)
      continue;
    let o = n.doc.lineAt(t ? s.to + 1 : s.from - 1), l = o.length + 1;
    if (t) {
      r.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + n.lineBreak });
      for (let a of s.ranges)
        i.push(G.range(Math.min(n.doc.length, a.anchor + l), Math.min(n.doc.length, a.head + l)));
    } else {
      r.push({ from: o.from, to: s.from }, { from: s.to, insert: n.lineBreak + o.text });
      for (let a of s.ranges)
        i.push(G.range(a.anchor - l, a.head - l));
    }
  }
  return r.length ? (e(n.update({
    changes: r,
    scrollIntoView: !0,
    selection: G.create(i, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const jne = ({ state: n, dispatch: e }) => XI(n, e, !1), Une = ({ state: n, dispatch: e }) => XI(n, e, !0);
function ZI(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [];
  for (let i of rg(n))
    t ? r.push({ from: i.from, insert: n.doc.slice(i.from, i.to) + n.lineBreak }) : r.push({ from: i.to, insert: n.lineBreak + n.doc.slice(i.from, i.to) });
  return e(n.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Kne = ({ state: n, dispatch: e }) => ZI(n, e, !1), Gne = ({ state: n, dispatch: e }) => ZI(n, e, !0), Yne = (n) => {
  if (n.state.readOnly)
    return !1;
  let { state: e } = n, t = e.changes(rg(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))), r = fu(e.selection, (i) => {
    let s;
    if (n.lineWrapping) {
      let o = n.lineBlockAt(i.head), l = n.coordsAtPos(i.head, i.assoc || 1);
      l && (s = o.bottom + n.documentTop - l.bottom + n.defaultLineHeight / 2);
    }
    return n.moveVertically(i, !0, s);
  }).map(t);
  return n.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function Jne(n, e) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = Fn(n).resolveInner(e), r = t.childBefore(e), i = t.childAfter(e), s;
  return r && i && r.to <= e && i.from >= e && (s = r.type.prop(st.closedBy)) && s.indexOf(i.name) > -1 && n.doc.lineAt(r.to).from == n.doc.lineAt(i.from).from && !/\S/.test(n.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
const Bk = /* @__PURE__ */ QI(!1), Xne = /* @__PURE__ */ QI(!0);
function QI(n) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((i) => {
      let { from: s, to: o } = i, l = e.doc.lineAt(s), a = !n && s == o && Jne(e, s);
      n && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let c = new l1(e, { simulateBreak: s, simulateDoubleBreak: !!a }), u = x3(c, s);
      for (u == null && (u = eu(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      a ? { from: s, to: o } = a : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let h = ["", If(e, u)];
      return a && h.push(If(e, c.lineIndent(l.from, -1))), {
        changes: { from: s, to: o, insert: ft.of(h) },
        range: G.cursor(s + 1 + h[1].length)
      };
    });
    return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Yv(n, e) {
  let t = -1;
  return n.changeByRange((r) => {
    let i = [];
    for (let o = r.from; o <= r.to; ) {
      let l = n.doc.lineAt(o);
      l.number > t && (r.empty || r.to > l.from) && (e(l, i, r), t = l.number), o = l.to + 1;
    }
    let s = n.changes(i);
    return {
      changes: i,
      range: G.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
    };
  });
}
const Zne = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), r = new l1(n, { overrideIndentation: (s) => {
    let o = t[s];
    return o ?? -1;
  } }), i = Yv(n, (s, o, l) => {
    let a = x3(r, s.from);
    if (a == null)
      return;
    /\S/.test(s.text) || (a = 0);
    let c = /^\s*/.exec(s.text)[0], u = If(n, a);
    (c != u || l.from < s.from + c.length) && (t[s.from] = a, o.push({ from: s.from, to: s.from + c.length, insert: u }));
  });
  return i.changes.empty || e(n.update(i, { userEvent: "indent" })), !0;
}, eD = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(Yv(n, (t, r) => {
  r.push({ from: t.from, insert: n.facet(o1) });
}), { userEvent: "input.indent" })), !0), tD = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(Yv(n, (t, r) => {
  let i = /^\s*/.exec(t.text)[0];
  if (!i)
    return;
  let s = eu(i, n.tabSize), o = 0, l = If(n, Math.max(0, s - wa(n)));
  for (; o < i.length && o < l.length && i.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  r.push({ from: t.from + o, to: t.from + i.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), Qne = (n) => (n.setTabFocusMode(), !0), ere = [
  { key: "Ctrl-b", run: DI, shift: HI, preventDefault: !0 },
  { key: "Ctrl-f", run: NI, shift: $I },
  { key: "Ctrl-p", run: _I, shift: WI },
  { key: "Ctrl-n", run: LI, shift: jI },
  { key: "Ctrl-a", run: xne, shift: Rne },
  { key: "Ctrl-e", run: kne, shift: Pne },
  { key: "Ctrl-d", run: GI },
  { key: "Ctrl-h", run: O5 },
  { key: "Ctrl-k", run: Hne },
  { key: "Ctrl-Alt-h", run: JI },
  { key: "Ctrl-o", run: qne },
  { key: "Ctrl-t", run: Wne },
  { key: "Ctrl-v", run: A5 }
], tre = /* @__PURE__ */ [
  { key: "ArrowLeft", run: DI, shift: HI, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: fne, shift: Mne, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: vne, shift: Dne, preventDefault: !0 },
  { key: "ArrowRight", run: NI, shift: $I, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: dne, shift: Tne, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: wne, shift: Nne, preventDefault: !0 },
  { key: "ArrowUp", run: _I, shift: WI, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Rk, shift: _k },
  { mac: "Ctrl-ArrowUp", run: Ik, shift: Dk },
  { key: "ArrowDown", run: LI, shift: jI, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Pk, shift: Lk },
  { mac: "Ctrl-ArrowDown", run: A5, shift: Nk },
  { key: "PageUp", run: Ik, shift: Dk },
  { key: "PageDown", run: A5, shift: Nk },
  { key: "Home", run: bne, shift: Ine, preventDefault: !0 },
  { key: "Mod-Home", run: Rk, shift: _k },
  { key: "End", run: yne, shift: Ene, preventDefault: !0 },
  { key: "Mod-End", run: Pk, shift: Lk },
  { key: "Enter", run: Bk, shift: Bk },
  { key: "Mod-a", run: _ne },
  { key: "Backspace", run: O5, shift: O5 },
  { key: "Delete", run: GI },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: JI },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Fne },
  { mac: "Mod-Backspace", run: $ne },
  { mac: "Mod-Delete", run: Vne }
].concat(/* @__PURE__ */ ere.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))), nD = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: mne, shift: Ane },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: gne, shift: One },
  { key: "Alt-ArrowUp", run: jne },
  { key: "Shift-Alt-ArrowUp", run: Kne },
  { key: "Alt-ArrowDown", run: Une },
  { key: "Shift-Alt-ArrowDown", run: Gne },
  { key: "Escape", run: zne },
  { key: "Mod-Enter", run: Xne },
  { key: "Alt-l", mac: "Ctrl-l", run: Lne },
  { key: "Mod-i", run: Bne, preventDefault: !0 },
  { key: "Mod-[", run: tD },
  { key: "Mod-]", run: eD },
  { key: "Mod-Alt-\\", run: Zne },
  { key: "Shift-Mod-k", run: Yne },
  { key: "Shift-Mod-\\", run: Cne },
  { key: "Mod-/", run: Kte },
  { key: "Alt-A", run: Yte },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: Qne }
].concat(tre), nre = { key: "Tab", run: eD, shift: tD };
var Lm = 200, Tn = function() {
};
Tn.prototype.append = function(e) {
  return e.length ? (e = Tn.from(e), !this.length && e || e.length < Lm && this.leafAppend(e) || this.length < Lm && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Tn.prototype.prepend = function(e) {
  return e.length ? Tn.from(e).append(this) : this;
};
Tn.prototype.appendInner = function(e) {
  return new rre(this, e);
};
Tn.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? Tn.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
Tn.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Tn.prototype.forEach = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
};
Tn.prototype.map = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(s, o) {
    return i.push(e(s, o));
  }, t, r), i;
};
Tn.from = function(e) {
  return e instanceof Tn ? e : e && e.length ? new rD(e) : Tn.empty;
};
var rD = /* @__PURE__ */ (function(n) {
  function e(r) {
    n.call(this), this.values = r;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, s) {
    return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, s, o, l) {
    for (var a = s; a < o; a++)
      if (i(this.values[a], l + a) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, s, o, l) {
    for (var a = s - 1; a >= o; a--)
      if (i(this.values[a], l + a) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Lm)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Lm)
      return new e(i.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
})(Tn);
Tn.empty = new rD([]);
var rre = /* @__PURE__ */ (function(n) {
  function e(t, r) {
    n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, s, o) {
    var l = this.left.length;
    if (i < l && this.left.forEachInner(r, i, Math.min(s, l), o) === !1 || s > l && this.right.forEachInner(r, Math.max(i - l, 0), Math.min(this.length, s) - l, o + l) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, o) {
    var l = this.left.length;
    if (i > l && this.right.forEachInvertedInner(r, i - l, Math.max(s, l) - l, o + l) === !1 || s < l && this.left.forEachInvertedInner(r, Math.min(i, l), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var s = this.left.length;
    return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
})(Tn);
const ire = 500;
class Ii {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, s;
    t && (i = this.remapping(r, this.items.length), s = i.maps.length);
    let o = e.tr, l, a, c = [], u = [];
    return this.items.forEach((h, f) => {
      if (!h.step) {
        i || (i = this.remapping(r, f + 1), s = i.maps.length), s--, u.push(h);
        return;
      }
      if (i) {
        u.push(new rs(h.map));
        let d = h.step.map(i.slice(s)), p;
        d && o.maybeStep(d).doc && (p = o.mapping.maps[o.mapping.maps.length - 1], c.push(new rs(p, void 0, void 0, c.length + u.length))), s--, p && i.appendMap(p, s);
      } else
        o.maybeStep(h.step);
      if (h.selection)
        return l = i ? h.selection.map(i.slice(s)) : h.selection, a = new Ii(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: a, transform: o, selection: l };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, r, i) {
    let s = [], o = this.eventCount, l = this.items, a = !i && l.length ? l.get(l.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let h = e.steps[u].invert(e.docs[u]), f = new rs(e.mapping.maps[u], h, t), d;
      (d = a && a.merge(f)) && (f = d, u ? s.pop() : l = l.slice(0, l.length - 1)), s.push(f), t && (o++, t = void 0), i || (a = f);
    }
    let c = o - r.depth;
    return c > ore && (l = sre(l, c), o -= c), new Ii(l.append(s), o);
  }
  remapping(e, t) {
    let r = new Pf();
    return this.items.forEach((i, s) => {
      let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, o);
    }, e, t), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new Ii(this.items.append(e.map((t) => new rs(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - t), s = e.mapping, o = e.steps.length, l = this.eventCount;
    this.items.forEach((f) => {
      f.selection && l--;
    }, i);
    let a = t;
    this.items.forEach((f) => {
      let d = s.getMirror(--a);
      if (d == null)
        return;
      o = Math.min(o, d);
      let p = s.maps[d];
      if (f.step) {
        let m = e.steps[d].invert(e.docs[d]), g = f.selection && f.selection.map(s.slice(a + 1, d));
        g && l++, r.push(new rs(p, m, g));
      } else
        r.push(new rs(p));
    }, i);
    let c = [];
    for (let f = t; f < o; f++)
      c.push(new rs(s.maps[f]));
    let u = this.items.slice(0, i).append(c).append(r), h = new Ii(u, l);
    return h.emptyItemCount() > ire && (h = h.compress(this.items.length - r.length)), h;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), r = t.maps.length, i = [], s = 0;
    return this.items.forEach((o, l) => {
      if (l >= e)
        i.push(o), o.selection && s++;
      else if (o.step) {
        let a = o.step.map(t.slice(r)), c = a && a.getMap();
        if (r--, c && t.appendMap(c, r), a) {
          let u = o.selection && o.selection.map(t.slice(r));
          u && s++;
          let h = new rs(c.invert(), a, u), f, d = i.length - 1;
          (f = i.length && i[d].merge(h)) ? i[d] = f : i.push(h);
        }
      } else o.map && r--;
    }, this.items.length, 0), new Ii(Tn.from(i.reverse()), s);
  }
}
Ii.empty = new Ii(Tn.empty, 0);
function sre(n, e) {
  let t;
  return n.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return t = i, !1;
  }), n.slice(t);
}
class rs {
  constructor(e, t, r, i) {
    this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new rs(t.getMap().invert(), t, this.selection);
    }
  }
}
class qo {
  constructor(e, t, r, i, s) {
    this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i, this.prevComposition = s;
  }
}
const ore = 20;
function lre(n, e, t, r) {
  let i = t.getMeta(da), s;
  if (i)
    return i.historyState;
  t.getMeta(ure) && (n = new qo(n.done, n.undone, null, 0, -1));
  let o = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (o && o.getMeta(da))
    return o.getMeta(da).redo ? new qo(n.done.addTransform(t, void 0, r, Ap(e)), n.undone, zk(t.mapping.maps), n.prevTime, n.prevComposition) : new qo(n.done, n.undone.addTransform(t, void 0, r, Ap(e)), null, n.prevTime, n.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let l = t.getMeta("composition"), a = n.prevTime == 0 || !o && n.prevComposition != l && (n.prevTime < (t.time || 0) - r.newGroupDelay || !are(t, n.prevRanges)), c = o ? X2(n.prevRanges, t.mapping) : zk(t.mapping.maps);
    return new qo(n.done.addTransform(t, a ? e.selection.getBookmark() : void 0, r, Ap(e)), Ii.empty, c, t.time, l ?? n.prevComposition);
  } else return (s = t.getMeta("rebased")) ? new qo(n.done.rebased(t, s), n.undone.rebased(t, s), X2(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new qo(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), X2(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
}
function are(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((r, i) => {
    for (let s = 0; s < e.length; s += 2)
      r <= e[s + 1] && i >= e[s] && (t = !0);
  }), t;
}
function zk(n) {
  let e = [];
  for (let t = n.length - 1; t >= 0 && e.length == 0; t--)
    n[t].forEach((r, i, s, o) => e.push(s, o));
  return e;
}
function X2(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let r = 0; r < n.length; r += 2) {
    let i = e.map(n[r], 1), s = e.map(n[r + 1], -1);
    i <= s && t.push(i, s);
  }
  return t;
}
function cre(n, e, t) {
  let r = Ap(e), i = da.get(e).spec.config, s = (t ? n.undone : n.done).popEvent(e, r);
  if (!s)
    return null;
  let o = s.selection.resolve(s.transform.doc), l = (t ? n.done : n.undone).addTransform(s.transform, e.selection.getBookmark(), i, r), a = new qo(t ? l : s.remaining, t ? s.remaining : l, null, 0, -1);
  return s.transform.setSelection(o).setMeta(da, { redo: t, historyState: a });
}
let Z2 = !1, Fk = null;
function Ap(n) {
  let e = n.plugins;
  if (Fk != e) {
    Z2 = !1, Fk = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        Z2 = !0;
        break;
      }
  }
  return Z2;
}
const da = new en("history"), ure = new en("closeHistory");
function hre(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new Ut({
    key: da,
    state: {
      init() {
        return new qo(Ii.empty, Ii.empty, null, 0, -1);
      },
      apply(e, t, r) {
        return lre(t, r, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let r = t.inputType, i = r == "historyUndo" ? ig : r == "historyRedo" ? jc : null;
          return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function iD(n, e) {
  return (t, r) => {
    let i = da.getState(t);
    if (!i || (n ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let s = cre(i, t, n);
      s && r(e ? s.scrollIntoView() : s);
    }
    return !0;
  };
}
const ig = iD(!1, !0), jc = iD(!0, !0);
var fre = Object.defineProperty, Hk = Object.getOwnPropertySymbols, dre = Object.prototype.hasOwnProperty, pre = Object.prototype.propertyIsEnumerable, $k = (n, e, t) => e in n ? fre(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, mre = (n, e) => {
  for (var t in e || (e = {}))
    dre.call(e, t) && $k(n, t, e[t]);
  if (Hk)
    for (var t of Hk(e))
      pre.call(e, t) && $k(n, t, e[t]);
  return n;
};
function sD(n, e) {
  return Object.assign(n, {
    meta: mre({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const gre = {
  extensions: [],
  languages: [],
  expandIcon: "⬇",
  searchIcon: "🔍",
  clearSearchIcon: "⌫",
  searchPlaceholder: "Search language",
  noResultText: "No result",
  copyText: "Copy",
  copyIcon: "📋",
  onCopy: () => {
  },
  renderLanguage: (n) => n,
  renderPreview: () => null,
  previewToggleButton: (n) => n ? "Edit" : "Hide",
  previewLabel: "Preview"
}, Nd = St(gre, "codeBlockConfigCtx");
sD(Nd, {
  displayName: "Config<code-block>",
  group: "CodeBlock"
});
class yre {
  constructor(e) {
    this.languages = e, this.map = {}, e.forEach((t) => {
      t.alias.forEach((r) => {
        this.map[r] = t;
      });
    });
  }
  getAll() {
    return this.languages.map((e) => ({
      name: e.name,
      alias: e.alias
    }));
  }
  load(e) {
    const r = this.map[e.toLowerCase()];
    return r ? r.support ? Promise.resolve(r.support) : r.load() : Promise.resolve(void 0);
  }
}
function Ac({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
Ac.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
var bre = (n, e, t) => new Promise((r, i) => {
  var s = (a) => {
    try {
      l(t.next(a));
    } catch (c) {
      i(c);
    }
  }, o = (a) => {
    try {
      l(t.throw(a));
    } catch (c) {
      i(c);
    }
  }, l = (a) => a.done ? r(a.value) : Promise.resolve(a.value).then(s, o);
  l((t = t.apply(n, e)).next());
});
function vre(n) {
  return bre(this, null, function* () {
    try {
      return navigator.clipboard.writeText(n);
    } catch {
      const t = document.createElement("textarea"), r = document.activeElement;
      t.value = n, t.setAttribute("readonly", ""), t.style.contain = "strict", t.style.position = "absolute", t.style.left = "-9999px", t.style.fontSize = "12pt";
      const i = document.getSelection(), s = i ? i.rangeCount > 0 && i.getRangeAt(0) : null;
      document.body.appendChild(t), t.select(), t.selectionStart = 0, t.selectionEnd = n.length, document.execCommand("copy"), document.body.removeChild(t), s && (i.removeAllRanges(), i.addRange(s)), r && r.focus();
    }
  });
}
const wre = /* @__PURE__ */ $n({
  props: {
    copyText: {
      type: String,
      required: !0
    },
    copyIcon: {
      type: String,
      required: !0
    },
    onCopy: {
      type: Function,
      required: !0
    },
    text: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = () => {
      vre(n.text).then(() => n.onCopy(n.text)).catch(console.error);
    };
    return () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("button", { type: "button", class: "copy-button", onClick: e }, /* @__PURE__ */ j(Ac, { icon: n.copyIcon }), n.copyText));
  }
}), xre = /* @__PURE__ */ $n({
  props: {
    language: {
      type: Object,
      required: !0
    },
    getReadOnly: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    getAllLanguages: {
      type: Function,
      required: !0
    },
    setLanguage: {
      type: Function,
      required: !0
    }
  },
  setup({ language: n, config: e, setLanguage: t, getAllLanguages: r, getReadOnly: i }) {
    const s = Ae(), o = Ae(!1), l = Ae(), a = Ae(), c = Ae("");
    Tc([o, s, a], () => {
      c.value = "";
      const m = s.value, g = a.value;
      !m || !g || $i(m, g, {
        placement: "bottom-start"
      }).then(({ x: b, y: w }) => {
        Object.assign(g.style, {
          left: `${b}px`,
          top: `${w}px`
        });
      }).catch(console.error);
    });
    const u = (m) => {
      if (m.preventDefault(), m.stopPropagation(), i()) return;
      const g = !o.value;
      o.value = g, g && setTimeout(() => {
        var b;
        return (b = l.value) == null ? void 0 : b.focus();
      }, 0);
    }, h = (m) => {
      const g = m.target;
      c.value = g.value;
    }, f = (m) => {
      m.key === "Escape" && (c.value = "");
    }, d = Da(() => {
      var m;
      if (!o.value) return [];
      const g = (m = r()) != null ? m : [], b = g.find(
        (k) => k.name.toLowerCase() === n.value.toLowerCase()
      ), w = g.filter((k) => {
        const C = c.value.toLowerCase();
        return (k.name.toLowerCase().includes(C) || k.alias.some(
          (M) => M.toLowerCase().includes(C)
        )) && k !== b;
      });
      return w.length === 0 ? [] : b ? [b, ...w] : w;
    }), p = (m) => {
      const g = m.target;
      if (s.value && s.value.contains(g)) return;
      const b = a.value, w = s.value;
      !w || !b || w.dataset.expanded === "true" && (b.contains(g) || (o.value = !1));
    };
    return kd(() => {
      window.addEventListener("click", p);
    }), Sd(() => {
      window.removeEventListener("click", p);
    }), () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j(
      "button",
      {
        type: "button",
        ref: s,
        class: "language-button",
        onClick: u,
        "data-expanded": String(o.value)
      },
      n.value || "Text",
      /* @__PURE__ */ j("div", { class: "expand-icon" }, /* @__PURE__ */ j(Ac, { icon: e.expandIcon }))
    ), /* @__PURE__ */ j("div", { ref: a, class: "language-picker" }, o.value ? /* @__PURE__ */ j("div", { class: "list-wrapper" }, /* @__PURE__ */ j("div", { class: "search-box" }, /* @__PURE__ */ j("div", { class: "search-icon" }, /* @__PURE__ */ j(Ac, { icon: e.searchIcon })), /* @__PURE__ */ j(
      "input",
      {
        ref: l,
        class: "search-input",
        placeholder: e.searchPlaceholder,
        value: c.value,
        onInput: h,
        onKeydown: f
      }
    ), /* @__PURE__ */ j(
      "div",
      {
        class: Hn(
          "clear-icon",
          c.value.length === 0 && "hidden"
        ),
        onMousedown: (m) => {
          m.preventDefault(), c.value = "";
        }
      },
      /* @__PURE__ */ j(Ac, { icon: e.clearSearchIcon })
    )), /* @__PURE__ */ j(
      "ul",
      {
        class: "language-list",
        role: "listbox",
        onKeydown: (m) => {
          if (m.key === "Enter") {
            const g = document.activeElement;
            g instanceof HTMLElement && g.dataset.language && t(g.dataset.language);
          }
        }
      },
      d.value.length ? d.value.map((m) => /* @__PURE__ */ j(
        "li",
        {
          role: "listitem",
          tabindex: "0",
          class: "language-list-item",
          "aria-selected": m.name.toLowerCase() === n.value.toLowerCase(),
          "data-language": m.name,
          onClick: () => {
            t(m.name), o.value = !1;
          }
        },
        e.renderLanguage(
          m.name,
          m.name.toLowerCase() === n.value.toLowerCase()
        )
      )) : /* @__PURE__ */ j("li", { class: "language-list-item no-result" }, e.noResultText)
    )) : null));
  }
}), kre = /* @__PURE__ */ $n({
  props: {
    text: {
      type: Object,
      required: !0
    },
    language: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    previewOnlyMode: {
      type: Object,
      required: !0
    },
    preview: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { previewOnlyMode: e, config: t, preview: r } = n, i = Ae();
    return cu(() => {
      const s = i.value;
      if (!s) return;
      for (; s.firstChild; )
        s.removeChild(s.firstChild);
      const o = r.value;
      (typeof o == "string" || o instanceof Element) && (s.innerHTML = Ui.sanitize(o));
    }), () => r.value ? /* @__PURE__ */ j("div", { class: "preview-panel" }, !e.value && /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("div", { class: "preview-divider" }), /* @__PURE__ */ j("div", { class: Hn("preview-label", e && "hidden") }, t.previewLabel)), /* @__PURE__ */ j("div", { ref: i, class: "preview" })) : null;
  }
}), Sre = /* @__PURE__ */ $n({
  props: {
    text: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    getReadOnly: {
      type: Function,
      required: !0
    },
    codemirror: {
      type: Object,
      required: !0
    },
    language: {
      type: Object,
      required: !0
    },
    getAllLanguages: {
      type: Function,
      required: !0
    },
    setLanguage: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = Ae(!1), t = Ae();
    kd(() => {
      for (var s; (s = t.value) != null && s.firstChild; )
        t.value.removeChild(t.value.firstChild);
      t.value && t.value.appendChild(n.codemirror.dom);
    });
    const r = Da(() => {
      const s = n.text.value, o = n.language.value;
      return n.config.renderPreview(o, s);
    }), i = () => {
    };
    return () => {
      var s;
      return /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j("div", { class: "tools" }, /* @__PURE__ */ j(
        xre,
        {
          language: n.language,
          config: n.config,
          setLanguage: n.setLanguage,
          getAllLanguages: n.getAllLanguages,
          getReadOnly: n.getReadOnly
        }
      ), /* @__PURE__ */ j("div", { class: "tools-button-group" }, /* @__PURE__ */ j(
        wre,
        {
          copyIcon: n.config.copyIcon,
          copyText: n.config.copyText,
          onCopy: (s = n.config.onCopy) != null ? s : i,
          text: n.text.value
        }
      ), r.value ? /* @__PURE__ */ j(
        "button",
        {
          class: "preview-toggle-button",
          onClick: () => e.value = !e.value
        },
        /* @__PURE__ */ j(
          Ac,
          {
            icon: n.config.previewToggleButton(
              e.value
            )
          }
        )
      ) : null)), /* @__PURE__ */ j(
        "div",
        {
          ref: t,
          class: Hn(
            "codemirror-host",
            r.value && e.value && "hidden"
          )
        }
      ), /* @__PURE__ */ j(
        kre,
        {
          text: n.text,
          language: n.language,
          config: n.config,
          previewOnlyMode: e,
          preview: r
        }
      ));
    };
  }
});
class Cre {
  constructor(e, t, r, i, s) {
    this.node = e, this.view = t, this.getPos = r, this.loader = i, this.config = s, this.selected = Ae(!1), this.language = Ae(""), this.text = Ae(""), this.updating = !1, this.languageName = "", this.forwardUpdate = (o) => {
      var l;
      if (this.updating || !this.cm.hasFocus) return;
      let a = ((l = this.getPos()) != null ? l : 0) + 1;
      const { main: c } = o.state.selection, u = a + c.from, h = a + c.to, f = this.view.state.selection;
      if (o.docChanged || f.from !== u || f.to !== h) {
        const d = this.view.state.tr;
        o.changes.iterChanges((p, m, g, b, w) => {
          w.length ? d.replaceWith(
            a + p,
            a + m,
            this.view.state.schema.text(w.toString())
          ) : d.delete(a + p, a + m), a += b - g - (m - p);
        }), d.setSelection(Ee.create(d.doc, u, h)), this.view.dispatch(d);
      }
    }, this.createApp = () => ji(Sre, {
      text: this.text,
      selected: this.selected,
      codemirror: this.cm,
      language: this.language,
      getAllLanguages: this.getAllLanguages,
      getReadOnly: () => !this.view.editable,
      setLanguage: this.setLanguage,
      config: this.config
    }), this.codeMirrorKeymap = () => {
      const o = this.view;
      return [
        { key: "ArrowUp", run: () => this.maybeEscape("line", -1) },
        { key: "ArrowLeft", run: () => this.maybeEscape("char", -1) },
        { key: "ArrowDown", run: () => this.maybeEscape("line", 1) },
        { key: "ArrowRight", run: () => this.maybeEscape("char", 1) },
        {
          key: "Mod-Enter",
          run: () => lA(o.state, o.dispatch) ? (o.focus(), !0) : !1
        },
        { key: "Mod-z", run: () => ig(o.state, o.dispatch) },
        { key: "Shift-Mod-z", run: () => jc(o.state, o.dispatch) },
        { key: "Mod-y", run: () => jc(o.state, o.dispatch) },
        {
          key: "Backspace",
          run: () => {
            var l;
            const a = this.cm.state.selection.ranges;
            if (a.length > 1) return !1;
            const c = a[0];
            if (c && (!c.empty || c.anchor > 0) || this.cm.state.doc.lines >= 2) return !1;
            const u = this.view.state, h = (l = this.getPos()) != null ? l : 0, f = u.tr.replaceWith(
              h,
              h + this.node.nodeSize,
              u.schema.nodes.paragraph.createChecked({}, this.node.content)
            );
            return f.setSelection(Ee.near(f.doc.resolve(h))), this.view.dispatch(f), this.view.focus(), !0;
          }
        }
      ];
    }, this.maybeEscape = (o, l) => {
      var a;
      const { state: c } = this.cm;
      let u = c.selection.main;
      if (!u.empty || (o === "line" && (u = c.doc.lineAt(u.head)), l < 0 ? u.from > 0 : u.to < c.doc.length)) return !1;
      const h = ((a = this.getPos()) != null ? a : 0) + (l < 0 ? 0 : this.node.nodeSize), f = Ee.near(
        this.view.state.doc.resolve(h),
        l
      ), d = this.view.state.tr.setSelection(f).scrollIntoView();
      return this.view.dispatch(d), this.view.focus(), !0;
    }, this.setLanguage = (o) => {
      var l;
      this.view.dispatch(
        this.view.state.tr.setNodeAttribute(
          (l = this.getPos()) != null ? l : 0,
          "language",
          o
        )
      );
    }, this.getAllLanguages = () => this.loader.getAll(), this.languageConf = new Nc(), this.readOnlyConf = new Nc(), this.cm = new Ce({
      doc: this.node.textContent,
      root: this.view.root,
      extensions: [
        this.readOnlyConf.of(jt.readOnly.of(!this.view.editable)),
        eM(),
        tu.of(this.codeMirrorKeymap()),
        this.languageConf.of([]),
        jt.changeFilter.of(() => this.view.editable),
        ...s.extensions,
        Ce.updateListener.of(this.forwardUpdate)
      ]
    }), this.app = this.createApp(), this.dom = this.createDom(this.app), this.disposeSelectedWatcher = cu(() => {
      this.selected.value ? this.dom.classList.add("selected") : this.dom.classList.remove("selected");
    }), this.updateLanguage();
  }
  createDom(e) {
    const t = document.createElement("div");
    return t.className = "milkdown-code-block", this.text.value = this.node.textContent, e.mount(t), t;
  }
  updateLanguage() {
    const e = this.node.attrs.language;
    if (e === this.languageName) return;
    this.language.value = e, this.loader.load(e ?? "").then((r) => {
      r && (this.cm.dispatch({
        effects: this.languageConf.reconfigure(r)
      }), this.languageName = e);
    }).catch(console.error);
  }
  setSelection(e, t) {
    this.cm.dom.isConnected && (this.cm.focus(), this.updating = !0, this.cm.dispatch({ selection: { anchor: e, head: t } }), this.updating = !1);
  }
  update(e) {
    if (e.type !== this.node.type) return !1;
    if (this.updating) return !0;
    this.node = e, this.text.value = e.textContent, this.updateLanguage(), this.view.editable === this.cm.state.readOnly && this.cm.dispatch({
      effects: this.readOnlyConf.reconfigure(
        jt.readOnly.of(!this.view.editable)
      )
    });
    const t = Mre(this.cm.state.doc.toString(), e.textContent);
    return t && (this.updating = !0, this.cm.dispatch({
      changes: { from: t.from, to: t.to, insert: t.text },
      scrollIntoView: !0
    }), this.updating = !1), !0;
  }
  selectNode() {
    this.selected.value = !0, this.cm.focus();
  }
  deselectNode() {
    this.selected.value = !1;
  }
  stopEvent() {
    return !0;
  }
  destroy() {
    this.app.unmount(), this.cm.destroy(), this.disposeSelectedWatcher();
  }
}
function Mre(n, e) {
  if (n === e) return null;
  let t = 0, r = n.length, i = e.length;
  for (; t < r && n.charCodeAt(t) === e.charCodeAt(t); )
    ++t;
  for (; r > t && i > t && n.charCodeAt(r - 1) === e.charCodeAt(i - 1); )
    r--, i--;
  return { from: t, to: r, text: e.slice(t, i) };
}
const oD = yd(
  Cs.node,
  (n) => {
    const e = n.get(Nd.key), t = new yre(e.languages);
    return (r, i, s) => new Cre(r, i, s, t, e);
  }
);
sD(oD, {
  displayName: "NodeView<code-block>",
  group: "CodeBlock"
});
const Tre = [
  oD,
  Nd
], Vk = typeof String.prototype.normalize == "function" ? (n) => n.normalize("NFKD") : (n) => n;
class Uc {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, r = 0, i = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = s ? (l) => s(Vk(l)) : Vk, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return kr(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = o3(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += ls(e);
      let i = this.normalize(t);
      if (i.length)
        for (let s = 0, o = r; ; s++) {
          let l = i.charCodeAt(s), a = this.match(l, o, this.bufferPos + this.bufferStart);
          if (s == i.length - 1) {
            if (a)
              return this.value = a, this;
            break;
          }
          o == r && s < t.length && t.charCodeAt(s) == l && o++;
        }
    }
  }
  match(e, t, r) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], l = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? i = { from: this.matches[s + 1], to: r } : (this.matches[s]++, l = !0)), l || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: r } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (Uc.prototype[Symbol.iterator] = function() {
  return this;
});
const lD = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Jv = "gm" + (/x/.unicode == null ? "" : "u");
class aD {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, r, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = lD, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new cD(e, t, r, i, s);
    this.re = new RegExp(t, Jv + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.iter = e.iter();
    let o = e.lineAt(i);
    this.curLineStart = o.from, this.matchPos = Bm(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let r = this.curLineStart + t.index, i = r + t[0].length;
        if (this.matchPos = Bm(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Q2 = /* @__PURE__ */ new WeakMap();
class Oc {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, r) {
    let i = Q2.get(e);
    if (!i || i.from >= r || i.to <= t) {
      let l = new Oc(t, e.sliceString(t, r));
      return Q2.set(e, l), l;
    }
    if (i.from == t && i.to == r)
      return i;
    let { text: s, from: o } = i;
    return o > t && (s = e.sliceString(t, o) + s, o = t), i.to < r && (s += e.sliceString(i.to, r)), Q2.set(e, new Oc(o, s)), new Oc(t, s.slice(t - o, r - o));
  }
}
class cD {
  constructor(e, t, r, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = lD, this.matchPos = Bm(e, i), this.re = new RegExp(t, Jv + (r?.ignoreCase ? "i" : "")), this.test = r?.test, this.flat = Oc.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let r = this.flat.from + t.index, i = r + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this.matchPos = Bm(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Oc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (aD.prototype[Symbol.iterator] = cD.prototype[Symbol.iterator] = function() {
  return this;
});
function Are(n) {
  try {
    return new RegExp(n, Jv), !0;
  } catch {
    return !1;
  }
}
function Bm(n, e) {
  if (e >= n.length)
    return e;
  let t = n.lineAt(e), r;
  for (; e < t.to && (r = t.text.charCodeAt(e - t.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function E5(n) {
  let e = String(n.state.doc.lineAt(n.state.selection.main.head).number), t = Tt("input", { class: "cm-textfield", name: "line", value: e }), r = Tt("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), n.dispatch({ effects: pf.of(!1) }), n.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, Tt("label", n.state.phrase("Go to line"), ": ", t), " ", Tt("button", { class: "cm-button", type: "submit" }, n.state.phrase("go")), Tt("button", {
    name: "close",
    onclick: () => {
      n.dispatch({ effects: pf.of(!1) }), n.focus();
    },
    "aria-label": n.state.phrase("close"),
    type: "button"
  }, ["×"]));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!s)
      return;
    let { state: o } = n, l = o.doc.lineAt(o.selection.main.head), [, a, c, u, h] = s, f = u ? +u.slice(1) : 0, d = c ? +c : l.number;
    if (c && h) {
      let g = d / 100;
      a && (g = g * (a == "-" ? -1 : 1) + l.number / o.doc.lines), d = Math.round(o.doc.lines * g);
    } else c && a && (d = d * (a == "-" ? -1 : 1) + l.number);
    let p = o.doc.line(Math.max(1, Math.min(o.doc.lines, d))), m = G.cursor(p.from + Math.max(0, Math.min(f, p.length)));
    n.dispatch({
      effects: [pf.of(!1), Ce.scrollIntoView(m.from, { y: "center" })],
      selection: m
    }), n.focus();
  }
  return { dom: r };
}
const pf = /* @__PURE__ */ Xe.define(), qk = /* @__PURE__ */ On.define({
  create() {
    return !0;
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(pf) && (n = t.value);
    return n;
  },
  provide: (n) => Ef.from(n, (e) => e ? E5 : null)
}), Ore = (n) => {
  let e = Of(n, E5);
  if (!e) {
    let t = [pf.of(!0)];
    n.state.field(qk, !1) == null && t.push(Xe.appendConfig.of([qk, Ere])), n.dispatch({ effects: t }), e = Of(n, E5);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, Ere = /* @__PURE__ */ Ce.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), Ire = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, Dre = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, Ire, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Nre(n) {
  return [Bre, Lre];
}
const Rre = /* @__PURE__ */ He.mark({ class: "cm-selectionMatch" }), Pre = /* @__PURE__ */ He.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function Wk(n, e, t, r) {
  return (t == 0 || n(e.sliceDoc(t - 1, t)) != Wt.Word) && (r == e.doc.length || n(e.sliceDoc(r, r + 1)) != Wt.Word);
}
function _re(n, e, t, r) {
  return n(e.sliceDoc(t, t + 1)) == Wt.Word && n(e.sliceDoc(r - 1, r)) == Wt.Word;
}
const Lre = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.selectionSet || n.docChanged || n.viewportChanged) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = n.state.facet(Dre), { state: t } = n, r = t.selection;
    if (r.ranges.length > 1)
      return He.none;
    let i = r.main, s, o = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return He.none;
      let a = t.wordAt(i.head);
      if (!a)
        return He.none;
      o = t.charCategorizer(i.head), s = t.sliceDoc(a.from, a.to);
    } else {
      let a = i.to - i.from;
      if (a < e.minSelectionLength || a > 200)
        return He.none;
      if (e.wholeWords) {
        if (s = t.sliceDoc(i.from, i.to), o = t.charCategorizer(i.head), !(Wk(o, t, i.from, i.to) && _re(o, t, i.from, i.to)))
          return He.none;
      } else if (s = t.sliceDoc(i.from, i.to), !s)
        return He.none;
    }
    let l = [];
    for (let a of n.visibleRanges) {
      let c = new Uc(t.doc, s, a.from, a.to);
      for (; !c.next().done; ) {
        let { from: u, to: h } = c.value;
        if ((!o || Wk(o, t, u, h)) && (i.empty && u <= i.from && h >= i.to ? l.push(Pre.range(u, h)) : (u >= i.to || h <= i.from) && l.push(Rre.range(u, h)), l.length > e.maxMatches))
          return He.none;
      }
    }
    return He.set(l);
  }
}, {
  decorations: (n) => n.decorations
}), Bre = /* @__PURE__ */ Ce.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), zre = ({ state: n, dispatch: e }) => {
  let { selection: t } = n, r = G.create(t.ranges.map((i) => n.wordAt(i.head) || G.cursor(i.head)), t.mainIndex);
  return r.eq(t) ? !1 : (e(n.update({ selection: r })), !0);
};
function Fre(n, e) {
  let { main: t, ranges: r } = n.selection, i = n.wordAt(t.head), s = i && i.from == t.from && i.to == t.to;
  for (let o = !1, l = new Uc(n.doc, e, r[r.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new Uc(n.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((a) => a.from == l.value.from))
        continue;
      if (s) {
        let a = n.wordAt(l.value.from);
        if (!a || a.from != l.value.from || a.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const Hre = ({ state: n, dispatch: e }) => {
  let { ranges: t } = n.selection;
  if (t.some((s) => s.from === s.to))
    return zre({ state: n, dispatch: e });
  let r = n.sliceDoc(t[0].from, t[0].to);
  if (n.selection.ranges.some((s) => n.sliceDoc(s.from, s.to) != r))
    return !1;
  let i = Fre(n, r);
  return i ? (e(n.update({
    selection: n.selection.addRange(G.range(i.from, i.to), !1),
    effects: Ce.scrollIntoView(i.to)
  })), !0) : !1;
}, du = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new Zre(e),
      scrollToMatch: (e) => Ce.scrollIntoView(e)
    });
  }
});
class uD {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Are(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new Wre(this) : new Vre(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, r) {
    let i = e.doc ? e : jt.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? cc(this, i, t, r) : ac(this, i, t, r);
  }
}
class hD {
  constructor(e) {
    this.spec = e;
  }
}
function ac(n, e, t, r) {
  return new Uc(e.doc, n.unquoted, t, r, n.caseSensitive ? void 0 : (i) => i.toLowerCase(), n.wholeWord ? $re(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function $re(n, e) {
  return (t, r, i, s) => ((s > t || s + i.length < r) && (s = Math.max(0, t - 2), i = n.sliceString(s, Math.min(n.length, r + 2))), (e(zm(i, t - s)) != Wt.Word || e(Fm(i, t - s)) != Wt.Word) && (e(Fm(i, r - s)) != Wt.Word || e(zm(i, r - s)) != Wt.Word));
}
class Vre extends hD {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, r) {
    let i = ac(this.spec, e, r, e.doc.length).nextOverlapping();
    if (i.done) {
      let s = Math.min(e.doc.length, t + this.spec.unquoted.length);
      i = ac(this.spec, e, 0, s).nextOverlapping();
    }
    return i.done || i.value.from == t && i.value.to == r ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, r) {
    for (let i = r; ; ) {
      let s = Math.max(t, i - 1e4 - this.spec.unquoted.length), o = ac(this.spec, e, s, i), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (s == t)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, t, r) {
    let i = this.prevMatchInRange(e, 0, t);
    return i || (i = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), i && (i.from != t || i.to != r) ? i : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let r = ac(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let s = ac(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function cc(n, e, t, r) {
  return new aD(e.doc, n.search, {
    ignoreCase: !n.caseSensitive,
    test: n.wholeWord ? qre(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, r);
}
function zm(n, e) {
  return n.slice(zn(n, e, !1), e);
}
function Fm(n, e) {
  return n.slice(e, zn(n, e));
}
function qre(n) {
  return (e, t, r) => !r[0].length || (n(zm(r.input, r.index)) != Wt.Word || n(Fm(r.input, r.index)) != Wt.Word) && (n(Fm(r.input, r.index + r[0].length)) != Wt.Word || n(zm(r.input, r.index + r[0].length)) != Wt.Word);
}
class Wre extends hD {
  nextMatch(e, t, r) {
    let i = cc(this.spec, e, r, e.doc.length).next();
    return i.done && (i = cc(this.spec, e, 0, t).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, t, r) {
    for (let i = 1; ; i++) {
      let s = Math.max(
        t,
        r - i * 1e4
        /* FindPrev.ChunkSize */
      ), o = cc(this.spec, e, s, r), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (s == t || l.from > s + 10))
        return l;
      if (s == t)
        return null;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (t, r) => {
      if (r == "&")
        return e.match[0];
      if (r == "$")
        return "$";
      for (let i = r.length; i > 0; i--) {
        let s = +r.slice(0, i);
        if (s > 0 && s < e.match.length)
          return e.match[s] + r.slice(i);
      }
      return t;
    });
  }
  matchAll(e, t) {
    let r = cc(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let s = cc(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const Jf = /* @__PURE__ */ Xe.define(), Xv = /* @__PURE__ */ Xe.define(), ol = /* @__PURE__ */ On.define({
  create(n) {
    return new e4(I5(n).create(), null);
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(Jf) ? n = new e4(t.value.create(), n.panel) : t.is(Xv) && (n = new e4(n.query, t.value ? Zv : null));
    return n;
  },
  provide: (n) => Ef.from(n, (e) => e.panel)
});
class e4 {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const jre = /* @__PURE__ */ He.mark({ class: "cm-searchMatch" }), Ure = /* @__PURE__ */ He.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Kre = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.decorations = this.highlight(n.state.field(ol));
  }
  update(n) {
    let e = n.state.field(ol);
    (e != n.startState.field(ol) || n.docChanged || n.selectionSet || n.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: n, panel: e }) {
    if (!e || !n.spec.valid)
      return He.none;
    let { view: t } = this, r = new lo();
    for (let i = 0, s = t.visibleRanges, o = s.length; i < o; i++) {
      let { from: l, to: a } = s[i];
      for (; i < o - 1 && a > s[i + 1].from - 500; )
        a = s[++i].to;
      n.highlight(t.state, l, a, (c, u) => {
        let h = t.state.selection.ranges.some((f) => f.from == c && f.to == u);
        r.add(c, u, h ? Ure : jre);
      });
    }
    return r.finish();
  }
}, {
  decorations: (n) => n.decorations
});
function Rd(n) {
  return (e) => {
    let t = e.state.field(ol, !1);
    return t && t.query.spec.valid ? n(e, t) : pD(e);
  };
}
const Hm = /* @__PURE__ */ Rd((n, { query: e }) => {
  let { to: t } = n.state.selection.main, r = e.nextMatch(n.state, t, t);
  if (!r)
    return !1;
  let i = G.single(r.from, r.to), s = n.state.facet(du);
  return n.dispatch({
    selection: i,
    effects: [Qv(n, r), s.scrollToMatch(i.main, n)],
    userEvent: "select.search"
  }), dD(n), !0;
}), $m = /* @__PURE__ */ Rd((n, { query: e }) => {
  let { state: t } = n, { from: r } = t.selection.main, i = e.prevMatch(t, r, r);
  if (!i)
    return !1;
  let s = G.single(i.from, i.to), o = n.state.facet(du);
  return n.dispatch({
    selection: s,
    effects: [Qv(n, i), o.scrollToMatch(s.main, n)],
    userEvent: "select.search"
  }), dD(n), !0;
}), Gre = /* @__PURE__ */ Rd((n, { query: e }) => {
  let t = e.matchAll(n.state, 1e3);
  return !t || !t.length ? !1 : (n.dispatch({
    selection: G.create(t.map((r) => G.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), Yre = ({ state: n, dispatch: e }) => {
  let t = n.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: r, to: i } = t.main, s = [], o = 0;
  for (let l = new Uc(n.doc, n.sliceDoc(r, i)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == r && (o = s.length), s.push(G.range(l.value.from, l.value.to));
  }
  return e(n.update({
    selection: G.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, jk = /* @__PURE__ */ Rd((n, { query: e }) => {
  let { state: t } = n, { from: r, to: i } = t.selection.main;
  if (t.readOnly)
    return !1;
  let s = e.nextMatch(t, r, r);
  if (!s)
    return !1;
  let o = s, l = [], a, c, u = [];
  o.from == r && o.to == i && (c = t.toText(e.getReplacement(o)), l.push({ from: o.from, to: o.to, insert: c }), o = e.nextMatch(t, o.from, o.to), u.push(Ce.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(r).number) + ".")));
  let h = n.state.changes(l);
  return o && (a = G.single(o.from, o.to).map(h), u.push(Qv(n, o)), u.push(t.facet(du).scrollToMatch(a.main, n))), n.dispatch({
    changes: h,
    selection: a,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), Jre = /* @__PURE__ */ Rd((n, { query: e }) => {
  if (n.state.readOnly)
    return !1;
  let t = e.matchAll(n.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: e.getReplacement(i) };
  });
  if (!t.length)
    return !1;
  let r = n.state.phrase("replaced $ matches", t.length) + ".";
  return n.dispatch({
    changes: t,
    effects: Ce.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function Zv(n) {
  return n.state.facet(du).createPanel(n);
}
function I5(n, e) {
  var t, r, i, s, o;
  let l = n.selection.main, a = l.empty || l.to > l.from + 100 ? "" : n.sliceDoc(l.from, l.to);
  if (e && !a)
    return e;
  let c = n.facet(du);
  return new uD({
    search: ((t = e?.literal) !== null && t !== void 0 ? t : c.literal) ? a : a.replace(/\n/g, "\\n"),
    caseSensitive: (r = e?.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (i = e?.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (s = e?.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e?.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function fD(n) {
  let e = Of(n, Zv);
  return e && e.dom.querySelector("[main-field]");
}
function dD(n) {
  let e = fD(n);
  e && e == n.root.activeElement && e.select();
}
const pD = (n) => {
  let e = n.state.field(ol, !1);
  if (e && e.panel) {
    let t = fD(n);
    if (t && t != n.root.activeElement) {
      let r = I5(n.state, e.query.spec);
      r.valid && n.dispatch({ effects: Jf.of(r) }), t.focus(), t.select();
    }
  } else
    n.dispatch({ effects: [
      Xv.of(!0),
      e ? Jf.of(I5(n.state, e.query.spec)) : Xe.appendConfig.of(eie)
    ] });
  return !0;
}, mD = (n) => {
  let e = n.state.field(ol, !1);
  if (!e || !e.panel)
    return !1;
  let t = Of(n, Zv);
  return t && t.dom.contains(n.root.activeElement) && n.focus(), n.dispatch({ effects: Xv.of(!1) }), !0;
}, Xre = [
  { key: "Mod-f", run: pD, scope: "editor search-panel" },
  { key: "F3", run: Hm, shift: $m, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Hm, shift: $m, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: mD, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Yre },
  { key: "Mod-Alt-g", run: Ore },
  { key: "Mod-d", run: Hre, preventDefault: !0 }
];
class Zre {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(ol).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Tt("input", {
      value: t.search,
      placeholder: Br(e, "Find"),
      "aria-label": Br(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Tt("input", {
      value: t.replace,
      placeholder: Br(e, "Replace"),
      "aria-label": Br(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Tt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = Tt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = Tt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function r(i, s, o) {
      return Tt("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = Tt("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => Hm(e), [Br(e, "next")]),
      r("prev", () => $m(e), [Br(e, "previous")]),
      r("select", () => Gre(e), [Br(e, "all")]),
      Tt("label", null, [this.caseField, Br(e, "match case")]),
      Tt("label", null, [this.reField, Br(e, "regexp")]),
      Tt("label", null, [this.wordField, Br(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Tt("br"),
        this.replaceField,
        r("replace", () => jk(e), [Br(e, "replace")]),
        r("replaceAll", () => Jre(e), [Br(e, "replace all")])
      ],
      Tt("button", {
        name: "close",
        onclick: () => mD(e),
        "aria-label": Br(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new uD({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Jf.of(e) }));
  }
  keydown(e) {
    Oz(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? $m : Hm)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), jk(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(Jf) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(du).top;
  }
}
function Br(n, e) {
  return n.state.phrase(e);
}
const M0 = 30, T0 = /[\s\.,:;?!]/;
function Qv(n, { from: e, to: t }) {
  let r = n.state.doc.lineAt(e), i = n.state.doc.lineAt(t).to, s = Math.max(r.from, e - M0), o = Math.min(i, t + M0), l = n.state.sliceDoc(s, o);
  if (s != r.from) {
    for (let a = 0; a < M0; a++)
      if (!T0.test(l[a + 1]) && T0.test(l[a])) {
        l = l.slice(a);
        break;
      }
  }
  if (o != i) {
    for (let a = l.length - 1; a > l.length - M0; a--)
      if (!T0.test(l[a - 1]) && T0.test(l[a])) {
        l = l.slice(0, a);
        break;
      }
  }
  return Ce.announce.of(`${n.state.phrase("current match")}. ${l} ${n.state.phrase("on line")} ${r.number}.`);
}
const Qre = /* @__PURE__ */ Ce.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), eie = [
  ol,
  /* @__PURE__ */ wl.low(Kre),
  Qre
];
class gD {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, r, i) {
    this.state = e, this.pos = t, this.explicit = r, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = Fn(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), r = Math.max(t.from, this.pos - 250), i = t.text.slice(r - t.from, this.pos - t.from), s = i.search(yD(e, !1));
    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, t, r) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(t), r && r.onDocChange && (this.abortOnDocChange = !0));
  }
}
function Uk(n) {
  let e = Object.keys(n).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function tie(n) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of n) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      t[i[s]] = !0;
  }
  let r = Uk(e) + Uk(t) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function nie(n) {
  let e = n.map((i) => typeof i == "string" ? { label: i } : i), [t, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : tie(e);
  return (i) => {
    let s = i.matchBefore(r);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: t } : null;
  };
}
function jue(n, e) {
  return (t) => {
    for (let r = Fn(t.state).resolveInner(t.pos, -1); r; r = r.parent) {
      if (n.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(t);
  };
}
class Kk {
  constructor(e, t, r, i) {
    this.completion = e, this.source = t, this.match = r, this.score = i;
  }
}
function pa(n) {
  return n.selection.main.from;
}
function yD(n, e) {
  var t;
  let { source: r } = n, i = e && r[0] != "^", s = r[r.length - 1] != "$";
  return !i && !s ? n : new RegExp(`${i ? "^" : ""}(?:${r})${s ? "$" : ""}`, (t = n.flags) !== null && t !== void 0 ? t : n.ignoreCase ? "i" : "");
}
const e7 = /* @__PURE__ */ vo.define();
function rie(n, e, t, r) {
  let { main: i } = n.selection, s = t - i.from, o = r - i.from;
  return {
    ...n.changeByRange((l) => {
      if (l != i && t != r && n.sliceDoc(l.from + s, l.from + o) != n.sliceDoc(t, r))
        return { range: l };
      let a = n.toText(e);
      return {
        changes: { from: l.from + s, to: r == i.from ? l.to : l.from + o, insert: a },
        range: G.cursor(l.from + s + a.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
const Gk = /* @__PURE__ */ new WeakMap();
function iie(n) {
  if (!Array.isArray(n))
    return n;
  let e = Gk.get(n);
  return e || Gk.set(n, e = nie(n)), e;
}
const Vm = /* @__PURE__ */ Xe.define(), Xf = /* @__PURE__ */ Xe.define();
class sie {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let r = kr(e, t), i = ls(r);
      this.chars.push(r);
      let s = e.slice(t, t + i), o = s.toUpperCase();
      this.folded.push(kr(o == s ? s.toLowerCase() : o, 0)), t += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: r, any: i, precise: s, byWord: o } = this;
    if (t.length == 1) {
      let w = kr(e, 0), k = ls(w), C = k == e.length ? 0 : -100;
      if (w != t[0]) if (w == r[0])
        C += -200;
      else
        return null;
      return this.ret(C, [0, k]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let a = t.length, c = 0;
    if (l < 0) {
      for (let w = 0, k = Math.min(e.length, 200); w < k && c < a; ) {
        let C = kr(e, w);
        (C == t[c] || C == r[c]) && (i[c++] = w), w += ls(C);
      }
      if (c < a)
        return null;
    }
    let u = 0, h = 0, f = !1, d = 0, p = -1, m = -1, g = /[a-z]/.test(e), b = !0;
    for (let w = 0, k = Math.min(e.length, 200), C = 0; w < k && h < a; ) {
      let M = kr(e, w);
      l < 0 && (u < a && M == t[u] && (s[u++] = w), d < a && (M == t[d] || M == r[d] ? (d == 0 && (p = w), m = w + 1, d++) : d = 0));
      let T, N = M < 255 ? M >= 48 && M <= 57 || M >= 97 && M <= 122 ? 2 : M >= 65 && M <= 90 ? 1 : 0 : (T = o3(M)) != T.toLowerCase() ? 1 : T != T.toUpperCase() ? 2 : 0;
      (!w || N == 1 && g || C == 0 && N != 0) && (t[h] == M || r[h] == M && (f = !0) ? o[h++] = w : o.length && (b = !1)), C = N, w += ls(M);
    }
    return h == a && o[0] == 0 && b ? this.result(-100 + (f ? -200 : 0), o, e) : d == a && p == 0 ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : d == a ? this.ret(-900 - e.length, [p, m]) : h == a ? this.result(-100 + (f ? -200 : 0) + -700 + (b ? 0 : -1100), o, e) : t.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, t, r) {
    let i = [], s = 0;
    for (let o of t) {
      let l = o + (this.astral ? ls(kr(r, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = l : (i[s++] = o, i[s++] = l);
    }
    return this.ret(e - r.length, i);
  }
}
class oie {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let t = e.slice(0, this.pattern.length), r = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, t.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const Mn = /* @__PURE__ */ xe.define({
  combine(n) {
    return Ts(n, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: lie,
      filterStrict: !1,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (r) => Yk(e(r), t(r)),
      optionClass: (e, t) => (r) => Yk(e(r), t(r)),
      addToOptions: (e, t) => e.concat(t),
      filterStrict: (e, t) => e || t
    });
  }
});
function Yk(n, e) {
  return n ? e ? n + " " + e : n : e;
}
function lie(n, e, t, r, i, s) {
  let o = n.textDirection == qt.RTL, l = o, a = !1, c = "top", u, h, f = e.left - i.left, d = i.right - e.right, p = r.right - r.left, m = r.bottom - r.top;
  if (l && f < Math.min(p, d) ? l = !1 : !l && d < Math.min(p, f) && (l = !0), p <= (l ? f : d))
    u = Math.max(i.top, Math.min(t.top, i.bottom - m)) - e.top, h = Math.min(400, l ? f : d);
  else {
    a = !0, h = Math.min(
      400,
      (o ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let w = i.bottom - e.bottom;
    w >= m || w > e.top ? u = t.bottom - e.top : (c = "bottom", u = e.bottom - t.top);
  }
  let g = (e.bottom - e.top) / s.offsetHeight, b = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${u / g}px; max-width: ${h / b}px`,
    class: "cm-completionInfo-" + (a ? o ? "left-narrow" : "right-narrow" : l ? "left" : "right")
  };
}
function aie(n) {
  let e = n.addToOptions.slice();
  return n.icons && e.push({
    render(t) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), t.type && r.classList.add(...t.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(t, r, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let l = t.displayLabel || t.label, a = 0;
      for (let c = 0; c < s.length; ) {
        let u = s[c++], h = s[c++];
        u > a && o.appendChild(document.createTextNode(l.slice(a, u)));
        let f = o.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(l.slice(u, h))), f.className = "cm-completionMatchedText", a = h;
      }
      return a < l.length && o.appendChild(document.createTextNode(l.slice(a))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = t.detail, r;
    },
    position: 80
  }), e.sort((t, r) => t.position - r.position).map((t) => t.render);
}
function t4(n, e, t) {
  if (n <= t)
    return { from: 0, to: n };
  if (e < 0 && (e = 0), e <= n >> 1) {
    let i = Math.floor(e / t);
    return { from: i * t, to: (i + 1) * t };
  }
  let r = Math.floor((n - e) / t);
  return { from: n - (r + 1) * t, to: n - r * t };
}
class cie {
  constructor(e, t, r) {
    this.view = e, this.stateField = t, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (a) => this.placeInfo(a),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(t), { options: s, selected: o } = i.open, l = e.state.facet(Mn);
    this.optionContent = aie(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = t4(s.length, o, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (a) => {
      let { options: c } = e.state.field(t).open;
      for (let u = a.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
          this.applyCompletion(e, c[+h[1]]), a.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (a) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Mn).closeOnBlur && a.relatedTarget != e.contentDOM && e.dispatch({ effects: Xf.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != i) {
      let { options: s, selected: o, disabled: l } = r.open;
      (!i.open || i.open.options != s) && (this.range = t4(s.length, o, e.state.facet(Mn).maxRenderedOptions), this.showOptions(s, r.id)), this.updateSel(), l != ((t = i.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of t.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = t4(t.options.length, t.selected, this.view.state.facet(Mn).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: r } = t.options[t.selected], { info: i } = r;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);
      }).catch((o) => Mr(this.view.state, o, "completion info")) : this.addInfoPane(s, r);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      r.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), t = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return t && hie(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.documentElement;
      s = { left: 0, top: 0, right: o.clientWidth, bottom: o.clientHeight };
    }
    return i.top > Math.min(s.bottom, t.bottom) - 10 || i.bottom < Math.max(s.top, t.top) + 10 ? null : this.view.state.facet(Mn).positionInfo(this.view, t, i, r, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, r) {
    const i = document.createElement("ul");
    i.id = t, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (o) => {
      o.target == i && o.preventDefault();
    });
    let s = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: l, match: a } = e[o], { section: c } = l;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != s && (o > r.from || r.from == 0))
          if (s = f, typeof c != "string" && c.header)
            i.appendChild(c.header(c));
          else {
            let d = i.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      u.id = t + "-" + o, u.setAttribute("role", "option");
      let h = this.optionClass(l);
      h && (u.className = h);
      for (let f of this.optionContent) {
        let d = f(l, this.view.state, this.view, a);
        d && u.appendChild(d);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function uie(n, e) {
  return (t) => new cie(t, n, e);
}
function hie(n, e) {
  let t = n.getBoundingClientRect(), r = e.getBoundingClientRect(), i = t.height / n.offsetHeight;
  r.top < t.top ? n.scrollTop -= (t.top - r.top) / i : r.bottom > t.bottom && (n.scrollTop += (r.bottom - t.bottom) / i);
}
function Jk(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
function fie(n, e) {
  let t = [], r = null, i = (c) => {
    t.push(c);
    let { section: u } = c.completion;
    if (u) {
      r || (r = []);
      let h = typeof u == "string" ? u : u.name;
      r.some((f) => f.name == h) || r.push(typeof u == "string" ? { name: h } : u);
    }
  }, s = e.facet(Mn);
  for (let c of n)
    if (c.hasResult()) {
      let u = c.result.getMatch;
      if (c.result.filter === !1)
        for (let h of c.result.options)
          i(new Kk(h, c.source, u ? u(h) : [], 1e9 - t.length));
      else {
        let h = e.sliceDoc(c.from, c.to), f, d = s.filterStrict ? new oie(h) : new sie(h);
        for (let p of c.result.options)
          if (f = d.match(p.label)) {
            let m = p.displayLabel ? u ? u(p, f.matched) : [] : f.matched;
            i(new Kk(p, c.source, m, f.score + (p.boost || 0)));
          }
      }
    }
  if (r) {
    let c = /* @__PURE__ */ Object.create(null), u = 0, h = (f, d) => {
      var p, m;
      return ((p = f.rank) !== null && p !== void 0 ? p : 1e9) - ((m = d.rank) !== null && m !== void 0 ? m : 1e9) || (f.name < d.name ? -1 : 1);
    };
    for (let f of r.sort(h))
      u -= 1e5, c[f.name] = u;
    for (let f of t) {
      let { section: d } = f.completion;
      d && (f.score += c[typeof d == "string" ? d : d.name]);
    }
  }
  let o = [], l = null, a = s.compareCompletions;
  for (let c of t.sort((u, h) => h.score - u.score || a(u.completion, h.completion))) {
    let u = c.completion;
    !l || l.label != u.label || l.detail != u.detail || l.type != null && u.type != null && l.type != u.type || l.apply != u.apply || l.boost != u.boost ? o.push(c) : Jk(c.completion) > Jk(l) && (o[o.length - 1] = c), l = c.completion;
  }
  return o;
}
class mc {
  constructor(e, t, r, i, s, o) {
    this.options = e, this.attrs = t, this.tooltip = r, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new mc(this.options, Xk(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, r, i, s, o) {
    if (i && !o && e.some((c) => c.isPending))
      return i.setDisabled();
    let l = fie(e, t);
    if (!l.length)
      return i && e.some((c) => c.isPending) ? i.setDisabled() : null;
    let a = t.facet(Mn).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let c = i.options[i.selected].completion;
      for (let u = 0; u < l.length; u++)
        if (l[u].completion == c) {
          a = u;
          break;
        }
    }
    return new mc(l, Xk(r, a), {
      pos: e.reduce((c, u) => u.hasResult() ? Math.min(c, u.from) : c, 1e8),
      create: bie,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new mc(this.options, this.attrs, { ...this.tooltip, pos: e.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new mc(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class qm {
  constructor(e, t, r) {
    this.active = e, this.id = t, this.open = r;
  }
  static start() {
    return new qm(gie, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, r = t.facet(Mn), s = (r.override || t.languageDataAt("autocomplete", pa(t)).map(iie)).map((a) => (this.active.find((u) => u.source == a) || new hi(
      a,
      this.active.some(
        (u) => u.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    s.length == this.active.length && s.every((a, c) => a == this.active[c]) && (s = this.active);
    let o = this.open, l = e.effects.some((a) => a.is(t7));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !die(s, this.active) || l ? o = mc.build(s, t, this.id, o, r, l) : o && o.disabled && !s.some((a) => a.isPending) && (o = null), !o && s.every((a) => !a.isPending) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new hi(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(vD) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new qm(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? pie : mie;
  }
}
function die(n, e) {
  if (n == e)
    return !0;
  for (let t = 0, r = 0; ; ) {
    for (; t < n.length && !n[t].hasResult(); )
      t++;
    for (; r < e.length && !e[r].hasResult(); )
      r++;
    let i = t == n.length, s = r == e.length;
    if (i || s)
      return i == s;
    if (n[t++].result != e[r++].result)
      return !1;
  }
}
const pie = {
  "aria-autocomplete": "list"
}, mie = {};
function Xk(n, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return e > -1 && (t["aria-activedescendant"] = n + "-" + e), t;
}
const gie = [];
function bD(n, e) {
  if (n.isUserEvent("input.complete")) {
    let r = n.annotation(e7);
    if (r && e.activateOnCompletion(r))
      return 12;
  }
  let t = n.isUserEvent("input.type");
  return t && e.activateOnTyping ? 5 : t ? 1 : n.isUserEvent("delete.backward") ? 2 : n.selection ? 8 : n.docChanged ? 16 : 0;
}
class hi {
  constructor(e, t, r = !1) {
    this.source = e, this.state = t, this.explicit = r;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, t) {
    let r = bD(e, t), i = this;
    (r & 8 || r & 16 && this.touches(e)) && (i = new hi(
      i.source,
      0
      /* State.Inactive */
    )), r & 4 && i.state == 0 && (i = new hi(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(e, r);
    for (let s of e.effects)
      if (s.is(Vm))
        i = new hi(i.source, 1, s.value);
      else if (s.is(Xf))
        i = new hi(
          i.source,
          0
          /* State.Inactive */
        );
      else if (s.is(t7))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  updateFor(e, t) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(pa(e.state));
  }
}
class Ec extends hi {
  constructor(e, t, r, i, s, o) {
    super(e, 3, t), this.limit = r, this.result = i, this.from = s, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, t) {
    var r;
    if (!(t & 3))
      return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), l = pa(e.state);
    if (l > o || !i || t & 2 && (pa(e.startState) == this.from || l < this.limit))
      return new hi(
        this.source,
        t & 4 ? 1 : 0
        /* State.Inactive */
      );
    let a = e.changes.mapPos(this.limit);
    return yie(i.validFor, e.state, s, o) ? new Ec(this.source, this.explicit, a, i, s, o) : i.update && (i = i.update(i, s, o, new gD(e.state, l, !1))) ? new Ec(this.source, this.explicit, a, i, i.from, (r = i.to) !== null && r !== void 0 ? r : pa(e.state)) : new hi(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Ec(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new hi(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function yie(n, e, t, r) {
  if (!n)
    return !1;
  let i = e.sliceDoc(t, r);
  return typeof n == "function" ? n(i, t, r, e) : yD(n, !0).test(i);
}
const t7 = /* @__PURE__ */ Xe.define({
  map(n, e) {
    return n.map((t) => t.map(e));
  }
}), vD = /* @__PURE__ */ Xe.define(), Cr = /* @__PURE__ */ On.define({
  create() {
    return qm.start();
  },
  update(n, e) {
    return n.update(e);
  },
  provide: (n) => [
    w3.from(n, (e) => e.tooltip),
    Ce.contentAttributes.from(n, (e) => e.attrs)
  ]
});
function n7(n, e) {
  const t = e.completion.apply || e.completion.label;
  let r = n.state.field(Cr).active.find((i) => i.source == e.source);
  return r instanceof Ec ? (typeof t == "string" ? n.dispatch({
    ...rie(n.state, t, r.from, r.to),
    annotations: e7.of(e.completion)
  }) : t(n, e.completion, r.from, r.to), !0) : !1;
}
const bie = /* @__PURE__ */ uie(Cr, n7);
function A0(n, e = "option") {
  return (t) => {
    let r = t.state.field(Cr, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < t.state.facet(Mn).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = iM(t, r.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, l = r.open.selected > -1 ? r.open.selected + i * (n ? 1 : -1) : n ? 0 : o - 1;
    return l < 0 ? l = e == "page" ? 0 : o - 1 : l >= o && (l = e == "page" ? o - 1 : 0), t.dispatch({ effects: vD.of(l) }), !0;
  };
}
const vie = (n) => {
  let e = n.state.field(Cr, !1);
  return n.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < n.state.facet(Mn).interactionDelay ? !1 : n7(n, e.open.options[e.open.selected]);
}, n4 = (n) => n.state.field(Cr, !1) ? (n.dispatch({ effects: Vm.of(!0) }), !0) : !1, wie = (n) => {
  let e = n.state.field(Cr, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: Xf.of(null) }), !0);
};
class xie {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const kie = 50, Sie = 1e3, Cie = /* @__PURE__ */ gn.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of n.state.field(Cr).active)
      e.isPending && this.startQuery(e);
  }
  update(n) {
    let e = n.state.field(Cr), t = n.state.facet(Mn);
    if (!n.selectionSet && !n.docChanged && n.startState.field(Cr) == e)
      return;
    let r = n.transactions.some((s) => {
      let o = bD(s, t);
      return o & 8 || (s.selection || s.docChanged) && !(o & 3);
    });
    for (let s = 0; s < this.running.length; s++) {
      let o = this.running[s];
      if (r || o.context.abortOnDocChange && n.docChanged || o.updates.length + n.transactions.length > kie && Date.now() - o.time > Sie) {
        for (let l of o.context.abortListeners)
          try {
            l();
          } catch (a) {
            Mr(this.view.state, a);
          }
        o.context.abortListeners = null, this.running.splice(s--, 1);
      } else
        o.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((s) => s.effects.some((o) => o.is(Vm))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : t.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((s) => s.isPending && !this.running.some((o) => o.active.source == s.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let s of n.transactions)
        s.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && s.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, e = n.field(Cr);
    for (let t of e.active)
      t.isPending && !this.running.some((r) => r.active.source == t.source) && this.startQuery(t);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Mn).updateSyncTime));
  }
  startQuery(n) {
    let { state: e } = this.view, t = pa(e), r = new gD(e, t, n.explicit, this.view), i = new xie(n, r);
    this.running.push(i), Promise.resolve(n.source(r)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: Xf.of(null) }), Mr(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Mn).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Mn), r = this.view.state.field(Cr);
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (s.done === void 0)
        continue;
      if (this.running.splice(i--, 1), s.done) {
        let l = pa(s.updates.length ? s.updates[0].startState : this.view.state), a = Math.min(l, s.done.from + (s.active.explicit ? 0 : 1)), c = new Ec(s.active.source, s.active.explicit, a, s.done, s.done.from, (n = s.done.to) !== null && n !== void 0 ? n : l);
        for (let u of s.updates)
          c = c.update(u, t);
        if (c.hasResult()) {
          e.push(c);
          continue;
        }
      }
      let o = r.active.find((l) => l.source == s.active.source);
      if (o && o.isPending)
        if (s.done == null) {
          let l = new hi(
            s.active.source,
            0
            /* State.Inactive */
          );
          for (let a of s.updates)
            l = l.update(a, t);
          l.isPending || e.push(l);
        } else
          this.startQuery(o);
    }
    (e.length || r.open && r.open.disabled) && this.view.dispatch({ effects: t7.of(e) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let e = this.view.state.field(Cr, !1);
      if (e && e.tooltip && this.view.state.facet(Mn).closeOnBlur) {
        let t = e.open && iM(this.view, e.open.tooltip);
        (!t || !t.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Xf.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Vm.of(!1) }), 20), this.composing = 0;
    }
  }
}), Mie = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), Tie = /* @__PURE__ */ wl.highest(/* @__PURE__ */ Ce.domEventHandlers({
  keydown(n, e) {
    let t = e.state.field(Cr, !1);
    if (!t || !t.open || t.open.disabled || t.open.selected < 0 || n.key.length > 1 || n.ctrlKey && !(Mie && n.altKey) || n.metaKey)
      return !1;
    let r = t.open.options[t.open.selected], i = t.active.find((o) => o.source == r.source), s = r.completion.commitCharacters || i.result.commitCharacters;
    return s && s.indexOf(n.key) > -1 && n7(e, r), !1;
  }
})), wD = /* @__PURE__ */ Ce.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class Aie {
  constructor(e, t, r, i) {
    this.field = e, this.line = t, this.from = r, this.to = i;
  }
}
class r7 {
  constructor(e, t, r) {
    this.field = e, this.from = t, this.to = r;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, Bn.TrackDel), r = e.mapPos(this.to, 1, Bn.TrackDel);
    return t == null || r == null ? null : new r7(this.field, t, r);
  }
}
class i7 {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let r = [], i = [t], s = e.doc.lineAt(t), o = /^\s*/.exec(s.text)[0];
    for (let a of this.lines) {
      if (r.length) {
        let c = o, u = /^\t*/.exec(a)[0].length;
        for (let h = 0; h < u; h++)
          c += e.facet(o1);
        i.push(t + c.length - u), a = c + a.slice(u);
      }
      r.push(a), t += a.length + 1;
    }
    let l = this.fieldPositions.map((a) => new r7(a.field, i[a.line] + a.from, i[a.line] + a.to));
    return { text: r, ranges: l };
  }
  static parse(e) {
    let t = [], r = [], i = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(o); ) {
        let l = s[1] ? +s[1] : null, a = s[2] || s[3] || "", c = -1, u = a.replace(/\\[{}]/g, (h) => h[1]);
        for (let h = 0; h < t.length; h++)
          (l != null ? t[h].seq == l : u && t[h].name == u) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < t.length && (l == null || t[h].seq != null && t[h].seq < l); )
            h++;
          t.splice(h, 0, { seq: l, name: u }), c = h;
          for (let f of i)
            f.field >= c && f.field++;
        }
        for (let h of i)
          if (h.line == r.length && h.from > s.index) {
            let f = s[2] ? 3 + (s[1] || "").length : 2;
            h.from -= f, h.to -= f;
          }
        i.push(new Aie(c, r.length, s.index, s.index + u.length)), o = o.slice(0, s.index) + a + o.slice(s.index + s[0].length);
      }
      o = o.replace(/\\([{}])/g, (l, a, c) => {
        for (let u of i)
          u.line == r.length && u.from > c && (u.from--, u.to--);
        return a;
      }), r.push(o);
    }
    return new i7(r, i);
  }
}
let Oie = /* @__PURE__ */ He.widget({ widget: /* @__PURE__ */ new class extends wo {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Eie = /* @__PURE__ */ He.mark({ class: "cm-snippetField" });
class pu {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = He.set(e.map((r) => (r.from == r.to ? Oie : Eie).range(r.from, r.to)), !0);
  }
  map(e) {
    let t = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i)
        return null;
      t.push(i);
    }
    return new pu(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((r) => r.field == this.active && r.from <= t.from && r.to >= t.to));
  }
}
const Pd = /* @__PURE__ */ Xe.define({
  map(n, e) {
    return n && n.map(e);
  }
}), Iie = /* @__PURE__ */ Xe.define(), Zf = /* @__PURE__ */ On.define({
  create() {
    return null;
  },
  update(n, e) {
    for (let t of e.effects) {
      if (t.is(Pd))
        return t.value;
      if (t.is(Iie) && n)
        return new pu(n.ranges, t.value);
    }
    return n && e.docChanged && (n = n.map(e.changes)), n && e.selection && !n.selectionInsideField(e.selection) && (n = null), n;
  },
  provide: (n) => Ce.decorations.from(n, (e) => e ? e.deco : He.none)
});
function s7(n, e) {
  return G.create(n.filter((t) => t.field == e).map((t) => G.range(t.from, t.to)));
}
function Die(n) {
  let e = i7.parse(n);
  return (t, r, i, s) => {
    let { text: o, ranges: l } = e.instantiate(t.state, i), { main: a } = t.state.selection, c = {
      changes: { from: i, to: s == a.from ? a.to : s, insert: ft.of(o) },
      scrollIntoView: !0,
      annotations: r ? [e7.of(r), ur.userEvent.of("input.complete")] : void 0
    };
    if (l.length && (c.selection = s7(l, 0)), l.some((u) => u.field > 0)) {
      let u = new pu(l, 0), h = c.effects = [Pd.of(u)];
      t.state.field(Zf, !1) === void 0 && h.push(Xe.appendConfig.of([Zf, Lie, Bie, wD]));
    }
    t.dispatch(t.state.update(c));
  };
}
function xD(n) {
  return ({ state: e, dispatch: t }) => {
    let r = e.field(Zf, !1);
    if (!r || n < 0 && r.active == 0)
      return !1;
    let i = r.active + n, s = n > 0 && !r.ranges.some((o) => o.field == i + n);
    return t(e.update({
      selection: s7(r.ranges, i),
      effects: Pd.of(s ? null : new pu(r.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const Nie = ({ state: n, dispatch: e }) => n.field(Zf, !1) ? (e(n.update({ effects: Pd.of(null) })), !0) : !1, Rie = /* @__PURE__ */ xD(1), Pie = /* @__PURE__ */ xD(-1), _ie = [
  { key: "Tab", run: Rie, shift: Pie },
  { key: "Escape", run: Nie }
], Zk = /* @__PURE__ */ xe.define({
  combine(n) {
    return n.length ? n[0] : _ie;
  }
}), Lie = /* @__PURE__ */ wl.highest(/* @__PURE__ */ tu.compute([Zk], (n) => n.facet(Zk)));
function Uue(n, e) {
  return { ...e, apply: Die(n) };
}
const Bie = /* @__PURE__ */ Ce.domEventHandlers({
  mousedown(n, e) {
    let t = e.state.field(Zf, !1), r;
    if (!t || (r = e.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let i = t.ranges.find((s) => s.from <= r && s.to >= r);
    return !i || i.field == t.active ? !1 : (e.dispatch({
      selection: s7(t.ranges, i.field),
      effects: Pd.of(t.ranges.some((s) => s.field > i.field) ? new pu(t.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), Qf = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, ra = /* @__PURE__ */ Xe.define({
  map(n, e) {
    let t = e.mapPos(n, -1, Bn.TrackAfter);
    return t ?? void 0;
  }
}), o7 = /* @__PURE__ */ new class extends ga {
}();
o7.startSide = 1;
o7.endSide = -1;
const kD = /* @__PURE__ */ On.define({
  create() {
    return ut.empty;
  },
  update(n, e) {
    if (n = n.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      n = n.update({ filter: (r) => r >= t.from && r <= t.to });
    }
    for (let t of e.effects)
      t.is(ra) && (n = n.update({ add: [o7.range(t.value, t.value + 1)] }));
    return n;
  }
});
function zie() {
  return [Hie, kD];
}
const r4 = "()[]{}<>«»»«［］｛｝";
function SD(n) {
  for (let e = 0; e < r4.length; e += 2)
    if (r4.charCodeAt(e) == n)
      return r4.charAt(e + 1);
  return o3(n < 128 ? n : n + 1);
}
function CD(n, e) {
  return n.languageDataAt("closeBrackets", e)[0] || Qf;
}
const Fie = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Hie = /* @__PURE__ */ Ce.inputHandler.of((n, e, t, r) => {
  if ((Fie ? n.composing : n.compositionStarted) || n.state.readOnly)
    return !1;
  let i = n.state.selection.main;
  if (r.length > 2 || r.length == 2 && ls(kr(r, 0)) == 1 || e != i.from || t != i.to)
    return !1;
  let s = qie(n.state, r);
  return s ? (n.dispatch(s), !0) : !1;
}), $ie = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let r = CD(n, n.selection.main.head).brackets || Qf.brackets, i = null, s = n.changeByRange((o) => {
    if (o.empty) {
      let l = Wie(n.doc, o.head);
      for (let a of r)
        if (a == l && sg(n.doc, o.head) == SD(kr(a, 0)))
          return {
            changes: { from: o.head - a.length, to: o.head + a.length },
            range: G.cursor(o.head - a.length)
          };
    }
    return { range: i = o };
  });
  return i || e(n.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, Vie = [
  { key: "Backspace", run: $ie }
];
function qie(n, e) {
  let t = CD(n, n.selection.main.head), r = t.brackets || Qf.brackets;
  for (let i of r) {
    let s = SD(kr(i, 0));
    if (e == i)
      return s == i ? Kie(n, i, r.indexOf(i + i + i) > -1, t) : jie(n, i, s, t.before || Qf.before);
    if (e == s && MD(n, n.selection.main.from))
      return Uie(n, i, s);
  }
  return null;
}
function MD(n, e) {
  let t = !1;
  return n.field(kD).between(0, n.doc.length, (r) => {
    r == e && (t = !0);
  }), t;
}
function sg(n, e) {
  let t = n.sliceString(e, e + 2);
  return t.slice(0, ls(kr(t, 0)));
}
function Wie(n, e) {
  let t = n.sliceString(e - 2, e);
  return ls(kr(t, 0)) == t.length ? t : t.slice(1);
}
function jie(n, e, t, r) {
  let i = null, s = n.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: ra.of(o.to + e.length),
        range: G.range(o.anchor + e.length, o.head + e.length)
      };
    let l = sg(n.doc, o.head);
    return !l || /\s/.test(l) || r.indexOf(l) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: ra.of(o.head + e.length),
      range: G.cursor(o.head + e.length)
    } : { range: i = o };
  });
  return i ? null : n.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Uie(n, e, t) {
  let r = null, i = n.changeByRange((s) => s.empty && sg(n.doc, s.head) == t ? {
    changes: { from: s.head, to: s.head + t.length, insert: t },
    range: G.cursor(s.head + t.length)
  } : r = { range: s });
  return r ? null : n.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Kie(n, e, t, r) {
  let i = r.stringPrefixes || Qf.stringPrefixes, s = null, o = n.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: ra.of(l.to + e.length),
        range: G.range(l.anchor + e.length, l.head + e.length)
      };
    let a = l.head, c = sg(n.doc, a), u;
    if (c == e) {
      if (Qk(n, a))
        return {
          changes: { insert: e + e, from: a },
          effects: ra.of(a + e.length),
          range: G.cursor(a + e.length)
        };
      if (MD(n, a)) {
        let f = t && n.sliceDoc(a, a + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: a, to: a + f.length, insert: f },
          range: G.cursor(a + f.length)
        };
      }
    } else {
      if (t && n.sliceDoc(a - 2 * e.length, a) == e + e && (u = e9(n, a - 2 * e.length, i)) > -1 && Qk(n, u))
        return {
          changes: { insert: e + e + e + e, from: a },
          effects: ra.of(a + e.length),
          range: G.cursor(a + e.length)
        };
      if (n.charCategorizer(a)(c) != Wt.Word && e9(n, a, i) > -1 && !Gie(n, a, e, i))
        return {
          changes: { insert: e + e, from: a },
          effects: ra.of(a + e.length),
          range: G.cursor(a + e.length)
        };
    }
    return { range: s = l };
  });
  return s ? null : n.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Qk(n, e) {
  let t = Fn(n).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function Gie(n, e, t, r) {
  let i = Fn(n).resolveInner(e, -1), s = r.reduce((o, l) => Math.max(o, l.length), 0);
  for (let o = 0; o < 5; o++) {
    let l = n.sliceDoc(i.from, Math.min(i.to, i.from + t.length + s)), a = l.indexOf(t);
    if (!a || a > -1 && r.indexOf(l.slice(0, a)) > -1) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > t.length + a; ) {
        if (n.sliceDoc(u.to - t.length, u.to) == t)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return !1;
}
function e9(n, e, t) {
  let r = n.charCategorizer(e);
  if (r(n.sliceDoc(e - 1, e)) != Wt.Word)
    return e;
  for (let i of t) {
    let s = e - i.length;
    if (n.sliceDoc(s, e) == i && r(n.sliceDoc(s - 1, s)) != Wt.Word)
      return s;
  }
  return -1;
}
function Yie(n = {}) {
  return [
    Tie,
    Cr,
    Mn.of(n),
    Cie,
    Jie,
    wD
  ];
}
const TD = [
  { key: "Ctrl-Space", run: n4 },
  { mac: "Alt-`", run: n4 },
  { mac: "Alt-i", run: n4 },
  { key: "Escape", run: wie },
  { key: "ArrowDown", run: /* @__PURE__ */ A0(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ A0(!1) },
  { key: "PageDown", run: /* @__PURE__ */ A0(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ A0(!1, "page") },
  { key: "Enter", run: vie }
], Jie = /* @__PURE__ */ wl.highest(/* @__PURE__ */ tu.computeN([Mn], (n) => n.facet(Mn).defaultKeymap ? [TD] : []));
class t9 {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.diagnostic = r;
  }
}
class Jl {
  constructor(e, t, r) {
    this.diagnostics = e, this.panel = t, this.selected = r;
  }
  static init(e, t, r) {
    let i = r.facet(ed).markerFilter;
    i && (e = i(e, r));
    let s = e.slice().sort((u, h) => u.from - h.from || u.to - h.to), o = new lo(), l = [], a = 0;
    for (let u = 0; ; ) {
      let h = u == s.length ? null : s[u];
      if (!h && !l.length)
        break;
      let f, d;
      for (l.length ? (f = a, d = l.reduce((m, g) => Math.min(m, g.to), h && h.from > f ? h.from : 1e8)) : (f = h.from, d = h.to, l.push(h), u++); u < s.length; ) {
        let m = s[u];
        if (m.from == f && (m.to > m.from || m.to == f))
          l.push(m), u++, d = Math.min(m.to, d);
        else {
          d = Math.min(m.from, d);
          break;
        }
      }
      let p = cse(l);
      if (l.some((m) => m.from == m.to || m.from == m.to - 1 && r.doc.lineAt(m.from).to == m.from))
        o.add(f, f, He.widget({
          widget: new sse(p),
          diagnostics: l.slice()
        }));
      else {
        let m = l.reduce((g, b) => b.markClass ? g + " " + b.markClass : g, "");
        o.add(f, d, He.mark({
          class: "cm-lintRange cm-lintRange-" + p + m,
          diagnostics: l.slice(),
          inclusiveEnd: l.some((g) => g.to > d)
        }));
      }
      a = d;
      for (let m = 0; m < l.length; m++)
        l[m].to <= a && l.splice(m--, 1);
    }
    let c = o.finish();
    return new Jl(c, t, Kc(c));
  }
}
function Kc(n, e = null, t = 0) {
  let r = null;
  return n.between(t, 1e9, (i, s, { spec: o }) => {
    if (!(e && o.diagnostics.indexOf(e) < 0))
      if (!r)
        r = new t9(i, s, e || o.diagnostics[0]);
      else {
        if (o.diagnostics.indexOf(r.diagnostic) < 0)
          return !1;
        r = new t9(r.from, s, r.diagnostic);
      }
  }), r;
}
function Xie(n, e) {
  let t = e.pos, r = e.end || t, i = n.state.facet(ed).hideOn(n, t, r);
  if (i != null)
    return i;
  let s = n.startState.doc.lineAt(e.pos);
  return !!(n.effects.some((o) => o.is(AD)) || n.changes.touchesRange(s.from, Math.max(s.to, r)));
}
function Zie(n, e) {
  return n.field(Yr, !1) ? e : e.concat(Xe.appendConfig.of(use));
}
const AD = /* @__PURE__ */ Xe.define(), l7 = /* @__PURE__ */ Xe.define(), OD = /* @__PURE__ */ Xe.define(), Yr = /* @__PURE__ */ On.define({
  create() {
    return new Jl(He.none, null, null);
  },
  update(n, e) {
    if (e.docChanged && n.diagnostics.size) {
      let t = n.diagnostics.map(e.changes), r = null, i = n.panel;
      if (n.selected) {
        let s = e.changes.mapPos(n.selected.from, 1);
        r = Kc(t, n.selected.diagnostic, s) || Kc(t, null, s);
      }
      !t.size && i && e.state.facet(ed).autoPanel && (i = null), n = new Jl(t, i, r);
    }
    for (let t of e.effects)
      if (t.is(AD)) {
        let r = e.state.facet(ed).autoPanel ? t.value.length ? td.open : null : n.panel;
        n = Jl.init(t.value, r, e.state);
      } else t.is(l7) ? n = new Jl(n.diagnostics, t.value ? td.open : null, n.selected) : t.is(OD) && (n = new Jl(n.diagnostics, n.panel, t.value));
    return n;
  },
  provide: (n) => [
    Ef.from(n, (e) => e.panel),
    Ce.decorations.from(n, (e) => e.diagnostics)
  ]
}), Qie = /* @__PURE__ */ He.mark({ class: "cm-lintRange cm-lintRange-active" });
function ese(n, e, t) {
  let { diagnostics: r } = n.state.field(Yr), i, s = -1, o = -1;
  r.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (a, c, { spec: u }) => {
    if (e >= a && e <= c && (a == c || (e > a || t > 0) && (e < c || t < 0)))
      return i = u.diagnostics, s = a, o = c, !1;
  });
  let l = n.state.facet(ed).tooltipFilter;
  return i && l && (i = l(i, n.state)), i ? {
    pos: s,
    end: o,
    above: n.state.doc.lineAt(s).to < o,
    create() {
      return { dom: tse(n, i) };
    }
  } : null;
}
function tse(n, e) {
  return Tt("ul", { class: "cm-tooltip-lint" }, e.map((t) => ID(n, t, !1)));
}
const nse = (n) => {
  let e = n.state.field(Yr, !1);
  (!e || !e.panel) && n.dispatch({ effects: Zie(n.state, [l7.of(!0)]) });
  let t = Of(n, td.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, n9 = (n) => {
  let e = n.state.field(Yr, !1);
  return !e || !e.panel ? !1 : (n.dispatch({ effects: l7.of(!1) }), !0);
}, rse = (n) => {
  let e = n.state.field(Yr, !1);
  if (!e)
    return !1;
  let t = n.state.selection.main, r = e.diagnostics.iter(t.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == t.from && r.to == t.to) ? !1 : (n.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, ise = [
  { key: "Mod-Shift-m", run: nse, preventDefault: !0 },
  { key: "F8", run: rse }
], ed = /* @__PURE__ */ xe.define({
  combine(n) {
    return Object.assign({ sources: n.map((e) => e.source).filter((e) => e != null) }, Ts(n.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, t) => e ? t ? (r) => e(r) || t(r) : e : t
    }));
  }
});
function ED(n) {
  let e = [];
  if (n)
    e: for (let { name: t } of n) {
      for (let r = 0; r < t.length; r++) {
        let i = t[r];
        if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function ID(n, e, t) {
  var r;
  let i = t ? ED(e.actions) : [];
  return Tt("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Tt("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(n) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((s, o) => {
    let l = !1, a = (f) => {
      if (f.preventDefault(), l)
        return;
      l = !0;
      let d = Kc(n.state.field(Yr).diagnostics, e);
      d && s.apply(n, d.from, d.to);
    }, { name: c } = s, u = i[o] ? c.indexOf(i[o]) : -1, h = u < 0 ? c : [
      c.slice(0, u),
      Tt("u", c.slice(u, u + 1)),
      c.slice(u + 1)
    ];
    return Tt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: a,
      onmousedown: a,
      "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[o]})"`}.`
    }, h);
  }), e.source && Tt("div", { class: "cm-diagnosticSource" }, e.source));
}
class sse extends wo {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return Tt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class r9 {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = ID(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class td {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (i) => {
      if (i.keyCode == 27)
        n9(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = ED(s.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == i.keyCode) {
            let a = Kc(this.view.state.field(Yr).diagnostics, s);
            a && s.actions[l].apply(e, a.from, a.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = Tt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: r
    }), this.dom = Tt("div", { class: "cm-panel-lint" }, this.list, Tt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => n9(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Yr).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Yr), r = 0, i = !1, s = null, o = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (l, a, { spec: c }) => {
      for (let u of c.diagnostics) {
        if (o.has(u))
          continue;
        o.add(u);
        let h = -1, f;
        for (let d = r; d < this.items.length; d++)
          if (this.items[d].diagnostic == u) {
            h = d;
            break;
          }
        h < 0 ? (f = new r9(this.view, u), this.items.splice(r, 0, f), i = !0) : (f = this.items[h], h > r && (this.items.splice(r, h - r), i = !0)), t && f.diagnostic == t.diagnostic ? f.dom.hasAttribute("aria-selected") || (f.dom.setAttribute("aria-selected", "true"), s = f) : f.dom.hasAttribute("aria-selected") && f.dom.removeAttribute("aria-selected"), r++;
      }
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new r9(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: l, panel: a }) => {
        let c = a.height / this.list.offsetHeight;
        l.top < a.top ? this.list.scrollTop -= (a.top - l.top) / c : l.bottom > a.bottom && (this.list.scrollTop += (l.bottom - a.bottom) / c);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          t();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Yr), r = Kc(t.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: OD.of(r)
    });
  }
  static open(e) {
    return new td(e);
  }
}
function ose(n, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(n)}</svg>')`;
}
function O0(n) {
  return ose(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const lse = /* @__PURE__ */ Ce.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ O0("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ O0("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ O0("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ O0("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function ase(n) {
  return n == "error" ? 4 : n == "warning" ? 3 : n == "info" ? 2 : 1;
}
function cse(n) {
  let e = "hint", t = 1;
  for (let r of n) {
    let i = ase(r.severity);
    i > t && (t = i, e = r.severity);
  }
  return e;
}
const use = [
  Yr,
  /* @__PURE__ */ Ce.decorations.compute([Yr], (n) => {
    let { selected: e, panel: t } = n.field(Yr);
    return !e || !t || e.from == e.to ? He.none : He.set([
      Qie.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ dF(ese, { hideOn: Xie }),
  lse
], hse = [
  CF(),
  AF(),
  Wz(),
  nne(),
  cH(),
  eM(),
  zz(),
  jt.allowMultipleSelections.of(!0),
  YF(),
  SM(dH, { fallback: !0 }),
  wH(),
  zie(),
  Yie(),
  nF(),
  sF(),
  Jz(),
  Nre(),
  tu.of([
    ...Vie,
    ...nD,
    ...Xre,
    ...hne,
    ...sH,
    ...TD,
    ...ise
  ])
];
function fse(n = {}) {
  return new Ut({
    view(e) {
      return new dse(e, n);
    }
  });
}
class dse {
  constructor(e, t) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = t.width) !== null && r !== void 0 ? r : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let s = (o) => {
        this[i](o);
      };
      return e.dom.addEventListener(i, s), { name: i, handler: s };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
  }
  update(e, t) {
    this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, r, i = this.editorView.dom, s = i.getBoundingClientRect(), o = s.width / i.offsetWidth, l = s.height / i.offsetHeight;
    if (t) {
      let h = e.nodeBefore, f = e.nodeAfter;
      if (h || f) {
        let d = this.editorView.nodeDOM(this.cursorPos - (h ? h.nodeSize : 0));
        if (d) {
          let p = d.getBoundingClientRect(), m = h ? p.bottom : p.top;
          h && f && (m = (m + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let g = this.width / 2 * l;
          r = { left: p.left, right: p.right, top: m - g, bottom: m + g };
        }
      }
    }
    if (!r) {
      let h = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * o;
      r = { left: h.left - f, right: h.left + f, top: h.top, bottom: h.bottom };
    }
    let a = this.editorView.dom.offsetParent;
    this.element || (this.element = a.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
    let c, u;
    if (!a || a == document.body && getComputedStyle(a).position == "static")
      c = -pageXOffset, u = -pageYOffset;
    else {
      let h = a.getBoundingClientRect(), f = h.width / a.offsetWidth, d = h.height / a.offsetHeight;
      c = h.left - a.scrollLeft * f, u = h.top - a.scrollTop * d;
    }
    this.element.style.left = (r.left - c) / o + "px", this.element.style.top = (r.top - u) / l + "px", this.element.style.width = (r.right - r.left) / o + "px", this.element.style.height = (r.bottom - r.top) / l + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i = r && r.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, t, e) : i;
    if (t && !s) {
      let o = t.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let l = sT(this.editorView.state.doc, o, this.editorView.dragging.slice);
        l != null && (o = l);
      }
      this.setCursor(o), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
  }
}
class rn extends Ge {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    return rn.valid(r) ? new rn(r) : Ge.near(r);
  }
  content() {
    return ve.empty;
  }
  eq(e) {
    return e instanceof rn && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new rn(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new a7(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !pse(e) || !mse(e))
      return !1;
    let r = t.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = t.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, r = !1) {
    e: for (; ; ) {
      if (!r && rn.valid(e))
        return e;
      let i = e.pos, s = null;
      for (let o = e.depth; ; o--) {
        let l = e.node(o);
        if (t > 0 ? e.indexAfter(o) < l.childCount : e.index(o) > 0) {
          s = l.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1);
          break;
        } else if (o == 0)
          return null;
        i += t;
        let a = e.doc.resolve(i);
        if (rn.valid(a))
          return a;
      }
      for (; ; ) {
        let o = t > 0 ? s.firstChild : s.lastChild;
        if (!o) {
          if (s.isAtom && !s.isText && !$e.isSelectable(s)) {
            e = e.doc.resolve(i + s.nodeSize * t), r = !1;
            continue e;
          }
          break;
        }
        s = o, i += t;
        let l = e.doc.resolve(i);
        if (rn.valid(l))
          return l;
      }
      return null;
    }
  }
}
rn.prototype.visible = !1;
rn.findFrom = rn.findGapCursorFrom;
Ge.jsonID("gapcursor", rn);
class a7 {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new a7(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return rn.valid(t) ? new rn(t) : Ge.near(t);
  }
}
function pse(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), r = n.node(e);
    if (t == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function mse(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), r = n.node(e);
    if (t == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function gse() {
  return new Ut({
    props: {
      decorations: wse,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && rn.valid(t) ? new rn(t) : null;
      },
      handleClick: bse,
      handleKeyDown: yse,
      handleDOMEvents: { beforeinput: vse }
    }
  });
}
const yse = K3({
  ArrowLeft: E0("horiz", -1),
  ArrowRight: E0("horiz", 1),
  ArrowUp: E0("vert", -1),
  ArrowDown: E0("vert", 1)
});
function E0(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, s) {
    let o = r.selection, l = e > 0 ? o.$to : o.$from, a = o.empty;
    if (o instanceof Ee) {
      if (!s.endOfTextblock(t) || l.depth == 0)
        return !1;
      a = !1, l = r.doc.resolve(e > 0 ? l.after() : l.before());
    }
    let c = rn.findGapCursorFrom(l, e, a);
    return c ? (i && i(r.tr.setSelection(new rn(c))), !0) : !1;
  };
}
function bse(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let r = n.state.doc.resolve(e);
  if (!rn.valid(r))
    return !1;
  let i = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return i && i.inside > -1 && $e.isSelectable(n.state.doc.nodeAt(i.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new rn(r))), !0);
}
function vse(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof rn))
    return !1;
  let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = ce.empty;
  for (let o = r.length - 1; o >= 0; o--)
    i = ce.from(r[o].createAndFill(null, i));
  let s = n.state.tr.replace(t.pos, t.pos, new ve(i, 0, 0));
  return s.setSelection(Ee.near(s.doc.resolve(t.pos + 1))), n.dispatch(s), !1;
}
function wse(n) {
  if (!(n.selection instanceof rn))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Ot.create(n.doc, [mn.widget(n.selection.head, e, { key: "gapcursor" })]);
}
function c7(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-cursor",
      ...e
    }
  }), n;
}
const og = St(
  {},
  "dropCursorConfig"
);
c7(og, {
  displayName: "Ctx<dropCursor>"
});
const DD = kn(
  (n) => fse(n.get(og.key))
);
c7(DD, {
  displayName: "Prose<dropCursor>"
});
const ND = kn(() => gse());
c7(ND, {
  displayName: "Prose<gapCursor>"
});
const xse = [
  og,
  DD,
  ND
];
function kse(n) {
  var e;
  const t = (e = void 0) != null ? e : !1;
  let r = typeof document > "u" ? null : document.createElement("div");
  return new Ut({
    key: Sse,
    view: (i) => {
      t !== !0 && Ase(i.state.schema, t || []);
      const s = i.dom.ownerDocument;
      r = r || document.createElement("div");
      const o = r, l = () => {
        Mse(i, o);
      };
      let a;
      return window.ResizeObserver && (a = new window.ResizeObserver(() => l()), a.observe(i.dom)), s.addEventListener("selectionchange", l), {
        update: () => {
          l();
        },
        destroy: () => {
          s.removeEventListener("selectionchange", l), a && a.unobserve(i.dom);
        }
      };
    },
    props: {
      handleKeyDown: (i, s) => {
        var o;
        const { selection: l } = i.state;
        if (s.altKey || s.ctrlKey || s.metaKey || s.shiftKey || s.isComposing || !["ArrowLeft", "ArrowRight"].includes(s.key) || !D5(l) || !l.empty)
          return !1;
        const a = l.$head, [c, u] = RD(a), h = i.state.storedMarks || a.marks();
        if (c && u && !nt.sameSet(c, u)) {
          if (s.key === "ArrowLeft" && !nt.sameSet(c, h))
            return i.dispatch(i.state.tr.setStoredMarks(c)), !0;
          if (s.key === "ArrowRight" && !nt.sameSet(u, h))
            return i.dispatch(i.state.tr.setStoredMarks(u)), !0;
        }
        return s.key === "ArrowLeft" && a.textOffset === 1 ? (i.dispatch(
          i.state.tr.setSelection(Ee.create(i.state.doc, a.pos - 1)).setStoredMarks(a.marks())
        ), !0) : s.key === "ArrowRight" && a.textOffset + 1 === ((o = a.parent.maybeChild(a.index())) == null ? void 0 : o.nodeSize) ? (i.dispatch(
          i.state.tr.setSelection(Ee.create(i.state.doc, a.pos + 1)).setStoredMarks(a.marks())
        ), !0) : !1;
      },
      decorations: (i) => {
        if (!(!r || !D5(i.selection) || !i.selection.empty))
          return Ot.create(i.doc, [
            mn.widget(0, r, {
              key: "prosemirror-virtual-cursor"
            })
          ]);
      },
      attributes: {
        class: "virtual-cursor-enabled"
      }
    }
  });
}
var Sse = new en("prosemirror-virtual-cursor");
function Cse(n, e) {
  var t;
  const r = window.getSelection();
  if (!r || !r.rangeCount)
    return null;
  const i = (t = r?.getRangeAt(0)) == null ? void 0 : t.cloneRange();
  if (!i)
    return null;
  i.collapse(e);
  const s = i.getClientRects(), o = s?.length ? s[s.length - 1] : null;
  return o?.height ? o : n.coordsAtPos(n.state.selection.head);
}
function RD(n) {
  const e = n.index(), t = n.parent.maybeChild(e);
  let r = n.textOffset ? t : null;
  return !r && e > 0 && (r = n.parent.maybeChild(e - 1)), [r?.marks, t?.marks];
}
function D5(n) {
  return n && typeof n == "object" && "$cursor" in n;
}
function Mse(n, e) {
  if (!n || !n.dom || n.isDestroyed || !e)
    return;
  const { state: t, dom: r } = n, { selection: i } = t;
  if (!D5(i))
    return;
  const s = Cse(n, i.$head === i.$from);
  if (!s)
    return e;
  const o = r.getBoundingClientRect();
  let l = "prosemirror-virtual-cursor";
  const a = t.selection.$head, [c, u] = RD(a), h = t.storedMarks || a.marks();
  i.$cursor && c && u && h && !nt.sameSet(c, u) && (nt.sameSet(c, h) ? l += " prosemirror-virtual-cursor-left" : nt.sameSet(u, h) && (l += " prosemirror-virtual-cursor-right")), e.className = l, Tse(e, "prosemirror-virtual-cursor-animation"), e.style.height = `${s.bottom - s.top}px`, e.style.left = `${s.left - o.left}px`, e.style.top = `${s.top - o.top}px`;
}
function Tse(n, e) {
  n.classList.remove(e), n.offsetWidth, n.classList.add(e);
}
function Ase(n, e) {
  for (const [t, r] of Object.entries(n.marks))
    r.spec.inclusive === !1 && !e.includes(t) && console.warn(
      `[prosemirror-virtual-cursor] Virtual cursor does not work well with marks that have inclusive set to false. Please consider removing the inclusive option from the "${t}" mark or adding it to the "skipWarning" option.`
    );
}
var Ose = Object.defineProperty, i9 = Object.getOwnPropertySymbols, Ese = Object.prototype.hasOwnProperty, Ise = Object.prototype.propertyIsEnumerable, s9 = (n, e, t) => e in n ? Ose(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Dse = (n, e) => {
  for (var t in e || (e = {}))
    Ese.call(e, t) && s9(n, t, e[t]);
  if (i9)
    for (var t of i9(e))
      Ise.call(e, t) && s9(n, t, e[t]);
  return n;
};
function PD(n, e) {
  return Object.assign(n, {
    meta: Dse({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const Nse = {
  imageIcon: "🌌",
  uploadButton: "Upload",
  confirmButton: "⏎",
  uploadPlaceholderText: "/Paste",
  onUpload: (n) => Promise.resolve(URL.createObjectURL(n))
}, lg = St(
  Nse,
  "inlineImageConfigCtx"
);
PD(lg, {
  displayName: "Config<image-inline>",
  group: "ImageInline"
});
function Op({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
Op.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const Rse = qE("abcdefg", 8), Pse = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setLink: {
      type: Function,
      required: !0
    },
    imageIcon: {
      type: String,
      required: !1
    },
    uploadButton: {
      type: String,
      required: !1
    },
    confirmButton: {
      type: String,
      required: !1
    },
    uploadPlaceholderText: {
      type: String,
      required: !1
    },
    onUpload: {
      type: Function,
      required: !0
    }
  },
  setup({
    readonly: n,
    src: e,
    setLink: t,
    onUpload: r,
    imageIcon: i,
    uploadButton: s,
    confirmButton: o,
    uploadPlaceholderText: l,
    className: a
  }) {
    var c, u;
    const h = Ae(!1), f = Ae(), d = Ae((c = e.value) != null ? c : ""), p = Ae(Rse()), m = Ae(((u = e.value) == null ? void 0 : u.length) !== 0), g = (C) => {
      const T = C.target.value;
      m.value = T.length !== 0, d.value = T;
    }, b = (C) => {
      var M, T;
      C.key === "Enter" && t((T = (M = f.value) == null ? void 0 : M.value) != null ? T : "");
    }, w = () => {
      var C, M;
      t((M = (C = f.value) == null ? void 0 : C.value) != null ? M : "");
    }, k = (C) => {
      var M;
      const T = (M = C.target.files) == null ? void 0 : M[0];
      T && r(T).then((N) => {
        N && (t(N), m.value = !0);
      }).catch((N) => {
        console.error("An error occurred while uploading image"), console.error(N);
      });
    };
    return () => /* @__PURE__ */ j("div", { class: Hn("image-edit", a) }, /* @__PURE__ */ j(Op, { icon: i, class: "image-icon" }), /* @__PURE__ */ j("div", { class: Hn("link-importer", h.value && "focus") }, /* @__PURE__ */ j(
      "input",
      {
        ref: f,
        draggable: "true",
        onDragstart: (C) => {
          C.preventDefault(), C.stopPropagation();
        },
        disabled: n.value,
        class: "link-input-area",
        value: d.value,
        onInput: g,
        onKeydown: b,
        onFocus: () => h.value = !0,
        onBlur: () => h.value = !1
      }
    ), !m.value && /* @__PURE__ */ j("div", { class: "placeholder" }, /* @__PURE__ */ j(
      "input",
      {
        disabled: n.value,
        class: "hidden",
        id: p.value,
        type: "file",
        accept: "image/*",
        onChange: k
      }
    ), /* @__PURE__ */ j("label", { class: "uploader", for: p.value }, /* @__PURE__ */ j(Op, { icon: s })), /* @__PURE__ */ j("span", { class: "text", onClick: () => {
      var C;
      return (C = f.value) == null ? void 0 : C.focus();
    } }, l))), d.value && /* @__PURE__ */ j("div", { class: "confirm", onClick: () => w() }, /* @__PURE__ */ j(Op, { icon: o })));
  }
}), _se = /* @__PURE__ */ $n({
  props: {
    src: {
      type: Object,
      required: !0
    },
    alt: {
      type: Object,
      required: !0
    },
    title: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { src: e, alt: t, title: r } = n;
    return () => {
      var i;
      return (i = e.value) != null && i.length ? /* @__PURE__ */ j(
        "img",
        {
          class: "image-inline",
          src: e.value,
          alt: t.value,
          title: r.value
        }
      ) : /* @__PURE__ */ j(
        Pse,
        {
          src: n.src,
          selected: n.selected,
          readonly: n.readonly,
          setLink: (s) => n.setAttr("src", s),
          imageIcon: n.config.imageIcon,
          uploadButton: n.config.uploadButton,
          confirmButton: n.config.confirmButton,
          uploadPlaceholderText: n.config.uploadPlaceholderText,
          onUpload: n.config.onUpload,
          className: "empty-image-inline"
        }
      );
    };
  }
}), _D = yd(
  La.node,
  (n) => (e, t, r) => {
    const i = Ae(e.attrs.src), s = Ae(e.attrs.alt), o = Ae(e.attrs.title), l = Ae(!1), a = Ae(!t.editable), c = (g, b) => {
      if (!t.editable) return;
      const w = r();
      w != null && t.dispatch(
        t.state.tr.setNodeAttribute(
          w,
          g,
          g === "src" ? Ui.sanitize(b) : b
        )
      );
    }, u = n.get(lg.key), h = ji(_se, {
      src: i,
      alt: s,
      title: o,
      selected: l,
      readonly: a,
      setAttr: c,
      config: u
    }), f = document.createElement("span");
    f.className = "milkdown-image-inline", h.mount(f);
    const d = cu(() => {
      l.value ? f.classList.add("selected") : f.classList.remove("selected");
    }), p = u.proxyDomURL, m = (g) => {
      if (!p)
        i.value = g.attrs.src;
      else {
        const b = p(g.attrs.src);
        typeof b == "string" ? i.value = b : b.then((w) => {
          i.value = w;
        }).catch(console.error);
      }
      s.value = g.attrs.alt, o.value = g.attrs.title;
    };
    return m(e), {
      dom: f,
      update: (g) => g.type !== e.type ? !1 : (m(g), !0),
      stopEvent: (g) => g.target instanceof HTMLInputElement,
      selectNode: () => {
        l.value = !0;
      },
      deselectNode: () => {
        l.value = !1;
      },
      destroy: () => {
        d(), h.unmount(), f.remove();
      }
    };
  }
);
PD(_D, {
  displayName: "NodeView<image-inline>",
  group: "ImageInline"
});
const Lse = [
  lg,
  _D
];
class Wr {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(e, t, r) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = t, this.end = r;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, t) {
    return t ? !e || !e.loc || !t.loc || e.loc.lexer !== t.loc.lexer ? null : new Wr(e.loc.lexer, e.loc.start, t.loc.end) : e && e.loc;
  }
}
class yi {
  // don't expand the token
  // used in \noexpand
  constructor(e, t) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = t;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, t) {
    return new yi(t, Wr.range(this, e));
  }
}
class se {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(e, t) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var r = "KaTeX parse error: " + e, i, s, o = t && t.loc;
    if (o && o.start <= o.end) {
      var l = o.lexer.input;
      i = o.start, s = o.end, i === l.length ? r += " at end of input: " : r += " at position " + (i + 1) + ": ";
      var a = l.slice(i, s).replace(/[^]/g, "$&̲"), c;
      i > 15 ? c = "…" + l.slice(i - 15, i) : c = l.slice(0, i);
      var u;
      s + 15 < l.length ? u = l.slice(s, s + 15) + "…" : u = l.slice(s), r += c + a + u;
    }
    var h = new Error(r);
    return h.name = "ParseError", h.__proto__ = se.prototype, h.position = i, i != null && s != null && (h.length = s - i), h.rawMessage = e, h;
  }
}
se.prototype.__proto__ = Error.prototype;
var Bse = function(e, t) {
  return e.indexOf(t) !== -1;
}, zse = function(e, t) {
  return e === void 0 ? t : e;
}, Fse = /([A-Z])/g, Hse = function(e) {
  return e.replace(Fse, "-$1").toLowerCase();
}, $se = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, Vse = /[&><"']/g;
function qse(n) {
  return String(n).replace(Vse, (e) => $se[e]);
}
var LD = function n(e) {
  return e.type === "ordgroup" || e.type === "color" ? e.body.length === 1 ? n(e.body[0]) : e : e.type === "font" ? n(e.body) : e;
}, Wse = function(e) {
  var t = LD(e);
  return t.type === "mathord" || t.type === "textord" || t.type === "atom";
}, jse = function(e) {
  if (!e)
    throw new Error("Expected non-null, but got " + String(e));
  return e;
}, Use = function(e) {
  var t = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
  return t ? t[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(t[1]) ? null : t[1].toLowerCase() : "_relative";
}, Be = {
  contains: Bse,
  deflt: zse,
  escape: qse,
  hyphenate: Hse,
  getBaseElem: LD,
  isCharacterBox: Wse,
  protocolFromUrl: Use
}, Ep = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (n) => "#" + n
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (n, e) => (e.push(n), e)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (n) => Math.max(0, n),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (n) => Math.max(0, n),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n) => Math.max(0, n),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n) => n === "Infinity" ? 1 / 0 : parseInt(n)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function Kse(n) {
  if (n.default)
    return n.default;
  var e = n.type, t = Array.isArray(e) ? e[0] : e;
  if (typeof t != "string")
    return t.enum[0];
  switch (t) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class u7 {
  constructor(e) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, e = e || {};
    for (var t in Ep)
      if (Ep.hasOwnProperty(t)) {
        var r = Ep[t];
        this[t] = e[t] !== void 0 ? r.processor ? r.processor(e[t]) : e[t] : Kse(r);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(e, t, r) {
    var i = this.strict;
    if (typeof i == "function" && (i = i(e, t, r)), !(!i || i === "ignore")) {
      if (i === !0 || i === "error")
        throw new se("LaTeX-incompatible input and strict mode is set to 'error': " + (t + " [" + e + "]"), r);
      i === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(e, t, r) {
    var i = this.strict;
    if (typeof i == "function")
      try {
        i = i(e, t, r);
      } catch {
        i = "error";
      }
    return !i || i === "ignore" ? !1 : i === !0 || i === "error" ? !0 : i === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(e) {
    if (e.url && !e.protocol) {
      var t = Be.protocolFromUrl(e.url);
      if (t == null)
        return !1;
      e.protocol = t;
    }
    var r = typeof this.trust == "function" ? this.trust(e) : this.trust;
    return !!r;
  }
}
class Io {
  constructor(e, t, r) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = t, this.cramped = r;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return ss[Gse[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return ss[Yse[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return ss[Jse[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return ss[Xse[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return ss[Zse[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return ss[Qse[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var h7 = 0, Wm = 1, Ic = 2, so = 3, nd = 4, fi = 5, Gc = 6, cr = 7, ss = [new Io(h7, 0, !1), new Io(Wm, 0, !0), new Io(Ic, 1, !1), new Io(so, 1, !0), new Io(nd, 2, !1), new Io(fi, 2, !0), new Io(Gc, 3, !1), new Io(cr, 3, !0)], Gse = [nd, fi, nd, fi, Gc, cr, Gc, cr], Yse = [fi, fi, fi, fi, cr, cr, cr, cr], Jse = [Ic, so, nd, fi, Gc, cr, Gc, cr], Xse = [so, so, fi, fi, cr, cr, cr, cr], Zse = [Wm, Wm, so, so, fi, fi, cr, cr], Qse = [h7, Wm, Ic, so, Ic, so, Ic, so], We = {
  DISPLAY: ss[h7],
  TEXT: ss[Ic],
  SCRIPT: ss[nd],
  SCRIPTSCRIPT: ss[Gc]
}, N5 = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function eoe(n) {
  for (var e = 0; e < N5.length; e++)
    for (var t = N5[e], r = 0; r < t.blocks.length; r++) {
      var i = t.blocks[r];
      if (n >= i[0] && n <= i[1])
        return t.name;
    }
  return null;
}
var Ip = [];
N5.forEach((n) => n.blocks.forEach((e) => Ip.push(...e)));
function BD(n) {
  for (var e = 0; e < Ip.length; e += 2)
    if (n >= Ip[e] && n <= Ip[e + 1])
      return !0;
  return !1;
}
var Xa = 80, toe = function(e, t) {
  return "M95," + (622 + e + t) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, noe = function(e, t) {
  return "M263," + (601 + e + t) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, roe = function(e, t) {
  return "M983 " + (10 + e + t) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, ioe = function(e, t) {
  return "M424," + (2398 + e + t) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + t + `
h400000v` + (40 + e) + "h-400000z";
}, soe = function(e, t) {
  return "M473," + (2713 + e + t) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "H1017.7z";
}, ooe = function(e) {
  var t = e / 2;
  return "M400000 " + e + " H0 L" + t + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, loe = function(e, t, r) {
  var i = r - 54 - t - e;
  return "M702 " + (e + t) + "H400000" + (40 + e) + `
H742v` + i + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + t + "H400000v" + (40 + e) + "H742z";
}, aoe = function(e, t, r) {
  t = 1e3 * t;
  var i = "";
  switch (e) {
    case "sqrtMain":
      i = toe(t, Xa);
      break;
    case "sqrtSize1":
      i = noe(t, Xa);
      break;
    case "sqrtSize2":
      i = roe(t, Xa);
      break;
    case "sqrtSize3":
      i = ioe(t, Xa);
      break;
    case "sqrtSize4":
      i = soe(t, Xa);
      break;
    case "sqrtTall":
      i = loe(t, Xa, r);
  }
  return i;
}, coe = function(e, t) {
  switch (e) {
    case "⎜":
      return "M291 0 H417 V" + t + " H291z M291 0 H417 V" + t + " H291z";
    case "∣":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z";
    case "∥":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z" + ("M367 0 H410 V" + t + " H367z M367 0 H410 V" + t + " H367z");
    case "⎟":
      return "M457 0 H583 V" + t + " H457z M457 0 H583 V" + t + " H457z";
    case "⎢":
      return "M319 0 H403 V" + t + " H319z M319 0 H403 V" + t + " H319z";
    case "⎥":
      return "M263 0 H347 V" + t + " H263z M263 0 H347 V" + t + " H263z";
    case "⎪":
      return "M384 0 H504 V" + t + " H384z M384 0 H504 V" + t + " H384z";
    case "⏐":
      return "M312 0 H355 V" + t + " H312z M312 0 H355 V" + t + " H312z";
    case "‖":
      return "M257 0 H300 V" + t + " H257z M257 0 H300 V" + t + " H257z" + ("M478 0 H521 V" + t + " H478z M478 0 H521 V" + t + " H478z");
    default:
      return "";
  }
}, o9 = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, uoe = function(e, t) {
  switch (e) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + t + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + t + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + ` v585 h43z
M367 15 v585 v` + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + t + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v602 h84z
M403 1759 V0 H319 V1759 v` + t + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + t + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (t + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (t + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (t + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (t + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class _d {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(e) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var e = document.createDocumentFragment(), t = 0; t < this.children.length; t++)
      e.appendChild(this.children[t].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var e = "", t = 0; t < this.children.length; t++)
      e += this.children[t].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var e = (t) => t.toText();
    return this.children.map(e).join("");
  }
}
var ps = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, I0 = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, l9 = {
  // Latin-1
  Å: "A",
  Ð: "D",
  Þ: "o",
  å: "a",
  ð: "d",
  þ: "o",
  // Cyrillic
  А: "A",
  Б: "B",
  В: "B",
  Г: "F",
  Д: "A",
  Е: "E",
  Ж: "K",
  З: "3",
  И: "N",
  Й: "N",
  К: "K",
  Л: "N",
  М: "M",
  Н: "H",
  О: "O",
  П: "N",
  Р: "P",
  С: "C",
  Т: "T",
  У: "y",
  Ф: "O",
  Х: "X",
  Ц: "U",
  Ч: "h",
  Ш: "W",
  Щ: "W",
  Ъ: "B",
  Ы: "X",
  Ь: "B",
  Э: "3",
  Ю: "X",
  Я: "R",
  а: "a",
  б: "b",
  в: "a",
  г: "r",
  д: "y",
  е: "e",
  ж: "m",
  з: "e",
  и: "n",
  й: "n",
  к: "n",
  л: "n",
  м: "m",
  н: "n",
  о: "o",
  п: "n",
  р: "p",
  с: "c",
  т: "o",
  у: "y",
  ф: "b",
  х: "x",
  ц: "n",
  ч: "n",
  ш: "w",
  щ: "w",
  ъ: "a",
  ы: "m",
  ь: "a",
  э: "e",
  ю: "m",
  я: "r"
};
function hoe(n, e) {
  ps[n] = e;
}
function f7(n, e, t) {
  if (!ps[e])
    throw new Error("Font metrics not found for font: " + e + ".");
  var r = n.charCodeAt(0), i = ps[e][r];
  if (!i && n[0] in l9 && (r = l9[n[0]].charCodeAt(0), i = ps[e][r]), !i && t === "text" && BD(r) && (i = ps[e][77]), i)
    return {
      depth: i[0],
      height: i[1],
      italic: i[2],
      skew: i[3],
      width: i[4]
    };
}
var i4 = {};
function foe(n) {
  var e;
  if (n >= 5 ? e = 0 : n >= 3 ? e = 1 : e = 2, !i4[e]) {
    var t = i4[e] = {
      cssEmPerMu: I0.quad[e] / 18
    };
    for (var r in I0)
      I0.hasOwnProperty(r) && (t[r] = I0[r][e]);
  }
  return i4[e];
}
var doe = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], a9 = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], c9 = function(e, t) {
  return t.size < 2 ? e : doe[e - 1][t.size - 1];
};
class Ys {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(e) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = e.style, this.color = e.color, this.size = e.size || Ys.BASESIZE, this.textSize = e.textSize || this.size, this.phantom = !!e.phantom, this.font = e.font || "", this.fontFamily = e.fontFamily || "", this.fontWeight = e.fontWeight || "", this.fontShape = e.fontShape || "", this.sizeMultiplier = a9[this.size - 1], this.maxSize = e.maxSize, this.minRuleThickness = e.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(e) {
    var t = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var r in e)
      e.hasOwnProperty(r) && (t[r] = e[r]);
    return new Ys(t);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(e) {
    return this.style === e ? this : this.extend({
      style: e,
      size: c9(this.textSize, e)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(e) {
    return this.size === e && this.textSize === e ? this : this.extend({
      style: this.style.text(),
      size: e,
      textSize: e,
      sizeMultiplier: a9[e - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(e) {
    e = e || this.style.text();
    var t = c9(Ys.BASESIZE, e);
    return this.size === t && this.textSize === Ys.BASESIZE && this.style === e ? this : this.extend({
      style: e,
      size: t
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var e;
    switch (this.style.id) {
      case 4:
      case 5:
        e = 3;
        break;
      case 6:
      case 7:
        e = 1;
        break;
      default:
        e = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: e
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(e) {
    return this.extend({
      color: e
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(e) {
    return this.extend({
      font: e
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(e) {
    return this.extend({
      fontFamily: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(e) {
    return this.extend({
      fontWeight: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(e) {
    return this.extend({
      fontShape: e,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(e) {
    return e.size !== this.size ? ["sizing", "reset-size" + e.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Ys.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Ys.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = foe(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Ys.BASESIZE = 6;
var R5 = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, poe = {
  ex: !0,
  em: !0,
  mu: !0
}, zD = function(e) {
  return typeof e != "string" && (e = e.unit), e in R5 || e in poe || e === "ex";
}, Qt = function(e, t) {
  var r;
  if (e.unit in R5)
    r = R5[e.unit] / t.fontMetrics().ptPerEm / t.sizeMultiplier;
  else if (e.unit === "mu")
    r = t.fontMetrics().cssEmPerMu;
  else {
    var i;
    if (t.style.isTight() ? i = t.havingStyle(t.style.text()) : i = t, e.unit === "ex")
      r = i.fontMetrics().xHeight;
    else if (e.unit === "em")
      r = i.fontMetrics().quad;
    else
      throw new se("Invalid unit: '" + e.unit + "'");
    i !== t && (r *= i.sizeMultiplier / t.sizeMultiplier);
  }
  return Math.min(e.number * r, t.maxSize);
}, fe = function(e) {
  return +e.toFixed(4) + "em";
}, yl = function(e) {
  return e.filter((t) => t).join(" ");
}, FD = function(e, t, r) {
  if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = r || {}, t) {
    t.style.isTight() && this.classes.push("mtight");
    var i = t.getColor();
    i && (this.style.color = i);
  }
}, HD = function(e) {
  var t = document.createElement(e);
  t.className = yl(this.classes);
  for (var r in this.style)
    this.style.hasOwnProperty(r) && (t.style[r] = this.style[r]);
  for (var i in this.attributes)
    this.attributes.hasOwnProperty(i) && t.setAttribute(i, this.attributes[i]);
  for (var s = 0; s < this.children.length; s++)
    t.appendChild(this.children[s].toNode());
  return t;
}, moe = /[\s"'>/=\x00-\x1f]/, $D = function(e) {
  var t = "<" + e;
  this.classes.length && (t += ' class="' + Be.escape(yl(this.classes)) + '"');
  var r = "";
  for (var i in this.style)
    this.style.hasOwnProperty(i) && (r += Be.hyphenate(i) + ":" + this.style[i] + ";");
  r && (t += ' style="' + Be.escape(r) + '"');
  for (var s in this.attributes)
    if (this.attributes.hasOwnProperty(s)) {
      if (moe.test(s))
        throw new se("Invalid attribute name '" + s + "'");
      t += " " + s + '="' + Be.escape(this.attributes[s]) + '"';
    }
  t += ">";
  for (var o = 0; o < this.children.length; o++)
    t += this.children[o].toMarkup();
  return t += "</" + e + ">", t;
};
class Ld {
  constructor(e, t, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, FD.call(this, e, r, i), this.children = t || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  toNode() {
    return HD.call(this, "span");
  }
  toMarkup() {
    return $D.call(this, "span");
  }
}
class d7 {
  constructor(e, t, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, FD.call(this, t, i), this.children = r || [], this.setAttribute("href", e);
  }
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  toNode() {
    return HD.call(this, "a");
  }
  toMarkup() {
    return $D.call(this, "a");
  }
}
class goe {
  constructor(e, t, r) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = t, this.src = e, this.classes = ["mord"], this.style = r;
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  toNode() {
    var e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (var t in this.style)
      this.style.hasOwnProperty(t) && (e.style[t] = this.style[t]);
    return e;
  }
  toMarkup() {
    var e = '<img src="' + Be.escape(this.src) + '"' + (' alt="' + Be.escape(this.alt) + '"'), t = "";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t += Be.hyphenate(r) + ":" + this.style[r] + ";");
    return t && (e += ' style="' + Be.escape(t) + '"'), e += "'/>", e;
  }
}
var yoe = {
  î: "ı̂",
  ï: "ı̈",
  í: "ı́",
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  ì: "ı̀"
};
class xi {
  constructor(e, t, r, i, s, o, l, a) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = t || 0, this.depth = r || 0, this.italic = i || 0, this.skew = s || 0, this.width = o || 0, this.classes = l || [], this.style = a || {}, this.maxFontSize = 0;
    var c = eoe(this.text.charCodeAt(0));
    c && this.classes.push(c + "_fallback"), /[îïíì]/.test(this.text) && (this.text = yoe[this.text]);
  }
  hasClass(e) {
    return Be.contains(this.classes, e);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var e = document.createTextNode(this.text), t = null;
    this.italic > 0 && (t = document.createElement("span"), t.style.marginRight = fe(this.italic)), this.classes.length > 0 && (t = t || document.createElement("span"), t.className = yl(this.classes));
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t = t || document.createElement("span"), t.style[r] = this.style[r]);
    return t ? (t.appendChild(e), t) : e;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var e = !1, t = "<span";
    this.classes.length && (e = !0, t += ' class="', t += Be.escape(yl(this.classes)), t += '"');
    var r = "";
    this.italic > 0 && (r += "margin-right:" + this.italic + "em;");
    for (var i in this.style)
      this.style.hasOwnProperty(i) && (r += Be.hyphenate(i) + ":" + this.style[i] + ";");
    r && (e = !0, t += ' style="' + Be.escape(r) + '"');
    var s = Be.escape(this.text);
    return e ? (t += ">", t += s, t += "</span>", t) : s;
  }
}
class po {
  constructor(e, t) {
    this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = t || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "svg");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    for (var i = 0; i < this.children.length; i++)
      t.appendChild(this.children[i].toNode());
    return t;
  }
  toMarkup() {
    var e = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + Be.escape(this.attributes[t]) + '"');
    e += ">";
    for (var r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</svg>", e;
  }
}
class bl {
  constructor(e, t) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = t;
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "path");
    return this.alternate ? t.setAttribute("d", this.alternate) : t.setAttribute("d", o9[this.pathName]), t;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + Be.escape(this.alternate) + '"/>' : '<path d="' + Be.escape(o9[this.pathName]) + '"/>';
  }
}
class P5 {
  constructor(e) {
    this.attributes = void 0, this.attributes = e || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "line");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    return t;
  }
  toMarkup() {
    var e = "<line";
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + Be.escape(this.attributes[t]) + '"');
    return e += "/>", e;
  }
}
function u9(n) {
  if (n instanceof xi)
    return n;
  throw new Error("Expected symbolNode but got " + String(n) + ".");
}
function boe(n) {
  if (n instanceof Ld)
    return n;
  throw new Error("Expected span<HtmlDomNode> but got " + String(n) + ".");
}
var voe = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, woe = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, zt = {
  math: {},
  text: {}
};
function y(n, e, t, r, i, s) {
  zt[n][i] = {
    font: e,
    group: t,
    replace: r
  }, s && r && (zt[n][r] = zt[n][i]);
}
var v = "math", ee = "text", x = "main", A = "ams", Kt = "accent-token", ke = "bin", br = "close", mu = "inner", qe = "mathord", yn = "op-token", ti = "open", ag = "punct", D = "rel", Mo = "spacing", _ = "textord";
y(v, x, D, "≡", "\\equiv", !0);
y(v, x, D, "≺", "\\prec", !0);
y(v, x, D, "≻", "\\succ", !0);
y(v, x, D, "∼", "\\sim", !0);
y(v, x, D, "⊥", "\\perp");
y(v, x, D, "⪯", "\\preceq", !0);
y(v, x, D, "⪰", "\\succeq", !0);
y(v, x, D, "≃", "\\simeq", !0);
y(v, x, D, "∣", "\\mid", !0);
y(v, x, D, "≪", "\\ll", !0);
y(v, x, D, "≫", "\\gg", !0);
y(v, x, D, "≍", "\\asymp", !0);
y(v, x, D, "∥", "\\parallel");
y(v, x, D, "⋈", "\\bowtie", !0);
y(v, x, D, "⌣", "\\smile", !0);
y(v, x, D, "⊑", "\\sqsubseteq", !0);
y(v, x, D, "⊒", "\\sqsupseteq", !0);
y(v, x, D, "≐", "\\doteq", !0);
y(v, x, D, "⌢", "\\frown", !0);
y(v, x, D, "∋", "\\ni", !0);
y(v, x, D, "∝", "\\propto", !0);
y(v, x, D, "⊢", "\\vdash", !0);
y(v, x, D, "⊣", "\\dashv", !0);
y(v, x, D, "∋", "\\owns");
y(v, x, ag, ".", "\\ldotp");
y(v, x, ag, "⋅", "\\cdotp");
y(v, x, _, "#", "\\#");
y(ee, x, _, "#", "\\#");
y(v, x, _, "&", "\\&");
y(ee, x, _, "&", "\\&");
y(v, x, _, "ℵ", "\\aleph", !0);
y(v, x, _, "∀", "\\forall", !0);
y(v, x, _, "ℏ", "\\hbar", !0);
y(v, x, _, "∃", "\\exists", !0);
y(v, x, _, "∇", "\\nabla", !0);
y(v, x, _, "♭", "\\flat", !0);
y(v, x, _, "ℓ", "\\ell", !0);
y(v, x, _, "♮", "\\natural", !0);
y(v, x, _, "♣", "\\clubsuit", !0);
y(v, x, _, "℘", "\\wp", !0);
y(v, x, _, "♯", "\\sharp", !0);
y(v, x, _, "♢", "\\diamondsuit", !0);
y(v, x, _, "ℜ", "\\Re", !0);
y(v, x, _, "♡", "\\heartsuit", !0);
y(v, x, _, "ℑ", "\\Im", !0);
y(v, x, _, "♠", "\\spadesuit", !0);
y(v, x, _, "§", "\\S", !0);
y(ee, x, _, "§", "\\S");
y(v, x, _, "¶", "\\P", !0);
y(ee, x, _, "¶", "\\P");
y(v, x, _, "†", "\\dag");
y(ee, x, _, "†", "\\dag");
y(ee, x, _, "†", "\\textdagger");
y(v, x, _, "‡", "\\ddag");
y(ee, x, _, "‡", "\\ddag");
y(ee, x, _, "‡", "\\textdaggerdbl");
y(v, x, br, "⎱", "\\rmoustache", !0);
y(v, x, ti, "⎰", "\\lmoustache", !0);
y(v, x, br, "⟯", "\\rgroup", !0);
y(v, x, ti, "⟮", "\\lgroup", !0);
y(v, x, ke, "∓", "\\mp", !0);
y(v, x, ke, "⊖", "\\ominus", !0);
y(v, x, ke, "⊎", "\\uplus", !0);
y(v, x, ke, "⊓", "\\sqcap", !0);
y(v, x, ke, "∗", "\\ast");
y(v, x, ke, "⊔", "\\sqcup", !0);
y(v, x, ke, "◯", "\\bigcirc", !0);
y(v, x, ke, "∙", "\\bullet", !0);
y(v, x, ke, "‡", "\\ddagger");
y(v, x, ke, "≀", "\\wr", !0);
y(v, x, ke, "⨿", "\\amalg");
y(v, x, ke, "&", "\\And");
y(v, x, D, "⟵", "\\longleftarrow", !0);
y(v, x, D, "⇐", "\\Leftarrow", !0);
y(v, x, D, "⟸", "\\Longleftarrow", !0);
y(v, x, D, "⟶", "\\longrightarrow", !0);
y(v, x, D, "⇒", "\\Rightarrow", !0);
y(v, x, D, "⟹", "\\Longrightarrow", !0);
y(v, x, D, "↔", "\\leftrightarrow", !0);
y(v, x, D, "⟷", "\\longleftrightarrow", !0);
y(v, x, D, "⇔", "\\Leftrightarrow", !0);
y(v, x, D, "⟺", "\\Longleftrightarrow", !0);
y(v, x, D, "↦", "\\mapsto", !0);
y(v, x, D, "⟼", "\\longmapsto", !0);
y(v, x, D, "↗", "\\nearrow", !0);
y(v, x, D, "↩", "\\hookleftarrow", !0);
y(v, x, D, "↪", "\\hookrightarrow", !0);
y(v, x, D, "↘", "\\searrow", !0);
y(v, x, D, "↼", "\\leftharpoonup", !0);
y(v, x, D, "⇀", "\\rightharpoonup", !0);
y(v, x, D, "↙", "\\swarrow", !0);
y(v, x, D, "↽", "\\leftharpoondown", !0);
y(v, x, D, "⇁", "\\rightharpoondown", !0);
y(v, x, D, "↖", "\\nwarrow", !0);
y(v, x, D, "⇌", "\\rightleftharpoons", !0);
y(v, A, D, "≮", "\\nless", !0);
y(v, A, D, "", "\\@nleqslant");
y(v, A, D, "", "\\@nleqq");
y(v, A, D, "⪇", "\\lneq", !0);
y(v, A, D, "≨", "\\lneqq", !0);
y(v, A, D, "", "\\@lvertneqq");
y(v, A, D, "⋦", "\\lnsim", !0);
y(v, A, D, "⪉", "\\lnapprox", !0);
y(v, A, D, "⊀", "\\nprec", !0);
y(v, A, D, "⋠", "\\npreceq", !0);
y(v, A, D, "⋨", "\\precnsim", !0);
y(v, A, D, "⪹", "\\precnapprox", !0);
y(v, A, D, "≁", "\\nsim", !0);
y(v, A, D, "", "\\@nshortmid");
y(v, A, D, "∤", "\\nmid", !0);
y(v, A, D, "⊬", "\\nvdash", !0);
y(v, A, D, "⊭", "\\nvDash", !0);
y(v, A, D, "⋪", "\\ntriangleleft");
y(v, A, D, "⋬", "\\ntrianglelefteq", !0);
y(v, A, D, "⊊", "\\subsetneq", !0);
y(v, A, D, "", "\\@varsubsetneq");
y(v, A, D, "⫋", "\\subsetneqq", !0);
y(v, A, D, "", "\\@varsubsetneqq");
y(v, A, D, "≯", "\\ngtr", !0);
y(v, A, D, "", "\\@ngeqslant");
y(v, A, D, "", "\\@ngeqq");
y(v, A, D, "⪈", "\\gneq", !0);
y(v, A, D, "≩", "\\gneqq", !0);
y(v, A, D, "", "\\@gvertneqq");
y(v, A, D, "⋧", "\\gnsim", !0);
y(v, A, D, "⪊", "\\gnapprox", !0);
y(v, A, D, "⊁", "\\nsucc", !0);
y(v, A, D, "⋡", "\\nsucceq", !0);
y(v, A, D, "⋩", "\\succnsim", !0);
y(v, A, D, "⪺", "\\succnapprox", !0);
y(v, A, D, "≆", "\\ncong", !0);
y(v, A, D, "", "\\@nshortparallel");
y(v, A, D, "∦", "\\nparallel", !0);
y(v, A, D, "⊯", "\\nVDash", !0);
y(v, A, D, "⋫", "\\ntriangleright");
y(v, A, D, "⋭", "\\ntrianglerighteq", !0);
y(v, A, D, "", "\\@nsupseteqq");
y(v, A, D, "⊋", "\\supsetneq", !0);
y(v, A, D, "", "\\@varsupsetneq");
y(v, A, D, "⫌", "\\supsetneqq", !0);
y(v, A, D, "", "\\@varsupsetneqq");
y(v, A, D, "⊮", "\\nVdash", !0);
y(v, A, D, "⪵", "\\precneqq", !0);
y(v, A, D, "⪶", "\\succneqq", !0);
y(v, A, D, "", "\\@nsubseteqq");
y(v, A, ke, "⊴", "\\unlhd");
y(v, A, ke, "⊵", "\\unrhd");
y(v, A, D, "↚", "\\nleftarrow", !0);
y(v, A, D, "↛", "\\nrightarrow", !0);
y(v, A, D, "⇍", "\\nLeftarrow", !0);
y(v, A, D, "⇏", "\\nRightarrow", !0);
y(v, A, D, "↮", "\\nleftrightarrow", !0);
y(v, A, D, "⇎", "\\nLeftrightarrow", !0);
y(v, A, D, "△", "\\vartriangle");
y(v, A, _, "ℏ", "\\hslash");
y(v, A, _, "▽", "\\triangledown");
y(v, A, _, "◊", "\\lozenge");
y(v, A, _, "Ⓢ", "\\circledS");
y(v, A, _, "®", "\\circledR");
y(ee, A, _, "®", "\\circledR");
y(v, A, _, "∡", "\\measuredangle", !0);
y(v, A, _, "∄", "\\nexists");
y(v, A, _, "℧", "\\mho");
y(v, A, _, "Ⅎ", "\\Finv", !0);
y(v, A, _, "⅁", "\\Game", !0);
y(v, A, _, "‵", "\\backprime");
y(v, A, _, "▲", "\\blacktriangle");
y(v, A, _, "▼", "\\blacktriangledown");
y(v, A, _, "■", "\\blacksquare");
y(v, A, _, "⧫", "\\blacklozenge");
y(v, A, _, "★", "\\bigstar");
y(v, A, _, "∢", "\\sphericalangle", !0);
y(v, A, _, "∁", "\\complement", !0);
y(v, A, _, "ð", "\\eth", !0);
y(ee, x, _, "ð", "ð");
y(v, A, _, "╱", "\\diagup");
y(v, A, _, "╲", "\\diagdown");
y(v, A, _, "□", "\\square");
y(v, A, _, "□", "\\Box");
y(v, A, _, "◊", "\\Diamond");
y(v, A, _, "¥", "\\yen", !0);
y(ee, A, _, "¥", "\\yen", !0);
y(v, A, _, "✓", "\\checkmark", !0);
y(ee, A, _, "✓", "\\checkmark");
y(v, A, _, "ℶ", "\\beth", !0);
y(v, A, _, "ℸ", "\\daleth", !0);
y(v, A, _, "ℷ", "\\gimel", !0);
y(v, A, _, "ϝ", "\\digamma", !0);
y(v, A, _, "ϰ", "\\varkappa");
y(v, A, ti, "┌", "\\@ulcorner", !0);
y(v, A, br, "┐", "\\@urcorner", !0);
y(v, A, ti, "└", "\\@llcorner", !0);
y(v, A, br, "┘", "\\@lrcorner", !0);
y(v, A, D, "≦", "\\leqq", !0);
y(v, A, D, "⩽", "\\leqslant", !0);
y(v, A, D, "⪕", "\\eqslantless", !0);
y(v, A, D, "≲", "\\lesssim", !0);
y(v, A, D, "⪅", "\\lessapprox", !0);
y(v, A, D, "≊", "\\approxeq", !0);
y(v, A, ke, "⋖", "\\lessdot");
y(v, A, D, "⋘", "\\lll", !0);
y(v, A, D, "≶", "\\lessgtr", !0);
y(v, A, D, "⋚", "\\lesseqgtr", !0);
y(v, A, D, "⪋", "\\lesseqqgtr", !0);
y(v, A, D, "≑", "\\doteqdot");
y(v, A, D, "≓", "\\risingdotseq", !0);
y(v, A, D, "≒", "\\fallingdotseq", !0);
y(v, A, D, "∽", "\\backsim", !0);
y(v, A, D, "⋍", "\\backsimeq", !0);
y(v, A, D, "⫅", "\\subseteqq", !0);
y(v, A, D, "⋐", "\\Subset", !0);
y(v, A, D, "⊏", "\\sqsubset", !0);
y(v, A, D, "≼", "\\preccurlyeq", !0);
y(v, A, D, "⋞", "\\curlyeqprec", !0);
y(v, A, D, "≾", "\\precsim", !0);
y(v, A, D, "⪷", "\\precapprox", !0);
y(v, A, D, "⊲", "\\vartriangleleft");
y(v, A, D, "⊴", "\\trianglelefteq");
y(v, A, D, "⊨", "\\vDash", !0);
y(v, A, D, "⊪", "\\Vvdash", !0);
y(v, A, D, "⌣", "\\smallsmile");
y(v, A, D, "⌢", "\\smallfrown");
y(v, A, D, "≏", "\\bumpeq", !0);
y(v, A, D, "≎", "\\Bumpeq", !0);
y(v, A, D, "≧", "\\geqq", !0);
y(v, A, D, "⩾", "\\geqslant", !0);
y(v, A, D, "⪖", "\\eqslantgtr", !0);
y(v, A, D, "≳", "\\gtrsim", !0);
y(v, A, D, "⪆", "\\gtrapprox", !0);
y(v, A, ke, "⋗", "\\gtrdot");
y(v, A, D, "⋙", "\\ggg", !0);
y(v, A, D, "≷", "\\gtrless", !0);
y(v, A, D, "⋛", "\\gtreqless", !0);
y(v, A, D, "⪌", "\\gtreqqless", !0);
y(v, A, D, "≖", "\\eqcirc", !0);
y(v, A, D, "≗", "\\circeq", !0);
y(v, A, D, "≜", "\\triangleq", !0);
y(v, A, D, "∼", "\\thicksim");
y(v, A, D, "≈", "\\thickapprox");
y(v, A, D, "⫆", "\\supseteqq", !0);
y(v, A, D, "⋑", "\\Supset", !0);
y(v, A, D, "⊐", "\\sqsupset", !0);
y(v, A, D, "≽", "\\succcurlyeq", !0);
y(v, A, D, "⋟", "\\curlyeqsucc", !0);
y(v, A, D, "≿", "\\succsim", !0);
y(v, A, D, "⪸", "\\succapprox", !0);
y(v, A, D, "⊳", "\\vartriangleright");
y(v, A, D, "⊵", "\\trianglerighteq");
y(v, A, D, "⊩", "\\Vdash", !0);
y(v, A, D, "∣", "\\shortmid");
y(v, A, D, "∥", "\\shortparallel");
y(v, A, D, "≬", "\\between", !0);
y(v, A, D, "⋔", "\\pitchfork", !0);
y(v, A, D, "∝", "\\varpropto");
y(v, A, D, "◀", "\\blacktriangleleft");
y(v, A, D, "∴", "\\therefore", !0);
y(v, A, D, "∍", "\\backepsilon");
y(v, A, D, "▶", "\\blacktriangleright");
y(v, A, D, "∵", "\\because", !0);
y(v, A, D, "⋘", "\\llless");
y(v, A, D, "⋙", "\\gggtr");
y(v, A, ke, "⊲", "\\lhd");
y(v, A, ke, "⊳", "\\rhd");
y(v, A, D, "≂", "\\eqsim", !0);
y(v, x, D, "⋈", "\\Join");
y(v, A, D, "≑", "\\Doteq", !0);
y(v, A, ke, "∔", "\\dotplus", !0);
y(v, A, ke, "∖", "\\smallsetminus");
y(v, A, ke, "⋒", "\\Cap", !0);
y(v, A, ke, "⋓", "\\Cup", !0);
y(v, A, ke, "⩞", "\\doublebarwedge", !0);
y(v, A, ke, "⊟", "\\boxminus", !0);
y(v, A, ke, "⊞", "\\boxplus", !0);
y(v, A, ke, "⋇", "\\divideontimes", !0);
y(v, A, ke, "⋉", "\\ltimes", !0);
y(v, A, ke, "⋊", "\\rtimes", !0);
y(v, A, ke, "⋋", "\\leftthreetimes", !0);
y(v, A, ke, "⋌", "\\rightthreetimes", !0);
y(v, A, ke, "⋏", "\\curlywedge", !0);
y(v, A, ke, "⋎", "\\curlyvee", !0);
y(v, A, ke, "⊝", "\\circleddash", !0);
y(v, A, ke, "⊛", "\\circledast", !0);
y(v, A, ke, "⋅", "\\centerdot");
y(v, A, ke, "⊺", "\\intercal", !0);
y(v, A, ke, "⋒", "\\doublecap");
y(v, A, ke, "⋓", "\\doublecup");
y(v, A, ke, "⊠", "\\boxtimes", !0);
y(v, A, D, "⇢", "\\dashrightarrow", !0);
y(v, A, D, "⇠", "\\dashleftarrow", !0);
y(v, A, D, "⇇", "\\leftleftarrows", !0);
y(v, A, D, "⇆", "\\leftrightarrows", !0);
y(v, A, D, "⇚", "\\Lleftarrow", !0);
y(v, A, D, "↞", "\\twoheadleftarrow", !0);
y(v, A, D, "↢", "\\leftarrowtail", !0);
y(v, A, D, "↫", "\\looparrowleft", !0);
y(v, A, D, "⇋", "\\leftrightharpoons", !0);
y(v, A, D, "↶", "\\curvearrowleft", !0);
y(v, A, D, "↺", "\\circlearrowleft", !0);
y(v, A, D, "↰", "\\Lsh", !0);
y(v, A, D, "⇈", "\\upuparrows", !0);
y(v, A, D, "↿", "\\upharpoonleft", !0);
y(v, A, D, "⇃", "\\downharpoonleft", !0);
y(v, x, D, "⊶", "\\origof", !0);
y(v, x, D, "⊷", "\\imageof", !0);
y(v, A, D, "⊸", "\\multimap", !0);
y(v, A, D, "↭", "\\leftrightsquigarrow", !0);
y(v, A, D, "⇉", "\\rightrightarrows", !0);
y(v, A, D, "⇄", "\\rightleftarrows", !0);
y(v, A, D, "↠", "\\twoheadrightarrow", !0);
y(v, A, D, "↣", "\\rightarrowtail", !0);
y(v, A, D, "↬", "\\looparrowright", !0);
y(v, A, D, "↷", "\\curvearrowright", !0);
y(v, A, D, "↻", "\\circlearrowright", !0);
y(v, A, D, "↱", "\\Rsh", !0);
y(v, A, D, "⇊", "\\downdownarrows", !0);
y(v, A, D, "↾", "\\upharpoonright", !0);
y(v, A, D, "⇂", "\\downharpoonright", !0);
y(v, A, D, "⇝", "\\rightsquigarrow", !0);
y(v, A, D, "⇝", "\\leadsto");
y(v, A, D, "⇛", "\\Rrightarrow", !0);
y(v, A, D, "↾", "\\restriction");
y(v, x, _, "‘", "`");
y(v, x, _, "$", "\\$");
y(ee, x, _, "$", "\\$");
y(ee, x, _, "$", "\\textdollar");
y(v, x, _, "%", "\\%");
y(ee, x, _, "%", "\\%");
y(v, x, _, "_", "\\_");
y(ee, x, _, "_", "\\_");
y(ee, x, _, "_", "\\textunderscore");
y(v, x, _, "∠", "\\angle", !0);
y(v, x, _, "∞", "\\infty", !0);
y(v, x, _, "′", "\\prime");
y(v, x, _, "△", "\\triangle");
y(v, x, _, "Γ", "\\Gamma", !0);
y(v, x, _, "Δ", "\\Delta", !0);
y(v, x, _, "Θ", "\\Theta", !0);
y(v, x, _, "Λ", "\\Lambda", !0);
y(v, x, _, "Ξ", "\\Xi", !0);
y(v, x, _, "Π", "\\Pi", !0);
y(v, x, _, "Σ", "\\Sigma", !0);
y(v, x, _, "Υ", "\\Upsilon", !0);
y(v, x, _, "Φ", "\\Phi", !0);
y(v, x, _, "Ψ", "\\Psi", !0);
y(v, x, _, "Ω", "\\Omega", !0);
y(v, x, _, "A", "Α");
y(v, x, _, "B", "Β");
y(v, x, _, "E", "Ε");
y(v, x, _, "Z", "Ζ");
y(v, x, _, "H", "Η");
y(v, x, _, "I", "Ι");
y(v, x, _, "K", "Κ");
y(v, x, _, "M", "Μ");
y(v, x, _, "N", "Ν");
y(v, x, _, "O", "Ο");
y(v, x, _, "P", "Ρ");
y(v, x, _, "T", "Τ");
y(v, x, _, "X", "Χ");
y(v, x, _, "¬", "\\neg", !0);
y(v, x, _, "¬", "\\lnot");
y(v, x, _, "⊤", "\\top");
y(v, x, _, "⊥", "\\bot");
y(v, x, _, "∅", "\\emptyset");
y(v, A, _, "∅", "\\varnothing");
y(v, x, qe, "α", "\\alpha", !0);
y(v, x, qe, "β", "\\beta", !0);
y(v, x, qe, "γ", "\\gamma", !0);
y(v, x, qe, "δ", "\\delta", !0);
y(v, x, qe, "ϵ", "\\epsilon", !0);
y(v, x, qe, "ζ", "\\zeta", !0);
y(v, x, qe, "η", "\\eta", !0);
y(v, x, qe, "θ", "\\theta", !0);
y(v, x, qe, "ι", "\\iota", !0);
y(v, x, qe, "κ", "\\kappa", !0);
y(v, x, qe, "λ", "\\lambda", !0);
y(v, x, qe, "μ", "\\mu", !0);
y(v, x, qe, "ν", "\\nu", !0);
y(v, x, qe, "ξ", "\\xi", !0);
y(v, x, qe, "ο", "\\omicron", !0);
y(v, x, qe, "π", "\\pi", !0);
y(v, x, qe, "ρ", "\\rho", !0);
y(v, x, qe, "σ", "\\sigma", !0);
y(v, x, qe, "τ", "\\tau", !0);
y(v, x, qe, "υ", "\\upsilon", !0);
y(v, x, qe, "ϕ", "\\phi", !0);
y(v, x, qe, "χ", "\\chi", !0);
y(v, x, qe, "ψ", "\\psi", !0);
y(v, x, qe, "ω", "\\omega", !0);
y(v, x, qe, "ε", "\\varepsilon", !0);
y(v, x, qe, "ϑ", "\\vartheta", !0);
y(v, x, qe, "ϖ", "\\varpi", !0);
y(v, x, qe, "ϱ", "\\varrho", !0);
y(v, x, qe, "ς", "\\varsigma", !0);
y(v, x, qe, "φ", "\\varphi", !0);
y(v, x, ke, "∗", "*", !0);
y(v, x, ke, "+", "+");
y(v, x, ke, "−", "-", !0);
y(v, x, ke, "⋅", "\\cdot", !0);
y(v, x, ke, "∘", "\\circ", !0);
y(v, x, ke, "÷", "\\div", !0);
y(v, x, ke, "±", "\\pm", !0);
y(v, x, ke, "×", "\\times", !0);
y(v, x, ke, "∩", "\\cap", !0);
y(v, x, ke, "∪", "\\cup", !0);
y(v, x, ke, "∖", "\\setminus", !0);
y(v, x, ke, "∧", "\\land");
y(v, x, ke, "∨", "\\lor");
y(v, x, ke, "∧", "\\wedge", !0);
y(v, x, ke, "∨", "\\vee", !0);
y(v, x, _, "√", "\\surd");
y(v, x, ti, "⟨", "\\langle", !0);
y(v, x, ti, "∣", "\\lvert");
y(v, x, ti, "∥", "\\lVert");
y(v, x, br, "?", "?");
y(v, x, br, "!", "!");
y(v, x, br, "⟩", "\\rangle", !0);
y(v, x, br, "∣", "\\rvert");
y(v, x, br, "∥", "\\rVert");
y(v, x, D, "=", "=");
y(v, x, D, ":", ":");
y(v, x, D, "≈", "\\approx", !0);
y(v, x, D, "≅", "\\cong", !0);
y(v, x, D, "≥", "\\ge");
y(v, x, D, "≥", "\\geq", !0);
y(v, x, D, "←", "\\gets");
y(v, x, D, ">", "\\gt", !0);
y(v, x, D, "∈", "\\in", !0);
y(v, x, D, "", "\\@not");
y(v, x, D, "⊂", "\\subset", !0);
y(v, x, D, "⊃", "\\supset", !0);
y(v, x, D, "⊆", "\\subseteq", !0);
y(v, x, D, "⊇", "\\supseteq", !0);
y(v, A, D, "⊈", "\\nsubseteq", !0);
y(v, A, D, "⊉", "\\nsupseteq", !0);
y(v, x, D, "⊨", "\\models");
y(v, x, D, "←", "\\leftarrow", !0);
y(v, x, D, "≤", "\\le");
y(v, x, D, "≤", "\\leq", !0);
y(v, x, D, "<", "\\lt", !0);
y(v, x, D, "→", "\\rightarrow", !0);
y(v, x, D, "→", "\\to");
y(v, A, D, "≱", "\\ngeq", !0);
y(v, A, D, "≰", "\\nleq", !0);
y(v, x, Mo, " ", "\\ ");
y(v, x, Mo, " ", "\\space");
y(v, x, Mo, " ", "\\nobreakspace");
y(ee, x, Mo, " ", "\\ ");
y(ee, x, Mo, " ", " ");
y(ee, x, Mo, " ", "\\space");
y(ee, x, Mo, " ", "\\nobreakspace");
y(v, x, Mo, null, "\\nobreak");
y(v, x, Mo, null, "\\allowbreak");
y(v, x, ag, ",", ",");
y(v, x, ag, ";", ";");
y(v, A, ke, "⊼", "\\barwedge", !0);
y(v, A, ke, "⊻", "\\veebar", !0);
y(v, x, ke, "⊙", "\\odot", !0);
y(v, x, ke, "⊕", "\\oplus", !0);
y(v, x, ke, "⊗", "\\otimes", !0);
y(v, x, _, "∂", "\\partial", !0);
y(v, x, ke, "⊘", "\\oslash", !0);
y(v, A, ke, "⊚", "\\circledcirc", !0);
y(v, A, ke, "⊡", "\\boxdot", !0);
y(v, x, ke, "△", "\\bigtriangleup");
y(v, x, ke, "▽", "\\bigtriangledown");
y(v, x, ke, "†", "\\dagger");
y(v, x, ke, "⋄", "\\diamond");
y(v, x, ke, "⋆", "\\star");
y(v, x, ke, "◃", "\\triangleleft");
y(v, x, ke, "▹", "\\triangleright");
y(v, x, ti, "{", "\\{");
y(ee, x, _, "{", "\\{");
y(ee, x, _, "{", "\\textbraceleft");
y(v, x, br, "}", "\\}");
y(ee, x, _, "}", "\\}");
y(ee, x, _, "}", "\\textbraceright");
y(v, x, ti, "{", "\\lbrace");
y(v, x, br, "}", "\\rbrace");
y(v, x, ti, "[", "\\lbrack", !0);
y(ee, x, _, "[", "\\lbrack", !0);
y(v, x, br, "]", "\\rbrack", !0);
y(ee, x, _, "]", "\\rbrack", !0);
y(v, x, ti, "(", "\\lparen", !0);
y(v, x, br, ")", "\\rparen", !0);
y(ee, x, _, "<", "\\textless", !0);
y(ee, x, _, ">", "\\textgreater", !0);
y(v, x, ti, "⌊", "\\lfloor", !0);
y(v, x, br, "⌋", "\\rfloor", !0);
y(v, x, ti, "⌈", "\\lceil", !0);
y(v, x, br, "⌉", "\\rceil", !0);
y(v, x, _, "\\", "\\backslash");
y(v, x, _, "∣", "|");
y(v, x, _, "∣", "\\vert");
y(ee, x, _, "|", "\\textbar", !0);
y(v, x, _, "∥", "\\|");
y(v, x, _, "∥", "\\Vert");
y(ee, x, _, "∥", "\\textbardbl");
y(ee, x, _, "~", "\\textasciitilde");
y(ee, x, _, "\\", "\\textbackslash");
y(ee, x, _, "^", "\\textasciicircum");
y(v, x, D, "↑", "\\uparrow", !0);
y(v, x, D, "⇑", "\\Uparrow", !0);
y(v, x, D, "↓", "\\downarrow", !0);
y(v, x, D, "⇓", "\\Downarrow", !0);
y(v, x, D, "↕", "\\updownarrow", !0);
y(v, x, D, "⇕", "\\Updownarrow", !0);
y(v, x, yn, "∐", "\\coprod");
y(v, x, yn, "⋁", "\\bigvee");
y(v, x, yn, "⋀", "\\bigwedge");
y(v, x, yn, "⨄", "\\biguplus");
y(v, x, yn, "⋂", "\\bigcap");
y(v, x, yn, "⋃", "\\bigcup");
y(v, x, yn, "∫", "\\int");
y(v, x, yn, "∫", "\\intop");
y(v, x, yn, "∬", "\\iint");
y(v, x, yn, "∭", "\\iiint");
y(v, x, yn, "∏", "\\prod");
y(v, x, yn, "∑", "\\sum");
y(v, x, yn, "⨂", "\\bigotimes");
y(v, x, yn, "⨁", "\\bigoplus");
y(v, x, yn, "⨀", "\\bigodot");
y(v, x, yn, "∮", "\\oint");
y(v, x, yn, "∯", "\\oiint");
y(v, x, yn, "∰", "\\oiiint");
y(v, x, yn, "⨆", "\\bigsqcup");
y(v, x, yn, "∫", "\\smallint");
y(ee, x, mu, "…", "\\textellipsis");
y(v, x, mu, "…", "\\mathellipsis");
y(ee, x, mu, "…", "\\ldots", !0);
y(v, x, mu, "…", "\\ldots", !0);
y(v, x, mu, "⋯", "\\@cdots", !0);
y(v, x, mu, "⋱", "\\ddots", !0);
y(v, x, _, "⋮", "\\varvdots");
y(ee, x, _, "⋮", "\\varvdots");
y(v, x, Kt, "ˊ", "\\acute");
y(v, x, Kt, "ˋ", "\\grave");
y(v, x, Kt, "¨", "\\ddot");
y(v, x, Kt, "~", "\\tilde");
y(v, x, Kt, "ˉ", "\\bar");
y(v, x, Kt, "˘", "\\breve");
y(v, x, Kt, "ˇ", "\\check");
y(v, x, Kt, "^", "\\hat");
y(v, x, Kt, "⃗", "\\vec");
y(v, x, Kt, "˙", "\\dot");
y(v, x, Kt, "˚", "\\mathring");
y(v, x, qe, "", "\\@imath");
y(v, x, qe, "", "\\@jmath");
y(v, x, _, "ı", "ı");
y(v, x, _, "ȷ", "ȷ");
y(ee, x, _, "ı", "\\i", !0);
y(ee, x, _, "ȷ", "\\j", !0);
y(ee, x, _, "ß", "\\ss", !0);
y(ee, x, _, "æ", "\\ae", !0);
y(ee, x, _, "œ", "\\oe", !0);
y(ee, x, _, "ø", "\\o", !0);
y(ee, x, _, "Æ", "\\AE", !0);
y(ee, x, _, "Œ", "\\OE", !0);
y(ee, x, _, "Ø", "\\O", !0);
y(ee, x, Kt, "ˊ", "\\'");
y(ee, x, Kt, "ˋ", "\\`");
y(ee, x, Kt, "ˆ", "\\^");
y(ee, x, Kt, "˜", "\\~");
y(ee, x, Kt, "ˉ", "\\=");
y(ee, x, Kt, "˘", "\\u");
y(ee, x, Kt, "˙", "\\.");
y(ee, x, Kt, "¸", "\\c");
y(ee, x, Kt, "˚", "\\r");
y(ee, x, Kt, "ˇ", "\\v");
y(ee, x, Kt, "¨", '\\"');
y(ee, x, Kt, "˝", "\\H");
y(ee, x, Kt, "◯", "\\textcircled");
var VD = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
y(ee, x, _, "–", "--", !0);
y(ee, x, _, "–", "\\textendash");
y(ee, x, _, "—", "---", !0);
y(ee, x, _, "—", "\\textemdash");
y(ee, x, _, "‘", "`", !0);
y(ee, x, _, "‘", "\\textquoteleft");
y(ee, x, _, "’", "'", !0);
y(ee, x, _, "’", "\\textquoteright");
y(ee, x, _, "“", "``", !0);
y(ee, x, _, "“", "\\textquotedblleft");
y(ee, x, _, "”", "''", !0);
y(ee, x, _, "”", "\\textquotedblright");
y(v, x, _, "°", "\\degree", !0);
y(ee, x, _, "°", "\\degree");
y(ee, x, _, "°", "\\textdegree", !0);
y(v, x, _, "£", "\\pounds");
y(v, x, _, "£", "\\mathsterling", !0);
y(ee, x, _, "£", "\\pounds");
y(ee, x, _, "£", "\\textsterling", !0);
y(v, A, _, "✠", "\\maltese");
y(ee, A, _, "✠", "\\maltese");
var h9 = '0123456789/@."';
for (var s4 = 0; s4 < h9.length; s4++) {
  var f9 = h9.charAt(s4);
  y(v, x, _, f9, f9);
}
var d9 = '0123456789!@*()-=+";:?/.,';
for (var o4 = 0; o4 < d9.length; o4++) {
  var p9 = d9.charAt(o4);
  y(ee, x, _, p9, p9);
}
var jm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var l4 = 0; l4 < jm.length; l4++) {
  var D0 = jm.charAt(l4);
  y(v, x, qe, D0, D0), y(ee, x, _, D0, D0);
}
y(v, A, _, "C", "ℂ");
y(ee, A, _, "C", "ℂ");
y(v, A, _, "H", "ℍ");
y(ee, A, _, "H", "ℍ");
y(v, A, _, "N", "ℕ");
y(ee, A, _, "N", "ℕ");
y(v, A, _, "P", "ℙ");
y(ee, A, _, "P", "ℙ");
y(v, A, _, "Q", "ℚ");
y(ee, A, _, "Q", "ℚ");
y(v, A, _, "R", "ℝ");
y(ee, A, _, "R", "ℝ");
y(v, A, _, "Z", "ℤ");
y(ee, A, _, "Z", "ℤ");
y(v, x, qe, "h", "ℎ");
y(ee, x, qe, "h", "ℎ");
var Ke = "";
for (var nr = 0; nr < jm.length; nr++) {
  var nn = jm.charAt(nr);
  Ke = String.fromCharCode(55349, 56320 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56372 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56424 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56580 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56684 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56736 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56788 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56840 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56944 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), nr < 26 && (Ke = String.fromCharCode(55349, 56632 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke), Ke = String.fromCharCode(55349, 56476 + nr), y(v, x, qe, nn, Ke), y(ee, x, _, nn, Ke));
}
Ke = "𝕜";
y(v, x, qe, "k", Ke);
y(ee, x, _, "k", Ke);
for (var Ll = 0; Ll < 10; Ll++) {
  var Do = Ll.toString();
  Ke = String.fromCharCode(55349, 57294 + Ll), y(v, x, qe, Do, Ke), y(ee, x, _, Do, Ke), Ke = String.fromCharCode(55349, 57314 + Ll), y(v, x, qe, Do, Ke), y(ee, x, _, Do, Ke), Ke = String.fromCharCode(55349, 57324 + Ll), y(v, x, qe, Do, Ke), y(ee, x, _, Do, Ke), Ke = String.fromCharCode(55349, 57334 + Ll), y(v, x, qe, Do, Ke), y(ee, x, _, Do, Ke);
}
var _5 = "ÐÞþ";
for (var a4 = 0; a4 < _5.length; a4++) {
  var N0 = _5.charAt(a4);
  y(v, x, qe, N0, N0), y(ee, x, _, N0, N0);
}
var R0 = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], m9 = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], xoe = function(e, t) {
  var r = e.charCodeAt(0), i = e.charCodeAt(1), s = (r - 55296) * 1024 + (i - 56320) + 65536, o = t === "math" ? 0 : 1;
  if (119808 <= s && s < 120484) {
    var l = Math.floor((s - 119808) / 26);
    return [R0[l][2], R0[l][o]];
  } else if (120782 <= s && s <= 120831) {
    var a = Math.floor((s - 120782) / 10);
    return [m9[a][2], m9[a][o]];
  } else {
    if (s === 120485 || s === 120486)
      return [R0[0][2], R0[0][o]];
    if (120486 < s && s < 120782)
      return ["", ""];
    throw new se("Unsupported character: " + e);
  }
}, cg = function(e, t, r) {
  return zt[r][e] && zt[r][e].replace && (e = zt[r][e].replace), {
    value: e,
    metrics: f7(e, t, r)
  };
}, Ei = function(e, t, r, i, s) {
  var o = cg(e, t, r), l = o.metrics;
  e = o.value;
  var a;
  if (l) {
    var c = l.italic;
    (r === "text" || i && i.font === "mathit") && (c = 0), a = new xi(e, l.height, l.depth, c, l.skew, l.width, s);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + e + "' in style '" + t + "' and mode '" + r + "'")), a = new xi(e, 0, 0, 0, 0, 0, s);
  if (i) {
    a.maxFontSize = i.sizeMultiplier, i.style.isTight() && a.classes.push("mtight");
    var u = i.getColor();
    u && (a.style.color = u);
  }
  return a;
}, koe = function(e, t, r, i) {
  return i === void 0 && (i = []), r.font === "boldsymbol" && cg(e, "Main-Bold", t).metrics ? Ei(e, "Main-Bold", t, r, i.concat(["mathbf"])) : e === "\\" || zt[t][e].font === "main" ? Ei(e, "Main-Regular", t, r, i) : Ei(e, "AMS-Regular", t, r, i.concat(["amsrm"]));
}, Soe = function(e, t, r, i, s) {
  return s !== "textord" && cg(e, "Math-BoldItalic", t).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, Coe = function(e, t, r) {
  var i = e.mode, s = e.text, o = ["mord"], l = i === "math" || i === "text" && t.font, a = l ? t.font : t.fontFamily, c = "", u = "";
  if (s.charCodeAt(0) === 55349 && ([c, u] = xoe(s, i)), c.length > 0)
    return Ei(s, c, i, t, o.concat(u));
  if (a) {
    var h, f;
    if (a === "boldsymbol") {
      var d = Soe(s, i, t, o, r);
      h = d.fontName, f = [d.fontClass];
    } else l ? (h = jD[a].fontName, f = [a]) : (h = P0(a, t.fontWeight, t.fontShape), f = [a, t.fontWeight, t.fontShape]);
    if (cg(s, h, i).metrics)
      return Ei(s, h, i, t, o.concat(f));
    if (VD.hasOwnProperty(s) && h.slice(0, 10) === "Typewriter") {
      for (var p = [], m = 0; m < s.length; m++)
        p.push(Ei(s[m], h, i, t, o.concat(f)));
      return WD(p);
    }
  }
  if (r === "mathord")
    return Ei(s, "Math-Italic", i, t, o.concat(["mathnormal"]));
  if (r === "textord") {
    var g = zt[i][s] && zt[i][s].font;
    if (g === "ams") {
      var b = P0("amsrm", t.fontWeight, t.fontShape);
      return Ei(s, b, i, t, o.concat("amsrm", t.fontWeight, t.fontShape));
    } else if (g === "main" || !g) {
      var w = P0("textrm", t.fontWeight, t.fontShape);
      return Ei(s, w, i, t, o.concat(t.fontWeight, t.fontShape));
    } else {
      var k = P0(g, t.fontWeight, t.fontShape);
      return Ei(s, k, i, t, o.concat(k, t.fontWeight, t.fontShape));
    }
  } else
    throw new Error("unexpected type: " + r + " in makeOrd");
}, Moe = (n, e) => {
  if (yl(n.classes) !== yl(e.classes) || n.skew !== e.skew || n.maxFontSize !== e.maxFontSize)
    return !1;
  if (n.classes.length === 1) {
    var t = n.classes[0];
    if (t === "mbin" || t === "mord")
      return !1;
  }
  for (var r in n.style)
    if (n.style.hasOwnProperty(r) && n.style[r] !== e.style[r])
      return !1;
  for (var i in e.style)
    if (e.style.hasOwnProperty(i) && n.style[i] !== e.style[i])
      return !1;
  return !0;
}, Toe = (n) => {
  for (var e = 0; e < n.length - 1; e++) {
    var t = n[e], r = n[e + 1];
    t instanceof xi && r instanceof xi && Moe(t, r) && (t.text += r.text, t.height = Math.max(t.height, r.height), t.depth = Math.max(t.depth, r.depth), t.italic = r.italic, n.splice(e + 1, 1), e--);
  }
  return n;
}, p7 = function(e) {
  for (var t = 0, r = 0, i = 0, s = 0; s < e.children.length; s++) {
    var o = e.children[s];
    o.height > t && (t = o.height), o.depth > r && (r = o.depth), o.maxFontSize > i && (i = o.maxFontSize);
  }
  e.height = t, e.depth = r, e.maxFontSize = i;
}, xr = function(e, t, r, i) {
  var s = new Ld(e, t, r, i);
  return p7(s), s;
}, qD = (n, e, t, r) => new Ld(n, e, t, r), Aoe = function(e, t, r) {
  var i = xr([e], [], t);
  return i.height = Math.max(r || t.fontMetrics().defaultRuleThickness, t.minRuleThickness), i.style.borderBottomWidth = fe(i.height), i.maxFontSize = 1, i;
}, Ooe = function(e, t, r, i) {
  var s = new d7(e, t, r, i);
  return p7(s), s;
}, WD = function(e) {
  var t = new _d(e);
  return p7(t), t;
}, Eoe = function(e, t) {
  return e instanceof _d ? xr([], [e], t) : e;
}, Ioe = function(e) {
  if (e.positionType === "individualShift") {
    for (var t = e.children, r = [t[0]], i = -t[0].shift - t[0].elem.depth, s = i, o = 1; o < t.length; o++) {
      var l = -t[o].shift - s - t[o].elem.depth, a = l - (t[o - 1].elem.height + t[o - 1].elem.depth);
      s = s + l, r.push({
        type: "kern",
        size: a
      }), r.push(t[o]);
    }
    return {
      children: r,
      depth: i
    };
  }
  var c;
  if (e.positionType === "top") {
    for (var u = e.positionData, h = 0; h < e.children.length; h++) {
      var f = e.children[h];
      u -= f.type === "kern" ? f.size : f.elem.height + f.elem.depth;
    }
    c = u;
  } else if (e.positionType === "bottom")
    c = -e.positionData;
  else {
    var d = e.children[0];
    if (d.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (e.positionType === "shift")
      c = -d.elem.depth - e.positionData;
    else if (e.positionType === "firstBaseline")
      c = -d.elem.depth;
    else
      throw new Error("Invalid positionType " + e.positionType + ".");
  }
  return {
    children: e.children,
    depth: c
  };
}, Doe = function(e, t) {
  for (var {
    children: r,
    depth: i
  } = Ioe(e), s = 0, o = 0; o < r.length; o++) {
    var l = r[o];
    if (l.type === "elem") {
      var a = l.elem;
      s = Math.max(s, a.maxFontSize, a.height);
    }
  }
  s += 2;
  var c = xr(["pstrut"], []);
  c.style.height = fe(s);
  for (var u = [], h = i, f = i, d = i, p = 0; p < r.length; p++) {
    var m = r[p];
    if (m.type === "kern")
      d += m.size;
    else {
      var g = m.elem, b = m.wrapperClasses || [], w = m.wrapperStyle || {}, k = xr(b, [c, g], void 0, w);
      k.style.top = fe(-s - d - g.depth), m.marginLeft && (k.style.marginLeft = m.marginLeft), m.marginRight && (k.style.marginRight = m.marginRight), u.push(k), d += g.height + g.depth;
    }
    h = Math.min(h, d), f = Math.max(f, d);
  }
  var C = xr(["vlist"], u);
  C.style.height = fe(f);
  var M;
  if (h < 0) {
    var T = xr([], []), N = xr(["vlist"], [T]);
    N.style.height = fe(-h);
    var B = xr(["vlist-s"], [new xi("​")]);
    M = [xr(["vlist-r"], [C, B]), xr(["vlist-r"], [N])];
  } else
    M = [xr(["vlist-r"], [C])];
  var $ = xr(["vlist-t"], M);
  return M.length === 2 && $.classes.push("vlist-t2"), $.height = f, $.depth = -h, $;
}, Noe = (n, e) => {
  var t = xr(["mspace"], [], e), r = Qt(n, e);
  return t.style.marginRight = fe(r), t;
}, P0 = function(e, t, r) {
  var i = "";
  switch (e) {
    case "amsrm":
      i = "AMS";
      break;
    case "textrm":
      i = "Main";
      break;
    case "textsf":
      i = "SansSerif";
      break;
    case "texttt":
      i = "Typewriter";
      break;
    default:
      i = e;
  }
  var s;
  return t === "textbf" && r === "textit" ? s = "BoldItalic" : t === "textbf" ? s = "Bold" : t === "textit" ? s = "Italic" : s = "Regular", i + "-" + s;
}, jD = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  mathsfit: {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, UD = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, Roe = function(e, t) {
  var [r, i, s] = UD[e], o = new bl(r), l = new po([o], {
    width: fe(i),
    height: fe(s),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + fe(i),
    viewBox: "0 0 " + 1e3 * i + " " + 1e3 * s,
    preserveAspectRatio: "xMinYMin"
  }), a = qD(["overlay"], [l], t);
  return a.height = s, a.style.height = fe(s), a.style.width = fe(i), a;
}, H = {
  fontMap: jD,
  makeSymbol: Ei,
  mathsym: koe,
  makeSpan: xr,
  makeSvgSpan: qD,
  makeLineSpan: Aoe,
  makeAnchor: Ooe,
  makeFragment: WD,
  wrapFragment: Eoe,
  makeVList: Doe,
  makeOrd: Coe,
  makeGlue: Noe,
  staticSvg: Roe,
  svgData: UD,
  tryCombineChars: Toe
}, Xt = {
  number: 3,
  unit: "mu"
}, Bl = {
  number: 4,
  unit: "mu"
}, Fs = {
  number: 5,
  unit: "mu"
}, Poe = {
  mord: {
    mop: Xt,
    mbin: Bl,
    mrel: Fs,
    minner: Xt
  },
  mop: {
    mord: Xt,
    mop: Xt,
    mrel: Fs,
    minner: Xt
  },
  mbin: {
    mord: Bl,
    mop: Bl,
    mopen: Bl,
    minner: Bl
  },
  mrel: {
    mord: Fs,
    mop: Fs,
    mopen: Fs,
    minner: Fs
  },
  mopen: {},
  mclose: {
    mop: Xt,
    mbin: Bl,
    mrel: Fs,
    minner: Xt
  },
  mpunct: {
    mord: Xt,
    mop: Xt,
    mrel: Fs,
    mopen: Xt,
    mclose: Xt,
    mpunct: Xt,
    minner: Xt
  },
  minner: {
    mord: Xt,
    mop: Xt,
    mbin: Bl,
    mrel: Fs,
    mopen: Xt,
    mpunct: Xt,
    minner: Xt
  }
}, _oe = {
  mord: {
    mop: Xt
  },
  mop: {
    mord: Xt,
    mop: Xt
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: Xt
  },
  mpunct: {},
  minner: {
    mop: Xt
  }
}, KD = {}, Um = {}, Km = {};
function be(n) {
  for (var {
    type: e,
    names: t,
    props: r,
    handler: i,
    htmlBuilder: s,
    mathmlBuilder: o
  } = n, l = {
    type: e,
    numArgs: r.numArgs,
    argTypes: r.argTypes,
    allowedInArgument: !!r.allowedInArgument,
    allowedInText: !!r.allowedInText,
    allowedInMath: r.allowedInMath === void 0 ? !0 : r.allowedInMath,
    numOptionalArgs: r.numOptionalArgs || 0,
    infix: !!r.infix,
    primitive: !!r.primitive,
    handler: i
  }, a = 0; a < t.length; ++a)
    KD[t[a]] = l;
  e && (s && (Um[e] = s), o && (Km[e] = o));
}
function $a(n) {
  var {
    type: e,
    htmlBuilder: t,
    mathmlBuilder: r
  } = n;
  be({
    type: e,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: t,
    mathmlBuilder: r
  });
}
var Gm = function(e) {
  return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
}, cn = function(e) {
  return e.type === "ordgroup" ? e.body : [e];
}, mo = H.makeSpan, Loe = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], Boe = ["rightmost", "mrel", "mclose", "mpunct"], zoe = {
  display: We.DISPLAY,
  text: We.TEXT,
  script: We.SCRIPT,
  scriptscript: We.SCRIPTSCRIPT
}, Foe = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, xn = function(e, t, r, i) {
  i === void 0 && (i = [null, null]);
  for (var s = [], o = 0; o < e.length; o++) {
    var l = ht(e[o], t);
    if (l instanceof _d) {
      var a = l.children;
      s.push(...a);
    } else
      s.push(l);
  }
  if (H.tryCombineChars(s), !r)
    return s;
  var c = t;
  if (e.length === 1) {
    var u = e[0];
    u.type === "sizing" ? c = t.havingSize(u.size) : u.type === "styling" && (c = t.havingStyle(zoe[u.style]));
  }
  var h = mo([i[0] || "leftmost"], [], t), f = mo([i[1] || "rightmost"], [], t), d = r === "root";
  return g9(s, (p, m) => {
    var g = m.classes[0], b = p.classes[0];
    g === "mbin" && Be.contains(Boe, b) ? m.classes[0] = "mord" : b === "mbin" && Be.contains(Loe, g) && (p.classes[0] = "mord");
  }, {
    node: h
  }, f, d), g9(s, (p, m) => {
    var g = L5(m), b = L5(p), w = g && b ? p.hasClass("mtight") ? _oe[g][b] : Poe[g][b] : null;
    if (w)
      return H.makeGlue(w, c);
  }, {
    node: h
  }, f, d), s;
}, g9 = function n(e, t, r, i, s) {
  i && e.push(i);
  for (var o = 0; o < e.length; o++) {
    var l = e[o], a = GD(l);
    if (a) {
      n(a.children, t, r, null, s);
      continue;
    }
    var c = !l.hasClass("mspace");
    if (c) {
      var u = t(l, r.node);
      u && (r.insertAfter ? r.insertAfter(u) : (e.unshift(u), o++));
    }
    c ? r.node = l : s && l.hasClass("newline") && (r.node = mo(["leftmost"])), r.insertAfter = /* @__PURE__ */ ((h) => (f) => {
      e.splice(h + 1, 0, f), o++;
    })(o);
  }
  i && e.pop();
}, GD = function(e) {
  return e instanceof _d || e instanceof d7 || e instanceof Ld && e.hasClass("enclosing") ? e : null;
}, Hoe = function n(e, t) {
  var r = GD(e);
  if (r) {
    var i = r.children;
    if (i.length) {
      if (t === "right")
        return n(i[i.length - 1], "right");
      if (t === "left")
        return n(i[0], "left");
    }
  }
  return e;
}, L5 = function(e, t) {
  return e ? (t && (e = Hoe(e, t)), Foe[e.classes[0]] || null) : null;
}, rd = function(e, t) {
  var r = ["nulldelimiter"].concat(e.baseSizingClasses());
  return mo(t.concat(r));
}, ht = function(e, t, r) {
  if (!e)
    return mo();
  if (Um[e.type]) {
    var i = Um[e.type](e, t);
    if (r && t.size !== r.size) {
      i = mo(t.sizingClasses(r), [i], t);
      var s = t.sizeMultiplier / r.sizeMultiplier;
      i.height *= s, i.depth *= s;
    }
    return i;
  } else
    throw new se("Got group of unknown type: '" + e.type + "'");
};
function _0(n, e) {
  var t = mo(["base"], n, e), r = mo(["strut"]);
  return r.style.height = fe(t.height + t.depth), t.depth && (r.style.verticalAlign = fe(-t.depth)), t.children.unshift(r), t;
}
function B5(n, e) {
  var t = null;
  n.length === 1 && n[0].type === "tag" && (t = n[0].tag, n = n[0].body);
  var r = xn(n, e, "root"), i;
  r.length === 2 && r[1].hasClass("tag") && (i = r.pop());
  for (var s = [], o = [], l = 0; l < r.length; l++)
    if (o.push(r[l]), r[l].hasClass("mbin") || r[l].hasClass("mrel") || r[l].hasClass("allowbreak")) {
      for (var a = !1; l < r.length - 1 && r[l + 1].hasClass("mspace") && !r[l + 1].hasClass("newline"); )
        l++, o.push(r[l]), r[l].hasClass("nobreak") && (a = !0);
      a || (s.push(_0(o, e)), o = []);
    } else r[l].hasClass("newline") && (o.pop(), o.length > 0 && (s.push(_0(o, e)), o = []), s.push(r[l]));
  o.length > 0 && s.push(_0(o, e));
  var c;
  t ? (c = _0(xn(t, e, !0)), c.classes = ["tag"], s.push(c)) : i && s.push(i);
  var u = mo(["katex-html"], s);
  if (u.setAttribute("aria-hidden", "true"), c) {
    var h = c.children[0];
    h.style.height = fe(u.height + u.depth), u.depth && (h.style.verticalAlign = fe(-u.depth));
  }
  return u;
}
function YD(n) {
  return new _d(n);
}
class Gr {
  constructor(e, t, r) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = t || [], this.classes = r || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && e.setAttribute(t, this.attributes[t]);
    this.classes.length > 0 && (e.className = yl(this.classes));
    for (var r = 0; r < this.children.length; r++)
      if (this.children[r] instanceof ms && this.children[r + 1] instanceof ms) {
        for (var i = this.children[r].toText() + this.children[++r].toText(); this.children[r + 1] instanceof ms; )
          i += this.children[++r].toText();
        e.appendChild(new ms(i).toNode());
      } else
        e.appendChild(this.children[r].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var e = "<" + this.type;
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="', e += Be.escape(this.attributes[t]), e += '"');
    this.classes.length > 0 && (e += ' class ="' + Be.escape(yl(this.classes)) + '"'), e += ">";
    for (var r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
}
class ms {
  constructor(e) {
    this.text = void 0, this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return Be.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class $oe {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(e) {
    this.width = void 0, this.character = void 0, this.width = e, e >= 0.05555 && e <= 0.05556 ? this.character = " " : e >= 0.1666 && e <= 0.1667 ? this.character = " " : e >= 0.2222 && e <= 0.2223 ? this.character = " " : e >= 0.2777 && e <= 0.2778 ? this.character = "  " : e >= -0.05556 && e <= -0.05555 ? this.character = " ⁣" : e >= -0.1667 && e <= -0.1666 ? this.character = " ⁣" : e >= -0.2223 && e <= -0.2222 ? this.character = " ⁣" : e >= -0.2778 && e <= -0.2777 ? this.character = " ⁣" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return e.setAttribute("width", fe(this.width)), e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + fe(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var ne = {
  MathNode: Gr,
  TextNode: ms,
  SpaceNode: $oe,
  newDocumentFragment: YD
}, ki = function(e, t, r) {
  return zt[t][e] && zt[t][e].replace && e.charCodeAt(0) !== 55349 && !(VD.hasOwnProperty(e) && r && (r.fontFamily && r.fontFamily.slice(4, 6) === "tt" || r.font && r.font.slice(4, 6) === "tt")) && (e = zt[t][e].replace), new ne.TextNode(e);
}, m7 = function(e) {
  return e.length === 1 ? e[0] : new ne.MathNode("mrow", e);
}, g7 = function(e, t) {
  if (t.fontFamily === "texttt")
    return "monospace";
  if (t.fontFamily === "textsf")
    return t.fontShape === "textit" && t.fontWeight === "textbf" ? "sans-serif-bold-italic" : t.fontShape === "textit" ? "sans-serif-italic" : t.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (t.fontShape === "textit" && t.fontWeight === "textbf")
    return "bold-italic";
  if (t.fontShape === "textit")
    return "italic";
  if (t.fontWeight === "textbf")
    return "bold";
  var r = t.font;
  if (!r || r === "mathnormal")
    return null;
  var i = e.mode;
  if (r === "mathit")
    return "italic";
  if (r === "boldsymbol")
    return e.type === "textord" ? "bold" : "bold-italic";
  if (r === "mathbf")
    return "bold";
  if (r === "mathbb")
    return "double-struck";
  if (r === "mathsfit")
    return "sans-serif-italic";
  if (r === "mathfrak")
    return "fraktur";
  if (r === "mathscr" || r === "mathcal")
    return "script";
  if (r === "mathsf")
    return "sans-serif";
  if (r === "mathtt")
    return "monospace";
  var s = e.text;
  if (Be.contains(["\\imath", "\\jmath"], s))
    return null;
  zt[i][s] && zt[i][s].replace && (s = zt[i][s].replace);
  var o = H.fontMap[r].fontName;
  return f7(s, o, i) ? H.fontMap[r].variant : null;
};
function c4(n) {
  if (!n)
    return !1;
  if (n.type === "mi" && n.children.length === 1) {
    var e = n.children[0];
    return e instanceof ms && e.text === ".";
  } else if (n.type === "mo" && n.children.length === 1 && n.getAttribute("separator") === "true" && n.getAttribute("lspace") === "0em" && n.getAttribute("rspace") === "0em") {
    var t = n.children[0];
    return t instanceof ms && t.text === ",";
  } else
    return !1;
}
var Pr = function(e, t, r) {
  if (e.length === 1) {
    var i = Nt(e[0], t);
    return r && i instanceof Gr && i.type === "mo" && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
  }
  for (var s = [], o, l = 0; l < e.length; l++) {
    var a = Nt(e[l], t);
    if (a instanceof Gr && o instanceof Gr) {
      if (a.type === "mtext" && o.type === "mtext" && a.getAttribute("mathvariant") === o.getAttribute("mathvariant")) {
        o.children.push(...a.children);
        continue;
      } else if (a.type === "mn" && o.type === "mn") {
        o.children.push(...a.children);
        continue;
      } else if (c4(a) && o.type === "mn") {
        o.children.push(...a.children);
        continue;
      } else if (a.type === "mn" && c4(o))
        a.children = [...o.children, ...a.children], s.pop();
      else if ((a.type === "msup" || a.type === "msub") && a.children.length >= 1 && (o.type === "mn" || c4(o))) {
        var c = a.children[0];
        c instanceof Gr && c.type === "mn" && (c.children = [...o.children, ...c.children], s.pop());
      } else if (o.type === "mi" && o.children.length === 1) {
        var u = o.children[0];
        if (u instanceof ms && u.text === "̸" && (a.type === "mo" || a.type === "mi" || a.type === "mn")) {
          var h = a.children[0];
          h instanceof ms && h.text.length > 0 && (h.text = h.text.slice(0, 1) + "̸" + h.text.slice(1), s.pop());
        }
      }
    }
    s.push(a), o = a;
  }
  return s;
}, vl = function(e, t, r) {
  return m7(Pr(e, t, r));
}, Nt = function(e, t) {
  if (!e)
    return new ne.MathNode("mrow");
  if (Km[e.type]) {
    var r = Km[e.type](e, t);
    return r;
  } else
    throw new se("Got group of unknown type: '" + e.type + "'");
};
function y9(n, e, t, r, i) {
  var s = Pr(n, t), o;
  s.length === 1 && s[0] instanceof Gr && Be.contains(["mrow", "mtable"], s[0].type) ? o = s[0] : o = new ne.MathNode("mrow", s);
  var l = new ne.MathNode("annotation", [new ne.TextNode(e)]);
  l.setAttribute("encoding", "application/x-tex");
  var a = new ne.MathNode("semantics", [o, l]), c = new ne.MathNode("math", [a]);
  c.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), r && c.setAttribute("display", "block");
  var u = i ? "katex" : "katex-mathml";
  return H.makeSpan([u], [c]);
}
var JD = function(e) {
  return new Ys({
    style: e.displayMode ? We.DISPLAY : We.TEXT,
    maxSize: e.maxSize,
    minRuleThickness: e.minRuleThickness
  });
}, XD = function(e, t) {
  if (t.displayMode) {
    var r = ["katex-display"];
    t.leqno && r.push("leqno"), t.fleqn && r.push("fleqn"), e = H.makeSpan(r, [e]);
  }
  return e;
}, Voe = function(e, t, r) {
  var i = JD(r), s;
  if (r.output === "mathml")
    return y9(e, t, i, r.displayMode, !0);
  if (r.output === "html") {
    var o = B5(e, i);
    s = H.makeSpan(["katex"], [o]);
  } else {
    var l = y9(e, t, i, r.displayMode, !1), a = B5(e, i);
    s = H.makeSpan(["katex"], [l, a]);
  }
  return XD(s, r);
}, qoe = function(e, t, r) {
  var i = JD(r), s = B5(e, i), o = H.makeSpan(["katex"], [s]);
  return XD(o, r);
}, Woe = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "←",
  underleftarrow: "←",
  xleftarrow: "←",
  overrightarrow: "→",
  underrightarrow: "→",
  xrightarrow: "→",
  underbrace: "⏟",
  overbrace: "⏞",
  overgroup: "⏠",
  undergroup: "⏡",
  overleftrightarrow: "↔",
  underleftrightarrow: "↔",
  xleftrightarrow: "↔",
  Overrightarrow: "⇒",
  xRightarrow: "⇒",
  overleftharpoon: "↼",
  xleftharpoonup: "↼",
  overrightharpoon: "⇀",
  xrightharpoonup: "⇀",
  xLeftarrow: "⇐",
  xLeftrightarrow: "⇔",
  xhookleftarrow: "↩",
  xhookrightarrow: "↪",
  xmapsto: "↦",
  xrightharpoondown: "⇁",
  xleftharpoondown: "↽",
  xrightleftharpoons: "⇌",
  xleftrightharpoons: "⇋",
  xtwoheadleftarrow: "↞",
  xtwoheadrightarrow: "↠",
  xlongequal: "=",
  xtofrom: "⇄",
  xrightleftarrows: "⇄",
  xrightequilibrium: "⇌",
  // Not a perfect match.
  xleftequilibrium: "⇋",
  // None better available.
  "\\cdrightarrow": "→",
  "\\cdleftarrow": "←",
  "\\cdlongequal": "="
}, joe = function(e) {
  var t = new ne.MathNode("mo", [new ne.TextNode(Woe[e.replace(/^\\/, "")])]);
  return t.setAttribute("stretchy", "true"), t;
}, Uoe = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, Koe = function(e) {
  return e.type === "ordgroup" ? e.body.length : 1;
}, Goe = function(e, t) {
  function r() {
    var l = 4e5, a = e.label.slice(1);
    if (Be.contains(["widehat", "widecheck", "widetilde", "utilde"], a)) {
      var c = e, u = Koe(c.base), h, f, d;
      if (u > 5)
        a === "widehat" || a === "widecheck" ? (h = 420, l = 2364, d = 0.42, f = a + "4") : (h = 312, l = 2340, d = 0.34, f = "tilde4");
      else {
        var p = [1, 1, 2, 2, 3, 3][u];
        a === "widehat" || a === "widecheck" ? (l = [0, 1062, 2364, 2364, 2364][p], h = [0, 239, 300, 360, 420][p], d = [0, 0.24, 0.3, 0.3, 0.36, 0.42][p], f = a + p) : (l = [0, 600, 1033, 2339, 2340][p], h = [0, 260, 286, 306, 312][p], d = [0, 0.26, 0.286, 0.3, 0.306, 0.34][p], f = "tilde" + p);
      }
      var m = new bl(f), g = new po([m], {
        width: "100%",
        height: fe(d),
        viewBox: "0 0 " + l + " " + h,
        preserveAspectRatio: "none"
      });
      return {
        span: H.makeSvgSpan([], [g], t),
        minWidth: 0,
        height: d
      };
    } else {
      var b = [], w = Uoe[a], [k, C, M] = w, T = M / 1e3, N = k.length, B, $;
      if (N === 1) {
        var R = w[3];
        B = ["hide-tail"], $ = [R];
      } else if (N === 2)
        B = ["halfarrow-left", "halfarrow-right"], $ = ["xMinYMin", "xMaxYMin"];
      else if (N === 3)
        B = ["brace-left", "brace-center", "brace-right"], $ = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + N + " children.");
      for (var V = 0; V < N; V++) {
        var z = new bl(k[V]), ue = new po([z], {
          width: "400em",
          height: fe(T),
          viewBox: "0 0 " + l + " " + M,
          preserveAspectRatio: $[V] + " slice"
        }), ie = H.makeSvgSpan([B[V]], [ue], t);
        if (N === 1)
          return {
            span: ie,
            minWidth: C,
            height: T
          };
        ie.style.height = fe(T), b.push(ie);
      }
      return {
        span: H.makeSpan(["stretchy"], b, t),
        minWidth: C,
        height: T
      };
    }
  }
  var {
    span: i,
    minWidth: s,
    height: o
  } = r();
  return i.height = o, i.style.height = fe(o), s > 0 && (i.style.minWidth = fe(s)), i;
}, Yoe = function(e, t, r, i, s) {
  var o, l = e.height + e.depth + r + i;
  if (/fbox|color|angl/.test(t)) {
    if (o = H.makeSpan(["stretchy", t], [], s), t === "fbox") {
      var a = s.color && s.getColor();
      a && (o.style.borderColor = a);
    }
  } else {
    var c = [];
    /^[bx]cancel$/.test(t) && c.push(new P5({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(t) && c.push(new P5({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var u = new po(c, {
      width: "100%",
      height: fe(l)
    });
    o = H.makeSvgSpan([], [u], s);
  }
  return o.height = l, o.style.height = fe(l), o;
}, go = {
  encloseSpan: Yoe,
  mathMLnode: joe,
  svgSpan: Goe
};
function Qe(n, e) {
  if (!n || n.type !== e)
    throw new Error("Expected node of type " + e + ", but got " + (n ? "node of type " + n.type : String(n)));
  return n;
}
function y7(n) {
  var e = ug(n);
  if (!e)
    throw new Error("Expected node of symbol group type, but got " + (n ? "node of type " + n.type : String(n)));
  return e;
}
function ug(n) {
  return n && (n.type === "atom" || woe.hasOwnProperty(n.type)) ? n : null;
}
var b7 = (n, e) => {
  var t, r, i;
  n && n.type === "supsub" ? (r = Qe(n.base, "accent"), t = r.base, n.base = t, i = boe(ht(n, e)), n.base = r) : (r = Qe(n, "accent"), t = r.base);
  var s = ht(t, e.havingCrampedStyle()), o = r.isShifty && Be.isCharacterBox(t), l = 0;
  if (o) {
    var a = Be.getBaseElem(t), c = ht(a, e.havingCrampedStyle());
    l = u9(c).skew;
  }
  var u = r.label === "\\c", h = u ? s.height + s.depth : Math.min(s.height, e.fontMetrics().xHeight), f;
  if (r.isStretchy)
    f = go.svgSpan(r, e), f = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "elem",
        elem: f,
        wrapperClasses: ["svg-align"],
        wrapperStyle: l > 0 ? {
          width: "calc(100% - " + fe(2 * l) + ")",
          marginLeft: fe(2 * l)
        } : void 0
      }]
    }, e);
  else {
    var d, p;
    r.label === "\\vec" ? (d = H.staticSvg("vec", e), p = H.svgData.vec[1]) : (d = H.makeOrd({
      mode: r.mode,
      text: r.label
    }, e, "textord"), d = u9(d), d.italic = 0, p = d.width, u && (h += d.depth)), f = H.makeSpan(["accent-body"], [d]);
    var m = r.label === "\\textcircled";
    m && (f.classes.push("accent-full"), h = s.height);
    var g = l;
    m || (g -= p / 2), f.style.left = fe(g), r.label === "\\textcircled" && (f.style.top = ".2em"), f = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "kern",
        size: -h
      }, {
        type: "elem",
        elem: f
      }]
    }, e);
  }
  var b = H.makeSpan(["mord", "accent"], [f], e);
  return i ? (i.children[0] = b, i.height = Math.max(b.height, i.height), i.classes[0] = "mord", i) : b;
}, ZD = (n, e) => {
  var t = n.isStretchy ? go.mathMLnode(n.label) : new ne.MathNode("mo", [ki(n.label, n.mode)]), r = new ne.MathNode("mover", [Nt(n.base, e), t]);
  return r.setAttribute("accent", "true"), r;
}, Joe = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((n) => "\\" + n).join("|"));
be({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var t = Gm(e[0]), r = !Joe.test(n.funcName), i = !r || n.funcName === "\\widehat" || n.funcName === "\\widetilde" || n.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: n.parser.mode,
      label: n.funcName,
      isStretchy: r,
      isShifty: i,
      base: t
    };
  },
  htmlBuilder: b7,
  mathmlBuilder: ZD
});
be({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (n, e) => {
    var t = e[0], r = n.parser.mode;
    return r === "math" && (n.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + n.funcName + " works only in text mode"), r = "text"), {
      type: "accent",
      mode: r,
      label: n.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: t
    };
  },
  htmlBuilder: b7,
  mathmlBuilder: ZD
});
be({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "accentUnder",
      mode: t.mode,
      label: r,
      base: i
    };
  },
  htmlBuilder: (n, e) => {
    var t = ht(n.base, e), r = go.svgSpan(n, e), i = n.label === "\\utilde" ? 0.12 : 0, s = H.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return H.makeSpan(["mord", "accentunder"], [s], e);
  },
  mathmlBuilder: (n, e) => {
    var t = go.mathMLnode(n.label), r = new ne.MathNode("munder", [Nt(n.base, e), t]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
var L0 = (n) => {
  var e = new ne.MathNode("mpadded", n ? [n] : []);
  return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
};
be({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n;
    return {
      type: "xArrow",
      mode: r.mode,
      label: i,
      body: e[0],
      below: t[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(n, e) {
    var t = e.style, r = e.havingStyle(t.sup()), i = H.wrapFragment(ht(n.body, r, e), e), s = n.label.slice(0, 2) === "\\x" ? "x" : "cd";
    i.classes.push(s + "-arrow-pad");
    var o;
    n.below && (r = e.havingStyle(t.sub()), o = H.wrapFragment(ht(n.below, r, e), e), o.classes.push(s + "-arrow-pad"));
    var l = go.svgSpan(n, e), a = -e.fontMetrics().axisHeight + 0.5 * l.height, c = -e.fontMetrics().axisHeight - 0.5 * l.height - 0.111;
    (i.depth > 0.25 || n.label === "\\xleftequilibrium") && (c -= i.depth);
    var u;
    if (o) {
      var h = -e.fontMetrics().axisHeight + o.height + 0.5 * l.height + 0.111;
      u = H.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: c
        }, {
          type: "elem",
          elem: l,
          shift: a
        }, {
          type: "elem",
          elem: o,
          shift: h
        }]
      }, e);
    } else
      u = H.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: c
        }, {
          type: "elem",
          elem: l,
          shift: a
        }]
      }, e);
    return u.children[0].children[0].children[1].classes.push("svg-align"), H.makeSpan(["mrel", "x-arrow"], [u], e);
  },
  mathmlBuilder(n, e) {
    var t = go.mathMLnode(n.label);
    t.setAttribute("minsize", n.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var r;
    if (n.body) {
      var i = L0(Nt(n.body, e));
      if (n.below) {
        var s = L0(Nt(n.below, e));
        r = new ne.MathNode("munderover", [t, s, i]);
      } else
        r = new ne.MathNode("mover", [t, i]);
    } else if (n.below) {
      var o = L0(Nt(n.below, e));
      r = new ne.MathNode("munder", [t, o]);
    } else
      r = L0(), r = new ne.MathNode("mover", [t, r]);
    return r;
  }
});
var Xoe = H.makeSpan;
function QD(n, e) {
  var t = xn(n.body, e, !0);
  return Xoe([n.mclass], t, e);
}
function eN(n, e) {
  var t, r = Pr(n.body, e);
  return n.mclass === "minner" ? t = new ne.MathNode("mpadded", r) : n.mclass === "mord" ? n.isCharacterBox ? (t = r[0], t.type = "mi") : t = new ne.MathNode("mi", r) : (n.isCharacterBox ? (t = r[0], t.type = "mo") : t = new ne.MathNode("mo", r), n.mclass === "mbin" ? (t.attributes.lspace = "0.22em", t.attributes.rspace = "0.22em") : n.mclass === "mpunct" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0.17em") : n.mclass === "mopen" || n.mclass === "mclose" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0em") : n.mclass === "minner" && (t.attributes.lspace = "0.0556em", t.attributes.width = "+0.1111em")), t;
}
be({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "mclass",
      mode: t.mode,
      mclass: "m" + r.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: cn(i),
      isCharacterBox: Be.isCharacterBox(i)
    };
  },
  htmlBuilder: QD,
  mathmlBuilder: eN
});
var hg = (n) => {
  var e = n.type === "ordgroup" && n.body.length ? n.body[0] : n;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
be({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "mclass",
      mode: t.mode,
      mclass: hg(e[0]),
      body: cn(e[1]),
      isCharacterBox: Be.isCharacterBox(e[1])
    };
  }
});
be({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[1], s = e[0], o;
    r !== "\\stackrel" ? o = hg(i) : o = "mrel";
    var l = {
      type: "op",
      mode: i.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: r !== "\\stackrel",
      body: cn(i)
    }, a = {
      type: "supsub",
      mode: s.mode,
      base: l,
      sup: r === "\\underset" ? null : s,
      sub: r === "\\underset" ? s : null
    };
    return {
      type: "mclass",
      mode: t.mode,
      mclass: o,
      body: [a],
      isCharacterBox: Be.isCharacterBox(a)
    };
  },
  htmlBuilder: QD,
  mathmlBuilder: eN
});
be({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "pmb",
      mode: t.mode,
      mclass: hg(e[0]),
      body: cn(e[0])
    };
  },
  htmlBuilder(n, e) {
    var t = xn(n.body, e, !0), r = H.makeSpan([n.mclass], t, e);
    return r.style.textShadow = "0.02em 0.01em 0.04px", r;
  },
  mathmlBuilder(n, e) {
    var t = Pr(n.body, e), r = new ne.MathNode("mstyle", t);
    return r.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), r;
  }
});
var Zoe = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, b9 = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), v9 = (n) => n.type === "textord" && n.text === "@", Qoe = (n, e) => (n.type === "mathord" || n.type === "atom") && n.text === e;
function ele(n, e, t) {
  var r = Zoe[n];
  switch (r) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return t.callFunction(r, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var i = t.callFunction("\\\\cdleft", [e[0]], []), s = {
        type: "atom",
        text: r,
        mode: "math",
        family: "rel"
      }, o = t.callFunction("\\Big", [s], []), l = t.callFunction("\\\\cdright", [e[1]], []), a = {
        type: "ordgroup",
        mode: "math",
        body: [i, o, l]
      };
      return t.callFunction("\\\\cdparent", [a], []);
    }
    case "\\\\cdlongequal":
      return t.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var c = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return t.callFunction("\\Big", [c], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function tle(n) {
  var e = [];
  for (n.gullet.beginGroup(), n.gullet.macros.set("\\cr", "\\\\\\relax"), n.gullet.beginGroup(); ; ) {
    e.push(n.parseExpression(!1, "\\\\")), n.gullet.endGroup(), n.gullet.beginGroup();
    var t = n.fetch().text;
    if (t === "&" || t === "\\\\")
      n.consume();
    else if (t === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new se("Expected \\\\ or \\cr or \\end", n.nextToken);
  }
  for (var r = [], i = [r], s = 0; s < e.length; s++) {
    for (var o = e[s], l = b9(), a = 0; a < o.length; a++)
      if (!v9(o[a]))
        l.body.push(o[a]);
      else {
        r.push(l), a += 1;
        var c = y7(o[a]).text, u = new Array(2);
        if (u[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, u[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(c) > -1)) if ("<>AV".indexOf(c) > -1)
          for (var h = 0; h < 2; h++) {
            for (var f = !0, d = a + 1; d < o.length; d++) {
              if (Qoe(o[d], c)) {
                f = !1, a = d;
                break;
              }
              if (v9(o[d]))
                throw new se("Missing a " + c + " character to complete a CD arrow.", o[d]);
              u[h].body.push(o[d]);
            }
            if (f)
              throw new se("Missing a " + c + " character to complete a CD arrow.", o[a]);
          }
        else
          throw new se('Expected one of "<>AV=|." after @', o[a]);
        var p = ele(c, u, n), m = {
          type: "styling",
          body: [p],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        r.push(m), l = b9();
      }
    s % 2 === 0 ? r.push(l) : r.shift(), r = [], i.push(r);
  }
  n.gullet.endGroup(), n.gullet.endGroup();
  var g = new Array(i[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: i,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: g,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(i.length + 1).fill([])
  };
}
be({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n;
    return {
      type: "cdlabel",
      mode: t.mode,
      side: r.slice(4),
      label: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = e.havingStyle(e.style.sup()), r = H.wrapFragment(ht(n.label, t, e), e);
    return r.classes.push("cd-label-" + n.side), r.style.bottom = fe(0.8 - r.depth), r.height = 0, r.depth = 0, r;
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mrow", [Nt(n.label, e)]);
    return t = new ne.MathNode("mpadded", [t]), t.setAttribute("width", "0"), n.side === "left" && t.setAttribute("lspace", "-1width"), t.setAttribute("voffset", "0.7em"), t = new ne.MathNode("mstyle", [t]), t.setAttribute("displaystyle", "false"), t.setAttribute("scriptlevel", "1"), t;
  }
});
be({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "cdlabelparent",
      mode: t.mode,
      fragment: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = H.wrapFragment(ht(n.fragment, e), e);
    return t.classes.push("cd-vert-arrow"), t;
  },
  mathmlBuilder(n, e) {
    return new ne.MathNode("mrow", [Nt(n.fragment, e)]);
  }
});
be({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    for (var {
      parser: t
    } = n, r = Qe(e[0], "ordgroup"), i = r.body, s = "", o = 0; o < i.length; o++) {
      var l = Qe(i[o], "textord");
      s += l.text;
    }
    var a = parseInt(s), c;
    if (isNaN(a))
      throw new se("\\@char has non-numeric argument " + s);
    if (a < 0 || a >= 1114111)
      throw new se("\\@char with invalid code point " + s);
    return a <= 65535 ? c = String.fromCharCode(a) : (a -= 65536, c = String.fromCharCode((a >> 10) + 55296, (a & 1023) + 56320)), {
      type: "textord",
      mode: t.mode,
      text: c
    };
  }
});
var tN = (n, e) => {
  var t = xn(n.body, e.withColor(n.color), !1);
  return H.makeFragment(t);
}, nN = (n, e) => {
  var t = Pr(n.body, e.withColor(n.color)), r = new ne.MathNode("mstyle", t);
  return r.setAttribute("mathcolor", n.color), r;
};
be({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = Qe(e[0], "color-token").color, i = e[1];
    return {
      type: "color",
      mode: t.mode,
      color: r,
      body: cn(i)
    };
  },
  htmlBuilder: tN,
  mathmlBuilder: nN
});
be({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(n, e) {
    var {
      parser: t,
      breakOnTokenText: r
    } = n, i = Qe(e[0], "color-token").color;
    t.gullet.macros.set("\\current@color", i);
    var s = t.parseExpression(!0, r);
    return {
      type: "color",
      mode: t.mode,
      color: i,
      body: s
    };
  },
  htmlBuilder: tN,
  mathmlBuilder: nN
});
be({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = r.gullet.future().text === "[" ? r.parseSizeGroup(!0) : null, s = !r.settings.displayMode || !r.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: r.mode,
      newLine: s,
      size: i && Qe(i, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(n, e) {
    var t = H.makeSpan(["mspace"], [], e);
    return n.newLine && (t.classes.push("newline"), n.size && (t.style.marginTop = fe(Qt(n.size, e)))), t;
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mspace");
    return n.newLine && (t.setAttribute("linebreak", "newline"), n.size && t.setAttribute("height", fe(Qt(n.size, e)))), t;
  }
});
var z5 = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, rN = (n) => {
  var e = n.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new se("Expected a control sequence", n);
  return e;
}, nle = (n) => {
  var e = n.gullet.popToken();
  return e.text === "=" && (e = n.gullet.popToken(), e.text === " " && (e = n.gullet.popToken())), e;
}, iN = (n, e, t, r) => {
  var i = n.gullet.macros.get(t.text);
  i == null && (t.noexpand = !0, i = {
    tokens: [t],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !n.gullet.isExpandable(t.text)
  }), n.gullet.macros.set(e, i, r);
};
be({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    e.consumeSpaces();
    var r = e.fetch();
    if (z5[r.text])
      return (t === "\\global" || t === "\\\\globallong") && (r.text = z5[r.text]), Qe(e.parseFunction(), "internal");
    throw new se("Invalid token after macro prefix", r);
  }
});
be({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = e.gullet.popToken(), i = r.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(i))
      throw new se("Expected a control sequence", r);
    for (var s = 0, o, l = [[]]; e.gullet.future().text !== "{"; )
      if (r = e.gullet.popToken(), r.text === "#") {
        if (e.gullet.future().text === "{") {
          o = e.gullet.future(), l[s].push("{");
          break;
        }
        if (r = e.gullet.popToken(), !/^[1-9]$/.test(r.text))
          throw new se('Invalid argument number "' + r.text + '"');
        if (parseInt(r.text) !== s + 1)
          throw new se('Argument number "' + r.text + '" out of order');
        s++, l.push([]);
      } else {
        if (r.text === "EOF")
          throw new se("Expected a macro definition");
        l[s].push(r.text);
      }
    var {
      tokens: a
    } = e.gullet.consumeArg();
    return o && a.unshift(o), (t === "\\edef" || t === "\\xdef") && (a = e.gullet.expandTokens(a), a.reverse()), e.gullet.macros.set(i, {
      tokens: a,
      numArgs: s,
      delimiters: l
    }, t === z5[t]), {
      type: "internal",
      mode: e.mode
    };
  }
});
be({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = rN(e.gullet.popToken());
    e.gullet.consumeSpaces();
    var i = nle(e);
    return iN(e, r, i, t === "\\\\globallet"), {
      type: "internal",
      mode: e.mode
    };
  }
});
be({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = rN(e.gullet.popToken()), i = e.gullet.popToken(), s = e.gullet.popToken();
    return iN(e, r, s, t === "\\\\globalfuture"), e.gullet.pushToken(s), e.gullet.pushToken(i), {
      type: "internal",
      mode: e.mode
    };
  }
});
var bh = function(e, t, r) {
  var i = zt.math[e] && zt.math[e].replace, s = f7(i || e, t, r);
  if (!s)
    throw new Error("Unsupported symbol " + e + " and font size " + t + ".");
  return s;
}, v7 = function(e, t, r, i) {
  var s = r.havingBaseStyle(t), o = H.makeSpan(i.concat(s.sizingClasses(r)), [e], r), l = s.sizeMultiplier / r.sizeMultiplier;
  return o.height *= l, o.depth *= l, o.maxFontSize = s.sizeMultiplier, o;
}, sN = function(e, t, r) {
  var i = t.havingBaseStyle(r), s = (1 - t.sizeMultiplier / i.sizeMultiplier) * t.fontMetrics().axisHeight;
  e.classes.push("delimcenter"), e.style.top = fe(s), e.height -= s, e.depth += s;
}, rle = function(e, t, r, i, s, o) {
  var l = H.makeSymbol(e, "Main-Regular", s, i), a = v7(l, t, i, o);
  return r && sN(a, i, t), a;
}, ile = function(e, t, r, i) {
  return H.makeSymbol(e, "Size" + t + "-Regular", r, i);
}, oN = function(e, t, r, i, s, o) {
  var l = ile(e, t, s, i), a = v7(H.makeSpan(["delimsizing", "size" + t], [l], i), We.TEXT, i, o);
  return r && sN(a, i, We.TEXT), a;
}, u4 = function(e, t, r) {
  var i;
  t === "Size1-Regular" ? i = "delim-size1" : i = "delim-size4";
  var s = H.makeSpan(["delimsizinginner", i], [H.makeSpan([], [H.makeSymbol(e, t, r)])]);
  return {
    type: "elem",
    elem: s
  };
}, h4 = function(e, t, r) {
  var i = ps["Size4-Regular"][e.charCodeAt(0)] ? ps["Size4-Regular"][e.charCodeAt(0)][4] : ps["Size1-Regular"][e.charCodeAt(0)][4], s = new bl("inner", coe(e, Math.round(1e3 * t))), o = new po([s], {
    width: fe(i),
    height: fe(t),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + fe(i),
    viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * t),
    preserveAspectRatio: "xMinYMin"
  }), l = H.makeSvgSpan([], [o], r);
  return l.height = t, l.style.height = fe(t), l.style.width = fe(i), {
    type: "elem",
    elem: l
  };
}, F5 = 8e-3, B0 = {
  type: "kern",
  size: -1 * F5
}, sle = ["|", "\\lvert", "\\rvert", "\\vert"], ole = ["\\|", "\\lVert", "\\rVert", "\\Vert"], lN = function(e, t, r, i, s, o) {
  var l, a, c, u, h = "", f = 0;
  l = c = u = e, a = null;
  var d = "Size1-Regular";
  e === "\\uparrow" ? c = u = "⏐" : e === "\\Uparrow" ? c = u = "‖" : e === "\\downarrow" ? l = c = "⏐" : e === "\\Downarrow" ? l = c = "‖" : e === "\\updownarrow" ? (l = "\\uparrow", c = "⏐", u = "\\downarrow") : e === "\\Updownarrow" ? (l = "\\Uparrow", c = "‖", u = "\\Downarrow") : Be.contains(sle, e) ? (c = "∣", h = "vert", f = 333) : Be.contains(ole, e) ? (c = "∥", h = "doublevert", f = 556) : e === "[" || e === "\\lbrack" ? (l = "⎡", c = "⎢", u = "⎣", d = "Size4-Regular", h = "lbrack", f = 667) : e === "]" || e === "\\rbrack" ? (l = "⎤", c = "⎥", u = "⎦", d = "Size4-Regular", h = "rbrack", f = 667) : e === "\\lfloor" || e === "⌊" ? (c = l = "⎢", u = "⎣", d = "Size4-Regular", h = "lfloor", f = 667) : e === "\\lceil" || e === "⌈" ? (l = "⎡", c = u = "⎢", d = "Size4-Regular", h = "lceil", f = 667) : e === "\\rfloor" || e === "⌋" ? (c = l = "⎥", u = "⎦", d = "Size4-Regular", h = "rfloor", f = 667) : e === "\\rceil" || e === "⌉" ? (l = "⎤", c = u = "⎥", d = "Size4-Regular", h = "rceil", f = 667) : e === "(" || e === "\\lparen" ? (l = "⎛", c = "⎜", u = "⎝", d = "Size4-Regular", h = "lparen", f = 875) : e === ")" || e === "\\rparen" ? (l = "⎞", c = "⎟", u = "⎠", d = "Size4-Regular", h = "rparen", f = 875) : e === "\\{" || e === "\\lbrace" ? (l = "⎧", a = "⎨", u = "⎩", c = "⎪", d = "Size4-Regular") : e === "\\}" || e === "\\rbrace" ? (l = "⎫", a = "⎬", u = "⎭", c = "⎪", d = "Size4-Regular") : e === "\\lgroup" || e === "⟮" ? (l = "⎧", u = "⎩", c = "⎪", d = "Size4-Regular") : e === "\\rgroup" || e === "⟯" ? (l = "⎫", u = "⎭", c = "⎪", d = "Size4-Regular") : e === "\\lmoustache" || e === "⎰" ? (l = "⎧", u = "⎭", c = "⎪", d = "Size4-Regular") : (e === "\\rmoustache" || e === "⎱") && (l = "⎫", u = "⎩", c = "⎪", d = "Size4-Regular");
  var p = bh(l, d, s), m = p.height + p.depth, g = bh(c, d, s), b = g.height + g.depth, w = bh(u, d, s), k = w.height + w.depth, C = 0, M = 1;
  if (a !== null) {
    var T = bh(a, d, s);
    C = T.height + T.depth, M = 2;
  }
  var N = m + k + C, B = Math.max(0, Math.ceil((t - N) / (M * b))), $ = N + B * M * b, R = i.fontMetrics().axisHeight;
  r && (R *= i.sizeMultiplier);
  var V = $ / 2 - R, z = [];
  if (h.length > 0) {
    var ue = $ - m - k, ie = Math.round($ * 1e3), he = uoe(h, Math.round(ue * 1e3)), Se = new bl(h, he), ge = (f / 1e3).toFixed(3) + "em", ye = (ie / 1e3).toFixed(3) + "em", ze = new po([Se], {
      width: ge,
      height: ye,
      viewBox: "0 0 " + f + " " + ie
    }), I = H.makeSvgSpan([], [ze], i);
    I.height = ie / 1e3, I.style.width = ge, I.style.height = ye, z.push({
      type: "elem",
      elem: I
    });
  } else {
    if (z.push(u4(u, d, s)), z.push(B0), a === null) {
      var Ie = $ - m - k + 2 * F5;
      z.push(h4(c, Ie, i));
    } else {
      var Ve = ($ - m - k - C) / 2 + 2 * F5;
      z.push(h4(c, Ve, i)), z.push(B0), z.push(u4(a, d, s)), z.push(B0), z.push(h4(c, Ve, i));
    }
    z.push(B0), z.push(u4(l, d, s));
  }
  var O = i.havingBaseStyle(We.TEXT), dt = H.makeVList({
    positionType: "bottom",
    positionData: V,
    children: z
  }, O);
  return v7(H.makeSpan(["delimsizing", "mult"], [dt], O), We.TEXT, i, o);
}, f4 = 80, d4 = 0.08, p4 = function(e, t, r, i, s) {
  var o = aoe(e, i, r), l = new bl(e, o), a = new po([l], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: fe(t),
    viewBox: "0 0 400000 " + r,
    preserveAspectRatio: "xMinYMin slice"
  });
  return H.makeSvgSpan(["hide-tail"], [a], s);
}, lle = function(e, t) {
  var r = t.havingBaseSizing(), i = hN("\\surd", e * r.sizeMultiplier, uN, r), s = r.sizeMultiplier, o = Math.max(0, t.minRuleThickness - t.fontMetrics().sqrtRuleThickness), l, a = 0, c = 0, u = 0, h;
  return i.type === "small" ? (u = 1e3 + 1e3 * o + f4, e < 1 ? s = 1 : e < 1.4 && (s = 0.7), a = (1 + o + d4) / s, c = (1 + o) / s, l = p4("sqrtMain", a, u, o, t), l.style.minWidth = "0.853em", h = 0.833 / s) : i.type === "large" ? (u = (1e3 + f4) * mf[i.size], c = (mf[i.size] + o) / s, a = (mf[i.size] + o + d4) / s, l = p4("sqrtSize" + i.size, a, u, o, t), l.style.minWidth = "1.02em", h = 1 / s) : (a = e + o + d4, c = e + o, u = Math.floor(1e3 * e + o) + f4, l = p4("sqrtTall", a, u, o, t), l.style.minWidth = "0.742em", h = 1.056), l.height = c, l.style.height = fe(a), {
    span: l,
    advanceWidth: h,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (t.fontMetrics().sqrtRuleThickness + o) * s
  };
}, aN = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"], ale = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"], cN = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], mf = [0, 1.2, 1.8, 2.4, 3], cle = function(e, t, r, i, s) {
  if (e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle"), Be.contains(aN, e) || Be.contains(cN, e))
    return oN(e, t, !1, r, i, s);
  if (Be.contains(ale, e))
    return lN(e, mf[t], !1, r, i, s);
  throw new se("Illegal delimiter: '" + e + "'");
}, ule = [{
  type: "small",
  style: We.SCRIPTSCRIPT
}, {
  type: "small",
  style: We.SCRIPT
}, {
  type: "small",
  style: We.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], hle = [{
  type: "small",
  style: We.SCRIPTSCRIPT
}, {
  type: "small",
  style: We.SCRIPT
}, {
  type: "small",
  style: We.TEXT
}, {
  type: "stack"
}], uN = [{
  type: "small",
  style: We.SCRIPTSCRIPT
}, {
  type: "small",
  style: We.SCRIPT
}, {
  type: "small",
  style: We.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], fle = function(e) {
  if (e.type === "small")
    return "Main-Regular";
  if (e.type === "large")
    return "Size" + e.size + "-Regular";
  if (e.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + e.type + "' here.");
}, hN = function(e, t, r, i) {
  for (var s = Math.min(2, 3 - i.style.size), o = s; o < r.length && r[o].type !== "stack"; o++) {
    var l = bh(e, fle(r[o]), "math"), a = l.height + l.depth;
    if (r[o].type === "small") {
      var c = i.havingBaseStyle(r[o].style);
      a *= c.sizeMultiplier;
    }
    if (a > t)
      return r[o];
  }
  return r[r.length - 1];
}, fN = function(e, t, r, i, s, o) {
  e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle");
  var l;
  Be.contains(cN, e) ? l = ule : Be.contains(aN, e) ? l = uN : l = hle;
  var a = hN(e, t, l, i);
  return a.type === "small" ? rle(e, a.style, r, i, s, o) : a.type === "large" ? oN(e, a.size, r, i, s, o) : lN(e, t, r, i, s, o);
}, dle = function(e, t, r, i, s, o) {
  var l = i.fontMetrics().axisHeight * i.sizeMultiplier, a = 901, c = 5 / i.fontMetrics().ptPerEm, u = Math.max(t - l, r + l), h = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    u / 500 * a,
    2 * u - c
  );
  return fN(e, h, !0, i, s, o);
}, oo = {
  sqrtImage: lle,
  sizedDelim: cle,
  sizeToMaxHeight: mf,
  customSizedDelim: fN,
  leftRightDelim: dle
}, w9 = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, ple = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function fg(n, e) {
  var t = ug(n);
  if (t && Be.contains(ple, t.text))
    return t;
  throw t ? new se("Invalid delimiter '" + t.text + "' after '" + e.funcName + "'", n) : new se("Invalid delimiter type '" + n.type + "'", n);
}
be({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (n, e) => {
    var t = fg(e[0], n);
    return {
      type: "delimsizing",
      mode: n.parser.mode,
      size: w9[n.funcName].size,
      mclass: w9[n.funcName].mclass,
      delim: t.text
    };
  },
  htmlBuilder: (n, e) => n.delim === "." ? H.makeSpan([n.mclass]) : oo.sizedDelim(n.delim, n.size, e, n.mode, [n.mclass]),
  mathmlBuilder: (n) => {
    var e = [];
    n.delim !== "." && e.push(ki(n.delim, n.mode));
    var t = new ne.MathNode("mo", e);
    n.mclass === "mopen" || n.mclass === "mclose" ? t.setAttribute("fence", "true") : t.setAttribute("fence", "false"), t.setAttribute("stretchy", "true");
    var r = fe(oo.sizeToMaxHeight[n.size]);
    return t.setAttribute("minsize", r), t.setAttribute("maxsize", r), t;
  }
});
function x9(n) {
  if (!n.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
be({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = n.parser.gullet.macros.get("\\current@color");
    if (t && typeof t != "string")
      throw new se("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: n.parser.mode,
      delim: fg(e[0], n).text,
      color: t
      // undefined if not set via \color
    };
  }
});
be({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = fg(e[0], n), r = n.parser;
    ++r.leftrightDepth;
    var i = r.parseExpression(!1);
    --r.leftrightDepth, r.expect("\\right", !1);
    var s = Qe(r.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: r.mode,
      body: i,
      left: t.text,
      right: s.delim,
      rightColor: s.color
    };
  },
  htmlBuilder: (n, e) => {
    x9(n);
    for (var t = xn(n.body, e, !0, ["mopen", "mclose"]), r = 0, i = 0, s = !1, o = 0; o < t.length; o++)
      t[o].isMiddle ? s = !0 : (r = Math.max(t[o].height, r), i = Math.max(t[o].depth, i));
    r *= e.sizeMultiplier, i *= e.sizeMultiplier;
    var l;
    if (n.left === "." ? l = rd(e, ["mopen"]) : l = oo.leftRightDelim(n.left, r, i, e, n.mode, ["mopen"]), t.unshift(l), s)
      for (var a = 1; a < t.length; a++) {
        var c = t[a], u = c.isMiddle;
        u && (t[a] = oo.leftRightDelim(u.delim, r, i, u.options, n.mode, []));
      }
    var h;
    if (n.right === ".")
      h = rd(e, ["mclose"]);
    else {
      var f = n.rightColor ? e.withColor(n.rightColor) : e;
      h = oo.leftRightDelim(n.right, r, i, f, n.mode, ["mclose"]);
    }
    return t.push(h), H.makeSpan(["minner"], t, e);
  },
  mathmlBuilder: (n, e) => {
    x9(n);
    var t = Pr(n.body, e);
    if (n.left !== ".") {
      var r = new ne.MathNode("mo", [ki(n.left, n.mode)]);
      r.setAttribute("fence", "true"), t.unshift(r);
    }
    if (n.right !== ".") {
      var i = new ne.MathNode("mo", [ki(n.right, n.mode)]);
      i.setAttribute("fence", "true"), n.rightColor && i.setAttribute("mathcolor", n.rightColor), t.push(i);
    }
    return m7(t);
  }
});
be({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = fg(e[0], n);
    if (!n.parser.leftrightDepth)
      throw new se("\\middle without preceding \\left", t);
    return {
      type: "middle",
      mode: n.parser.mode,
      delim: t.text
    };
  },
  htmlBuilder: (n, e) => {
    var t;
    if (n.delim === ".")
      t = rd(e, []);
    else {
      t = oo.sizedDelim(n.delim, 1, e, n.mode, []);
      var r = {
        delim: n.delim,
        options: e
      };
      t.isMiddle = r;
    }
    return t;
  },
  mathmlBuilder: (n, e) => {
    var t = n.delim === "\\vert" || n.delim === "|" ? ki("|", "text") : ki(n.delim, n.mode), r = new ne.MathNode("mo", [t]);
    return r.setAttribute("fence", "true"), r.setAttribute("lspace", "0.05em"), r.setAttribute("rspace", "0.05em"), r;
  }
});
var w7 = (n, e) => {
  var t = H.wrapFragment(ht(n.body, e), e), r = n.label.slice(1), i = e.sizeMultiplier, s, o = 0, l = Be.isCharacterBox(n.body);
  if (r === "sout")
    s = H.makeSpan(["stretchy", "sout"]), s.height = e.fontMetrics().defaultRuleThickness / i, o = -0.5 * e.fontMetrics().xHeight;
  else if (r === "phase") {
    var a = Qt({
      number: 0.6,
      unit: "pt"
    }, e), c = Qt({
      number: 0.35,
      unit: "ex"
    }, e), u = e.havingBaseSizing();
    i = i / u.sizeMultiplier;
    var h = t.height + t.depth + a + c;
    t.style.paddingLeft = fe(h / 2 + a);
    var f = Math.floor(1e3 * h * i), d = ooe(f), p = new po([new bl("phase", d)], {
      width: "400em",
      height: fe(f / 1e3),
      viewBox: "0 0 400000 " + f,
      preserveAspectRatio: "xMinYMin slice"
    });
    s = H.makeSvgSpan(["hide-tail"], [p], e), s.style.height = fe(h), o = t.depth + a + c;
  } else {
    /cancel/.test(r) ? l || t.classes.push("cancel-pad") : r === "angl" ? t.classes.push("anglpad") : t.classes.push("boxpad");
    var m = 0, g = 0, b = 0;
    /box/.test(r) ? (b = Math.max(
      e.fontMetrics().fboxrule,
      // default
      e.minRuleThickness
      // User override.
    ), m = e.fontMetrics().fboxsep + (r === "colorbox" ? 0 : b), g = m) : r === "angl" ? (b = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness), m = 4 * b, g = Math.max(0, 0.25 - t.depth)) : (m = l ? 0.2 : 0, g = m), s = go.encloseSpan(t, r, m, g, e), /fbox|boxed|fcolorbox/.test(r) ? (s.style.borderStyle = "solid", s.style.borderWidth = fe(b)) : r === "angl" && b !== 0.049 && (s.style.borderTopWidth = fe(b), s.style.borderRightWidth = fe(b)), o = t.depth + g, n.backgroundColor && (s.style.backgroundColor = n.backgroundColor, n.borderColor && (s.style.borderColor = n.borderColor));
  }
  var w;
  if (n.backgroundColor)
    w = H.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: s,
          shift: o
        },
        {
          type: "elem",
          elem: t,
          shift: 0
        }
      ]
    }, e);
  else {
    var k = /cancel|phase/.test(r) ? ["svg-align"] : [];
    w = H.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: t,
          shift: 0
        },
        {
          type: "elem",
          elem: s,
          shift: o,
          wrapperClasses: k
        }
      ]
    }, e);
  }
  return /cancel/.test(r) && (w.height = t.height, w.depth = t.depth), /cancel/.test(r) && !l ? H.makeSpan(["mord", "cancel-lap"], [w], e) : H.makeSpan(["mord"], [w], e);
}, x7 = (n, e) => {
  var t = 0, r = new ne.MathNode(n.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [Nt(n.body, e)]);
  switch (n.label) {
    case "\\cancel":
      r.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      r.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      r.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      r.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      r.setAttribute("notation", "box");
      break;
    case "\\angl":
      r.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (t = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm, r.setAttribute("width", "+" + 2 * t + "pt"), r.setAttribute("height", "+" + 2 * t + "pt"), r.setAttribute("lspace", t + "pt"), r.setAttribute("voffset", t + "pt"), n.label === "\\fcolorbox") {
        var i = Math.max(
          e.fontMetrics().fboxrule,
          // default
          e.minRuleThickness
          // user override
        );
        r.setAttribute("style", "border: " + i + "em solid " + String(n.borderColor));
      }
      break;
    case "\\xcancel":
      r.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return n.backgroundColor && r.setAttribute("mathbackground", n.backgroundColor), r;
};
be({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n, s = Qe(e[0], "color-token").color, o = e[1];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: s,
      body: o
    };
  },
  htmlBuilder: w7,
  mathmlBuilder: x7
});
be({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n, s = Qe(e[0], "color-token").color, o = Qe(e[1], "color-token").color, l = e[2];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: o,
      borderColor: s,
      body: l
    };
  },
  htmlBuilder: w7,
  mathmlBuilder: x7
});
be({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
be({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "enclose",
      mode: t.mode,
      label: r,
      body: i
    };
  },
  htmlBuilder: w7,
  mathmlBuilder: x7
});
be({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\angl",
      body: e[0]
    };
  }
});
var dN = {};
function Ds(n) {
  for (var {
    type: e,
    names: t,
    props: r,
    handler: i,
    htmlBuilder: s,
    mathmlBuilder: o
  } = n, l = {
    type: e,
    numArgs: r.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: i
  }, a = 0; a < t.length; ++a)
    dN[t[a]] = l;
  s && (Um[e] = s), o && (Km[e] = o);
}
var pN = {};
function S(n, e) {
  pN[n] = e;
}
function k9(n) {
  var e = [];
  n.consumeSpaces();
  var t = n.fetch().text;
  for (t === "\\relax" && (n.consume(), n.consumeSpaces(), t = n.fetch().text); t === "\\hline" || t === "\\hdashline"; )
    n.consume(), e.push(t === "\\hdashline"), n.consumeSpaces(), t = n.fetch().text;
  return e;
}
var dg = (n) => {
  var e = n.parser.settings;
  if (!e.displayMode)
    throw new se("{" + n.envName + "} can be used only in display mode.");
};
function k7(n) {
  if (n.indexOf("ed") === -1)
    return n.indexOf("*") === -1;
}
function Ol(n, e, t) {
  var {
    hskipBeforeAndAfter: r,
    addJot: i,
    cols: s,
    arraystretch: o,
    colSeparationType: l,
    autoTag: a,
    singleRow: c,
    emptySingleRow: u,
    maxNumCols: h,
    leqno: f
  } = e;
  if (n.gullet.beginGroup(), c || n.gullet.macros.set("\\cr", "\\\\\\relax"), !o) {
    var d = n.gullet.expandMacroAsText("\\arraystretch");
    if (d == null)
      o = 1;
    else if (o = parseFloat(d), !o || o < 0)
      throw new se("Invalid \\arraystretch: " + d);
  }
  n.gullet.beginGroup();
  var p = [], m = [p], g = [], b = [], w = a != null ? [] : void 0;
  function k() {
    a && n.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function C() {
    w && (n.gullet.macros.get("\\df@tag") ? (w.push(n.subparse([new yi("\\df@tag")])), n.gullet.macros.set("\\df@tag", void 0, !0)) : w.push(!!a && n.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (k(), b.push(k9(n)); ; ) {
    var M = n.parseExpression(!1, c ? "\\end" : "\\\\");
    n.gullet.endGroup(), n.gullet.beginGroup(), M = {
      type: "ordgroup",
      mode: n.mode,
      body: M
    }, t && (M = {
      type: "styling",
      mode: n.mode,
      style: t,
      body: [M]
    }), p.push(M);
    var T = n.fetch().text;
    if (T === "&") {
      if (h && p.length === h) {
        if (c || l)
          throw new se("Too many tab characters: &", n.nextToken);
        n.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      n.consume();
    } else if (T === "\\end") {
      C(), p.length === 1 && M.type === "styling" && M.body[0].body.length === 0 && (m.length > 1 || !u) && m.pop(), b.length < m.length + 1 && b.push([]);
      break;
    } else if (T === "\\\\") {
      n.consume();
      var N = void 0;
      n.gullet.future().text !== " " && (N = n.parseSizeGroup(!0)), g.push(N ? N.value : null), C(), b.push(k9(n)), p = [], m.push(p), k();
    } else
      throw new se("Expected & or \\\\ or \\cr or \\end", n.nextToken);
  }
  return n.gullet.endGroup(), n.gullet.endGroup(), {
    type: "array",
    mode: n.mode,
    addJot: i,
    arraystretch: o,
    body: m,
    cols: s,
    rowGaps: g,
    hskipBeforeAndAfter: r,
    hLinesBeforeRow: b,
    colSeparationType: l,
    tags: w,
    leqno: f
  };
}
function S7(n) {
  return n.slice(0, 1) === "d" ? "display" : "text";
}
var Ns = function(e, t) {
  var r, i, s = e.body.length, o = e.hLinesBeforeRow, l = 0, a = new Array(s), c = [], u = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    t.fontMetrics().arrayRuleWidth,
    t.minRuleThickness
    // User override.
  ), h = 1 / t.fontMetrics().ptPerEm, f = 5 * h;
  if (e.colSeparationType && e.colSeparationType === "small") {
    var d = t.havingStyle(We.SCRIPT).sizeMultiplier;
    f = 0.2778 * (d / t.sizeMultiplier);
  }
  var p = e.colSeparationType === "CD" ? Qt({
    number: 3,
    unit: "ex"
  }, t) : 12 * h, m = 3 * h, g = e.arraystretch * p, b = 0.7 * g, w = 0.3 * g, k = 0;
  function C(ae) {
    for (var re = 0; re < ae.length; ++re)
      re > 0 && (k += 0.25), c.push({
        pos: k,
        isDashed: ae[re]
      });
  }
  for (C(o[0]), r = 0; r < e.body.length; ++r) {
    var M = e.body[r], T = b, N = w;
    l < M.length && (l = M.length);
    var B = new Array(M.length);
    for (i = 0; i < M.length; ++i) {
      var $ = ht(M[i], t);
      N < $.depth && (N = $.depth), T < $.height && (T = $.height), B[i] = $;
    }
    var R = e.rowGaps[r], V = 0;
    R && (V = Qt(R, t), V > 0 && (V += w, N < V && (N = V), V = 0)), e.addJot && (N += m), B.height = T, B.depth = N, k += T, B.pos = k, k += N + V, a[r] = B, C(o[r + 1]);
  }
  var z = k / 2 + t.fontMetrics().axisHeight, ue = e.cols || [], ie = [], he, Se, ge = [];
  if (e.tags && e.tags.some((ae) => ae))
    for (r = 0; r < s; ++r) {
      var ye = a[r], ze = ye.pos - z, I = e.tags[r], Ie = void 0;
      I === !0 ? Ie = H.makeSpan(["eqn-num"], [], t) : I === !1 ? Ie = H.makeSpan([], [], t) : Ie = H.makeSpan([], xn(I, t, !0), t), Ie.depth = ye.depth, Ie.height = ye.height, ge.push({
        type: "elem",
        elem: Ie,
        shift: ze
      });
    }
  for (
    i = 0, Se = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    i < l || Se < ue.length;
    ++i, ++Se
  ) {
    for (var Ve = ue[Se] || {}, O = !0; Ve.type === "separator"; ) {
      if (O || (he = H.makeSpan(["arraycolsep"], []), he.style.width = fe(t.fontMetrics().doubleRuleSep), ie.push(he)), Ve.separator === "|" || Ve.separator === ":") {
        var dt = Ve.separator === "|" ? "solid" : "dashed", Ue = H.makeSpan(["vertical-separator"], [], t);
        Ue.style.height = fe(k), Ue.style.borderRightWidth = fe(u), Ue.style.borderRightStyle = dt, Ue.style.margin = "0 " + fe(-u / 2);
        var et = k - z;
        et && (Ue.style.verticalAlign = fe(-et)), ie.push(Ue);
      } else
        throw new se("Invalid separator type: " + Ve.separator);
      Se++, Ve = ue[Se] || {}, O = !1;
    }
    if (!(i >= l)) {
      var Ct = void 0;
      (i > 0 || e.hskipBeforeAndAfter) && (Ct = Be.deflt(Ve.pregap, f), Ct !== 0 && (he = H.makeSpan(["arraycolsep"], []), he.style.width = fe(Ct), ie.push(he)));
      var Ft = [];
      for (r = 0; r < s; ++r) {
        var sn = a[r], Gt = sn[i];
        if (Gt) {
          var _r = sn.pos - z;
          Gt.depth = sn.depth, Gt.height = sn.height, Ft.push({
            type: "elem",
            elem: Gt,
            shift: _r
          });
        }
      }
      Ft = H.makeVList({
        positionType: "individualShift",
        children: Ft
      }, t), Ft = H.makeSpan(["col-align-" + (Ve.align || "c")], [Ft]), ie.push(Ft), (i < l - 1 || e.hskipBeforeAndAfter) && (Ct = Be.deflt(Ve.postgap, f), Ct !== 0 && (he = H.makeSpan(["arraycolsep"], []), he.style.width = fe(Ct), ie.push(he)));
    }
  }
  if (a = H.makeSpan(["mtable"], ie), c.length > 0) {
    for (var E = H.makeLineSpan("hline", t, u), P = H.makeLineSpan("hdashline", t, u), W = [{
      type: "elem",
      elem: a,
      shift: 0
    }]; c.length > 0; ) {
      var Q = c.pop(), J = Q.pos - z;
      Q.isDashed ? W.push({
        type: "elem",
        elem: P,
        shift: J
      }) : W.push({
        type: "elem",
        elem: E,
        shift: J
      });
    }
    a = H.makeVList({
      positionType: "individualShift",
      children: W
    }, t);
  }
  if (ge.length === 0)
    return H.makeSpan(["mord"], [a], t);
  var Y = H.makeVList({
    positionType: "individualShift",
    children: ge
  }, t);
  return Y = H.makeSpan(["tag"], [Y], t), H.makeFragment([a, Y]);
}, mle = {
  c: "center ",
  l: "left ",
  r: "right "
}, Rs = function(e, t) {
  for (var r = [], i = new ne.MathNode("mtd", [], ["mtr-glue"]), s = new ne.MathNode("mtd", [], ["mml-eqn-num"]), o = 0; o < e.body.length; o++) {
    for (var l = e.body[o], a = [], c = 0; c < l.length; c++)
      a.push(new ne.MathNode("mtd", [Nt(l[c], t)]));
    e.tags && e.tags[o] && (a.unshift(i), a.push(i), e.leqno ? a.unshift(s) : a.push(s)), r.push(new ne.MathNode("mtr", a));
  }
  var u = new ne.MathNode("mtable", r), h = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
  u.setAttribute("rowspacing", fe(h));
  var f = "", d = "";
  if (e.cols && e.cols.length > 0) {
    var p = e.cols, m = "", g = !1, b = 0, w = p.length;
    p[0].type === "separator" && (f += "top ", b = 1), p[p.length - 1].type === "separator" && (f += "bottom ", w -= 1);
    for (var k = b; k < w; k++)
      p[k].type === "align" ? (d += mle[p[k].align], g && (m += "none "), g = !0) : p[k].type === "separator" && g && (m += p[k].separator === "|" ? "solid " : "dashed ", g = !1);
    u.setAttribute("columnalign", d.trim()), /[sd]/.test(m) && u.setAttribute("columnlines", m.trim());
  }
  if (e.colSeparationType === "align") {
    for (var C = e.cols || [], M = "", T = 1; T < C.length; T++)
      M += T % 2 ? "0em " : "1em ";
    u.setAttribute("columnspacing", M.trim());
  } else e.colSeparationType === "alignat" || e.colSeparationType === "gather" ? u.setAttribute("columnspacing", "0em") : e.colSeparationType === "small" ? u.setAttribute("columnspacing", "0.2778em") : e.colSeparationType === "CD" ? u.setAttribute("columnspacing", "0.5em") : u.setAttribute("columnspacing", "1em");
  var N = "", B = e.hLinesBeforeRow;
  f += B[0].length > 0 ? "left " : "", f += B[B.length - 1].length > 0 ? "right " : "";
  for (var $ = 1; $ < B.length - 1; $++)
    N += B[$].length === 0 ? "none " : B[$][0] ? "dashed " : "solid ";
  return /[sd]/.test(N) && u.setAttribute("rowlines", N.trim()), f !== "" && (u = new ne.MathNode("menclose", [u]), u.setAttribute("notation", f.trim())), e.arraystretch && e.arraystretch < 1 && (u = new ne.MathNode("mstyle", [u]), u.setAttribute("scriptlevel", "1")), u;
}, mN = function(e, t) {
  e.envName.indexOf("ed") === -1 && dg(e);
  var r = [], i = e.envName.indexOf("at") > -1 ? "alignat" : "align", s = e.envName === "split", o = Ol(e.parser, {
    cols: r,
    addJot: !0,
    autoTag: s ? void 0 : k7(e.envName),
    emptySingleRow: !0,
    colSeparationType: i,
    maxNumCols: s ? 2 : void 0,
    leqno: e.parser.settings.leqno
  }, "display"), l, a = 0, c = {
    type: "ordgroup",
    mode: e.mode,
    body: []
  };
  if (t[0] && t[0].type === "ordgroup") {
    for (var u = "", h = 0; h < t[0].body.length; h++) {
      var f = Qe(t[0].body[h], "textord");
      u += f.text;
    }
    l = Number(u), a = l * 2;
  }
  var d = !a;
  o.body.forEach(function(b) {
    for (var w = 1; w < b.length; w += 2) {
      var k = Qe(b[w], "styling"), C = Qe(k.body[0], "ordgroup");
      C.body.unshift(c);
    }
    if (d)
      a < b.length && (a = b.length);
    else {
      var M = b.length / 2;
      if (l < M)
        throw new se("Too many math in a row: " + ("expected " + l + ", but got " + M), b[0]);
    }
  });
  for (var p = 0; p < a; ++p) {
    var m = "r", g = 0;
    p % 2 === 1 ? m = "l" : p > 0 && d && (g = 1), r[p] = {
      type: "align",
      align: m,
      pregap: g,
      postgap: 0
    };
  }
  return o.colSeparationType = d ? "align" : "alignat", o;
};
Ds({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var t = ug(e[0]), r = t ? [e[0]] : Qe(e[0], "ordgroup").body, i = r.map(function(o) {
      var l = y7(o), a = l.text;
      if ("lcr".indexOf(a) !== -1)
        return {
          type: "align",
          align: a
        };
      if (a === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (a === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new se("Unknown column alignment: " + a, o);
    }), s = {
      cols: i,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: i.length
    };
    return Ol(n.parser, s, S7(n.envName));
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[n.envName.replace("*", "")], t = "c", r = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: t
      }]
    };
    if (n.envName.charAt(n.envName.length - 1) === "*") {
      var i = n.parser;
      if (i.consumeSpaces(), i.fetch().text === "[") {
        if (i.consume(), i.consumeSpaces(), t = i.fetch().text, "lcr".indexOf(t) === -1)
          throw new se("Expected l or c or r", i.nextToken);
        i.consume(), i.consumeSpaces(), i.expect("]"), i.consume(), r.cols = [{
          type: "align",
          align: t
        }];
      }
    }
    var s = Ol(n.parser, r, S7(n.envName)), o = Math.max(0, ...s.body.map((l) => l.length));
    return s.cols = new Array(o).fill({
      type: "align",
      align: t
    }), e ? {
      type: "leftright",
      mode: n.mode,
      body: [s],
      left: e[0],
      right: e[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : s;
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      arraystretch: 0.5
    }, t = Ol(n.parser, e, "script");
    return t.colSeparationType = "small", t;
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var t = ug(e[0]), r = t ? [e[0]] : Qe(e[0], "ordgroup").body, i = r.map(function(o) {
      var l = y7(o), a = l.text;
      if ("lc".indexOf(a) !== -1)
        return {
          type: "align",
          align: a
        };
      throw new se("Unknown column alignment: " + a, o);
    });
    if (i.length > 1)
      throw new se("{subarray} can contain only one column");
    var s = {
      cols: i,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (s = Ol(n.parser, s, "script"), s.body.length > 0 && s.body[0].length > 1)
      throw new se("{subarray} can contain only one column");
    return s;
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, t = Ol(n.parser, e, S7(n.envName));
    return {
      type: "leftright",
      mode: n.mode,
      body: [t],
      left: n.envName.indexOf("r") > -1 ? "." : "\\{",
      right: n.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: mN,
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    Be.contains(["gather", "gather*"], n.envName) && dg(n);
    var e = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: k7(n.envName),
      emptySingleRow: !0,
      leqno: n.parser.settings.leqno
    };
    return Ol(n.parser, e, "display");
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: mN,
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    dg(n);
    var e = {
      autoTag: k7(n.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: n.parser.settings.leqno
    };
    return Ol(n.parser, e, "display");
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
Ds({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(n) {
    return dg(n), tle(n.parser);
  },
  htmlBuilder: Ns,
  mathmlBuilder: Rs
});
S("\\nonumber", "\\gdef\\@eqnsw{0}");
S("\\notag", "\\nonumber");
be({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(n, e) {
    throw new se(n.funcName + " valid only within array environment");
  }
});
var S9 = dN;
be({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    if (i.type !== "ordgroup")
      throw new se("Invalid environment name", i);
    for (var s = "", o = 0; o < i.body.length; ++o)
      s += Qe(i.body[o], "textord").text;
    if (r === "\\begin") {
      if (!S9.hasOwnProperty(s))
        throw new se("No such environment: " + s, i);
      var l = S9[s], {
        args: a,
        optArgs: c
      } = t.parseArguments("\\begin{" + s + "}", l), u = {
        mode: t.mode,
        envName: s,
        parser: t
      }, h = l.handler(u, a, c);
      t.expect("\\end", !1);
      var f = t.nextToken, d = Qe(t.parseFunction(), "environment");
      if (d.name !== s)
        throw new se("Mismatch: \\begin{" + s + "} matched by \\end{" + d.name + "}", f);
      return h;
    }
    return {
      type: "environment",
      mode: t.mode,
      name: s,
      nameGroup: i
    };
  }
});
var gN = (n, e) => {
  var t = n.font, r = e.withFont(t);
  return ht(n.body, r);
}, yN = (n, e) => {
  var t = n.font, r = e.withFont(t);
  return Nt(n.body, r);
}, C9 = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
be({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = Gm(e[0]), s = r;
    return s in C9 && (s = C9[s]), {
      type: "font",
      mode: t.mode,
      font: s.slice(1),
      body: i
    };
  },
  htmlBuilder: gN,
  mathmlBuilder: yN
});
be({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0], i = Be.isCharacterBox(r);
    return {
      type: "mclass",
      mode: t.mode,
      mclass: hg(r),
      body: [{
        type: "font",
        mode: t.mode,
        font: "boldsymbol",
        body: r
      }],
      isCharacterBox: i
    };
  }
});
be({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r,
      breakOnTokenText: i
    } = n, {
      mode: s
    } = t, o = t.parseExpression(!0, i), l = "math" + r.slice(1);
    return {
      type: "font",
      mode: s,
      font: l,
      body: {
        type: "ordgroup",
        mode: t.mode,
        body: o
      }
    };
  },
  htmlBuilder: gN,
  mathmlBuilder: yN
});
var bN = (n, e) => {
  var t = e;
  return n === "display" ? t = t.id >= We.SCRIPT.id ? t.text() : We.DISPLAY : n === "text" && t.size === We.DISPLAY.size ? t = We.TEXT : n === "script" ? t = We.SCRIPT : n === "scriptscript" && (t = We.SCRIPTSCRIPT), t;
}, C7 = (n, e) => {
  var t = bN(n.size, e.style), r = t.fracNum(), i = t.fracDen(), s;
  s = e.havingStyle(r);
  var o = ht(n.numer, s, e);
  if (n.continued) {
    var l = 8.5 / e.fontMetrics().ptPerEm, a = 3.5 / e.fontMetrics().ptPerEm;
    o.height = o.height < l ? l : o.height, o.depth = o.depth < a ? a : o.depth;
  }
  s = e.havingStyle(i);
  var c = ht(n.denom, s, e), u, h, f;
  n.hasBarLine ? (n.barSize ? (h = Qt(n.barSize, e), u = H.makeLineSpan("frac-line", e, h)) : u = H.makeLineSpan("frac-line", e), h = u.height, f = u.height) : (u = null, h = 0, f = e.fontMetrics().defaultRuleThickness);
  var d, p, m;
  t.size === We.DISPLAY.size || n.size === "display" ? (d = e.fontMetrics().num1, h > 0 ? p = 3 * f : p = 7 * f, m = e.fontMetrics().denom1) : (h > 0 ? (d = e.fontMetrics().num2, p = f) : (d = e.fontMetrics().num3, p = 3 * f), m = e.fontMetrics().denom2);
  var g;
  if (u) {
    var w = e.fontMetrics().axisHeight;
    d - o.depth - (w + 0.5 * h) < p && (d += p - (d - o.depth - (w + 0.5 * h))), w - 0.5 * h - (c.height - m) < p && (m += p - (w - 0.5 * h - (c.height - m)));
    var k = -(w - 0.5 * h);
    g = H.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: c,
        shift: m
      }, {
        type: "elem",
        elem: u,
        shift: k
      }, {
        type: "elem",
        elem: o,
        shift: -d
      }]
    }, e);
  } else {
    var b = d - o.depth - (c.height - m);
    b < p && (d += 0.5 * (p - b), m += 0.5 * (p - b)), g = H.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: c,
        shift: m
      }, {
        type: "elem",
        elem: o,
        shift: -d
      }]
    }, e);
  }
  s = e.havingStyle(t), g.height *= s.sizeMultiplier / e.sizeMultiplier, g.depth *= s.sizeMultiplier / e.sizeMultiplier;
  var C;
  t.size === We.DISPLAY.size ? C = e.fontMetrics().delim1 : t.size === We.SCRIPTSCRIPT.size ? C = e.havingStyle(We.SCRIPT).fontMetrics().delim2 : C = e.fontMetrics().delim2;
  var M, T;
  return n.leftDelim == null ? M = rd(e, ["mopen"]) : M = oo.customSizedDelim(n.leftDelim, C, !0, e.havingStyle(t), n.mode, ["mopen"]), n.continued ? T = H.makeSpan([]) : n.rightDelim == null ? T = rd(e, ["mclose"]) : T = oo.customSizedDelim(n.rightDelim, C, !0, e.havingStyle(t), n.mode, ["mclose"]), H.makeSpan(["mord"].concat(s.sizingClasses(e)), [M, H.makeSpan(["mfrac"], [g]), T], e);
}, M7 = (n, e) => {
  var t = new ne.MathNode("mfrac", [Nt(n.numer, e), Nt(n.denom, e)]);
  if (!n.hasBarLine)
    t.setAttribute("linethickness", "0px");
  else if (n.barSize) {
    var r = Qt(n.barSize, e);
    t.setAttribute("linethickness", fe(r));
  }
  var i = bN(n.size, e.style);
  if (i.size !== e.style.size) {
    t = new ne.MathNode("mstyle", [t]);
    var s = i.size === We.DISPLAY.size ? "true" : "false";
    t.setAttribute("displaystyle", s), t.setAttribute("scriptlevel", "0");
  }
  if (n.leftDelim != null || n.rightDelim != null) {
    var o = [];
    if (n.leftDelim != null) {
      var l = new ne.MathNode("mo", [new ne.TextNode(n.leftDelim.replace("\\", ""))]);
      l.setAttribute("fence", "true"), o.push(l);
    }
    if (o.push(t), n.rightDelim != null) {
      var a = new ne.MathNode("mo", [new ne.TextNode(n.rightDelim.replace("\\", ""))]);
      a.setAttribute("fence", "true"), o.push(a);
    }
    return m7(o);
  }
  return t;
};
be({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = e[1], o, l = null, a = null, c = "auto";
    switch (r) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        o = !0;
        break;
      case "\\\\atopfrac":
        o = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        o = !1, l = "(", a = ")";
        break;
      case "\\\\bracefrac":
        o = !1, l = "\\{", a = "\\}";
        break;
      case "\\\\brackfrac":
        o = !1, l = "[", a = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (r) {
      case "\\dfrac":
      case "\\dbinom":
        c = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        c = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !1,
      numer: i,
      denom: s,
      hasBarLine: o,
      leftDelim: l,
      rightDelim: a,
      size: c,
      barSize: null
    };
  },
  htmlBuilder: C7,
  mathmlBuilder: M7
});
be({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = e[1];
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !0,
      numer: i,
      denom: s,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
be({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t,
      token: r
    } = n, i;
    switch (t) {
      case "\\over":
        i = "\\frac";
        break;
      case "\\choose":
        i = "\\binom";
        break;
      case "\\atop":
        i = "\\\\atopfrac";
        break;
      case "\\brace":
        i = "\\\\bracefrac";
        break;
      case "\\brack":
        i = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: e.mode,
      replaceWith: i,
      token: r
    };
  }
});
var M9 = ["display", "text", "script", "scriptscript"], T9 = function(e) {
  var t = null;
  return e.length > 0 && (t = e, t = t === "." ? null : t), t;
};
be({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = e[4], i = e[5], s = Gm(e[0]), o = s.type === "atom" && s.family === "open" ? T9(s.text) : null, l = Gm(e[1]), a = l.type === "atom" && l.family === "close" ? T9(l.text) : null, c = Qe(e[2], "size"), u, h = null;
    c.isBlank ? u = !0 : (h = c.value, u = h.number > 0);
    var f = "auto", d = e[3];
    if (d.type === "ordgroup") {
      if (d.body.length > 0) {
        var p = Qe(d.body[0], "textord");
        f = M9[Number(p.text)];
      }
    } else
      d = Qe(d, "textord"), f = M9[Number(d.text)];
    return {
      type: "genfrac",
      mode: t.mode,
      numer: r,
      denom: i,
      continued: !1,
      hasBarLine: u,
      barSize: h,
      leftDelim: o,
      rightDelim: a,
      size: f
    };
  },
  htmlBuilder: C7,
  mathmlBuilder: M7
});
be({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r,
      token: i
    } = n;
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: "\\\\abovefrac",
      size: Qe(e[0], "size").value,
      token: i
    };
  }
});
be({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = jse(Qe(e[1], "infix").size), o = e[2], l = s.number > 0;
    return {
      type: "genfrac",
      mode: t.mode,
      numer: i,
      denom: o,
      continued: !1,
      hasBarLine: l,
      barSize: s,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: C7,
  mathmlBuilder: M7
});
var vN = (n, e) => {
  var t = e.style, r, i;
  n.type === "supsub" ? (r = n.sup ? ht(n.sup, e.havingStyle(t.sup()), e) : ht(n.sub, e.havingStyle(t.sub()), e), i = Qe(n.base, "horizBrace")) : i = Qe(n, "horizBrace");
  var s = ht(i.base, e.havingBaseStyle(We.DISPLAY)), o = go.svgSpan(i, e), l;
  if (i.isOver ? (l = H.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: s
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: o
    }]
  }, e), l.children[0].children[0].children[1].classes.push("svg-align")) : (l = H.makeVList({
    positionType: "bottom",
    positionData: s.depth + 0.1 + o.height,
    children: [{
      type: "elem",
      elem: o
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: s
    }]
  }, e), l.children[0].children[0].children[0].classes.push("svg-align")), r) {
    var a = H.makeSpan(["mord", i.isOver ? "mover" : "munder"], [l], e);
    i.isOver ? l = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: r
      }]
    }, e) : l = H.makeVList({
      positionType: "bottom",
      positionData: a.depth + 0.2 + r.height + r.depth,
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: a
      }]
    }, e);
  }
  return H.makeSpan(["mord", i.isOver ? "mover" : "munder"], [l], e);
}, gle = (n, e) => {
  var t = go.mathMLnode(n.label);
  return new ne.MathNode(n.isOver ? "mover" : "munder", [Nt(n.base, e), t]);
};
be({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n;
    return {
      type: "horizBrace",
      mode: t.mode,
      label: r,
      isOver: /^\\over/.test(r),
      base: e[0]
    };
  },
  htmlBuilder: vN,
  mathmlBuilder: gle
});
be({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[1], i = Qe(e[0], "url").url;
    return t.settings.isTrusted({
      command: "\\href",
      url: i
    }) ? {
      type: "href",
      mode: t.mode,
      href: i,
      body: cn(r)
    } : t.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.body, e, !1);
    return H.makeAnchor(n.href, [], t, e);
  },
  mathmlBuilder: (n, e) => {
    var t = vl(n.body, e);
    return t instanceof Gr || (t = new Gr("mrow", [t])), t.setAttribute("href", n.href), t;
  }
});
be({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = Qe(e[0], "url").url;
    if (!t.settings.isTrusted({
      command: "\\url",
      url: r
    }))
      return t.formatUnsupportedCmd("\\url");
    for (var i = [], s = 0; s < r.length; s++) {
      var o = r[s];
      o === "~" && (o = "\\textasciitilde"), i.push({
        type: "textord",
        mode: "text",
        text: o
      });
    }
    var l = {
      type: "text",
      mode: t.mode,
      font: "\\texttt",
      body: i
    };
    return {
      type: "href",
      mode: t.mode,
      href: r,
      body: cn(l)
    };
  }
});
be({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "hbox",
      mode: t.mode,
      body: cn(e[0])
    };
  },
  htmlBuilder(n, e) {
    var t = xn(n.body, e, !1);
    return H.makeFragment(t);
  },
  mathmlBuilder(n, e) {
    return new ne.MathNode("mrow", Pr(n.body, e));
  }
});
be({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r,
      token: i
    } = n, s = Qe(e[0], "raw").string, o = e[1];
    t.settings.strict && t.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var l, a = {};
    switch (r) {
      case "\\htmlClass":
        a.class = s, l = {
          command: "\\htmlClass",
          class: s
        };
        break;
      case "\\htmlId":
        a.id = s, l = {
          command: "\\htmlId",
          id: s
        };
        break;
      case "\\htmlStyle":
        a.style = s, l = {
          command: "\\htmlStyle",
          style: s
        };
        break;
      case "\\htmlData": {
        for (var c = s.split(","), u = 0; u < c.length; u++) {
          var h = c[u].split("=");
          if (h.length !== 2)
            throw new se("Error parsing key-value for \\htmlData");
          a["data-" + h[0].trim()] = h[1].trim();
        }
        l = {
          command: "\\htmlData",
          attributes: a
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return t.settings.isTrusted(l) ? {
      type: "html",
      mode: t.mode,
      attributes: a,
      body: cn(o)
    } : t.formatUnsupportedCmd(r);
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.body, e, !1), r = ["enclosing"];
    n.attributes.class && r.push(...n.attributes.class.trim().split(/\s+/));
    var i = H.makeSpan(r, t, e);
    for (var s in n.attributes)
      s !== "class" && n.attributes.hasOwnProperty(s) && i.setAttribute(s, n.attributes[s]);
    return i;
  },
  mathmlBuilder: (n, e) => vl(n.body, e)
});
be({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n;
    return {
      type: "htmlmathml",
      mode: t.mode,
      html: cn(e[0]),
      mathml: cn(e[1])
    };
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.html, e, !1);
    return H.makeFragment(t);
  },
  mathmlBuilder: (n, e) => vl(n.mathml, e)
});
var m4 = function(e) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e))
    return {
      number: +e,
      unit: "bp"
    };
  var t = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
  if (!t)
    throw new se("Invalid size: '" + e + "' in \\includegraphics");
  var r = {
    number: +(t[1] + t[2]),
    // sign + magnitude, cast to number
    unit: t[3]
  };
  if (!zD(r))
    throw new se("Invalid unit: '" + r.unit + "' in \\includegraphics.");
  return r;
};
be({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (n, e, t) => {
    var {
      parser: r
    } = n, i = {
      number: 0,
      unit: "em"
    }, s = {
      number: 0.9,
      unit: "em"
    }, o = {
      number: 0,
      unit: "em"
    }, l = "";
    if (t[0])
      for (var a = Qe(t[0], "raw").string, c = a.split(","), u = 0; u < c.length; u++) {
        var h = c[u].split("=");
        if (h.length === 2) {
          var f = h[1].trim();
          switch (h[0].trim()) {
            case "alt":
              l = f;
              break;
            case "width":
              i = m4(f);
              break;
            case "height":
              s = m4(f);
              break;
            case "totalheight":
              o = m4(f);
              break;
            default:
              throw new se("Invalid key: '" + h[0] + "' in \\includegraphics.");
          }
        }
      }
    var d = Qe(e[0], "url").url;
    return l === "" && (l = d, l = l.replace(/^.*[\\/]/, ""), l = l.substring(0, l.lastIndexOf("."))), r.settings.isTrusted({
      command: "\\includegraphics",
      url: d
    }) ? {
      type: "includegraphics",
      mode: r.mode,
      alt: l,
      width: i,
      height: s,
      totalheight: o,
      src: d
    } : r.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (n, e) => {
    var t = Qt(n.height, e), r = 0;
    n.totalheight.number > 0 && (r = Qt(n.totalheight, e) - t);
    var i = 0;
    n.width.number > 0 && (i = Qt(n.width, e));
    var s = {
      height: fe(t + r)
    };
    i > 0 && (s.width = fe(i)), r > 0 && (s.verticalAlign = fe(-r));
    var o = new goe(n.src, n.alt, s);
    return o.height = t, o.depth = r, o;
  },
  mathmlBuilder: (n, e) => {
    var t = new ne.MathNode("mglyph", []);
    t.setAttribute("alt", n.alt);
    var r = Qt(n.height, e), i = 0;
    if (n.totalheight.number > 0 && (i = Qt(n.totalheight, e) - r, t.setAttribute("valign", fe(-i))), t.setAttribute("height", fe(r + i)), n.width.number > 0) {
      var s = Qt(n.width, e);
      t.setAttribute("width", fe(s));
    }
    return t.setAttribute("src", n.src), t;
  }
});
be({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = Qe(e[0], "size");
    if (t.settings.strict) {
      var s = r[1] === "m", o = i.value.unit === "mu";
      s ? (o || t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " supports only mu units, " + ("not " + i.value.unit + " units")), t.mode !== "math" && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " works only in math mode")) : o && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: t.mode,
      dimension: i.value
    };
  },
  htmlBuilder(n, e) {
    return H.makeGlue(n.dimension, e);
  },
  mathmlBuilder(n, e) {
    var t = Qt(n.dimension, e);
    return new ne.SpaceNode(t);
  }
});
be({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "lap",
      mode: t.mode,
      alignment: r.slice(5),
      body: i
    };
  },
  htmlBuilder: (n, e) => {
    var t;
    n.alignment === "clap" ? (t = H.makeSpan([], [ht(n.body, e)]), t = H.makeSpan(["inner"], [t], e)) : t = H.makeSpan(["inner"], [ht(n.body, e)]);
    var r = H.makeSpan(["fix"], []), i = H.makeSpan([n.alignment], [t, r], e), s = H.makeSpan(["strut"]);
    return s.style.height = fe(i.height + i.depth), i.depth && (s.style.verticalAlign = fe(-i.depth)), i.children.unshift(s), i = H.makeSpan(["thinbox"], [i], e), H.makeSpan(["mord", "vbox"], [i], e);
  },
  mathmlBuilder: (n, e) => {
    var t = new ne.MathNode("mpadded", [Nt(n.body, e)]);
    if (n.alignment !== "rlap") {
      var r = n.alignment === "llap" ? "-1" : "-0.5";
      t.setAttribute("lspace", r + "width");
    }
    return t.setAttribute("width", "0px"), t;
  }
});
be({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(n, e) {
    var {
      funcName: t,
      parser: r
    } = n, i = r.mode;
    r.switchMode("math");
    var s = t === "\\(" ? "\\)" : "$", o = r.parseExpression(!1, s);
    return r.expect(s), r.switchMode(i), {
      type: "styling",
      mode: r.mode,
      style: "text",
      body: o
    };
  }
});
be({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(n, e) {
    throw new se("Mismatched " + n.funcName);
  }
});
var A9 = (n, e) => {
  switch (e.style.size) {
    case We.DISPLAY.size:
      return n.display;
    case We.TEXT.size:
      return n.text;
    case We.SCRIPT.size:
      return n.script;
    case We.SCRIPTSCRIPT.size:
      return n.scriptscript;
    default:
      return n.text;
  }
};
be({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n;
    return {
      type: "mathchoice",
      mode: t.mode,
      display: cn(e[0]),
      text: cn(e[1]),
      script: cn(e[2]),
      scriptscript: cn(e[3])
    };
  },
  htmlBuilder: (n, e) => {
    var t = A9(n, e), r = xn(t, e, !1);
    return H.makeFragment(r);
  },
  mathmlBuilder: (n, e) => {
    var t = A9(n, e);
    return vl(t, e);
  }
});
var wN = (n, e, t, r, i, s, o) => {
  n = H.makeSpan([], [n]);
  var l = t && Be.isCharacterBox(t), a, c;
  if (e) {
    var u = ht(e, r.havingStyle(i.sup()), r);
    c = {
      elem: u,
      kern: Math.max(r.fontMetrics().bigOpSpacing1, r.fontMetrics().bigOpSpacing3 - u.depth)
    };
  }
  if (t) {
    var h = ht(t, r.havingStyle(i.sub()), r);
    a = {
      elem: h,
      kern: Math.max(r.fontMetrics().bigOpSpacing2, r.fontMetrics().bigOpSpacing4 - h.height)
    };
  }
  var f;
  if (c && a) {
    var d = r.fontMetrics().bigOpSpacing5 + a.elem.height + a.elem.depth + a.kern + n.depth + o;
    f = H.makeVList({
      positionType: "bottom",
      positionData: d,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: a.elem,
        marginLeft: fe(-s)
      }, {
        type: "kern",
        size: a.kern
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: fe(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else if (a) {
    var p = n.height - o;
    f = H.makeVList({
      positionType: "top",
      positionData: p,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: a.elem,
        marginLeft: fe(-s)
      }, {
        type: "kern",
        size: a.kern
      }, {
        type: "elem",
        elem: n
      }]
    }, r);
  } else if (c) {
    var m = n.depth + o;
    f = H.makeVList({
      positionType: "bottom",
      positionData: m,
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: fe(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else
    return n;
  var g = [f];
  if (a && s !== 0 && !l) {
    var b = H.makeSpan(["mspace"], [], r);
    b.style.marginRight = fe(s), g.unshift(b);
  }
  return H.makeSpan(["mop", "op-limits"], g, r);
}, xN = ["\\smallint"], gu = (n, e) => {
  var t, r, i = !1, s;
  n.type === "supsub" ? (t = n.sup, r = n.sub, s = Qe(n.base, "op"), i = !0) : s = Qe(n, "op");
  var o = e.style, l = !1;
  o.size === We.DISPLAY.size && s.symbol && !Be.contains(xN, s.name) && (l = !0);
  var a;
  if (s.symbol) {
    var c = l ? "Size2-Regular" : "Size1-Regular", u = "";
    if ((s.name === "\\oiint" || s.name === "\\oiiint") && (u = s.name.slice(1), s.name = u === "oiint" ? "\\iint" : "\\iiint"), a = H.makeSymbol(s.name, c, "math", e, ["mop", "op-symbol", l ? "large-op" : "small-op"]), u.length > 0) {
      var h = a.italic, f = H.staticSvg(u + "Size" + (l ? "2" : "1"), e);
      a = H.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: a,
          shift: 0
        }, {
          type: "elem",
          elem: f,
          shift: l ? 0.08 : 0
        }]
      }, e), s.name = "\\" + u, a.classes.unshift("mop"), a.italic = h;
    }
  } else if (s.body) {
    var d = xn(s.body, e, !0);
    d.length === 1 && d[0] instanceof xi ? (a = d[0], a.classes[0] = "mop") : a = H.makeSpan(["mop"], d, e);
  } else {
    for (var p = [], m = 1; m < s.name.length; m++)
      p.push(H.mathsym(s.name[m], s.mode, e));
    a = H.makeSpan(["mop"], p, e);
  }
  var g = 0, b = 0;
  return (a instanceof xi || s.name === "\\oiint" || s.name === "\\oiiint") && !s.suppressBaseShift && (g = (a.height - a.depth) / 2 - e.fontMetrics().axisHeight, b = a.italic), i ? wN(a, t, r, e, o, b, g) : (g && (a.style.position = "relative", a.style.top = fe(g)), a);
}, Bd = (n, e) => {
  var t;
  if (n.symbol)
    t = new Gr("mo", [ki(n.name, n.mode)]), Be.contains(xN, n.name) && t.setAttribute("largeop", "false");
  else if (n.body)
    t = new Gr("mo", Pr(n.body, e));
  else {
    t = new Gr("mi", [new ms(n.name.slice(1))]);
    var r = new Gr("mo", [ki("⁡", "text")]);
    n.parentIsSupSub ? t = new Gr("mrow", [t, r]) : t = YD([t, r]);
  }
  return t;
}, yle = {
  "∏": "\\prod",
  "∐": "\\coprod",
  "∑": "\\sum",
  "⋀": "\\bigwedge",
  "⋁": "\\bigvee",
  "⋂": "\\bigcap",
  "⋃": "\\bigcup",
  "⨀": "\\bigodot",
  "⨁": "\\bigoplus",
  "⨂": "\\bigotimes",
  "⨄": "\\biguplus",
  "⨆": "\\bigsqcup"
};
be({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
  props: {
    numArgs: 0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = r;
    return i.length === 1 && (i = yle[i]), {
      type: "op",
      mode: t.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: i
    };
  },
  htmlBuilder: gu,
  mathmlBuilder: Bd
});
be({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: cn(r)
    };
  },
  htmlBuilder: gu,
  mathmlBuilder: Bd
});
var ble = {
  "∫": "\\int",
  "∬": "\\iint",
  "∭": "\\iiint",
  "∮": "\\oint",
  "∯": "\\oiint",
  "∰": "\\oiiint"
};
be({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    return {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: gu,
  mathmlBuilder: Bd
});
be({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    return {
      type: "op",
      mode: e.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: gu,
  mathmlBuilder: Bd
});
be({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = t;
    return r.length === 1 && (r = ble[r]), {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: r
    };
  },
  htmlBuilder: gu,
  mathmlBuilder: Bd
});
var kN = (n, e) => {
  var t, r, i = !1, s;
  n.type === "supsub" ? (t = n.sup, r = n.sub, s = Qe(n.base, "operatorname"), i = !0) : s = Qe(n, "operatorname");
  var o;
  if (s.body.length > 0) {
    for (var l = s.body.map((h) => {
      var f = h.text;
      return typeof f == "string" ? {
        type: "textord",
        mode: h.mode,
        text: f
      } : h;
    }), a = xn(l, e.withFont("mathrm"), !0), c = 0; c < a.length; c++) {
      var u = a[c];
      u instanceof xi && (u.text = u.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    o = H.makeSpan(["mop"], a, e);
  } else
    o = H.makeSpan(["mop"], [], e);
  return i ? wN(o, t, r, e, e.style, 0, 0) : o;
}, vle = (n, e) => {
  for (var t = Pr(n.body, e.withFont("mathrm")), r = !0, i = 0; i < t.length; i++) {
    var s = t[i];
    if (!(s instanceof ne.SpaceNode)) if (s instanceof ne.MathNode)
      switch (s.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        // Do nothing yet.
        case "mo": {
          var o = s.children[0];
          s.children.length === 1 && o instanceof ne.TextNode ? o.text = o.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : r = !1;
          break;
        }
        default:
          r = !1;
      }
    else
      r = !1;
  }
  if (r) {
    var l = t.map((u) => u.toText()).join("");
    t = [new ne.TextNode(l)];
  }
  var a = new ne.MathNode("mi", t);
  a.setAttribute("mathvariant", "normal");
  var c = new ne.MathNode("mo", [ki("⁡", "text")]);
  return n.parentIsSupSub ? new ne.MathNode("mrow", [a, c]) : ne.newDocumentFragment([a, c]);
};
be({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "operatorname",
      mode: t.mode,
      body: cn(i),
      alwaysHandleSupSub: r === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: kN,
  mathmlBuilder: vle
});
S("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
$a({
  type: "ordgroup",
  htmlBuilder(n, e) {
    return n.semisimple ? H.makeFragment(xn(n.body, e, !1)) : H.makeSpan(["mord"], xn(n.body, e, !0), e);
  },
  mathmlBuilder(n, e) {
    return vl(n.body, e, !0);
  }
});
be({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "overline",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder(n, e) {
    var t = ht(n.body, e.havingCrampedStyle()), r = H.makeLineSpan("overline-line", e), i = e.fontMetrics().defaultRuleThickness, s = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: i
      }]
    }, e);
    return H.makeSpan(["mord", "overline"], [s], e);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mo", [new ne.TextNode("‾")]);
    t.setAttribute("stretchy", "true");
    var r = new ne.MathNode("mover", [Nt(n.body, e), t]);
    return r.setAttribute("accent", "true"), r;
  }
});
be({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "phantom",
      mode: t.mode,
      body: cn(r)
    };
  },
  htmlBuilder: (n, e) => {
    var t = xn(n.body, e.withPhantom(), !1);
    return H.makeFragment(t);
  },
  mathmlBuilder: (n, e) => {
    var t = Pr(n.body, e);
    return new ne.MathNode("mphantom", t);
  }
});
be({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "hphantom",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder: (n, e) => {
    var t = H.makeSpan([], [ht(n.body, e.withPhantom())]);
    if (t.height = 0, t.depth = 0, t.children)
      for (var r = 0; r < t.children.length; r++)
        t.children[r].height = 0, t.children[r].depth = 0;
    return t = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e), H.makeSpan(["mord"], [t], e);
  },
  mathmlBuilder: (n, e) => {
    var t = Pr(cn(n.body), e), r = new ne.MathNode("mphantom", t), i = new ne.MathNode("mpadded", [r]);
    return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
  }
});
be({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "vphantom",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder: (n, e) => {
    var t = H.makeSpan(["inner"], [ht(n.body, e.withPhantom())]), r = H.makeSpan(["fix"], []);
    return H.makeSpan(["mord", "rlap"], [t, r], e);
  },
  mathmlBuilder: (n, e) => {
    var t = Pr(cn(n.body), e), r = new ne.MathNode("mphantom", t), i = new ne.MathNode("mpadded", [r]);
    return i.setAttribute("width", "0px"), i;
  }
});
be({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = Qe(e[0], "size").value, i = e[1];
    return {
      type: "raisebox",
      mode: t.mode,
      dy: r,
      body: i
    };
  },
  htmlBuilder(n, e) {
    var t = ht(n.body, e), r = Qt(n.dy, e);
    return H.makeVList({
      positionType: "shift",
      positionData: -r,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mpadded", [Nt(n.body, e)]), r = n.dy.number + n.dy.unit;
    return t.setAttribute("voffset", r), t;
  }
});
be({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInArgument: !0
  },
  handler(n) {
    var {
      parser: e
    } = n;
    return {
      type: "internal",
      mode: e.mode
    };
  }
});
be({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    argTypes: ["size", "size", "size"]
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = t[0], s = Qe(e[0], "size"), o = Qe(e[1], "size");
    return {
      type: "rule",
      mode: r.mode,
      shift: i && Qe(i, "size").value,
      width: s.value,
      height: o.value
    };
  },
  htmlBuilder(n, e) {
    var t = H.makeSpan(["mord", "rule"], [], e), r = Qt(n.width, e), i = Qt(n.height, e), s = n.shift ? Qt(n.shift, e) : 0;
    return t.style.borderRightWidth = fe(r), t.style.borderTopWidth = fe(i), t.style.bottom = fe(s), t.width = r, t.height = i + s, t.depth = -s, t.maxFontSize = i * 1.125 * e.sizeMultiplier, t;
  },
  mathmlBuilder(n, e) {
    var t = Qt(n.width, e), r = Qt(n.height, e), i = n.shift ? Qt(n.shift, e) : 0, s = e.color && e.getColor() || "black", o = new ne.MathNode("mspace");
    o.setAttribute("mathbackground", s), o.setAttribute("width", fe(t)), o.setAttribute("height", fe(r));
    var l = new ne.MathNode("mpadded", [o]);
    return i >= 0 ? l.setAttribute("height", fe(i)) : (l.setAttribute("height", fe(i)), l.setAttribute("depth", fe(-i))), l.setAttribute("voffset", fe(i)), l;
  }
});
function SN(n, e, t) {
  for (var r = xn(n, e, !1), i = e.sizeMultiplier / t.sizeMultiplier, s = 0; s < r.length; s++) {
    var o = r[s].classes.indexOf("sizing");
    o < 0 ? Array.prototype.push.apply(r[s].classes, e.sizingClasses(t)) : r[s].classes[o + 1] === "reset-size" + e.size && (r[s].classes[o + 1] = "reset-size" + t.size), r[s].height *= i, r[s].depth *= i;
  }
  return H.makeFragment(r);
}
var O9 = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], wle = (n, e) => {
  var t = e.havingSize(n.size);
  return SN(n.body, t, e);
};
be({
  type: "sizing",
  names: O9,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      breakOnTokenText: t,
      funcName: r,
      parser: i
    } = n, s = i.parseExpression(!1, t);
    return {
      type: "sizing",
      mode: i.mode,
      // Figure out what size to use based on the list of functions above
      size: O9.indexOf(r) + 1,
      body: s
    };
  },
  htmlBuilder: wle,
  mathmlBuilder: (n, e) => {
    var t = e.havingSize(n.size), r = Pr(n.body, t), i = new ne.MathNode("mstyle", r);
    return i.setAttribute("mathsize", fe(t.sizeMultiplier)), i;
  }
});
be({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (n, e, t) => {
    var {
      parser: r
    } = n, i = !1, s = !1, o = t[0] && Qe(t[0], "ordgroup");
    if (o)
      for (var l = "", a = 0; a < o.body.length; ++a) {
        var c = o.body[a];
        if (l = c.text, l === "t")
          i = !0;
        else if (l === "b")
          s = !0;
        else {
          i = !1, s = !1;
          break;
        }
      }
    else
      i = !0, s = !0;
    var u = e[0];
    return {
      type: "smash",
      mode: r.mode,
      body: u,
      smashHeight: i,
      smashDepth: s
    };
  },
  htmlBuilder: (n, e) => {
    var t = H.makeSpan([], [ht(n.body, e)]);
    if (!n.smashHeight && !n.smashDepth)
      return t;
    if (n.smashHeight && (t.height = 0, t.children))
      for (var r = 0; r < t.children.length; r++)
        t.children[r].height = 0;
    if (n.smashDepth && (t.depth = 0, t.children))
      for (var i = 0; i < t.children.length; i++)
        t.children[i].depth = 0;
    var s = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
    return H.makeSpan(["mord"], [s], e);
  },
  mathmlBuilder: (n, e) => {
    var t = new ne.MathNode("mpadded", [Nt(n.body, e)]);
    return n.smashHeight && t.setAttribute("height", "0px"), n.smashDepth && t.setAttribute("depth", "0px"), t;
  }
});
be({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = t[0], s = e[0];
    return {
      type: "sqrt",
      mode: r.mode,
      body: s,
      index: i
    };
  },
  htmlBuilder(n, e) {
    var t = ht(n.body, e.havingCrampedStyle());
    t.height === 0 && (t.height = e.fontMetrics().xHeight), t = H.wrapFragment(t, e);
    var r = e.fontMetrics(), i = r.defaultRuleThickness, s = i;
    e.style.id < We.TEXT.id && (s = e.fontMetrics().xHeight);
    var o = i + s / 4, l = t.height + t.depth + o + i, {
      span: a,
      ruleWidth: c,
      advanceWidth: u
    } = oo.sqrtImage(l, e), h = a.height - c;
    h > t.height + t.depth + o && (o = (o + h - t.height - t.depth) / 2);
    var f = a.height - t.height - o - c;
    t.style.paddingLeft = fe(u);
    var d = H.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(t.height + f)
      }, {
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: c
      }]
    }, e);
    if (n.index) {
      var p = e.havingStyle(We.SCRIPTSCRIPT), m = ht(n.index, p, e), g = 0.6 * (d.height - d.depth), b = H.makeVList({
        positionType: "shift",
        positionData: -g,
        children: [{
          type: "elem",
          elem: m
        }]
      }, e), w = H.makeSpan(["root"], [b]);
      return H.makeSpan(["mord", "sqrt"], [w, d], e);
    } else
      return H.makeSpan(["mord", "sqrt"], [d], e);
  },
  mathmlBuilder(n, e) {
    var {
      body: t,
      index: r
    } = n;
    return r ? new ne.MathNode("mroot", [Nt(t, e), Nt(r, e)]) : new ne.MathNode("msqrt", [Nt(t, e)]);
  }
});
var E9 = {
  display: We.DISPLAY,
  text: We.TEXT,
  script: We.SCRIPT,
  scriptscript: We.SCRIPTSCRIPT
};
be({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n, e) {
    var {
      breakOnTokenText: t,
      funcName: r,
      parser: i
    } = n, s = i.parseExpression(!0, t), o = r.slice(1, r.length - 5);
    return {
      type: "styling",
      mode: i.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: o,
      body: s
    };
  },
  htmlBuilder(n, e) {
    var t = E9[n.style], r = e.havingStyle(t).withFont("");
    return SN(n.body, r, e);
  },
  mathmlBuilder(n, e) {
    var t = E9[n.style], r = e.havingStyle(t), i = Pr(n.body, r), s = new ne.MathNode("mstyle", i), o = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, l = o[n.style];
    return s.setAttribute("scriptlevel", l[0]), s.setAttribute("displaystyle", l[1]), s;
  }
});
var xle = function(e, t) {
  var r = e.base;
  if (r)
    if (r.type === "op") {
      var i = r.limits && (t.style.size === We.DISPLAY.size || r.alwaysHandleSupSub);
      return i ? gu : null;
    } else if (r.type === "operatorname") {
      var s = r.alwaysHandleSupSub && (t.style.size === We.DISPLAY.size || r.limits);
      return s ? kN : null;
    } else {
      if (r.type === "accent")
        return Be.isCharacterBox(r.base) ? b7 : null;
      if (r.type === "horizBrace") {
        var o = !e.sub;
        return o === r.isOver ? vN : null;
      } else
        return null;
    }
  else return null;
};
$a({
  type: "supsub",
  htmlBuilder(n, e) {
    var t = xle(n, e);
    if (t)
      return t(n, e);
    var {
      base: r,
      sup: i,
      sub: s
    } = n, o = ht(r, e), l, a, c = e.fontMetrics(), u = 0, h = 0, f = r && Be.isCharacterBox(r);
    if (i) {
      var d = e.havingStyle(e.style.sup());
      l = ht(i, d, e), f || (u = o.height - d.fontMetrics().supDrop * d.sizeMultiplier / e.sizeMultiplier);
    }
    if (s) {
      var p = e.havingStyle(e.style.sub());
      a = ht(s, p, e), f || (h = o.depth + p.fontMetrics().subDrop * p.sizeMultiplier / e.sizeMultiplier);
    }
    var m;
    e.style === We.DISPLAY ? m = c.sup1 : e.style.cramped ? m = c.sup3 : m = c.sup2;
    var g = e.sizeMultiplier, b = fe(0.5 / c.ptPerEm / g), w = null;
    if (a) {
      var k = n.base && n.base.type === "op" && n.base.name && (n.base.name === "\\oiint" || n.base.name === "\\oiiint");
      (o instanceof xi || k) && (w = fe(-o.italic));
    }
    var C;
    if (l && a) {
      u = Math.max(u, m, l.depth + 0.25 * c.xHeight), h = Math.max(h, c.sub2);
      var M = c.defaultRuleThickness, T = 4 * M;
      if (u - l.depth - (a.height - h) < T) {
        h = T - (u - l.depth) + a.height;
        var N = 0.8 * c.xHeight - (u - l.depth);
        N > 0 && (u += N, h -= N);
      }
      var B = [{
        type: "elem",
        elem: a,
        shift: h,
        marginRight: b,
        marginLeft: w
      }, {
        type: "elem",
        elem: l,
        shift: -u,
        marginRight: b
      }];
      C = H.makeVList({
        positionType: "individualShift",
        children: B
      }, e);
    } else if (a) {
      h = Math.max(h, c.sub1, a.height - 0.8 * c.xHeight);
      var $ = [{
        type: "elem",
        elem: a,
        marginLeft: w,
        marginRight: b
      }];
      C = H.makeVList({
        positionType: "shift",
        positionData: h,
        children: $
      }, e);
    } else if (l)
      u = Math.max(u, m, l.depth + 0.25 * c.xHeight), C = H.makeVList({
        positionType: "shift",
        positionData: -u,
        children: [{
          type: "elem",
          elem: l,
          marginRight: b
        }]
      }, e);
    else
      throw new Error("supsub must have either sup or sub.");
    var R = L5(o, "right") || "mord";
    return H.makeSpan([R], [o, H.makeSpan(["msupsub"], [C])], e);
  },
  mathmlBuilder(n, e) {
    var t = !1, r, i;
    n.base && n.base.type === "horizBrace" && (i = !!n.sup, i === n.base.isOver && (t = !0, r = n.base.isOver)), n.base && (n.base.type === "op" || n.base.type === "operatorname") && (n.base.parentIsSupSub = !0);
    var s = [Nt(n.base, e)];
    n.sub && s.push(Nt(n.sub, e)), n.sup && s.push(Nt(n.sup, e));
    var o;
    if (t)
      o = r ? "mover" : "munder";
    else if (n.sub)
      if (n.sup) {
        var c = n.base;
        c && c.type === "op" && c.limits && e.style === We.DISPLAY || c && c.type === "operatorname" && c.alwaysHandleSupSub && (e.style === We.DISPLAY || c.limits) ? o = "munderover" : o = "msubsup";
      } else {
        var a = n.base;
        a && a.type === "op" && a.limits && (e.style === We.DISPLAY || a.alwaysHandleSupSub) || a && a.type === "operatorname" && a.alwaysHandleSupSub && (a.limits || e.style === We.DISPLAY) ? o = "munder" : o = "msub";
      }
    else {
      var l = n.base;
      l && l.type === "op" && l.limits && (e.style === We.DISPLAY || l.alwaysHandleSupSub) || l && l.type === "operatorname" && l.alwaysHandleSupSub && (l.limits || e.style === We.DISPLAY) ? o = "mover" : o = "msup";
    }
    return new ne.MathNode(o, s);
  }
});
$a({
  type: "atom",
  htmlBuilder(n, e) {
    return H.mathsym(n.text, n.mode, e, ["m" + n.family]);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mo", [ki(n.text, n.mode)]);
    if (n.family === "bin") {
      var r = g7(n, e);
      r === "bold-italic" && t.setAttribute("mathvariant", r);
    } else n.family === "punct" ? t.setAttribute("separator", "true") : (n.family === "open" || n.family === "close") && t.setAttribute("stretchy", "false");
    return t;
  }
});
var CN = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
$a({
  type: "mathord",
  htmlBuilder(n, e) {
    return H.makeOrd(n, e, "mathord");
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mi", [ki(n.text, n.mode, e)]), r = g7(n, e) || "italic";
    return r !== CN[t.type] && t.setAttribute("mathvariant", r), t;
  }
});
$a({
  type: "textord",
  htmlBuilder(n, e) {
    return H.makeOrd(n, e, "textord");
  },
  mathmlBuilder(n, e) {
    var t = ki(n.text, n.mode, e), r = g7(n, e) || "normal", i;
    return n.mode === "text" ? i = new ne.MathNode("mtext", [t]) : /[0-9]/.test(n.text) ? i = new ne.MathNode("mn", [t]) : n.text === "\\prime" ? i = new ne.MathNode("mo", [t]) : i = new ne.MathNode("mi", [t]), r !== CN[i.type] && i.setAttribute("mathvariant", r), i;
  }
});
var g4 = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, y4 = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
$a({
  type: "spacing",
  htmlBuilder(n, e) {
    if (y4.hasOwnProperty(n.text)) {
      var t = y4[n.text].className || "";
      if (n.mode === "text") {
        var r = H.makeOrd(n, e, "textord");
        return r.classes.push(t), r;
      } else
        return H.makeSpan(["mspace", t], [H.mathsym(n.text, n.mode, e)], e);
    } else {
      if (g4.hasOwnProperty(n.text))
        return H.makeSpan(["mspace", g4[n.text]], [], e);
      throw new se('Unknown type of space "' + n.text + '"');
    }
  },
  mathmlBuilder(n, e) {
    var t;
    if (y4.hasOwnProperty(n.text))
      t = new ne.MathNode("mtext", [new ne.TextNode(" ")]);
    else {
      if (g4.hasOwnProperty(n.text))
        return new ne.MathNode("mspace");
      throw new se('Unknown type of space "' + n.text + '"');
    }
    return t;
  }
});
var I9 = () => {
  var n = new ne.MathNode("mtd", []);
  return n.setAttribute("width", "50%"), n;
};
$a({
  type: "tag",
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mtable", [new ne.MathNode("mtr", [I9(), new ne.MathNode("mtd", [vl(n.body, e)]), I9(), new ne.MathNode("mtd", [vl(n.tag, e)])])]);
    return t.setAttribute("width", "100%"), t;
  }
});
var D9 = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, N9 = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, kle = {
  "\\textit": "textit",
  "\\textup": "textup"
}, R9 = (n, e) => {
  var t = n.font;
  if (t) {
    if (D9[t])
      return e.withTextFontFamily(D9[t]);
    if (N9[t])
      return e.withTextFontWeight(N9[t]);
    if (t === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(kle[t]);
};
be({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "text",
      mode: t.mode,
      body: cn(i),
      font: r
    };
  },
  htmlBuilder(n, e) {
    var t = R9(n, e), r = xn(n.body, t, !0);
    return H.makeSpan(["mord", "text"], r, t);
  },
  mathmlBuilder(n, e) {
    var t = R9(n, e);
    return vl(n.body, t);
  }
});
be({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "underline",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = ht(n.body, e), r = H.makeLineSpan("underline-line", e), i = e.fontMetrics().defaultRuleThickness, s = H.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return H.makeSpan(["mord", "underline"], [s], e);
  },
  mathmlBuilder(n, e) {
    var t = new ne.MathNode("mo", [new ne.TextNode("‾")]);
    t.setAttribute("stretchy", "true");
    var r = new ne.MathNode("munder", [Nt(n.body, e), t]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
be({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "vcenter",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = ht(n.body, e), r = e.fontMetrics().axisHeight, i = 0.5 * (t.height - r - (t.depth + r));
    return H.makeVList({
      positionType: "shift",
      positionData: i,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(n, e) {
    return new ne.MathNode("mpadded", [Nt(n.body, e)], ["vcenter"]);
  }
});
be({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(n, e, t) {
    throw new se("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(n, e) {
    for (var t = P9(n), r = [], i = e.havingStyle(e.style.text()), s = 0; s < t.length; s++) {
      var o = t[s];
      o === "~" && (o = "\\textasciitilde"), r.push(H.makeSymbol(o, "Typewriter-Regular", n.mode, i, ["mord", "texttt"]));
    }
    return H.makeSpan(["mord", "text"].concat(i.sizingClasses(e)), H.tryCombineChars(r), i);
  },
  mathmlBuilder(n, e) {
    var t = new ne.TextNode(P9(n)), r = new ne.MathNode("mtext", [t]);
    return r.setAttribute("mathvariant", "monospace"), r;
  }
});
var P9 = (n) => n.body.replace(/ /g, n.star ? "␣" : " "), tl = KD, MN = `[ \r
	]`, Sle = "\\\\[a-zA-Z@]+", Cle = "\\\\[^\uD800-\uDFFF]", Mle = "(" + Sle + ")" + MN + "*", Tle = `\\\\(
|[ \r	]+
?)[ \r	]*`, H5 = "[̀-ͯ]", Ale = new RegExp(H5 + "+$"), Ole = "(" + MN + "+)|" + // whitespace
(Tle + "|") + // \whitespace
"([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
(H5 + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(H5 + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + Mle) + // \macroName + spaces
("|" + Cle + ")");
class _9 {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(e, t) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = e, this.settings = t, this.tokenRegex = new RegExp(Ole, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(e, t) {
    this.catcodes[e] = t;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var e = this.input, t = this.tokenRegex.lastIndex;
    if (t === e.length)
      return new yi("EOF", new Wr(this, t, t));
    var r = this.tokenRegex.exec(e);
    if (r === null || r.index !== t)
      throw new se("Unexpected character: '" + e[t] + "'", new yi(e[t], new Wr(this, t, t + 1)));
    var i = r[6] || r[3] || (r[2] ? "\\ " : " ");
    if (this.catcodes[i] === 14) {
      var s = e.indexOf(`
`, this.tokenRegex.lastIndex);
      return s === -1 ? (this.tokenRegex.lastIndex = e.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = s + 1, this.lex();
    }
    return new yi(i, new Wr(this, t, this.tokenRegex.lastIndex));
  }
}
class Ele {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(e, t) {
    e === void 0 && (e = {}), t === void 0 && (t = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = t, this.builtins = e, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new se("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var e = this.undefStack.pop();
    for (var t in e)
      e.hasOwnProperty(t) && (e[t] == null ? delete this.current[t] : this.current[t] = e[t]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(e) {
    return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(e) {
    return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(e, t, r) {
    if (r === void 0 && (r = !1), r) {
      for (var i = 0; i < this.undefStack.length; i++)
        delete this.undefStack[i][e];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = t);
    } else {
      var s = this.undefStack[this.undefStack.length - 1];
      s && !s.hasOwnProperty(e) && (s[e] = this.current[e]);
    }
    t == null ? delete this.current[e] : this.current[e] = t;
  }
}
var Ile = pN;
S("\\noexpand", function(n) {
  var e = n.popToken();
  return n.isExpandable(e.text) && (e.noexpand = !0, e.treatAsRelax = !0), {
    tokens: [e],
    numArgs: 0
  };
});
S("\\expandafter", function(n) {
  var e = n.popToken();
  return n.expandOnce(!0), {
    tokens: [e],
    numArgs: 0
  };
});
S("\\@firstoftwo", function(n) {
  var e = n.consumeArgs(2);
  return {
    tokens: e[0],
    numArgs: 0
  };
});
S("\\@secondoftwo", function(n) {
  var e = n.consumeArgs(2);
  return {
    tokens: e[1],
    numArgs: 0
  };
});
S("\\@ifnextchar", function(n) {
  var e = n.consumeArgs(3);
  n.consumeSpaces();
  var t = n.future();
  return e[0].length === 1 && e[0][0].text === t.text ? {
    tokens: e[1],
    numArgs: 0
  } : {
    tokens: e[2],
    numArgs: 0
  };
});
S("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
S("\\TextOrMath", function(n) {
  var e = n.consumeArgs(2);
  return n.mode === "text" ? {
    tokens: e[0],
    numArgs: 0
  } : {
    tokens: e[1],
    numArgs: 0
  };
});
var L9 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
S("\\char", function(n) {
  var e = n.popToken(), t, r = "";
  if (e.text === "'")
    t = 8, e = n.popToken();
  else if (e.text === '"')
    t = 16, e = n.popToken();
  else if (e.text === "`")
    if (e = n.popToken(), e.text[0] === "\\")
      r = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new se("\\char` missing argument");
      r = e.text.charCodeAt(0);
    }
  else
    t = 10;
  if (t) {
    if (r = L9[e.text], r == null || r >= t)
      throw new se("Invalid base-" + t + " digit " + e.text);
    for (var i; (i = L9[n.future().text]) != null && i < t; )
      r *= t, r += i, n.popToken();
  }
  return "\\@char{" + r + "}";
});
var T7 = (n, e, t, r) => {
  var i = n.consumeArg().tokens;
  if (i.length !== 1)
    throw new se("\\newcommand's first argument must be a macro name");
  var s = i[0].text, o = n.isDefined(s);
  if (o && !e)
    throw new se("\\newcommand{" + s + "} attempting to redefine " + (s + "; use \\renewcommand"));
  if (!o && !t)
    throw new se("\\renewcommand{" + s + "} when command " + s + " does not yet exist; use \\newcommand");
  var l = 0;
  if (i = n.consumeArg().tokens, i.length === 1 && i[0].text === "[") {
    for (var a = "", c = n.expandNextToken(); c.text !== "]" && c.text !== "EOF"; )
      a += c.text, c = n.expandNextToken();
    if (!a.match(/^\s*[0-9]+\s*$/))
      throw new se("Invalid number of arguments: " + a);
    l = parseInt(a), i = n.consumeArg().tokens;
  }
  return o && r || n.macros.set(s, {
    tokens: i,
    numArgs: l
  }), "";
};
S("\\newcommand", (n) => T7(n, !1, !0, !1));
S("\\renewcommand", (n) => T7(n, !0, !1, !1));
S("\\providecommand", (n) => T7(n, !0, !0, !0));
S("\\message", (n) => {
  var e = n.consumeArgs(1)[0];
  return console.log(e.reverse().map((t) => t.text).join("")), "";
});
S("\\errmessage", (n) => {
  var e = n.consumeArgs(1)[0];
  return console.error(e.reverse().map((t) => t.text).join("")), "";
});
S("\\show", (n) => {
  var e = n.popToken(), t = e.text;
  return console.log(e, n.macros.get(t), tl[t], zt.math[t], zt.text[t]), "";
});
S("\\bgroup", "{");
S("\\egroup", "}");
S("~", "\\nobreakspace");
S("\\lq", "`");
S("\\rq", "'");
S("\\aa", "\\r a");
S("\\AA", "\\r A");
S("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
S("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
S("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
S("ℬ", "\\mathscr{B}");
S("ℰ", "\\mathscr{E}");
S("ℱ", "\\mathscr{F}");
S("ℋ", "\\mathscr{H}");
S("ℐ", "\\mathscr{I}");
S("ℒ", "\\mathscr{L}");
S("ℳ", "\\mathscr{M}");
S("ℛ", "\\mathscr{R}");
S("ℭ", "\\mathfrak{C}");
S("ℌ", "\\mathfrak{H}");
S("ℨ", "\\mathfrak{Z}");
S("\\Bbbk", "\\Bbb{k}");
S("·", "\\cdotp");
S("\\llap", "\\mathllap{\\textrm{#1}}");
S("\\rlap", "\\mathrlap{\\textrm{#1}}");
S("\\clap", "\\mathclap{\\textrm{#1}}");
S("\\mathstrut", "\\vphantom{(}");
S("\\underbar", "\\underline{\\text{#1}}");
S("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
S("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
S("\\ne", "\\neq");
S("≠", "\\neq");
S("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
S("∉", "\\notin");
S("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
S("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
S("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
S("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
S("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
S("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
S("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
S("⟂", "\\perp");
S("‼", "\\mathclose{!\\mkern-0.8mu!}");
S("∌", "\\notni");
S("⌜", "\\ulcorner");
S("⌝", "\\urcorner");
S("⌞", "\\llcorner");
S("⌟", "\\lrcorner");
S("©", "\\copyright");
S("®", "\\textregistered");
S("️", "\\textregistered");
S("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
S("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
S("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
S("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
S("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
S("⋮", "\\vdots");
S("\\varGamma", "\\mathit{\\Gamma}");
S("\\varDelta", "\\mathit{\\Delta}");
S("\\varTheta", "\\mathit{\\Theta}");
S("\\varLambda", "\\mathit{\\Lambda}");
S("\\varXi", "\\mathit{\\Xi}");
S("\\varPi", "\\mathit{\\Pi}");
S("\\varSigma", "\\mathit{\\Sigma}");
S("\\varUpsilon", "\\mathit{\\Upsilon}");
S("\\varPhi", "\\mathit{\\Phi}");
S("\\varPsi", "\\mathit{\\Psi}");
S("\\varOmega", "\\mathit{\\Omega}");
S("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
S("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
S("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
S("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
S("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
S("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
S("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
S("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var B9 = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
S("\\dots", function(n) {
  var e = "\\dotso", t = n.expandAfterFuture().text;
  return t in B9 ? e = B9[t] : (t.slice(0, 4) === "\\not" || t in zt.math && Be.contains(["bin", "rel"], zt.math[t].group)) && (e = "\\dotsb"), e;
});
var A7 = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
S("\\dotso", function(n) {
  var e = n.future().text;
  return e in A7 ? "\\ldots\\," : "\\ldots";
});
S("\\dotsc", function(n) {
  var e = n.future().text;
  return e in A7 && e !== "," ? "\\ldots\\," : "\\ldots";
});
S("\\cdots", function(n) {
  var e = n.future().text;
  return e in A7 ? "\\@cdots\\," : "\\@cdots";
});
S("\\dotsb", "\\cdots");
S("\\dotsm", "\\cdots");
S("\\dotsi", "\\!\\cdots");
S("\\dotsx", "\\ldots\\,");
S("\\DOTSI", "\\relax");
S("\\DOTSB", "\\relax");
S("\\DOTSX", "\\relax");
S("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
S("\\,", "\\tmspace+{3mu}{.1667em}");
S("\\thinspace", "\\,");
S("\\>", "\\mskip{4mu}");
S("\\:", "\\tmspace+{4mu}{.2222em}");
S("\\medspace", "\\:");
S("\\;", "\\tmspace+{5mu}{.2777em}");
S("\\thickspace", "\\;");
S("\\!", "\\tmspace-{3mu}{.1667em}");
S("\\negthinspace", "\\!");
S("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
S("\\negthickspace", "\\tmspace-{5mu}{.277em}");
S("\\enspace", "\\kern.5em ");
S("\\enskip", "\\hskip.5em\\relax");
S("\\quad", "\\hskip1em\\relax");
S("\\qquad", "\\hskip2em\\relax");
S("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
S("\\tag@paren", "\\tag@literal{({#1})}");
S("\\tag@literal", (n) => {
  if (n.macros.get("\\df@tag"))
    throw new se("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
S("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
S("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
S("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
S("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
S("\\newline", "\\\\\\relax");
S("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var TN = fe(ps["Main-Regular"][84][1] - 0.7 * ps["Main-Regular"][65][1]);
S("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + TN + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
S("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + TN + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
S("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
S("\\@hspace", "\\hskip #1\\relax");
S("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
S("\\ordinarycolon", ":");
S("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
S("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
S("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
S("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
S("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
S("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
S("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
S("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
S("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
S("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
S("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
S("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
S("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
S("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
S("∷", "\\dblcolon");
S("∹", "\\eqcolon");
S("≔", "\\coloneqq");
S("≕", "\\eqqcolon");
S("⩴", "\\Coloneqq");
S("\\ratio", "\\vcentcolon");
S("\\coloncolon", "\\dblcolon");
S("\\colonequals", "\\coloneqq");
S("\\coloncolonequals", "\\Coloneqq");
S("\\equalscolon", "\\eqqcolon");
S("\\equalscoloncolon", "\\Eqqcolon");
S("\\colonminus", "\\coloneq");
S("\\coloncolonminus", "\\Coloneq");
S("\\minuscolon", "\\eqcolon");
S("\\minuscoloncolon", "\\Eqcolon");
S("\\coloncolonapprox", "\\Colonapprox");
S("\\coloncolonsim", "\\Colonsim");
S("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
S("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
S("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
S("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
S("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
S("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
S("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
S("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
S("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
S("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
S("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
S("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
S("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
S("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
S("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
S("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
S("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
S("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
S("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
S("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
S("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
S("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
S("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
S("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
S("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
S("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
S("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
S("\\imath", "\\html@mathml{\\@imath}{ı}");
S("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
S("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
S("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
S("⟦", "\\llbracket");
S("⟧", "\\rrbracket");
S("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
S("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
S("⦃", "\\lBrace");
S("⦄", "\\rBrace");
S("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
S("⦵", "\\minuso");
S("\\darr", "\\downarrow");
S("\\dArr", "\\Downarrow");
S("\\Darr", "\\Downarrow");
S("\\lang", "\\langle");
S("\\rang", "\\rangle");
S("\\uarr", "\\uparrow");
S("\\uArr", "\\Uparrow");
S("\\Uarr", "\\Uparrow");
S("\\N", "\\mathbb{N}");
S("\\R", "\\mathbb{R}");
S("\\Z", "\\mathbb{Z}");
S("\\alef", "\\aleph");
S("\\alefsym", "\\aleph");
S("\\Alpha", "\\mathrm{A}");
S("\\Beta", "\\mathrm{B}");
S("\\bull", "\\bullet");
S("\\Chi", "\\mathrm{X}");
S("\\clubs", "\\clubsuit");
S("\\cnums", "\\mathbb{C}");
S("\\Complex", "\\mathbb{C}");
S("\\Dagger", "\\ddagger");
S("\\diamonds", "\\diamondsuit");
S("\\empty", "\\emptyset");
S("\\Epsilon", "\\mathrm{E}");
S("\\Eta", "\\mathrm{H}");
S("\\exist", "\\exists");
S("\\harr", "\\leftrightarrow");
S("\\hArr", "\\Leftrightarrow");
S("\\Harr", "\\Leftrightarrow");
S("\\hearts", "\\heartsuit");
S("\\image", "\\Im");
S("\\infin", "\\infty");
S("\\Iota", "\\mathrm{I}");
S("\\isin", "\\in");
S("\\Kappa", "\\mathrm{K}");
S("\\larr", "\\leftarrow");
S("\\lArr", "\\Leftarrow");
S("\\Larr", "\\Leftarrow");
S("\\lrarr", "\\leftrightarrow");
S("\\lrArr", "\\Leftrightarrow");
S("\\Lrarr", "\\Leftrightarrow");
S("\\Mu", "\\mathrm{M}");
S("\\natnums", "\\mathbb{N}");
S("\\Nu", "\\mathrm{N}");
S("\\Omicron", "\\mathrm{O}");
S("\\plusmn", "\\pm");
S("\\rarr", "\\rightarrow");
S("\\rArr", "\\Rightarrow");
S("\\Rarr", "\\Rightarrow");
S("\\real", "\\Re");
S("\\reals", "\\mathbb{R}");
S("\\Reals", "\\mathbb{R}");
S("\\Rho", "\\mathrm{P}");
S("\\sdot", "\\cdot");
S("\\sect", "\\S");
S("\\spades", "\\spadesuit");
S("\\sub", "\\subset");
S("\\sube", "\\subseteq");
S("\\supe", "\\supseteq");
S("\\Tau", "\\mathrm{T}");
S("\\thetasym", "\\vartheta");
S("\\weierp", "\\wp");
S("\\Zeta", "\\mathrm{Z}");
S("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
S("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
S("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
S("\\bra", "\\mathinner{\\langle{#1}|}");
S("\\ket", "\\mathinner{|{#1}\\rangle}");
S("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
S("\\Bra", "\\left\\langle#1\\right|");
S("\\Ket", "\\left|#1\\right\\rangle");
var AN = (n) => (e) => {
  var t = e.consumeArg().tokens, r = e.consumeArg().tokens, i = e.consumeArg().tokens, s = e.consumeArg().tokens, o = e.macros.get("|"), l = e.macros.get("\\|");
  e.macros.beginGroup();
  var a = (h) => (f) => {
    n && (f.macros.set("|", o), i.length && f.macros.set("\\|", l));
    var d = h;
    if (!h && i.length) {
      var p = f.future();
      p.text === "|" && (f.popToken(), d = !0);
    }
    return {
      tokens: d ? i : r,
      numArgs: 0
    };
  };
  e.macros.set("|", a(!1)), i.length && e.macros.set("\\|", a(!0));
  var c = e.consumeArg().tokens, u = e.expandTokens([
    ...s,
    ...c,
    ...t
    // reversed
  ]);
  return e.macros.endGroup(), {
    tokens: u.reverse(),
    numArgs: 0
  };
};
S("\\bra@ket", AN(!1));
S("\\bra@set", AN(!0));
S("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
S("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
S("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
S("\\angln", "{\\angl n}");
S("\\blue", "\\textcolor{##6495ed}{#1}");
S("\\orange", "\\textcolor{##ffa500}{#1}");
S("\\pink", "\\textcolor{##ff00af}{#1}");
S("\\red", "\\textcolor{##df0030}{#1}");
S("\\green", "\\textcolor{##28ae7b}{#1}");
S("\\gray", "\\textcolor{gray}{#1}");
S("\\purple", "\\textcolor{##9d38bd}{#1}");
S("\\blueA", "\\textcolor{##ccfaff}{#1}");
S("\\blueB", "\\textcolor{##80f6ff}{#1}");
S("\\blueC", "\\textcolor{##63d9ea}{#1}");
S("\\blueD", "\\textcolor{##11accd}{#1}");
S("\\blueE", "\\textcolor{##0c7f99}{#1}");
S("\\tealA", "\\textcolor{##94fff5}{#1}");
S("\\tealB", "\\textcolor{##26edd5}{#1}");
S("\\tealC", "\\textcolor{##01d1c1}{#1}");
S("\\tealD", "\\textcolor{##01a995}{#1}");
S("\\tealE", "\\textcolor{##208170}{#1}");
S("\\greenA", "\\textcolor{##b6ffb0}{#1}");
S("\\greenB", "\\textcolor{##8af281}{#1}");
S("\\greenC", "\\textcolor{##74cf70}{#1}");
S("\\greenD", "\\textcolor{##1fab54}{#1}");
S("\\greenE", "\\textcolor{##0d923f}{#1}");
S("\\goldA", "\\textcolor{##ffd0a9}{#1}");
S("\\goldB", "\\textcolor{##ffbb71}{#1}");
S("\\goldC", "\\textcolor{##ff9c39}{#1}");
S("\\goldD", "\\textcolor{##e07d10}{#1}");
S("\\goldE", "\\textcolor{##a75a05}{#1}");
S("\\redA", "\\textcolor{##fca9a9}{#1}");
S("\\redB", "\\textcolor{##ff8482}{#1}");
S("\\redC", "\\textcolor{##f9685d}{#1}");
S("\\redD", "\\textcolor{##e84d39}{#1}");
S("\\redE", "\\textcolor{##bc2612}{#1}");
S("\\maroonA", "\\textcolor{##ffbde0}{#1}");
S("\\maroonB", "\\textcolor{##ff92c6}{#1}");
S("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
S("\\maroonD", "\\textcolor{##ca337c}{#1}");
S("\\maroonE", "\\textcolor{##9e034e}{#1}");
S("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
S("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
S("\\purpleC", "\\textcolor{##aa87ff}{#1}");
S("\\purpleD", "\\textcolor{##7854ab}{#1}");
S("\\purpleE", "\\textcolor{##543b78}{#1}");
S("\\mintA", "\\textcolor{##f5f9e8}{#1}");
S("\\mintB", "\\textcolor{##edf2df}{#1}");
S("\\mintC", "\\textcolor{##e0e5cc}{#1}");
S("\\grayA", "\\textcolor{##f6f7f7}{#1}");
S("\\grayB", "\\textcolor{##f0f1f2}{#1}");
S("\\grayC", "\\textcolor{##e3e5e6}{#1}");
S("\\grayD", "\\textcolor{##d6d8da}{#1}");
S("\\grayE", "\\textcolor{##babec2}{#1}");
S("\\grayF", "\\textcolor{##888d93}{#1}");
S("\\grayG", "\\textcolor{##626569}{#1}");
S("\\grayH", "\\textcolor{##3b3e40}{#1}");
S("\\grayI", "\\textcolor{##21242c}{#1}");
S("\\kaBlue", "\\textcolor{##314453}{#1}");
S("\\kaGreen", "\\textcolor{##71B307}{#1}");
var ON = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class Dle {
  constructor(e, t, r) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = t, this.expansionCount = 0, this.feed(e), this.macros = new Ele(Ile, t.macros), this.mode = r, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(e) {
    this.lexer = new _9(e, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(e) {
    this.stack.push(e);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(e) {
    this.stack.push(...e);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(e) {
    var t, r, i;
    if (e) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      t = this.popToken(), {
        tokens: i,
        end: r
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: i,
        start: t,
        end: r
      } = this.consumeArg());
    return this.pushToken(new yi("EOF", r.loc)), this.pushTokens(i), t.range(r, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var e = this.future();
      if (e.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(e) {
    var t = [], r = e && e.length > 0;
    r || this.consumeSpaces();
    var i = this.future(), s, o = 0, l = 0;
    do {
      if (s = this.popToken(), t.push(s), s.text === "{")
        ++o;
      else if (s.text === "}") {
        if (--o, o === -1)
          throw new se("Extra }", s);
      } else if (s.text === "EOF")
        throw new se("Unexpected end of input in a macro argument, expected '" + (e && r ? e[l] : "}") + "'", s);
      if (e && r)
        if ((o === 0 || o === 1 && e[l] === "{") && s.text === e[l]) {
          if (++l, l === e.length) {
            t.splice(-l, l);
            break;
          }
        } else
          l = 0;
    } while (o !== 0 || r);
    return i.text === "{" && t[t.length - 1].text === "}" && (t.pop(), t.shift()), t.reverse(), {
      tokens: t,
      start: i,
      end: s
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(e, t) {
    if (t) {
      if (t.length !== e + 1)
        throw new se("The length of delimiters doesn't match the number of args!");
      for (var r = t[0], i = 0; i < r.length; i++) {
        var s = this.popToken();
        if (r[i] !== s.text)
          throw new se("Use of the macro doesn't match its definition", s);
      }
    }
    for (var o = [], l = 0; l < e; l++)
      o.push(this.consumeArg(t && t[l + 1]).tokens);
    return o;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(e) {
    if (this.expansionCount += e, this.expansionCount > this.settings.maxExpand)
      throw new se("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(e) {
    var t = this.popToken(), r = t.text, i = t.noexpand ? null : this._getExpansion(r);
    if (i == null || e && i.unexpandable) {
      if (e && i == null && r[0] === "\\" && !this.isDefined(r))
        throw new se("Undefined control sequence: " + r);
      return this.pushToken(t), !1;
    }
    this.countExpansion(1);
    var s = i.tokens, o = this.consumeArgs(i.numArgs, i.delimiters);
    if (i.numArgs) {
      s = s.slice();
      for (var l = s.length - 1; l >= 0; --l) {
        var a = s[l];
        if (a.text === "#") {
          if (l === 0)
            throw new se("Incomplete placeholder at end of macro body", a);
          if (a = s[--l], a.text === "#")
            s.splice(l + 1, 1);
          else if (/^[1-9]$/.test(a.text))
            s.splice(l, 2, ...o[+a.text - 1]);
          else
            throw new se("Not a valid argument number", a);
        }
      }
    }
    return this.pushTokens(s), s.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var e = this.stack.pop();
        return e.treatAsRelax && (e.text = "\\relax"), e;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(e) {
    return this.macros.has(e) ? this.expandTokens([new yi(e)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(e) {
    var t = [], r = this.stack.length;
    for (this.pushTokens(e); this.stack.length > r; )
      if (this.expandOnce(!0) === !1) {
        var i = this.stack.pop();
        i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), t.push(i);
      }
    return this.countExpansion(t.length), t;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(e) {
    var t = this.expandMacro(e);
    return t && t.map((r) => r.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(e) {
    var t = this.macros.get(e);
    if (t == null)
      return t;
    if (e.length === 1) {
      var r = this.lexer.catcodes[e];
      if (r != null && r !== 13)
        return;
    }
    var i = typeof t == "function" ? t(this) : t;
    if (typeof i == "string") {
      var s = 0;
      if (i.indexOf("#") !== -1)
        for (var o = i.replace(/##/g, ""); o.indexOf("#" + (s + 1)) !== -1; )
          ++s;
      for (var l = new _9(i, this.settings), a = [], c = l.lex(); c.text !== "EOF"; )
        a.push(c), c = l.lex();
      a.reverse();
      var u = {
        tokens: a,
        numArgs: s
      };
      return u;
    }
    return i;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(e) {
    return this.macros.has(e) || tl.hasOwnProperty(e) || zt.math.hasOwnProperty(e) || zt.text.hasOwnProperty(e) || ON.hasOwnProperty(e);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(e) {
    var t = this.macros.get(e);
    return t != null ? typeof t == "string" || typeof t == "function" || !t.unexpandable : tl.hasOwnProperty(e) && !tl[e].primitive;
  }
}
var z9 = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/, z0 = Object.freeze({
  "₊": "+",
  "₋": "-",
  "₌": "=",
  "₍": "(",
  "₎": ")",
  "₀": "0",
  "₁": "1",
  "₂": "2",
  "₃": "3",
  "₄": "4",
  "₅": "5",
  "₆": "6",
  "₇": "7",
  "₈": "8",
  "₉": "9",
  "ₐ": "a",
  "ₑ": "e",
  "ₕ": "h",
  "ᵢ": "i",
  "ⱼ": "j",
  "ₖ": "k",
  "ₗ": "l",
  "ₘ": "m",
  "ₙ": "n",
  "ₒ": "o",
  "ₚ": "p",
  "ᵣ": "r",
  "ₛ": "s",
  "ₜ": "t",
  "ᵤ": "u",
  "ᵥ": "v",
  "ₓ": "x",
  "ᵦ": "β",
  "ᵧ": "γ",
  "ᵨ": "ρ",
  "ᵩ": "ϕ",
  "ᵪ": "χ",
  "⁺": "+",
  "⁻": "-",
  "⁼": "=",
  "⁽": "(",
  "⁾": ")",
  "⁰": "0",
  "¹": "1",
  "²": "2",
  "³": "3",
  "⁴": "4",
  "⁵": "5",
  "⁶": "6",
  "⁷": "7",
  "⁸": "8",
  "⁹": "9",
  "ᴬ": "A",
  "ᴮ": "B",
  "ᴰ": "D",
  "ᴱ": "E",
  "ᴳ": "G",
  "ᴴ": "H",
  "ᴵ": "I",
  "ᴶ": "J",
  "ᴷ": "K",
  "ᴸ": "L",
  "ᴹ": "M",
  "ᴺ": "N",
  "ᴼ": "O",
  "ᴾ": "P",
  "ᴿ": "R",
  "ᵀ": "T",
  "ᵁ": "U",
  "ⱽ": "V",
  "ᵂ": "W",
  "ᵃ": "a",
  "ᵇ": "b",
  "ᶜ": "c",
  "ᵈ": "d",
  "ᵉ": "e",
  "ᶠ": "f",
  "ᵍ": "g",
  ʰ: "h",
  "ⁱ": "i",
  ʲ: "j",
  "ᵏ": "k",
  ˡ: "l",
  "ᵐ": "m",
  ⁿ: "n",
  "ᵒ": "o",
  "ᵖ": "p",
  ʳ: "r",
  ˢ: "s",
  "ᵗ": "t",
  "ᵘ": "u",
  "ᵛ": "v",
  ʷ: "w",
  ˣ: "x",
  ʸ: "y",
  "ᶻ": "z",
  "ᵝ": "β",
  "ᵞ": "γ",
  "ᵟ": "δ",
  "ᵠ": "ϕ",
  "ᵡ": "χ",
  "ᶿ": "θ"
}), b4 = {
  "́": {
    text: "\\'",
    math: "\\acute"
  },
  "̀": {
    text: "\\`",
    math: "\\grave"
  },
  "̈": {
    text: '\\"',
    math: "\\ddot"
  },
  "̃": {
    text: "\\~",
    math: "\\tilde"
  },
  "̄": {
    text: "\\=",
    math: "\\bar"
  },
  "̆": {
    text: "\\u",
    math: "\\breve"
  },
  "̌": {
    text: "\\v",
    math: "\\check"
  },
  "̂": {
    text: "\\^",
    math: "\\hat"
  },
  "̇": {
    text: "\\.",
    math: "\\dot"
  },
  "̊": {
    text: "\\r",
    math: "\\mathring"
  },
  "̋": {
    text: "\\H"
  },
  "̧": {
    text: "\\c"
  }
}, F9 = {
  á: "á",
  à: "à",
  ä: "ä",
  ǟ: "ǟ",
  ã: "ã",
  ā: "ā",
  ă: "ă",
  ắ: "ắ",
  ằ: "ằ",
  ẵ: "ẵ",
  ǎ: "ǎ",
  â: "â",
  ấ: "ấ",
  ầ: "ầ",
  ẫ: "ẫ",
  ȧ: "ȧ",
  ǡ: "ǡ",
  å: "å",
  ǻ: "ǻ",
  ḃ: "ḃ",
  ć: "ć",
  ḉ: "ḉ",
  č: "č",
  ĉ: "ĉ",
  ċ: "ċ",
  ç: "ç",
  ď: "ď",
  ḋ: "ḋ",
  ḑ: "ḑ",
  é: "é",
  è: "è",
  ë: "ë",
  ẽ: "ẽ",
  ē: "ē",
  ḗ: "ḗ",
  ḕ: "ḕ",
  ĕ: "ĕ",
  ḝ: "ḝ",
  ě: "ě",
  ê: "ê",
  ế: "ế",
  ề: "ề",
  ễ: "ễ",
  ė: "ė",
  ȩ: "ȩ",
  ḟ: "ḟ",
  ǵ: "ǵ",
  ḡ: "ḡ",
  ğ: "ğ",
  ǧ: "ǧ",
  ĝ: "ĝ",
  ġ: "ġ",
  ģ: "ģ",
  ḧ: "ḧ",
  ȟ: "ȟ",
  ĥ: "ĥ",
  ḣ: "ḣ",
  ḩ: "ḩ",
  í: "í",
  ì: "ì",
  ï: "ï",
  ḯ: "ḯ",
  ĩ: "ĩ",
  ī: "ī",
  ĭ: "ĭ",
  ǐ: "ǐ",
  î: "î",
  ǰ: "ǰ",
  ĵ: "ĵ",
  ḱ: "ḱ",
  ǩ: "ǩ",
  ķ: "ķ",
  ĺ: "ĺ",
  ľ: "ľ",
  ļ: "ļ",
  ḿ: "ḿ",
  ṁ: "ṁ",
  ń: "ń",
  ǹ: "ǹ",
  ñ: "ñ",
  ň: "ň",
  ṅ: "ṅ",
  ņ: "ņ",
  ó: "ó",
  ò: "ò",
  ö: "ö",
  ȫ: "ȫ",
  õ: "õ",
  ṍ: "ṍ",
  ṏ: "ṏ",
  ȭ: "ȭ",
  ō: "ō",
  ṓ: "ṓ",
  ṑ: "ṑ",
  ŏ: "ŏ",
  ǒ: "ǒ",
  ô: "ô",
  ố: "ố",
  ồ: "ồ",
  ỗ: "ỗ",
  ȯ: "ȯ",
  ȱ: "ȱ",
  ő: "ő",
  ṕ: "ṕ",
  ṗ: "ṗ",
  ŕ: "ŕ",
  ř: "ř",
  ṙ: "ṙ",
  ŗ: "ŗ",
  ś: "ś",
  ṥ: "ṥ",
  š: "š",
  ṧ: "ṧ",
  ŝ: "ŝ",
  ṡ: "ṡ",
  ş: "ş",
  ẗ: "ẗ",
  ť: "ť",
  ṫ: "ṫ",
  ţ: "ţ",
  ú: "ú",
  ù: "ù",
  ü: "ü",
  ǘ: "ǘ",
  ǜ: "ǜ",
  ǖ: "ǖ",
  ǚ: "ǚ",
  ũ: "ũ",
  ṹ: "ṹ",
  ū: "ū",
  ṻ: "ṻ",
  ŭ: "ŭ",
  ǔ: "ǔ",
  û: "û",
  ů: "ů",
  ű: "ű",
  ṽ: "ṽ",
  ẃ: "ẃ",
  ẁ: "ẁ",
  ẅ: "ẅ",
  ŵ: "ŵ",
  ẇ: "ẇ",
  ẘ: "ẘ",
  ẍ: "ẍ",
  ẋ: "ẋ",
  ý: "ý",
  ỳ: "ỳ",
  ÿ: "ÿ",
  ỹ: "ỹ",
  ȳ: "ȳ",
  ŷ: "ŷ",
  ẏ: "ẏ",
  ẙ: "ẙ",
  ź: "ź",
  ž: "ž",
  ẑ: "ẑ",
  ż: "ż",
  Á: "Á",
  À: "À",
  Ä: "Ä",
  Ǟ: "Ǟ",
  Ã: "Ã",
  Ā: "Ā",
  Ă: "Ă",
  Ắ: "Ắ",
  Ằ: "Ằ",
  Ẵ: "Ẵ",
  Ǎ: "Ǎ",
  Â: "Â",
  Ấ: "Ấ",
  Ầ: "Ầ",
  Ẫ: "Ẫ",
  Ȧ: "Ȧ",
  Ǡ: "Ǡ",
  Å: "Å",
  Ǻ: "Ǻ",
  Ḃ: "Ḃ",
  Ć: "Ć",
  Ḉ: "Ḉ",
  Č: "Č",
  Ĉ: "Ĉ",
  Ċ: "Ċ",
  Ç: "Ç",
  Ď: "Ď",
  Ḋ: "Ḋ",
  Ḑ: "Ḑ",
  É: "É",
  È: "È",
  Ë: "Ë",
  Ẽ: "Ẽ",
  Ē: "Ē",
  Ḗ: "Ḗ",
  Ḕ: "Ḕ",
  Ĕ: "Ĕ",
  Ḝ: "Ḝ",
  Ě: "Ě",
  Ê: "Ê",
  Ế: "Ế",
  Ề: "Ề",
  Ễ: "Ễ",
  Ė: "Ė",
  Ȩ: "Ȩ",
  Ḟ: "Ḟ",
  Ǵ: "Ǵ",
  Ḡ: "Ḡ",
  Ğ: "Ğ",
  Ǧ: "Ǧ",
  Ĝ: "Ĝ",
  Ġ: "Ġ",
  Ģ: "Ģ",
  Ḧ: "Ḧ",
  Ȟ: "Ȟ",
  Ĥ: "Ĥ",
  Ḣ: "Ḣ",
  Ḩ: "Ḩ",
  Í: "Í",
  Ì: "Ì",
  Ï: "Ï",
  Ḯ: "Ḯ",
  Ĩ: "Ĩ",
  Ī: "Ī",
  Ĭ: "Ĭ",
  Ǐ: "Ǐ",
  Î: "Î",
  İ: "İ",
  Ĵ: "Ĵ",
  Ḱ: "Ḱ",
  Ǩ: "Ǩ",
  Ķ: "Ķ",
  Ĺ: "Ĺ",
  Ľ: "Ľ",
  Ļ: "Ļ",
  Ḿ: "Ḿ",
  Ṁ: "Ṁ",
  Ń: "Ń",
  Ǹ: "Ǹ",
  Ñ: "Ñ",
  Ň: "Ň",
  Ṅ: "Ṅ",
  Ņ: "Ņ",
  Ó: "Ó",
  Ò: "Ò",
  Ö: "Ö",
  Ȫ: "Ȫ",
  Õ: "Õ",
  Ṍ: "Ṍ",
  Ṏ: "Ṏ",
  Ȭ: "Ȭ",
  Ō: "Ō",
  Ṓ: "Ṓ",
  Ṑ: "Ṑ",
  Ŏ: "Ŏ",
  Ǒ: "Ǒ",
  Ô: "Ô",
  Ố: "Ố",
  Ồ: "Ồ",
  Ỗ: "Ỗ",
  Ȯ: "Ȯ",
  Ȱ: "Ȱ",
  Ő: "Ő",
  Ṕ: "Ṕ",
  Ṗ: "Ṗ",
  Ŕ: "Ŕ",
  Ř: "Ř",
  Ṙ: "Ṙ",
  Ŗ: "Ŗ",
  Ś: "Ś",
  Ṥ: "Ṥ",
  Š: "Š",
  Ṧ: "Ṧ",
  Ŝ: "Ŝ",
  Ṡ: "Ṡ",
  Ş: "Ş",
  Ť: "Ť",
  Ṫ: "Ṫ",
  Ţ: "Ţ",
  Ú: "Ú",
  Ù: "Ù",
  Ü: "Ü",
  Ǘ: "Ǘ",
  Ǜ: "Ǜ",
  Ǖ: "Ǖ",
  Ǚ: "Ǚ",
  Ũ: "Ũ",
  Ṹ: "Ṹ",
  Ū: "Ū",
  Ṻ: "Ṻ",
  Ŭ: "Ŭ",
  Ǔ: "Ǔ",
  Û: "Û",
  Ů: "Ů",
  Ű: "Ű",
  Ṽ: "Ṽ",
  Ẃ: "Ẃ",
  Ẁ: "Ẁ",
  Ẅ: "Ẅ",
  Ŵ: "Ŵ",
  Ẇ: "Ẇ",
  Ẍ: "Ẍ",
  Ẋ: "Ẋ",
  Ý: "Ý",
  Ỳ: "Ỳ",
  Ÿ: "Ÿ",
  Ỹ: "Ỹ",
  Ȳ: "Ȳ",
  Ŷ: "Ŷ",
  Ẏ: "Ẏ",
  Ź: "Ź",
  Ž: "Ž",
  Ẑ: "Ẑ",
  Ż: "Ż",
  ά: "ά",
  ὰ: "ὰ",
  ᾱ: "ᾱ",
  ᾰ: "ᾰ",
  έ: "έ",
  ὲ: "ὲ",
  ή: "ή",
  ὴ: "ὴ",
  ί: "ί",
  ὶ: "ὶ",
  ϊ: "ϊ",
  ΐ: "ΐ",
  ῒ: "ῒ",
  ῑ: "ῑ",
  ῐ: "ῐ",
  ό: "ό",
  ὸ: "ὸ",
  ύ: "ύ",
  ὺ: "ὺ",
  ϋ: "ϋ",
  ΰ: "ΰ",
  ῢ: "ῢ",
  ῡ: "ῡ",
  ῠ: "ῠ",
  ώ: "ώ",
  ὼ: "ὼ",
  Ύ: "Ύ",
  Ὺ: "Ὺ",
  Ϋ: "Ϋ",
  Ῡ: "Ῡ",
  Ῠ: "Ῠ",
  Ώ: "Ώ",
  Ὼ: "Ὼ"
};
class pg {
  constructor(e, t) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new Dle(e, t, this.mode), this.settings = t, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(e, t) {
    if (t === void 0 && (t = !0), this.fetch().text !== e)
      throw new se("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
    t && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e, this.gullet.switchMode(e);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var e = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(e) {
    var t = this.nextToken;
    this.consume(), this.gullet.pushToken(new yi("}")), this.gullet.pushTokens(e);
    var r = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = t, r;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(e, t) {
    for (var r = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var i = this.fetch();
      if (pg.endOfExpression.indexOf(i.text) !== -1 || t && i.text === t || e && tl[i.text] && tl[i.text].infix)
        break;
      var s = this.parseAtom(t);
      if (s) {
        if (s.type === "internal")
          continue;
      } else break;
      r.push(s);
    }
    return this.mode === "text" && this.formLigatures(r), this.handleInfixNodes(r);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(e) {
    for (var t = -1, r, i = 0; i < e.length; i++)
      if (e[i].type === "infix") {
        if (t !== -1)
          throw new se("only one infix operator per group", e[i].token);
        t = i, r = e[i].replaceWith;
      }
    if (t !== -1 && r) {
      var s, o, l = e.slice(0, t), a = e.slice(t + 1);
      l.length === 1 && l[0].type === "ordgroup" ? s = l[0] : s = {
        type: "ordgroup",
        mode: this.mode,
        body: l
      }, a.length === 1 && a[0].type === "ordgroup" ? o = a[0] : o = {
        type: "ordgroup",
        mode: this.mode,
        body: a
      };
      var c;
      return r === "\\\\abovefrac" ? c = this.callFunction(r, [s, e[t], o], []) : c = this.callFunction(r, [s, o], []), [c];
    } else
      return e;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(e) {
    var t = this.fetch(), r = t.text;
    this.consume(), this.consumeSpaces();
    var i;
    do {
      var s;
      i = this.parseGroup(e);
    } while (((s = i) == null ? void 0 : s.type) === "internal");
    if (!i)
      throw new se("Expected group after '" + r + "'", t);
    return i;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.push({
        type: "textord",
        mode: "text",
        text: e[r]
      });
    var i = {
      type: "text",
      mode: this.mode,
      body: t
    }, s = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [i]
    };
    return s;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(e) {
    var t = this.parseGroup("atom", e);
    if (t?.type === "internal" || this.mode === "text")
      return t;
    for (var r, i; ; ) {
      this.consumeSpaces();
      var s = this.fetch();
      if (s.text === "\\limits" || s.text === "\\nolimits") {
        if (t && t.type === "op") {
          var o = s.text === "\\limits";
          t.limits = o, t.alwaysHandleSupSub = !0;
        } else if (t && t.type === "operatorname")
          t.alwaysHandleSupSub && (t.limits = s.text === "\\limits");
        else
          throw new se("Limit controls must follow a math operator", s);
        this.consume();
      } else if (s.text === "^") {
        if (r)
          throw new se("Double superscript", s);
        r = this.handleSupSubscript("superscript");
      } else if (s.text === "_") {
        if (i)
          throw new se("Double subscript", s);
        i = this.handleSupSubscript("subscript");
      } else if (s.text === "'") {
        if (r)
          throw new se("Double superscript", s);
        var l = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, a = [l];
        for (this.consume(); this.fetch().text === "'"; )
          a.push(l), this.consume();
        this.fetch().text === "^" && a.push(this.handleSupSubscript("superscript")), r = {
          type: "ordgroup",
          mode: this.mode,
          body: a
        };
      } else if (z0[s.text]) {
        var c = z9.test(s.text), u = [];
        for (u.push(new yi(z0[s.text])), this.consume(); ; ) {
          var h = this.fetch().text;
          if (!z0[h] || z9.test(h) !== c)
            break;
          u.unshift(new yi(z0[h])), this.consume();
        }
        var f = this.subparse(u);
        c ? i = {
          type: "ordgroup",
          mode: "math",
          body: f
        } : r = {
          type: "ordgroup",
          mode: "math",
          body: f
        };
      } else
        break;
    }
    return r || i ? {
      type: "supsub",
      mode: this.mode,
      base: t,
      sup: r,
      sub: i
    } : t;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(e, t) {
    var r = this.fetch(), i = r.text, s = tl[i];
    if (!s)
      return null;
    if (this.consume(), t && t !== "atom" && !s.allowedInArgument)
      throw new se("Got function '" + i + "' with no arguments" + (t ? " as " + t : ""), r);
    if (this.mode === "text" && !s.allowedInText)
      throw new se("Can't use function '" + i + "' in text mode", r);
    if (this.mode === "math" && s.allowedInMath === !1)
      throw new se("Can't use function '" + i + "' in math mode", r);
    var {
      args: o,
      optArgs: l
    } = this.parseArguments(i, s);
    return this.callFunction(i, o, l, r, e);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(e, t, r, i, s) {
    var o = {
      funcName: e,
      parser: this,
      token: i,
      breakOnTokenText: s
    }, l = tl[e];
    if (l && l.handler)
      return l.handler(o, t, r);
    throw new se("No function handler for " + e);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(e, t) {
    var r = t.numArgs + t.numOptionalArgs;
    if (r === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var i = [], s = [], o = 0; o < r; o++) {
      var l = t.argTypes && t.argTypes[o], a = o < t.numOptionalArgs;
      (t.primitive && l == null || // \sqrt expands into primitive if optional argument doesn't exist
      t.type === "sqrt" && o === 1 && s[0] == null) && (l = "primitive");
      var c = this.parseGroupOfType("argument to '" + e + "'", l, a);
      if (a)
        s.push(c);
      else if (c != null)
        i.push(c);
      else
        throw new se("Null argument, please report this as a bug");
    }
    return {
      args: i,
      optArgs: s
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(e, t, r) {
    switch (t) {
      case "color":
        return this.parseColorGroup(r);
      case "size":
        return this.parseSizeGroup(r);
      case "url":
        return this.parseUrlGroup(r);
      case "math":
      case "text":
        return this.parseArgumentGroup(r, t);
      case "hbox": {
        var i = this.parseArgumentGroup(r, "text");
        return i != null ? {
          type: "styling",
          mode: i.mode,
          body: [i],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var s = this.parseStringGroup("raw", r);
        return s != null ? {
          type: "raw",
          mode: "text",
          string: s.text
        } : null;
      }
      case "primitive": {
        if (r)
          throw new se("A primitive argument cannot be optional");
        var o = this.parseGroup(e);
        if (o == null)
          throw new se("Expected group as " + e, this.fetch());
        return o;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(r);
      default:
        throw new se("Unknown group type as " + e, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(e, t) {
    var r = this.gullet.scanArgument(t);
    if (r == null)
      return null;
    for (var i = "", s; (s = this.fetch()).text !== "EOF"; )
      i += s.text, this.consume();
    return this.consume(), r.text = i, r;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(e, t) {
    for (var r = this.fetch(), i = r, s = "", o; (o = this.fetch()).text !== "EOF" && e.test(s + o.text); )
      i = o, s += i.text, this.consume();
    if (s === "")
      throw new se("Invalid " + t + ": '" + r.text + "'", r);
    return r.range(i, s);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(e) {
    var t = this.parseStringGroup("color", e);
    if (t == null)
      return null;
    var r = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(t.text);
    if (!r)
      throw new se("Invalid color: '" + t.text + "'", t);
    var i = r[0];
    return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
      type: "color-token",
      mode: this.mode,
      color: i
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(e) {
    var t, r = !1;
    if (this.gullet.consumeSpaces(), !e && this.gullet.future().text !== "{" ? t = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : t = this.parseStringGroup("size", e), !t)
      return null;
    !e && t.text.length === 0 && (t.text = "0pt", r = !0);
    var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t.text);
    if (!i)
      throw new se("Invalid size: '" + t.text + "'", t);
    var s = {
      number: +(i[1] + i[2]),
      // sign + magnitude, cast to number
      unit: i[3]
    };
    if (!zD(s))
      throw new se("Invalid unit: '" + s.unit + "'", t);
    return {
      type: "size",
      mode: this.mode,
      value: s,
      isBlank: r
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(e) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var t = this.parseStringGroup("url", e);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), t == null)
      return null;
    var r = t.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: r
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(e, t) {
    var r = this.gullet.scanArgument(e);
    if (r == null)
      return null;
    var i = this.mode;
    t && this.switchMode(t), this.gullet.beginGroup();
    var s = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var o = {
      type: "ordgroup",
      mode: this.mode,
      loc: r.loc,
      body: s
    };
    return t && this.switchMode(i), o;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(e, t) {
    var r = this.fetch(), i = r.text, s;
    if (i === "{" || i === "\\begingroup") {
      this.consume();
      var o = i === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var l = this.parseExpression(!1, o), a = this.fetch();
      this.expect(o), this.gullet.endGroup(), s = {
        type: "ordgroup",
        mode: this.mode,
        loc: Wr.range(r, a),
        body: l,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: i === "\\begingroup" || void 0
      };
    } else if (s = this.parseFunction(t, e) || this.parseSymbol(), s == null && i[0] === "\\" && !ON.hasOwnProperty(i)) {
      if (this.settings.throwOnError)
        throw new se("Undefined control sequence: " + i, r);
      s = this.formatUnsupportedCmd(i), this.consume();
    }
    return s;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(e) {
    for (var t = e.length - 1, r = 0; r < t; ++r) {
      var i = e[r], s = i.text;
      s === "-" && e[r + 1].text === "-" && (r + 1 < t && e[r + 2].text === "-" ? (e.splice(r, 3, {
        type: "textord",
        mode: "text",
        loc: Wr.range(i, e[r + 2]),
        text: "---"
      }), t -= 2) : (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Wr.range(i, e[r + 1]),
        text: "--"
      }), t -= 1)), (s === "'" || s === "`") && e[r + 1].text === s && (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Wr.range(i, e[r + 1]),
        text: s + s
      }), t -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var e = this.fetch(), t = e.text;
    if (/^\\verb[^a-zA-Z]/.test(t)) {
      this.consume();
      var r = t.slice(5), i = r.charAt(0) === "*";
      if (i && (r = r.slice(1)), r.length < 2 || r.charAt(0) !== r.slice(-1))
        throw new se(`\\verb assertion failed --
                    please report what input caused this bug`);
      return r = r.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: r,
        star: i
      };
    }
    F9.hasOwnProperty(t[0]) && !zt[this.mode][t[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + t[0] + '" used in math mode', e), t = F9[t[0]] + t.slice(1));
    var s = Ale.exec(t);
    s && (t = t.substring(0, s.index), t === "i" ? t = "ı" : t === "j" && (t = "ȷ"));
    var o;
    if (zt[this.mode][t]) {
      this.settings.strict && this.mode === "math" && _5.indexOf(t) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + t[0] + '" used in math mode', e);
      var l = zt[this.mode][t].group, a = Wr.range(e), c;
      if (voe.hasOwnProperty(l)) {
        var u = l;
        c = {
          type: "atom",
          mode: this.mode,
          family: u,
          loc: a,
          text: t
        };
      } else
        c = {
          type: l,
          mode: this.mode,
          loc: a,
          text: t
        };
      o = c;
    } else if (t.charCodeAt(0) >= 128)
      this.settings.strict && (BD(t.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + t[0] + '" used in math mode', e) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + t[0] + '"' + (" (" + t.charCodeAt(0) + ")"), e)), o = {
        type: "textord",
        mode: "text",
        loc: Wr.range(e),
        text: t
      };
    else
      return null;
    if (this.consume(), s)
      for (var h = 0; h < s[0].length; h++) {
        var f = s[0][h];
        if (!b4[f])
          throw new se("Unknown accent ' " + f + "'", e);
        var d = b4[f][this.mode] || b4[f].text;
        if (!d)
          throw new se("Accent " + f + " unsupported in " + this.mode + " mode", e);
        o = {
          type: "accent",
          mode: this.mode,
          loc: Wr.range(e),
          label: d,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: o
        };
      }
    return o;
  }
}
pg.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var O7 = function(e, t) {
  if (!(typeof e == "string" || e instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var r = new pg(e, t);
  delete r.gullet.macros.current["\\df@tag"];
  var i = r.parse();
  if (delete r.gullet.macros.current["\\current@color"], delete r.gullet.macros.current["\\color"], r.gullet.macros.get("\\df@tag")) {
    if (!t.displayMode)
      throw new se("\\tag works only in display equations");
    i = [{
      type: "tag",
      mode: "text",
      body: i,
      tag: r.subparse([new yi("\\df@tag")])
    }];
  }
  return i;
}, EN = function(e, t, r) {
  t.textContent = "";
  var i = E7(e, r).toNode();
  t.appendChild(i);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), EN = function() {
  throw new se("KaTeX doesn't work in quirks mode.");
});
var Nle = function(e, t) {
  var r = E7(e, t).toMarkup();
  return r;
}, Rle = function(e, t) {
  var r = new u7(t);
  return O7(e, r);
}, IN = function(e, t, r) {
  if (r.throwOnError || !(e instanceof se))
    throw e;
  var i = H.makeSpan(["katex-error"], [new xi(t)]);
  return i.setAttribute("title", e.toString()), i.setAttribute("style", "color:" + r.errorColor), i;
}, E7 = function(e, t) {
  var r = new u7(t);
  try {
    var i = O7(e, r);
    return Voe(i, e, r);
  } catch (s) {
    return IN(s, e, r);
  }
}, Ple = function(e, t) {
  var r = new u7(t);
  try {
    var i = O7(e, r);
    return qoe(i, e, r);
  } catch (s) {
    return IN(s, e, r);
  }
}, _le = "0.16.22", Lle = {
  Span: Ld,
  Anchor: d7,
  SymbolNode: xi,
  SvgNode: po,
  PathNode: bl,
  LineNode: P5
}, DN = {
  /**
   * Current KaTeX version
   */
  version: _le,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: EN,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: Nle,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: se,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA: Ep,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: Rle,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: E7,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: Ple,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: hoe,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: y,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: be,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: S,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: Lle
};
class mg {
  constructor(e) {
    this.#i = !1, this.onShow = () => {
    }, this.onHide = () => {
    }, this.#c = (t, r) => {
      const { state: i, composing: s } = t, { selection: o, doc: l } = i, { ranges: a } = o, c = Math.min(...a.map((d) => d.$from.pos)), u = Math.max(...a.map((d) => d.$to.pos)), h = r && r.doc.eq(l) && r.selection.eq(o);
      if (this.#i || ((this.#a ?? t.dom.parentElement ?? document.body).appendChild(this.element), this.#i = !0), s || h) return;
      if (!this.#e(t, r)) {
        this.hide();
        return;
      }
      $i({
        getBoundingClientRect: () => y1(t, c, u)
      }, this.element, {
        placement: this.#n.placement ?? "top",
        middleware: [
          Mm(),
          ml(this.#s),
          b8(this.#o),
          ...this.#r
        ]
      }).then(({ x: d, y: p }) => {
        Object.assign(this.element.style, {
          left: `${d}px`,
          top: `${p}px`
        });
      }).catch(console.error), this.show();
    }, this.update = (t, r) => {
      this.#l(t, r);
    }, this.destroy = () => {
      this.#l.cancel();
    }, this.show = (t) => {
      this.element.dataset.show = "true", t && $i(t, this.element, {
        placement: "top",
        middleware: [
          Mm(),
          ml(this.#s),
          b8(this.#o),
          ...this.#r
        ],
        ...this.#n
      }).then(({ x: r, y: i }) => {
        Object.assign(this.element.style, {
          left: `${r}px`,
          top: `${i}px`
        });
      }).catch(console.error), this.onShow();
    }, this.hide = () => {
      this.element.dataset.show !== "false" && (this.element.dataset.show = "false", this.onHide());
    }, this.element = e.content, this.#t = e.debounce ?? 200, this.#e = e.shouldShow ?? this.#u, this.#s = e.offset, this.#o = e.shift, this.#r = e.middleware ?? [], this.#n = e.floatingUIOptions ?? {}, this.#a = e.root, this.element.dataset.show = "false", this.#l = e1(this.#c, this.#t);
  }
  /// @internal
  #t;
  /// @internal
  #e;
  /// @internal
  #r;
  /// @internal
  #n;
  /// @internal
  #a;
  #i;
  /// @internal
  #s;
  /// @internal
  #o;
  /// @internal
  #l;
  #c;
  /// @internal
  #u(e) {
    const { doc: t, selection: r } = e.state, { empty: i, from: s, to: o } = r, l = !t.textBetween(s, o).length && e.state.selection instanceof Ee, a = this.element.contains(document.activeElement), c = !e.hasFocus() && !a, u = !e.editable;
    return !(c || i || l || u);
  }
}
function gg(n) {
  const e = St(
    {},
    `${n}_TOOLTIP_SPEC`
  ), t = kn((i) => {
    const s = i.get(e.key);
    return new Ut({
      key: new en(`${n}_TOOLTIP`),
      ...s
    });
  }), r = [e, t];
  return r.key = e.key, r.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Ctx<tooltipSpec>|${n}`
  }, t.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Prose<tooltip>|${n}`
  }, r;
}
function Ble() {
  return {
    enter: {
      mathFlow: n,
      mathFlowFenceMeta: e,
      mathText: s
    },
    exit: {
      mathFlow: i,
      mathFlowFence: r,
      mathFlowFenceMeta: t,
      mathFlowValue: l,
      mathText: o,
      mathTextData: l
    }
  };
  function n(a) {
    const c = {
      type: "element",
      tagName: "code",
      properties: { className: ["language-math", "math-display"] },
      children: []
    };
    this.enter(
      {
        type: "math",
        meta: null,
        value: "",
        data: { hName: "pre", hChildren: [c] }
      },
      a
    );
  }
  function e() {
    this.buffer();
  }
  function t() {
    const a = this.resume(), c = this.stack[this.stack.length - 1];
    c.type, c.meta = a;
  }
  function r() {
    this.data.mathFlowInside || (this.buffer(), this.data.mathFlowInside = !0);
  }
  function i(a) {
    const c = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), u = this.stack[this.stack.length - 1];
    u.type, this.exit(a), u.value = c;
    const h = (
      /** @type {HastElement} */
      u.data.hChildren[0]
    );
    h.type, h.tagName, h.children.push({ type: "text", value: c }), this.data.mathFlowInside = void 0;
  }
  function s(a) {
    this.enter(
      {
        type: "inlineMath",
        value: "",
        data: {
          hName: "code",
          hProperties: { className: ["language-math", "math-inline"] },
          hChildren: []
        }
      },
      a
    ), this.buffer();
  }
  function o(a) {
    const c = this.resume(), u = this.stack[this.stack.length - 1];
    u.type, this.exit(a), u.value = c, /** @type {Array<HastElementContent>} */
    // @ts-expect-error: we defined it in `enterMathFlow`.
    u.data.hChildren.push({ type: "text", value: c });
  }
  function l(a) {
    this.config.enter.data.call(this, a), this.config.exit.data.call(this, a);
  }
}
function zle(n) {
  let e = (n || {}).singleDollarTextMath;
  return e == null && (e = !0), r.peek = i, {
    unsafe: [
      { character: "\r", inConstruct: "mathFlowMeta" },
      { character: `
`, inConstruct: "mathFlowMeta" },
      {
        character: "$",
        after: e ? void 0 : "\\$",
        inConstruct: "phrasing"
      },
      { character: "$", inConstruct: "mathFlowMeta" },
      { atBreak: !0, character: "$", after: "\\$" }
    ],
    handlers: { math: t, inlineMath: r }
  };
  function t(s, o, l, a) {
    const c = s.value || "", u = l.createTracker(a), h = "$".repeat(Math.max(HT(c, "$") + 1, 2)), f = l.enter("mathFlow");
    let d = u.move(h);
    if (s.meta) {
      const p = l.enter("mathFlowMeta");
      d += u.move(
        l.safe(s.meta, {
          after: `
`,
          before: d,
          encode: ["$"],
          ...u.current()
        })
      ), p();
    }
    return d += u.move(`
`), c && (d += u.move(c + `
`)), d += u.move(h), f(), d;
  }
  function r(s, o, l) {
    let a = s.value || "", c = 1;
    for (e || c++; new RegExp("(^|[^$])" + "\\$".repeat(c) + "([^$]|$)").test(a); )
      c++;
    const u = "$".repeat(c);
    // Contains non-space.
    /[^ \r\n]/.test(a) && // Starts with space and ends with space.
    (/^[ \r\n]/.test(a) && /[ \r\n]$/.test(a) || // Starts or ends with dollar.
    /^\$|\$$/.test(a)) && (a = " " + a + " ");
    let h = -1;
    for (; ++h < l.unsafe.length; ) {
      const f = l.unsafe[h];
      if (!f.atBreak) continue;
      const d = l.compilePattern(f);
      let p;
      for (; p = d.exec(a); ) {
        let m = p.index;
        a.codePointAt(m) === 10 && a.codePointAt(m - 1) === 13 && m--, a = a.slice(0, m) + " " + a.slice(p.index + 1);
      }
    }
    return u + a + u;
  }
  function i() {
    return "$";
  }
}
const Fle = {
  tokenize: Hle,
  concrete: !0,
  name: "mathFlow"
}, H9 = {
  tokenize: $le,
  partial: !0
};
function Hle(n, e, t) {
  const r = this, i = r.events[r.events.length - 1], s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let o = 0;
  return l;
  function l(w) {
    return n.enter("mathFlow"), n.enter("mathFlowFence"), n.enter("mathFlowFenceSequence"), a(w);
  }
  function a(w) {
    return w === 36 ? (n.consume(w), o++, a) : o < 2 ? t(w) : (n.exit("mathFlowFenceSequence"), it(n, c, "whitespace")(w));
  }
  function c(w) {
    return w === null || Ne(w) ? h(w) : (n.enter("mathFlowFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), u(w));
  }
  function u(w) {
    return w === null || Ne(w) ? (n.exit("chunkString"), n.exit("mathFlowFenceMeta"), h(w)) : w === 36 ? t(w) : (n.consume(w), u);
  }
  function h(w) {
    return n.exit("mathFlowFence"), r.interrupt ? e(w) : n.attempt(H9, f, g)(w);
  }
  function f(w) {
    return n.attempt({
      tokenize: b,
      partial: !0
    }, g, d)(w);
  }
  function d(w) {
    return (s ? it(n, p, "linePrefix", s + 1) : p)(w);
  }
  function p(w) {
    return w === null ? g(w) : Ne(w) ? n.attempt(H9, f, g)(w) : (n.enter("mathFlowValue"), m(w));
  }
  function m(w) {
    return w === null || Ne(w) ? (n.exit("mathFlowValue"), p(w)) : (n.consume(w), m);
  }
  function g(w) {
    return n.exit("mathFlow"), e(w);
  }
  function b(w, k, C) {
    let M = 0;
    return it(w, T, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function T($) {
      return w.enter("mathFlowFence"), w.enter("mathFlowFenceSequence"), N($);
    }
    function N($) {
      return $ === 36 ? (M++, w.consume($), N) : M < o ? C($) : (w.exit("mathFlowFenceSequence"), it(w, B, "whitespace")($));
    }
    function B($) {
      return $ === null || Ne($) ? (w.exit("mathFlowFence"), k($)) : C($);
    }
  }
}
function $le(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? e(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
function Vle(n) {
  let t = (n || {}).singleDollarTextMath;
  return t == null && (t = !0), {
    tokenize: r,
    resolve: qle,
    previous: Wle,
    name: "mathText"
  };
  function r(i, s, o) {
    let l = 0, a, c;
    return u;
    function u(m) {
      return i.enter("mathText"), i.enter("mathTextSequence"), h(m);
    }
    function h(m) {
      return m === 36 ? (i.consume(m), l++, h) : l < 2 && !t ? o(m) : (i.exit("mathTextSequence"), f(m));
    }
    function f(m) {
      return m === null ? o(m) : m === 36 ? (c = i.enter("mathTextSequence"), a = 0, p(m)) : m === 32 ? (i.enter("space"), i.consume(m), i.exit("space"), f) : Ne(m) ? (i.enter("lineEnding"), i.consume(m), i.exit("lineEnding"), f) : (i.enter("mathTextData"), d(m));
    }
    function d(m) {
      return m === null || m === 32 || m === 36 || Ne(m) ? (i.exit("mathTextData"), f(m)) : (i.consume(m), d);
    }
    function p(m) {
      return m === 36 ? (i.consume(m), a++, p) : a === l ? (i.exit("mathTextSequence"), i.exit("mathText"), s(m)) : (c.type = "mathTextData", d(m));
    }
  }
}
function qle(n) {
  let e = n.length - 4, t = 3, r, i;
  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {
    for (r = t; ++r < e; )
      if (n[r][1].type === "mathTextData") {
        n[e][1].type = "mathTextPadding", n[t][1].type = "mathTextPadding", t += 2, e -= 2;
        break;
      }
  }
  for (r = t - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "mathTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function Wle(n) {
  return n !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function jle(n) {
  return {
    flow: {
      36: Fle
    },
    text: {
      36: Vle(n)
    }
  };
}
const Ule = {};
function Kle(n) {
  const e = (
    /** @type {Processor} */
    this
  ), t = n || Ule, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(jle(t)), s.push(Ble()), o.push(zle(t));
}
var Gle = Object.defineProperty, $9 = Object.getOwnPropertySymbols, Yle = Object.prototype.hasOwnProperty, Jle = Object.prototype.propertyIsEnumerable, V9 = (n, e, t) => e in n ? Gle(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Xle = (n, e) => {
  for (var t in e || (e = {}))
    Yle.call(e, t) && V9(n, t, e[t]);
  if ($9)
    for (var t of $9(e))
      Jle.call(e, t) && V9(n, t, e[t]);
  return n;
};
function Va(n, e) {
  return Object.assign(n, {
    meta: Xle({
      package: "@milkdown/components"
    }, e)
  }), n;
}
var Zle = Object.defineProperty, q9 = Object.getOwnPropertySymbols, Qle = Object.prototype.hasOwnProperty, eae = Object.prototype.propertyIsEnumerable, W9 = (n, e, t) => e in n ? Zle(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, I7 = (n, e) => {
  for (var t in e || (e = {}))
    Qle.call(e, t) && W9(n, t, e[t]);
  if (q9)
    for (var t of q9(e))
      eae.call(e, t) && W9(n, t, e[t]);
  return n;
};
const tae = {
  mode: "preview"
}, yo = St(I7({}, tae), "linkTooltipStateCtx");
Va(yo, {
  displayName: "State<link-tooltip>",
  group: "LinkTooltip"
});
const nae = {
  addLink: () => {
  },
  editLink: () => {
  },
  removeLink: () => {
  }
}, Yc = St(I7({}, nae), "linkTooltipAPICtx");
Va(yo, {
  displayName: "API<link-tooltip>",
  group: "LinkTooltip"
});
const rae = {
  linkIcon: "🔗",
  editButton: "✎",
  removeButton: "⌫",
  confirmButton: "Confirm ⏎",
  onCopyLink: () => {
  },
  inputPlaceholder: "Paste link..."
}, Jc = St(
  I7({}, rae),
  "linkTooltipConfigCtx"
);
Va(yo, {
  displayName: "Config<link-tooltip>",
  group: "LinkTooltip"
});
const NN = Ye("ToggleLink", (n) => () => (e) => {
  const { doc: t, selection: r } = e, i = Ri.type(n);
  return t.rangeHasMark(r.from, r.to, i) ? (n.get(Yc.key).removeLink(r.from, r.to), !0) : (n.get(Yc.key).addLink(r.from, r.to), !0);
}), zd = gg("LINK_PREVIEW");
Va(zd[0], {
  displayName: "PreviewTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
Va(zd[1], {
  displayName: "PreviewTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
const yg = gg("LINK_EDIT");
Va(yg[0], {
  displayName: "EditTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
Va(yg[1], {
  displayName: "EditTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
function gf({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
gf.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const iae = /* @__PURE__ */ $n({
  props: {
    config: {
      type: Object,
      required: !0
    },
    src: {
      type: Object,
      required: !0
    },
    onConfirm: {
      type: Function,
      required: !0
    },
    onCancel: {
      type: Function,
      required: !0
    }
  },
  setup({ config: n, src: e, onConfirm: t, onCancel: r }) {
    const i = Ae(e);
    Tc(e, (l) => {
      i.value = l;
    });
    const s = () => {
      t(i.value);
    }, o = (l) => {
      l.stopPropagation(), l.key === "Enter" && (l.preventDefault(), s()), l.key === "Escape" && (l.preventDefault(), r());
    };
    return () => /* @__PURE__ */ j("div", { class: "link-edit" }, /* @__PURE__ */ j(
      "input",
      {
        class: "input-area",
        placeholder: n.value.inputPlaceholder,
        onKeydown: o,
        onInput: (l) => {
          i.value = l.target.value;
        },
        value: i.value
      }
    ), i.value ? /* @__PURE__ */ j(
      gf,
      {
        class: "button confirm",
        icon: n.value.confirmButton,
        onClick: s
      }
    ) : null);
  }
});
var sae = Object.defineProperty, oae = Object.defineProperties, lae = Object.getOwnPropertyDescriptors, j9 = Object.getOwnPropertySymbols, aae = Object.prototype.hasOwnProperty, cae = Object.prototype.propertyIsEnumerable, RN = (n) => {
  throw TypeError(n);
}, U9 = (n, e, t) => e in n ? sae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, F0 = (n, e) => {
  for (var t in e || (e = {}))
    aae.call(e, t) && U9(n, t, e[t]);
  if (j9)
    for (var t of j9(e))
      cae.call(e, t) && U9(n, t, e[t]);
  return n;
}, K9 = (n, e) => oae(n, lae(e)), PN = (n, e, t) => e.has(n) || RN("Cannot " + t), Jt = (n, e, t) => (PN(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Hs = (n, e, t) => e.has(n) ? RN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), zl = (n, e, t, r) => (PN(n, e, "write to private field"), e.set(n, t), t), vh, Po, _o, Dp, wh, Np, Wl, $5, Rp;
const G9 = {
  from: -1,
  to: -1,
  mark: null
};
class uae {
  constructor(e, t) {
    this.ctx = e, Hs(this, vh), Hs(this, Po), Hs(this, _o, F0({}, G9)), Hs(this, Dp), Hs(this, wh), Hs(this, Np, Ae("")), Hs(this, Wl, () => {
      Jt(this, Po).hide(), this.ctx.update(yo.key, (s) => K9(F0({}, s), {
        mode: "preview"
      })), zl(this, _o, F0({}, G9));
    }), Hs(this, $5, (s) => {
      const o = this.ctx.get(Lt), { from: l, to: a, mark: c } = Jt(this, _o), u = Ri.type(this.ctx), h = Ui.sanitize(s);
      if (c && c.attrs.href === h) {
        Jt(this, Wl).call(this);
        return;
      }
      const f = o.state.tr;
      c && f.removeMark(l, a, c), f.addMark(l, a, u.create({ href: h })), o.dispatch(f), Jt(this, Wl).call(this);
    }), Hs(this, Rp, (s, o, l) => {
      const a = this.ctx.get(Jc.key);
      Jt(this, wh).value = a, Jt(this, Np).value = s, this.ctx.update(yo.key, (u) => K9(F0({}, u), {
        mode: "edit"
      }));
      const c = this.ctx.get(Lt);
      c.dispatch(
        c.state.tr.setSelection(Ee.create(c.state.doc, o, l))
      ), Jt(this, Po).show({
        getBoundingClientRect: () => y1(c, o, l)
      }), requestAnimationFrame(() => {
        var u;
        (u = Jt(this, vh).querySelector("input")) == null || u.focus();
      });
    }), this.update = (s) => {
      const { state: o } = s, { selection: l } = o;
      if (!(l instanceof Ee)) return;
      const { from: a, to: c } = l;
      a === Jt(this, _o).from && c === Jt(this, _o).to || Jt(this, Wl).call(this);
    }, this.destroy = () => {
      Jt(this, Dp).unmount(), Jt(this, Po).destroy(), Jt(this, vh).remove();
    }, this.addLink = (s, o) => {
      zl(this, _o, {
        from: s,
        to: o,
        mark: null
      }), Jt(this, Rp).call(this, "", s, o);
    }, this.editLink = (s, o, l) => {
      zl(this, _o, {
        from: o,
        to: l,
        mark: s
      }), Jt(this, Rp).call(this, s.attrs.href, o, l);
    }, this.removeLink = (s, o) => {
      const l = this.ctx.get(Lt), a = l.state.tr;
      a.removeMark(s, o, Ri.type(this.ctx)), l.dispatch(a), Jt(this, Wl).call(this);
    }, zl(this, wh, Ae(this.ctx.get(Jc.key)));
    const r = document.createElement("div");
    r.className = "milkdown-link-edit";
    const i = ji(iae, {
      config: Jt(this, wh),
      src: Jt(this, Np),
      onConfirm: Jt(this, $5),
      onCancel: Jt(this, Wl)
    });
    i.mount(r), zl(this, Dp, i), zl(this, vh, r), zl(this, Po, new mg({
      content: r,
      debounce: 0,
      shouldShow: () => !1
    })), Jt(this, Po).onHide = () => {
      requestAnimationFrame(() => {
        t.dom.focus({ preventScroll: !0 });
      });
    }, Jt(this, Po).update(t);
  }
}
vh = /* @__PURE__ */ new WeakMap();
Po = /* @__PURE__ */ new WeakMap();
_o = /* @__PURE__ */ new WeakMap();
Dp = /* @__PURE__ */ new WeakMap();
wh = /* @__PURE__ */ new WeakMap();
Np = /* @__PURE__ */ new WeakMap();
Wl = /* @__PURE__ */ new WeakMap();
$5 = /* @__PURE__ */ new WeakMap();
Rp = /* @__PURE__ */ new WeakMap();
var hae = Object.defineProperty, fae = Object.defineProperties, dae = Object.getOwnPropertyDescriptors, Y9 = Object.getOwnPropertySymbols, pae = Object.prototype.hasOwnProperty, mae = Object.prototype.propertyIsEnumerable, J9 = (n, e, t) => e in n ? hae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, gae = (n, e) => {
  for (var t in e || (e = {}))
    pae.call(e, t) && J9(n, t, e[t]);
  if (Y9)
    for (var t of Y9(e))
      mae.call(e, t) && J9(n, t, e[t]);
  return n;
}, yae = (n, e) => fae(n, dae(e));
function bae(n) {
  let e;
  n.update(Yc.key, (t) => yae(gae({}, t), {
    addLink: (r, i) => {
      e?.addLink(r, i);
    },
    editLink: (r, i, s) => {
      e?.editLink(r, i, s);
    },
    removeLink: (r, i) => {
      e?.removeLink(r, i);
    }
  })), n.set(yg.key, {
    view: (t) => (e = new uae(n, t), e)
  });
}
function vae(n, e, t, r, i) {
  let s = { start: -1, end: -1 };
  return t.nodesBetween(r, i, (o, l) => {
    if (s.start > -1) return !1;
    s.start === -1 && n.isInSet(o.marks) && e === o && (s = {
      start: l,
      end: l + Math.max(o.textContent.length, 1)
    });
  }), s;
}
function wae(n, e, t) {
  const r = e.posAtCoords({ left: t.clientX, top: t.clientY });
  if (!r) return;
  const { pos: i } = r, s = e.state.doc.nodeAt(i);
  if (!s) return;
  const o = s.marks.find(
    (a) => a.type === Ri.mark.type(n)
  );
  if (!(!o || !zd.pluginKey()))
    return { show: !0, pos: i, node: s, mark: o };
}
const xae = /* @__PURE__ */ $n({
  props: {
    config: {
      type: Object,
      required: !0
    },
    src: {
      type: Object,
      required: !0
    },
    onEdit: {
      type: Object,
      required: !0
    },
    onRemove: {
      type: Object,
      required: !0
    }
  },
  setup({ config: n, src: e, onEdit: t, onRemove: r }) {
    const i = (l) => {
      l.preventDefault(), l.stopPropagation(), t.value();
    }, s = (l) => {
      l.preventDefault(), l.stopPropagation(), r.value();
    }, o = (l) => {
      l.preventDefault();
      const a = e.value;
      navigator.clipboard && a && navigator.clipboard.writeText(a).then(() => {
        n.value.onCopyLink(a);
      }).catch((c) => console.error(c));
    };
    return () => /* @__PURE__ */ j("div", { class: "link-preview" }, /* @__PURE__ */ j(
      gf,
      {
        class: "button link-icon",
        icon: n.value.linkIcon,
        onClick: o
      }
    ), /* @__PURE__ */ j("a", { href: e.value, target: "_blank", class: "link-display" }, e.value), /* @__PURE__ */ j(
      gf,
      {
        class: "button link-edit-button",
        icon: n.value.editButton,
        onClick: i
      }
    ), /* @__PURE__ */ j(
      gf,
      {
        class: "button link-remove-button",
        icon: n.value.removeButton,
        onClick: s
      }
    ));
  }
});
var _N = (n) => {
  throw TypeError(n);
}, LN = (n, e, t) => e.has(n) || _N("Cannot " + t), ct = (n, e, t) => (LN(n, e, "read from private field"), t ? t.call(n) : e.get(n)), zr = (n, e, t) => e.has(n) ? _N("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Fl = (n, e, t, r) => (LN(n, e, "write to private field"), e.set(n, t), t), jl, Ai, xh, kh, Pp, _p, Lp, Sh, Ch, Bp, zp, Fp, Mh;
class kae {
  constructor(e, t) {
    this.ctx = e, zr(this, jl), zr(this, Ai), zr(this, xh, this.ctx.use(yo.key)), zr(this, kh), zr(this, Pp, Ae("")), zr(this, _p, Ae(() => {
    })), zr(this, Lp, Ae(() => {
    })), zr(this, Sh), zr(this, Ch, !1), zr(this, Bp, ({ mode: r }) => {
      r === "edit" && ct(this, Mh).call(this);
    }), zr(this, zp, () => {
      Fl(this, Ch, !0);
    }), zr(this, Fp, () => {
      Fl(this, Ch, !1);
    }), zr(this, Mh, () => {
      ct(this, Ai).hide(), ct(this, Ai).element.removeEventListener("mouseenter", ct(this, zp)), ct(this, Ai).element.removeEventListener("mouseleave", ct(this, Fp));
    }), this.show = (r, i, s, o) => {
      ct(this, kh).value = this.ctx.get(Jc.key), ct(this, Pp).value = r.attrs.href, ct(this, _p).value = () => {
        this.ctx.get(Yc.key).editLink(r, i, s);
      }, ct(this, Lp).value = () => {
        this.ctx.get(Yc.key).removeLink(i, s), ct(this, Mh).call(this);
      }, ct(this, Ai).show({
        getBoundingClientRect: () => o
      }), ct(this, Ai).element.addEventListener("mouseenter", ct(this, zp)), ct(this, Ai).element.addEventListener("mouseleave", ct(this, Fp));
    }, this.hide = () => {
      ct(this, Ch) || ct(this, Mh).call(this);
    }, this.update = () => {
    }, this.destroy = () => {
      ct(this, Sh).unmount(), ct(this, xh).off(ct(this, Bp)), ct(this, Ai).destroy(), ct(this, jl).remove();
    }, Fl(this, kh, Ae(this.ctx.get(Jc.key))), Fl(this, Sh, ji(xae, {
      config: ct(this, kh),
      src: ct(this, Pp),
      onEdit: ct(this, _p),
      onRemove: ct(this, Lp)
    })), Fl(this, jl, document.createElement("div")), ct(this, jl).className = "milkdown-link-preview", ct(this, Sh).mount(ct(this, jl)), Fl(this, Ai, new mg({
      debounce: 0,
      content: ct(this, jl),
      shouldShow: () => !1
    })), ct(this, Ai).update(t), Fl(this, xh, e.use(yo.key)), ct(this, xh).on(ct(this, Bp));
  }
}
jl = /* @__PURE__ */ new WeakMap();
Ai = /* @__PURE__ */ new WeakMap();
xh = /* @__PURE__ */ new WeakMap();
kh = /* @__PURE__ */ new WeakMap();
Pp = /* @__PURE__ */ new WeakMap();
_p = /* @__PURE__ */ new WeakMap();
Lp = /* @__PURE__ */ new WeakMap();
Sh = /* @__PURE__ */ new WeakMap();
Ch = /* @__PURE__ */ new WeakMap();
Bp = /* @__PURE__ */ new WeakMap();
zp = /* @__PURE__ */ new WeakMap();
Fp = /* @__PURE__ */ new WeakMap();
Mh = /* @__PURE__ */ new WeakMap();
function Sae(n) {
  let e;
  const r = Qm((s, o) => {
    if (!e || !s.hasFocus() || n.get(yo.key).mode === "edit") return;
    const a = wae(n, s, o);
    if (a) {
      const c = s.state.doc.resolve(a.pos), u = vae(
        a.mark,
        a.node,
        s.state.doc,
        c.before(),
        c.after()
      ), h = u.start, f = u.end;
      e.show(
        a.mark,
        h,
        f,
        y1(s, h, f)
      );
      return;
    }
    e.hide();
  }, 50), i = () => {
    setTimeout(() => {
      e?.hide();
    }, 50);
  };
  n.set(zd.key, {
    props: {
      handleDOMEvents: {
        mousemove: r,
        mouseleave: i
      }
    },
    view: (s) => (e = new kae(n, s), e)
  });
}
function Cae(n) {
  Sae(n), bae(n);
}
const Mae = [
  yo,
  Yc,
  Jc,
  zd,
  yg,
  NN
].flat();
var Tae = Object.defineProperty, X9 = Object.getOwnPropertySymbols, Aae = Object.prototype.hasOwnProperty, Oae = Object.prototype.propertyIsEnumerable, Z9 = (n, e, t) => e in n ? Tae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Eae = (n, e) => {
  for (var t in e || (e = {}))
    Aae.call(e, t) && Z9(n, t, e[t]);
  if (X9)
    for (var t of X9(e))
      Oae.call(e, t) && Z9(n, t, e[t]);
  return n;
};
function BN(n, e) {
  return Object.assign(n, {
    meta: Eae({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const Iae = {
  renderLabel: ({ label: n, listType: e, checked: t }) => t == null ? e === "bullet" ? "⦿" : n : t ? "☑" : "□"
}, bg = St(
  Iae,
  "listItemBlockConfigCtx"
);
BN(bg, {
  displayName: "Config<list-item-block>",
  group: "ListItemBlock"
});
function zN({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
zN.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const Dae = /* @__PURE__ */ $n({
  props: {
    label: {
      type: Object,
      required: !0
    },
    checked: {
      type: Object,
      required: !0
    },
    listType: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    onMount: {
      type: Function,
      required: !0
    }
  },
  setup({
    label: n,
    checked: e,
    listType: t,
    config: r,
    readonly: i,
    setAttr: s,
    onMount: o,
    selected: l
  }) {
    const a = (f) => {
      f != null && f instanceof Element && o(f);
    }, c = (f) => {
      f.stopPropagation(), f.preventDefault(), e.value != null && s("checked", !e.value);
    }, u = Da(() => r.renderLabel({
      label: n.value,
      listType: t.value,
      checked: e.value,
      readonly: i.value
    })), h = Da(() => e.value == null ? t.value === "bullet" ? "bullet" : "ordered" : e.value ? "checked" : "unchecked");
    return () => /* @__PURE__ */ j(
      "li",
      {
        class: Hn(
          "list-item",
          l.value && "ProseMirror-selectednode"
        )
      },
      /* @__PURE__ */ j(
        "div",
        {
          class: "label-wrapper",
          onPointerdown: c,
          contenteditable: !1
        },
        /* @__PURE__ */ j(
          zN,
          {
            class: Hn(
              "label",
              i.value && "readonly",
              h.value
            ),
            icon: u.value
          }
        )
      ),
      /* @__PURE__ */ j("div", { class: "children", ref: a })
    );
  }
}), FN = yd(
  Wi.node,
  (n) => (e, t, r) => {
    const i = document.createElement("div");
    i.className = "milkdown-list-item-block";
    const s = document.createElement("div");
    s.setAttribute("data-content-dom", "true"), s.classList.add("content-dom");
    const o = Ae(e.attrs.label), l = Ae(e.attrs.checked), a = Ae(e.attrs.listType), c = Ae(!t.editable), u = n.get(bg.key), h = Ae(!1), f = (k, C) => {
      if (!t.editable) return;
      const M = r();
      M != null && (t.hasFocus() || t.focus(), t.dispatch(t.state.tr.setNodeAttribute(M, k, C)));
    }, d = cu(() => {
      h.value ? i.classList.add("selected") : i.classList.remove("selected");
    });
    let p = 0;
    const g = ji(Dae, {
      label: o,
      checked: l,
      listType: a,
      readonly: c,
      config: u,
      selected: h,
      setAttr: f,
      onMount: (k) => {
        const { anchor: C, head: M } = t.state.selection;
        k.appendChild(s);
        const T = t.state.doc.resolve(C), N = t.state.doc.resolve(M);
        p = requestAnimationFrame(() => {
          if (cancelAnimationFrame(p), !T.doc.eq(t.state.doc)) return;
          const B = new Ee(T, N);
          t.dispatch(t.state.tr.setSelection(B));
        });
      }
    });
    g.mount(i);
    const b = (k) => {
      a.value = k.attrs.listType, o.value = k.attrs.label, l.value = k.attrs.checked, c.value = !t.editable;
    };
    b(e);
    let w = e;
    return {
      dom: i,
      contentDOM: s,
      update: (k) => k.type !== e.type ? !1 : (k.sameMarkup(w) && k.content.eq(w.content) || (w = k, b(k)), !0),
      ignoreMutation: (k) => !i || !s ? !0 : k.type === "selection" ? !1 : s === k.target && k.type === "attributes" ? !0 : !s.contains(k.target),
      selectNode: () => {
        h.value = !0;
      },
      deselectNode: () => {
        h.value = !1;
      },
      destroy: () => {
        d(), g.unmount(), i.remove(), s.remove();
      }
    };
  }
);
BN(FN, {
  displayName: "NodeView<list-item-block>",
  group: "ListItemBlock"
});
const Nae = [
  bg,
  FN
];
var Rae = Object.defineProperty, Q9 = Object.getOwnPropertySymbols, Pae = Object.prototype.hasOwnProperty, _ae = Object.prototype.propertyIsEnumerable, eS = (n, e, t) => e in n ? Rae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Lae = (n, e) => {
  for (var t in e || (e = {}))
    Pae.call(e, t) && eS(n, t, e[t]);
  if (Q9)
    for (var t of Q9(e))
      _ae.call(e, t) && eS(n, t, e[t]);
  return n;
};
function HN(n, e) {
  return Object.assign(n, {
    meta: Lae({
      package: "@milkdown/components"
    }, e)
  }), n;
}
var Bae = Object.defineProperty, tS = Object.getOwnPropertySymbols, zae = Object.prototype.hasOwnProperty, Fae = Object.prototype.propertyIsEnumerable, nS = (n, e, t) => e in n ? Bae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Hae = (n, e) => {
  for (var t in e || (e = {}))
    zae.call(e, t) && nS(n, t, e[t]);
  if (tS)
    for (var t of tS(e))
      Fae.call(e, t) && nS(n, t, e[t]);
  return n;
};
const $ae = {
  renderButton: (n) => {
    switch (n) {
      case "add_row":
        return "+";
      case "add_col":
        return "+";
      case "delete_row":
        return "-";
      case "delete_col":
        return "-";
      case "align_col_left":
        return "left";
      case "align_col_center":
        return "center";
      case "align_col_right":
        return "right";
      case "col_drag_handle":
        return "=";
      case "row_drag_handle":
        return "=";
    }
  }
}, vg = St(
  Hae({}, $ae),
  "tableBlockConfigCtx"
);
HN(vg, {
  displayName: "Config<table-block>",
  group: "TableBlock"
});
function es({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ j(
    "span",
    {
      class: Hn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ui.sanitize(n.trim()));
      }
    }
  );
}
es.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
function $N(n) {
  const {
    dragPreviewRef: e,
    tableWrapperRef: t,
    contentWrapperRef: r,
    yLineHandleRef: i,
    xLineHandleRef: s,
    colHandleRef: o,
    rowHandleRef: l
  } = n, a = e.value;
  if (!a) return;
  const c = t.value;
  if (!c) return;
  const u = r.value;
  if (!u) return;
  const h = u.querySelector("tbody");
  if (!h) return;
  const f = a.querySelector("tbody");
  if (!f) return;
  const d = i.value;
  if (!d) return;
  const p = s.value;
  if (!p) return;
  const m = o.value;
  if (!m) return;
  const g = l.value;
  return g ? {
    preview: a,
    wrapper: c,
    content: u,
    contentRoot: h,
    previewRoot: f,
    yHandle: d,
    xHandle: p,
    colHandle: m,
    rowHandle: g
  } : void 0;
}
function VN(n) {
  for (; n.firstChild; ) n.removeChild(n.firstChild);
}
function qN(n, e, t, r, i) {
  const { width: s, height: o } = r.querySelector("tbody").getBoundingClientRect();
  if (n === "y") {
    const a = r.querySelectorAll("tr")[i];
    if (!a) return;
    t.appendChild(a.cloneNode(!0));
    const c = a.getBoundingClientRect().height;
    Object.assign(e.style, {
      width: `${s}px`,
      height: `${c}px`
    }), e.dataset.show = "true";
    return;
  }
  if (n === "x") {
    const l = r.querySelectorAll("tr");
    let a;
    Array.from(l).forEach((c) => {
      const u = c.children[i];
      if (!u) return;
      a === void 0 && (a = u.getBoundingClientRect().width);
      const h = u.parentElement.cloneNode(!1), f = u.cloneNode(!0);
      h.appendChild(f), t.appendChild(h);
    }), Object.assign(e.style, {
      width: `${a}px`,
      height: `${o}px`
    }), e.dataset.show = "true";
    return;
  }
}
function Vae(n, e) {
  return (t) => {
    jN(n, t, e, (r) => {
      WN("y", t, r, n);
      const { preview: i, content: s, previewRoot: o } = r;
      VN(o);
      const { hoverIndex: l } = n, [a] = l.value;
      qN("y", i, o, s, a);
    });
  };
}
function qae(n, e) {
  return (t) => {
    jN(n, t, e, (r) => {
      WN("x", t, r, n);
      const { preview: i, content: s, previewRoot: o } = r, { hoverIndex: l } = n, [a, c] = l.value;
      VN(o), qN("x", i, o, s, c);
    });
  };
}
function WN(n, e, t, r) {
  const { xHandle: i, yHandle: s, colHandle: o, rowHandle: l, preview: a } = t;
  i.dataset.displayType = n === "y" ? "indicator" : "none", s.dataset.displayType = n === "x" ? "indicator" : "none", n === "y" ? (o.dataset.show = "false", rS(l)) : (l.dataset.show = "false", rS(o));
  const { hoverIndex: c, dragInfo: u } = r, [h, f] = c.value;
  u.value = {
    startCoords: [e.clientX, e.clientY],
    startIndex: n === "y" ? h : f,
    endIndex: n === "y" ? h : f,
    type: n === "y" ? "row" : "col"
  }, a.dataset.direction = n === "y" ? "vertical" : "horizontal";
}
function jN(n, e, t, r) {
  const i = t?.get(Lt);
  if (!i?.editable) return;
  e.stopPropagation(), e.dataTransfer && (e.dataTransfer.effectAllowed = "move");
  const s = $N(n);
  s && requestAnimationFrame(() => {
    r(s);
  });
}
function rS(n) {
  var e;
  (e = n.querySelector(".button-group")) == null || e.setAttribute("data-show", "false");
}
function V5(n, e) {
  for (let t = 0; t < n.childCount; t++)
    if (n.child(t) === e) return t;
  return -1;
}
function Wae(n, e) {
  var t, r, i;
  if (e)
    try {
      const s = e.posAtCoords({
        left: n.clientX,
        top: n.clientY
      });
      if (!s) return;
      const o = s?.inside;
      if (o == null || o < 0) return;
      const l = e.state.doc.resolve(o), a = e.state.doc.nodeAt(o);
      if (!a) return;
      const c = ["table_cell", "table_header"], u = ["table_row", "table_header_row"], h = c.includes(a.type.name) ? a : (t = ys((g) => c.includes(g.type.name))(l)) == null ? void 0 : t.node, f = (r = ys((g) => u.includes(g.type.name))(
        l
      )) == null ? void 0 : r.node, d = (i = ys((g) => g.type.name === "table")(l)) == null ? void 0 : i.node;
      if (!h || !f || !d) return;
      const p = V5(f, h);
      return [V5(d, f), p];
    } catch {
      return;
    }
}
function wg(n, [e, t]) {
  const r = n.value;
  if (!r) return;
  const i = r.querySelectorAll("tr"), s = i[e];
  if (!s) return;
  const o = i[0];
  if (!o) return;
  const l = o.children[t];
  if (!l) return;
  const a = s.children[t];
  if (a)
    return {
      row: s,
      col: a,
      headerCol: l
    };
}
function jae(n, e, t) {
  if (!t || !e) return;
  const { selection: r } = e.state;
  if (!(r instanceof Dt)) return;
  const { $from: i } = r, s = hu(i);
  if (!(!s || s.node !== t)) {
    if (r.isColSelection()) {
      const { $head: o } = r, l = o.index(o.depth - 1);
      D7({
        refs: n,
        index: [0, l],
        before: (a) => {
          var c;
          (c = a.querySelector(".button-group")) == null || c.setAttribute("data-show", "true");
        }
      });
      return;
    }
    if (r.isRowSelection()) {
      const { $head: o } = r, l = ys(
        (c) => c.type.name === "table_row" || c.type.name === "table_header_row"
      )(o);
      if (!l) return;
      const a = V5(s.node, l.node);
      N7({
        refs: n,
        index: [a, 0],
        before: (c) => {
          var u;
          a > 0 && ((u = c.querySelector(".button-group")) == null || u.setAttribute("data-show", "true"));
        }
      });
    }
  }
}
function D7({
  refs: n,
  index: e,
  before: t,
  after: r
}) {
  const { contentWrapperRef: i, colHandleRef: s, hoverIndex: o } = n, l = s.value;
  if (!l) return;
  o.value = e;
  const a = wg(i, e);
  if (!a) return;
  const { headerCol: c } = a;
  l.dataset.show = "true", t && t(l), $i(c, l, { placement: "top" }).then(({ x: u, y: h }) => {
    Object.assign(l.style, {
      left: `${u}px`,
      top: `${h}px`
    }), r && r(l);
  }).catch(console.error);
}
function N7({
  refs: n,
  index: e,
  before: t,
  after: r
}) {
  const { contentWrapperRef: i, rowHandleRef: s, hoverIndex: o } = n, l = s.value;
  if (!l) return;
  o.value = e;
  const a = wg(i, e);
  if (!a) return;
  const { row: c } = a;
  l.dataset.show = "true", t && t(l), $i(c, l, { placement: "left" }).then(({ x: u, y: h }) => {
    Object.assign(l.style, {
      left: `${u}px`,
      top: `${h}px`
    }), r && r(l);
  }).catch(console.error);
}
function UN(n, e, t) {
  const r = t === "x" ? "left" : "top", i = t === "x" ? "right" : "bottom", s = n.length - 1, o = n.findIndex((a, c) => {
    const u = a.getBoundingClientRect(), h = u[r], f = u[i];
    return h <= e && e <= f || c === s && e > f || c === 0 && e < h;
  }), l = n[o];
  return l ? [l, o] : void 0;
}
function Uae(n, e) {
  const t = n.querySelector("tr");
  if (!t) return;
  const r = Array.from(t.children);
  return UN(r, e, "x");
}
function Kae(n, e) {
  const t = Array.from(n.querySelectorAll("tr"));
  return UN(t, e, "y");
}
function Gae(n) {
  return e1((e) => {
    const t = $N(n);
    if (!t) return;
    const { preview: r, content: i, contentRoot: s, xHandle: o, yHandle: l } = t, { dragInfo: a, hoverIndex: c } = n;
    if (r.dataset.show === "false") return;
    const u = wg(n.contentWrapperRef, c.value);
    if (!u || !s.querySelector("tr")) return;
    const f = a.value;
    if (!f || !s.offsetParent) return;
    const d = s.offsetParent.offsetTop, p = s.offsetParent.offsetLeft;
    if (f.type === "col") {
      const m = u.col.getBoundingClientRect().width, { left: g, width: b } = s.getBoundingClientRect(), w = p - g, k = e.clientX + w - m / 2, [C] = f.startCoords, M = C < e.clientX ? "right" : "left";
      r.style.top = `${d}px`;
      const T = k < g + w - 20 ? g + w - 20 : k > g + b + w - m + 20 ? g + b + w - m + 20 : k;
      r.style.left = `${T}px`;
      const N = Uae(s, e.clientX);
      if (N) {
        const [B, $] = N, R = l.getBoundingClientRect().width, V = i.getBoundingClientRect();
        f.endIndex = $, $i(B, l, {
          placement: M === "left" ? "left" : "right",
          middleware: [ml(M === "left" ? -1 * R : 0)]
        }).then(({ x: z }) => {
          l.dataset.show = "true", Object.assign(l.style, {
            height: `${V.height}px`,
            left: `${z}px`,
            top: `${d}px`
          });
        }).catch(console.error);
      }
    } else if (f.type === "row") {
      const m = u.row.getBoundingClientRect().height, { top: g, height: b } = s.getBoundingClientRect(), w = d - g, k = e.clientY + w - m / 2, [C, M] = f.startCoords, T = M < e.clientY ? "down" : "up", N = k < g + w - 20 ? g + w - 20 : k > g + b + w - m + 20 ? g + b + w - m + 20 : k;
      r.style.top = `${N}px`, r.style.left = `${p}px`;
      const B = Kae(s, e.clientY);
      if (B) {
        const [$, R] = B, V = o.getBoundingClientRect().height, z = i.getBoundingClientRect();
        f.endIndex = R, $i($, o, {
          placement: T === "up" ? "top" : "bottom",
          middleware: [ml(T === "up" ? -1 * V : 0)]
        }).then(({ y: ue }) => {
          o.dataset.show = "true", Object.assign(o.style, {
            width: `${z.width}px`,
            top: `${ue}px`
          });
        }).catch(console.error);
      }
    }
  }, 20);
}
function Yae(n, e, t) {
  const { dragPreviewRef: r, yLineHandleRef: i, xLineHandleRef: s, dragInfo: o } = n, l = Vae(n, e), a = qae(n, e), c = () => {
    const f = r.value;
    if (!f || f.dataset.show === "false") return;
    const d = f?.querySelector("tbody");
    for (; d?.firstChild; )
      d?.removeChild(d.firstChild);
    f && (f.dataset.show = "false");
  }, u = () => {
    var f;
    const d = r.value;
    if (!d) return;
    const p = i.value;
    if (!p) return;
    const m = s.value;
    if (!m) return;
    const g = o.value;
    if (!g || !e || d.dataset.show === "false" || !n.colHandleRef.value || !n.rowHandleRef.value || (p.dataset.show = "false", m.dataset.show = "false", g.startIndex === g.endIndex)) return;
    const k = e.get(Me), C = {
      from: g.startIndex,
      to: g.endIndex,
      pos: ((f = t?.()) != null ? f : 0) + 1
    };
    if (g.type === "col") {
      k.call(na.key, {
        pos: C.pos,
        index: g.startIndex
      }), k.call(_v.key, C);
      const M = [0, g.endIndex];
      D7({
        refs: n,
        index: M
      });
    } else {
      k.call(ta.key, {
        pos: C.pos,
        index: g.startIndex
      }), k.call(Pv.key, C);
      const M = [g.endIndex, 0];
      N7({
        refs: n,
        index: M
      });
    }
    requestAnimationFrame(() => {
      e.get(Lt).focus();
    });
  }, h = Gae(n);
  return kd(() => {
    window.addEventListener("dragover", h), window.addEventListener("dragend", c), window.addEventListener("drop", u);
  }), Sd(() => {
    window.removeEventListener("dragover", h), window.removeEventListener("dragend", c), window.removeEventListener("drop", u);
  }), {
    dragRow: l,
    dragCol: a
  };
}
function Jae(n, e, t) {
  const {
    xLineHandleRef: r,
    contentWrapperRef: i,
    colHandleRef: s,
    rowHandleRef: o,
    hoverIndex: l,
    lineHoverIndex: a
  } = n;
  return {
    onAddRow: () => {
      var m, g, b;
      if (!e) return;
      const w = r.value;
      if (!w) return;
      const [k] = a.value;
      if (k < 0 || !e.get(Lt).editable) return;
      const C = Array.from(
        (g = (m = i.value) == null ? void 0 : m.querySelectorAll("tr")) != null ? g : []
      ), M = e.get(Me), T = ((b = t?.()) != null ? b : 0) + 1;
      C.length === k ? (M.call(ta.key, { pos: T, index: k - 1 }), M.call(Hv.key)) : (M.call(ta.key, { pos: T, index: k }), M.call(Fv.key)), M.call(ta.key, { pos: T, index: k }), w.dataset.show = "false";
    },
    onAddCol: () => {
      var m, g, b, w;
      if (!e || !r.value) return;
      const [C, M] = a.value;
      if (M < 0 || !e.get(Lt).editable) return;
      const T = Array.from(
        (b = (g = (m = i.value) == null ? void 0 : m.querySelector("tr")) == null ? void 0 : g.children) != null ? b : []
      ), N = e.get(Me), B = ((w = t?.()) != null ? w : 0) + 1;
      T.length === M ? (N.call(na.key, { pos: B, index: M - 1 }), N.call(zv.key)) : (N.call(na.key, { pos: B, index: M }), N.call(Bv.key)), N.call(na.key, { pos: B, index: M });
    },
    selectCol: () => {
      var m, g;
      if (!e) return;
      const [b, w] = l.value, k = e.get(Me), C = ((m = t?.()) != null ? m : 0) + 1;
      k.call(na.key, { pos: C, index: w });
      const M = (g = s.value) == null ? void 0 : g.querySelector(".button-group");
      M && (M.dataset.show = M.dataset.show === "true" ? "false" : "true");
    },
    selectRow: () => {
      var m, g;
      if (!e) return;
      const [b, w] = l.value, k = e.get(Me), C = ((m = t?.()) != null ? m : 0) + 1;
      k.call(ta.key, { pos: C, index: b });
      const M = (g = o.value) == null ? void 0 : g.querySelector(".button-group");
      M && b > 0 && (M.dataset.show = M.dataset.show === "true" ? "false" : "true");
    },
    deleteSelected: (m) => {
      if (!e || !e.get(Lt).editable) return;
      m.preventDefault(), m.stopPropagation(), e.get(Me).call(Lv.key), requestAnimationFrame(() => {
        e.get(Lt).focus();
      });
    },
    onAlign: (m) => (g) => {
      if (!e || !e.get(Lt).editable) return;
      g.preventDefault(), g.stopPropagation(), e.get(Me).call($v.key, m), requestAnimationFrame(() => {
        e.get(Lt).focus();
      });
    }
  };
}
function Xae(n, e) {
  return e1((t) => {
    if (!e?.editable) return;
    const {
      contentWrapperRef: r,
      yLineHandleRef: i,
      xLineHandleRef: s,
      colHandleRef: o,
      rowHandleRef: l,
      hoverIndex: a,
      lineHoverIndex: c
    } = n, u = i.value;
    if (!u) return;
    const h = s.value;
    if (!h) return;
    const f = r.value;
    if (!f) return;
    const d = l.value;
    if (!d) return;
    const p = o.value;
    if (!p) return;
    const m = Wae(t, e);
    if (!m) return;
    const g = wg(r, m);
    if (!g) return;
    const [b, w] = m, k = g.col.getBoundingClientRect(), C = Math.abs(t.clientX - k.left) < 8, M = Math.abs(k.right - t.clientX) < 8, T = Math.abs(t.clientY - k.top) < 8, N = Math.abs(k.bottom - t.clientY) < 8, B = C || M || T || N, $ = d.querySelector(".button-group"), R = p.querySelector(".button-group");
    if ($ && ($.dataset.show = "false"), R && (R.dataset.show = "false"), B) {
      const V = f.getBoundingClientRect();
      d.dataset.show = "false", p.dataset.show = "false", h.dataset.displayType = "tool", u.dataset.displayType = "tool";
      const z = u.getBoundingClientRect().width, ue = h.getBoundingClientRect().height;
      C || M ? (c.value[1] = C ? w : w + 1, $i(g.col, u, {
        placement: C ? "left" : "right",
        middleware: [ml(C ? -1 * z : 0)]
      }).then(({ x: ie }) => {
        u.dataset.show = "true", Object.assign(u.style, {
          height: `${V.height}px`,
          left: `${ie}px`
        });
      }).catch(console.error)) : u.dataset.show = "false", m[0] !== 0 && (T || N) ? (c.value[0] = T ? b : b + 1, $i(g.row, h, {
        placement: T ? "top" : "bottom",
        middleware: [ml(T ? -1 * ue : 0)]
      }).then(({ y: ie }) => {
        h.dataset.show = "true", Object.assign(h.style, {
          width: `${V.width}px`,
          top: `${ie}px`
        });
      }).catch(console.error)) : h.dataset.show = "false";
      return;
    }
    c.value = [-1, -1], u.dataset.show = "false", h.dataset.show = "false", d.dataset.show = "true", p.dataset.show = "true", N7({
      refs: n,
      index: m
    }), D7({
      refs: n,
      index: m
    }), a.value = m;
  }, 20);
}
function Zae(n) {
  return () => {
    const { rowHandleRef: e, colHandleRef: t, yLineHandleRef: r, xLineHandleRef: i } = n;
    setTimeout(() => {
      const s = e.value;
      if (!s) return;
      const o = t.value;
      if (!o) return;
      const l = r.value;
      if (!l) return;
      const a = i.value;
      a && (s.dataset.show = "false", o.dataset.show = "false", l.dataset.show = "false", a.dataset.show = "false");
    }, 200);
  };
}
function Qae(n, e) {
  const t = Xae(n, e), r = Zae(n);
  return {
    pointerMove: t,
    pointerLeave: r
  };
}
const ece = /* @__PURE__ */ $n({
  props: {
    view: {
      type: Object,
      required: !0
    },
    ctx: {
      type: Object,
      required: !0
    },
    getPos: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    onMount: {
      type: Function,
      required: !0
    },
    node: {
      type: Object,
      required: !0
    }
  },
  setup({ view: n, node: e, ctx: t, getPos: r, config: i, onMount: s }) {
    const o = Ae(), l = (z) => {
      z != null && (z instanceof HTMLElement ? (o.value = z, s(z)) : o.value = void 0);
    }, a = Ae(), c = Ae(), u = Ae(), h = Ae(), f = Ae(), d = Ae(), p = Ae([0, 0]), m = Ae([-1, -1]), g = Ae(), b = {
      dragPreviewRef: d,
      tableWrapperRef: f,
      contentWrapperRef: o,
      yLineHandleRef: h,
      xLineHandleRef: u,
      colHandleRef: a,
      rowHandleRef: c,
      hoverIndex: p,
      lineHoverIndex: m,
      dragInfo: g
    }, { pointerLeave: w, pointerMove: k } = Qae(b, n), { dragRow: C, dragCol: M } = Yae(b, t, r), {
      onAddRow: T,
      onAddCol: N,
      selectCol: B,
      selectRow: $,
      deleteSelected: R,
      onAlign: V
    } = Jae(b, t, r);
    return kd(() => {
      requestAnimationFrame(() => {
        n.editable && jae(b, n, e.value);
      });
    }), () => /* @__PURE__ */ j(
      "div",
      {
        onDragstart: (z) => z.preventDefault(),
        onDragover: (z) => z.preventDefault(),
        onDragleave: (z) => z.preventDefault(),
        onPointermove: k,
        onPointerleave: w
      },
      /* @__PURE__ */ j(
        "button",
        {
          type: "button",
          "data-show": "false",
          contenteditable: "false",
          draggable: "true",
          "data-role": "col-drag-handle",
          class: "handle cell-handle",
          onDragstart: M,
          onClick: B,
          onPointerdown: (z) => z.stopPropagation(),
          onPointermove: (z) => z.stopPropagation(),
          ref: a
        },
        /* @__PURE__ */ j(es, { icon: i.renderButton("col_drag_handle") }),
        /* @__PURE__ */ j(
          "div",
          {
            "data-show": "false",
            class: "button-group",
            onPointermove: (z) => z.stopPropagation()
          },
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: V("left") }, /* @__PURE__ */ j(es, { icon: i.renderButton("align_col_left") })),
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: V("center") }, /* @__PURE__ */ j(es, { icon: i.renderButton("align_col_center") })),
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: V("right") }, /* @__PURE__ */ j(es, { icon: i.renderButton("align_col_right") })),
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: R }, /* @__PURE__ */ j(es, { icon: i.renderButton("delete_col") }))
        )
      ),
      /* @__PURE__ */ j(
        "button",
        {
          type: "button",
          "data-show": "false",
          contenteditable: "false",
          draggable: "true",
          "data-role": "row-drag-handle",
          class: "handle cell-handle",
          onDragstart: C,
          onClick: $,
          onPointerdown: (z) => z.stopPropagation(),
          onPointermove: (z) => z.stopPropagation(),
          ref: c
        },
        /* @__PURE__ */ j(es, { icon: i.renderButton("row_drag_handle") }),
        /* @__PURE__ */ j(
          "div",
          {
            "data-show": "false",
            class: "button-group",
            onPointermove: (z) => z.stopPropagation()
          },
          /* @__PURE__ */ j("button", { type: "button", onPointerdown: R }, /* @__PURE__ */ j(es, { icon: i.renderButton("delete_row") }))
        )
      ),
      /* @__PURE__ */ j("div", { class: "table-wrapper", ref: f }, /* @__PURE__ */ j(
        "div",
        {
          "data-show": "false",
          class: "drag-preview",
          "data-direction": "vertical",
          ref: d
        },
        /* @__PURE__ */ j("table", null, /* @__PURE__ */ j("tbody", null))
      ), /* @__PURE__ */ j(
        "div",
        {
          "data-show": "false",
          contenteditable: "false",
          "data-display-type": "tool",
          "data-role": "x-line-drag-handle",
          class: "handle line-handle",
          onPointermove: (z) => z.stopPropagation(),
          ref: u
        },
        /* @__PURE__ */ j("button", { type: "button", onClick: T, class: "add-button" }, /* @__PURE__ */ j(es, { icon: i.renderButton("add_row") }))
      ), /* @__PURE__ */ j(
        "div",
        {
          "data-show": "false",
          contenteditable: "false",
          "data-display-type": "tool",
          "data-role": "y-line-drag-handle",
          class: "handle line-handle",
          onPointermove: (z) => z.stopPropagation(),
          ref: h
        },
        /* @__PURE__ */ j("button", { type: "button", onClick: N, class: "add-button" }, /* @__PURE__ */ j(es, { icon: i.renderButton("add_col") }))
      ), /* @__PURE__ */ j("table", { ref: l, class: "children" }))
    );
  }
});
var KN = (n) => {
  throw TypeError(n);
}, tce = (n, e, t) => e.has(n) || KN("Cannot " + t), nce = (n, e, t) => e.has(n) ? KN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), rce = (n, e, t) => (tce(n, e, "access private method"), t), q5, GN;
class ice {
  constructor(e, t, r, i) {
    this.ctx = e, this.node = t, this.view = r, this.getPos = i, nce(this, q5);
    const s = document.createElement("div");
    s.className = "milkdown-table-block";
    const o = document.createElement("tbody");
    this.contentDOM = o, o.setAttribute("data-content-dom", "true"), o.classList.add("content-dom"), this.nodeRef = Am(t);
    const l = ji(ece, {
      view: r,
      ctx: e,
      getPos: i,
      config: e.get(vg.key),
      onMount: (a) => {
        a.appendChild(o);
      },
      node: this.nodeRef
    });
    l.mount(s), this.app = l, this.dom = s;
  }
  update(e) {
    return e.type !== this.node.type || e.sameMarkup(this.node) && e.content.eq(this.node.content) ? !1 : (this.node = e, this.nodeRef.value = e, !0);
  }
  stopEvent(e) {
    if (e.type === "drop" || e.type.startsWith("drag")) return !0;
    if (e.type === "mousedown" || e.type === "pointerdown") {
      if (e.target instanceof Element && e.target.closest("button")) return !0;
      const t = e.target;
      if (t instanceof HTMLElement && (t.closest("th") || t.closest("td"))) {
        const r = e;
        return rce(this, q5, GN).call(this, r);
      }
    }
    return !1;
  }
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : e.type === "selection" ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  destroy() {
    this.app.unmount(), this.dom.remove(), this.contentDOM.remove();
  }
}
q5 = /* @__PURE__ */ new WeakSet();
GN = function(n) {
  const e = this.view;
  if (!e.editable) return !1;
  const { state: t, dispatch: r } = e, i = e.posAtCoords({ left: n.clientX, top: n.clientY });
  if (!i) return !1;
  const s = t.doc.resolve(i.inside), o = ys(
    (c) => c.type.name === "table_cell" || c.type.name === "table_header"
  )(s);
  if (!o) return !1;
  if (t.selection instanceof Ee) {
    const c = ys(
      (u) => u.type.name === "table_cell" || u.type.name === "table_header"
    )(t.selection.$from);
    if (c?.node === o.node) return !1;
  }
  const { from: l } = o, a = $e.create(t.doc, l + 1);
  return t.selection.eq(a) ? !1 : (t.selection instanceof Dt ? setTimeout(() => {
    r(t.tr.setSelection(a).scrollIntoView());
  }, 20) : requestAnimationFrame(() => {
    r(t.tr.setSelection(a).scrollIntoView());
  }), !0);
};
const YN = yd(
  Ha.node,
  (n) => (e, t, r) => new ice(n, e, t, r)
);
HN(YN, {
  displayName: "NodeView<table-block>",
  group: "TableBlock"
});
const sce = [vg, YN];
function W5(n) {
  if (!n) return !1;
  if (Array.isArray(n))
    return n.length > 1 ? !1 : W5(n[0]);
  const e = n.content;
  return e ? W5(e) : n.type === "text";
}
const JN = kn((n) => {
  const e = n.get(bs);
  n.update(tf, (i) => ({
    ...i,
    editable: i.editable ?? (() => !0)
  }));
  const t = new en("MILKDOWN_CLIPBOARD");
  return new Ut({
    key: t,
    props: {
      handlePaste: (i, s) => {
        const o = n.get(Qh), l = i.props.editable?.(i.state), { clipboardData: a } = s;
        if (!l || !a || i.state.selection.$from.node().type.spec.code) return !1;
        const u = a.getData("text/plain"), h = a.getData("vscode-editor-data");
        if (h) {
          const w = JSON.parse(h)?.mode;
          if (u && w) {
            const { tr: k } = i.state, C = yV("code_block", e);
            return k.replaceSelectionWith(C.create({ language: w })).setSelection(
              Ee.near(
                k.doc.resolve(Math.max(0, k.selection.from - 2))
              )
            ).insertText(u.replace(/\r\n?/g, `
`)), i.dispatch(k), !0;
          }
        }
        const f = a.getData("text/html");
        if (f.length === 0 && u.length === 0) return !1;
        const d = Sa.fromSchema(e);
        let p;
        if (f.length === 0) {
          const b = o(u);
          if (!b || typeof b == "string") return !1;
          p = Pa.fromSchema(e).serializeFragment(
            b.content
          );
        } else {
          const b = document.createElement("template");
          b.innerHTML = f, p = b.content.cloneNode(!0), b.remove();
        }
        const m = d.parseSlice(p), g = mV(m);
        return g ? (i.dispatch(i.state.tr.replaceSelectionWith(g, !0)), !0) : (i.dispatch(i.state.tr.replaceSelection(m)), !0);
      },
      clipboardTextSerializer: (i) => {
        const s = n.get(xc);
        if (W5(i.content.toJSON()))
          return i.content.textBetween(
            0,
            i.content.size,
            `

`
          );
        const l = e.topNodeType.createAndFill(void 0, i.content);
        return l ? s(l) : "";
      }
    }
  });
});
JN.meta = {
  displayName: "Prose<clipboard>",
  package: "@milkdown/plugin-clipboard"
};
function yu(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-history",
      ...e
    }
  }), n;
}
const R7 = Ye("Undo", () => () => ig);
yu(R7, {
  displayName: "Command<undo>"
});
const P7 = Ye("Redo", () => () => jc);
yu(P7, {
  displayName: "Command<redo>"
});
const _7 = St({}, "historyProviderConfig");
yu(_7, {
  displayName: "Ctx<historyProviderConfig>"
});
const XN = kn(
  (n) => hre(n.get(_7.key))
);
yu(XN, {
  displayName: "Ctx<historyProviderPlugin>"
});
const L7 = Rr("historyKeymap", {
  Undo: {
    shortcuts: "Mod-z",
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(R7.key);
    }
  },
  Redo: {
    shortcuts: ["Mod-y", "Shift-Mod-z"],
    command: (n) => {
      const e = n.get(Me);
      return () => e.call(P7.key);
    }
  }
});
yu(L7.ctx, {
  displayName: "KeymapCtx<history>"
});
yu(L7.shortcuts, {
  displayName: "Keymap<history>"
});
const oce = [
  _7,
  XN,
  L7,
  R7,
  P7
].flat();
function lce(n, e) {
  const { doc: t, selection: r } = n;
  if (!t || !r || !(r instanceof Ee || r instanceof Or))
    return n;
  const { to: i } = r, s = e.type === "space" ? Array(e.size).fill(" ").join("") : "	";
  return n.insertText(s, i);
}
const xg = St(
  { type: "space", size: 2 },
  "indentConfig"
);
xg.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Ctx<indentConfig>"
};
const ZN = nO((n) => ({
  Tab: (e, t) => {
    const r = n.get(xg.key), { tr: i } = e, s = lce(i, r);
    return s.docChanged ? (t?.(s), !0) : !1;
  }
}));
ZN.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Shortcut<indent>"
};
const ace = [xg, ZN];
class QN {
  constructor() {
    this.beforeMountedListeners = [], this.mountedListeners = [], this.updatedListeners = [], this.selectionUpdatedListeners = [], this.markdownUpdatedListeners = [], this.blurListeners = [], this.focusListeners = [], this.destroyListeners = [], this.beforeMount = (e) => (this.beforeMountedListeners.push(e), this), this.mounted = (e) => (this.mountedListeners.push(e), this), this.updated = (e) => (this.updatedListeners.push(e), this);
  }
  /// A getter to get all [subscribers](#interface-subscribers). You should not use this method directly.
  get listeners() {
    return {
      beforeMount: this.beforeMountedListeners,
      mounted: this.mountedListeners,
      updated: this.updatedListeners,
      markdownUpdated: this.markdownUpdatedListeners,
      blur: this.blurListeners,
      focus: this.focusListeners,
      destroy: this.destroyListeners,
      selectionUpdated: this.selectionUpdatedListeners
    };
  }
  /// Subscribe to the markdownUpdated event.
  /// This event will be triggered after the editor state is updated and **the document is changed**.
  /// The second parameter is the current markdown and the third parameter is the previous markdown.
  markdownUpdated(e) {
    return this.markdownUpdatedListeners.push(e), this;
  }
  /// Subscribe to the blur event.
  /// This event will be triggered when the editor is blurred.
  blur(e) {
    return this.blurListeners.push(e), this;
  }
  /// Subscribe to the focus event.
  /// This event will be triggered when the editor is focused.
  focus(e) {
    return this.focusListeners.push(e), this;
  }
  /// Subscribe to the destroy event.
  /// This event will be triggered before the editor is destroyed.
  destroy(e) {
    return this.destroyListeners.push(e), this;
  }
  /// Subscribe to the selectionUpdated event.
  /// This event will be triggered when the editor selection is updated.
  selectionUpdated(e) {
    return this.selectionUpdatedListeners.push(e), this;
  }
}
const Ym = at(
  new QN(),
  "listener"
), cce = new en("MILKDOWN_LISTENER"), eR = (n) => (n.inject(Ym, new QN()), async () => {
  await n.wait(ca);
  const e = n.get(Ym), { listeners: t } = e;
  t.beforeMount.forEach((a) => a(n)), await n.wait(ef);
  const r = n.get(xc);
  let i = null, s = null, o = null;
  const l = new Ut({
    key: cce,
    view: () => ({
      destroy: () => {
        t.destroy.forEach((a) => a(n));
      }
    }),
    props: {
      handleDOMEvents: {
        focus: () => (t.focus.forEach((a) => a(n)), !1),
        blur: () => (t.blur.forEach((a) => a(n)), !1)
      }
    },
    state: {
      init: (a, c) => {
        i = c.doc, s = r(c.doc);
      },
      apply: (a) => {
        const c = a.selection;
        return (!o && c || o && !c.eq(o)) && (t.selectionUpdated.forEach((h) => {
          h(n, c, o);
        }), o = c), !a.docChanged || a.getMeta("addToHistory") === !1 ? void 0 : Qm(() => {
          const { doc: h } = a;
          if (t.updated.length > 0 && i && !i.eq(h) && t.updated.forEach((f) => {
            f(n, h, i);
          }), t.markdownUpdated.length > 0 && i && !i.eq(h)) {
            const f = r(h);
            t.markdownUpdated.forEach((d) => {
              d(n, f, s);
            }), s = f;
          }
          i = h;
        }, 200)();
      }
    }
  });
  n.update(dl, (a) => a.concat(l)), await n.wait(bp), t.mounted.forEach((a) => a(n));
});
eR.meta = {
  package: "@milkdown/plugin-listener",
  displayName: "Listener"
};
const B7 = St(
  {
    shouldAppend: (n) => !(!n || ["heading", "paragraph"].includes(n.type.name)),
    getNode: (n) => n.schema.nodes.paragraph.create()
  },
  "trailingConfig"
);
B7.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Ctx<trailingConfig>"
};
const tR = kn((n) => {
  const e = new en("MILKDOWN_TRAILING"), { shouldAppend: t, getNode: r } = n.get(B7.key), i = new Ut({
    key: e,
    state: {
      init: (s, o) => {
        const l = o.tr.doc.lastChild;
        return t(l, o);
      },
      apply: (s, o, l, a) => {
        if (!s.docChanged) return o;
        const c = s.doc.lastChild;
        return t(c, a);
      }
    },
    appendTransaction: (s, o, l) => {
      const { doc: a, tr: c } = l, u = r?.(l), h = i.getState(l), f = a.content.size;
      if (!(!h || !u))
        return c.insert(f, u);
    }
  });
  return i;
});
tR.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Prose<trailing>"
};
const uce = [B7, tR];
var kt = /* @__PURE__ */ ((n) => (n.CodeMirror = "code-mirror", n.ListItem = "list-item", n.LinkTooltip = "link-tooltip", n.Cursor = "cursor", n.ImageBlock = "image-block", n.BlockEdit = "block-edit", n.Toolbar = "toolbar", n.Placeholder = "placeholder", n.Table = "table", n.Latex = "latex", n))(kt || {});
const hce = {
  cursor: !0,
  "list-item": !0,
  "link-tooltip": !0,
  "image-block": !0,
  "block-edit": !0,
  placeholder: !0,
  toolbar: !0,
  "code-mirror": !0,
  table: !0,
  latex: !0
}, fce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25ZM8.25 16.625C8.0375 16.625 7.85942 16.5531 7.71575 16.4093C7.57192 16.2654 7.5 16.0872 7.5 15.8748C7.5 15.6621 7.57192 15.484 7.71575 15.3405C7.85942 15.1968 8.0375 15.125 8.25 15.125H15.75C15.9625 15.125 16.1406 15.1969 16.2843 15.3408C16.4281 15.4846 16.5 15.6628 16.5 15.8753C16.5 16.0879 16.4281 16.266 16.2843 16.4095C16.1406 16.5532 15.9625 16.625 15.75 16.625H8.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM8.25 8.875C8.0375 8.875 7.85942 8.80308 7.71575 8.65925C7.57192 8.51542 7.5 8.33725 7.5 8.12475C7.5 7.91208 7.57192 7.734 7.71575 7.5905C7.85942 7.44683 8.0375 7.375 8.25 7.375H15.75C15.9625 7.375 16.1406 7.44692 16.2843 7.59075C16.4281 7.73458 16.5 7.91275 16.5 8.12525C16.5 8.33792 16.4281 8.516 16.2843 8.6595C16.1406 8.80317 15.9625 8.875 15.75 8.875H8.25ZM4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25Z"
    />
  </svg>
`, dce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25ZM4.25 16.625C4.0375 16.625 3.85942 16.5531 3.71575 16.4093C3.57192 16.2654 3.5 16.0872 3.5 15.8748C3.5 15.6621 3.57192 15.484 3.71575 15.3405C3.85942 15.1968 4.0375 15.125 4.25 15.125H13.75C13.9625 15.125 14.1406 15.1969 14.2843 15.3408C14.4281 15.4846 14.5 15.6628 14.5 15.8753C14.5 16.0879 14.4281 16.266 14.2843 16.4095C14.1406 16.5532 13.9625 16.625 13.75 16.625H4.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM4.25 8.875C4.0375 8.875 3.85942 8.80308 3.71575 8.65925C3.57192 8.51542 3.5 8.33725 3.5 8.12475C3.5 7.91208 3.57192 7.734 3.71575 7.5905C3.85942 7.44683 4.0375 7.375 4.25 7.375H13.75C13.9625 7.375 14.1406 7.44692 14.2843 7.59075C14.4281 7.73458 14.5 7.91275 14.5 8.12525C14.5 8.33792 14.4281 8.516 14.2843 8.6595C14.1406 8.80317 13.9625 8.875 13.75 8.875H4.25ZM4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25Z"
    />
  </svg>
`, pce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25ZM10.25 8.875C10.0375 8.875 9.85942 8.80308 9.71575 8.65925C9.57192 8.51542 9.5 8.33725 9.5 8.12475C9.5 7.91208 9.57192 7.734 9.71575 7.5905C9.85942 7.44683 10.0375 7.375 10.25 7.375H19.75C19.9625 7.375 20.1406 7.44692 20.2843 7.59075C20.4281 7.73458 20.5 7.91275 20.5 8.12525C20.5 8.33792 20.4281 8.516 20.2843 8.6595C20.1406 8.80317 19.9625 8.875 19.75 8.875H10.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM10.25 16.625C10.0375 16.625 9.85942 16.5531 9.71575 16.4093C9.57192 16.2654 9.5 16.0872 9.5 15.8748C9.5 15.6621 9.57192 15.484 9.71575 15.3405C9.85942 15.1968 10.0375 15.125 10.25 15.125H19.75C19.9625 15.125 20.1406 15.1969 20.2843 15.3408C20.4281 15.4846 20.5 15.6628 20.5 15.8753C20.5 16.0879 20.4281 16.266 20.2843 16.4095C20.1406 16.5532 19.9625 16.625 19.75 16.625H10.25ZM4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25Z"
    />
  </svg>
`, mce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M8.85758 18.625C8.4358 18.625 8.07715 18.4772 7.78163 18.1817C7.48613 17.8862 7.33838 17.5275 7.33838 17.1058V6.8942C7.33838 6.47242 7.48613 6.11377 7.78163 5.81825C8.07715 5.52275 8.4358 5.375 8.85758 5.375H12.1999C13.2191 5.375 14.1406 5.69231 14.9643 6.32693C15.788 6.96154 16.1999 7.81603 16.1999 8.89038C16.1999 9.63779 16.0194 10.2471 15.6585 10.7183C15.2976 11.1894 14.9088 11.5314 14.4922 11.7442C15.005 11.9211 15.4947 12.2708 15.9614 12.7933C16.428 13.3157 16.6614 14.0192 16.6614 14.9038C16.6614 16.182 16.1902 17.1217 15.2479 17.723C14.3056 18.3243 13.3563 18.625 12.3999 18.625H8.85758ZM9.4883 16.6327H12.3191C13.1063 16.6327 13.6627 16.4141 13.9884 15.9769C14.314 15.5397 14.4768 15.1205 14.4768 14.7192C14.4768 14.3179 14.314 13.8987 13.9884 13.4615C13.6627 13.0243 13.0909 12.8057 12.273 12.8057H9.4883V16.6327ZM9.4883 10.875H12.0826C12.6903 10.875 13.172 10.7013 13.5278 10.3539C13.8836 10.0064 14.0615 9.59037 14.0615 9.10575C14.0615 8.59035 13.8733 8.16918 13.497 7.84225C13.1207 7.51533 12.6595 7.35188 12.1133 7.35188H9.4883V10.875Z"
    />
  </svg>
`, gce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_952_6527)">
      <circle cx="12" cy="12" r="3" />
    </g>
    <defs>
      <clipPath id="clip0_952_6527">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, yce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8070)">
      <path
        d="M4 10.5C3.17 10.5 2.5 11.17 2.5 12C2.5 12.83 3.17 13.5 4 13.5C4.83 13.5 5.5 12.83 5.5 12C5.5 11.17 4.83 10.5 4 10.5ZM4 4.5C3.17 4.5 2.5 5.17 2.5 6C2.5 6.83 3.17 7.5 4 7.5C4.83 7.5 5.5 6.83 5.5 6C5.5 5.17 4.83 4.5 4 4.5ZM4 16.5C3.17 16.5 2.5 17.18 2.5 18C2.5 18.82 3.18 19.5 4 19.5C4.82 19.5 5.5 18.82 5.5 18C5.5 17.18 4.83 16.5 4 16.5ZM8 19H20C20.55 19 21 18.55 21 18C21 17.45 20.55 17 20 17H8C7.45 17 7 17.45 7 18C7 18.55 7.45 19 8 19ZM8 13H20C20.55 13 21 12.55 21 12C21 11.45 20.55 11 20 11H8C7.45 11 7 11.45 7 12C7 12.55 7.45 13 8 13ZM7 6C7 6.55 7.45 7 8 7H20C20.55 7 21 6.55 21 6C21 5.45 20.55 5 20 5H8C7.45 5 7 5.45 7 6Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8070">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, bce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 24 24"
  >
    <path
      fill="currentColor"
      d="M9 22a1 1 0 0 1-1-1v-3H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6.1l-3.7 3.71c-.2.19-.45.29-.7.29zm1-6v3.08L13.08 16H20V4H4v12z"
    />
  </svg>
`, vce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1803_1151)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM10.71 16.29C10.32 16.68 9.69 16.68 9.3 16.29L5.71 12.7C5.32 12.31 5.32 11.68 5.71 11.29C6.1 10.9 6.73 10.9 7.12 11.29L10 14.17L16.88 7.29C17.27 6.9 17.9 6.9 18.29 7.29C18.68 7.68 18.68 8.31 18.29 8.7L10.71 16.29Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1803_1151">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, wce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1803_535)">
      <path
        d="M18 19H6C5.45 19 5 18.55 5 18V6C5 5.45 5.45 5 6 5H18C18.55 5 19 5.45 19 6V18C19 18.55 18.55 19 18 19ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1803_535">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, nR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M19.5 8.25l-7.5 7.5-7.5-7.5"
    />
  </svg>
`, rR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1098_15553)">
      <path
        d="M18.3007 5.70973C17.9107 5.31973 17.2807 5.31973 16.8907 5.70973L12.0007 10.5897L7.1107 5.69973C6.7207 5.30973 6.0907 5.30973 5.7007 5.69973C5.3107 6.08973 5.3107 6.71973 5.7007 7.10973L10.5907 11.9997L5.7007 16.8897C5.3107 17.2797 5.3107 17.9097 5.7007 18.2997C6.0907 18.6897 6.7207 18.6897 7.1107 18.2997L12.0007 13.4097L16.8907 18.2997C17.2807 18.6897 17.9107 18.6897 18.3007 18.2997C18.6907 17.9097 18.6907 17.2797 18.3007 16.8897L13.4107 11.9997L18.3007 7.10973C18.6807 6.72973 18.6807 6.08973 18.3007 5.70973Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1098_15553">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, iR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8081)">
      <path
        d="M9.4 16.6L4.8 12L9.4 7.4L8 6L2 12L8 18L9.4 16.6ZM14.6 16.6L19.2 12L14.6 7.4L16 6L22 12L16 18L14.6 16.6Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8081">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, z7 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
  >
    <g clip-path="url(#clip0_1013_1606)">
      <path
        d="M9.00012 16.1998L5.50012 12.6998C5.11012 12.3098 4.49012 12.3098 4.10012 12.6998C3.71012 13.0898 3.71012 13.7098 4.10012 14.0998L8.29012 18.2898C8.68012 18.6798 9.31012 18.6798 9.70012 18.2898L20.3001 7.69982C20.6901 7.30982 20.6901 6.68982 20.3001 6.29982C19.9101 5.90982 19.2901 5.90982 18.9001 6.29982L9.00012 16.1998Z"
        fill="#817567"
      />
    </g>
    <defs>
      <clipPath id="clip0_1013_1606">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, sR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    height="24px"
    viewBox="0 -960 960 960"
    width="24px"
    fill="none"
  >
    <path
      d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z"
    />
  </svg>
`, xce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7900)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M19 13H5C4.45 13 4 12.55 4 12C4 11.45 4.45 11 5 11H19C19.55 11 20 11.45 20 12C20 12.55 19.55 13 19 13Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7900">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, iS = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="16"
    height="16"
    viewBox="0 0 16 16"
  >
    <path
      d="M3.5 9.83366C3.35833 9.83366 3.23961 9.78571 3.14383 9.68983C3.04794 9.59394 3 9.47516 3 9.33349C3 9.19171 3.04794 9.07299 3.14383 8.97733C3.23961 8.88155 3.35833 8.83366 3.5 8.83366H12.5C12.6417 8.83366 12.7604 8.8816 12.8562 8.97749C12.9521 9.07338 13 9.19216 13 9.33383C13 9.4756 12.9521 9.59433 12.8562 9.68999C12.7604 9.78577 12.6417 9.83366 12.5 9.83366H3.5ZM3.5 7.16699C3.35833 7.16699 3.23961 7.11905 3.14383 7.02316C3.04794 6.92727 3 6.80849 3 6.66683C3 6.52505 3.04794 6.40633 3.14383 6.31066C3.23961 6.21488 3.35833 6.16699 3.5 6.16699H12.5C12.6417 6.16699 12.7604 6.21494 12.8562 6.31083C12.9521 6.40671 13 6.52549 13 6.66716C13 6.80894 12.9521 6.92766 12.8562 7.02333C12.7604 7.1191 12.6417 7.16699 12.5 7.16699H3.5Z"
    />
  </svg>
`, F7 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1013_1585)">
      <path
        d="M14.06 9.02L14.98 9.94L5.92 19H5V18.08L14.06 9.02ZM17.66 3C17.41 3 17.15 3.1 16.96 3.29L15.13 5.12L18.88 8.87L20.71 7.04C21.1 6.65 21.1 6.02 20.71 5.63L18.37 3.29C18.17 3.09 17.92 3 17.66 3ZM14.06 6.19L3 17.25V21H6.75L17.81 9.94L14.06 6.19Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1013_1585">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, kce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5553)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM12 17H14V7H10V9H12V17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5553">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Sce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5559)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15H11V13H13C14.1 13 15 12.11 15 11V9C15 7.89 14.1 7 13 7H9V9H13V11H11C9.9 11 9 11.89 9 13V17H15V15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5559">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Cce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5565)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15V13.5C15 12.67 14.33 12 13.5 12C14.33 12 15 11.33 15 10.5V9C15 7.89 14.1 7 13 7H9V9H13V11H11V13H13V15H9V17H13C14.1 17 15 16.11 15 15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5565">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Mce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7757)">
      <path
        d="M19.04 3H5.04004C3.94004 3 3.04004 3.9 3.04004 5V19C3.04004 20.1 3.94004 21 5.04004 21H19.04C20.14 21 21.04 20.1 21.04 19V5C21.04 3.9 20.14 3 19.04 3ZM19.04 19H5.04004V5H19.04V19ZM13.04 17H15.04V7H13.04V11H11.04V7H9.04004V13H13.04V17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7757">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Tce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7760)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15V13C15 11.89 14.1 11 13 11H11V9H15V7H9V13H13V15H9V17H13C14.1 17 15 16.11 15 15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7760">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ace = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7763)">
      <path
        d="M11 17H13C14.1 17 15 16.11 15 15V13C15 11.89 14.1 11 13 11H11V9H15V7H11C9.9 7 9 7.89 9 9V15C9 16.11 9.9 17 11 17ZM11 13H13V15H11V13ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7763">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, j5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8075)">
      <path
        d="M19 5V19H5V5H19ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM14.14 11.86L11.14 15.73L9 13.14L6 17H18L14.14 11.86Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8075">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Oce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M6.29811 18.625C6.04505 18.625 5.83115 18.5375 5.65641 18.3626C5.48166 18.1877 5.39429 17.9736 5.39429 17.7203C5.39429 17.467 5.48166 17.2532 5.65641 17.0788C5.83115 16.9045 6.04505 16.8173 6.29811 16.8173H9.21159L12.452 7.18265H9.53851C9.28545 7.18265 9.07155 7.0952 8.89681 6.9203C8.72206 6.7454 8.63469 6.5313 8.63469 6.278C8.63469 6.02472 8.72206 5.81089 8.89681 5.63652C9.07155 5.46217 9.28545 5.375 9.53851 5.375H16.8847C17.1377 5.375 17.3516 5.46245 17.5264 5.63735C17.7011 5.81225 17.7885 6.02634 17.7885 6.27962C17.7885 6.53293 17.7011 6.74676 17.5264 6.92113C17.3516 7.09548 17.1377 7.18265 16.8847 7.18265H14.2789L11.0385 16.8173H13.6443C13.8973 16.8173 14.1112 16.9048 14.286 17.0797C14.4607 17.2546 14.5481 17.4687 14.5481 17.722C14.5481 17.9752 14.4607 18.1891 14.286 18.3634C14.1112 18.5378 13.8973 18.625 13.6443 18.625H6.29811Z"
    />
  </svg>
`, Ece = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M17.0385 19.5003V16.5388H14.0769V15.0388H17.0385V12.0773H18.5384V15.0388H21.5V16.5388H18.5384V19.5003H17.0385ZM10.8077 16.5388H7.03845C5.78282 16.5388 4.7125 16.0963 3.8275 15.2114C2.9425 14.3266 2.5 13.2564 2.5 12.0009C2.5 10.7454 2.9425 9.67504 3.8275 8.78979C4.7125 7.90454 5.78282 7.46191 7.03845 7.46191H10.8077V8.96186H7.03845C6.1987 8.96186 5.48235 9.25834 4.8894 9.85129C4.29645 10.4442 3.99998 11.1606 3.99998 12.0003C3.99998 12.8401 4.29645 13.5564 4.8894 14.1494C5.48235 14.7423 6.1987 15.0388 7.03845 15.0388H10.8077V16.5388ZM8.25 12.7503V11.2504H15.75V12.7503H8.25ZM21.5 12.0003H20C20 11.1606 19.7035 10.4442 19.1106 9.85129C18.5176 9.25834 17.8013 8.96186 16.9615 8.96186H13.1923V7.46191H16.9615C18.2171 7.46191 19.2875 7.90441 20.1725 8.78939C21.0575 9.67439 21.5 10.7447 21.5 12.0003Z"
    />
  </svg>
`, Ice = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_971_7680)">
      <path
        d="M11 18C11 19.1 10.1 20 9 20C7.9 20 7 19.1 7 18C7 16.9 7.9 16 9 16C10.1 16 11 16.9 11 18ZM9 10C7.9 10 7 10.9 7 12C7 13.1 7.9 14 9 14C10.1 14 11 13.1 11 12C11 10.9 10.1 10 9 10ZM9 4C7.9 4 7 4.9 7 6C7 7.1 7.9 8 9 8C10.1 8 11 7.1 11 6C11 4.9 10.1 4 9 4ZM15 8C16.1 8 17 7.1 17 6C17 4.9 16.1 4 15 4C13.9 4 13 4.9 13 6C13 7.1 13.9 8 15 8ZM15 10C13.9 10 13 10.9 13 12C13 13.1 13.9 14 15 14C16.1 14 17 13.1 17 12C17 10.9 16.1 10 15 10ZM15 16C13.9 16 13 16.9 13 18C13 19.1 13.9 20 15 20C16.1 20 17 19.1 17 18C17 16.9 16.1 16 15 16Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_971_7680">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Dce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8067)">
      <path
        d="M8 7H20C20.55 7 21 6.55 21 6C21 5.45 20.55 5 20 5H8C7.45 5 7 5.45 7 6C7 6.55 7.45 7 8 7ZM20 17H8C7.45 17 7 17.45 7 18C7 18.55 7.45 19 8 19H20C20.55 19 21 18.55 21 18C21 17.45 20.55 17 20 17ZM20 11H8C7.45 11 7 11.45 7 12C7 12.55 7.45 13 8 13H20C20.55 13 21 12.55 21 12C21 11.45 20.55 11 20 11ZM4.5 16H2.5C2.22 16 2 16.22 2 16.5C2 16.78 2.22 17 2.5 17H4V17.5H3.5C3.22 17.5 3 17.72 3 18C3 18.28 3.22 18.5 3.5 18.5H4V19H2.5C2.22 19 2 19.22 2 19.5C2 19.78 2.22 20 2.5 20H4.5C4.78 20 5 19.78 5 19.5V16.5C5 16.22 4.78 16 4.5 16ZM2.5 5H3V7.5C3 7.78 3.22 8 3.5 8C3.78 8 4 7.78 4 7.5V4.5C4 4.22 3.78 4 3.5 4H2.5C2.22 4 2 4.22 2 4.5C2 4.78 2.22 5 2.5 5ZM4.5 10H2.5C2.22 10 2 10.22 2 10.5C2 10.78 2.22 11 2.5 11H3.8L2.12 12.96C2.04 13.05 2 13.17 2 13.28V13.5C2 13.78 2.22 14 2.5 14H4.5C4.78 14 5 13.78 5 13.5C5 13.22 4.78 13 4.5 13H3.2L4.88 11.04C4.96 10.95 5 10.83 5 10.72V10.5C5 10.22 4.78 10 4.5 10Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8067">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, U5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_971_7676)">
      <path
        d="M18 13H13V18C13 18.55 12.55 19 12 19C11.45 19 11 18.55 11 18V13H6C5.45 13 5 12.55 5 12C5 11.45 5.45 11 6 11H11V6C11 5.45 11.45 5 12 5C12.55 5 13 5.45 13 6V11H18C18.55 11 19 11.45 19 12C19 12.55 18.55 13 18 13Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_971_7676">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Nce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7897)">
      <path
        d="M7.17 17C7.68 17 8.15 16.71 8.37 16.26L9.79 13.42C9.93 13.14 10 12.84 10 12.53V8C10 7.45 9.55 7 9 7H5C4.45 7 4 7.45 4 8V12C4 12.55 4.45 13 5 13H7L5.97 15.06C5.52 15.95 6.17 17 7.17 17ZM17.17 17C17.68 17 18.15 16.71 18.37 16.26L19.79 13.42C19.93 13.14 20 12.84 20 12.53V8C20 7.45 19.55 7 19 7H15C14.45 7 14 7.45 14 8V12C14 12.55 14.45 13 15 13H17L15.97 15.06C15.52 15.95 16.17 17 17.17 17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7897">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, K5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M7.30775 20.4997C6.81058 20.4997 6.385 20.3227 6.031 19.9687C5.677 19.6147 5.5 19.1892 5.5 18.692V5.99973H5.25C5.0375 5.99973 4.85942 5.92782 4.71575 5.78398C4.57192 5.64015 4.5 5.46198 4.5 5.24948C4.5 5.03682 4.57192 4.85873 4.71575 4.71523C4.85942 4.57157 5.0375 4.49973 5.25 4.49973H9C9 4.2549 9.08625 4.04624 9.25875 3.87374C9.43108 3.7014 9.63967 3.61523 9.8845 3.61523H14.1155C14.3603 3.61523 14.5689 3.7014 14.7413 3.87374C14.9138 4.04624 15 4.2549 15 4.49973H18.75C18.9625 4.49973 19.1406 4.57165 19.2843 4.71548C19.4281 4.85932 19.5 5.03748 19.5 5.24998C19.5 5.46265 19.4281 5.64073 19.2843 5.78423C19.1406 5.9279 18.9625 5.99973 18.75 5.99973H18.5V18.692C18.5 19.1892 18.323 19.6147 17.969 19.9687C17.615 20.3227 17.1894 20.4997 16.6923 20.4997H7.30775ZM17 5.99973H7V18.692C7 18.7818 7.02883 18.8556 7.0865 18.9132C7.14417 18.9709 7.21792 18.9997 7.30775 18.9997H16.6923C16.7821 18.9997 16.8558 18.9709 16.9135 18.9132C16.9712 18.8556 17 18.7818 17 18.692V5.99973ZM10.1543 16.9997C10.3668 16.9997 10.5448 16.9279 10.6885 16.7842C10.832 16.6404 10.9037 16.4622 10.9037 16.2497V8.74973C10.9037 8.53723 10.8318 8.35907 10.688 8.21523C10.5443 8.07157 10.3662 7.99973 10.1535 7.99973C9.941 7.99973 9.76292 8.07157 9.61925 8.21523C9.47575 8.35907 9.404 8.53723 9.404 8.74973V16.2497C9.404 16.4622 9.47583 16.6404 9.6195 16.7842C9.76333 16.9279 9.94158 16.9997 10.1543 16.9997ZM13.8465 16.9997C14.059 16.9997 14.2371 16.9279 14.3807 16.7842C14.5243 16.6404 14.596 16.4622 14.596 16.2497V8.74973C14.596 8.53723 14.5242 8.35907 14.3805 8.21523C14.2367 8.07157 14.0584 7.99973 13.8458 7.99973C13.6333 7.99973 13.4552 8.07157 13.3115 8.21523C13.168 8.35907 13.0962 8.53723 13.0962 8.74973V16.2497C13.0962 16.4622 13.1682 16.6404 13.312 16.7842C13.4557 16.9279 13.6338 16.9997 13.8465 16.9997Z"
    />
  </svg>
`, oR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
    />
  </svg>
`, Rce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M3.25 13.7404C3.0375 13.7404 2.85938 13.6684 2.71563 13.5246C2.57188 13.3808 2.5 13.2026 2.5 12.99C2.5 12.7774 2.57188 12.5993 2.71563 12.4558C2.85938 12.3122 3.0375 12.2404 3.25 12.2404H20.75C20.9625 12.2404 21.1406 12.3123 21.2843 12.4561C21.4281 12.5999 21.5 12.7781 21.5 12.9907C21.5 13.2033 21.4281 13.3814 21.2843 13.525C21.1406 13.6686 20.9625 13.7404 20.75 13.7404H3.25ZM10.9423 10.2596V6.62495H6.5673C6.2735 6.62495 6.02377 6.52201 5.8181 6.31613C5.61245 6.11026 5.50963 5.86027 5.50963 5.56615C5.50963 5.27205 5.61245 5.02083 5.8181 4.8125C6.02377 4.60417 6.2735 4.5 6.5673 4.5H17.4423C17.7361 4.5 17.9858 4.60294 18.1915 4.80883C18.3971 5.01471 18.5 5.2647 18.5 5.5588C18.5 5.85292 18.3971 6.10413 18.1915 6.31245C17.9858 6.52078 17.7361 6.62495 17.4423 6.62495H13.0673V10.2596H10.9423ZM10.9423 15.7211H13.0673V18.4423C13.0673 18.7361 12.9643 18.9858 12.7584 19.1915C12.5526 19.3971 12.3026 19.5 12.0085 19.5C11.7144 19.5 11.4631 19.3962 11.2548 19.1887C11.0465 18.9811 10.9423 18.7291 10.9423 18.4327V15.7211Z"
    />
  </svg>
`, Pce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8078)">
      <path
        d="M20 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H20C21.1 21 22 20.1 22 19V5C22 3.9 21.1 3 20 3ZM20 5V8H5V5H20ZM15 19H10V10H15V19ZM5 10H8V19H5V10ZM17 19V10H20V19H17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8078">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, _ce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5547)">
      <path
        d="M5 5.5C5 6.33 5.67 7 6.5 7H10.5V17.5C10.5 18.33 11.17 19 12 19C12.83 19 13.5 18.33 13.5 17.5V7H17.5C18.33 7 19 6.33 19 5.5C19 4.67 18.33 4 17.5 4H6.5C5.67 4 5 4.67 5 5.5Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5547">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Lce = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M5.66936 16.3389L9.39244 12.6158C9.54115 12.4671 9.71679 12.3937 9.91936 12.3957C10.1219 12.3976 10.2975 12.4761 10.4463 12.6312C10.5847 12.7823 10.654 12.9585 10.654 13.1599C10.654 13.3613 10.5847 13.5363 10.4463 13.6851L6.32704 17.8197C6.14627 18.0004 5.93538 18.0908 5.69436 18.0908C5.45333 18.0908 5.24243 18.0004 5.06166 17.8197L3.01744 15.7754C2.87899 15.637 2.81136 15.4629 2.81456 15.2533C2.81776 15.0437 2.88859 14.8697 3.02706 14.7312C3.16551 14.5928 3.34008 14.5235 3.55076 14.5235C3.76144 14.5235 3.93494 14.5928 4.07126 14.7312L5.66936 16.3389ZM5.66936 8.72359L9.39244 5.00049C9.54115 4.85177 9.71679 4.77838 9.91936 4.78031C10.1219 4.78223 10.2975 4.86075 10.4463 5.01586C10.5847 5.16691 10.654 5.34314 10.654 5.54454C10.654 5.74592 10.5847 5.92097 10.4463 6.06969L6.32704 10.2043C6.14627 10.3851 5.93538 10.4755 5.69436 10.4755C5.45333 10.4755 5.24243 10.3851 5.06166 10.2043L3.01744 8.16009C2.87899 8.02162 2.81136 7.84759 2.81456 7.63799C2.81776 7.42837 2.88859 7.25433 3.02706 7.11586C3.16551 6.97741 3.34008 6.90819 3.55076 6.90819C3.76144 6.90819 3.93494 6.97741 4.07126 7.11586L5.66936 8.72359ZM13.7597 16.5581C13.5472 16.5581 13.3691 16.4862 13.2253 16.3424C13.0816 16.1986 13.0097 16.0204 13.0097 15.8078C13.0097 15.5952 13.0816 15.4171 13.2253 15.2735C13.3691 15.13 13.5472 15.0582 13.7597 15.0582H20.7597C20.9722 15.0582 21.1503 15.1301 21.2941 15.2739C21.4378 15.4177 21.5097 15.5959 21.5097 15.8085C21.5097 16.0211 21.4378 16.1992 21.2941 16.3427C21.1503 16.4863 20.9722 16.5581 20.7597 16.5581H13.7597ZM13.7597 8.94276C13.5472 8.94276 13.3691 8.87085 13.2253 8.72704C13.0816 8.58324 13.0097 8.40504 13.0097 8.19244C13.0097 7.97985 13.0816 7.80177 13.2253 7.65819C13.3691 7.5146 13.5472 7.44281 13.7597 7.44281H20.7597C20.9722 7.44281 21.1503 7.51471 21.2941 7.65851C21.4378 7.80233 21.5097 7.98053 21.5097 8.19311C21.5097 8.40571 21.4378 8.5838 21.2941 8.72739C21.1503 8.87097 20.9722 8.94276 20.7597 8.94276H13.7597Z"
    />
  </svg>
`, lR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 24 24"
  >
    <path
      fill="currentColor"
      d="M7 19v-.808L13.096 12L7 5.808V5h10v1.25H9.102L14.727 12l-5.625 5.77H17V19z"
    />
  </svg>
`, aR = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    height="24px"
    viewBox="0 -960 960 960"
    width="24px"
  >
    <path
      d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"
    />
  </svg>
`, Bce = {
  [kt.CodeMirror]: {
    theme: VH,
    languages: DH,
    expandIcon: nR,
    searchIcon: oR,
    clearSearchIcon: rR,
    searchPlaceholder: "Search language",
    noResultText: "No result",
    previewToggleIcon: (n) => n ? F7 : aR
  }
}, zce = at([], "FeaturesCtx"), Fce = at({}, "CrepeCtx");
function Hce(n) {
  return n.get("CrepeCtx");
}
function kg(n) {
  return n.use("FeaturesCtx");
}
function Ps(n) {
  return (e) => {
    kg(e).update((t) => t.includes(n) ? t : [...t, n]);
  };
}
function cR(n) {
  return n.$from.parent.type.name === "code_block";
}
function uR(n) {
  var e;
  const t = (e = n.$from.node(n.$from.depth - 1)) == null ? void 0 : e.type;
  return t?.name === "list_item";
}
var hR = (n) => {
  throw TypeError(n);
}, fR = (n, e, t) => e.has(n) || hR("Cannot " + t), Gu = (n, e, t) => (fR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), sS = (n, e, t) => e.has(n) ? hR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), $ce = (n, e, t, r) => (fR(n, e, "write to private field"), e.set(n, t), t), uc, Hp;
class dR {
  constructor() {
    sS(this, uc, []), this.clear = () => ($ce(this, uc, []), this), sS(this, Hp, (e) => {
      const t = {
        group: e,
        addItem: (r, i) => {
          const s = { ...i, key: r };
          return e.items.push(s), t;
        },
        clear: () => (e.items = [], t)
      };
      return t;
    }), this.addGroup = (e, t) => {
      const i = {
        key: e,
        label: t,
        items: []
      };
      return Gu(this, uc).push(i), Gu(this, Hp).call(this, i);
    }, this.getGroup = (e) => {
      const t = Gu(this, uc).find((r) => r.key === e);
      if (!t) throw new Error(`Group with key ${e} not found`);
      return Gu(this, Hp).call(this, t);
    }, this.build = () => Gu(this, uc);
  }
}
uc = /* @__PURE__ */ new WeakMap();
Hp = /* @__PURE__ */ new WeakMap();
function Vce(n, e, t) {
  var r, i, s, o, l, a, c, u, h, f, d, p, m, g, b, w, k, C, M, T, N, B, $, R, V, z, ue, ie, he, Se, ge, ye, ze, I, Ie, Ve, O, dt, Ue, et, Ct, Ft, sn, Gt, _r, E, P, W, Q, J, Y, ae, re, oe, te, De, de, Te, Pe, F, X, pe, _e, je, xt, Rt, Yt, on, wt, pt, Vn, En, El, Il, Fd, To, Hd, $d, ln, _s, Vd, bu, qa, vu, wu, qd, Lr, Ls, xu, ku, Wa, Su, ni, Cu, Mu, Tu, Au, Wd, Re, L, le, Oe, Mt, bn, tn, In, ri, Ao, ja, vn, Ou, Eu, $7, V7, q7, W7, j7, U7, K7;
  const Ua = t && kg(t).get(), AR = Ua?.includes(kt.Latex), OR = Ua?.includes(kt.ImageBlock), ER = Ua?.includes(kt.Table), Iu = new dR();
  if (e?.textGroup !== null) {
    const gt = Iu.addGroup(
      "text",
      (i = (r = e?.textGroup) == null ? void 0 : r.label) != null ? i : "Text"
    );
    ((s = e?.textGroup) == null ? void 0 : s.text) !== null && gt.addItem("text", {
      label: (a = (l = (o = e?.textGroup) == null ? void 0 : o.text) == null ? void 0 : l.label) != null ? a : "Text",
      icon: (h = (u = (c = e?.textGroup) == null ? void 0 : c.text) == null ? void 0 : u.icon) != null ? h : _ce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Os.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt
        });
      }
    }), ((f = e?.textGroup) == null ? void 0 : f.h1) !== null && gt.addItem("h1", {
      label: (m = (p = (d = e?.textGroup) == null ? void 0 : d.h1) == null ? void 0 : p.label) != null ? m : "Heading 1",
      icon: (w = (b = (g = e?.textGroup) == null ? void 0 : g.h1) == null ? void 0 : b.icon) != null ? w : kce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 1
          }
        });
      }
    }), ((k = e?.textGroup) == null ? void 0 : k.h2) !== null && gt.addItem("h2", {
      label: (T = (M = (C = e?.textGroup) == null ? void 0 : C.h2) == null ? void 0 : M.label) != null ? T : "Heading 2",
      icon: ($ = (B = (N = e?.textGroup) == null ? void 0 : N.h2) == null ? void 0 : B.icon) != null ? $ : Sce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 2
          }
        });
      }
    }), ((R = e?.textGroup) == null ? void 0 : R.h3) !== null && gt.addItem("h3", {
      label: (ue = (z = (V = e?.textGroup) == null ? void 0 : V.h3) == null ? void 0 : z.label) != null ? ue : "Heading 3",
      icon: (Se = (he = (ie = e?.textGroup) == null ? void 0 : ie.h3) == null ? void 0 : he.icon) != null ? Se : Cce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 3
          }
        });
      }
    }), ((ge = e?.textGroup) == null ? void 0 : ge.h4) !== null && gt.addItem("h4", {
      label: (I = (ze = (ye = e?.textGroup) == null ? void 0 : ye.h4) == null ? void 0 : ze.label) != null ? I : "Heading 4",
      icon: (O = (Ve = (Ie = e?.textGroup) == null ? void 0 : Ie.h4) == null ? void 0 : Ve.icon) != null ? O : Mce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 4
          }
        });
      }
    }), ((dt = e?.textGroup) == null ? void 0 : dt.h5) !== null && gt.addItem("h5", {
      label: (Ct = (et = (Ue = e?.textGroup) == null ? void 0 : Ue.h5) == null ? void 0 : et.label) != null ? Ct : "Heading 5",
      icon: (Gt = (sn = (Ft = e?.textGroup) == null ? void 0 : Ft.h5) == null ? void 0 : sn.icon) != null ? Gt : Tce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 5
          }
        });
      }
    }), ((_r = e?.textGroup) == null ? void 0 : _r.h6) !== null && gt.addItem("h6", {
      label: (W = (P = (E = e?.textGroup) == null ? void 0 : E.h6) == null ? void 0 : P.label) != null ? W : "Heading 6",
      icon: (Y = (J = (Q = e?.textGroup) == null ? void 0 : Q.h6) == null ? void 0 : J.icon) != null ? Y : Ace,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = jr.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt,
          attrs: {
            level: 6
          }
        });
      }
    }), ((ae = e?.textGroup) == null ? void 0 : ae.quote) !== null && gt.addItem("quote", {
      label: (te = (oe = (re = e?.textGroup) == null ? void 0 : re.quote) == null ? void 0 : oe.label) != null ? te : "Quote",
      icon: (Te = (de = (De = e?.textGroup) == null ? void 0 : De.quote) == null ? void 0 : de.icon) != null ? Te : Nce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = ou.type(Le);
        Fe.call(Dn.key), Fe.call(dh.key, {
          nodeType: mt
        });
      }
    }), ((Pe = e?.textGroup) == null ? void 0 : Pe.divider) !== null && gt.addItem("divider", {
      label: (pe = (X = (F = e?.textGroup) == null ? void 0 : F.divider) == null ? void 0 : X.label) != null ? pe : "Divider",
      icon: (xt = (je = (_e = e?.textGroup) == null ? void 0 : _e.divider) == null ? void 0 : je.icon) != null ? xt : xce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = lu.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: mt
        });
      }
    });
  }
  if (e?.listGroup !== null) {
    const gt = Iu.addGroup(
      "list",
      (Yt = (Rt = e?.listGroup) == null ? void 0 : Rt.label) != null ? Yt : "List"
    );
    ((on = e?.listGroup) == null ? void 0 : on.bulletList) !== null && gt.addItem("bullet-list", {
      label: (Vn = (pt = (wt = e?.listGroup) == null ? void 0 : wt.bulletList) == null ? void 0 : pt.label) != null ? Vn : "Bullet List",
      icon: (Il = (El = (En = e?.listGroup) == null ? void 0 : En.bulletList) == null ? void 0 : El.icon) != null ? Il : yce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Ba.type(Le);
        Fe.call(Dn.key), Fe.call(dh.key, {
          nodeType: mt
        });
      }
    }), ((Fd = e?.listGroup) == null ? void 0 : Fd.orderedList) !== null && gt.addItem("ordered-list", {
      label: ($d = (Hd = (To = e?.listGroup) == null ? void 0 : To.orderedList) == null ? void 0 : Hd.label) != null ? $d : "Ordered List",
      icon: (Vd = (_s = (ln = e?.listGroup) == null ? void 0 : ln.orderedList) == null ? void 0 : _s.icon) != null ? Vd : Dce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = za.type(Le);
        Fe.call(Dn.key), Fe.call(dh.key, {
          nodeType: mt
        });
      }
    }), ((bu = e?.listGroup) == null ? void 0 : bu.taskList) !== null && gt.addItem("task-list", {
      label: (wu = (vu = (qa = e?.listGroup) == null ? void 0 : qa.taskList) == null ? void 0 : vu.label) != null ? wu : "Task List",
      icon: (Ls = (Lr = (qd = e?.listGroup) == null ? void 0 : qd.taskList) == null ? void 0 : Lr.icon) != null ? Ls : Lce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Wi.type(Le);
        Fe.call(Dn.key), Fe.call(dh.key, {
          nodeType: mt,
          attrs: { checked: !1 }
        });
      }
    });
  }
  if (e?.advancedGroup !== null) {
    const gt = Iu.addGroup(
      "advanced",
      (ku = (xu = e?.advancedGroup) == null ? void 0 : xu.label) != null ? ku : "Advanced"
    );
    ((Wa = e?.advancedGroup) == null ? void 0 : Wa.image) !== null && OR && gt.addItem("image", {
      label: (Cu = (ni = (Su = e?.advancedGroup) == null ? void 0 : Su.image) == null ? void 0 : ni.label) != null ? Cu : "Image",
      icon: (Au = (Tu = (Mu = e?.advancedGroup) == null ? void 0 : Mu.image) == null ? void 0 : Tu.icon) != null ? Au : j5,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Y1.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: mt
        });
      }
    }), ((Wd = e?.advancedGroup) == null ? void 0 : Wd.codeBlock) !== null && gt.addItem("code", {
      label: (le = (L = (Re = e?.advancedGroup) == null ? void 0 : Re.codeBlock) == null ? void 0 : L.label) != null ? le : "Code",
      icon: (bn = (Mt = (Oe = e?.advancedGroup) == null ? void 0 : Oe.codeBlock) == null ? void 0 : Mt.icon) != null ? bn : iR,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Cs.type(Le);
        Fe.call(Dn.key), Fe.call(Vs.key, {
          nodeType: mt
        });
      }
    }), ((tn = e?.advancedGroup) == null ? void 0 : tn.table) !== null && ER && gt.addItem("table", {
      label: (Ao = (ri = (In = e?.advancedGroup) == null ? void 0 : In.table) == null ? void 0 : ri.label) != null ? Ao : "Table",
      icon: (Ou = (vn = (ja = e?.advancedGroup) == null ? void 0 : ja.table) == null ? void 0 : vn.icon) != null ? Ou : Pce,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Le.get(Lt);
        Fe.call(Dn.key);
        const { from: IR } = mt.state.selection;
        Fe.call(ph.key, {
          nodeType: Iv(Le, 3, 3)
        }), Fe.call(_O.key, {
          pos: IR
        });
      }
    }), ((Eu = e?.advancedGroup) == null ? void 0 : Eu.math) !== null && AR && gt.addItem("math", {
      label: (q7 = (V7 = ($7 = e?.advancedGroup) == null ? void 0 : $7.math) == null ? void 0 : V7.label) != null ? q7 : "Math",
      icon: (U7 = (j7 = (W7 = e?.advancedGroup) == null ? void 0 : W7.math) == null ? void 0 : j7.icon) != null ? U7 : lR,
      onRun: (Le) => {
        const Fe = Le.get(Me), mt = Cs.type(Le);
        Fe.call(Dn.key), Fe.call(ph.key, {
          nodeType: mt,
          attrs: { language: "LaTex" }
        });
      }
    });
  }
  (K7 = e?.buildMenu) == null || K7.call(e, Iu);
  let Du = Iu.build();
  n && (Du = Du.map((gt) => {
    const Le = gt.items.filter(
      (Fe) => Fe.label.toLowerCase().includes(n.toLowerCase())
    );
    return {
      ...gt,
      items: Le
    };
  }).filter((gt) => gt.items.length > 0));
  const G7 = Du.flatMap((gt) => gt.items);
  return G7.forEach((gt, Le) => {
    Object.assign(gt, { index: Le });
  }), Du.reduce((gt, Le) => {
    const Fe = gt + Le.items.length;
    return Object.assign(Le, {
      range: [gt, Fe]
    }), Fe;
  }, 0), {
    groups: Du,
    size: G7.length
  };
}
const qce = /* @__PURE__ */ $n({
  props: {
    ctx: {
      type: Object,
      required: !0
    },
    show: {
      type: Object,
      required: !0
    },
    filter: {
      type: Object,
      required: !0
    },
    hide: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !1
    }
  },
  setup({ ctx: n, show: e, filter: t, hide: r, config: i }) {
    const s = Ae(), o = Da(() => Vce(t.value, i, n)), l = Ae(0), a = Ae({ x: -999, y: -999 }), c = (m) => {
      const { x: g, y: b } = m;
      a.value = { x: g, y: b };
    };
    Tc([o, e], () => {
      const { size: m } = o.value;
      m === 0 && e.value ? r() : l.value >= m && (l.value = 0);
    });
    const u = (m, g) => {
      const b = l.value, w = typeof m == "function" ? m(b) : m;
      g?.(w), l.value = w;
    }, h = (m) => {
      var g, b;
      const w = (g = s.value) == null ? void 0 : g.querySelector(
        `[data-index="${m}"]`
      ), k = (b = s.value) == null ? void 0 : b.querySelector(".menu-groups");
      !w || !k || (k.scrollTop = w.offsetTop - k.offsetTop);
    }, f = (m) => {
      const g = o.value.groups.flatMap((b) => b.items).at(m);
      g && n && g.onRun(n), r();
    }, d = (m) => {
      const { size: g, groups: b } = o.value;
      if (m.key === "Escape") {
        m.preventDefault(), r?.();
        return;
      }
      if (m.key === "ArrowDown")
        return m.preventDefault(), u(
          (w) => w < g - 1 ? w + 1 : w,
          h
        );
      if (m.key === "ArrowUp")
        return m.preventDefault(), u(
          (w) => w <= 0 ? w : w - 1,
          h
        );
      if (m.key === "ArrowLeft")
        return m.preventDefault(), u((w) => {
          const k = b.find(
            (M) => M.range[0] <= w && M.range[1] > w
          );
          if (!k) return w;
          const C = b[b.indexOf(k) - 1];
          return C ? C.range[1] - 1 : w;
        }, h);
      if (m.key === "ArrowRight")
        return m.preventDefault(), u((w) => {
          const k = b.find(
            (M) => M.range[0] <= w && M.range[1] > w
          );
          if (!k) return w;
          const C = b[b.indexOf(k) + 1];
          return C ? C.range[0] : w;
        }, h);
      m.key === "Enter" && (m.preventDefault(), f(l.value));
    }, p = (m) => (g) => {
      const b = a.value;
      if (!b) return;
      const { x: w, y: k } = g;
      w === b.x && k === b.y || u(m);
    };
    return cu(() => {
      e.value ? window.addEventListener("keydown", d, { capture: !0 }) : window.removeEventListener("keydown", d, { capture: !0 });
    }), Sd(() => {
      window.removeEventListener("keydown", d, { capture: !0 });
    }), () => /* @__PURE__ */ j("div", { ref: s, onPointerdown: (m) => m.preventDefault() }, /* @__PURE__ */ j("nav", { class: "tab-group" }, /* @__PURE__ */ j("ul", null, o.value.groups.map((m) => /* @__PURE__ */ j(
      "li",
      {
        key: m.key,
        onPointerdown: () => u(m.range[0], h),
        class: l.value >= m.range[0] && l.value < m.range[1] ? "selected" : ""
      },
      m.label
    )))), /* @__PURE__ */ j("div", { class: "menu-groups", onPointermove: c }, o.value.groups.map((m) => /* @__PURE__ */ j("div", { key: m.key, class: "menu-group" }, /* @__PURE__ */ j("h6", null, m.label), /* @__PURE__ */ j("ul", null, m.items.map((g) => /* @__PURE__ */ j(
      "li",
      {
        key: g.key,
        "data-index": g.index,
        class: l.value === g.index ? "hover" : "",
        onPointerenter: p(g.index),
        onPointerdown: () => {
          var b, w;
          (w = (b = s.value) == null ? void 0 : b.querySelector(`[data-index="${g.index}"]`)) == null || w.classList.add("active");
        },
        onPointerup: () => {
          var b, w;
          (w = (b = s.value) == null ? void 0 : b.querySelector(`[data-index="${g.index}"]`)) == null || w.classList.remove("active"), f(g.index);
        }
      },
      /* @__PURE__ */ j(Wc, { icon: g.icon }),
      /* @__PURE__ */ j("span", null, g.label)
    )))))));
  }
});
var pR = (n) => {
  throw TypeError(n);
}, mR = (n, e, t) => e.has(n) || pR("Cannot " + t), Mi = (n, e, t) => (mR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Yu = (n, e, t) => e.has(n) ? pR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Hl = (n, e, t, r) => (mR(n, e, "write to private field"), e.set(n, t), t), Th, $p, Vp, js, hc;
const gR = sZ("CREPE_MENU"), H7 = St(
  {
    show: () => {
    },
    hide: () => {
    }
  },
  "menuAPICtx"
);
function Wce(n, e) {
  n.set(gR.key, {
    view: (t) => new jce(n, t, e)
  });
}
class jce {
  constructor(e, t, r) {
    Yu(this, Th), Yu(this, $p), Yu(this, Vp), Yu(this, js), Yu(this, hc, null), this.update = (u) => {
      Mi(this, js).update(u);
    }, this.show = (u) => {
      Hl(this, hc, u), Mi(this, Vp).value = "", Mi(this, js).show();
    }, this.hide = () => {
      Hl(this, hc, null), Mi(this, js).hide();
    }, this.destroy = () => {
      Mi(this, js).destroy(), Mi(this, $p).unmount(), Mi(this, Th).remove();
    };
    const i = document.createElement("div");
    i.classList.add("milkdown-slash-menu");
    const s = Ae(!1), o = Ae("");
    Hl(this, Vp, o);
    const l = this.hide, a = ji(qce, {
      ctx: e,
      config: r,
      show: s,
      filter: o,
      hide: l
    });
    Hl(this, $p, a), a.mount(i), Hl(this, Th, i);
    const c = this;
    Hl(this, js, new oZ({
      content: Mi(this, Th),
      debounce: 20,
      shouldShow(u) {
        if (cR(u.state.selection) || uR(u.state.selection))
          return !1;
        const h = this.getContent(
          u,
          (d) => ["paragraph", "heading"].includes(d.type.name)
        );
        if (h == null || !Uce(u.state.selection))
          return !1;
        const f = Mi(c, hc);
        if (o.value = h.startsWith("/") ? h.slice(1) : h, typeof f == "number") {
          const d = u.state.doc.nodeSize - 2, p = Math.min(f, d);
          return u.state.doc.resolve(p).node() !== u.state.doc.resolve(u.state.selection.from).node() ? (Hl(c, hc, null), !1) : !0;
        }
        return !!h.startsWith("/");
      },
      offset: 10
    })), Mi(this, js).onShow = () => {
      s.value = !0;
    }, Mi(this, js).onHide = () => {
      s.value = !1;
    }, this.update(t), e.set(H7.key, {
      show: (u) => this.show(u),
      hide: () => this.hide()
    });
  }
}
Th = /* @__PURE__ */ new WeakMap();
$p = /* @__PURE__ */ new WeakMap();
Vp = /* @__PURE__ */ new WeakMap();
js = /* @__PURE__ */ new WeakMap();
hc = /* @__PURE__ */ new WeakMap();
function Uce(n) {
  if (!(n instanceof Ee)) return !1;
  const { $head: e } = n, t = e.parent;
  return e.parentOffset === t.content.size;
}
const Kce = /* @__PURE__ */ $n({
  props: {
    onAdd: {
      type: Function,
      required: !0
    },
    addIcon: {
      type: String,
      required: !0
    },
    handleIcon: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = Ae();
    return () => /* @__PURE__ */ j(Ln, null, /* @__PURE__ */ j(
      "div",
      {
        ref: e,
        class: "operation-item",
        onPointerdown: (t) => {
          var r;
          t.preventDefault(), t.stopPropagation(), (r = e.value) == null || r.classList.add("active");
        },
        onPointerup: (t) => {
          var r;
          t.preventDefault(), t.stopPropagation(), (r = e.value) == null || r.classList.remove("active"), n.onAdd();
        }
      },
      /* @__PURE__ */ j(Wc, { icon: n.addIcon })
    ), /* @__PURE__ */ j("div", { class: "operation-item" }, /* @__PURE__ */ j(Wc, { icon: n.handleIcon })));
  }
});
var yR = (n) => {
  throw TypeError(n);
}, bR = (n, e, t) => e.has(n) || yR("Cannot " + t), $l = (n, e, t) => (bR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), H0 = (n, e, t) => e.has(n) ? yR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), $0 = (n, e, t, r) => (bR(n, e, "write to private field"), e.set(n, t), t), qp, Ul, Wp, jp;
class Gce {
  constructor(e, t) {
    H0(this, qp), H0(this, Ul), H0(this, Wp), H0(this, jp), this.update = () => {
      $l(this, Ul).update();
    }, this.destroy = () => {
      $l(this, Ul).destroy(), $l(this, qp).remove(), $l(this, Wp).unmount();
    }, this.onAdd = () => {
      const c = $l(this, jp), u = c.get(Lt);
      u.hasFocus() || u.focus();
      const { state: h, dispatch: f } = u, d = $l(this, Ul).active;
      if (!d) return;
      const m = d.$pos.pos + d.node.nodeSize;
      let g = h.tr.insert(m, Os.type(c).create());
      g = g.setSelection(Ee.near(g.doc.resolve(m))), f(g.scrollIntoView()), $l(this, Ul).hide(), c.get(H7.key).show(g.selection.from);
    };
    var r, i, s;
    $0(this, jp, e);
    const o = document.createElement("div");
    o.classList.add("milkdown-block-handle");
    const l = ji(Kce, {
      onAdd: this.onAdd,
      addIcon: (r = t?.handleAddIcon) != null ? r : U5,
      handleIcon: (i = t?.handleDragIcon) != null ? i : Ice
    });
    l.mount(o), $0(this, Wp, l), $0(this, qp, o);
    const a = (s = t?.blockHandle) != null ? s : {};
    $0(this, Ul, new iY({
      ctx: e,
      content: o,
      getOffset: () => 16,
      getPlacement: ({ active: c, blockDom: u }) => {
        if (c.node.type.name === "heading") return "left";
        let h = 0;
        c.node.descendants((C) => {
          h += C.childCount;
        });
        const f = c.el, d = f.getBoundingClientRect(), p = u.getBoundingClientRect(), m = window.getComputedStyle(f), g = Number.parseInt(m.paddingTop, 10) || 0, b = Number.parseInt(m.paddingBottom, 10) || 0, w = d.height - g - b, k = p.height;
        return h > 2 || k < w ? "left-start" : "left";
      },
      ...a
    })), this.update();
  }
}
qp = /* @__PURE__ */ new WeakMap();
Ul = /* @__PURE__ */ new WeakMap();
Wp = /* @__PURE__ */ new WeakMap();
jp = /* @__PURE__ */ new WeakMap();
function Yce(n, e) {
  n.set(N1.key, {
    filterNodes: (t) => !ys(
      (i) => ["table", "blockquote", "math_inline"].includes(i.type.name)
    )(t)
  }), n.set(_1.key, {
    view: () => new Gce(n, e)
  });
}
const Jce = (n, e) => {
  n.config(Ps(kt.BlockEdit)).config((t) => Yce(t, e)).config((t) => Wce(t, e)).use(H7).use(_1).use(gR);
}, Xce = (n, e = {}) => {
  n.config(Ps(kt.CodeMirror)).config((t) => {
    const { languages: r = [], theme: i } = e, s = [
      tu.of(nD.concat(nre)),
      hse
    ];
    i && s.push(i), e.extensions && s.push(...e.extensions), t.update(Nd.key, (o) => ({
      extensions: s,
      languages: r,
      expandIcon: e.expandIcon || nR,
      searchIcon: e.searchIcon || oR,
      clearSearchIcon: e.clearSearchIcon || rR,
      searchPlaceholder: e.searchPlaceholder || "Search language",
      copyText: e.copyText || "Copy",
      copyIcon: e.copyIcon || sR,
      onCopy: e.onCopy || (() => {
      }),
      noResultText: e.noResultText || "No result",
      renderLanguage: e.renderLanguage || o.renderLanguage,
      renderPreview: e.renderPreview || o.renderPreview,
      previewToggleButton: (l) => {
        var a, c;
        const u = ((a = e.previewToggleIcon) == null ? void 0 : a.call(e, l)) || (l ? F7 : aR), h = ((c = e.previewToggleText) == null ? void 0 : c.call(e, l)) || (l ? "Edit" : "Hide");
        return [u, h].map((f) => f.trim()).join(" ");
      },
      previewLabel: e.previewLabel || o.previewLabel
    }));
  }).use(Tre);
}, Zce = (n, e) => {
  if (n.config(Ps(kt.Cursor)).config((r) => {
    r.update(og.key, () => {
      var i, s;
      return {
        class: "crepe-drop-cursor",
        width: (i = e?.width) != null ? i : 4,
        color: (s = e?.color) != null ? s : !1
      };
    });
  }).use(xse), e?.virtual === !1)
    return;
  const t = kse();
  n.use(kn(() => t));
}, Qce = (n, e) => {
  n.config(Ps(kt.ImageBlock)).config((t) => {
    t.update(lg.key, (r) => {
      var i, s, o, l, a, c;
      return {
        uploadButton: (i = e?.inlineUploadButton) != null ? i : "Upload",
        imageIcon: (s = e?.inlineImageIcon) != null ? s : j5,
        confirmButton: (o = e?.inlineConfirmButton) != null ? o : z7,
        uploadPlaceholderText: (l = e?.inlineUploadPlaceholderText) != null ? l : "or paste link",
        onUpload: (c = (a = e?.inlineOnUpload) != null ? a : e?.onUpload) != null ? c : r.onUpload,
        proxyDomURL: e?.proxyDomURL
      };
    }), t.update(G1.key, (r) => {
      var i, s, o, l, a, c, u, h;
      return {
        uploadButton: (i = e?.blockUploadButton) != null ? i : "Upload file",
        imageIcon: (s = e?.blockImageIcon) != null ? s : j5,
        captionIcon: (o = e?.blockCaptionIcon) != null ? o : bce,
        confirmButton: (l = e?.blockConfirmButton) != null ? l : "Confirm",
        captionPlaceholderText: (a = e?.blockCaptionPlaceholderText) != null ? a : "Write Image Caption",
        uploadPlaceholderText: (c = e?.blockUploadPlaceholderText) != null ? c : "or paste link",
        onUpload: (h = (u = e?.blockOnUpload) != null ? u : e?.onUpload) != null ? h : r.onUpload,
        proxyDomURL: e?.proxyDomURL
      };
    });
  }).use(GZ).use(Lse);
}, eue = Cs.extendSchema((n) => (e) => {
  const t = n(e);
  return {
    ...t,
    toMarkdown: {
      match: t.toMarkdown.match,
      runner: (r, i) => {
        var s, o;
        if (((s = i.attrs.language) != null ? s : "").toLowerCase() === "latex")
          r.addNode(
            "math",
            void 0,
            ((o = i.content.firstChild) == null ? void 0 : o.text) || ""
          );
        else
          return t.toMarkdown.runner(r, i);
      }
    }
  };
}), Ah = "math_inline", id = hn(Ah, () => ({
  group: "inline",
  inline: !0,
  draggable: !0,
  atom: !0,
  attrs: {
    value: {
      default: ""
    }
  },
  parseDOM: [
    {
      tag: `span[data-type="${Ah}"]`,
      getAttrs: (n) => {
        var e;
        return {
          value: (e = n.dataset.value) != null ? e : ""
        };
      }
    }
  ],
  toDOM: (n) => {
    const e = n.attrs.value, t = document.createElement("span");
    return t.dataset.type = Ah, t.dataset.value = e, DN.render(e, t, {
      throwOnError: !1
    }), t;
  },
  parseMarkdown: {
    match: (n) => n.type === "inlineMath",
    runner: (n, e, t) => {
      n.addNode(t, { value: e.value });
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === Ah,
    runner: (n, e) => {
      n.addNode("inlineMath", void 0, e.attrs.value);
    }
  }
})), vR = Ye("ToggleLatex", (n) => () => (e, t) => {
  const {
    hasNode: r,
    pos: i,
    target: s
  } = xT(e, id.type(n)), { selection: o, doc: l, tr: a } = e;
  if (!r) {
    const d = l.textBetween(o.from, o.to);
    let p = a.replaceSelectionWith(
      id.type(n).create({
        value: d
      })
    );
    return t && t(
      p.setSelection($e.create(p.doc, o.from))
    ), !0;
  }
  const { from: c, to: u } = o;
  if (!s || i < 0) return !1;
  let h = a.delete(i, i + 1);
  const f = s.attrs.value;
  return h = h.insertText(f, i), t && t(
    h.setSelection(
      Ee.create(h.doc, c, u + f.length - 1)
    )
  ), !0;
}), oS = gg("INLINE_LATEX"), tue = /* @__PURE__ */ $n({
  props: {
    config: {
      type: Object,
      required: !0
    },
    innerView: {
      type: Object,
      required: !0
    },
    updateValue: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = (r) => {
      if (!(!r || !(r instanceof HTMLElement))) {
        for (; r.firstChild; )
          r.removeChild(r.firstChild);
        n.innerView.value && r.appendChild(n.innerView.value.dom);
      }
    }, t = (r) => {
      r.preventDefault(), n.updateValue.value();
    };
    return () => /* @__PURE__ */ j("div", { class: "container" }, n.innerView && /* @__PURE__ */ j("div", { ref: e }), /* @__PURE__ */ j("button", { onPointerdown: t }, /* @__PURE__ */ j(Wc, { icon: n.config.inlineEditConfirm })));
  }
});
var wR = (n) => {
  throw TypeError(n);
}, xR = (n, e, t) => e.has(n) || wR("Cannot " + t), Sn = (n, e, t) => (xR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), No = (n, e, t) => e.has(n) ? wR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), V0 = (n, e, t, r) => (xR(n, e, "write to private field"), e.set(n, t), t), Oh, fc, Up, Kl, Eh, Ih, G5, Y5;
class nue {
  constructor(e, t, r) {
    this.ctx = e, No(this, Oh), No(this, fc), No(this, Up), No(this, Kl, Am(null)), No(this, Eh, Am(() => {
    })), No(this, Ih), No(this, G5, () => {
      Sn(this, Kl).value && (Sn(this, Kl).value.destroy(), Sn(this, Kl).value = null);
    }), No(this, Y5, (s) => {
      const l = (() => {
        const { selection: a, schema: c } = s.state;
        if (a.empty || !(a instanceof $e)) return !1;
        const u = a.node;
        if (u.type.name !== Ah) return !1;
        const h = a.from, f = c.nodes.paragraph.create(
          null,
          c.text(u.attrs.value)
        ), d = new rb(Sn(this, Up), {
          state: Zl.create({
            doc: f,
            schema: new YM({
              nodes: {
                doc: {
                  content: "block+"
                },
                paragraph: {
                  content: "inline*",
                  group: "block",
                  parseDOM: [{ tag: "p" }],
                  toDOM() {
                    return ["p", 0];
                  }
                },
                text: {
                  group: "inline"
                }
              }
            }),
            plugins: [
              hA({
                "Mod-z": ig,
                "Mod-Z": jc,
                "Mod-y": jc,
                Enter: () => (Sn(this, Eh).value(), !0)
              })
            ]
          })
        });
        return Sn(this, Kl).value = d, Sn(this, Eh).value = () => {
          const { tr: p } = s.state;
          p.setNodeAttribute(h, "value", d.state.doc.textContent), s.dispatch(p), requestAnimationFrame(() => {
            s.focus();
          });
        }, !0;
      })();
      return l || Sn(this, G5).call(this), l;
    }), this.update = (s, o) => {
      Sn(this, fc).update(s, o);
    }, this.destroy = () => {
      Sn(this, Ih).unmount(), Sn(this, fc).destroy(), Sn(this, Oh).remove();
    };
    const i = document.createElement("div");
    i.className = "milkdown-latex-inline-edit", V0(this, Oh, i), V0(this, Ih, ji(tue, {
      config: r,
      innerView: Sn(this, Kl),
      updateValue: Sn(this, Eh)
    })), Sn(this, Ih).mount(i), V0(this, fc, new mg({
      debounce: 0,
      content: Sn(this, Oh),
      shouldShow: Sn(this, Y5),
      offset: 10,
      floatingUIOptions: {
        placement: "bottom"
      }
    })), Sn(this, fc).update(t), V0(this, Up, document.createElement("div"));
  }
}
Oh = /* @__PURE__ */ new WeakMap();
fc = /* @__PURE__ */ new WeakMap();
Up = /* @__PURE__ */ new WeakMap();
Kl = /* @__PURE__ */ new WeakMap();
Eh = /* @__PURE__ */ new WeakMap();
Ih = /* @__PURE__ */ new WeakMap();
G5 = /* @__PURE__ */ new WeakMap();
Y5 = /* @__PURE__ */ new WeakMap();
const rue = Qn(
  (n) => oV(/(?:\$)([^$]+)(?:\$)$/, id.type(n), {
    getAttr: (e) => {
      var t;
      return {
        value: (t = e[1]) != null ? t : ""
      };
    }
  })
), iue = Qn(
  (n) => D3(/^\$\$[\s\n]$/, Cs.type(n), () => ({
    language: "LaTeX"
  }))
), sue = As(
  "remarkMath",
  () => Kle
);
function oue(n) {
  return Sl(
    n,
    "math",
    (e, t, r) => {
      const { value: i } = e, s = {
        type: "code",
        lang: "LaTeX",
        value: i
      };
      r.children.splice(t, 1, s);
    }
  );
}
const lue = As(
  "remarkMathBlock",
  () => () => oue
), aue = (n, e) => {
  n.config(Ps(kt.Latex)).config((t) => {
    if (!kg(t).get().includes(kt.CodeMirror))
      throw new Error("You need to enable CodeMirror to use LaTeX feature");
    t.update(Nd.key, (s) => ({
      ...s,
      renderPreview: (o, l) => {
        if (o.toLowerCase() === "latex" && l.length > 0)
          return cue(l, e?.katexOptions);
        const a = s.renderPreview;
        return a(o, l);
      }
    })), t.set(oS.key, {
      view: (s) => {
        var o;
        return new nue(t, s, {
          inlineEditConfirm: (o = e?.inlineEditConfirm) != null ? o : z7,
          ...e
        });
      }
    });
  }).use(sue).use(lue).use(id).use(oS).use(rue).use(iue).use(eue).use(vR);
};
function cue(n, e) {
  return DN.renderToString(n, {
    ...e,
    throwOnError: !1,
    displayMode: !0
  });
}
const uue = (n, e) => {
  n.config(Ps(kt.LinkTooltip)).config(Cae).config((t) => {
    t.update(Jc.key, (r) => {
      var i, s, o, l, a, c;
      return {
        ...r,
        linkIcon: (i = e?.linkIcon) != null ? i : sR,
        editButton: (s = e?.editButton) != null ? s : F7,
        removeButton: (o = e?.removeButton) != null ? o : K5,
        confirmButton: (l = e?.confirmButton) != null ? l : z7,
        inputPlaceholder: (a = e?.inputPlaceholder) != null ? a : "Paste link...",
        onCopyLink: (c = e?.onCopyLink) != null ? c : (() => {
        })
      };
    });
  }).use(Mae);
};
function hue(n, e) {
  n.set(bg.key, {
    renderLabel: ({ label: t, listType: r, checked: i }) => {
      var s, o, l;
      return i == null ? r === "bullet" ? (s = e?.bulletIcon) != null ? s : gce : t : i ? (o = e?.checkBoxCheckedIcon) != null ? o : vce : (l = e?.checkBoxUncheckedIcon) != null ? l : wce;
    }
  });
}
const fue = (n, e) => {
  n.config(Ps(kt.ListItem)).config((t) => hue(t, e)).use(Nae);
};
function due(n) {
  var e;
  return n.childCount <= 1 && !((e = n.firstChild) != null && e.content.size);
}
function pue(n, e) {
  const { selection: t } = n;
  if (!t.empty) return null;
  const r = t.$anchor, i = r.parent;
  if (i.content.size > 0 || ys((l) => l.type.name === "table")(r)) return null;
  const o = r.before();
  return mn.node(o, o + i.nodeSize, {
    class: "crepe-placeholder",
    "data-placeholder": e
  });
}
const J5 = St(
  {
    text: "Please enter...",
    mode: "block"
  },
  "placeholderConfigCtx"
), mue = kn((n) => new Ut({
  key: new en("CREPE_PLACEHOLDER"),
  props: {
    decorations: (e) => {
      var t;
      if (Hce(n).readonly) return null;
      const i = n.get(J5.key);
      if (i.mode === "doc" && !due(e.doc) || cR(e.selection) || uR(e.selection))
        return null;
      const s = (t = i.text) != null ? t : "Please enter...", o = pue(e, s);
      return o ? Ot.create(e.doc, [o]) : null;
    }
  }
})), gue = (n, e) => {
  n.config(Ps(kt.Placeholder)).config((t) => {
    e && t.update(J5.key, (r) => ({
      ...r,
      ...e
    }));
  }).use(mue).use(J5);
}, yue = (n, e) => {
  n.config(Ps(kt.Table)).config((t) => {
    t.update(vg.key, (r) => ({
      ...r,
      renderButton: (i) => {
        var s, o, l, a, c, u, h, f, d;
        switch (i) {
          case "add_row":
            return (s = e?.addRowIcon) != null ? s : U5;
          case "add_col":
            return (o = e?.addColIcon) != null ? o : U5;
          case "delete_row":
            return (l = e?.deleteRowIcon) != null ? l : K5;
          case "delete_col":
            return (a = e?.deleteColIcon) != null ? a : K5;
          case "align_col_left":
            return (c = e?.alignLeftIcon) != null ? c : dce;
          case "align_col_center":
            return (u = e?.alignCenterIcon) != null ? u : fce;
          case "align_col_right":
            return (h = e?.alignRightIcon) != null ? h : pce;
          case "col_drag_handle":
            return (f = e?.colDragHandleIcon) != null ? f : iS;
          case "row_drag_handle":
            return (d = e?.rowDragHandleIcon) != null ? d : iS;
        }
      }
    }));
  }).use(sce);
};
function bue(n, e) {
  var t, r, i, s, o, l, a;
  const c = new dR();
  c.addGroup("formatting", "Formatting").addItem("bold", {
    icon: (t = n?.boldIcon) != null ? t : mce,
    active: (d) => d.get(Me).call(rc.key, su.type(d)),
    onRun: (d) => {
      d.get(Me).call(B1.key);
    }
  }).addItem("italic", {
    icon: (r = n?.italicIcon) != null ? r : Oce,
    active: (d) => d.get(Me).call(
      rc.key,
      _a.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(L1.key);
    }
  }).addItem("strikethrough", {
    icon: (i = n?.strikethroughIcon) != null ? i : Rce,
    active: (d) => d.get(Me).call(
      rc.key,
      uu.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(X1.key);
    }
  });
  const u = c.addGroup("function", "Function");
  u.addItem("code", {
    icon: (s = n?.codeIcon) != null ? s : iR,
    active: (d) => d.get(Me).call(
      rc.key,
      eo.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(z1.key);
    }
  });
  const h = e && kg(e).get();
  return h?.includes(kt.Latex) && u.addItem("latex", {
    icon: (o = n?.latexIcon) != null ? o : lR,
    active: (d) => d.get(Me).call(
      PO.key,
      id.type(d)
    ),
    onRun: (d) => {
      d.get(Me).call(vR.key);
    }
  }), u.addItem("link", {
    icon: (l = n?.linkIcon) != null ? l : Ece,
    active: (d) => d.get(Me).call(rc.key, Ri.type(d)),
    onRun: (d) => {
      d.get(Me).call(NN.key);
    }
  }), (a = n?.buildToolbar) == null || a.call(n, c), c.build();
}
const vue = /* @__PURE__ */ $n({
  props: {
    ctx: {
      type: Object,
      required: !0
    },
    hide: {
      type: Function,
      required: !0
    },
    show: {
      type: Object,
      required: !0
    },
    selection: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !1
    }
  },
  setup(n) {
    const { ctx: e, config: t } = n, r = (o) => (l) => {
      l.preventDefault(), e && o(e);
    };
    function i(o) {
      return n.selection.value, e.get(Xy).status !== xm.Created ? !1 : o(e);
    }
    const s = Da(() => bue(t, e));
    return () => /* @__PURE__ */ j(Ln, null, s.value.map((o) => o.items.map((l) => /* @__PURE__ */ j(
      "button",
      {
        type: "button",
        class: Hn(
          "toolbar-item",
          e && i(l.active) && "active"
        ),
        onPointerdown: r(l.onRun)
      },
      /* @__PURE__ */ j(Wc, { icon: l.icon })
    ))).reduce((o, l, a) => (a === 0 ? o.push(...l) : o.push(/* @__PURE__ */ j("div", { class: "divider" }), ...l), o), []));
  }
});
var kR = (n) => {
  throw TypeError(n);
}, SR = (n, e, t) => e.has(n) || kR("Cannot " + t), Fr = (n, e, t) => (SR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Ju = (n, e, t) => e.has(n) ? kR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), q0 = (n, e, t, r) => (SR(n, e, "write to private field"), e.set(n, t), t), Lo, Dh, Kp, Nh, Rh;
const lS = gg("CREPE_TOOLBAR");
class wue {
  constructor(e, t, r) {
    Ju(this, Lo), Ju(this, Dh), Ju(this, Kp), Ju(this, Nh), Ju(this, Rh, Ae(!1)), this.update = (o, l) => {
      Fr(this, Lo).update(o, l), Fr(this, Nh).value = o.state.selection;
    }, this.destroy = () => {
      Fr(this, Lo).destroy(), Fr(this, Kp).unmount(), Fr(this, Dh).remove();
    }, this.hide = () => {
      Fr(this, Lo).hide();
    };
    const i = document.createElement("div");
    i.className = "milkdown-toolbar", q0(this, Nh, Am(t.state.selection));
    const s = ji(vue, {
      ctx: e,
      hide: this.hide,
      config: r,
      selection: Fr(this, Nh),
      show: Fr(this, Rh)
    });
    s.mount(i), q0(this, Dh, i), q0(this, Kp, s), q0(this, Lo, new mg({
      content: Fr(this, Dh),
      debounce: 20,
      offset: 10,
      shouldShow(o) {
        const { doc: l, selection: a } = o.state, { empty: c, from: u, to: h } = a, f = !l.textBetween(u, h).length && a instanceof Ee, d = !(a instanceof Ee), p = o.dom.getRootNode().activeElement, m = i.contains(p), g = !o.hasFocus() && !m, b = !o.editable;
        return !(g || d || c || f || b);
      }
    })), Fr(this, Lo).onShow = () => {
      Fr(this, Rh).value = !0;
    }, Fr(this, Lo).onHide = () => {
      Fr(this, Rh).value = !1;
    }, this.update(t);
  }
}
Lo = /* @__PURE__ */ new WeakMap();
Dh = /* @__PURE__ */ new WeakMap();
Kp = /* @__PURE__ */ new WeakMap();
Nh = /* @__PURE__ */ new WeakMap();
Rh = /* @__PURE__ */ new WeakMap();
const xue = (n, e) => {
  n.config(Ps(kt.Toolbar)).config((t) => {
    t.set(lS.key, {
      view: (r) => new wue(t, r, e)
    });
  }).use(lS);
};
function kue(n, e, t) {
  switch (n) {
    case kt.CodeMirror:
      return Xce(e, t);
    case kt.ListItem:
      return fue(e, t);
    case kt.LinkTooltip:
      return uue(e, t);
    case kt.ImageBlock:
      return Qce(e, t);
    case kt.Cursor:
      return Zce(e, t);
    case kt.BlockEdit:
      return Jce(e, t);
    case kt.Placeholder:
      return gue(e, t);
    case kt.Toolbar:
      return xue(e, t);
    case kt.Table:
      return yue(e, t);
    case kt.Latex:
      return aue(e, t);
  }
}
var CR = (n) => {
  throw TypeError(n);
}, MR = (n, e, t) => e.has(n) || CR("Cannot " + t), Hr = (n, e, t) => (MR(n, e, "read from private field"), t ? t.call(n) : e.get(n)), v4 = (n, e, t) => e.has(n) ? CR("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), w4 = (n, e, t, r) => (MR(n, e, "write to private field"), e.set(n, t), t), $r, Gp, Ph;
class Sue {
  /// The constructor of the crepe builder.
  /// You can pass configs to the builder to configure the editor.
  constructor({ root: e, defaultValue: t = "" } = {}) {
    v4(this, $r), v4(this, Gp), v4(this, Ph, !0), this.addFeature = (i, s) => (i(Hr(this, $r), s), this), this.create = () => Hr(this, $r).create(), this.destroy = () => Hr(this, $r).destroy(), this.setReadonly = (i) => (w4(this, Ph, !i), Hr(this, $r).action((s) => {
      Hr(this, $r).status === xm.Created && s.get(Lt).setProps({
        editable: () => !i
      });
    }), this), this.getMarkdown = () => Hr(this, $r).action(dG()), this.on = (i) => Hr(this, $r).status !== xm.Created ? (Hr(this, $r).config((s) => {
      const o = s.get(Ym);
      i(o);
    }), this) : (Hr(this, $r).action((s) => {
      const o = s.get(Ym);
      i(o);
    }), this);
    var r;
    w4(this, Gp, (r = typeof e == "string" ? document.querySelector(e) : e) != null ? r : document.body), w4(this, $r, ib.make().config((i) => {
      i.inject(Fce, this), i.inject(zce, []);
    }).config((i) => {
      i.set(vp, Hr(this, Gp)), i.set(gp, t), i.set(tf, {
        editable: () => Hr(this, Ph)
      }), i.update(xg.key, (s) => ({
        ...s,
        size: 4
      }));
    }).use(EY).use(eR).use(oce).use(ace).use(uce).use(JN).use(Ute));
  }
  /// Get the milkdown editor instance.
  get editor() {
    return Hr(this, $r);
  }
  /// Get the readonly state of the editor.
  get readonly() {
    return !Hr(this, Ph);
  }
}
$r = /* @__PURE__ */ new WeakMap();
Gp = /* @__PURE__ */ new WeakMap();
Ph = /* @__PURE__ */ new WeakMap();
class TR extends Sue {
  /// The constructor of the crepe editor.
  /// You can pass configs to the editor to configure the editor.
  /// Calling the constructor will not create the editor, you need to call `create` to create the editor.
  constructor({
    features: e = {},
    featureConfigs: t = {},
    ...r
  } = {}) {
    super(r);
    const i = mL(t, Bce);
    Object.entries({
      ...hce,
      ...e
    }).filter(([, o]) => o).map(([o]) => o).forEach((o) => {
      const l = i[o];
      kue(o, this.editor, l);
    });
  }
}
TR.Feature = kt;
const Cue = (n, e) => new TR({
  root: n,
  defaultValue: e
}), Mue = async (n, e = () => {
}) => {
  await n.create(), n.on((t) => {
    t.updated(e);
  });
}, Tue = async (n) => {
  await n.destroy();
}, Aue = (n) => n.getMarkdown(), Kue = {
  createEditor: Cue,
  create: Mue,
  destroy: Tue,
  getMarkdown: Aue
};
export {
  Xl as A,
  jt as B,
  gD as C,
  q as D,
  Ce as E,
  fy as F,
  xH as G,
  yL as H,
  Zt as I,
  BF as J,
  Kue as K,
  HF as L,
  Eue as N,
  DS as P,
  si as T,
  hy as a,
  jue as b,
  Hue as c,
  nie as d,
  Fn as e,
  XF as f,
  zue as g,
  Fue as h,
  fM as i,
  $ue as j,
  Uue as k,
  G as l,
  Qr as m,
  st as n,
  n3 as o,
  Due as p,
  Bt as q,
  JF as r,
  NF as s,
  U as t,
  wl as u,
  tu as v,
  ci as w,
  uM as x,
  eu as y,
  o1 as z
};
